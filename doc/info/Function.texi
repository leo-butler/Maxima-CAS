@menu
* Introduction to Function Definition::  
* Function::                    
* Macros::                      
* Definitions for Function Definition::  
@end menu

@node Introduction to Function Definition, Function, Function Definition, Function Definition
@section Introduction to Function Definition

@node Function, Macros, Introduction to Function Definition, Function Definition
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@section Function
To define a function in Maxima you use the := operator.
E.g.

@example
f(x) := sin(x)
@end example

@noindent
defines a function @code{f}.
Anonmyous functions may also be created using @code{lambda}.
For example

@example
lambda ([i, j], ...)
@end example

@noindent
can be used instead of @code{f}
where

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@noindent
would return a list with 1 added to each term.

You may also define a function with a variable number of arguments,
by having a final argument which is assigned to a list of the extra
arguments:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

The right hand side of a function is an expression.  Thus
if you want a sequence of expressions, you do

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

and the value of @var{exprn} is what is returned by the function.

If you wish to make a @code{return} from some expression inside the
function then you must use @code{block} and @code{return}.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

is itelf an expression, and so could take the place of the
right hand side of a function definition.  Here it may happen
that the return happens earlier than the last expression.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
The first @code{[]} in the block, may contain a list of variables and
variable assignments, such as @code{[a: 3, b, c: []]}, which would cause the
three variables @code{a},@code{b},and @code{c} to not refer to their
global values, but rather have these special values for as long as the
code executes inside the @code{block}, or inside functions called from
inside the @code{block}.  This is called @i{dynamic} binding, since the
variables last from the start of the block to the time it exits.  Once
you return from the @code{block}, or throw out of it, the old values (if
any) of the variables will be restored.   It is certainly a good idea
to protect your variables in this way.   Note that the assignments
in the block variables, are done in parallel.   This means, that if
you had used @code{c: a} in the above, the value of @code{c} would
have been the value of @code{a} at the time you just entered the block,
but before @code{a} was bound.   Thus doing something like

@example
block ([a: a], expr1, ... a: a+3, ..., exprn)
@end example

will protect the external value of @code{a} from being altered, but
would let you access what that value was.   Thus the right hand
side of the assignments, is evaluated in the entering context, before
any binding occurs.
Using just @code{block ([x], ...} would cause the @code{x} to have itself
as value, just as if it would have if you entered a fresh @b{Maxima}
session.

The actual arguments to a function are treated in exactly same way as
the variables in a block.  Thus in

@example
f(x) := (expr1, ..., exprn);
@end example

and

@example
f(1);
@end example

we would have a similar context for evaluation of the expressions
as if we had done

@example
block ([x: 1], expr1, ..., exprn)
@end example

Inside functions, when the right hand side of a definition,
may be computed at runtime, it is useful to use @code{define} and
possibly @code{buildq}.  


@node Macros, Definitions for Function Definition, Function, Function Definition
@section Macros

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} buildq (@var{variables}, @var{expr})

@var{expr} is any single Maxima expression and
@var{variables} is a list of elements of the form @code{<atom>}
or @code{<atom>: <value>}.

@subsection Semantics

The elements of the list @var{variables} are evaluated left to right (the syntax
@var{atom} is equivalent to @code{@var{atom}: @var{atom}}).  then these values are substituted
into <expression> in parallel.  If any @var{atom} appears as a single 
argument to the special form @code{splice} (i.e. @code{splice (@var{atom})}) inside
@var{expr}, then the value associated with that @var{atom} must be a Maxima
list, and it is spliced into @var{expr} instead of substituted.

@subsection Simplification

The arguments to @code{buildq} need to be protected from simplification until
the substitutions have been carried out.  This code should effect that
by using @code{'}.

@code{buildq} can be useful for building functions on the fly.  One
of the powerful things about @b{Maxima} is that you can have your
functions define other functions to help solve the problem.
Further below we discuss building a recursive function, for a
series solution.   This defining of functions inside functions
usually uses @code{define}, which evaluates its arguments.
A number of examples are included under @code{splice}.
@end deffn

@c NEEDS CLARIFICATION
@deffn {Function} splice (@var{atom})
This is used with buildq to construct a list. This is handy
for making argument lists, in conjunction with @code{buildq}.

@example
mprint ([x]) ::= buildq ([u : x],
  if (debuglevel > 3) print (splice (u)));
@end example

Including a call like

@example
mprint ("matrix is", mat, "with length", length(mat))
@end example

is equivalent to putting in the line

@example
if (debuglevel > 3) print ("matrix is", mat, "with length", length(mat));
@end example

A more non trivial example would try to display the variable values
and their names.  
@example
mshow (a, b, c) 
@end example

should become

@example
print ('a, "=", a, ",", 'b, "=", b, ", and", 'c, "=", c)
@end example

so that if it occurs as a line in a program we can print values.

@example
(%i1) foo (x,y,z) := mshow (x, y, z);
(%i2) foo (1, 2, 3);
x = 1 , y = 2 , and z = 3
@end example


The actual definition of mshow is the following.   Note how buildq
lets you build "quoted" structure, so that the  @code{'u} lets
you get the variable name.  Note that in macros, the result is
a piece of code which will then be substituted for the macro and evaluated.

@example
mshow ([l]) ::= block ([ans:[], n:length(l)],
    for i:1 thru n do
        (ans: append (ans, buildq ([u: l[i]], ['u, "=", u])),
        if i < n then
            ans: append (ans, if i < n-1 then [","] else [", and"])),
    buildq ([u:ans], print (splice(u))));
@end example

The splice also works to put arguments into algebraic operations:

@example
(%i1) buildq ([a: '[b, c, d]], +splice(a));
(%o1)                       d + c + b
@end example

Note how the simplification only occurs @i{after} the substitution,
The operation applying to the splice in the first cae is the @code{+}
while in the second it is the @code{*}, yet logically you
might think @code{splice(a)+splice(a)} could be replaced by
@code{2*splice(a)}.   No simplification takes place with the @code{buildq}.
To understand what @code{splice} is doing with the algebra you must understand
that for Maxima, a formula an operation like @code{a+b+c} is really
internally similar to @code{+(a,b,c)}, and similarly for multiplication.
Thus @code{*(2,b,c,d)} is @code{2*b*c*d}.

@example
(%i1) buildq ([a: '[b,c,d]], +splice(a));
(%o1)                       d + c + b
(%i2) buildq ([a: '[b,c,d]], splice(a)+splice(a));
(%o2)                    2 d + 2 c + 2 b
@end example

but

@example
(%i3) buildq ([a: '[b,c,d]], 2*splice(a));
(%o3)                        2 b c d
@end example

Finally @code{buildq} can be invaluable for building recursive functions.
Suppose your program is solving a differential equation using the
series method, and has determined that it needs to build a
recursion relation

@example
f[n] := -((n^2 - 2*n + 1)*f[n-1] + f[n-2] + f[n-3])/(n^2-n)
@end example

and it must do this on the fly inside your function.  Now you
would really like to add @code{expand}.

@example
f[n] := expand (-((n^2 - 2*n + 1)*f[n-1] + f[n-2] + f[n-3])/(n^2-n))
@end example

but how do you build this code.  You want the @code{expand}
to happen each time the function runs, @i{not} before it.

@example
(%i1) val: -((n^2 - 2*n + 1)*f[n-1] + f[n-2] + f[n-3])/(n^2-n)$
(%i2) define (f[n], buildq ([u: val], expand(u)))$
@end example

does the job.   This might be useful, since when you do
(with @code{expand})

@example
(%i3) f[0]: aa0$
(%i4) f[1]: aa1$
(%i5) f[2]: aa2$
(%i6) f[6];
                       3 aa2   aa1   7 aa0
(%o6)                  ----- + --- + -----
                        10     40     90
@end example

where as without it is kept unsimplified, and even after 6 terms
it becomes:

@example
(%i7) define (g[n], buildq ([u: val], u))$
(%i8) g[0]: bb0$
(%i9) g[1]: bb1$
(%i10) g[2]: bb2$
(%i11) g[6];
          aa2         7 aa2   aa1   11 aa0    aa1   aa0
          --- - 25 (- ----- - --- - ------) + --- + ---
           4           20     40     120       8    24
(%o11)    ---------------------------------------------
                               30
(%i12) expand (%);
                       3 aa2   aa1   7 aa0
(%o12)                 ----- + --- + -----
                        10     40     90
@end example

The expression quickly becomes complicated if not simplified at
each stage, so the simplification must be part of the definition.
Hence the @code{buildq} is useful for building the form.
@end deffn


@c end concepts Function Definition
@node Definitions for Function Definition,  , Macros, Function Definition
@section Definitions for Function Definition
@c NEEDS CLARIFICATION AND EXAMPLES
@c IMPORTANT TOPIC
@deffn {Function} apply (@var{f}, [@var{x_1}, ..., @var{x_n}])
Returns the result of applying the function @var{f} to the list of arguments @var{x_1}, ..., @var{x_n}.
@var{f} is the name of a function or a lambda expression.

This is useful when it is desired to
compute the arguments to a function before applying that function.
For example, if @code{l} is the list @code{[1, 5, -10.2, 4, 3]}, then @code{apply (min, l)}
gives -10.2.  @code{apply} is also useful when calling functions which do not
have their arguments evaluated if it is desired to cause evaluation of
them.  For example, if @code{filespec} is a variable bound to the list @code{[test,
case]} then @code{apply (closefile, filespec)} is equivalent to
@code{closefile (test, case)}.  In general the first argument to @code{apply} should
be preceded by a ' to make it evaluate to itself.  Since some atomic
variables have the same name as certain functions the values of the
variable would be used rather than the function because @code{apply} has its
first argument evaluated as well as its second.

@end deffn


@deffn {Function} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Function} block (@var{expr_1}, ..., @var{expr_n})
@code{block} evaluates @var{expr_1}, ..., @var{expr_n} in sequence
and returns the value of the last expression evaluated.
The sequence can be modified by the @code{go}, @code{throw}, and @code{return} functions.
The last expression is @var{expr_n} unless @code{return} or an expression containing @code{throw}
is evaluated.
Some variables @var{v_1}, ..., @var{v_m} can be declared local to the block;
these are distinguished from global variables of the same names.
If no variables are declared local then the list may be omitted.
Within the block,
any variable other than @var{v_1}, ..., @var{v_m} is a global variable.

@code{block} saves the current values of the variables @var{v_1}, ..., @var{v_m} (if any)
upon entry to the block,
then unbinds the variables so that they evaluate to themselves.
The local variables may be bound to arbitrary values within the block but when the
block is exited the saved values are restored,
and the values assigned within the block are lost.

@code{block} may appear within another @code{block}.
Local variables are established each time a new @code{block} is evaluated.
Local variables appear to be global to any enclosed blocks.
If a variable is non-local in a block,
its value is the value most recently assigned by an enclosing block, if any,
otherwise, it is the value of the variable in the global environment.
This policy may coincide with the usual understanding of "dynamic scope".

If it is desired to save and restore other local properties
besides @code{value}, for example @code{array} (except for complete arrays),
@code{function}, @code{dependencies}, @code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant}, and
@code{nonscalar} then the function @code{local} should be used inside of the block
with arguments being the names of the variables.

The value of the block is the value of the last statement or the
value of the argument to the function @code{return} which may be used to exit
explicitly from the block. The function @code{go} may be used to transfer
control to the statement of the block that is tagged with the argument
to @code{go}.  To tag a statement, precede it by an atomic argument as
another statement in the block.  For example:
@code{block ([x], x:1, loop, x: x+1, ..., go(loop), ...)}.  The argument to @code{go} must
be the name of a tag appearing within the block.  One cannot use @code{go} to
transfer to a tag in a block other than the one containing the @code{go}.

Blocks typically appear on the right side of a function definition
but can be used in other places as well.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Function} break (@var{expr_1}, ..., @var{expr_n})
Evaluates and prints @var{expr_1}, ..., @var{expr_n} and then
causes a Maxima break at which point the user can examine and change
his environment.  Upon typing @code{exit;} the computation resumes.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE. MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Function} catch (@var{expr_1}, ..., @var{expr_n})
Evaluates @var{expr_1}, ..., @var{expr_n} one by one; if any
leads to the evaluation of an expression of the
form @code{throw (arg)}, then the value of the @code{catch} is the value of
@code{throw (arg)}, and no further expressions are evaluated.
This "non-local return" thus goes through any depth of
nesting to the nearest enclosing @code{catch}.
If there is no @code{catch} enclosing a @code{throw}, an error message is printed.

If the evaluation of the arguments does not lead to the evaluation of any @code{throw}
then the value of @code{catch} is the value of @var{expr_n}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
The function @code{g} returns a list of @code{f} of each element of @code{l} if @code{l}
consists only of non-negative numbers; otherwise, @code{g} "catches" the
first negative element of @code{l} and "throws" it up.

@end deffn

@deffn {Function} compfile (@var{filename}, @var{f_1}, ..., @var{f_n})
Translates Maxima functions @var{f_1}, ..., @var{f_n} into Lisp 
and writes the translated code into the file @var{filename}.

The Lisp translations are not evaluated, nor is the output file processed by the Lisp compiler.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} creates and evaluates Lisp translations.
@code{compile_file} translates Maxima into Lisp, and then executes the Lisp compiler. 

See also @code{translate}, @code{translate_file}, and @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} is @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Function} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Function} compile (functions)
@deffnx {Function} compile (all)
Translates Maxima functions @var{f_1}, ..., @var{f_n} into Lisp, evaluates the Lisp translations,
and calls the Lisp function @code{COMPILE} on each translated function.
@code{compile} returns a list of the names of the compiled functions.

@code{compile (all)} or @code{compile (functions)} compiles all user-defined functions.

@code{compile} quotes its arguments; 
the double-single-quotes operator @code{'@w{}'} defeats quotation.

@end deffn

@deffn {Function} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
Defines a function named @var{f} with arguments @var{x_1}, ..., @var{x_n} and function body @var{expr}.

@code{define} quotes its first argument in most cases,
and evaluates its second argument unless explicitly quoted.
However, if the first argument is an expression of the form
@code{ev (@var{expr})}, @code{funmake (@var{expr})}, or @code{arraymake (@var{expr})},
the first argument is evaluated;
this allows for the function name to be computed, as well as the body.

@code{define} is similar to the function definition operator @code{:=}, but when
@code{define} appears inside a function, the definition is created using the value
of @code{expr} at execution time rather than at the
time of definition of the function which contains it.

All function definitions appear in the same namespace;
defining a function @code{f} within another function @code{g}
does not limit the scope of @code{f} to @code{g}.

Examples:

@example
(%i1) foo: 2^bar;
                               bar
(%o1)                         2
(%i2) g(x) := (f_1 (y) :=   foo*x*y,
               f_2 (y) := ''foo*x*y,
       define (f_3 (y),     foo*x*y),
       define (f_4 (y),   ''foo*x*y));
                                             bar
(%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y, 
                                                        bar
               define(f_3(y), foo x y), define(f_4(y), 2    x y))
(%i3) functions;
(%o3)                        [g(x)]
(%i4) g(a);
                                    bar
(%o4)                  f_4(y) := a 2    y
(%i5) functions;
(%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
(%i6) dispfun (f_1, f_2, f_3, f_4);
(%t6)                   f_1(y) := foo x y

                                  bar
(%t7)                  f_2(y) := 2    x y

                                    bar
(%t8)                  f_3(y) := a 2    y

                                    bar
(%t9)                  f_4(y) := a 2    y

(%o9)                         done
@end example
@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Function} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Function} define_variable (@var{name}, @var{default_value}, @var{mode})

Introduces a global variable into the Maxima environment.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} is useful in user-written packages, which are often translated or compiled.

@code{define_variable} carries out the following steps:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} declares the mode of @var{name} to the translator.
See @code{mode_declare} for a list of the possible modes.

@item
If the variable is unbound, @var{default_value} is assigned to @var{name}.

@item
@code{declare (@var{name}, special)} declares it special.
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
Associates @var{name} with a test function
to ensure that @var{name} is only assigned values of the declared mode.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argument is a documentation string.  When
@c @code{translate_file} is used on a package which includes documentation
@c strings, a second file is output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

The @code{value_check} property can be assigned to any variable which has been defined
via @code{define_variable} with a mode other than @code{any}.
The @code{value_check} property is a lambda expression or the name of a function of one variable,
which is called when an attempt is made to assign a value to the variable.
The argument of the @code{value_check} function is the would-be assigned value.

@code{define_variable} evaluates @code{default_value}, and quotes @code{name} and @code{mode}.
@code{define_variable} returns the current value of @code{name},
which is @code{default_value} if @code{name} was unbound before,
and otherwise it is the previous value of @code{name}.

Examples:

@code{foo} is a Boolean variable, with the initial value @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} is an integer variable, which must be prime.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} is a variable which cannot be assigned a value.
The mode @code{any_check} is like @code{any}, 
but @code{any_check} enables the @code{value_check} mechanism, and @code{any} does not.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Function} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Function} dispfun (all)
Displays the definition of the user-defined functions @var{f_1}, ..., @var{f_n}.
Each argument may be the name of a macro (defined with @code{::=}),
an ordinary function (defined with @code{:=} or @code{define}),
an array function (defined with @code{:=} or @code{define},
but enclosing arguments in square brackets @code{[ ]}),
a subscripted function, (defined with @code{:=} or @code{define},
but enclosing some arguments in square brackets and others in parentheses @code{( )})
one of a family of subscripted functions selected by a particular subscript value,
or a subscripted function defined with a constant subscript.

@code{dispfun (all)} displays all user-defined functions as
given by the @code{functions}, @code{arrays}, and @code{macros} lists,
omitting subscripted functions defined with constant subscripts.

@code{dispfun} creates an intermediate expression label
(@code{%t1}, @code{%t2}, etc.)
for each displayed function, and assigns the function definition to the label.
In contrast, @code{fundef} returns the function definition.

@code{dispfun} quotes its arguments; 
the double-single-quote operator @code{'@w{}'} defeats quotation.
@code{dispfun} always returns @code{done}.

Examples:

@example
(%i1) m(x, y) ::= x^(-y)$
(%i2) f(x, y) :=  x^(-y)$
(%i3) g[x, y] :=  x^(-y)$
(%i4) h[x](y) :=  x^(-y)$
(%i5) i[8](y) :=  8^(-y)$
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8])$
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8
@end example

@end deffn

@defvr {Variable} functions
Default value: @code{[]}

@code{functions} is the list of user-defined Maxima functions
in the current session.
A user-defined function is a function constructed by
@code{define} or @code{:=}.
A function may be defined at the Maxima prompt
or in a Maxima file loaded by @code{load} or @code{batch}.
Lisp functions, however, are not added to @code{functions}.

@end defvr

@deffn {Function} fundef (@var{f})
Returns the definition of the function @var{f}.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
The argument may be the name of a macro (defined with @code{::=}),
an ordinary function (defined with @code{:=} or @code{define}),
an array function (defined with @code{:=} or @code{define},
but enclosing arguments in square brackets @code{[ ]}),
a subscripted function, (defined with @code{:=} or @code{define},
but enclosing some arguments in square brackets and others in parentheses @code{( )})
one of a family of subscripted functions selected by a particular subscript value,
or a subscripted function defined with a constant subscript.

@code{fundef} quotes its argument;
the double-single-quote operator @code{'@w{}'} defeats quotation.

@code{fundef (@var{f})} returns the definition of @var{f}.
In contrast, @code{dispfun (@var{f})} creates an intermediate expression label
and assigns the definition to the label.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Function} funmake (@var{name}, [@var{arg_1}, ..., @var{arg_n}])
Returns an expression @code{@var{name} (@var{arg_1}, ..., @var{arg_n})}.
The return value is simplified, but not evaluated,
so the function is not called.

@code{funmake} evaluates its arguments.

Examples:

@itemize @bullet
@item
@code{funmake} evaluates its arguments, but not the return value.
@example
(%i1) det(a,b,c) := b^2 -4*a*c$
(%i2) x: 8$
(%i3) y: 10$
(%i4) z: 12$
(%i5) f: det$
(%i6) funmake (f, [x, y, z]);
(%o6)                    det(8, 10, 12)
(%i7) ''%;
(%o7)                         - 284
@end example
@item
Maxima simplifies @code{funmake}'s return value.
@example
(%i1) funmake (sin, [%pi/2]);
(%o1)                           1
@end example
@end itemize

@end deffn

@deffn {Function} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
Defines and returns a lambda expression (that is, an anonymous function)
with arguments @var{x_1}, ..., @var{x_m} and return value @var{expr_n}.
A lambda expression can be assigned to a variable and evaluated like an ordinary function.
A lambda expression may appear in contexts in which a function evaluation
(but not a function name) is expected.

When the function is evaluated,
unbound local variables @var{x_1}, ..., @var{x_m} are created.
@code{lambda} may appear within @code{block} or another @code{lambda};
local variables are established each time another @code{block} or @code{lambda} is evaluated.
Local variables appear to be global to any enclosed @code{block} or @code{lambda}.
If a variable is not local,
its value is the value most recently assigned in an enclosing @code{block} or @code{lambda}, if any,
otherwise, it is the value of the variable in the global environment.
This policy may coincide with the usual understanding of "dynamic scope".

After local variables are established,
@var{expr_1} through @var{expr_n} are evaluated in turn.
The special variable @code{%%}, representing the value of the preceding expression,
is recognized.
@code{throw} and @code{catch} may also appear in the list of expressions.

@code{return} cannot appear in a lambda expression unless enclosed by @code{block},
in which case @code{return} defines the return value of the block and not of the
lambda expression,
unless the block happens to be @var{expr_n}.
Likewise, @code{go} cannot appear in a lambda expression unless enclosed by @code{block}.

@code{lambda} quotes its arguments; 
the double-single-quote operator @code{'@w{}'} defeats quotation.

Examples:

@c FOLLOWING EXAMPLES GENERATED FROM THIS SCRIPT:
@c f: lambda ([x], x^2);
@c f(a);
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@itemize @bullet
@item
A lambda expression can be assigned to a variable and evaluated like an ordinary function.
@end itemize
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
A lambda expression may appear in contexts in which a function evaluation is expected.
@end itemize
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Argument variables are local variables.
Other variables appear to be global variables.
Global variables are evaluated at the time the lambda expression is evaluated,
unless some special evaluation is forced by some means, such as @code{'@w{}'}.
@end itemize
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Lambda expressions may be nested.
Local variables within the outer lambda expression appear to be global to the inner expression
unless masked by local variables of the same names.
@end itemize
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Since @code{lambda} quotes its arguments, lambda expression @code{i} below 
does not define a "multiply by @code{a}" function.
Such a function can be defined via @code{buildq}, as in lambda expression @code{i2} below.
@end itemize
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} local (@var{v_1}, ..., @var{v_n})
Declares the variables @var{v_1}, ..., @var{v_n} to be local with
respect to all the properties in the statement in which this function
is used.

@code{local} may only be used in @code{block}, in the body of function
definitions or @code{lambda} expressions, or in the @code{ev} function, and only one
occurrence is permitted in each.

@code{local} is independent of @code{context}.

@end deffn

@defvr {Variable} macroexpansion
Default value: @code{false}

@code{macroexpansion} controls advanced features which
affect the efficiency of macros. Possible settings:

@itemize @bullet
@item
@code{false} -- Macros expand normally each time they are called.
@item
@code{expand} -- The first time a particular call is evaluated, the
expansion is remembered internally, so that it doesn't have to be
recomputed on subsequent calls making subsequent calls faster.  The
macro call still calls @code{grind} and @code{display} normally. However, extra memory is
required to remember all of the expansions.
@item
@code{displace} -- The first time a particular call is evaluated, the
expansion is substituted for the call.  This requires slightly less
storage than when @code{macroexpansion} is set to @code{expand} and is just as fast,
but has the disadvantage that the original macro call is no longer
remembered and hence the expansion will be seen if @code{display} or @code{grind} is
called.  See documentation for @code{translate} and @code{macros} for more details.
@end itemize
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variable} mode_checkp
Default value: @code{true}

@c WHAT DOES THIS MEAN ??
When @code{mode_checkp} is @code{true}, @code{mode_declare} checks the modes
of bound variables.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variable} mode_check_errorp
Default value: @code{false}

@c WHAT DOES THIS MEAN ??
When @code{mode_check_errorp} is @code{true}, @code{mode_declare} calls
error.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variable} mode_check_warnp
Default value: @code{true}

@c WHAT DOES THIS MEAN ??
When @code{mode_check_warnp} is @code{true}, mode errors are
described.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} is used to declare the modes of variables and
functions for subsequent translation or compilation of functions.
@code{mode_declare} is typically placed at the beginning of a function
definition, at the beginning of a Maxima script, or executed at the interactive prompt.

The arguments of @code{mode_declare} are pairs consisting of a variable and a mode which is
one of @code{boolean}, @code{fixnum}, @code{number}, @code{rational}, or @code{float}.
Each variable may also
be a list of variables all of which are declared to have the same mode.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
If a variable is an array, and if every element of the array which is
referenced has a value then @code{array (yi, complete, dim1, dim2, ...)}
rather than
@example
array(yi, dim1, dim2, ...)
@end example
should be used when first
declaring the bounds of the array.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
If all the elements of the array
are of mode @code{fixnum} (@code{float}), use @code{fixnum} (@code{float}) instead of @code{complete}.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Also if every element of the array is of the same mode, say @code{m}, then

@example
mode_declare (completearray (yi), m))
@end example

should be used for efficient
translation.

Numeric code using arrays might run faster
by declaring the expected size of the array, as in:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

for a floating point number array which is 10 x 10.

One may declare the mode of the result of a function by
using @code{function (f_1, f_2, ...)} as an argument;
here @code{f_1}, @code{f_2}, ... are the names
of functions.  For example the expression,

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

declares that the values returned by @code{f_1}, @code{f_2}, ... are single-word integers.

@code{modedeclare} is a synonym for @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} mode_identity (@var{arg_1}, @var{arg_2})
A special form used with @code{mode_declare} and
@code{macros} to declare, e.g., a list of lists of flonums, or other compound
data object.  The first argument to @code{mode_identity} is a primitive value
mode name as given to @code{mode_declare} (i.e., one of @code{float}, @code{fixnum}, @code{number},
@code{list}, or @code{any}), and the second argument is an expression which is
evaluated and returned as the value of @code{mode_identity}.  However, if the
return value is not allowed by the mode declared in the first
argument, an error or warning is signalled.  The important thing is
that the mode of the expression as determined by the Maxima to Lisp
translator, will be that given as the first argument, independent of
anything that goes on in the second argument.
E.g., @code{x: 3.3; mode_identity (fixnum, x);} yields an error. @code{mode_identity (flonum, x)}
returns 3.3 . 
This has a number of uses, e.g., if you knew that @code{first (l)} returned a
number then you might write @code{mode_identity (number, first (l))}.  However,
a more efficient way to do it would be to define a new primitive,

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@end example

and use @code{firstnumb}
every time you take the first of a list of numbers.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Variable} transcompile
Default value: @code{true}

When @code{transcompile} is @code{true}, @code{translate} and @code{translate_file} generate
declarations to make the translated code more suitable for compilation.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} sets @code{transcompile: true} for the duration.

@end defvr

@deffn {Function} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Function} translate (functions)
@deffnx {Function} translate (all)
Translates the user-defined functions
@var{f_1}, ..., @var{f_n} from the Maxima language into Lisp
and evaluates the Lisp translations.
Typically the translated functions run faster than the originals.

@code{translate (all)} or @code{translate (functions)} translates all user-defined functions.

Functions to be translated should include a call to @code{mode_declare} at the
beginning when possible in order to produce more efficient code.  For
example:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

where the @var{x_1}, @var{x_2}, ...  are the parameters to the function and the
@var{v_1}, @var{v_2}, ... are the local variables.

The names of translated functions
are removed from the @code{functions} list if @code{savedef} is @code{false} (see below)
and are added to the @code{props} lists.

Functions should not be translated
unless they are fully debugged.

Expressions are assumed simplified; if they are not, correct but non- optimal code gets
generated.  Thus, the user should not set the @code{simp} switch to @code{false}
which inhibits simplification of the expressions to be translated.

The switch @code{translate}, if @code{true}, causes automatic
translation of a user's function to Lisp.

Note that translated
functions may not run identically to the way they did before
translation as certain incompatabilities may exist between the Lisp
and Maxima versions.  Principally, the @code{rat} function with more than
one argument and the @code{ratvars} function should not be used if any
variables are @code{mode_declare}'d canonical rational expressions (CRE).
Also the @code{prederror: false} setting
will not translate.
@c WHAT ABOUT % AND %% ???

@code{savedef} - if @code{true} will cause the Maxima version of a user
function to remain when the function is @code{translate}'d.  This permits the
definition to be displayed by @code{dispfun} and allows the function to be
edited.

@code{transrun} - if @code{false} will cause the interpreted version of all
functions to be run (provided they are still around) rather than the
translated version.

The result returned by @code{translate} is a list of the names of the
functions translated.

@end deffn

@deffn {Function} translate_file (@var{maxima_filename})
@deffnx {Function} translate_file (@var{maxima_filename}, @var{lisp_filename})
Translates a file of Maxima code into a file of Lisp code.
@code{translate_file} returns a list of three filenames:
the name of the Maxima file, the name of the Lisp file, and the name of file
containing additional information about the translation.
@code{translate_file} evaluates its arguments.

@code{translate_file ("foo.mac"); load("foo.LISP")} is the same as
@code{batch ("foo.mac")} except for certain restrictions,
the use of @code{'@w{}'} and @code{%}, for example.
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_filename})} translates a Maxima file @var{maxima_filename}
into a similarly-named Lisp file.
For example, @code{foo.mac} is translated into @code{foo.LISP}.
The Maxima filename may include a directory name or names,
in which case the Lisp output file is written
to the same directory from which the Maxima input comes.

@code{translate_file (@var{maxima_filename}, @var{lisp_filename})} translates
a Maxima file @var{maxima_filename} into a Lisp file @var{lisp_filename}.
@code{translate_file} ignores the filename extension, if any, of @code{lisp_filename};
the filename extension of the Lisp output file is always @code{LISP}.
The Lisp filename may include a directory name or names,
in which case the Lisp output file is written to the specified directory.

@code{translate_file} also writes a file of translator warning
messages of various degrees of severity.
The filename extension of this file is @code{UNLISP}.
This file may contain valuable information, though possibly obscure,
for tracking down bugs in translated code.
The @code{UNLISP} file is always written
to the same directory from which the Maxima input comes.

@code{translate_file} emits Lisp code which causes
some declarations and definitions to take effect as soon
as the Lisp code is compiled.
See @code{compile_file} for more on this topic.

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
See also @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared}, 
@code{tr_warn_undefined_variable},
and @code{tr_windy}.

@end deffn

@defvr {Variable} transrun
Default value: @code{true}

When @code{transrun} is @code{false} will cause the interpreted
version of all functions to be run (provided they are still around)
rather than the translated version.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Variable} tr_array_as_ref
Default value: @code{true}

If @code{translate_fast_arrays} is false, array references in
Lisp code emitted by @code{translate_file} are affected by @code{tr_array_as_ref}.
When @code{tr_array_as_ref} is @code{true},
array names are evaluated,
otherwise array names appear as literal symbols in translated code.

@code{tr_array_as_ref} has no effect if @code{translate_fast_arrays} is @code{true}.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Variable} tr_bound_function_applyp
Default value: @code{true}

When @code{tr_bound_function_applyp} is @code{true}, Maxima gives a warning if a bound
variable (such as a function argument) is found being used as a function.
@code{tr_bound_function_applyp} does not affect the code generated in such cases.

For example, an expression such as @code{g (f, x) := f (x+1)} will trigger
the warning message.

@end defvr

@defvr {Variable} tr_file_tty_messagesp
Default value: @code{false}

When @code{tr_file_tty_messagesp} is @code{true},
messages generated by @code{translate_file} during translation of a file are displayed
on the console and inserted into the UNLISP file. 
When @code{false}, messages about translation of the
file are only inserted into the UNLISP file.

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT. SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Variable} tr_float_can_branch_complex
Default value: @code{true}

Tells the Maxima-to-Lisp translator to assume that the functions 
@code{acos}, @code{asin}, @code{asec}, and @code{acsc} can return complex results.

The ostensible effect of @code{tr_float_can_branch_complex} is the following.
However, it appears that this flag has no effect on the translator output.

When it is @code{true} then @code{acos(x)} is of mode @code{any}
even if @code{x} is of mode @code{float} (as set by @code{mode_declare}).
When @code{false} then @code{acos(x)} is of mode
@code{float} if and only if @code{x} is of mode @code{float}.

@end defvr

@defvr {Variable} tr_function_call_default
Default value: @code{general}

@code{false} means give up and
call @code{meval}, @code{expr} means assume Lisp fixed arg function.  @code{general}, the
default gives code good for @code{mexprs} and @code{mlexprs} but not @code{macros}.
@code{general} assures variable bindings are correct in compiled code.  In
@code{general} mode, when translating F(X), if F is a bound variable, then it
assumes that @code{apply (f, [x])} is meant, and translates a such, with
apropriate warning. There is no need to turn this off.  With the
default settings, no warning messages implies full compatibility of
translated and compiled code with the Maxima interpreter.

@end defvr

@defvr {Variable} tr_numer
Default value: @code{false}

When @code{tr_numer} is @code{true} numer properties are used for
atoms which have them, e.g. @code{%pi}.

@end defvr

@defvr {Variable} tr_optimize_max_loop
Default value: 100

@code{tr_optimize_max_loop} is the maximum number of times the
macro-expansion and optimization pass of the translator will loop in
considering a form.  This is to catch macro expansion errors, and
non-terminating optimization properties.

@end defvr

@defvr {Variable} tr_semicompile
Default value: @code{false}

When @code{tr_semicompile} is @code{true}, @code{translate_file} and @code{compfile}
output forms which will be macroexpanded but not compiled into machine
code by the Lisp compiler.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Variable} tr_state_vars
Default value:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

The list of the switches that affect the form of the
translated output.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
This information is useful to system people when
trying to debug the translator.  By comparing the translated product
to what should have been produced for a given state, it is possible to
track down bugs.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Function} tr_warnings_get ()
Prints a list of warnings which have been given by
the translator during the current translation.

@end deffn

@defvr {Variable} tr_warn_bad_function_calls
Default value: @code{true}

- Gives a warning when
when function calls are being made which may not be correct due to
improper declarations that were made at translate time.

@end defvr

@defvr {Variable} tr_warn_fexpr
Default value: @code{compfile}

- Gives a warning if any FEXPRs are
encountered.  FEXPRs should not normally be output in translated code,
all legitimate special program forms are translated.

@end defvr

@defvr {Variable} tr_warn_meval
Default value: @code{compfile}

- Gives a warning if the function
@code{meval} gets called.  If @code{meval} is called that indicates problems in the
translation.

@end defvr

@defvr {Variable} tr_warn_mode
Default value: @code{all}

- Gives a warning when variables are
assigned values inappropriate for their mode.

@end defvr

@defvr {Variable} tr_warn_undeclared
Default value: @code{compile}

- Determines when to send
warnings about undeclared variables to the TTY.

@end defvr

@defvr {Variable} tr_warn_undefined_variable
Default value: @code{all}

- Gives a warning when
undefined global variables are seen.

@end defvr

@c $tr_windy IS USED IN EXACTLY ONE PLACE (def%tr $kill IN src/trans1.lisp)
@c WHERE IT CAUSES A WARNING ABOUT USING kill. 
@c HOW ABOUT IF WE PERMANENTLY ENABLE THE WARNING MESSAGE
@c AND CUT OUT tr_windy FROM CODE AND DOCS.
@defvr {Variable} tr_windy
Default value: @code{true}

- Generate "helpfull" comments and
programming hints.

@end defvr

@deffn {Function} compile_file (@var{filename})
@deffnx {Function} compile_file (@var{filename}, @var{compiled_filename})
@deffnx {Function} compile_file (@var{filename}, @var{compiled_filename}, @var{lisp_filename})
Translates the Maxima file @var{filename} into Lisp,
executes the Lisp compiler,
and, if the translation and compilation succeed, loads the compiled code into Maxima.

@code{compile_file} returns a list of the names of four files:
the original Maxima file, the Lisp translation, notes on translation, and the compiled code.
If the compilation fails,
the fourth item is @code{false}.

Some declarations and definitions take effect as soon
as the Lisp code is compiled (without loading the compiled code).
These include functions defined with the @code{:=} operator,
macros define with the @code{::=} operator, @c HEDGE -- DON'T KNOW IF THERE IS ANOTHER WAY
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
and 
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
and @code{compfile}.

Assignments and function calls are not evaluated until the compiled code is loaded.
In particular, within the Maxima file,
assignments to the translation flags (@code{tr_numer}, etc.) have no effect on the translation.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded. This is a bug. 
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{filename} may not contain @code{:lisp} statements.

@code{compile_file} evaluates its arguments.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Function} declare_translated (@var{f_1}, @var{f_2}, ...)
When translating a file of Maxima code
to Lisp, it is important for the translator to know which functions it
sees in the file are to be called as translated or compiled functions,
and which ones are just Maxima functions or undefined.  Putting this
declaration at the top of the file, lets it know that although a symbol
does which does not yet have a Lisp function value, will have one at
call time. @code{(MFUNCTION-CALL fn arg1 arg2 ...)} is generated when
the translator does not know fn is going to be a Lisp function.

@end deffn

