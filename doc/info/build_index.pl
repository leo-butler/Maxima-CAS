$main_info = $ARGV[0];
$index_node_name = $ARGV[1];

$unit_separator = "";

# ------------------------------------------------------------------
# PART 1. BUILD INDEX FOR @DEFFN AND @DEFVR ITEMS
# ------------------------------------------------------------------

# (1.1)  Build index tables.

# (1.1a) Scan the *.info-* files for unit separator characters;
#        those mark the start of each texinfo node.
#        Build a hash table which associates the node name with the filename
#        and byte offset (NOT character offset) of the unit separator.
#
#        Do NOT use the indirect table + tag table (generated by makeinfo),
#        because those tables give character offsets; we want byte offsets.
#        It is easier to construct a byte offset table by hand,
#        rather than attempting to fix up the character offsets.
#        (Which are strange anyway.)

open (FH, $main_info);
read (FH, $stuff, -s FH);

while ($stuff =~ m/^($main_info-\d+): (\d+)/cgsm) {
    $filename = $1;
    push @info_filenames, $filename;

    open FH2, $filename;
    read FH2, $stuff2, -s FH2;

    while ($stuff2 =~ m/\G.*?(?=\n$unit_separator)/cgsm) {
        $offset = pos $stuff2;

        if ($stuff2 =~ m/^File:.*?Node: (.*?),/csgm) {
            $node_name = $1;
        }

print "; HEY $node_name => $filename, $offset\n";
        $node_offset{$node_name} = [($filename, int($offset))];
    }

    close $FH2;
}

close FH;

# print "HEY info_filenames = @info_filenames\n";

# (1.1b) Read the info index, which gives the node name and number of lines offset
#        for each indexed item. 

($index_filename, $index_node_offset) = @{$node_offset{$index_node_name}};
# print "HEY index_filename = $index_filename, index_node_offset = $index_node_offset\n";

open (FH, $index_filename);
read (FH, $stuff, -s FH);

if ($stuff =~ m/^File:.*?Node: $index_node_name.*^\* Menu:/icgsm) {
    while ($stuff =~ m/\G.*?^\* (\S+|[^:]+):\s+(.*?)\.\s+\(line\s+(\d+)\)/cgsm) {
        $topic_name = $1;
        $node_name = $2;
        $lines_offset = $3;
print "; HEY $topic_name => $node_name, $lines_offset\n";
        $topic_locator{$topic_name} = [($node_name, $lines_offset)];
    }
}

close FH;

# (1.2)  Translate node name and number of lines offset into file name and byte offset
#        for each indexed item.
#        Also find the length of each item.

foreach $key (sort keys %topic_locator) {
    ($node_name, $lines_offset) = @{$topic_locator{$key}};
    ($filename, $byte_offset0) = @{$node_offset{$node_name}};
    $byte_offset = seek_lines($filename, $byte_offset0, $lines_offset);

    open FH, "<:utf8", $filename;
    seek FH, $byte_offset, 0;
    read FH, $stuff, -s FH;
    if ($stuff =~ m/(.*?)(?:\n\n(?= -- )|\n(?=[0-9])|(?=$unit_separator))/cgsm) {
        $text_length = length $1;
    }
    else {
        # Eat everything up til end of file.
        $stuff =~ m/(.*)/cgsm;
        $text_length = length $1;
    }
    close FH;

    $topic_locator{$key} = [($node_name, $filename, $byte_offset, $text_length)];
}

# (1.3)  Generate Lisp code. The functions in info.lisp expect this stuff.

print "(in-package :cl-info)\n";
print "(defun cause-describe-index-to-load () nil)\n";

#        Pairs of the form (<index topic> . (<filename> <byte offset> <length> <node name>))

print "(defvar *info-deffn-defvr-pairs* '(\n";

foreach $key (sort keys %topic_locator) {
    print "(\"$key\" . (\"$topic_locator{$key}[1]\" $topic_locator{$key}[2] $topic_locator{$key}[3] \"$topic_locator{$key}[0]\"))\n";
}

print "))\n";

# ------------------------------------------------------------------
# PART 2. BUILD INDEX FOR @NODE ITEMS
# ------------------------------------------------------------------

# (2.1)  Search for 'mmm.nnn' at the start of a line,
#        and take each one of those to be the start of a node.
#
#        We could use the node table ($node_offset here), but we don't.
#        (a) The node table indexes nodes which contain only menus.
#            We don't want those because they have no useful text.
#        (b) The byte offset stated in the node table tells the location
#            of the "File: ..." header. We would have to cut off that stuff.
#        (c) The following regex-only code works OK as it stands.

for $filename (@info_filenames) {

# print "HEY IN LOOP filename = $filename\n";
    open (FH, $filename);
    read (FH, $stuff, -s FH);

    while ($stuff =~ m/\G.*?((^\d+\.\d+) (.*?)\n)/cgsm) {

        $begin_node_offset = pos($stuff) - length($1);
        $node_title = $3;

        # ?? $pos1 = pos($stuff);

        # Node text ends at a unit separator character,
        # or at the end of the file.

        if ($stuff =~ m/\G.*?($unit_separator)/cgsm) {
            $end_node_offset = pos($stuff) - length($1);
        }
        else {
            $stuff =~ m/\G.*/csgm;
            $end_node_offset = pos($stuff);
        }

        # ?? pos($stuff) = $pos1;

        $node_locator{$node_title} = [($filename, $begin_node_offset, $end_node_offset - $begin_node_offset)];
    }

    close FH;
}

# (2.2)  Generate Lisp code.
#
#        Pairs of the form (<node name> . (<filename> <byte offset> <length>))

print "(defvar *info-section-pairs* '(\n";

foreach $node_title (sort keys %node_locator) {
    ($filename, $begin_node_offset, $length) = @{$node_locator{$node_title}};
    print "(\"$node_title\" . (\"$filename\" $begin_node_offset ", $length, "))\n";
}

print "))\n";

#        Construct hashtables from the lists given above.

print "(load-info-hashtables)\n";

# ------------------------------------------------------------------
# Helper functions
# ------------------------------------------------------------------

sub seek_lines {
    my ($filename, $byte_offset, $lines_offset) = @_;
    open FH, $filename;
    seek FH, $byte_offset, 0;

    # MAKEINFO BUG: LINE OFFSET IS LINE NUMBER OF LAST LINE IN FUNCTION DEFINITION
    # (BUT WE NEED THE FIRST LINE OF THE FUNCTION DEFINITION)
    # BUG IS PRESENT IN MAKEINFO 4.8; FOLLOWING CAN GO AWAY WHEN BUG IS FIXED
    
    for (1 .. $lines_offset + 1) {
        my $x_maybe = tell FH;
        my $line = <FH>;
        if ($line =~ /^ -- \S/) {
            $x = $x_maybe;
        }
    }

    # END OF MAKEINFO BUG WORKAROUND
    # WHEN WORKAROUND IS NO LONGER NEEDED, ENABLE THE FOLLOWING LINES:

    # <FH> for 1 .. $lines_offset;
    # $x = tell FH;

    close FH;
    return $x;
}
