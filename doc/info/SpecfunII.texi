
@menu
* Introduction to Orthogonal Polynomials::  
* Definitions for Orthogonal Polynomials::  
@end menu


@c SEEMS LIKE THIS INTRODUCTION COULD REORGANIZED -- IT'S A BIT HAPHAZARD
@node Introduction to Orthogonal Polynomials, Definitions for Orthogonal Polynomials, , Orthogonal Polynomials
@section Introduction to Orthogonal Polynomials

The @code{specfun} package contains Maxima
code for the evaluation of all orthogonal polynomials listed in 
Chapter 22 of Abramowitz and Stegun. These include Chebyshev, 
Laguerre, Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) 
polynomials.  Additionally, @code{specfun} contains code for 
spherical Bessel, spherical Hankel, and spherical harmonic functions.
The @code{specfun} package is not part of Maxima proper;
it is loaded at request of the user via @code{load} or automatically via the @code{autoload} system.

The following table lists each function in @code{specfun},
its Maxima name, restrictions on its arguments, and a 
reference to the algorithm @code{specfun} uses to evaluate it.
With few exceptions, @code{specfun} follows the conventions of
Abramowitz and Stegun.
In all cases, @math{m} and @math{n} must be integers.
@c UM, I REALLY DON'T THINK THIS DISCLAIMER IS NECESSARY
@c Before you use @code{specfun}, check
@c that @code{specfun}'s conventions match your expectations.

A&S refers to Abramowitz and Stegun, @emph{Handbook of 
Mathematical Functions} (10th printing, December 1972), 
G&R to Gradshteyn and Ryzhik, 
@emph{Table of Integrals, Series, and Products}
(1980 corrected and enlarged edition), and Merzbacher 
to @emph{Quantum Mechanics} (second edition, 1970).

@c CONSIDER STRIKING OUT RESTRICTIONS COLUMN TO MAKE TABLE NARROWER
@multitable @columnfractions 0.25 0.25 0.25 0.25
@item @emph{Function} @tab  @emph{Maxima Name}  @tab @emph{Restrictions} @tab @emph{Reference(s)}
@item @ Chebyshev T @tab chebyshev_t(n, x) @tab @math{n > -1} @tab A&S 22.5.31 
@item  Chebyshev U @tab chebyshev_u(n, x) @tab @math{n > -1} @tab A&S 22.5.32 
@item generalized Laguerre @tab gen_laguerre(n,a,x) @tab @math{n > -1} @tab A&S page 789
@item Laguerre @tab laguerre(n,x) @tab @math{n > -1} @tab A&S 22.5.67
@item Hermite @tab hermite(n,x) @tab @math{ n > -1} @tab A&S 22.4.40, 22.5.41
@item Jacobi @tab jacobi_p(n,a,b,x) @tab @math{ n > -1, a, b > -1} @tab A&S page 789
@item associated Legendre P @tab assoc_legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.37, 8.6.6, 8.2.5
@item associated Legendre Q @tab assoc_legendre_q(n,m,x) @tab @math{n > -1, m > -1} @tab G & R 8.706
@item Legendre P @tab legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.35
@item Legendre Q @tab legendre_q(n,m,x) @tab @math{n > -1} @tab A&S 8.6.19
@item spherical Hankel 1st @tab spherical_hankel1(n, x) @tab @math{n > -1} @tab A&S 10.1.36
@item spherical Hankel 2nd @tab spherical_hankel2(n, x) @tab @math{n > -1} @tab A&S 10.1.17
@item spherical Bessel J @tab spherical_bessel_j(n,x) @tab @math{n > -1} @tab A&S 10.1.8, 10.1.15
@item spherical Bessel Y @tab spherical_bessel_y(n,x) @tab @math{n > -1} @tab A&S 10.1.9, 10.1.15
@item spherical harmonic @tab spherical_harmonic(n,m,x,y) @tab @math{n > -1, |m| <= n} @tab Merzbacher 9.64
@item ultraspherical (Gegenbauer) @tab ultraspherical(n,a,x) @tab @math{ n > -1} @tab A&S 22.5.27
@end multitable

The @code{specfun} package is primarily intended for symbolic 
computation. It is hoped that it gives accurate floating point 
results as well; however, no claims are made that the algorithms 
are well suited for numerical evaluation.  Some effort, however,
has been made to provide
@c "GOOD NUMERICAL PERFORMANCE" -- LET'S BE MORE PRECISE. FAST? ACCURATE? SOMETHING ELSE?
good numerical performance.
When all arguments, except for the order, are floats (but not bigfloats), 
many functions in @code{specfun} call a float modedeclared version of the
Jacobi function.  This greatly speeds floating point evaluation
of the orthogonal polynomials.

@code{specfun} handles most domain errors by returning an unevaluated
function.  
No simplification rules (based on recursion relations) are defined for unevaluated functions.
It is possible for an expression
involving sums of unevaluated special functions to vanish, yet 
Maxima is unable to reduce it to zero.
@c DISCLAIMER UNNECESSARY
@c Be careful.

@code{load ("specfun")} loads the @code{specfun} package.
Alternatively, @code{setup_autoload} causes the package to be loaded
when one of the @code{specfun} functions appears in an expression.
@code{setup_autoload} may appear at the command line or in the @code{maxima-init.mac} file.
See @code{setup_autoload}.

An example use of @code{specfun} is

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c [hermite (0, x), hermite (1, x), hermite (2, x)];
@c diff (hermite (n, x), x);
@example
(%i1) load ("specfun")$
(%i2) [hermite (0, x), hermite (1, x), hermite (2, x)];
                                         2
(%o2)               [1, 2 x, - 2 (1 - 2 x )]
(%i3) diff (hermite (n, x), x);
(%o3)                 2 n hermite(n - 1, x)
@end example

@c FOLLOWING REMARKS ABOUT WRONG NUMBER OF ARGUMENTS CAUSING FATAL ERROR
@c WITH COMPILED CODE SEEM OUT OF DATE:
@c TESTING WITH 5.9.1 CMUCL, 5.9.1CVS CLISP, 5.9.1CVS GCL,
@c I GET ERROR MESSAGES ABOUT WRONG NUMBER OF ARGUMENTS (NOT FATAL)

@c When using the compiled version of @code{specfun}, be especially
@c careful to  use the correct number of function arguments; calling
@c them with too few arguments may generate a fatal error messages.  
@c For example
@c @example
@c (%i1) load("specfun")$
@c /* chebyshev_t requires two arguments. */
@c (%i2) chebyshev_t(8);
@c Error: Caught fatal error [memory may be damaged]
@c Fast links are on: do (si::use-fast-links nil) for debugging
@c Error signalled by MMAPCAR.
@c Broken at SIMPLIFY.  Type :H for Help.
@c @end example
@c Maxima code translated into Lisp handles such errors more gracefully. 
@c If @code{specfun.lisp} is installed on your machine, the same computation 
@c results in  a clear error message.  For example
@c @example
@c (%i1) load("specfun.lisp")$
@c (%i2) chebyshev_t(8);
@c Error: Expected 2 args but received 1 args
@c Fast links are on: do (si::use-fast-links nil) for debugging
@c Error signalled by MACSYMA-TOP-LEVEL.
@c Broken at |$CHEBYSHEV_T|.  Type :H for Help.
@c @end example 

@c NEED CONTEXT FOR THIS REMARK, OR MAYBE JUST CUT IT
Generally, compiled code runs faster than translated code; however, 
translated code may be better for program development.

Some functions 
@c SUM IS CONSTRUCTED BY jacobi_p FOR SYMBOLIC n. OTHER FUNCTIONS CALL jacobi_p OR EACH OTHER.
@c THERE ARE SOME FUNCTIONS WHICH IMPOSE THE REQUIREMENT THAT n BE NUMERICAL,
@c SO THEY NEVER CALL A FUNCTION ON THIS LIST WITH A SYMBOLIC n.
(namely @code{jacobi_p}, @code{ultraspherical}, @code{chebyshev_t},
@code{chebyshev_u}, and @code{legendre_p}),
return a series representation when the order is a symbolic integer.
The series representation is not
used by @code{specfun} for any computations,
but it may be simplified by Maxima automatically,
or it may be possible to use the series to evaluate the function
through further manipulations.
For example:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@c declare (n, integer)$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@example
(%i1) load ("specfun")$
(%i2) legendre_p (n, x);
(%o2)                   legendre_p(n, x)
(%i3) ultraspherical (n, 3/2, 2);
             genfact(3, n, - 1) jacobi_p(n, 1, 1, 2)
(%o3)        ---------------------------------------
                       genfact(2, n, - 1)
(%i4) declare (n, integer)$
(%i5) legendre_p (n, x);
       n - 1
       ====
       \                                                 n - i%
(%o5) ( >     binomial(n, i%) binomial(n, n - i%) (x - 1)
       /
       ====
       i% = 1

                                    i%          n          n   n
                             (x + 1)   + (x + 1)  + (x - 1) )/2
(%i6) ultraspherical (n, 3/2, 2);
                          n - 1
                          ====
                          \       i%
(%o6) genfact(3, n, - 1) ( >     3   binomial(n + 1, i%)
                          /
                          ====
                          i% = 1

                                    n
 binomial(n + 1, n - i%) + (n + 1) 3  + n + 1)

                      n
/(genfact(2, n, - 1) 2 )
@end example

The first and last terms
of the sum are added outside the summation.  Removing these
two terms avoids Maxima bugs associated with @math{0^0} terms
in a sum that should evaluate to 1, but evaluate to 0 in a Maxima 
summation. Because the sum index runs from 1 to 
@math{n - 1}, the lower sum 
index will exceed the upper sum index when @math{n = 0}; 
setting @code{sumhack} to true provides a fix. For example:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c declare (n, integer)$
@c e: legendre_p(n,x)$
@c ev (e, sum, n = 0);
@c ev (e, sum, n = 0, sumhack = true);
@example 
(%i1) load ("specfun")$
(%i2) declare (n, integer)$
(%i3) e: legendre_p(n,x)$
(%i4) ev (e, sum, n=0);
Lower bound to sum: 1
is greater than the upper bound: - 1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ev (e, sum, n=0, sumhack=true);
(%o5)                           1
@end example

Most functions in @code{specfun} have a @code{gradef} property; 
derivatives with respect to the order or other function parameters 
are undefined, and an attempt to compute such a derivative yields an error message.

The @code{specfun} package and its documentation were written by
Barton Willis of the University of Nebraska at Kearney. It is 
released under the terms of the General Public License (GPL).
@c HMM, SHOULD BUG REPORTS BE DIRECTED TO SF BUG TRACKER ??
@c PERHAPS FOR SHARE PACKAGES WE SHOULD HAVE BUG REPORTS GO TO THE SF BUG TRACKER AND 
@c ASK AUTHORS TO MONITOR THE BUG TRACKER FOR ITEMS RELATED TO THEIR PACKAGE.
Send bug reports and comments on this package to 
willisb@@unk.edu.  In your report, please include 
the Maxima version, as reported by @code{build_info()},
and the @code{specfun} version, as reported by @code{get ('specfun, 'version)}.

@c end concepts Orthogonal Polynomials
@node Definitions for Orthogonal Polynomials, , Introduction to Orthogonal Polynomials, Orthogonal Polynomials
@section Definitions for Orthogonal Polynomials

@anchor{assoc_legendre_p}
@defun assoc_legendre_p (@var{n}, @var{m}, @var{x})
Returns the associated Legendre function
of the first kind for  integers @math{ n > -1 } and 
@math{ m > -1}.  When @math{ | m | > n } and @math{ n >= 0},
we have   @math{assoc_legendre_p (n, m, x) = 0}.
Reference: A&S 22.5.37 page 779,  A&S 8.6.6 (second 
equation) page 334, and A&S 8.2.5 page 333.

@code{load ("specfun")} loads this function.

See @ref{assoc_legendre_q}, @ref{legendre_p}, and @ref{legendre_q}.
@end defun

@anchor{assoc_legendre_q}
@defun assoc_legendre_q (@var{n}, @var{m}, @var{x})

Returns the associated Legendre function
of the second kind for  integers @math{ n > -1 } and 
@math{ m > -1}. 

Reference: Gradshteyn and Ryzhik  8.706 page 1000.

@code{load ("specfun")} loads this function.

See also @ref{assoc_legendre_p}, @ref{legendre_p}, and @ref{legendre_q}.
@end defun

@anchor{chebyshev_t}
@defun   chebyshev_t (@var{n}, @var{x})

Returns the Chebyshev function of the first kind
for  integers @math{ n > -1}.

Reference: A&S 22.5.31 page 778 and A&S 6.1.22 page 256.

@code{load ("specfun")} loads this function.

See also @ref{chebyshev_u}.

@end defun

@anchor{chebyshev_u}
@defun   chebyshev_u (@var{n}, @var{x})

Returns the Chebyshev function of the 
second kind for integers @math{ n > -1}.

Reference: A&S, 22.8.3 page 783  and A&S 6.1.22 page 256. 

@code{load ("specfun")} loads this function.

See also @ref{chebyshev_t}.

@end defun

@anchor{gen_laguerre}
@defun   gen_laguerre (@var{n}, @var{a}, @var{x})

Returns the generalized Laguerre polynomial
for  integers @math{ n > -1}.

@code{load ("specfun")} loads this function.

Reference: table on page 789 in A&S.
@end defun

@anchor{hermite}
@defun hermite (@var{n}, @var{x})

Returns the Hermite polynomial for
integers @math{ n > -1}.

@code{load ("specfun")} loads this function.

Reference:  A&S 22.5.40 and 22.5.41, page 779.

@end defun

@anchor{jacobi_p}
@defun  jacobi_p (@var{n}, @var{a}, @var{b}, @var{x})

Returns the Jacobi polynomial for
integers @math{ n > -1 } and @math{ a } and @math{ b }
symbolic or @math{ a > -1}  and @math{b > -1}.  
(The Jacobi polynomials are actually defined for all
@math{ a } and @math{ b }; however, the Jacobi polynomial
weight @math{ (1-x)^a(1+x)^b} isn't integrable for @math{ a <= -1} or  
@math{ b <= -1}.) 

When @math{a, b}, and @math{ x } are floats (but not bfloats)  
specfun calls a special modedeclared version of @math{jacobi_p}.
For numerical values, the modedeclared version is much 
faster than the other version. Many  functions in specfun are 
computed as a special case of the  Jacobi polynomials; they also 
enjoy the  speed boost from the modedeclared version of 
@math{ jacobi}.

If @math{ n } has been declared to be an integer, 
@math{jacobi_p (n, a, b, x)} returns a summation representation
for the Jacobi function. Because Maxima simplifies 
@math{0^0}  to @math{ 0 } in a sum, two terms of the sum are
added outside the summation.

@code{load ("specfun")} loads this function.

Reference:  table on page 789 in A&S.

@c NEEDS EXAMPLES
@end defun

@anchor{laguerre}
@defun  laguerre (@var{n}, @var{x})

Returns the Laguerre polynomial for 
integers @math{ n > -1}.  

Reference: A&S 22.5.16, page 778 and A&S page 789.

@code{load ("specfun")} loads this function.

See also @ref{gen_laguerre}.

@end defun

@anchor{legendre_p}
@defun  legendre_p (@var{n}, @var{x})

Returns the Legendre polynomial of the 
first kind for  integers @math{ n > -1}.  

Reference: A&S 22.5.35 page 779.

@code{load ("specfun")} loads this function.

See @ref{legendre_q}.

@end defun

@anchor{legendre_q}
@defun  legendre_q (@var{n}, @var{x})

Returns the Legendre polynomial of the 
first kind for  integers @math{ n > -1}.  

Reference: A&S 8.6.19 page 334.

@code{load ("specfun")} loads this function.

See also @ref{legendre_p}.

@end defun

@anchor{spherical_bessel_j}
@defun spherical_bessel_j (@var{n}, @var{x})

Returns the spherical Bessel function of
the first kind for  integers @math{ n > -1}.  

Reference: A&S 10.1.8 page 437 and A&S 10.1.15 page 439.

@code{load ("specfun")} loads this function.

See also @ref{spherical_hankel1}, @ref{spherical_hankel2}, 
and @ref{spherical_bessel_y}.

@end defun

@anchor{spherical_bessel_y}
@defun spherical_bessel_y (@var{n}, @var{x})

Returns the spherical Bessel function of
the second kind for  integers @math{ n > -1}.  

Reference: A&S 10.1.9 page 437 and 10.1.15 page 439.

@code{load ("specfun")} loads this function.

See also @ref{spherical_hankel1}, @ref{spherical_hankel2}, 
and @ref{spherical_bessel_y}.

@end defun

@anchor{spherical_hankel1}
@defun spherical_hankel1 (@var{n}, @var{x})

Returns the spherical hankel function  of the
first kind for  integers @math{ n > -1}.  

Reference: A&S 10.1.36 page 439.

@code{load ("specfun")} loads this function.

See also @ref{spherical_hankel2}, @ref{spherical_bessel_j}, and
@ref{spherical_bessel_y}.

@end defun

@anchor{spherical_hankel2}
@defun spherical_hankel2 (@var{n}, @var{x})

Returns the spherical hankel function  of the
second kind for  integers @math{ n > -1}.  

Reference:  A&S 10.1.17 page 439.

@code{load ("specfun")} loads this function.

See also @ref{spherical_hankel1}, @ref{spherical_bessel_j}, and
@ref{spherical_bessel_y}.

@end defun

@anchor{spherical_harmonic}
@defun spherical_harmonic (@var{n}, @var{m}, @var{x}, @var{y})

Returns the spherical harmonic function
for integers @math{ n > -1} and @math{ | m | <= n }.

Reference:  Merzbacher 9.64.

@code{load ("specfun")} loads this function.

See also @ref{assoc_legendre_p}.

@end defun

@anchor{ultraspherical}
@defun ultraspherical (@var{n}, @var{a}, @var{x})

Returns the ultraspherical polynomials for  
integers @math{ n > -1}.  The ultraspherical polynomials are
also known as Gegenbauer polynomials.

Reference: A&S 22.5.27

@code{load ("specfun")} loads this function.

See also @ref{jacobi_p}.

@end defun

