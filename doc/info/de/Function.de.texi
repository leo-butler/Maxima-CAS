@c -----------------------------------------------------------------------------
@c File        : Function.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Function.texi revision 1.53
@c Translation : Dr. Dieter Kaiser
@c Date        : 14.11.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Funktionsdefinitionen::
* Funktionen::
* Makros::
* Funktionen und Variablen f@"ur Funktionsdefinitionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Funktionsdefinitionen, Funktionen, Funktionsdefinitionen, Funktionsdefinitionen
@section Einf@"uhrung in Funktionsdefinitionen

@c -----------------------------------------------------------------------------
@node Funktionen, Makros, Einf@"uhrung in Funktionsdefinitionen, Funktionsdefinitionen
@section Funktionen

@c @opencatbox
@c @category{Function definition} @category{Programming}
@c @closecatbox

@c -----------------------------------------------------------------------------
@subsection Einfache Funktionen

@c To define a function in Maxima you use the @code{:=} operator. E.g.

Eine Maxima-Funktion wird mit dem Operator @code{:=} definiert. Im folgenden 
wird die Funktion @code{f} definiert:

@example
f(x) := sin(x)
@end example

@c defines a function @code{f}. Anonmyous functions may also be created using 
@c @code{lambda}. For example

@noindent
Funktionen, die mit der Funktion @code{lambda} definiert werden, sind anonyme 
Funktionen, die keinen Namen haben. Diese werden auch @code{lambda}-Ausdr@"ucke
genannt:

@example
lambda ([i, j], ...)
@end example

@c @noindent
@c can be used instead of @code{f} where
@c would return a list with 1 added to each term.

@noindent
Anonyme Funktionen k@"onnen @"uberall dort genutzt werden, wo eine Funktion als
Argument erwartet wird. Das folgene Beispiel gibt eine Liste zur@"uck, bei der
jedes Element mit 1 addiert wurde:

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@c You may also define a function with a variable number of arguments, by 
@c having a final argument which is assigned to a list of the extra arguments:

Ist das letzte Argument einer Funktion eine Liste, kann auch eine variable
Anzahl an Argumenten an die Funktion @"ubergeben werden:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

@c The right hand side of a function is an expression.  Thus if you want a
@c  sequence of expressions, you do
@c and the value of @var{exprn} is what is returned by the function.

Die rechte Seite einer Funktionsdefinition ist ein Ausdruck. Mehrere Ausdr@"ucke 
werden durch Kommata getrennt und mit Klammern umgegeben. Das Ergebnis der
Funktion ist der Wert des letzten Ausdruck @var{exprn}:

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

@c If you wish to make a @code{return} from some expression inside the
@c function then you must use @code{block} and @code{return}.

Einen R@"ucksprung mit @code{return} aus einer Funktion ist m@"oglich, wenn die
Definition der Funktion in einen Block @code{block} eingef@"ugt wird:

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

@c is itself an expression, and so could take the place of the right hand side 
@c of a function definition.  Here it may happen that the return happens earlier 
@c than the last expression.

Das obige Beispiel ist ein Ausdruck, der entweder @code{exprn} oder den Wert
des Symbols @code{a} als Ergebnis hat.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES

@c The first @code{[]} in the block, may contain a list of variables and
@c variable assignments, such as @code{[a: 3, b, c: []]}, which would cause the
@c three variables @code{a},@code{b},and @code{c} to not refer to their
@c global values, but rather have these special values for as long as the
@c code executes inside the @code{block}, or inside functions called from
@c inside the @code{block}.  This is called @i{dynamic} binding, since the
@c variables last from the start of the block to the time it exits.  Once
@c you return from the @code{block}, or throw out of it, the old values (if
@c any) of the variables will be restored.   It is certainly a good idea
@c to protect your variables in this way.   Note that the assignments
@c in the block variables, are done in parallel.   This means, that if
@c you had used @code{c: a} in the above, the value of @code{c} would
@c have been the value of @code{a} at the time you just entered the block,
@c but before @code{a} was bound.   Thus doing something like

Das erste paar Klammern @code{[]} in eine Block @code{block} enth@"alt die
Definition von lokalen Variablen wie zum Beispiel @code{[a: 3, b, c: []]}.
Die Variablen sind au@ss{}erhalb des Blocks nicht sichtbar und die Werte von 
globalen Variablen werden von den lokalen Werten @"uberschrieben. Au@ss{}erhalb 
des Blocks haben die Variablen, wenn vorhanden, wieder ihre alten Werte. Die 
Zuweisungen der Werte an die lokalen Variablen wird parallel durchgef@"uhrt. 

Im folgenden Beispiel wird der Wert der globalen Variablen @var{a} der lokalen 
Variablen @var{a} zugewiesen. @"Anderungen von @var{a} im Block wirken sich 
nicht auf den globalen Wert der Variablen aus.

@example
block ([a: a], expr1, ... a: a+3, ..., exprn)
@end example

@c will protect the external value of @code{a} from being altered, but
@c would let you access what that value was.   
@c Thus the right hand side of the assignments, is evaluated in the entering 
@c context, before any binding occurs.
@c Using just @code{block ([x], ...} would cause the @code{x} to have itself
@c as value, just as if it would have if you entered a fresh Maxima session.

Die Anweisung @code{block ([x], ...} bewirkt, dass @code{x} als lokale Variable
ohne einen Wert verwendet werden kann.

@c The actual arguments to a function are treated in exactly same way as the 
@c variables in a block.  Thus in

Die Argumente einer Funktion werden in gleicher Weise wie lokal definierte
Variable behandelt. Die folgende Defintion

@example
f(x) := (expr1, ..., exprn);
@end example

mit

@example
f(1);
@end example

@c we would have a similar context for evaluation of the expressions
@c as if we had done

hat denselben Effekt wie der folgende Block:

@example
block ([x: 1], expr1, ..., exprn)
@end example

@c Inside functions, when the right hand side of a definition, may be computed 
@c at runtime, it is useful to use @code{define} and possibly @code{buildq}.

Muss innerhalb von Funktionen die rechte Seite einer Defintion berechnet werden,
kann es sinnvoll sein, die Funktion @code{define} oder auch @code{buildq} zu
nutzen.

@c -----------------------------------------------------------------------------
@subsection Array-Funktionen

@c An array function stores the function value the first time it is called with 
@c a given argument, and returns the stored value, without recomputing it, when 
@c that same argument is given. Such a function is often called a 
@c @i{memoizing function}.

Eine Array-Funktion speichert bei dem ersten Aufruf den Funktionswert zu dem 
Argument. Wird die Array-Funktion mit demselben Argument aufgerufen, wird der
gespeicherte Wert zur@"uckgeben, ohne diesen neu zu berechnen. Dies wird auch
Memoisation genannt.

@c Array function names are appended to the global list @code{arrays} (not the 
@c global list @code{functions}). @code{arrayinfo} returns the list of arguments 
@c for which there are stored values, and @code{listarray} returns the stored 
@c values. @code{dispfun} and @code{fundef} return the array function 
@c definition.

Die Namen der Array-Funktionen werden in die Informationsliste @code{arrays}
und nicht in die Liste @code{functions} eingetragen. @code{arrayinfo} gibt eine
Liste der Argumente zur@"uck, f@"ur die Werte gespeichert sind und 
@code{listarrays} gibt die Werte zur@"uck. @code{dispfun} und @code{fundef} 
geben die Definition der Array-Funktion zur@"uck.

@c @code{arraymake} constructs an array function call, analogous to 
@c @code{funmake} for ordinary functions. @code{arrayapply} applies an array 
@c function to its arguments, analogous to @code{apply} for ordinary functions. 
@c There is nothing exactly analogous to @code{map} for array functions, 
@c although @code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} or 
@c @code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, where @var{L} is a list,
@c are not too far off the mark.

@code{arraymake} erzeugt den Aufruf einer Array-Funktion. Dies ist analog zu
der Funktion @code{funmake} f@"ur gew@"ohnliche Funktionen. @code{arrayapply}
wendet eine Array-Funktion auf die Argumente an. Dies entspricht der Funktion
@code{apply} f@"ur gew@"ohnliche Funktionen. Die Funktion @code{map} hat keine
Entsprechung f@"ur Array-Funktionen. Vergleichbare Konstruktionen sind
@code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} oder 
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, wobei @var{L} eine Liste
ist.

@c @code{remarray} removes an array function definition (including any stored 
@c function values), analogous to @code{remfunction} for ordinary functions.

@code{remarray} entfernt die Definition einer Array-Funktion einschlie@ss{}lich 
der gespeicherten Werte. Dies entspricht @code{remfunction} f@"ur gew@"ohnliche
Funktionen.

@c @code{kill(@var{a}[@var{x}])} removes the value of the array function @var{a}
@c stored for the argument @var{x}; the next time @var{a} is called with 
@c argument @var{x}, the function value is recomputed. However, there is no way 
@c to remove all of the stored values at once, except for @code{kill(@var{a})} 
@c or @code{remarray(@var{a})}, which also remove the function definition.

@code{kill(@var{a}[@var{x}])} entfernt den f@"ur das Argument @var{x} 
gespeicherten Wert einer Array-Funktion @var{a}. Beim n@"achsten Aufruf von 
@var{a} mit dem Argument @var{x} wird der Funktionswert neu berechnet. Es gibt
keine M@"oglichkeit, alle gespeicherten Wert zu l@"oschen. Die Kommandos
@code{kill(@var{a})} und @code{remarray(@var{a})} l@"oschen alle Werte
einschlie@ss{}lich der Definition der Funktion.

@c -----------------------------------------------------------------------------
@node Makros, Funktionen und Variablen f@"ur Funktionsdefinitionen, Funktionen, Funktionsdefinitionen
@section Makros

@c --- 02.12.2010 DK -----------------------------------------------------------
@anchor{buildq}
@deffn {Funktion} buildq (@var{L}, @var{expr})

@c Substitutes variables named by the list @var{L} into the expression 
@c @var{expr}, in parallel, without evaluating @var{expr}. The resulting 
@c expression is simplified, but not evaluated, after @code{buildq} carries out 
@c the substitution.

Die Namen der Variablen der Liste @var{L} werden in den Ausdruck @var{expr}
substituiert. Die Substitution wird parallel ausgef@"uhrt. Das Ergebnis der
Substitution wird vereinfacht, aber nicht ausgewertet.

@c The elements of @var{L} are symbols or assignment expressions 
@c @code{@var{symbol}: @var{value}}, evaluated in parallel. That is, the binding
@c of a variable on the right-hand side of an assignment is the binding of that
@c variable in the context from which @code{buildq} was called, not the binding 
@c of that variable in the variable list @var{L}. If some variable in @var{L} is 
@c not given an explicit assignment, its binding in @code{buildq} is the same as
@c in the context from which @code{buildq} was called.

Die Elemente der Liste @var{L} sind Symbole oder Zuweisungen 
@code{@var{symbol}: @var{value}}. Zuweisungen werden parallel ausgewertet.
Der Wert einer Variablen auf der rechten Seite einer Zuweisung ist der globale
Wert in dem Kontext in dem @code{buildq} aufgerufen wird und nicht der lokale
Wert einer vorhergenden Zuweisung. Erh@"alt eine Variable keinen Wert, dann 
beh@"alt die Variable den globalen Wert.

@c Then the variables named by @var{L} are substituted into @var{expr} in 
@c parallel. That is, the substitution for every variable is determined before 
@c any substitution is made, so the substitution for one variable has no effect 
@c on any other.

Dann werden die in der Liste @var{L} enthaltenen Variablen parallel in den 
Ausdruck @var{expr} substituiert.

@c If any variable @var{x} appears as @code{splice (@var{x})} in @var{expr},
@c then @var{x} must be bound to a list, and the list is spliced (interpolated) 
@c into @var{expr} instead of substituted.

Enth@"alt @var{expr} Ausdr@"ucke der Form @code{splice(@var{x})}, muss die 
Variable @var{x} eine Liste sein. Die Liste wird in den Ausdruck eingef@"ugt.

@c Any variables in @var{expr} not appearing in @var{L} are carried into the 
@c result verbatim, even if they have bindings in the context from which 
@c @code{buildq} was called.

Variablen in @var{expr}, die nicht in @var{L} enthalten sind, werden nicht
durch einen Wert ersetzt, auch wenn es eine globale Variable mit demselben
Namen gibt.

Beispiele:

@c @code{a} is explicitly bound to @code{x}, while @code{b} has the same binding 
@c (namely 29) as in the calling context, and @code{c} is carried through 
@c verbatim. The resulting expression is not evaluated until the explicit 
@c evaluation @code{''%}.

Der Variable @code{a} wird der Wert zugewiesen. Die Variable @code{b} erh@"alt
den globalen Wert. Die Variable @code{c} hat keinen Wert. Das Ergebnis ist
ein nicht ausgewerteter Ausdruck. Die Auswertung wird mit dem 
Quote-Quote-Opearator erzwungen.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@c @code{e} is bound to a list, which appears as such in the arguments of 
@c @code{foo}, and interpolated into the arguments of @code{bar}.

@code{e} ist eine Liste, die einmal als Argument der Funktion @code{foo}
vorliegt und zum anderen in die Argumentliste der Funktion @code{bar} 
eingef@"ugt wird.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

@c The result is simplified after substitution. If simplification were applied 
@c before substitution, these two results would be the same.

Das Ergebnis wird nach der Substitution vereinfacht, ansonsten h@"atten die
beiden folgenden Beispiele dasselbe Ergebnis.

@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

@c The variables in @var{L} are bound in parallel; if bound sequentially, the 
@c first result would be @code{foo (b, b)}. Substitutions are carried out in 
@c parallel; compare the second result with the result of @code{subst}, which 
@c carries out substitutions sequentially.

Die Variablen der Liste @var{L} erhalten ihren Wert parallel, ansonsten w@"are
das erste Ergebnis @code{foo(b,b)}. Substitutionen werden parallel ausgef@"uhrt.
Im Gegensatz dazu werden die Substitution mit der Funktion @code{subst}
nacheinander ausgef@"uhrt.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], 
@c               bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], 
@c              bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
              bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
             bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

@c Construct a list of equations with some variables or expressions on the 
@c left-hand side and their values on the right-hand side. @code{macroexpand} 
@c shows the expression returned by @code{show_values}.

Konstruktion einer List mit Gleichungen mit Variablen oder Ausdr@"ucken auf der
linken Seite und deren Werten auf der rechten Seite. Die Funktion
@code{macroexpand} expandiert das Makro @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c show_values (a, b, c - a - b);
@c macroexpand (show_values (a, b, c - a - b));
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
@end example

@c Given a function of several arguments, create another function for which 
@c some of the arguments are fixed.

Konstruktion einer Funktion.

@c ===beg===
@c curry (f, [a]) :=
@c         buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
@c by3 : curry ("*", 3);
@c by3 (a + b);
@c ===end===
@example
(%i1) curry (f, [a]) :=
        buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
(%i2) by3 : curry ("*", 3);
(%o2)        lambda([[x]], apply(*, append([3], x)))
(%i3) by3 (a + b);
(%o3)                       3 (b + a)
@end example

@c @opencatbox
@c @category{Function definition}
@c @closecatbox
@end deffn

@c --- 04.12 2010 DK -----------------------------------------------------------
@anchor{macroexpand}
@deffn {Funktion} macroexpand (@var{expr})

@c Returns the macro expansion of @var{expr} without evaluating it, when 
@c @code{expr} is a macro function call. Otherwise, @code{macroexpand} returns 
@c @var{expr}.

Ist @var{expr} eine Makrodefinition, wird das Makro expandiert, ohne dass es 
ausgewertet wird. Ansonsten wird @var{expr} zur@"uckgegeben.

@c If the expansion of @var{expr} yields another macro function call,
@c that macro function call is also expanded.

Ist die Expansion des Makros selbst ein Makro, wird dieses Makro wiederholt
expandiert.

@c @code{macroexpand} quotes its argument. However, if the expansion of a macro 
@c function call has side effects, those side effects are executed.

@code{macroexpand} wertet das Argument @var{expr} nicht aus. Hat die Expansion
des Makros Seiteneffekte, dann werden diese ausgef@"uhrt.

@c See also @code{::=}, @code{macros}, and @code{macroexpand1}.

Siehe auch @mrefcomma{::=} @mref{Makros} und @mrefdot{macroexpand1}

Beispiele:

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn

@c --- 04.12.2010 DK -----------------------------------------------------------
@anchor{macroexpand1}
@deffn {Funktion} macroexpand1 (@var{expr})

@c Returns the macro expansion of @var{expr} without evaluating it, when 
@c @code{expr} is a macro function call. Otherwise, @code{macroexpand1} returns 
@c @var{expr}.

Gibt die Makro-Expansion von @var{expr} zur@"uck, ohne das Ergebnis auszuwerten.
Ist @var{expr} keine Makro-Funktion gibt @code{macroexpand1} das Argument
@var{expr} zur@"uck.

@c @code{macroexpand1} quotes its argument. However, if the expansion of a macro
@c function call has side effects, those side effects are executed.

@code{macroexpand1} wertet das Argument nicht aus. Hat die Expansion des Makros
Seiteneffekte, dann werden diese ausgef@"uhrt.

@c If the expansion of @var{expr} yields another macro function call, that 
@c macro function call is not expanded.

Enth@"alt die Expansion @var{expr} wiederum Makros, werden diese im Unterschied
zur Funktion @code{macroexpand} nicht expandiert.

Siehe auch @mrefcomma{::=} @mref{Makros} und @mrefdot{macroexpand}

Beispiele:

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn

@c --- 19.11.2010 DK -----------------------------------------------------------
@anchor{macros}
@defvr {Systemvariable} macros
Standardwert: @code{[]}

@c @code{macros} is the list of user-defined macro functions. The macro function
@c definition operator @code{::=} puts a new macro function onto this list, and 
@c @code{kill}, @code{remove}, and @code{remfunction} remove macro functions 
@c from the list. See also @code{infolists}.

@code{macros} ist eine Informationsliste, die die vom Nutzer mit dem Operator
@code{::=} definierten Makro-Funktionen enth@"alt. Wird die Makro-Funktion mit 
einer der Funktionen @code{kill}, @code{remove} oder @code{remfunction} 
gel@"oscht, wird der Eintrag aus der Informationsliste entfernt. Siehe auch 
@mrefdot{infolists}

@c @opencatbox
@c @category{Function definition} @category{Global variables}
@c @closecatbox
@end defvr

@c --- 27.12.2010 DK -----------------------------------------------------------
@anchor{remfunction}
@deffn  {Funktion} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} remfunction (all)

@c Unbinds the function definitions of the symbols @var{f_1}, ..., @var{f_n}.
@c The arguments may be the names of ordinary functions (created by @code{:=} 
@c or @code{define}) or macro functions (created by @code{::=}).

Hebt die Bindung der Symbole @var{f_1}, ..., @var{f_n} an ihren 
Funktionsdefinitionen auf. Die Argumente k@"onnen die Namen von Funktionen sein, 
die durch @code{:=} oder @code{define} definiert wurden sowie Makro-Funktionen, 
die durch @code{::=} definiert wurden.

@c @code{remfunction (all)} unbinds all function definitions.

@code{remfunction(all)} entfernt alle Bindungen von Funktionsdefinitionen. 

@c @code{remfunction} quotes its arguments.

@code{remfunction} wertet seine Argumente nicht aus.

@c @code{remfunction} returns a list of the symbols for which the function 
@c definition was unbound. @code{false} is returned in place of any symbol for 
@c which there is no function definition.

@code{remfunction} gibt eine Liste mit den Symbolen zur@"uck, die von ihren 
Funktionsdefinitionen entbunden wurden. @code{false} wird statt der Symbole 
zur@"uckgegeben, f@"ur die es keine Funktionsdefinition gibt.

@c @code{remfunction} does not apply to array functions or subscripted functions.
@c @code{remarray} applies to those types of functions.

@code{remfunction} kann nicht auf Array-Funktionen und indizierte Funktionen
angewendet werden. F@"ur diese Funktionen kann @code{remarray} verwendet werden.

@c @opencatbox
@c @category{Funktionsdefinitionen}
@c @closecatbox
@end deffn

@c --- 04.12.2010 DK -----------------------------------------------------------
@anchor{splice}
@deffn {Funktion} splice (@var{a})

@c Splices (interpolates) the list named by the atom @var{a} into an expression,
@c but only if @code{splice} appears within @code{buildq}; otherwise, 
@c @code{splice} is treated as an undefined function. If appearing within 
@c @code{buildq} as @var{a} alone (without @code{splice}), @var{a} is 
@c substituted (not interpolated) as a list into the result. The argument of 
@c @code{splice} can only be an atom; it cannot be a literal list or an 
@c expression which yields a list.

Die Funktion @code{splice} kann nur im Zusammenhang mit der Funktion 
@code{buildq} genutzt werden. Das Argument @var{a} bezeichnet eine Liste, die
an Stelle von @code{splice(a)} in einen Ausdruck eingef@"ugt wird. @var{a} kann
nicht selbst eine Liste sein oder ein Ausdruck sein, der zu einer Liste 
auswertet.

@c Typically @code{splice} supplies the arguments for a function or operator.
@c For a function @code{f}, the expression @code{f (splice (@var{a}))} within 
@c @code{buildq} expands to @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}.
@c For an operator @code{o}, the expression @code{"o" (splice (@var{a})} within 
@c @code{buildq} expands to @code{"o" (@var{a}[1], @var{a}[2],@var{a}[3], ...)},
@c where @code{o} may be any type of operator (typically one which takes 
@c multiple arguments). Note that the operator must be enclosed in double quotes
@c @code{"}.

@c TODO: TEXT NICHT UEBERSETZT. BESSER ALS GUTE BEISPIELE DOKUMENTIEREN!

Beispiele:

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@c @opencatbox
@c @category{Function definition}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Funktionsdefinitionen, , Makros, Funktionsdefinitionen
@section Funktionen und Variablen f@"ur Funktionsdefinitionen

@c --- 04.12.2010 DK -----------------------------------------------------------
@anchor{apply}
@deffn {Funktion} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])

@c Constructs and evaluates an expression 
@c @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.

Konstruiert den Ausdruck @code{@var{F}(@var{arg_1}, ..., @var{arg_n})} und 
wertet diesen aus.

@c @code{apply} does not attempt to distinguish array functions from ordinary 
@c functions; when @var{F} is the name of an array function, @code{apply} 
@c evaluates @code{@var{F}(...)} (that is, a function call with parentheses 
@c instead of square brackets). @code{arrayapply} evaluates a function call with
@c square brackets in this case.

@code{apply} versucht nicht Array-Funktionen von gew@"ohnlichen Funktionen zu
unterscheiden. Ist @var{F} der Name eine Array-Funktion, wertet @code{apply}
den Ausdruck @code{@var{F}(...)} aus. @code{arrayapply} entspricht der 
Funktion @code{apply}, wenn @var{F} eine Array-Funktion ist.

Beispiele:

@c @code{apply} evaluates its arguments. In this example, @code{min} is applied 
@c to the value of @code{L}.

@code{apply} wertet die Argumente aus. In diesem Beispiel wird die Funktion
@code{min} auf die Liste @code{L} angewendet.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@c @code{apply} evaluates arguments, even if the function @var{F} quotes them.

@code{apply} wertet die Argumente auch dann aus, wenn die Funktion @code{F}
die Auswertung ihrer Argumente unterdr@"uckt.

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@c @code{apply} evaluates the function name @var{F}. Single quote @code{'} 
@c defeats evaluation. @code{demoivre} is the name of a global variable and also
@c a function.

@code{apply} wertet den Namen der Funktion @var{F} aus. Mit dem Quote-Operator
@code{'} wird die Auswertung unterdr@"uckt. @code{demoivre} ist der Name einer
globalen Optionsvariable und einer Funktion.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{define}
@deffn  {Funktion} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
@deffnx {Funktion} define (@var{f}[@var{x_1}, ..., @var{x_n}], @var{expr})
@deffnx {Funktion} define (funmake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Funktion} define (arraymake (@var{f}, [@var{x_1}, ..., @var{x_n}]), @var{expr})
@deffnx {Funktion} define (ev (@var{expr_1}), @var{expr_2})

@c Defines a function named @var{f} with arguments @var{x_1}, ..., @var{x_n} and
@c function body @var{expr}. @code{define} always evaluates its second argument
@c (unless explicitly quoted). The function so defined may be an ordinary Maxima
@c function (with arguments enclosed in parentheses) or an array function (with
@c arguments enclosed in square brackets).

Definiert eine Funktion mit dem Namen @var{f} und den Argumenten @var{x1}, ...,
@var{x_n} und dem Funktionsk@"orper @var{expr}. @code{define} wertet das zweite
Argument immer aus.


 When the last or only function argument @var{x_n} is a list of one element, 
 the function defined by @code{define} accepts a variable number of arguments.
 Actual arguments are assigned one-to-one to formal arguments @var{x_1}, ..., 
 @var{x_(n - 1)}, and any further actual arguments, if present, are assigned 
 to @var{x_n} as a list.

 When the first argument of @code{define} is an expression of the form
 @code{@var{f}(@var{x_1}, ..., @var{x_n})} or @code{@var{f}[@var{x_1}, ..., 
 @var{x_n}]}, the function arguments are evaluated but @var{f} is not 
 evaluated, even if there is already a function or variable by that name.

 When the first argument is an expression with operator @code{funmake}, 
 @code{arraymake}, or @code{ev}, the first argument is evaluated; this allows 
 for the function name to be computed, as well as the body.

 All function definitions appear in the same namespace; defining a function 
 @code{f} within another function @code{g} does not automatically limit the 
 scope of @code{f} to @code{g}. However, @code{local(f)} makes the definition 
 of function @code{f} effective only within the block or other compound 
 expression in which @code{local} appears.

 If some formal argument @var{x_k} is a quoted symbol (after evaluation), the 
 function defined by @code{define} does not evaluate the corresponding actual 
 argument. Otherwise all actual arguments are evaluated.

 See also @code{:=} and @code{::=}.

Beispiele:

 @code{define} always evaluates its second argument (unless explicitly quoted).

@c ===beg===
@c expr : cos(y) - sin(x);
@c define (F1 (x, y), expr);
@c F1 (a, b);
@c F2 (x, y) := expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
@end example

 The function defined by @code{define} may be an ordinary Maxima function or 
 an array function.

@c ===beg===
@c define (G1 (x, y), x.y - y.x);
@c define (G2 [x, y], x.y - y.x);
@c ===end===
@example
(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
@end example

 When the last or only function argument @var{x_n} is a list of one element,
 the function defined by @code{define} accepts a variable number of arguments.

@c ===beg===
@c define (H ([L]), '(apply ("+", L)));
@c H (a, b, c);
@c ===end===
@example
(%i1) define (H ([L]), '(apply ("+", L)));
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

 When the first argument is an expression with operator @code{funmake}, 
 @code{arraymake}, or @code{ev}, the first argument is evaluated.

@c ===beg===
@c [F : I, u : x];
@c funmake (F, [u]);
@c define (funmake (F, [u]), cos(u) + 1);
@c define (arraymake (F, [u]), cos(u) + 1);
@c define (foo (x, y), bar (y, x));
@c define (ev (foo (x, y)), sin(x) - cos(y));
@c ===end===
@example
(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
@end example

@c @opencatbox
@c @category{Function definition}
@c @closecatbox
@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Function} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})

@c -----------------------------------------------------------------------------
@anchor{define_variable}
@deffn {Funktion} define_variable (@var{name}, @var{default_value}, @var{mode})

Introduces a global variable into the Maxima environment.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} is useful in user-written packages, which are often translated or compiled.

@code{define_variable} carries out the following steps:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} declares the mode of @var{name} to the translator.
See @code{mode_declare} for a list of the possible modes.

@item
If the variable is unbound, @var{default_value} is assigned to @var{name}.

@item
@code{declare (@var{name}, special)} declares it special.
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
Associates @var{name} with a test function
to ensure that @var{name} is only assigned values of the declared mode.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argument is a documentation string.  When
@c @code{translate_file} is used on a package which includes documentation
@c strings, a second file is output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

The @code{value_check} property can be assigned to any variable which has been defined
via @code{define_variable} with a mode other than @code{any}.
The @code{value_check} property is a lambda expression or the name of a function of one variable,
which is called when an attempt is made to assign a value to the variable.
The argument of the @code{value_check} function is the would-be assigned value.

@code{define_variable} evaluates @code{default_value}, and quotes @code{name} and @code{mode}.
@code{define_variable} returns the current value of @code{name},
which is @code{default_value} if @code{name} was unbound before,
and otherwise it is the previous value of @code{name}.

Examples:

@code{foo} is a Boolean variable, with the initial value @code{true}.
@c ===beg===
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;
@c ===end===
@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} is an integer variable, which must be prime.
@c ===beg===
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then 
@c                            error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;
@c ===end===
@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} is a variable which cannot be assigned a value.
The mode @code{any_check} is like @code{any}, 
but @code{any_check} enables the @code{value_check} mechanism, and @code{any} does not.
@c ===beg===
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then 
@c                  error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;
@c ===end===
@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
                 error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@c @opencatbox
@c @category{Translation and compilation}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Function} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Function} dispfun (all)

Displays the definition of the user-defined functions @var{f_1}, ..., @var{f_n}.
Each argument may be the name of a macro (defined with @code{::=}),
an ordinary function (defined with @code{:=} or @code{define}),
an array function (defined with @code{:=} or @code{define},
but enclosing arguments in square brackets @code{[ ]}),
a subscripted function, (defined with @code{:=} or @code{define},
but enclosing some arguments in square brackets and others in parentheses @code{( )})
one of a family of subscripted functions selected by a particular subscript value,
or a subscripted function defined with a constant subscript.

@code{dispfun (all)} displays all user-defined functions as
given by the @code{functions}, @code{arrays}, and @code{macros} lists,
omitting subscripted functions defined with constant subscripts.

@code{dispfun} creates an intermediate expression label
(@code{%t1}, @code{%t2}, etc.)
for each displayed function, and assigns the function definition to the label.
In contrast, @code{fundef} returns the function definition.

@code{dispfun} quotes its arguments; 
the quote-quote operator @code{'@w{}'} defeats quotation.
@code{dispfun} returns the list of intermediate expression labels corresponding to the displayed functions.

Examples:

@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
@end example

@c @opencatbox
@c @category{Function definition} @category{Display functions}
@c @closecatbox
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{fullmap}
@deffn {Funktion} fullmap (@var{f}, @var{expr_1}, ...)

@c Similar to @code{map}, but @code{fullmap} keeps mapping down all 
@c subexpressions until the main operators are no longer the same.

Die Funktion @code{fullmap} ist vergleichbar mit der Funktion @code{map}. Im 
Unterschied zu der Funktion @code{map} kann @code{fullmap} auf verschachtelte 
Audr@"ucke angewendet werden.

@c @code{fullmap} is used by the Maxima simplifier for certain matrix 
@c manipulations; thus, Maxima sometimes generates an error message concerning 
@c @code{fullmap} even though @code{fullmap} was not explicitly called by the 
@c user.

Intern wird @code{fullmap} von Maxima f@"ur die Vereinfachung von Matrizen 
aufgerufen. Daher k@"onnen bei der Vereinfachung von Matrizen Fehlermeldungen 
im Zusammenhang mit @code{fullmap} auftreten, ohne dass die Funktion direkt 
aufgerufen wurde.

Beispiele:

@c ===beg===
@c a + b * c;
@c fullmap (g, %);
@c map (g, %th(2));
@c ===end===
@example
(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@c @opencatbox
@c @category{Funktionsanwendungen} @category{Ausdr@"ucke}
@c @closecatbox
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{fullmapl}
@deffn {Funktion} fullmapl (@var{f}, @var{list_1}, ...)

@c Similar to @code{fullmap}, but @code{fullmapl} only maps onto lists and 
@c matrices.

Die Funktion @code{fullmapl} ist vergleichbar mit @code{fullmap}. 
@code{fullmapl} kann jedoch nur auf Matrizen und Listen angewendet werden kann.

Beispiele:

@c ===beg===
@c fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
@c ===end===
@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@c @opencatbox
@c @category{Funktionsanwendungen} @category{Ausdr@"ucke}
@c @closecatbox
@end deffn

@c --- 19.11.2010 DK -----------------------------------------------------------
@anchor{functions}
@defvr {Systemvariable} functions
Standardwert: @code{[]}

@c @code{functions} is the list of ordinary Maxima functions in the current 
@c session. An ordinary function is a function constructed by @code{define} or 
@c @code{:=} and called with parentheses @code{()}. A function may be defined at
@c the Maxima prompt or in a Maxima file loaded by @code{load} or @code{batch}.

@code{functions} ist eine Informationsliste, die die vom Benutzer mit dem
Operator @var{:=} oder der Funktion @code{define} definierten Funktionen 
enth@"alt. Siehe @mrefdot{infolists}

@c Array functions (called with square brackets, e.g., @code{F[x]}) and 
@c subscripted functions (called with square brackets and parentheses, e.g., 
@c @code{F[x](y)}) are listed by the global variable @code{arrays}, and not by 
@c @code{functions}.

Array-Funktionen und indizierte Funktionen werden nicht in die Informationsliste
@code{functions}, sondern in die Informationsliste @code{arrays} eingetragen.
Siehe @mrefdot{arrays}

@c Lisp functions are not kept on any list.

Beispiele:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@c @opencatbox
@c @category{Function definition} @category{Global variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{fundef}
@deffn {Function} fundef (@var{f})

Returns the definition of the function @var{f}.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
The argument may be the name of a macro (defined with @code{::=}),
an ordinary function (defined with @code{:=} or @code{define}),
an array function (defined with @code{:=} or @code{define},
but enclosing arguments in square brackets @code{[ ]}),
a subscripted function, (defined with @code{:=} or @code{define},
but enclosing some arguments in square brackets and others in parentheses @code{( )})
one of a family of subscripted functions selected by a particular subscript value,
or a subscripted function defined with a constant subscript.

@code{fundef} quotes its argument;
the quote-quote operator @code{'@w{}'} defeats quotation.

@code{fundef (@var{f})} returns the definition of @var{f}.
In contrast, @code{dispfun (@var{f})} creates an intermediate expression label
and assigns the definition to the label.

@c PROBABLY NEED SOME EXAMPLES HERE
@c @opencatbox
@c @category{Function definition}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{funmake}
@deffn {Function} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])

Returns an expression @code{@var{F}(@var{arg_1}, ..., @var{arg_n})}.
The return value is simplified, but not evaluated,
so the function @var{F} is not called, even if it exists.

@code{funmake} does not attempt to distinguish array functions from ordinary functions;
when @var{F} is the name of an array function,
@code{funmake} returns @code{@var{F}(...)}
(that is, a function call with parentheses instead of square brackets).
@code{arraymake} returns a function call with square brackets in this case.

@code{funmake} evaluates its arguments.

Examples:

@code{funmake} applied to an ordinary Maxima function.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} applied to a macro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} applied to a subscripted function.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} applied to a symbol which is not a defined function of any kind.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

@code{funmake} evaluates its arguments, but not the return value.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example

Maxima simplifies @code{funmake}'s return value.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@c @opencatbox
@c @category{Function application} @category{Expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Function} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Function} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Function} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})

Defines and returns a lambda expression (that is, an anonymous function).
The function may have required arguments @var{x_1}, ..., @var{x_m}
and/or optional arguments @var{L}, which appear within the function body as a list.
The return value of the function is @var{expr_n}.
A lambda expression can be assigned to a variable and evaluated like an ordinary function.
A lambda expression may appear in some contexts in which a function name is expected.

When the function is evaluated,
unbound local variables @var{x_1}, ..., @var{x_m} are created.
@code{lambda} may appear within @code{block} or another @code{lambda};
local variables are established each time another @code{block} or @code{lambda} is evaluated.
Local variables appear to be global to any enclosed @code{block} or @code{lambda}.
If a variable is not local,
its value is the value most recently assigned in an enclosing @code{block} or @code{lambda}, if any,
otherwise, it is the value of the variable in the global environment.
This policy may coincide with the usual understanding of "dynamic scope".

After local variables are established,
@var{expr_1} through @var{expr_n} are evaluated in turn.
The special variable @code{%%}, representing the value of the preceding expression,
is recognized.
@code{throw} and @code{catch} may also appear in the list of expressions.

@code{return} cannot appear in a lambda expression unless enclosed by @code{block},
in which case @code{return} defines the return value of the block and not of the
lambda expression,
unless the block happens to be @var{expr_n}.
Likewise, @code{go} cannot appear in a lambda expression unless enclosed by @code{block}.

@code{lambda} quotes its arguments; 
the quote-quote operator @code{'@w{}'} defeats quotation.

Examples:

@itemize @bullet
@item
A lambda expression can be assigned to a variable and evaluated like an ordinary function.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
A lambda expression may appear in contexts in which a function evaluation is expected.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Argument variables are local variables.
Other variables appear to be global variables.
Global variables are evaluated at the time the lambda expression is evaluated,
unless some special evaluation is forced by some means, such as @code{'@w{}'}.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Lambda expressions may be nested.
Local variables within the outer lambda expression appear to be global to the inner expression
unless masked by local variables of the same names.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Since @code{lambda} quotes its arguments, lambda expression @code{i} below 
does not define a "multiply by @code{a}" function.
Such a function can be defined via @code{buildq}, as in lambda expression @code{i2} below.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
A lambda expression may take a variable number of arguments,
which are indicated by @code{[@var{L}]} as the sole or final argument.
The arguments appear within the function body as a list.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example

@c @opencatbox
@c @category{Function definition}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} macroexpansion
Default value: @code{false}

@code{macroexpansion} controls whether the expansion (that is, the return value) of a macro function
is substituted for the macro function call.
A substitution may speed up subsequent expression evaluations,
at the cost of storing the expansion.

@table @code
@item false
The expansion of a macro function is not substituted for the macro function call.
@item expand
The first time a macro function call is evaluated,
the expansion is stored.
The expansion is not recomputed on subsequent calls;
any side effects (such as @code{print} or assignment to global variables) happen
only when the macro function call is first evaluated.
Expansion in an expression does not affect other expressions
which have the same macro function call.
@item displace
The first time a macro function call is evaluated,
the expansion is substituted for the call,
thus modifying the expression from which the macro function was called.
The expansion is not recomputed on subsequent calls;
any side effects happen only when the macro function call is first evaluated.
Expansion in an expression does not affect other expressions
which have the same macro function call.
@end table

Examples

When @code{macroexpansion} is @code{false},
a macro function is called every time the calling expression is evaluated,
and the calling expression is not modified.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), 
@c                        return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), 
@c                        return (x - 99));
@c macroexpansion: false;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                       return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                       return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

When @code{macroexpansion} is @code{expand},
a macro function is called once,
and the calling expression is not modified.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), 
@c                        return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), 
@c                        return (x - 99));
@c macroexpansion: expand;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                       return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                       return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

When @code{macroexpansion} is @code{expand},
a macro function is called once,
and the calling expression is modified.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), 
@c                        return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), 
@c                        return (x - 99));
@c macroexpansion: displace;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                       return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                       return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

@c @opencatbox
@c @category{Function application} @category{Global flags}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{map}
@deffn {Funktion} map (@var{f}, @var{expr_1}, ..., @var{expr_n})

@c Returns an expression whose leading operator is the same as that of the 
@c expressions @var{expr_1}, ..., @var{expr_n} but whose subparts are the 
@c results of applying @var{f} to the corresponding subparts of the expressions.
@c @var{f} is either the name of a function of @math{n} arguments or is a 
@c @code{lambda} form of @math{n} arguments.

Gibt einen Ausdruck zur@"uck, dessen Hauptoperator derselbe ist, wie der der
Argumente @var{expr_1}, ..., @var{expr_n} aber dessen Operanden das Ergebnis
der Anwendung des Operators @var{f} auf die Teilausdr@"ucke des Ausdrucks sind.
@var{f} ist entweder der Name einer Funktion mit @math{n} Argumenten oder
ein Lambda-Ausdruck mit @math{n} Argumenten.

@c @code{maperror} - if @code{false} will cause all of the mapping functions to 
@c (1) stop when they finish going down the shortest @var{expr_i} if not all of 
@c the @var{expr_i} are of the same length and (2) apply @var{f} to 
@c [@var{expr_1}, @var{expr_2}, ...]  if the @var{expr_i} are not all the same 
@c type of object. If @code{maperror} is @code{true} then an error message will 
@c be given in the above two instances.

Hat @code{maperror} den Wert @code{false}, wird die Anwendung der Funktion 
@var{f} gestoppt, (1) wenn die Anwendung auf den k@"urzesten Ausdruck 
@var{expr_i} beendet ist und die Ausdr@"ucke nicht alle dieselbe L@"ange haben 
oder (2) wenn die Ausdr@"ucke @var{expr_i} einen verschiedenen Typ haben. Hat 
@code{maperror} den Wert @code{true} wird in den obigen F@"allen eine 
Fehlermeldung ausgegeben.

@c One of the uses of this function is to @code{map} a function (e.g. 
@c @code{partfrac}) onto each term of a very large expression where it 
@c ordinarily wouldn't be possible to use the function on the entire expression 
@c due to an exhaustion of list storage space in the course of the computation.

@c TODO: NICHT UEBERSETZT

   @c IN THESE EXAMPLES, SPELL OUT WHAT IS THE MAIN OPERATOR AND SHOW HOW THE 
   @c RESULT FOLLOWS FROM THE DESCRIPTION STATED IN THE FIRST PARAGRAPH

@example
(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map("=",[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


@end example

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mapatom}
@deffn {Funktion} mapatom (@var{expr})

@c Returns @code{true} if and only if @var{expr} is treated by the mapping
@c routines as an atom.  "Mapatoms" are atoms, numbers (including rational 
@c numbers), and subscripted variables.

Gibt den Wert @code{true} zur@"uck, wenn der Ausdruck @var{expr} von Funktionen 
die auf Argumente angewendete werden, als ein Atom betrachtet wird. Als Atome
werden Zahlen, einschlie@ss{}lich rationaler Zahlen und gro@ss{}er 
Gleitkommazahlen, Symbole und indizierte Symbole betrachtet.

   @c WHAT ARE "THE MAPPING ROUTINES", AND WHY DO THEY HAVE A SPECIALIZED NOTION
   @c OF ATOMS ??

@c @opencatbox
@c @category{Predicate functions}
@c @closecatbox
@end deffn

@c NEEDS CLARIFICATION

@c -----------------------------------------------------------------------------
@anchor{maperror}
@defvr {Optionsvariable} maperror
Standwert: @code{true}

@c When @code{maperror} is @code{false}, causes all of the mapping functions, 
@c for example

@c @example
@c map (@var{f}, @var{expr_1}, @var{expr_2}, ...)
@c @end example

@c to (1) stop when they finish going down the shortest @var{expr_i} if not all 
@c of the @var{expr_i} are of the same length and (2) apply @var{f} to 
@c [@var{expr_1}, @var{expr_2}, ...] if the @var{expr_i} are not all the same 
@c type of object.

@c If @code{maperror} is @code{true} then an error message is displayed in the 
@c above two instances.

Hat @code{maperror} den Wert @code{false}, wird die Anwendung der Funktion 
@var{f} gestoppt, (1) wenn die Anwendung auf den k@"urzesten Ausdruck 
@var{expr_i} beendet ist und die Ausdr@"ucke nicht alle dieselbe L@"ange haben 
oder (2) wenn die Ausdr@"ucke @var{expr_i} einen verschiedenen Typ haben. Hat 
@code{maperror} den Wert @code{true} wird in den obigen F@"allen eine 
Fehlermeldung ausgegeben.

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{mapprint}
@defvr {Optionsvariable} mapprint
Standardwert: @code{true}

@c When @code{mapprint} is @code{true}, various information messages from 
@c @code{map}, @code{mapl}, and @code{fullmap} are produced in certain 
@c situations.  These include situations where @code{map} would use 
@c @code{apply}, or @code{map} is truncating on the shortest list.

Hat @code{mapprint} den Wert @code{true}, werden verschiedene Informationen von
den Funktionen @code{map}, @code{mapl} und @code{fullmap} ausgegeben. Dies ist
der Fall, wenn die Funktion @code{map} die Funktion @code{apply} aufruft oder
wenn f@"ur die Funktion @code{map} die Argumente eine verschiedene L@"ange 
haben.

@c If @code{mapprint} is @code{false}, these messages are suppressed.

Hat @code{mapprint} den Wert @code{false}, werden diese Meldungen unterdr@"uckt.

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{maplist}
@deffn {Funktion} maplist (@var{f}, @var{expr_1}, ..., @var{expr_n})

@c Returns a list of the applications of @var{f} to the parts of the expressions
@c @var{expr_1}, ..., @var{expr_n}. @var{f} is the name of a function, or a 
@c lambda expression.

Wendet die Funktion @var{f} auf die Ausdr@"ucke @var{expr_1}, ..., @var{expr_n} 
an und gibt das Ergebnis als eine Liste zur@"uck. @var{f} ist der Name einer 
Funktion oder ein lambda-Ausdruck.

@c @code{maplist} differs from @code{map (@var{f}, @var{expr_1}, ..., 
@c @var{expr_n})} which returns an expression with the same main operator as 
@c @var{expr_i} has (except for simplifications and the case where @code{map} 
@c does an @code{apply}).

Im Unterschied zu @code{maplist} gibt die Funktion @code{map} einen Ausdruck
zur@"uck, der denselben Hauptoperator wie die Ausdr@"ucke @var{expr_i} hat.

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{outermap}
@deffn {Funktion} outermap (@var{f}, @var{a_1}, ..., @var{a_n})

@c Applies the function @var{f} to each one of the elements of the outer product
@c @var{a_1} cross @var{a_2} ... cross @var{a_n}.

Wendet die Funktion @var{f} auf jedes Element des @"au@ss{}eren Produktes der
Argumente @var{a_1} @code{x} @var{a_2} ... @code{x} @var{a_n} an. 

@c @var{f} is the name of a function of @math{n} arguments or a lambda 
@c expression of @math{n} arguments. Each argument @var{a_k} may be a list or 
@c nested list, or a matrix, or any other kind of expression.

@var{f} ist der Name einer Funktion mit @math{n} Argumenten oder ein 
Lambda-Ausdruck mit @math{n} Argumenten. Jedes Argument @var{a_k} kann eine
Liste oder verschachtelte Liste, eine Matrix oder irgendein anderer Ausdruck
sein.

@c The @code{outermap} return value is a nested structure. Let @var{x} be the 
@c return value. Then @var{x} has the same structure as the first list, nested 
@c list, or matrix argument, @code{@var{x}[i_1]...[i_m]} has the same structure 
@c as the second list, nested list, or matrix argument, 
@c @code{@var{x}[i_1]...[i_m][j_1]...[j_n]} has the same structure as the third 
@c list, nested list, or matrix argument, and so on, where @var{m}, @var{n}, ...
@c are the numbers of indices required to access the elements of each argument 
@c (one for a list, two for a matrix, one or more for a nested list). Arguments 
@c which are not lists or matrices have no effect on the structure of the return
@c value.

@c Note that the effect of @code{outermap} is different from that of applying 
@c @var{f} to each one of the elements of the outer product returned by 
@c @code{cartesian_product}. @code{outermap} preserves the structure of the 
@c arguments in the return value, while @code{cartesian_product} does not.

@c TODO: OBIGE UEBERSETZUNG FEHLEN

@c @code{outermap} evaluates its arguments.

@code{outermap} werdet die Argumente aus.

@c See also @code{map}, @code{maplist}, and @code{apply}.

Siehe auch @mrefcomma{map} @mref{maplist} und @mrefdot{apply}

@c CROSS REF OTHER FUNCTIONS HERE ??

Beispiele:

@c Elementary examples of @code{outermap}. To show the argument combinations 
@c more clearly, @code{F} is left undefined.

@c ===beg===
@c outermap (F, [a, b, c], [1, 2, 3]);
@c outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
@c outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
@c outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
@c outermap ("+", [a, b, c], [1, 2, 3]);
@c ===end===
@example
(%i1) outermap(F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap ("+", [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
@end example

@c A closer examination of the @code{outermap} return value. The first, second, 
@c and third arguments are a matrix, a list, and a matrix, respectively. The 
@c return value is a matrix. Each element of that matrix is a list, and each 
@c element of each list is a matrix.

@c ===beg===
@c arg_1 :  matrix ([a, b], [c, d]);
@c arg_2 : [11, 22];
@c arg_3 : matrix ([xx, yy]);
@c xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, 
@c                                                    arg_2, arg_3);
@c xx_1 : xx_0 [1][1];
@c xx_2 : xx_0 [1][1] [1];
@c xx_3 : xx_0 [1][1] [1] [1][1];
@c [op (arg_1), op (arg_2), op (arg_3)];
@c [op (xx_0), op (xx_1), op (xx_2)];
@c ===end===
@example
(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                   arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
@end example

@c @code{outermap} preserves the structure of the arguments in the return value,
@c while @code{cartesian_product} does not.

@c ===beg===
@c outermap (F, [a, b, c], [1, 2, 3]);
@c setify (flatten (%));
@c map (lambda ([L], apply (F, L)), 
@c                      cartesian_product ({a, b, c}, {1, 2, 3}));
@c is (equal (%, %th (2)));
@c ===end===
@example
(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) @{F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)@}
(%i3) map(lambda([L], apply(F, L)),
                     cartesian_product(@{a, b, c@}, @{1, 2, 3@}));
(%o3) @{F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)@}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
@end example

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn



@c NEEDS CLARIFICATION

@c -----------------------------------------------------------------------------
@anchor{scanmap}
@deffn  {Funktion} scanmap (@var{f}, @var{expr})
@deffnx {Funktion} scanmap (@var{f}, @var{expr}, bottomup)

@c Recursively applies @var{f} to @var{expr}, in a top down manner. This is most
@c useful when complete factorization is desired, for example:

Wendet die Funktion @var{f} rekursiv auf alle Teilausdr@"ucke in @var{expr} an. 

Beispiele:

@example
(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
@end example

@c Note the way in which @code{scanmap} applies the given function @code{factor}
@c to the constituent subexpressions of @var{expr}; if another form of 
@c @var{expr} is presented to @code{scanmap} then the result may be different. 
@c Thus, @code{%o2} is not recovered when @code{scanmap} is applied to the 
@c expanded form of @code{exp}:

@example
(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
@end example

@c Here is another example of the way in which @code{scanmap} recursively
@c applies a given function to all subexpressions, including exponents:

Ein weiteres Beispiel f@"ur die Anwendung einer Funktion auf alle 
Teilausdr@"ucke.

@example
(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
@end example

@c @code{scanmap (@var{f}, @var{expr}, bottomup)} applies @var{f} to @var{expr} 
@c in a bottom-up manner.  E.g., for undefined @code{f},

@code{scanmap (@var{f}, @var{expr}, bottomup)} wendet die Funktion @var{f}
Bottom-up auf den Ausdruck @var{expr} an.

@example
scanmap(f,a*x+b) ->
   f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
    -> f(f(a)*f(x))+f(b) ->
     f(f(f(a)*f(x))+f(b))
@end example

@c In this case, you get the same answer both ways.

@c @opencatbox
@c @category{Function application}
@c @closecatbox
@end deffn







@c --- End of file Function.de.texi --------------------------------------------

