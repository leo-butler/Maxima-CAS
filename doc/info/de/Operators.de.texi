@c -----------------------------------------------------------------------------
@c File        : Operators.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Operators.texi revision 1.61
@c Translation : Dr. Dieter Kaiser
@c Date        : 17.10.2010
@c Revision    : 24.02.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu                     
* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren f@"ur Gleichungen::
* Zuweisungsoperatoren::
* Nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Arithmetische Operatoren, Relationale Operatoren, Operatoren, Operatoren
@section Arithmetische Operatoren
@c -----------------------------------------------------------------------------

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{+} 
@anchor{-}
@anchor{*}
@anchor{/}
@anchor{^}
@deffn {Operator} +
@ifinfo
@fnindex Addition
@end ifinfo
@deffnx {Operator} -
@ifinfo
@fnindex Subtraktion
@end ifinfo
@deffnx {Operator} *
@ifinfo
@fnindex Multiplikation
@end ifinfo
@deffnx {Operator} /
@ifinfo
@fnindex Division
@end ifinfo
@deffnx {Operator} ^
@ifinfo
@fnindex Exponentiation
@end ifinfo

Sind die Operatoren der Addition, Multiplikation, Division und Exponentiation.
Wird der Name eines Operators in einem Ausdruck ben@"otigt, k@"onnen die 
Bezeichnungen @code{"+"}, @code{"*"}, @code{"/"} und @code{"^"} verwendet 
werden.

Die Symbole @code{+} und @code{-} repr@"asentieren die un@"are Addition and 
Negation.  Die Namen der Operatoren sind @code{"+"} und @code{"-"}.

Die Subtraktion @code{a - b} wird von Maxima intern als Addition 
@code{a + (- b)} dargestellt.  In der Ausgabe werden die Ausdr@"ucke 
@code{a + (- b)} als Subtraktion @code{a - b} angezeigt.  Maxima erkennt 
@code{"-"} nur als den Namen der un@"aren Negation, nicht jedoch als den 
bin@"aren Operator der Subtraktion.

Die Division @code{a / b} wird von Maxima intern als Multiplikation
@code{a * b^(- 1)} dargestellt.  In der Ausgabe werden die Ausdr@"ucke 
@code{a * b^(- 1)} als Division @code{a / b} angezeigt.  Der Name des Operators
f@"ur die Division ist @code{"/"}.

Die Addition und Multiplikation sind kommutative N-ary-Operatoren.  Die Division 
und Exponentiation sind nicht-kommutative bin@"are Operatoren.

Maxima sortiert die Argumente eines kommutativen Operators und konstruiert eine
kanonische Darstellung.  F@"ur die interne Darstellung wird die Ordnung durch
@mref{orderlessp} bestimmt.  F@"ur die externe Darstellung der Anzeige wird die 
Ordnung mit @mref{ordergreatp} festgelegt.  Ausnahme ist die Multiplikaton.
F@"ur diese sind die interne und die externe Darstellung identisch.

Arithmetische Rechnungen werden mit Zahlen (ganzen Zahlen, rationale Zahlen, 
Gleitkommazahlen und gro@ss{}en Gleitkommazahlen) durchgef@"uhrt.  Mit Ausnahme 
der Exponentiation werden alle arithmetischen Operationen mit Zahlen zu Zahlen 
vereinfacht.  Die Exponentiation vereinfacht zu einer Zahl, wenn eines der 
Argumente eine Gleikommazahl ist, oder wenn das Ergebnis eine ganze 
oder rationale Zahl ist.  In anderen F@"allen kann die Exponentiation zum 
Beispiel zu einer Wurzelfunktion @mref{sqrt} oder wiederum zu einer
Exponentiation vereinfachen.

Bei einer arithmetische Rechnung kann es zur Umwandlung in Gleitkommazahlen
kommen.  Ist eines der Argumente eine gro@ss{}e Gleitkommazahl, so ist auch das
Ergebnis eine gro@ss{}e Gleitkommazahl.  Entsprechend ist das Ergebnis eine
einfache Gleitkommazahl, sofern mindestens eines der Argumente eine einfache
Gleitkommazahl ist.  Treten nur ganze oder rationale Zahlen auf, ist das
Ergebnis wieder eine ganze oder rationale Zahl.

Arithmetische Rechnungen sind Vereinfachungen und keine Auswertungen.  Daher
werden arithmetische Rechnungen auch dann ausgef@"uhrt, wenn die Auswertung des
Ausdrucks mit den Quote-Operator @mref{'} unterdr@"uckt wird.

Arithmetische Operatoren werden elementweise auf Listen angewendet, wenn die
Optionsvariable @mref{listarith} den Wert @code{true} hat.  Auf Matrizen werden
die arithmetischen Operatoren immer elementweise angewendet.  Ist eines der 
Argumente eine Liste oder Matrix und das andere Argument hat einen anderen 
Typ, dann wird dieses Argument mit jedem Element der Liste oder Matrix 
kombiniert.

Beispiele:

Addition und Multiplikation sind kommutative N-ary-Operatoren.  Maxima sortiert
die Operanden und konstruiert eine kanonische Darstellung.  Die Namen der 
Operatoren sind @code{"+"} und @code{"*"}.

@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

Die Division und Exponentiation sind nicht-kommutative bin@"are Operatoren.  Die 
Namen der Operatoren sind @code{"/"} und @code{"^"}.

@example
(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

Subtraktion and Divison werden intern als Addition und Multiplikation 
dargestellt.

@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

Rechnungen werden f@"ur Zahlen ausgef@"uhrt.  Die Umwandlung in Gleitkommazahlen
wird angewendet.

@example
@group
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
@end group
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

Arithmetische Rechnungen sind Vereinfachungen und keine Auswertung.

@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

Arithmetische Rechnungen werden elementweise f@"ur Listen und Matrizen 
ausgef@"uhrt.  Bei Listen wird dies mit der Optionsvariablen
@mref{listarith} kontrolliert.

@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
(%i2) 5 * matrix ([a, x], [h, u]);
                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
@group
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end group
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{**}
@deffn {Operator} **

Ist eine alternative Schreibweise f@"ur den Operator @code{^} der 
Exponentiation.  In der Ausgabe wird entweder @code{^} angezeigt oder der 
Exponent hochgestellt.  Siehe @mrefdot{^}

Die Funktion @mref{fortran} zeigt den Operator der Exponentiation immer als 
@code{**} an, unabh@"angig davon ob @code{**} oder @code{^} eingegeben wird.

Beispiele:

@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{^^}
@deffn {Operator} ^^
@ifinfo
@fnindex Nicht-kommutative Exponentiation
@end ifinfo

Ist der Operator der nicht-kommutativen Exponentiation von Matrizen.  In der 
linearen Ausgabe wird der nicht-kommutative Operator als @code{^^} angezeigt.
In der zweidimensionalen Ausgabe wird der hochgestellte Exponent von spitzen 
Klammern @code{< >} eingeschlossen.

Beispiele:

@example
(%i1) a . a . b . b . b + a * a * a * b * b;
                        3  2    <2>    <3>
(%o1)                  a  b  + a    . b
(%i2) string (a . a . b . b . b + a * a * a * b * b);
(%o2)                  a^3*b^2+a^^2 . b^^3
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{.}
@deffn {Operator} .
@ifinfo
@fnindex Nicht-kommutative Multiplikation
@end ifinfo

Ist der Operator f@"ur die nicht-kommutative Multiplikation von Matrizen.

Siehe auch
@mrefcomma{dot} @mrefcomma{dot0nscsimp} @mrefcomma{dot0simp}@ 
@mrefcomma{dot1simp} @mrefcomma{dotassoc} @mrefcomma{dotconstrules}@ 
@mrefcomma{dotdistrib} @mrefcomma{dotexptsimp} @mref{dotident}@ 
und @mrefdot{dotscrules}
@end deffn

@c -----------------------------------------------------------------------------
@node Relationale Operatoren, Logische Operatoren, Arithmetische Operatoren, Operatoren
@section Relationale Operatoren
@c -----------------------------------------------------------------------------

@c --- 31.10.2010 DK -----------------------------------------------------------
@anchor{<}
@anchor{<=}
@anchor{>=}
@anchor{>}
@deffn {Operator} <
@ifinfo
@fnindex kleiner als
@end ifinfo
@deffnx {Operator} <=
@ifinfo
@fnindex kleiner als oder gleich
@end ifinfo
@deffnx {Operator} >=
@ifinfo
@fnindex gr@"o@ss{}er als oder gleich
@end ifinfo
@deffnx {Operator} >
@ifinfo
@fnindex gr@"o@ss{}er als
@end ifinfo

Die Symbole @code{<}, @code{<=}, @code{>=} und @code{>} repr@"asentieren die 
Operatoren "kleiner als", "kleiner als oder gleich", "gr@"o@ss{}er als oder 
gleich" und "gr@"o@ss{}er als".  Die Namen dieser Operatoren sind jeweils: 
@code{"<"}, @code{"<="}, @code{">="} und @code{">"}.  Diese k@"onnen dort 
eingesetzt werden, wo der Name des Operators ben@"otigt wird.

Die relationalen Operatoren sind bin@"are Operatoren.  Ausdr@"ucke wie 
@code{a < b < c} werden von Maxima nicht erkannt.

Relationale Ausdr@"ucke werden von den Funktionen @mref{is} und
@mref{maybe} sowie den Funktionen @mrefcomma{if} @mref{while} und
@mref{unless} zu boolschen Werten ausgewertet.  Relationale Ausdr@"ucke werden
ansonsten nicht zu boolschen Werten ausgewertet oder vereinfacht.  Jedoch
werden die Argumente eines boolschen Ausdruckes ausgewertet, wenn die
Auswertung nicht auf andere Weise unterdr@"uckt ist.

Wenn ein relationaler Ausdruck nicht zu @code{true} oder @code{false} 
ausgewertet werden kann, wird das Verhalten von @code{is} und @code{if} von der
Optionsvariable @mref{prederror} kontrolliert.  Hat @code{prederror} den Wert 
@code{true}, wird von @code{is} and @code{if} ein Fehler erzeugt.  Hat 
@code{prederror} den Wert @code{false}, hat @code{is} den R@"uckgabewert 
@code{unknown} und @code{if} gibt einen konditionalen Ausdruck zur@"uck, der 
teilweise ausgewertet ist.

Die Funktion @code{maybe} verh@"alt sich immer so, als ob @code{prederror} den 
Wert @code{false} hat, und @code{while} sowie @code{unless} verhalten sich 
immer so, als ob @code{prederror} den Wert @code{true} hat.

Relationale Operatoren werden nicht auf die Elemente von Listen oder Matrizen
sowie auf die beiden Seiten einer Gleichung angewendet.

Siehe auch @mrefcomma{=} @mrefcomma{#} @mref{equal} und @mrefdot{notequal}

Beispiele:

Relationale Ausdr@"ucke werden von einigen Funktionen zu boolschen Werten 
ausgewertet.

@example
(%i1) [x, y, z] : [123, 456, 789];
(%o1)                    [123, 456, 789]
(%i2) is (x < y);
(%o2)                         true
(%i3) maybe (y > z);
(%o3)                         false
(%i4) if x >= z then 1 else 0;
(%o4)                           0
(%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i, 
             return (S));
(%o5)                         5050
@end example

Relationale Ausdr@"ucke werden ansonsten nicht zu boolschen Werten ausgewertet 
oder vereinfacht, auch wenn die Argumente eines relationalen Ausdruckes 
ausgewertet werden.

@example
(%o1)                    [123, 456, 789]
(%i2) [x < y, y <= z, z >= y, y > z];
(%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
(%i3) map (is, %);
(%o3)               [true, true, true, false]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Logische Operatoren, Operatoren f@"ur Gleichungen, Relationale Operatoren, Operatoren
@section Logische Operatoren
@c -----------------------------------------------------------------------------

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{and}
@deffn {Operator} and
@ifinfo
@fnindex Logische Konjunktion
@end ifinfo

Ist der logische Operator der Konjunktion.  @code{and} ist ein N-ary Infix 
Operator.  Seine Argumente sind boolsche Ausdr@"ucke und sein Ergebnis ist ein 
boolscher Wert.

Wie @mref{is} erzwingt @code{and} die Auswertung aller oder einen Teil seiner 
Argumente.

Die Argumente werden in der Reihenfolge ausgewertet, in der sie auftreten.
@code{and} wertet nur soviele Argumente aus, wie n@"otig sind, um das Ergebnis 
des Ausdrucks zu bestimmen.  Hat irgendein Argument den Wert @code{false}, ist 
das Ergebnis @code{false} und die weiteren Argumente werden nicht ausgewertet.

Die Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{and}
f@"ur den Fall, dass ein Argument nicht zu @code{true} oder @code{false} 
ausgewertet werden kann.  @code{and} gibt eine Fehlermeldung, wenn 
@code{prederror} den Wert @code{true} hat.  Andernfalls werden Argumente, die 
nicht zu @code{true} oder @code{false} ausgewertet werden k@"onnen, akzeptiert 
und das Ergebnis ist ein boolscher Ausdruck.

@code{and} ist nicht kommutativ, da aufgrund von nicht ausgewerteten Argumenten
die Ausdr@"ucke @code{a and b} und @code{b and a} ein unterschiedliches Ergebnis
haben k@"onnen.
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{or}
@deffn {Operator} or
@ifinfo
@fnindex Logische Disjunktion
@end ifinfo

Ist der logische Operator der Disjunktion.  @code{or} ist ein N-ary Infix 
Operator.  Seine Argumente sind boolsche Ausdr@"ucke und sein Ergebnis ist ein 
boolscher Wert.

Wie @mref{is} erzwingt der Operator @code{or} die Auswertung aller oder einen
Teil seiner Argumente.

Die Argumente werden in der Reihenfolge ausgewertet, in der sie auftreten.
@code{or} wertet nur soviele Argumente aus, wie n@"otig sind, um das Ergebnis 
des Ausdrucks zu bestimmen.  Hat irgendein Argument den Wert @code{true}, ist
das Ergebnis @code{true} und die weiteren Argumente werden nicht ausgewertet.

Die Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{or},
f@"ur den Fall, das ein Argument nicht zu @code{true} oder @code{false} 
ausgewertet werden kann.  @code{and} gibt eine Fehlermeldung, wenn
@code{prederror} den Wert @code{true} hat.  Andernfalls, werden Argumente, die
nicht zu @code{true} oder @code{false} ausgewertet werden k@"onnen, akzeptiert
und das Ergebnis ist ein boolscher Ausdruck.

@code{or} ist nicht kommutativ, da aufgrund von nicht ausgewerteten Argumenten
die Ausdr@"ucke @code{a or b} und @code{b or a} ein unterschiedliches Ergebnis
haben k@"onnen.
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{not}
@deffn {Operator} not
@ifinfo
@fnindex Logische Negation
@end ifinfo

Ist die logische Negation.  @code{not} ist ein Prefix-Operator.  Sein Argument
ist ein boolscher Ausdruck und sein Ergebnis ein boolscher Wert.

Wie @mref{is} erzwingt @code{not} die Auswertung seiner Argumente.

Die Optionsvariable @mref{prederror} kontrolliert das Verhalten von @code{not},
f@"ur den Fall, dass das Argument nicht zu @code{true} oder @code{false} 
ausgewertet werden kann.  @code{not} gibt eine Fehlermeldung, wenn 
@code{prederror} den Wert @code{true} hat.  Andernfalls wird ein Argument, das 
nicht zu @code{true} oder @code{false} ausgewertet werden kann, akzeptiert und 
das Ergebnis ist ein boolscher Ausdruck.
@end deffn

@c -----------------------------------------------------------------------------
@node Operatoren f@"ur Gleichungen, Zuweisungsoperatoren, Logische Operatoren, Operatoren
@section Operatoren f@"ur Gleichungen
@c -----------------------------------------------------------------------------

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{#}
@deffn {Operator} #
@ifinfo
@fnindex  Nicht gleich (Ungleichheit)
@end ifinfo

Ist der Operator f@"ur eine Ungleichung.

Wegen der Regeln f@"ur die Auswertung von Aussagen und weil 
@code{not @var{expr}} die Auswertung des Argumentes @var{expr} bewirkt, ist der 
Ausdruck @code{not @var{a} = @var{b}} @"aquivalent zu 
@code{is(@var{a} # @var{b})} und nicht zu @code{@var{a} # @var{b}}.

Beispiele:

@example
(%i1) a = b;
(%o1)                         a = b
(%i2) is (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) is (a # b);
(%o5)                         true
(%i6) is (not a = b);
(%o6)                         true
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{=}
@deffn {Operator} =
@ifinfo
@fnindex Operator for Gleichungen
@fnindex gleich (Gleichheit)
@end ifinfo

Ist der Operator f@"ur eine Gleichung.

Ein Ausdruck @code{@var{a} = @var{b}} repr@"asentiert eine nicht ausgewertete 
Gleichung, welche zutreffen kann oder auch nicht.  Nicht ausgewertete 
Gleichungen k@"onnen zum Beispiel als Argument der Funktionen @mref{solve} und
@mref{algsys} auftreten.

Die Funktion @mref{is} wertet @code{=} zu einem boolschen Wert aus.
@code{is(@var{a} = @var{b})} wertet die Gleichung @code{@var{a} = @var{b}} zum 
Wert @code{true} aus, wenn @var{a} and @var{b} identische Ausdr@"ucke sind.  Das 
trifft zu, wenn @var{a} und @var{b} identische Atome sind, oder wenn ihre 
Operatoren sowie die Argumente identisch sind.  In jedem anderen Fall ist das 
Ergebnis @code{false}.  Das Ergebnis der Auswertung ist nie @code{unkown}.  Hat 
@code{is(@var{a} = @var{b})} das Ergebnis @code{true}, werden @code{a} und 
@code{b} als syntaktisch gleich bezeichnet.  Im Unterschied dazu gilt f@"ur
@"aquivalente Ausdr@"ucke, das @code{is(equal(@var{a}, @var{b}))} den Wert 
@code{true} hat.  Ausdr@"ucke k@"onnen @"aquivalent, aber syntaktisch 
verschieden sein.

Die Negation von @code{=} wird durch @mref{#} repr@"asentiert.  Wie bei @code{=}
wird ein Ausdruck @code{@var{a} # @var{b}} nicht ausgewertet.  Eine Auswertung
erfolgt mit @code{is(@var{a} # @var{b})}, welche die Werte @code{true} oder
@code{false} liefert.

Neben @code{is} werten auch die Operatoren
@mrefcomma{if} @mrefcomma{and} @mref{or} und @mref{not} die Operatoren
@code{=} und @code{#} zu den Werten @code{true} oder @code{false} aus.

Wegen der Regeln f@"ur die Auswertung von Aussagen und weil im Ausdruck
@code{not @var{expr}} das Argument @var{expr} ausgewertet wird, ist
@code{not @var{a} = @var{b}} @"aquivalent zu @code{is(@var{a} # @var{b})} und 
nicht zu @code{@var{a} # @var{b}}.

Die Funktionen @mref{rhs} und @mref{lhs} geben die rechte und die linke einer
Gleichung oder Ungleichung zur@"uck.

Siehe auch @mref{equal} und @mrefdot{notequal}

Beispiele:

Ein Ausdruck @code{@var{a} = @var{b}} repr@"asentiert eine nicht ausgewertete
Gleichung.  Diese kann zutreffen oder nicht.

@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(@var{a} = @var{b})} wertet @code{@var{a} = @var{b}} zu @code{true} aus,
wenn @var{a} und @var{b} syntaktisch gleich sind.  Ausdr@"ucke k@"onnen 
@"aquivalent sein, ohne syntaktisch gleich zu sein.

@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

Einige Operatoren werten @code{=} und @code{#} zu @code{true} oder @code{false}
aus.

@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
      BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

Da @code{not @var{expr}} die Auswertung des Ausdrucks @var{expr} bewirkt, ist
@code{not @var{a} = @var{b}} @"aquivalent zu @code{is(@var{a} # @var{b})}.

@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Zuweisungsoperatoren, Nutzerdefinierte Operatoren, Operatoren f@"ur Gleichungen, Operatoren
@section Zuweisungsoperatoren
@c -----------------------------------------------------------------------------

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{:}
@deffn {Operator} :
@ifinfo
@fnindex Zuweisungsoperator
@end ifinfo

Ist der Operator f@"ur die Zuweisung eines Wertes an eine Variable.

Ist die linke Seite eine Variable (ohne Index), wertet der Operator @code{:} die
rechte Seite aus und weist den Wert der Variablen auf der linken Seite zu.

Ist die linke Seite ein Element einer Liste, Matrix oder ein deklariertes 
Maxima- oder Lisp-Array, wird die rechte Seite diesem Element zugewiesen.  Der 
Index muss ein existierendes Element bezeichnen.

Ist die linke Seite ein Element eines nicht deklarierten Maxima-Array, dann wird
die rechte Seite diesem Element zugewiesen, falls dieses existiert.  Existiert 
das Element noch nicht, wird ein neues Element erzeugt.

Ist die linke Seite eine Liste mit Variablen (ohne Index), muss die rechte Seite
zu einer Liste auswerten.  Die Elemente der Liste auf der rechten Seite werden 
den Elementen auf der linken Seite parallel zugewiesen.

Siehe auch @mref{kill} und @mref{remvalue} f@"ur die Aufhebung der Zuweisung
eines Wertes an die linke Seite.

Beispiele:

Zuweisung an eine einfache Variable.

@example
(%i1) a;
(%o1)                           a
(%i2) a : 123;
(%o2)                          123
(%i3) a;
(%o3)                          123
@end example

Zuweisung an ein Element einer Liste.

@example
(%i1) b : [1, 2, 3];
(%o1)                       [1, 2, 3]
(%i2) b[3] : 456;
(%o2)                          456
(%i3) b;
(%o3)                      [1, 2, 456]
@end example

Die Zuweisung erzeugt ein nicht deklariertes Array.

@example
(%i1) c[99] : 789;
(%o1)                          789
(%i2) c[99];
(%o2)                          789
(%i3) c;
(%o3)                           c
(%i4) arrayinfo (c);
(%o4)                   [hashed, 1, [99]]
(%i5) listarray (c);
(%o5)                         [789]
@end example

Mehrfache Zuweisung.

@example
(%i1) [a, b, c] : [45, 67, 89];
(%o1)                     [45, 67, 89]
(%i2) a;
(%o2)                          45
(%i3) b;
(%o3)                          67
(%i4) c;
(%o4)                          89
@end example

Die mehrfache Zuweisung wird parallel ausgef@"uhrt.  Die Werte von @code{a} und
@code{b} werden in diesem Beispiel ausgetauscht.

@example
(%i1) [a, b] : [33, 55];
(%o1)                       [33, 55]
(%i2) [a, b] : [b, a];
(%o2)                       [55, 33]
(%i3) a;
(%o3)                          55
(%i4) b;
(%o4)                          33
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{::}
@deffn {Operator} ::
@ifinfo
@fnindex Zuweisungsoperaotor (wertet die linke Seite aus)
@end ifinfo

Ist der Operator f@"ur die Zuweisung eines Wertes an eine Variable.

@code{::} ist wie @mref{:} mit der Ausnahme, dass @code{::} sowohl die rechte
als auch die linke Seite auswertet.

Beispiele:

@example
(%i1) x : 'foo;
(%o1)                          foo
(%i2) x :: 123;
(%o2)                          123
(%i3) foo;
(%o3)                          123
(%i4) x : '[a, b, c];
(%o4)                       [a, b, c]
(%i5) x :: [11, 22, 33];
(%o5)                     [11, 22, 33]
(%i6) a;
(%o6)                          11
(%i7) b;
(%o7)                          22
(%i8) c;
(%o8)                          33
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{::=}
@deffn {Operator} ::=
@ifinfo
@fnindex Operator for Makrodefinitionen
@end ifinfo

Ist der Operator f@"ur die Definition von Makro-Funktionen.  @code{::=} 
definiert eine Funktion (aus historischen Gr@"unden Makro genannt), welche ihre
Argumenente nicht auswertet.  Der Ausdruck, welcher zur@"uckgegeben wird, wird
in dem Kontext ausgewertet, in dem das Makro aufgerufen wurde.  Ansonsten
verh@"alt sich eine Makro-Funktion wie eine gew@"ohnliche Funktion.

@mref{macroexpand} expandiert ein Makro ohne es auszuwerten.
@code{macroexpand(foo(x)} dem @code{''%} folgt, ist @"aquivalent zu 
@code{foo (x)}, wenn @code{foo} eine Makro-Funktion ist.

@code{::=} f@"ugt den Namen der neuen Makro-Funktion der Informationsliste
@mref{macros} hinzu.  Die Funktionen @mrefcomma{kill} @mref{remove} und
@mref{remfunction} heben die Zuweisung der Makro-Funktion an ein Symbol auf und
entfernen die Makro-Funktion von der Informationsliste @code{macros}.

@mref{fundef} oder @mref{dispfun} geben die Definition einer Makro-Funktion
zur@"uck oder weisen die Makro-Funktion einer Marke zu.

Makro-Funktionen enthalten h@"aufig Ausdr@"ucke mit den Funktionen
@mref{buildq} und @mrefdot{splice}  Mit diesen werden Ausdr@"ucke konstruiert,
die dann ausgewertet werden.

Beispiele:

Eine Makro-Funktion wertet ihre Argumente nicht aus.  Daher zeigt Beispiel (1)
@code{y - z} und nicht den Wert von @code{y - z}.  Das Makro wird in 
dem Kontext ausgewertet, in dem das Makro aufgerufen wird.  Dies zeigt (2).

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$

(%i5) printq1 (y - z);
(1) x is equal to y - z
(2) x is equal to %pi
(%o5)                                 %pi
@end example

Eine gew@"ohnliche Funktion wertet ihre Argumente aus.  Daher zeigt (1) den Wert 
von @code{y - z}.  Der R@"uckgabewert wird nicht ausgewertet und gibt (2).  Mit
@code{''%} wird die Auswertung erzwungen.

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) printe1 (x) := block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$

(%i5) printe1 (y - z);
(1) x is equal to 1234 - 1729 w
(%o5)                     print((2) x is equal to, x)
(%i6) ''%;
(2) x is equal to %pi
(%o6)                                 %pi
@end example

@mref{macroexpand} gibt die Expansion des Makros zur@"uck.
@code{macroexpand(foo(x)} dem @code{''%} folgt, ist @"aquivalent zu 
@code{foo (x)}, wenn @code{foo} eine Makro-Funktion ist.

@example
(%i1) x: %pi$

(%i2) y: 1234$

(%i3) z: 1729 * w$

(%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

(%i5) macroexpand (g (y - z));
(%o5)                     print(x is equal to, y - z)
(%i6) ''%;
x is equal to 1234 - 1729 w
(%o6)                            1234 - 1729 w
(%i7) g (y - z);
x is equal to 1234 - 1729 w
(%o7)                            1234 - 1729 w
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{:=}
@deffn {Operator} :=
@ifinfo
@fnindex Operator f@"ur Funktionsdefinitionen
@end ifinfo

Ist der Operator f@"ur Funktionsdefinitionen.
@code{@var{f}(@var{x_1}, ..., @var{x_n})} := @var{expr} definiert eine Funktion
mit dem Namen @var{f}, den Argumenten @var{x_1}, @dots{}, @var{x_n} und der 
Funktionsdefinition @var{expr}.  @code{:=} wertet die Funktionsdefinition nicht
aus.  Die Auswertung kann mit dem Quote-Quote-Operator @mref{''} erzwungen
werden.  Die definierte Funktion kann eine gew@"ohnliche Maxima-Funktion sein,
deren Argumente in runden Klammern eingeschlossen sind, oder eine Array-Funktion
mit Argumenten, die in eckigen Klammern eingeschlossen sind.

Ist das letzte oder das einzige Argument der Funktion @var{x_n} eine Liste mit
einem Element, dann akzeptiert die mit @code{:=} definierte Funktion eine 
variable Anzahl an Argumenten.  Die Argumente werden zun@"achst nacheinander den
Argumenten @var{x_1}, @dots{}, @var{x_(n - 1)} zugewiesen.  Sind weitere
Argumente vorhanden, werden diese @var{x_n} als Liste zugewiesen.

Funktionsdefinitionen erscheinen in demselben Namensraum.  Wird eine Funktion
@code{f} innerhalb einer Funktion @code{g} definiert, wird die Reichweite der
Funktion nicht automatisch auf @code{g} beschr@"ankt.  Dagegen f@"uhrt 
@code{local(f)} zu einer Definition, die nur innerhalb eines Blockes oder einem
anderen zusammengesetzten Ausdr@"uck erscheint.  Siehe auch @mrefdot{local}

Ist eines der Argumente ein Symbol auf das der Quote-Operator angewendet wurde, 
wird dieses Argument nicht ausgewertet.  Ansonsten werden alle Argumente 
ausgewertet.

Siehe auch @mref{define} und @mrefdot{::=}

Beispiele:

@code{:=} wertet die Funktions-Definition nie aus, au@ss{}er wenn der 
Quote-Quote-Operator angewendet wird.

@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) F1 (x, y) := expr;
(%o2)                   F1(x, y) := expr
(%i3) F1 (a, b);
(%o3)                    cos(y) - sin(x)
(%i4) F2 (x, y) := ''expr;
(%o4)              F2(x, y) := cos(y) - sin(x)
(%i5) F2 (a, b);
(%o5)                    cos(b) - sin(a)
@end example

Mit dem Operator @code{:=} definierte Funktionen k@"onnen eine gew@"ohnliche
Maxima-Funktion oder eine Array-Funktion sein.

@example
(%i1) G1 (x, y) := x.y - y.x;
(%o1)               G1(x, y) := x . y - y . x
(%i2) G2 [x, y] := x.y - y.x;
(%o2)                G2     := x . y - y . x
                       x, y
@end example

Ist das letzte oder einzige Argument @var{x_n} eine Liste mit einem Element, 
akzepiert die Funktion eine variable Anzahl an Argumenten.

@example
(%i1) H ([L]) := apply ("+", L);
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

@mref{local} erzeugt eine lokale Funktionsdefinition.

@example
(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Nutzerdefinierte Operatoren, , Zuweisungsoperatoren, Operatoren
@section Einf@"uhrung in nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

Es ist m@"oglich neue Operatoren zu definieren, vorhandene Operatoren zu
entfernen oder deren Eigenschaften zu @"andern.  Es k@"onnen Operatoren mit den
folgenden Eigenschaften definiert werden:

@table @dfn
@item un@"ar Prefix
Negation @code{- a}

@item un@"ar Postfix
Fakult@"at @code{a!}

@item bin@"ar Infix
Exponentiation @code{a^b}

@item N-ary Infix
Addition @code{a + b}

@item Matchfix
Liste @code{[a,b]}

@item Nofix
Maxima hat keinen implementierten Nofix-Operator.
@end table

Jede Funktion kann als ein Operator definiert werden, die Funktion kann, muss 
aber nicht definiert sein.

Im Folgenden werden die Operatoren @code{dd} und @code{"<-"} definiert.  Nach
der Definition als Operatoren ist @code{dd a} gleichbedeutend mit @code{"dd"(a)}
und @code{a <- b} entspricht dem Funktionsaufruf @code{"<-"(a,b)}.  In diesem
Beispiel sind die Funktionen @code{"dd"} und @code{"<-"} nicht definiert.

@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

Die Maxima-Funktionen, um Operatoren zu definieren, sind in der folgenden
Tabelle zusammengefasst.  Weiterhin sind die Standardvorgaben f@"ur die links- 
und rechtsseitige Bindungskraft der Operatoren (lbp und rbp) angegeben.  Die 
Bindungskr@"afte bestimmen den Vorrang der Operatoren.

@table @code
@item Prefix
rbp=180
@item Postfix
lbp=180
@item Infix
lbp=180, rbp=180
@item N-ary
lbp=180, rbp=180
@item Matchfix
(Bindungskraft nicht anwendbar)
@item Nofix
(Bindungskraft nicht anwendbar)
@end table

Die folgende Tabelle enth@"alt die Maxima-Operatoren und deren links- und 
rechtsseitigen Bindungskr@"afte.

@example
Operator   lbp     rbp     lpos     rpos     pos
                                               
  :        180     20                         
  ::       180     20                           
  :=       180     20                          
  ::=      180     20                             
  !        160                                      
  !!       160                                     
  ^        140     139                              
  .        130     129                                
  *        120             expr              expr     
  /        120     120     expr     expr     expr 
  +        100     134              expr     expr
  -        100     134              expr     expr
  =        80      80                            
  #        80      80                                 
  >        80      80                              
  >=       80      80                                
  <        80      80                         
  <=       80      80                                
  not              70      clause   clause   clause
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

Mit den Befehlen @mref{remove} und @mref{kill} k@"onnen Operatoreigenschaften
von einem Symbol entfernt werden.  @code{remove("@var{a}", op)} entfernt
die Operator-Eigenschaften des Symbols @var{a}.  @code{kill("@var{a}")} entfernt
alle Eigenschaften einschlie@ss{}ich der Operator-Eigenschaften des Symbols 
@var{a}.  In diesem Fall steht der Name des Symbols in Anf@"uhrungszeichen.

@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@c --- -------------------------------------------------------------------------
@section Funktionen und Variable f@"ur nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{infix}
@deffn  {Funktion} infix (@var{op})
@deffnx {Funktion} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Funktion} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})

Deklariert @var{op} als einen Infix-Operator.  Ein Infix-Operator hat eine 
Funktionsdefinition mit zwei Argumenten.  Der Infix-Operator steht zwischen den
Argumenten.  Zum Beispiel ist die Subtraktion @code{-} ein Infix-Operator.

@code{infix(@var{op})} deklariert @var{op} als einen Infix-Operator mit einer
links- und rechtsseitigen Bindungskraft von jeweils 180.

@code{infix (@var{op}, @var{lbp}, @var{rbp})} deklariert @var{op} als einen
Infix-Operator mit den angegebenen Werten f@"ur die links- und rechtsseitige 
Bindungskraft.

@code{infix(@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
deklariert @var{op} als einen Infix-Operator mit den angegebenen 
Bindungskr@"aften sowie den Wortarten @var{lpos}, @var{rpos} und @var{pos} f@"ur
den linken und den rechten Operanden sowie das Ergebnis des Operators.

Wortart bedeutet hier, den Type eines Operanden.  Maxima kennt die drei Typen
@code{expr}, @code{clause} und @code{any}.  Diese stehen f@"ur einen
algebraischen Ausdruck, einen logischen Ausdruck und einen beliebigen Ausdruck.
Mit Hilfe der f@"ur einen Operator definierten Wortart kann der Parser beim 
Einlesen eines Ausdrucks Syntaxfehler feststellen.

Der Vorrang eines Operators @var{op} vor anderen Operatoren leitet sich aus den
links- und rechtsseitigen Bindungskr@"aften ab.  Sind die links- und 
rechtsseitigen Bindungskr@"afte von @var{op} beide gr@"o@ss{}er als die links- 
und rechtsseitige Bindungskraft eines anderen Operators, dann hat @var{op} 
Vorrang vor dem anderen Operator.  Sind die Bindungskr@"afte nicht beide 
gr@"o@ss{}er oder kleiner, werden weitere Regeln zur Bestimmung des Vorrangs 
herangezogen.

Die Assoziativit@"at eines Operators @var{op} h@"angt ab von seiner 
Bindungskraft.  Eine gr@"o@ss{}ere linksseitige Bindungskraft hat zur Folge,
dass der Operator @var{op} vor einem anderen Operator auf seiner linken Seite
ausgewertet wird.  W@"ahrend eine gr@"o@ss{}ere rechtsseitige Bindungskraft zur 
Folge hat, dass der Operator vor anderen Operaroten auf der rechten Seite 
ausgewertet wird.  Daraus folgt, dass eine gr@"o@ss{}ere linksseitige 
Bindungskraft @var{lbp} einen Operator @var{op} rechts-assoziativ und eine 
gr@"o@ss{}ere rechtsseitige Bindungskraft @var{rbp} den Operator 
links-assoziativ macht.  Sind die links- und rechtsseitigen Bindungskr@"afte 
gleich gro@ss{}, ist der Operator @var{op} links-assoziativ.

Beispiele:

Sind die rechtsseitigen und linksseitigen Bindungskr@"afte eines Operators
@var{op} gr@"o@ss{}er als die entsprechenden Bindungskr@"afte eines anderen 
Operatores, dann hat der Operator @var{op} Vorrang.

@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

Eine gr@"o@ss{}ere linksseitige Bindungskraft @var{lbp} bewirkt, dass der 
Operator @var{op} rechts-assoziativ ist.  Eine gr@"o@ss{}ere rechtsseitige 
Bindungskraft macht dagegen den Operator @var{op} links-assoziativ.

@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

Maxima kann Syntaxfehler beim Einlesen eines Ausdrucks feststellen, wenn der
eingelesene Operand nicht die f@"ur den Operator definierte Wortart hat.

@example
(%i1) infix ("##", 100, 99, expr, expr, expr);
(%o1)                          ##
(%i2) if x ## y then 1 else 0;
Incorrect syntax: Found algebraic expression where 
logical expression expected
if x ## y then 
             ^
(%i2) infix ("##", 100, 99, expr, expr, clause);
(%o2)                          ##
(%i3) if x ## y then 1 else 0;
(%o3)                if x ## y then 1 else 0
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{matchfix}
@deffn  {Funktion} matchfix (@var{ldelimiter}, @var{rdelimiter})
@deffnx {Funktion} matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})

Deklariert einen Matchfix-Operator mit dem linksseitigen Begrenzungszeichen 
@var{ldelimiter} und dem rechtsseitigen Begrenzungszeichen @var{rdelimiter}.

Ein Matchfix-Operator hat eine beliebige Anzahl an Argumenten, die zwischen
dem linksseitigen und dem rechtsseitigen Begrenzungszeichen stehen.  Das
Begrenzungszeichen kann eine beliebige Zeichenkette sein.  Einige Zeichen wie
@code{%}, @code{,}, @code{$} und @code{;} k@"onnen nicht als Begrenzungszeichen
definiert werden.

Ein linksseitiges Begrenzungszeichen kann nicht verschiedene rechtsseitige
Begrenzungszeichen haben.

Maxima-Operatoren k@"onnen als Matchfix-Operatoren definiert werden, ohne 
dass sich die sonstigen Operatoreigenschaften @"andern.  So kann zum Beispiel
der Operator @code{+} als Matchfix-Operator definiert werden.

@code{matchfix(@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})}
definiert die Wortarten f@"ur die Argumente @var{arg_pos} und das Ergebnis
@var{pos} sowie das linksseitige @var{ldelimiter} und rechtsseitige
@var{rdelimiter} Begrenzungszeichen.

Wortart bedeutet hier, den Type eines Operanden.  Maxima kennt die drei Typen
@code{expr}, @code{clause} und @code{any}.  Diese stehen f@"ur einen
algebraischen Ausdruck, einen logischen Ausdruck und einen beliebigen Ausdruck.
Mit Hilfe der f@"ur einen Operator definierten Wortart kann der Parser beim 
Einlesen eines Ausdrucks Syntaxfehler feststellen.

Die zu einem Matchfix-Operator zugeh@"orige Funktion kann jede 
nutzerdefinierte Funktion sein, die mit @mref{:=} oder @mref{define} definiert
wird.  Die Definition der Funktion kann mit @code{dispfun(@var{ldelimiter})} 
ausgegeben werden.

Maxima kennt nur den Operator f@"ur Listen @code{[ ]} als Matchfix-Operator.
Klammern @code{( )} und Anf@"uhrungszeichen @code{" "} arbeiten wie 
Matchfix-Operatoren, werden aber vom Parser nicht als Matchfix-Operatoren 
behandelt.

@mref{matchfix} wertet seine Argumente aus.  @code{matchfix} gibt das erste
Argument @var{ldelimiter} als Ergebnis zur@"uck.

Beispiele:

Begrenzungszeichen k@"onnen eine beliebige Zeichenkette sein.

@example
(%i1) matchfix ("@@@@", "~");
(%o1)                          @@@@
(%i2) @@@@ a, b, c ~;
(%o2)                      @@@@a, b, c~
(%i3) matchfix (">>", "<<");
(%o3)                          >>
(%i4) >> a, b, c <<;
(%o4)                      >>a, b, c<<
(%i5) matchfix ("foo", "oof");
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) >> w + foo x, y oof + z << / @@@@ p, q ~;
                     >>z + foox, yoof + w<<
(%o7)                ----------------------
                            @@@@p, q~
@end example

Matchfix-Operatoren k@"onnen f@"ur nutzerdefinierte Funktionen definiert 
werden.

@example
(%i1) matchfix ("!-", "-!");
(%o1)                         "!-"
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define ("!-" (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun ("!-");
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) "!-" (3, 5);
                                16
(%o7)                         - --
                                15
@end example
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{nary}
@deffn {Funktion} nary (@var{x})

Ein @code{N-ary}-Operator ist ein Operator, der eine beliebige Anzahl an 
Argumenten haben kann.  Die Argumente werden durch den Operator voneinander 
getrennt, so ist zum Beispiel @code{+} ein @code{N-ary}-Operator und 
@code{A+B+C}.  Die Funktion @code{nary("x")} erm@"oglicht die Erweiterung der 
Maxima-Syntax um einen N-ary-Operator @code{x}.  Funktionen k@"onnen als 
N-ary-Operator deklariert werden.  @code{declare(j,nary)} deklariert den
Operator @code{j} zu einem N-ary-Operator.  Ein Ausdruck @code{j(j(a,b),j(c,d)}
wird in diesem Fall zu @code{j(a,b,c,d)} vereinfacht.
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{nofix}
@deffn {Funktion} nofix (@var{x})

Nofix-Operatoren sind Operatoren, die kein Argument haben.  Tritt ein solcher 
Operator allein auf, wird die dazugeh@"orige Funktion ausgewertet.  Zum Beispiel
beendet die Funktion @code{quit()} eine Maxima-Sitzung.  Wird diese Funktion 
mit @code{nofix("quit")} zu einen Nofix-Operator deklariert, gen@"ugt die 
Eingabe von @code{quit;}, um eine Maxima-Sitzung zu beenden.  Die Funktion 
@code{nofix("x")} erweitert die Maxima-Syntax um den Nofix-Operator @code{x}.
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{postfix}
@deffn {Funktion} postfix (@var{x})

Postfix-Operatoren und Prefix-Operatoren bezeichnen Operatoren mit einem 
Argument, wobei f@"ur Postfix-Operatoren der Operator dem Argument direkt 
nachfolgt.  Ein Beispiel ist der @code{!}-Operator mit @code{3!}.  Die Funktion
@code{postfix("x")} erweitert die Maxima-Syntax um den Postfix-Operator 
@code{x}.
@end deffn

@c --- 09.10.2010 DK -----------------------------------------------------------
@anchor{prefix}
@deffn {Funktion} prefix (@var{x})

Ein Prefix-Operator ist ein Operator mit einem Argument, das dem Operator
nachfolgt.  Mit @code{prefix("x")} wird die Maxima-Syntax um einen
Prefix-Operator @code{x} erweitert.
@end deffn

@c --- End of file Operators.de.texi -------------------------------------------

