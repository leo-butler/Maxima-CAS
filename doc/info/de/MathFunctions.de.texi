@c -----------------------------------------------------------------------------
@c File        : MathFunctions.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 19.10.2010
@c Revision    : 22.02.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu 
* Funktionen f@"ur Zahlen::
* Funktionen f@"ur komplexe Zahlen::
* Funktionen der Kombinatorik::
* Algebraische Funktionen::
* Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur Zahlen, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen, Mathematische Funktionen
@section Funktionen f@"ur Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{abs}
@deffn {Funktion} abs (@var{expr})

Die Funktion @code{abs} ist die Betragsfunktion und f@"ur numerische und
symbolische Rechnungen geeignet.  Ist das Argument @var{expr} eine reelle oder
komplexe Zahl wird der Betrag berechnet.  Wenn m@"oglich werden allgemeine
Ausdr@"ucke mit der Betragsfunktion vereinfacht.  Maxima kann Ausdr@"ucke mit
der Betragsfunktion integrieren und ableiten sowie Grenzwerte von Ausdr@"ucken
mit der Betragsfunktion ermitteln.  Siehe auch @mrefcomma{diff}@ 
@mref{integrate} und @mrefdot{limit}  Das Paket @mref{abs_integrate} erweitert
Maximas M@"oglichkeiten, Integrale mit der Betragsfunktion zu berechnen.

Die Betragsfunktion wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe die Funktion @mrefcomma{cabs} um den Betrag eines komplexen Ausdrucks
oder Funktion zu berechnen.

Beispiele:

Berechnung des Betrages f@"ur reelle und komplexen Zahlen sowie numerische
Konstanten und unendliche Gr@"o@ss{}en.  Das erste Beispiel zeigt, wie die
Betragsfunktion von Maxima auf die Elemente einer Liste angewendet werden.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Vereinfachung von Ausdr@"ucken mit der Betragsfunktion.

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Ableitung und Integrale mit der Betragsfunktion.  Wird das Paket
@nref{abs_integrate} geladen, k@"onnen weitere Integrale mit der Betragsfunktion
gel@"ost werden.  Das letzte Beispiel zeigt die Laplacetransformation der
Betragsfunktion.

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{ceiling}
@deffn {Funktion} ceiling (@var{x})

Die Funktion @code{ceiling} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{ceiling} die kleinste
ganze Zahl zur@"uck, die gr@"o@ss{}er oder gleich @var{x} ist.

Die Funktion @code{ceiling} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{ceiling} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{ceiling}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{ceiling} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{floor} oder @mref{round} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{ceiling} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{floor} und @mrefdot{round}

Beispiele:

@example
(%i1) ceiling(ceiling(x));
(%o1)                      ceiling(x)
(%i2) ceiling(floor(x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) ceiling([n, abs(n), max (n, 6)]);
(%o4)               [n, abs(n), max(6, n)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @code{ceiling} und
@mref{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{ceiling}.

@example
(%i1) integrate(ceiling(x),x);
               (- ceiling(x) + 2 x + 1) ceiling(x)
(%o1)          -----------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{entier}
@deffn {Funktion} entier (@var{x})

@code{entier} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.
Siehe @mrefdot{floor}
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{floor}
@deffn {Funktion} floor (@var{expr})

Die Funktion @code{floor} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{floor} die gr@"o@ss{}te
ganze Zahl zur@"uck, die kleiner oder gleich @var{x} ist.

Die Funktion @code{floor} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{floor} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{floor}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{floor} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{ceiling} oder @mref{round} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{floor} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{round}

Beispiele:

@example
(%i1) floor(ceiling(x));
(%o1)                      ceiling(x)
(%i2) floor(floor(x));
(%o2)                       floor(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) floor([n, abs(n), min (n, 6)]);
(%o4)                [n, abs(n), min(6, n)]
(%i5) assume(x>0, x<1)$
(%i6) floor(x);
(%o6)                           0
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @mref{ceiling} und
@code{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor(f(x));
(%o2)                         f(x)
(%i3) ceiling(f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{floor}.

@example
(%i6) integrate(floor(x),x);
                 (- floor(x) + 2 x - 1) floor(x)
(%o6)            -------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{fix}
@deffn {Funktion} fix (@var{x})

@code{fix} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.  Siehe
@mrefdot{floor}
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmax}
@deffn {Funktion} lmax (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{max} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, wird ein Maxima-Fehler signalisiert.

Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i1) lmax(L);
(%o1)                        %e + 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmin}
@deffn {Funktion} lmin (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{min} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, wird ein Maxima-Fehler signalisiert.

Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i2) lmin(L);
(%o2)                           3
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{max}
@deffn {Funktion} max (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
gr@"o@ss{}te Zahlenwert zur@"uckgegeben.  Treten symbolische Argumente oder
Ausdr@"ucke auf, gibt Maxima einen vereinfachten Ausdruck zur@"uck.

Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf} k@"onnen als Argument
auftreten und werden von @code{max} korrekt behandelt.

Die Vereinfachung der Funktion @code{max} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen 
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt
keine besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eleminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{max(x,2*x, 3*x)} zu @code{max(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{max} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die Aussagen
und Fakten der aktiven Kontexte.  Siehe das Kapitel 
@nrefdot{Funktionen und Variablen f@"ur Fakten}

Beispiele:

@example
(%i1) max(1.6, 3/2, 1);
(%o1)                          1.6
(%i2) max(1.5b0,1.5,3/2);
@group
                                3
(%o2)                           -
                                2
@end group
(%i3) max(%e,%pi,1,2,3);
(%o3)                          %pi
(%i4) max(1+%e,%pi,1,2,3);
(%o4)                        %e + 1
(%i5) max(minf,inf);
(%o5)                          inf
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{min}
@deffn {Funktion} min (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
kleinste Zahlenwert zur@"uckgegeben.  Treten symbolische Argumente oder
Ausdr@"ucke auf, gibt Maxima einen vereinfachten Ausdruck zur@"uck.

Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf} k@"onnen als Argument
auftreten und werden von @code{min} korrekt behandelt.

Die Vereinfachung der Funktion @code{mmin} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt keine
besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eleminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{min(x,2*x, 3*x)} zu @code{min(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{min} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die Aussagen
und Fakten der aktiven Kontexte.  Siehe das Kapitel 
@nrefdot{Funktionen und Variablen f@"ur Fakten}

Beispiele:

@example
(%i1) min(1.6, 3/2, 1);
(%o1)                           1
(%i2) min(1.5b0,1.5,3/2);
                                3
(%o2)                           -
                                2
(%i3) min(%e,%pi,3);
(%o3)                          %e
(%i4) min(1+%e,%pi,3);
(%o4)                           3
(%i5) min(minf,inf);
(%o5)                         minf
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{round}
@deffn {Funktion} round (@var{expr})

Die Funktion @code{round} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{round} die am
n@"achsten liegende ganze Zahl zur@"uck.  Vielfache von 1/2 werden auf die 
n@"achste gerade ganze Zahl gerundet.

Die Funktion @code{round} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{round} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{round}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{round} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{ceiling} oder @mref{floor} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{round} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{floor}

Beispiele:

@example
(%i1) round(floor(x));
(%o1)                       floor(x)
(%i2) round(round(x));
(%o2)                       round(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) round([n, abs(n), min(n,6)]);
(%o4)                [n, abs(n), min(6, n)]
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktion @code{round} kann diese
Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare(f, integervalued);
(%o1)                         done
(%i2) round(f(x));
(%o2)                         f(x)
(%i3) round(f(x) - 1);
(%o3)                       f(x) - 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{signum}
@deffn {Funktion} signum (@var{expr})

Die Signumfunktion @code{signum} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Ist das Argument @var{expr} eine Zahl, ist das Ergebnis 0, 1
oder -1, wenn die Zahl Null, positiv oder negativ ist.  Das Argument kann auch
ein konstanter Ausdruck wie @code{%pi} oder @code{1+%e} sein.  Ist das Argument
@var{expr} eine komplexe Zahl, vereinfacht die Funktion @code{signum(expr)} zu
@code{expr/abs(expr)}.

Ist das Argument @var{expr} keine Zahl oder kein konstanter Ausdruck, versucht
Maxima den Ausdruck zu vereinfachen.  Maxima kann die Funktion @code{signum}
differenzieren.  Wird das Paket @nref{abs_integrate} geladen, kann Maxima
Integrale mit der Funktion @code{signum} l@"osen.

@code{signum} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Ergebnisse f@"ur verschiedene Zahlen und konstante Ausdr@"ucke.  Die Beispiele
zeigen, dass das Ergebnis der Signumfunktion den Typ der Zahl erh@"alt.  Die
unendlichen Gr@"o@ss{}en @mref{minf} und @mref{inf} k@"onnen als Argument
auftreten.

@example
(%i1) signum([-1.5, 0, 0.0, 1.5, 1.5b0, %e, sin(1), cos(4)]);
(%o1)        [- 1.0, 0, 0.0, 1.0, 1.0b0, 1, 1, - 1]
(%i2) signum(1+%i);
                          %i         1
(%o2)                   ------- + -------
                        sqrt(2)   sqrt(2)
(%i3) signum([minf,inf]);
(%o3)                      [- 1, 1]
@end example

Vereinfachungen der Signumfunktion.

@example
(%i3) signum(x*y);
(%o3)                  signum(x) signum(y)
(%i4) signum(-x);
(%o4)                      - signum(x)
@end example

Wird das Paket @nref{abs_integrate} geladen, kann Maxima Integrale mit der
Signumfunktion l@"osen.  Ausdr@"ucke mit der Signumfunktion k@"onnen
differenziert werden.

@example
(%i5) load(abs_integrate)$

(%i6) integrate(signum(x),x);
(%o6)                        abs(x)

(%i7) integrate(sin(x)*signum(x),x);
(%o7)               (1 - cos(x)) signum(x)

(%i7) diff(%,x);
(%o7)                  signum(x) sin(x)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur komplexe Zahlen, Funktionen der Kombinatorik, Funktionen f@"ur Zahlen, Mathematische Funktionen
@section Funktionen f@"ur komplexe Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{cabs}
@deffn {Funktion} cabs (@var{expr})

Berechnet den Betrag eines komplexen Ausdrucks @var{expr}.  Im Unterschied
zu der Funktion @mrefcomma{abs} zerlegt die Funktion @code{cabs} einen komplexen
Ausdruck immer in einen Realteil und Imagin@"arteil, um den komplexen Betrag zu
berechnen.  Sind @var{x} und @var{y} zwei reelle Variablen oder Ausdr@"ucke
berechnet die Funktion @code{cabs} den Betrag des komplexen Ausdrucks
@code{x + %i*y} als:
@example
                           2    2
                     sqrt(y  + x )
@end example

Die Funktion @code{cabs} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Betrag eines Ausdrucks zu berechnen.
Sind solche Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{cabs} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{cabs} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.  F@"ur das symbolische Rechnen wie der Integration oder der
Ableitung von Ausdr@"ucken muss die Betragsfunktion @code{abs} verwendet werden.

Das Ergebnis der Funktion @code{cabs} kann die Betragsfunktion @mref{abs} und
die Arcustangensfunktion @mref{atan2} enthalten.

@code{cabs} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.  Siehe @mrefdot{distribute_over}

Siehe auch die Funktionen @mrefcomma{rectform} @mrefcomma{realpart}@ 
@mrefcomma{imagpart} @mrefcomma{carg} @mrefcomma{conjugate} und 
@mref{polarform} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zwei Beispiele mit der Wurzelfunktion @mref{sqrt} und der Sinusfunktion
@mrefdot{sin}

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

Die Funktion @mref{erf} hat Spiegelsymmetrie, die hier f@"ur die Berechnung des
komplexen Betrages angwendet wird.

@example
(%i3) cabs(erf(x+%i*y));
@group
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end group
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen, um den komplexen
Betrag zu vereinfachen.  Dies ist ein Beispiel f@"ur die Besselfunktion
@mrefdot{bessel_j}

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{carg}
@deffn {Funktion} carg (@var{expr})

Gibt das komplexe Argument des Ausdrucks @var{expr} zur@"uck.  Das komplexe
Argument ist ein Winkel @code{theta} im Intervall @code{(-%pi, %pi)} derart,
dass @var{expr} = @code{r exp (theta %i)} gilt, wobei @code{r} den Betrag des
komplexen Ausdrucks @var{expr} bezeichnet.  Das ist die Polarform des Ausdrucks,
wie sie auch von der Funktion @mref{polarform} zur@"uckgegeben wird.  Der Betrag
des komplexen Ausdrucks kann mit der Funktion @mref{cabs} berechnet werden.

Das Ergebnis der Funktion @code{carg} kann die Funktion @mref{atan2} enthalten.

@code{carg} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.  Siehe @mrefdot{distribute_over}

Die Funktion @code{carg} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{rectform} @mref{realpart} und
@mref{imagpart} sowie die Funktionen @mref{cabs} und @mrefdot{conjugate}

Beispiele:

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
@group
                               %pi
(%o2)                          ---
                                4
@end group
(%i3) carg (exp (%i));
(%o3)                           1

(%i4) carg (exp (3/2 * %pi * %i));
                                %pi
(%o4)                         - ---
                                 2
(%i5) carg(exp(x+%i*y));
(%o5)                atan2(sin(y), cos(y))

(%i6) carg(sqrt(x+%i*y));
                          atan2(y, x)
(%o6)                     -----------
                               2
(%i7) carg(sqrt(1+%i*y));
                            atan(y)
(%o7)                       -------
                               2
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{conjugate}
@deffn {Funktion} conjugate (@var{expr})

Gibt den konjugiert komplexen Wert des Ausdrucks @var{expr} zur@"uck.  Sind
@var{x} und @var{y} reelle Variablen oder Ausdr@"ucke, dann hat der Ausdruck
@code{x + %i*y} das Ergebnis @code{x - %i*y}.  Die Funktion @code{conjugate} ist
f@"ur numerische und symbolische Rechnungen geeignet.

Maxima kennt Regeln, um den konjugierten Wert f@"ur Summen, Produkte und
Quotienten von komplexen Ausdr@"ucken zu vereinfachen.  Weiterhin kennt Maxima
Symmetrieeigenschaften und komplexe Eigenschaften von Funktionen, um den 
konjugierten Wert mit diesen Funktionen zu vereinfachen.  Sind solche
Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{conjugate} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{conjugate} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

F@"ur das Rechnen mit komplexen Ausdr@"ucken siehe auch die Funktionen
@mref{cabs} und @mref{carg} sowie @mref{rectform} und @mrefdot{polarform}

Beispiele:

Beispiele mit reellen, imagin@"aren und komplexen Variablen.

@example
(%i1) declare ([x, y], real, [z1, z2], complex, j, imaginary);
(%o1)                         done
(%i2) conjugate(x + %i*y);
(%o2)                       x - %i y
(%i3) conjugate(z1*z2);
(%o3)              conjugate(z1) conjugate(z2)
(%i4) conjugate(j/z2);
                                 j
(%o4)                    - -------------
                           conjugate(z2)
@end example

Im Folgenden nutzt Maxima Symmetrieeigenschaften, um den konjugiert komplexen
Wert der Funktionen @mref{gamma} und @mref{sin} zu berechnen.  Die
Logarithmusfunktion @mref{log} hat Spiegelsymmetrie, wenn das Argument einen
positiven Realteil hat.

@example
(%i5) conjugate(gamma(x+%i*y));
(%o5)                    gamma(x - %i y)
(%i6) conjugate(sin(x+%i*y));
(%o6)                    - sin(%i y - x)
(%i7) conjugate(log(x+%i*y));
(%o7)               conjugate(log(%i y + x))
(%i8) conjugate(log(1+%i*y));
(%o8)                     log(1 - %i y)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{imagpart}
@deffn {Funktion} imagpart (@var{expr})

Gibt den Imagin@"arteil des Ausrucks @var{expr} zur@"uck.  Intern berechnet
Maxima den Imagin@"arteil mit der Funktion @mrefcomma{rectform} die einen
Ausdruck in den Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die
Ausf@"uhrungen zu @code{rectform} auch auf die Funktion @code{imagpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{imagpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{imagpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{realpart} wird der Realteil eines Ausdrucks berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) imagpart((2-%i)/(1-%i));
                                1
(%o1)                           -
                                2
(%i2) imagpart(sin(x+%i*y));
(%o2)                    cos(x) sinh(y)
(%i3) imagpart(gamma(x+%i*y));
             %i (gamma(x - %i y) - gamma(%i y + x))
(%o3)        --------------------------------------
                               2
(%i4) imagpart(bessel_j(1,%i));
(%o4)                    bessel_j(1, %i)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{polarform}
@deffn {Funktion} polarform (@var{expr})

Gibt den Ausdruck @var{expr} in der Polarform @code{r %e^(%i theta)} zur@"uck.
@code{r} ist der Betrag des komplexen Ausdrucks, wie er auch mit der Funktion
@mref{cabs} berechnet werden kann.  @code{theta} ist das Argument des komplexen
Ausdrucks, das mit der Funktion @mref{carg} berechnet werden kann.

Maxima kennt komplexe Eigenschaften von Funktionen, die bei der Berechnung der
Polarform angewendet werden.  Siehe die Funktion @mref{cabs} f@"ur weitere
Erl@"auterungen.

Wenn mit komplexen Ausdr@"ucken in der Polarform gerechnet werden soll, ist es
hilfreich die Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.
Damit wird verhindert, dass Maxima komplexe Ausdr@"ucke mit der
Exponentialfunktion @mref{exp} automatisch in die Standardform vereinfacht.

@code{polarform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktion @code{polarform} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{rectform} kann ein komplexer Ausdruck in die Standardform gebracht werden.

Beispiele:

Die allgemeine Polarform eines komplexen Ausdrucks.  Die Variablen @var{x} und
@var{y} werden von Maxima als reell angenommen.

@example
(%i1) polarform(x+%i*y);
                       2    2    %i atan2(y, x)
(%o1)            sqrt(y  + x ) %e
@end example

Die Polarform einer komplexen Zahl und eines Ausdrucks mit einer reellen 
Variablen @var{x}.

@example
(%i2) polarform(4/5+3*%i/5);
                           %i atan(3/4)
(%o2)                    %e
(%i3) polarform(sqrt(1+%i*x));
                                  %i atan(x)
                                  ----------
                      2     1/4       2
(%o3)               (x  + 1)    %e
@end example

Wenn in der Polarform gerechnet werden soll, ist es hilfreich die
Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.  Damit wird
verhindert, dass Maxima komplexe Ausdr@"ucke mit der Exponentialfunktion 
@mref{exp} automatisch in eine Standardform vereinfacht.

@example
(%i4) z:polarform(1+%i);
                                  %i %pi
                                  ------
                                    4
(%o4)                   sqrt(2) %e
(%i5) z^3;
                     3/2    %i         1
(%o5)               2    (------- - -------)
                          sqrt(2)   sqrt(2)
(%i6) %emode:false;
(%o6)                         false
(%i7) z^3;
                                3 %i %pi
                                --------
                          3/2      4
(%o7)                    2    %e
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{realpart}
@deffn {Funktion} realpart (@var{expr})

Gibt den Realteil des Ausrucks @var{expr} zur@"uck.  Intern berechnet Maxima
den Realteil mit der Funktion @mrefcomma{rectform} die einen Ausdruck in den
Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die Ausf@"uhrungen
zu @code{rectform} auch auf die Funktion @code{realpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{realpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{realpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{imagpart} wird der Imagin@"arteil eines Ausdrucks
berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) realpart((2-%i)/(1-%i));
                                3
(%o1)                           -
                                2
(%i2) realpart(sin(x+%i*y));
(%o2)                    sin(x) cosh(y)
(%i3) realpart(gamma(x+%i*y));
                gamma(%i y + x) + gamma(x - %i y)
(%o3)           ---------------------------------
                                2
(%i4) realpart(bessel_j(1,%i));
(%o4)                           0
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{rectform}
@deffn {Funktion} rectform (@var{expr})

Zerlegt den Ausdruck @var{expr} in den Realteil @code{a} und den Imagin@"arteil
@code{b} und gibt den komplexen Ausdruck in der Standardform @code{a + b %i}
zur@"uck.

Die Funktion @code{rectform} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Realteil und Imagin@"arteil eines
komplexen Ausdrucks zu berechnen.  Sind solche Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der Funktion @mref{properties} angezeigt werden.
Eigenschaften, die das Ergebnis der Funktion @code{rectform} bestimmen, sind:
@code{mirror symmetry}, @code{conjugate function} und
@code{complex characteristic}.

@code{rectform} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.

@code{rectform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktionen @mref{realpart} und @mref{imagpart} geben jeweils allein den
Realteil und den Imagin@"arteil eines Ausdrucks zur@"uck.  Um einen Ausdruck in
die Polarform zu bringen, kann die Funktion @mref{polarform} verwendet werden.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zerlegung eines komplexen Ausdrucks und der Sinusfunktion @mref{sin} in den
Realteil und Imagin@"arteil.  Maxima kennt komplexe Eigenschaften der
trigonometrischen Funktionen, um den Realteil und den Imagin@"arteil zu
bestimmen.

@example
(%i1) rectform((2-%i)/(1-%i));
@group
                             %i   3
(%o1)                        -- + -
                             2    2
@end group
(%i2) rectform(sin(x+%i*y));
(%o2)          %i cos(x) sinh(y) + sin(x) cosh(y)
@end example

Bei der Zerlegung in einen Realteil und einen Imagin@"arteil nutzt Maxima die
Spiegelsymmetrie der Gammfunktion @mrefdot{gamma}  Die Eigenschaft der 
Spiegelsymmetrie wird mit der Funktion @mref{properties} angezeigt, der Eintrag
lautet @code{mirror symmetry}.

@example
(%i3) properties(gamma);
(%o3)    [mirror symmetry, noun, rule, gradef, transfun]

(%i4) rectform(gamma(x+%i*y));
      gamma(%i y + x) + gamma(x - %i y)
(%o4) ---------------------------------
                      2
                                gamma(x - %i y) - gamma(%i y + x)
                              - ---------------------------------
                                                2
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen.  Die Besselfunktion
@mref{bessel_j} ist f@"ur eine ganzzahlige Ordnung und einem imagin@"aren
Argument rein imagin@"ar.

@example
(%i5) rectform(bessel_j(1,%i));
(%o5)                  %i bessel_j(1, %i)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen der Kombinatorik, Algebraische Funktionen, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen
@section Funktionen der Kombinatorik
@c -----------------------------------------------------------------------------

@c TODO: DOKUMENTATION FUER DOUBLE_FACTORIAL FEHLT

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{!!}
@deffn {Operator} !!
@ifinfo
@fnindex Doppelte Fakult@"at
@end ifinfo

@c The double factorial operator.

Ist der Operator der doppelten Fakult@"at.

@c For an integer, float, or rational number @code{n}, @code{n!!} evaluates to 
@c the product @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))} where @code{k} is 
@c equal to @code{entier (n/2)}, that is, the largest integer less than or equal
@c to @code{n/2}. Note that this definition does not coincide with other 
@c published definitions for arguments which are not integers.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

F@"ur eine ganze Zahl, rationale Zahl oder Gleitkommazahl @code{n},  wird 
@code{n!!} zu dem Produkt @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))} 
vereinfacht, wobei @code{k} gleich @code{floor(n/2)} ist und @code{floor} die 
gr@"o@ss{}te ganze Zahl liefert, die kleiner oder gleich @code{n/2} ist.  Diese 
Definition entspricht f@"ur nicht ganze Zahlen nicht der @"ublichen Definition.

@c For an even (or odd) integer @code{n}, @code{n!!} evaluates to the product of
@c all the consecutive even (or odd) integers from 2 (or 1) through @code{n} 
@c inclusive.

F@"ur eine gerade (oder ungerade) ganze Zahl wird @code{n!!} zum Produkt aller
aufeinanderfolgenden geraden (oder ungeraden) ganzen Zahlen beginnend mit 2 
(oder 1) einschlie@ss{}lich @code{n} vereinfacht.

@c For an argument @code{n} which is not an integer, float, or rational,
@c @code{n!!} yields a noun form @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? 
@c OR TOO MUCH DETAIL ???

F@"ur ein Argument @code{n}, das keine ganze, rationale oder Gleitkommazahl ist, 
gibt @code{n!!} die Substantivform @code{genfact(n, n/2,2)} zur@"uck.

Maxima kennt noch die Funktion @code{double_factorial}, die wesentlich 
allgemeiner definiert ist.  Siehe @code{double_factorial}.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{binomial}
@deffn {Funktion} binomial (@var{x}, @var{y})

@c The binomial coefficient @code{@var{x}!/(@var{y}! (@var{x} - @var{y})!)}. If 
@c @var{x} and @var{y} are integers, then the numerical value of the binomial
@c coefficient is computed. If @var{y}, or @var{x - y}, is an integer, the 
@c binomial coefficient is expressed as a polynomial.

Der Binomialkoeffizient @code{@var{x}!/(@var{y}! (@var{x} - @var{y})!)}.  Sind
die Argumente @var{x} und @var{y} ganze Zahlen, wird der Binomialkoeffizient
numerisch berechnet.  Sind @var{y} oder @var{x-y} ganze Zahlen, dann wird der
Binomialkoeffizient zu einem Polynom vereinfacht.

Beispiele:

@example
(%i1) binomial (11, 7);
(%o1)                          330
(%i2) 11! / 7! / (11 - 7)!;
(%o2)                          330
(%i3) binomial (x, 7);
        (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
(%o3)   -------------------------------------------------
                              5040
(%i4) binomial (x + 7, x);
      (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
(%o4) -------------------------------------------------------
                               5040
(%i5) binomial (11, y);
(%o5)                    binomial(11, y)
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{factcomb}
@deffn {Funktion} factcomb (@var{expr})

@c Tries to combine the coefficients of factorials in @var{expr} with the 
@c factorials themselves by converting, for example, @code{(n + 1)*n!} into 
@c @code{(n + 1)!}.

Fasst Faktoren in Ausdr@"ucken mit Fakult@"aten zusammen.  Zum Beispiel wird 
@code{(n+1)*n!} zu @code{(n+1)!} zusammengefasst.

@c @code{sumsplitfact} if set to @code{false} will cause @code{minfactorial} to
@c be applied after a @code{factcomb}.

Hat die Optionsvariable @code{sumsplitfact} den Wert @code{false}, wird die
Vereinfachung mit der Funktion @code{minfactorial} nach der Funktion
@code{factcomb} angewendet.

@c Example:
@c UH, THESE ARE THE EXPRESSIONS WHICH WERE GIVEN IN 
@c THE PREVIOUS REVISION OF THIS FILE, BUT IN THIS CASE
@c factcomb HAS NO EFFECT -- I GUESS A DIFFERENT EXAMPLE IS CALLED FOR
@c (n + 1)^b*n!^b;
@c factcomb (%);
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{factorial}
@anchor{!}
@deffn  {Funktion} factorial (@var{x})
@deffnx {Operator} !
@ifinfo
@fnindex Fakult@"at
@end ifinfo

@c The factorial operator. For any complex number @code{x}, except for negative 
@c integers, @code{x!} is defined as @code{gamma(x+1)}.

@code{factorial} ist die Funktion f@"ur die Berechnung der Fakult@"at.  Der 
Operator f@"ur die Fakult@"at @code{!}, ist identisch mit der Funktion.  F@"ur 
jede komplexe Zahl @code{x}, einschlie@ss{}lich ganze und rationale Zahlen, 
sowie Gleitkommazahlen und mit Ausnahme der negative ganzen Zahlen, ist die 
Fakult@"at definiert als @code{gamma(x+1}.

@c For an integer @code{x}, @code{x!} simplifies to the product of the integers 
@c from 1 to @code{x} inclusive. @code{0!} simplifies to 1. For a real or 
@c complex number in float or bigfloat precision @code{x}, @code{x!} simplifies
@c to the value of @code{gamma (x+1)}. For @code{x} equal to @code{n/2} where 
@c @code{n} is an odd integer, @code{x!} simplifies to a rational factor times 
@c @code{sqrt (%pi)} (since @code{gamma (1/2)} is equal to @code{sqrt (%pi)}).

F@"ur eine ganze Zahl @code{x}, vereinfacht @code{x!} zum Produkt der ganzen 
Zahlen von 1 bis einschlie@ss{}lich @code{x}.  @code{0!} vereinfacht zu 1.  
F@"ur eine Gleitkommazahl vereinfacht @code{x!} zu @code{gamma(x+1)}.  F@"ur 
eine halbzahlige rationale Zahl @code{n/2}, wobei @code{n} eine ungerade ganze 
Zahl ist, vereinfacht @code{(n/2)!} zu einem rationalen Faktor multipliziert mit
@code{sqrt(%pi)}.  F@"ur jedes andere Argument wird @code{x!} nicht vereinfacht.

@c The option variables @code{factlim} and @code{gammalim} control the numerical 
@c evaluation of factorials for integer and rational arguments. The functions 
@c @code{minfactorial} and @code{factcomb} simplifies expressions containing 
@c factorials. See @code{factlim}, @code{gammalim}, @code{minfactorial} and 
@c @code{factcomb}.

Die Optionsvariablen @code{factlim} und @code{gammalim} steuern die numerische
Berechnung von Ausdr@"ucken, die Fakult@"aten enthalten.  Siehe @code{factlim} 
und @code{gammalim}.

Die Funktionen @code{minfactorial} und @code{factcomb} vereinfachen 
Ausdr@"ucken, die die Fakult@"at enthalten.  Siehe @code{minfactorial} und 
@code{factcomb}.

@c The functions @code{gamma}, @code{bffac}, and @code{cbffac} are varieties of 
@c the gamma function. @code{bffac} and @code{cbffac} are called internally by 
@c @code{gamma} to evaluate the gamma function for real and complex numbers in 
@c bigfloat precision.

Die Funktionen @code{gamma}, @code{bbfac} und @code{cbffac} sind Varianten der
Gamma Funktion.  @code{bffac} und @code{cbffac} werden intern von Maxima 
aufgerufen, um die Gammafunktion f@"ur reelle und komplexe gro@ss{}e 
Gleitkommazahlen zu berechnen.

@c @code{makegamma} substitutes @code{gamma} for factorials and related 
@c functions.

Die Funktion @code{makegamma} ersetzt die Gamma Funktion @code{gamma} f@"ur die
Fakult@"at und verwandte Funktionen in einem Ausdruck.

@c Maxima knows the derivative of the factorial function and the limits for 
@c specific values like negative integers.

Maxima kennt die Ableitung der Fakult@"at und den Grenzwert f@"ur spezielle Wert
wie negative ganze Zahlen.

@c The option variable @code{factorial_expand} controls the simplification of 
@c expressions like @code{(n+x)!}, where @code{n} is an integer.

Die Optionsvariable @code{factorial_expand} kontrolliert die Vereinfachung von 
Aus@-dr@"u@-cken wie @code{(n+1)!}, wobei @code{n} eine ganze Zahl ist.

@c See also @code{binomial}.

Siehe auch @code{binomial}.

Beispiele:

@c The factorial of an integer is simplified to an exact number unless the 
@c operand is greater than @code{factlim}. The factorial for real and complex 
@c numbers is evaluated in float or bigfloat precision.

Die Fakult@"at einer ganzen Zahl wird zu einer exakten Zahl vereinfacht, wenn
das Argument nicht gr@"o@ss{}er als @code{factlim} ist.  Die Fakult@"at f@"ur 
reelle und komplexe Zahlen wird in als Gleitkommazahl berechnet.

@example
(%i1) factlim:10;
(%o1)                                 10
(%i2) [0!, (7/2)!, 8!, 20!];
                            105 sqrt(%pi)
(%o2)                   [1, -------------, 40320, 20!]
                                 16
(%i3) [4.77!, (1.0+%i)!];
(%o3)    [81.44668037931197, 
          .3430658398165454 %i + .6529654964201665]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 
       3.430658398165454b-1 %i + 6.529654964201667b-1]
@end example

@c The factorial of a known constant, or general expression is not simplified. 
@c Even so it may be possible to simplify the factorial after evaluating the 
@c operand.

Die Fakult@"at einer komplexen Zahl, bekannten Konstanten oder eines allgemeinen
Ausdrucks wird nicht vereinfacht.  Der Vereinfachung kann m@"oglich sein, wenn 
der Operand zu einer Zahl ausgewertet werden kann.

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165454 %i + .6529654964201665, 
       7.188082728976031, 
       4.260820476357003, 1.227580202486819]
@end example

@c REMOVING THIS EXAMPLE. IT IS NOT SPECIFIC FOR THE FACTORIAL FUNCTION:
@c The factorial of an unbound symbol is not simplified.

@c @c ===beg===
@c @c kill (foo);
@c @c foo!;
@c @c ===end===
@c @example
@c (%i1) kill (foo);
@c (%o1)                         done
@c (%i2) foo!;
@c (%o2)                         foo!
@c @end example

@c Factorials are simplified, not evaluated. Thus @code{x!} may be replaced 
@c even in a quoted expression.

Fakult@"aten werden vereinfacht und nicht ausgewertet.  Daher kann @code{x!} 
auch in Ausdr@"ucken ersetzt werden, deren Auswertung mit dem Quote-Operator 
verhindert wurde.

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                                             2432902008176640000]
@end example

@c Maxima knows the derivative of the factorial function.

Maxima kennt die Ableitung der Fakult@"at.

@example
(%i1) diff(x!,x);
(%o1)                           x! psi (x + 1)
                                      0
@end example

@c The option variable @code{factorial_expand} controls expansion and 
@c simplification of expressions with the factorial function.

Die Optionsvariable @code{factorial_expand} steuert die Expansion und
Vereinfachung von Ausdr@"ucken, die die Fakult@"at enthalten.

@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                                n + 1
@end example
@end deffn

@c --- 17.10.2010 DK -----------------------------------------------------------
@anchor{factlim}
@defvr {Optionsvariable} factlim
Standardwert: 100000

@c @code{factlim} specifies the highest factorial which is automatically 
@c expanded. If it is -1 then all integers are expanded.

Die Optionsvariable @code{factlim} spezifiziert die gr@"o@ss{}te ganze Zahl, 
f@"ur die die Fakult@"at einer ganzen Zahl berechnet wird.  Wenn @code{factlim} 
den Wert -1 hat, wird die Fakult@"at f@"ur jede ganze Zahl berechnet.

@c TODO: IN ABHAENIGKEIT VON DER LISP IMPLEMENTATION GIBT ES GRENZEN FUER DIE
@c       GROESSTE ZAHL.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{factorial_expand}
@defvr {Optionsvariable} factorial_expand
Standardwert: @code{false}

@c The option variable @code{factorial_expand} controls the simplification of 
@c expressions like @code{(n+1)!}, where @code{n} is an integer. See @code{!} 
@c for an example.

Die Optionsvariable @code{factorial_expand} kontrolliert die Vereinfachung von
Aus@-dr@"u@-cken wie @code{(n+1)!}, wobei @code{n} eine ganze Zahl ist.  Siehe
@code{factorial} f@"ur ein Beispiel.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{genfact}
@deffn {Funktion} genfact (@var{x}, @var{y}, @var{z})

@c Returns the generalized factorial, defined as
@c @code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Thus, for integral @var{x},
@c @code{genfact (x, x, 1) = x!} and @code{genfact (x, x/2, 2) = x!!}.

Gibt die verallgemeinerte Fakult@"at zur@"uck, die als @code{x (x-z) (x - 2 z) 
... (x - (y - 1) z)} definiert ist.  Damit gilt f@"ur ein ganzzahliges Argument 
@var{x}, @code{genfact (x, x, 1) = x!} und @code{genfact (x, x/2, 2) = x!!}.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{minfactorial}
@deffn {Funktion} minfactorial (@var{expr})

@c Examines @var{expr} for occurrences of two factorials which differ by an 
@c integer. @code{minfactorial} then turns one into a polynomial times the 
@c other.

Treten mehrere Fakult@"aten in einem Ausdruck @var{expr} auf, die sich nur um
ganze Zahlen voneinander unterscheiden, werden diese vereinfacht.

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO MEAN. !!!
@c minfactorial DOESN'T SEEM TO DO ANYTHING binomial DOESN'T DO BY ITSELF !!!
@c LOOKING AT THE minfactorial CODE DOESN'T HELP !!!
@c If exp involves binomial coefficients then they will be
@c converted into ratios of factorials.

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{sumsplitfact}
@defvr {Optionsvariable} sumsplitfact
Standardwert: @code{true}

@c When @code{sumsplitfact} is @code{false},
@c "IS APPLIED" -- UNDER WHAT CIRCUMSTANCES EXACTLY ??
@c @code{minfactorial} is applied after a @code{factcomb}.

Hat die Optionsvariable @code{sumsplitfact} den Wert @code{false}, wird die
Vereinfachung mit der Funktion @code{minfactorial} nach der Funktion
@code{factcomb} angewendet.

@c TODO: EIN BEISPIEL
@end defvr

@c -----------------------------------------------------------------------------
@node Algebraische Funktionen, Exponential- und Logarithmusfunktion, Funktionen der Kombinatorik, Mathematische Funktionen
@section Algebraische Funktionen
@c -----------------------------------------------------------------------------

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{isqrt}
@deffn {Funktion} isqrt (@var{x})

@c Returns the "integer square root" of the absolute value of @var{x}, which is 
@c an integer.

Gibt die ganzzahlige Wurzel des Betrages von @var{x} zur@"uck, wenn @var{x} eine
ganze Zahl ist.  Andernfalls wird eine Substantivform zur@"uckgegeben.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{sqrt}
@deffn {Funktion} sqrt (@var{x})

@c The square root of @var{x}. It is represented internally by 
@c @code{@var{x}^(1/2)}.  See also @code{rootscontract}.

Ist die Wurzelfunktion.  Intern stellt Maxima die Wurzelfunktion als
@code{sqrt@var{x}^(1/2)} dar.  Siehe auch die Funktion @code{rootscontract}.

@c @code{radexpand} if @code{true} will cause nth roots of factors of a product
@c which are powers of n to be pulled outside of the radical, e.g.
@c @code{sqrt(16*x^2)} will become @code{4*x} only if @code{radexpand} is 
@c @code{true}.

Hat die Optionsvariable @code{radexpand} den Wert @code{true}, werden die
n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel herausgezogen.
So wird zum Beispiel @code{sqrt(16*x^2)} nur dann zu @code{4*x} vereinfacht,
wenn @code{radexpand} den Wert @code{true} hat.
@end deffn

@c -----------------------------------------------------------------------------
@node Exponential- und Logarithmusfunktion, Winkelfunktionen, Algebraische Funktionen, Mathematische Funktionen
@section Exponential- und Logarithmusfunktion
@c -----------------------------------------------------------------------------

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{exp}
@deffn {Funktion} exp (@var{x})

@c Represents the exponential function. Instances of @code{exp (@var{x})} in 
@c input are simplified to @code{%e^@var{x}}; @code{exp} does not appear in
@c simplified expressions.

Ist die Exponentialfunktion.  Die Exponentialfunkton @var{exp} wird sofort zu
@code{%e^@var{x}} vereinfacht und tritt in vereinfachten Ausdr@"ucken nicht auf.

@c @code{demoivre} if @code{true} causes @code{%e^(a + b %i)} to simplify to
@c @code{%e^(a (cos(b) + %i sin(b)))} if @code{b} is free of @code{%i}. See 
@c @code{demoivre}.

Hat die Optionsvariable @code{demoivre} den Wert @code{true}, werden Ausdr@"ucke
der Form @code{%e^(a + b %i)} zu @code{%e^(a (cos(b) + %i sin(b)))} vereinfacht,
wobei @var{a} und @var{b} reelle Ausdr@"ucke sind.

@c @code{%emode}, when @code{true}, causes @code{%e^(%pi %i x)} to be 
@c simplified. See @code{%emode}.

Hat die Optionsvariable @code{%emode} den Wert @code{true}, dann werden
Ausdr@"ucke der Form  @code{%e^(%pi %i x)} vereinfacht.  Siehe @mrefdot{%emode}

@c @code{%enumer}, when @code{true} causes @code{%e} to be replaced by
@c 2.718...  whenever @code{numer} is @code{true}. See @code{%enumer}.

Hat die Optionsvariable @code{%enumer} den Wert @code{true}, wird die Konstante
@code{%e} durch ihren nummerischen Wert 2.718@dots{} ersetzt, sobald auch die
Optionsvariable @code{numer} den Wert @code{true} hat.  Siehe @mrefdot{%enumer}
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{%emode}
@defvr {Optionsvariable} %emode
Standardwert: @code{true}

@c When @code{%emode} is @code{true}, @code{%e^(%pi %i x)} is simplified as 
@c follows.

Hat die Optionsvariable @code{%emode} den Wert @code{true}, wird 
@code{%e^(%pi %i x)} wie folgt vereinfacht:

@c @code{%e^(%pi %i x)} simplifies to @code{cos (%pi x) + %i sin (%pi x)} if 
@c @code{x} is a floating point number, an integer, or a multiple of 1/2, 1/3, 
@c 1/4, or 1/6, and then further simplified.

@code{%e^(%pi %i x)} wird zu @code{cos (%pi x) + %i sin (%pi x)} vereinfacht, 
wenn @code{x} eine Gleitkommazahl, eine ganze Zahl oder ein vielfaches von
1/2, 1/3, 1/4 oder 1/6 ist. 

@c For other numerical @code{x}, @code{%e^(%pi %i x)} simplifies to 
@c @code{%e^(%pi %i y)} where @code{y} is @code{x - 2 k} for some integer 
@c @code{k} such that @code{abs(y) < 1}.  

F@"ur andere nummerische Werte @code{x} wird @code{%e^(%pi %i x)} zu 
@code{%e^(%pi %i y)} vereinfacht, wobei @code{y} eine ganze Zahl @code{x - 2 k} 
mit einem @code{k} ist, so dass @code{abs(y) < 1} gilt.

@c When @code{%emode} is @code{false}, no special simplification of 
@c @code{%e^(%pi %i x)} is carried out.

Hat @code{%emode} den Wert @code{false}, werden keine speziellen Vereinfachungen
f@"ur den Ausdruck @code{%e^(%pi %i x)} vorgenommen.

@c NEED EXAMPLES HERE
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{%enumer}
@defvr {Optionsvariable} %enumer
Standardwert: @code{false}

@c When @code{%enumer} is @code{true}, @code{%e} is replaced by its numeric 
@c value 2.718...  whenever @code{numer} is @code{true}. 

Hat @code{%enumer} den Wert @code{true}, wird die Konstante @code{%e} immer dann
durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable @code{numer} den
Wert @code{true} hat.

@c When @code{%enumer} is @code{false}, this substitution is carried out only 
@c if the exponent in @code{%e^x} evaluates to a number.

Hat @code{%enumer} den Wert @code{false}, wird die Konstante @code{%e} nur dann
durch ihren nummerischen Wert ersetzt, wenn der Exponent von @code{%e^x} zu 
einer Gleitkommazahl ausgewertet wird.

@c See also @code{ev} and @code{numer}.

Siehe auch @mref{ev} und @mrefdot{numer}

   @c NEED EXAMPLES HERE
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{%e_to_numlog}
@defvr {Optionsvariable} %e_to_numlog
Standardwert: @code{false}

@c When @code{true}, @code{r} some rational number, and @code{x} some 
@c expression, @code{%e^(r*log(x))} will be simplified into @code{x^r} . It 
@c should be noted that the @code{radcan} command also does this transformation,
@c and more complicated transformations of this ilk as well. The 
@c @code{logcontract} command "contracts" expressions containing @code{log}.

Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck der Form @code{%e^(r*log(x))} zu @code{x^r} vereinfacht.  Dabei sind 
@code{r} eine rationale Zahl und @code{x} ein beliebiger Ausdruck.  Die Funktion 
@code{radcan} f@"uhrt diese Vereinfachung ebenfalls aus.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{log}
@deffn {Funktion} log (@var{x})

@c Represents the natural (base @math{e}) logarithm of @var{x}.

Ist der nat@"urliche Logaritmus zur Basis @math{e}.

@c Maxima does not have a built-in function for the base 10 logarithm or other 
@c bases. @code{log10(x) := log(x) / log(10)} is a useful definition.

Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10 oder anderen 
Basen.  Eine einfache Definition ist zum Beispiel 
@code{log10(x) := log(x)/log(10)}.

@c Simplification and evaluation of logarithms is governed by several global 
@c flags:

F@"ur die Vereinfachung und Auswertung der Logarithmusfunktion hat Maxima
verschiedene Optionsvariablen:

@c @code{logexpand} - causes @code{log(a^b)} to become @code{b*log(a)}. If it 
@c is set to @code{all}, @code{log(a*b)} will also simplify to 
@c @code{log(a)+log(b)}. If it is set to @code{super}, then @code{log(a/b)} will
@c also simplify to @code{log(a)-log(b)} for rational numbers @code{a/b}, 
@c @code{a#1}.  (@code{log(1/b)}, for @code{b} integer, always simplifies.)  If
@c it is set to @code{false}, all of these simplifications will be turned off.

@table @code
@item logexpand
@code{log(a^b)} wird zu @code{b*log(a)} vereinfacht.  Hat @code{logexpand} den 
Wert @code{all}, wird zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)} 
vereinfacht.  Mit den Wert @code{super} vereinfacht Maxima weiterhin 
@code{log(a/b)} zu @code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl 
ist.  @code{log(1/b} wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.  Hat
die Optionsvariable @code{logexpand} den Wert @code{false} werden alle obigen
Vereinfachungen ausgeschaltet.

@c @code{logsimp} - if @code{false} then no simplification of @code{%e} to a 
@c power containing @code{log}'s is done.

@item logsimp
Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @code{exp}, die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.

@c @code{lognumer} - if @code{true} then negative floating point arguments to
@c @code{log} will always be converted to their absolute value before the 
@c @code{log} is taken.  If @code{numer} is also @code{true}, then negative 
@c integer arguments to @code{log} will also be converted to their absolute 
@c value.

@item lognumer
Hat die Optionsvariable @code{lognumer} den Wert @code{true}, wird von
negativen Gleitkommazahlen der Absolutwert genommen, bevor der Logarithmus
berechnet wird.

@c @code{lognegint} - if @code{true} implements the rule @code{log(-n)} ->
@c @code{log(n)+%i*%pi} for @code{n} a positive integer.

@item lognegint
Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur postive @code{n} vereinfacht.

@c @code{%e_to_numlog} - when @code{true}, @code{r} some rational number, and
@c @code{x} some expression, @code{%e^(r*log(x))} will be simplified into
@c @code{x^r} .  It should be noted that the @code{radcan} command also
@c does this transformation, and more complicated transformations of this ilk as 
@c well. The @code{logcontract} command "contracts" expressions containing 
@c @code{log}.

@item %e_to_numlog
Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck @code{%e^(r*log(x))} zu @code{x^r} vereinfacht.  Dabei sind @code{r}  
eine rationale Zahl und @code{x} ein beliebiger Ausdruck.  Die Funktion 
@code{radcan} f@"uhrt diese Vereinfachung ebenfalls aus.
@end table
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logabs}
@defvr {Optionsvariable} logabs
Standardwert: @code{false}

@c When doing indefinite integration where logs are generated, e.g. 
@c @code{integrate(1/x,x)}, the answer is given in terms of @code{log(abs(...))}
@c if @code{logabs} is @code{true}, but in terms of @code{log(...)} if 
@c @code{logabs} is @code{false}.  For definite integration, the 
@c @code{logabs:true} setting is used, because here "evaluation" of the 
@c indefinite integral at the endpoints is often needed.

Werden unbestimmte Integrale mit Logarithmusfunktionen erzeugt, zum Beispiel
@code{integrate(1/x,x)}, wird der Betrag der Argumente der 
Logarithmusfunktionen gebildet @code{log(abs(...))}, wenn die Optionsvariable
@code{logabs} den Wert @code{true} hat.  Ist der Wert @code{false} werden keine
Betr@"age gebildet @code{log(...)}. 

Bei der Berechnung von bestimmten Integralen setzt Maxima die Optionsvariable
@code{logabs} zu den Wert @code{false}.  
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logarc}
@deffn  {Funktion} logarc (@var{expr})
@deffnx {Optionsvariable} logarc

@c When the global variable @code{logarc} is @code{true}, inverse circular and 
@c hyperbolic functions are replaced by equivalent logarithmic functions.
@c The default value of @code{logarc} is @code{false}.

Hat die Optionsvariable @code{logarc} den Wert @code{true}, werden inverse
Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen ersetzt.  Der 
Standardwert von @code{logarc} ist @code{false}.

@c The function @code{logarc(@var{expr})} carries out that replacement for an 
@c expression @var{expr} without setting the global variable @code{logarc}.

Die Funktion @code{logarc(@var{expr})} f@"uhrt diese Ersetzung aus, ohne dass 
die Optionsvariable @code{logarc} gesetzt wird.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logconcoeffp}
@defvr {Optionsvariable} logconcoeffp
Standardwert: @code{false}

@c Controls which coefficients are contracted when using @code{logcontract}.  
@c It may be set to the name of a predicate function of one argument.  E.g. if 
@c you like to generate SQRTs, you can do @code{logconcoeffp:'logconfun$
@c logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Then
@c @code{logcontract(1/2*log(x));} will give @code{log(sqrt(x))}.

Die Optionsvariable @code{logconcoeffp} kontrolliert, welche Koeffizienten von
der Funktion @code{logcontract} zusammengezogen werden.  Der Optionsvariablen 
kann der Name einer Aussagefunktion mit einem Argument zugewiesen werden. 
Sollen zum Beispiel Wurzeln generiert werden, kann folgende Definition 
verwendet werden: 
@example
logconcoeffp:'logconfun$ 
logconfun(m) := featurep(m,integer) or ratnump(m)$
@end example
Dann hat @code{logcontract(1/2*log(x))} das Ergebnis @code{log(sqrt(x))}.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logcontract}
@deffn {Funktion} logcontract (@var{expr})

@c Recursively scans the expression @var{expr}, transforming subexpressions of 
@c the form @code{a1*log(b1) + a2*log(b2) + c} into 
@c @code{log(ratsimp(b1^a1 * b2^a2)) + c}

Der Ausdruck @var{expr} wird rekursiv nach Ausdr@"ucken der Form 
@code{a1*log(b1) + a2*log(b2) + c} abgesucht.  Diese werden zu 
@code{log(ratsimp(b1^a1 * b2^a2)) + c} transformiert.

@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )
@end example

@c If you do @code{declare(n,integer);} then @code{logcontract(2*a*n*log(x));} 
@c gives @code{a*log(x^(2*n))}.  The coefficients that "contract" in this manner 
@c are those such as the 2 and the @code{n} here which satisfy
@c @code{featurep(coeff,integer)}.  The user can control which coefficients are
@c contracted by setting the option @code{logconcoeffp} to the name of a 
@c predicate function of one argument.  E.g. if you like to generate SQRTs, you 
@c can do @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or 
@c ratnump(m)$} . Then @code{logcontract(1/2*log(x));} will give 
@c @code{log(sqrt(x))}.

Wird die Variable @var{n} mit dem Kommando @code{declare(n, integer)} als eine 
ganze Zahl deklariert, dann wird  @code{logcontract(2*a*n*log(x))} zu
@code{a*log(x^(2*n))} vereinfacht.  Die Koeffizienten, die zusammengezogen 
werden, sind in diesem Fall die Zahl 2 und die Variable @var{n}, welche
die folgende Aussage erf@"ullen @code{featurep(coeff, integer)}. 
Der Nutzer kann kontrollieren, welche Koeffizienten zusammengezogen werden. 
Dazu wird der Optionsvariablen @code{logconcoeffp} eine Aussagefunktion mit 
einem Argument zugewiesen.  Sollen zum Beispiel Wurzeln generiert werden, kann 
folgende Definition verwendet: @code{logconcoeffp: 'logconfun$ logconfun(m) :=
featurep(m,integer) or ratnump(m)$}.  Dann ergibt sich f@"ur 
@code{logcontract(1/2*log(x))} das Ergebnis @code{log(sqrt(x))}.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logexpand}
@defvr {Optionsvariable} logexpand
Standardwert: @code{true}

@c Causes @code{log(a^b)} to become @code{b*log(a)}. If it is set to @code{all},
@c @code{log(a*b)} will also simplify to @code{log(a)+log(b)}.  If it is set to 
@c @code{super}, then @code{log(a/b)} will also simplify to @code{log(a)-log(b)}
@c for rational numbers @code{a/b}, @code{a#1}.  (@code{log(1/b)}, for integer 
@c @code{b}, always simplifies.)  If it is set to @code{false}, all of these 
@c simplifications will be turned off.

@code{log(a^b)} wird zu @code{b*log(a)} vereinfacht.  Hat @code{logexpand} den 
Wert @code{all}, wird zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)} 
vereinfacht.  Mit den Wert @code{super} vereinfacht Maxima weiterhin 
@code{log(a/b)} zu @code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl 
ist.  @code{log(1/b} wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.  Hat
die Optionsvariable @code{logexpand} den Wert @code{false} werden alle obigen
Vereinfachungen ausgeschaltet.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{lognegint}
@defvr {Optionsvariable} lognegint
Standardwert: @code{false}

@c If @code{true} implements the rule @code{log(-n)} -> @code{log(n)+%i*%pi} for
@c @code{n} a positive integer.

Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur postive @code{n} vereinfacht.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{lognummer}
@defvr {Optionsvariable} lognumer
Standardwert: @code{false}

@c If @code{true} then negative floating point arguments to @code{log} will 
@c always be converted to their absolute value before the @code{log} is taken.  
@c If @code{numer} is also @code{true}, then negative integer arguments to 
@c @code{log} will also be converted to their absolute value.

Hat die Optionsvariable @code{lognumer} den Wert @code{true}, wird von
negativen Gleitkommazahlen der Absolutwert genommen, bevor der Logarithmus
berechnet wird.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logsimp}
@defvr {Optionsvariable} logsimp
Standardwert: @code{true}

@c If @code{false} then no simplification of @code{%e} to a power containing 
@c @code{log}'s is done.

Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @code{exp}, die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{plog}
@deffn {Funktion} plog (@var{x})

@c Represents the principal branch of the complex-valued natural logarithm with 
@c @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

Gibt den Hauptwert des komplexen nat@"urlichen Logarithmus im Intervall
@code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@node Winkelfunktionen, Hyperbelfunktionen, Exponential- und Logarithmusfunktion, Mathematische Funktionen
@section Winkelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Winkelfunktionen::
* Funktionen und Variablen f@"ur Winkelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Winkelfunktionen, Funktionen und Variablen f@"ur Winkelfunktionen, Winkelfunktionen, Winkelfunktionen
@subsection Einf@"uhrung in Winkelfunktionen
@c -----------------------------------------------------------------------------

@c Maxima has many trigonometric functions defined.  Not all trigonometric
@c identities are programmed, but it is possible for the user to add many of 
@c them using the pattern matching capabilities of the system. The trigonometric
@c functions defined in Maxima are: 
@c @code{acos}, @code{acosh}, @code{acot}, @code{acoth}, @code{acsc},
@c @code{acsch}, @code{asec}, @code{asech}, @code{asin},
@c @code{asinh}, @code{atan}, @code{atanh}, @code{cos},
@c @code{cosh}, @code{cot}, @code{coth}, @code{csc}, @code{csch},
@c @code{sec}, @code{sech}, @code{sin}, @code{sinh}, @code{tan},
@c and @code{tanh}.  
@c There are a number of commands especially for handling trigonometric 
@c functions, see @code{trigexpand}, @code{trigreduce}, and the switch 
@c @code{trigsign}.  Two share packages extend the simplification rules built 
@c into Maxima, @code{ntrig} and @code{atrig1}. 
@c Do @code{describe(@var{command})} for details.

Maxima kennt viele Winkel- und Hyperbelfunktionen.  Nicht alle Identit@"aten 
f@"ur Winkel- und Hyperbelfunktionen sind programmiert, aber es ist m@"oglich 
weitere Identit@"aten mit der F@"ahigkeit der Erkennung von Mustern 
hinzuzuf@"ugen.

Maxima kennt die folgenden Winkel- und Hypelfunktionen sowie deren Inverse:

@multitable @columnfractions .15 .15 .15
@item @code{sin}   @tab @code{cos}       @tab @code{tan}
@item @code{sec}   @tab @code{csc}       @tab @code{cot}
@item @code{asin}  @tab @code{acos}      @tab @code{atan}
@item @code{asec}  @tab @code{acsc}      @tab @code{acot}
@item @code{sinh}  @tab @code{cosh}      @tab @code{tanh}
@item @code{sech}  @tab @code{csch}      @tab @code{coth}
@item @code{asinh} @tab @code{acosh}     @tab @code{atanh}
@item @code{asech} @tab @code{acsch}     @tab @code{acoth}
@end multitable

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Winkelfunktionen, , Einf@"uhrung in Winkelfunktionen, Winkelfunktionen
@subsection Funktionen und Variablen f@"ur Winkelfunktionen
@c -----------------------------------------------------------------------------

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acos (@var{x})
-- Arkuskosinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acot (@var{x})
-- Arkuskotangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acsc (@var{x})
-- Arkuskosekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asec (@var{x})
-- Arkussekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asin (@var{x})
-- Arkussinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{atan}
@deffn {Funktion} atan (@var{x})
-- Arkustangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{atan2}
@deffn {Funktion} atan2 (@var{y}, @var{x})

@c -- yields the value of @code{atan(@var{y}/@var{x})} in the interval 
@c @code{-%pi} to @code{%pi}.

-- Gibt den Wert von @code{atan(@var{y}/@var{x})} im Intervall @code{-%pi}
bis @code{%pi} zur@"uck.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cos (@var{x})
-- Kosinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cot (@var{x})
-- Kotangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} csc (@var{x})
-- Kosekans.

@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sec (@var{x})
-- Sekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{sin}
@deffn {Funktion} sin (@var{x})

Die Sinusfunktion.

Die Sinusfunktion kann f@"ur reelle und komplexe Gleitkommazahlen in doppelter
und in beliebiger Genauigkeit berechnet werden.  Ist das Argument eine ganze
oder rationale Zahl, wird die Sinusfunktion nicht numerisch berechnet und eine
Substantivform zur@"uckgegeben.  Die numerische Berechnung kann mit der 
Optionsvariablen @mref{numer} oder der Funktion @mref{float} erzwungen werden.

Die Sinusfunktion ist eine ungerade Funktion und hat Spiegelsymmetrie.  Maxima 
wendet diese Symmetrieeigenschaften automatisch f@"ur die Sinusfunktion an.

Ist das Argument @var{x} eine Matrix, eine Liste oder eine Gleichung wird die
Sinusfunktion auf die Elemente der Matrix, der Liste oder auf die beiden Seiten
der Gleichung angewendet.  Dieses Verhalten wird mit der Optionsvariablen
@mref{distribute_over} kontrolliert.

Die Sinusfunktion kann f@"ur symbolische Rechnungen verwendet werden.  Maxima
kann Ausdr@"ucke mit der Sinusfunktion differenzieren und integrieren, 
Grenzwerte mit der Sinusfunktion bestimmen sowie Gleichungen und 
Differentialgleichungen mit der Sinusfunktion l@"osen.

Das Argument der Sinusfunktion kann eine Taylorreihe sein.  In diesem Fall
wird die Taylorreihenentwicklung f@"ur die Sinusfunktion vollst@"andig 
ausgef@"uhrt.

Die folgenden Optionsvariablen kontrollieren die Vereinfachung der 
Sinusfunktion:

@table @code

@item distribute_over
Hat die Optionsvariable den Wert @code{true} und ist das Argument der 
Sinusfunktion eine Matrix, Liste oder Gleichung wird die Funktion auf die 
Elemente oder beiden Seiten der Gleichung angewendet.  Der Standardwert ist 
@code{true}.

@item %piargs
Hat die Optionsvariable den Wert @code{true}, vereinfacht die Sinusfunktion
f@"ur ganzahlige und halbzahlige Vielfache sowie Vielfache von @code{1/3} und 
@code{1/4} von @code{%pi}.  Der Standardwert ist @code{true}.

@item %iargs
Hat die Optionsvariable den Wert @code{true} und ist das Argument der 
Sinusfunktion ein Vielfaches von @code{%i} vereinfacht die Sinusfunktion zum 
Sinus Hyperbolicus.  Der Standardwert ist @code{true}.

@item trigsign
Hat die Optionsvariable den Wert @code{true}, wird die Eigenschaften, dass 
der Sinus eine ungerade Funktion ist, angewendet, zum Beispiel vereinfacht 
@code{sin(-x)} zu @code{-sin(x)}.  Der Standardwert ist @code{true}.

@item triginverses
Hat die Optionsvariable den Wert @code{true} und ist das Argument eine inverse
Winkelfunktion vereinfacht die Sinusfunktion zu einem einfachen algebraischen
Ausdruck, zum Beispiel vereinfacht @code{sin(acos(x))} zu @code{sqrt(1-x^2)}.
Der Standardwert ist @code{true}.

@item trigexpand
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion f@"ur 
ein Argument expandiert, das eine Summe oder ein Produkt mit einer ganzen Zahl 
ist.  Der Standardwert ist @code{false}.

@item exponentialize
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion in
die Exponentialform transformiert.  Der Standardwert ist @code{false}.

@item halfangles
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion f@"ur
halbzahlige Argumente zu einem @"aquivalenten Ausdruck transformiert.  Der 
Standardwert ist @code{false}.

@end table

F@"ur die Sinusfunktion hat Maxima die folgenden Eigenschaften definiert, die 
mit dem Kommando @code{properties(sin)} angezeigt werden:

@table @code
@item mirror symmetry
Die Sinusfunktion hat Spiegelsymmetrie.

@item deftaylor
Die Taylorreihenentwicklung der Sinusfunktion.

@item integral
Das Integral der Sinusfunktion.

@item distributes over bags
Die Sinusfunktion wird auf Elemente einer Matrix oder Liste oder auf beide
Seiten einer Gleichung angewendet.

@item rule
Die Sinusfunktion ist eine ungerade Funktion.

@item noun
Die Sinusfunktion hat eine Verbform.

@item gradef
Die Ableitung der Sinusfunktion.

@item transfun
Die Sinusfunktion ist eine kompilierte Lisp-Funktion.

@end table

Beispiele:

Numerische Berechnungen f@"ur Gleitkommazahlen:

@example
(%i1) sin(1+%i);
(%o1)                      sin(%i + 1)
(%i2) sin(1.0+%i);
(%o2)       .6349639147847361 %i + 1.298457581415977
(%i3) sin(1.0b0+%i);
(%o3)     6.349639147847361b-1 %i + 1.298457581415977b0
(%i4) sin(1.0b0),fpprec:45;
(%o4)   8.41470984807896506652502321630298999622563061b-1
@end example

Einige Vereinfachungen der Sinusfunktionen:

@example
(%i5) sin(%i*(x+y));
(%o5)                    %i sinh(y + x)
(%i6) sin(%pi/3);
                             sqrt(3)
(%o6)                        -------
                                2
(%i2) sin(x+y),trigexpand:true;
(%o2)             cos(x) sin(y) + sin(x) cos(y)
(%i3) sin(2*x+y),trigexpand:true;
           2         2
(%o3)  (cos (x) - sin (x)) sin(y) + 2 cos(x) sin(x) cos(y)
@end example

Grenzwerte, Ableitungen und Integrale mit der Sinusfunktion:

@example
(%i4) limit(sin(x)/x,x,0);
(%o4)                          1
(%i5) diff(sin(sqrt(x))/x,x);
                  cos(sqrt(x))   sin(sqrt(x))
(%o5)             ------------ - ------------
                        3/2            2
                     2 x              x
(%i6) integrate(sin(x^3),x);
@group
(%o6) 
                         1      3                     1        3
        gamma_incomplete(-, %i x ) + gamma_incomplete(-, - %i x )
                         3                            3
      - ---------------------------------------------------------
                                   12
@end group
@end example

Reihenentwicklung der Sinusfunktion:

@example
(%i7) taylor(sin(x),x,0,3);
@group
                              3
                             x
(%o7)/T/                 x - -- + . . .
                             6
@end group
@end example
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} tan (@var{x})
-- Tangens.
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%piargs}
@defvr {Optionsvariable} %piargs
Standardwert: @code{true}

@c When @code{%piargs} is @code{true}, trigonometric functions are simplified to
@c algebraic constants when the argument is an integer multiple of
@c @iftex
@c @math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4}, or @math{\pi/6}.
@c @end iftex
@c @ifnottex
@c @math{%pi}, @math{%pi/2}, @math{%pi/3}, @math{%pi/4}, or @math{%pi/6}.
@c @end ifnottex

Hat @code{%piargs} den Wert @code{true}, werden Winkel- und Hyperbelfunktionen 
sowie deren Inverse zu algebraischen Konstanten vereinfacht, wenn das Argument
ein ganzzahliges Vielfaches der folgenden Konstanten ist:
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4} oder @math{\pi/6}.
@end iftex
@ifnottex
@code{%pi}, @code{%pi/2}, @code{%pi/3}, @code{%pi/4} oder @code{%pi/6}.
@end ifnottex

@c Maxima knows some identities which can be applied when 
@c are multiplied by an integer variable (that is, a symbol declared to be 
@c integer).

Maxima kennt weiterhin einige Identit@"aten, wenn die Konstante
@iftex 
@math{\pi}
@end iftex
@ifnottex 
@code{%pi}
@end ifnottex
mit einer Variablen multipliziert wird, die als ganzzahlig deklariert wurde.

Beispiele:

@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example

@c @iftex
@c Some identities are applied when @math{\pi} and @math{\pi/2} are multiplied 
@c by an integer variable.
@c @end iftex
@c @ifnottex
@c Some identities are applied when @math{%pi} and @math{%pi/2} are multiplied 
@c by an integer variable.
@c @end ifnottex

Weitere Identit@"aten werden angewendet, wenn
@iftex 
@math{\pi} und @math{\pi/2}
@end iftex 
@ifnottex 
@code{%pi} und @code{%pi/2}
@end ifnottex
mit einer ganzzahligen Variable multipliziert werden.

@example
(%i1) declare (n, integer, m, even)$
@group
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%iargs}
@defvr {Optionsvariable} %iargs
Standardwert: @code{true}

@c When @code{%iargs} is @code{true}, trigonometric functions are simplified to
@c hyperbolic functions
@c @iftex
@c when the argument is apparently a multiple of the imaginary unit @math{i}.
@c @end iftex
@c @ifnottex
@c when the argument is apparently a multiple of the imaginary unit @math{%i}.
@c @end ifnottex

Hat @code{%iargs} den Wert @code{true}, werden Winkelfunktionen zu 
Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches der 
imagin@"aren Einheit
@iftex
@math{i}
@end iftex
@ifnottex
@code{%i}
@end ifnottex
ist.

@c Even when the argument is demonstrably real, the simplification is applied;
@c @iftex
@c Maxima considers only whether the argument is a literal multiple of @math{i}.
@c @end iftex
@c @ifnottex
@c Maxima considers only whether the argument is a literal multiple of @math{%i}.
@c @end ifnottex

Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgef@"uhrt, wenn das
Argument offensichtlich reel ist.

Beispiele:

@example
(%i1) %iargs : false$
@group
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
@end group
(%i3) %iargs : true$
@group
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end group
@end example

@c Even when the argument is demonstrably real, the simplification is applied.

Auch wenn das Argument offensichtlich reel ist, wird zu einer Hyperbelfunktion
vereinfacht.

@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{halfangles}
@defvr {Optionsvariable} halfangles
Standardwert: @code{false}

@c When @code{halfangles} is @code{true}, trigonometric functions of arguments 
@c @code{@var{expr}/2} are simplified to functions of @var{expr}.

Hat @code{halfangles} den Wert @code{true}, werden Winkel- und 
Hyperbelfunktionen mit halbzahligen Argumenten @code{@var{expr}/2} vereinfacht.

@c For a real argument @var{x} in the interval @code{0 < x < 2*%pi} the sine of 
@c the half-angle simplifies to a simple formula:

F@"ur ein reelles Argument @var{x} im Intervall @code{0 < x < 2*%pi} vereinfacht
der Sinus f@"ur ein halbzahliges Argument zu einer einfachen Formel: 

@example
                         sqrt(1 - cos(x))
                         ----------------
                             sqrt(2)
@end example

@c A complicated factor is needed to make this formula correct for all complex 
@c arguments @var{z}:

Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt ist f@"ur ein
komplexes Argument @var{z}:

@verbatim
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                            realpart(z)            realpart(z)
                      floor(-----------) - ceiling(-----------)
                               2 %pi                  2 %pi
                ((- 1)                                          + 1))
@end verbatim

@c Maxima knows this factor and similar factors for the functions @code{sin}, 
@c @code{cos}, @code{sinh}, and @code{cosh}. For special values of the argument 
@c @math{z} these factors simplify accordingly.

Maxima kennt diesen Faktor und @"ahnliche Faktoren f@"ur die Sinus, Cosinus, 
Sinus Hyperbolicus und Cosinus Hyperbolicus Funktionen.  F@"ur spezielle 
Argumente @math{z} dieser Funktionen vereinfachen diese Funktionen entsprechend.

Beispiele:

@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{ntrig}
@defvr {Paket} ntrig

@c The @code{ntrig} package contains a set of simplification rules that are
@c used to simplify trigonometric function whose arguments are of the form
@c @code{@var{f}(@var{n} %pi/10)} where @var{f} is any of the functions
@c @code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} and @code{cot}.

Das Paket @code{ntrig} enth@"alt Regeln, um Winkelfunktionen zu vereinfachen, 
die Argumente der Form @code{@var{f}(@var{n} %pi/10)} haben.  @var{f} ist eine 
der Funktionen @code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} oder 
@code{cot}.

Das Kommando @code{load(ntrig)} l@"adt das Paket.  Die Vereinfachungen werden
dann von Maxima automatisch ausgef@"uhrt.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpand}
@deffn {Funktion} trigexpand (@var{expr})

@c Expands trigonometric and hyperbolic functions of sums of angles and of 
@c multiple angles occurring in @var{expr}. For best results, @var{expr} should
@c be expanded. To enhance user control of simplification, this function expands
@c only one level at a time, expanding sums of angles or multiple angles.  To 
@c obtain full expansion into sines and cosines immediately, set the switch 
@c @code{trigexpand: true}.

Die Funktion @code{trigexpand} expandiert Winkel- und Hyperbelfunktionen im 
Ausdruck @var{expr}, die Summen und Vielfache von Winkeln als Argument haben.
Die besten Ergebnisse werden erzielt, wenn der Ausdruck @var{expr} zun@"achst
expandiert wird.

@c @code{trigexpand} is governed by the following global flags:

Folgende Schalter kontrollieren @code{trigexpand}:

@table @code
@c @item trigexpand
@c If @code{true} causes expansion of all expressions containing sin's and 
@c cos's occurring subsequently.

@item trigexpand
Wenn @code{true}, werden Sinus- und Cosinus-Funktionen expandiert.

@c @item halfangles
@c If @code{true} causes half-angles to be simplified away.

@item halfangles
Wenn @code{true}, werden Vereinfachungen f@"ur halbzahlige Argumente angewendet.

@c @item trigexpandplus
@c Controls the "sum" rule for @code{trigexpand}, expansion of sums (e.g.
@c @code{sin(x + y)}) will take place only if @code{trigexpandplus} is 
@c @code{true}.

@item trigexpandplus
Wenn @code{true}, werden Winkelfunktionen, die eine Summe als Argument haben,
wie zum Beispiel @code{sin(x+y)}, vereinfacht.

@c @item trigexpandtimes
@c Controls the "product" rule for @code{trigexpand}, expansion of products 
@c (e.g. @code{sin(2 x)}) will take place only if @code{trigexpandtimes} is 
@c @code{true}.

@item trigexpandtimes
Wenn @code{true},  werden Winkelfunktionen, die ein Produkt als Argument haben,
wie zum Beispiel @code{sin(2 x)}, vereinfacht.

@end table

Beispiele:

@example
@group
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
@group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end group
@end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandplus}
@defvr {Optionsvariable} trigexpandplus
Standardwert: @code{true}

@c @code{trigexpandplus} controls the "sum" rule for @code{trigexpand}.  Thus, 
@c when the @code{trigexpand} command is used or the @code{trigexpand} switch 
@c set to @code{true}, expansion of sums (e.g. @code{sin(x+y))} will take place 
@c only if @code{trigexpandplus} is @code{true}.

@code{trigexpandplus} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @code{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit Summen
als Argumente auftreten.  Hat @code{trigexpandplus} den Wert @code{true},
werden zum Beispiel Winkelfunktionen wie @code{sin(x+y)} vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandtimes}
@defvr {Optionsvariable} trigexpandtimes
Standardwert: @code{true}

@c @code{trigexpandtimes} controls the "product" rule for @code{trigexpand}.  
@c Thus, when the @code{trigexpand} command is used or the @code{trigexpand} 
@c switch set to @code{true}, expansion of products (e.g. @code{sin(2*x)}) will 
@c take place only if @code{trigexpandtimes} is @code{true}.

@code{trigexpandtimes} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @code{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit 
Produkten als Argumente auftreten.  Hat @code{trigexpandtimes} den Wert 
@code{true}, werden zum Beispiel Winkelfunktionen wie @code{sin(2 x)} 
vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{triginverses}
@defvr {Optionsvariable} triginverses
Standardwert: @code{true}

@c @code{triginverses} controls the simplification of the composition of 
@c trigonometric and hyperbolic functions with their inverse functions.

Kontrolliert die Vereinfachung, wenn das Argument einer Trigonometrischen oder
Hyperbolischen Funktion eine der inversen Funktion ist.

@c If @code{all}, both e.g. @code{atan(tan(@var{x}))} and 
@c @code{tan(atan(@var{x}))} simplify to @var{x}.

Hat @code{triginverses} den Wert @code{all}, vereinfachen beide Ausdr@"ucke
@code{atan(tan(@var{x}))} und @code{tan(atan(@var{x}))} zum Wert @var{x}.

@c If @code{true}, the @code{@var{arcfun}(@var{fun}(@var{x}))} simplification 
@c is turned off.

Hat @code{triginverses} den Wert @code{all}, wird
@code{@var{arcfun}(@var{fun}(@var{x}))} nicht vereinfacht.

@c If @code{false}, both the @code{@var{arcfun}(@var{fun}(@var{x}))} and
@c @code{@var{fun}(@var{arcfun}(@var{x}))} simplifications are turned off.

Hat @code{triginverses} den Wert @code{false}, werden
@code{@var{arcfun}(@var{fun}(@var{x}))} und 
@code{@var{fun}(@var{arcfun}(@var{x}))} nicht vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigreduce}
@deffn  {Funktion} trigreduce (@var{expr}, @var{x})
@deffnx {Funktion} trigreduce (@var{expr})

@c Combines products and powers of trigonometric and hyperbolic sin's and cos's 
@c of @var{x} into those of multiples of @var{x}. It also tries to eliminate 
@c these functions when they occur in denominators.  If @var{x} is omitted then 
@c all variables in @var{expr} are used.

Produkte und Potenzen von Trigonometrischen und Hyperbolischen Sinus und Cosinus
Funktionen mit dem Argument @var{x} werden zu Funktionen vereinfacht, die
Vielfache von @var{x} enthalten.  @code{trigreduce} versucht auch, Sinus und
Cosinus Funktionen in einem Nenner zu eleminieren.  Wird keine Variable @var{x}
angegeben, werden alle Variablen im Ausdruck @code{expr} betrachtet.

Siehe auch @mrefdot{poissimp}

@example
@group
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example

@c 
@c     OBSOLETE
@c     The behavior was changed in order to avoid calling expand in the core
@c     simplifier (trigi.lisp rev 1.31)
@c     See http://www.math.utexas.edu/pipermail/maxima/2008/010919.html.
@c 
@c The trigonometric simplification routines will use declared
@c information in some simple cases.  Declarations about variables are
@c used as follows, e.g.
@c 
@c ---beg---
@c declare(j, integer, e, even, o, odd)$
@c sin(x + (e + 1/2)*%pi);
@c sin(x + (o + 1/2)*%pi);
@c ---end---
@c @example
@c (%i1) declare(j, integer, e, even, o, odd)$
@c (%i2) sin(x + (e + 1/2)*%pi);
@c (%o2)                        cos(x)
@c (%i3) sin(x + (o + 1/2)*%pi);
@c (%o3)                       - cos(x)
@c @end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsign}
@defvr {Optionsvariable} trigsign
Standardwert: @code{true}

@c When @code{trigsign} is @code{true}, it permits simplification of negative
@c arguments to trigonometric functions. E.g., @code{sin(-x)} will become
@c @code{-sin(x)} only if @code{trigsign} is @code{true}.

Hat @code{trigsign} den Wert @code{true}, werden Trigonometrische Funktionen
mit einem negativem Argument vereinfacht.  Zum Beispiel vereinfacht in diesem
Fall @code{sin(-x)} zu @code{-sin(x)}.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsimp}
@deffn {Funktion} trigsimp (@var{expr})

@c @iftex
@c Employs the identities
@c @tex
@c $\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@c @end tex
@c and
@c @tex
@c $\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@c @end tex
@c to simplify expressions containing @code{tan}, @code{sec},
@c etc., to @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@c @end iftex
@c @ifnottex
@c Employs the identities @math{sin(x)^2 + cos(x)^2 = 1} and
@c @math{cosh(x)^2 - sinh(x)^2 = 1} to simplify expressions containing 
@c @code{tan}, @code{sec}, etc., to @code{sin}, @code{cos}, @code{sinh}, 
@c @code{cosh}.
@c @end ifnottex

Wendet die Identit@"aten
@iftex
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{sin(x)^2 + cos(x)^2 = 1}
@end ifnottex
und
@iftex
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{cosh(x)^2 - sinh(x)^2 = 1}
@end ifnottex
an, um Ausdr@"ucke, die Funktionen wie @code{tan}, @code{sec}, usw. enthalten, 
zu Ausdr@"ucken mit den Funktionen @code{sin}, @code{cos}, @code{sinh}, 
@code{cosh} zu vereinfachen.

@c @code{trigreduce}, @code{ratsimp}, and @code{radcan} may be able to further 
@c simplify the result.

Die Anwendung von Funktionen wie @code{trigreduce}, @code{ratsimp} und 
@code{radcan} kann den Ausdruck weiter vereinfachen.

@c @code{demo ("trgsmp.dem")} displays some examples of @code{trigsimp}.

Das Kommando @code{demo(trgsmp)} zeigt einige Beispiele.

@c MERGE EXAMPLES INTO THIS ITEM
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trigrat}
@deffn {Funktion} trigrat (@var{expr})

Gives a canonical simplifyed quasilinear form of a trigonometrical expression; 
@var{expr} is a rational fraction of several @code{sin}, @code{cos} or 
@code{tan}, the arguments of them are linear forms in some variables (or 
kernels) and @code{%pi/@var{n}} (@var{n} integer) with integer coefficients.
The result is a simplified fraction with numerator and denominator linear in 
@code{sin} and @code{cos}.  Thus @code{trigrat} linearize always when it is 
possible.

@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

The following example is taken from
Davenport, Siret, and Tournier, @i{Calcul Formel}, Masson (or in English,
Addison-Wesley), section 1.5.5, Morley theorem.

@example
(%i1) c : %pi/3 - a - b$
@group
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
@group
(%i3) ba : bc, c=a, a=c;
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
@group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
@group
(%i5) trigrat (ac2);
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Hyperbelfunktionen, Zufallszahlen, Winkelfunktionen, Mathematische Funktionen
@section Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Hyperbelfunktionen::
* Funktionen und Variablen f@"ur Hyperbelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Hyperbelfunktionen, Funktionen und Variablen f@"ur Hyperbelfunktionen, Hyperbelfunktionen, Hyperbelfunktionen
@subsection Einf@"uhrung in Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Hyperbelfunktionen, , Einf@"uhrung in Hyperbelfunktionen, Hyperbelfunktionen
@subsection Funktionen und Variablen f@"ur Hyperbelfunktionen

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acosh (@var{x})
-- Areakosinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acoth (@var{x})
-- Areakotangens Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acsch (@var{x})
-- Areakosekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asech (@var{x})
-- Areasekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asinh (@var{x})
-- Areasinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} atanh (@var{x})
-- Areatangens Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cosh (@var{x})
-- Kosinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} coth (@var{x})
-- Kotangens Hyperbolicus.

@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} csch (@var{x})
-- Kosekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sech (@var{x})
-- Sekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sinh (@var{x})
-- Sinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} tanh (@var{x})
-- Tangens Hyperbolicus.
@end deffn

@c -----------------------------------------------------------------------------
@node Zufallszahlen, , Hyperbelfunktionen, Mathematische Funktionen
@section Zufallszahlen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@deffn  {Funktion} make_random_state (@var{n})
@deffnx {Funktion} make_random_state (@var{s})
@deffnx {Funktion} make_random_state (true)
@deffnx {Funktion} make_random_state (false)
@c OMIT THIS FOR NOW. SEE COMMENT BELOW.
@c @defunx make_random_state (@var{a})

@c A random state object represents the state of the random number generator.
@c The state comprises 627 32-bit words.

Ein Zufallszustand repr@"asentiert den Zustand des Zufallszahlengenerators.  Der
Zustand enth@"alt 627 32-Bit Worte.

@c @code{make_random_state (@var{n})} returns a new random state object created 
@c from an integer seed value equal to @var{n} modulo 2^32. @var{n} may be 
@c negative.

@code{make_random_state(@var{n})} gibt einen neuen Zufallszustand zur@"uck, der 
aus einer ganzen Zahl @var{n} modulo 2^32 erzeugt wird.  @var{n} kann eine 
negative Zahl sein.

 @c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
 @c @code{make_random_state (@var{a})} returns a new random state object
 @c created from an array @var{a}, which must be a Lisp array of 32 unsigned
 @c bytes.

@c @code{make_random_state (@var{s})} returns a copy of the random state 
@c @var{s}.

@code{make_random_state(@var{s})} gibt eine Kopie des Zufallszutandes @var{s}
zur@"uck.

@c @code{make_random_state (true)} returns a new random state object, using the
@c current computer clock time as the seed.

@code{make_random_state(true)} gibt einen neuen Zufallszustand zur@"uck, der aus
der aktuellen Systemzeit des Computers erzeugt wird.

@c @code{make_random_state (false)} returns a copy of the current state of the 
@c random number generator.

@code{make_random_state(false)} gibt eine Kopie des aktuellen Zustands des
Zufallszahlengenerators zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Funktion} set_random_state (@var{s})

@c Copies @var{s} to the random number generator state.

Kopiert @var{s} in den Zufallszustand des Zufallszahlengenerators.

@c @code{set_random_state} always returns @code{done}.

@code{set_random_state} gibt immer @code{done} zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Funktion} random (@var{x})

@c Returns a pseudorandom number. If @var{x} is an integer, @code{random 
@c (@var{x})} returns an integer from 0 through @code{@var{x} - 1} inclusive. 
@c If @var{x} is a floating point number, @code{random (@var{x})} returns a 
@c nonnegative floating point number less than @var{x}. @code{random} complains 
@c with an error if @var{x} is neither an integer nor a float, or if @var{x} is 
@c not positive.

Erzeugt eine Pseudo-Zufallszahl.  Ist @var{x} eine ganze Zahl, gibt 
@code{random(@var{x})} eine ganze Zahl im Intervall 0 bis einschlie@ss{}lich
@code{@var{x}-1} zur@"uck.  Ist @var{x} eine Gleitkommazahl, gibt
@code{random(@var{x})} eine positive Gleitkommazahl zur@"uck, die kleiner als
@var{x} ist.  @code{random} gibt eine Fehlermeldung, wenn @var{x} weder eine
ganze Zahl noch eine Gleitkommazahl ist oder wenn @var{x} eine negative Zahl 
ist.

@c The functions @code{make_random_state} and @code{set_random_state} maintain 
@c the state of the random number generator.

Die Funktionen @code{make_random_state} und @code{set_random_state} verwalten
den Zustand des Zufallszahlengenerators.

@c The Maxima random number generator is an implementation of the Mersenne 
@c twister MT 19937.

Der Maxima-Zufallszahlengenerator ist eine Implementation des Mersenne twister
MT 19937.

Beispiele:

@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn

@c --- End of file MathFunctions.de.texi ---------------------------------------

