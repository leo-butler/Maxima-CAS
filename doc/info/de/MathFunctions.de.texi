@c -----------------------------------------------------------------------------
@c File        : MathFunctions.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 19.10.2010
@c Revision    : 27.02.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu 
* Funktionen f@"ur Zahlen::
* Funktionen f@"ur komplexe Zahlen::
* Funktionen der Kombinatorik::
* Wurzel-@comma{} Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur Zahlen, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen, Mathematische Funktionen
@section Funktionen f@"ur Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{abs}
@deffn {Funktion} abs (@var{expr})

Die Funktion @code{abs} ist die Betragsfunktion und f@"ur numerische und
symbolische Rechnungen geeignet.  Ist das Argument @var{expr} eine reelle oder
komplexe Zahl wird der Betrag berechnet.  Wenn m@"oglich werden allgemeine
Ausdr@"ucke mit der Betragsfunktion vereinfacht.  Maxima kann Ausdr@"ucke mit
der Betragsfunktion integrieren und ableiten sowie Grenzwerte von Ausdr@"ucken
mit der Betragsfunktion ermitteln.  Siehe auch @mrefcomma{diff}@ 
@mref{integrate} und @mrefdot{limit}  Das Paket @mref{abs_integrate} erweitert
Maximas M@"oglichkeiten, Integrale mit der Betragsfunktion zu berechnen.

Die Betragsfunktion wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe die Funktion @mrefcomma{cabs} um den Betrag eines komplexen Ausdrucks
oder Funktion zu berechnen.

Beispiele:

Berechnung des Betrages f@"ur reelle und komplexen Zahlen sowie numerische
Konstanten und unendliche Gr@"o@ss{}en.  Das erste Beispiel zeigt, wie die
Betragsfunktion von Maxima auf die Elemente einer Liste angewendet werden.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Vereinfachung von Ausdr@"ucken mit der Betragsfunktion.

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Ableitung und Integrale mit der Betragsfunktion.  Wird das Paket
@nref{abs_integrate} geladen, k@"onnen weitere Integrale mit der Betragsfunktion
gel@"ost werden.  Das letzte Beispiel zeigt die Laplacetransformation der
Betragsfunktion.

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{ceiling}
@deffn {Funktion} ceiling (@var{x})

Die Funktion @code{ceiling} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{ceiling} die kleinste
ganze Zahl zur@"uck, die gr@"o@ss{}er oder gleich @var{x} ist.

Die Funktion @code{ceiling} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{ceiling} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{ceiling}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{ceiling} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{floor} oder @mref{round} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{ceiling} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{floor} und @mrefdot{round}

Beispiele:

@example
(%i1) ceiling(ceiling(x));
(%o1)                      ceiling(x)
(%i2) ceiling(floor(x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) ceiling([n, abs(n), max (n, 6)]);
(%o4)               [n, abs(n), max(6, n)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @code{ceiling} und
@mref{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{ceiling}.

@example
(%i1) integrate(ceiling(x),x);
               (- ceiling(x) + 2 x + 1) ceiling(x)
(%o1)          -----------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{entier}
@deffn {Funktion} entier (@var{x})

@code{entier} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.
Siehe @mrefdot{floor}
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{floor}
@deffn {Funktion} floor (@var{expr})

Die Funktion @code{floor} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{floor} die gr@"o@ss{}te
ganze Zahl zur@"uck, die kleiner oder gleich @var{x} ist.

Die Funktion @code{floor} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{floor} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{floor}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{floor} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{ceiling} oder @mref{round} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{floor} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{round}

Beispiele:

@example
(%i1) floor(ceiling(x));
(%o1)                      ceiling(x)
(%i2) floor(floor(x));
(%o2)                       floor(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) floor([n, abs(n), min (n, 6)]);
(%o4)                [n, abs(n), min(6, n)]
(%i5) assume(x>0, x<1)$
(%i6) floor(x);
(%o6)                           0
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktionen @mref{ceiling} und
@code{floor} k@"onnen diese Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare (f, integervalued)$
(%i2) floor(f(x));
(%o2)                         f(x)
(%i3) ceiling(f(x) - 1);
(%o3)                       f(x) - 1
@end example

Maxima kennt das Integral der Funktion @code{floor}.

@example
(%i6) integrate(floor(x),x);
                 (- floor(x) + 2 x - 1) floor(x)
(%o6)            -------------------------------
                                2
@end example
@end deffn

@c --- 19.10.2010 DK -----------------------------------------------------------
@anchor{fix}
@deffn {Funktion} fix (@var{x})

@code{fix} ist eine andere Bezeichnung f@"ur die Funktion @code{floor}.  Siehe
@mrefdot{floor}
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmax}
@deffn {Funktion} lmax (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{max} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, wird ein Maxima-Fehler signalisiert.

Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i1) lmax(L);
(%o1)                        %e + 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{lmin}
@deffn {Funktion} lmin (@var{L})

Ist das Argument @var{L} eine Liste oder Menge, wird die Funktion @mref{min} auf
die Elemente der Liste oder Menge angewendet und das Ergebnis zur@"uckgegeben.
Ist @var{L} keine Liste oder Menge, wird ein Maxima-Fehler signalisiert.

Beispiel:

@example
(%i1) L:[1+%e, %pi, 3];
(%o1)                   [%e + 1, %pi, 3]
(%i2) lmin(L);
(%o2)                           3
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{max}
@deffn {Funktion} max (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
gr@"o@ss{}te Zahlenwert zur@"uckgegeben.  Treten symbolische Argumente oder
Ausdr@"ucke auf, gibt Maxima einen vereinfachten Ausdruck zur@"uck.

Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf} k@"onnen als Argument
auftreten und werden von @code{max} korrekt behandelt.

Die Vereinfachung der Funktion @code{max} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen 
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt
keine besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{max(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eleminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{max(x,2*x, 3*x)} zu @code{max(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{max} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die Aussagen
und Fakten der aktiven Kontexte.  Siehe das Kapitel 
@nrefdot{Funktionen und Variablen f@"ur Fakten}

Beispiele:

@example
(%i1) max(1.6, 3/2, 1);
(%o1)                          1.6
(%i2) max(1.5b0,1.5,3/2);
@group
                                3
(%o2)                           -
                                2
@end group
(%i3) max(%e,%pi,1,2,3);
(%o3)                          %pi
(%i4) max(1+%e,%pi,1,2,3);
(%o4)                        %e + 1
(%i5) max(minf,inf);
(%o5)                          inf
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{min}
@deffn {Funktion} min (@var{x_1}, @dots{}, @var{x_n})

Sind alle Argumente @var{x_1}, @dots{}, @var{x_n} Zahlen oder konstante
Ausdr@"ucke wie zum Beispiel @code{1+%e} oder @code{sin(1)}, dann wird der
kleinste Zahlenwert zur@"uckgegeben.  Treten symbolische Argumente oder
Ausdr@"ucke auf, gibt Maxima einen vereinfachten Ausdruck zur@"uck.

Die unendliche Gr@"o@ss{}en @mref{inf} und @mref{minf} k@"onnen als Argument
auftreten und werden von @code{min} korrekt behandelt.

Die Vereinfachung der Funktion @code{mmin} kann kontrolliert werden, in dem mit
der Funktion @mref{put} dem Symbol @code{trylevel} zu der Eigenschaft
@code{maxmin} ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte k@"onnen
mit der Funktion @code{put} gesetzt werden:

@table @code
@item put(trylevel, 1, maxmin)
@code{trylevel} hat den Wert 1.  Das ist der Standardwert.  Maxima f@"uhrt keine
besonderen Vereinfachungen aus.
@item put(trylevel, 2, maxmin)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an.
@item put(trylevel, 3, maxima)
Maxima wendet die Vereinfachung @code{min(e,-e) --> |e|} an und versucht
Ausdr@"ucke zu eleminieren, die zwischen zwei anderen Argumenten liegen.  So
wird zum Beispiel @code{min(x,2*x, 3*x)} zu @code{min(x, 3*x)} vereinfacht.
@end table

Mit dem Kommando @code{get(trylevel, maxmin)} wird der aktuelle Wert f@"ur
das Symbol @code{trylevel} angezeigt.  Siehe die Funktion @mrefdot{get}

@code{min} ber@"ucksichtigt bei der Vereinfachung von Ausdr@"ucken die Aussagen
und Fakten der aktiven Kontexte.  Siehe das Kapitel 
@nrefdot{Funktionen und Variablen f@"ur Fakten}

Beispiele:

@example
(%i1) min(1.6, 3/2, 1);
(%o1)                           1
(%i2) min(1.5b0,1.5,3/2);
                                3
(%o2)                           -
                                2
(%i3) min(%e,%pi,3);
(%o3)                          %e
(%i4) min(1+%e,%pi,3);
(%o4)                           3
(%i5) min(minf,inf);
(%o5)                         minf
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{round}
@deffn {Funktion} round (@var{expr})

Die Funktion @code{round} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Ist das Argument @var{expr} eine reelle Zahl, gibt @code{round} die am
n@"achsten liegende ganze Zahl zur@"uck.  Vielfache von 1/2 werden auf die 
n@"achste gerade ganze Zahl gerundet.

Die Funktion @code{round} gibt auch dann einen numerischen Wert zur@"uck, wenn
das Argument ein konstanter Ausdruck ist, wie zum Beispiel @code{1+%e}, der zu
einer reellen Zahl ausgewertet werden kann.  In diesem Fall wird der konstante
Ausdruck in eine gro@ss{}e Gleitkommazahl umgewandelt, auf die die Funktion
@code{round} angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von @code{round}
kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
@mref{fpprec} f@"ur die Berechnung von @code{round} um drei Stellen erh@"oht.

Wenn m@"oglich werden andere Ausdr@"ucke von Maxima vereinfacht.  Maxima kennt
inbesondere Vereinfachungen f@"ur den Fall, dass das Argument @var{expr} ein
Ausdruck mit den Funktionen @mref{ceiling} oder @mref{floor} ist.  Weiterhin
werden f@"ur die Vereinfachung die Aussagen und Fakten der aktiven Kontexte
herangezogen.  Siehe das Kapitel @nrefdot{Funktionen und Variablen f@"ur Fakten}

Ist das Argument @var{expr} der Funktion ein komplexer Ausdruck, wird eine
Substantivform zur@"uckgegeben.

@code{round} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Siehe auch die Funktionen @mref{ceiling} und @mrefdot{floor}

Beispiele:

@example
(%i1) round(floor(x));
(%o1)                       floor(x)
(%i2) round(round(x));
(%o2)                       round(x)
(%i3) declare(n, integer);
(%o3)                         done
(%i4) round([n, abs(n), min(n,6)]);
(%o4)                [n, abs(n), min(6, n)]
@end example

Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen, kann diese als
@mref{integervalued} deklariert werden.  Die Funktion @code{round} kann diese
Information nutzen, um Ausdr@"ucke zu vereinfachen.

@example
(%i1) declare(f, integervalued);
(%o1)                         done
(%i2) round(f(x));
(%o2)                         f(x)
(%i3) round(f(x) - 1);
(%o3)                       f(x) - 1
@end example
@end deffn

@c --- 22.02.2011 DK -----------------------------------------------------------
@anchor{signum}
@deffn {Funktion} signum (@var{expr})

Die Signumfunktion @code{signum} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Ist das Argument @var{expr} eine Zahl, ist das Ergebnis 0, 1
oder -1, wenn die Zahl Null, positiv oder negativ ist.  Das Argument kann auch
ein konstanter Ausdruck wie @code{%pi} oder @code{1+%e} sein.  Ist das Argument
@var{expr} eine komplexe Zahl, vereinfacht die Funktion @code{signum(expr)} zu
@code{expr/abs(expr)}.

Ist das Argument @var{expr} keine Zahl oder kein konstanter Ausdruck, versucht
Maxima den Ausdruck zu vereinfachen.  Maxima kann die Funktion @code{signum}
differenzieren.  Wird das Paket @nref{abs_integrate} geladen, kann Maxima
Integrale mit der Funktion @code{signum} l@"osen.

@code{signum} wird automatisch auf die Elemente von Listen und Matrizen
sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Ergebnisse f@"ur verschiedene Zahlen und konstante Ausdr@"ucke.  Die Beispiele
zeigen, dass das Ergebnis der Signumfunktion den Typ der Zahl erh@"alt.  Die
unendlichen Gr@"o@ss{}en @mref{minf} und @mref{inf} k@"onnen als Argument
auftreten.

@example
(%i1) signum([-1.5, 0, 0.0, 1.5, 1.5b0, %e, sin(1), cos(4)]);
(%o1)        [- 1.0, 0, 0.0, 1.0, 1.0b0, 1, 1, - 1]
(%i2) signum(1+%i);
                          %i         1
(%o2)                   ------- + -------
                        sqrt(2)   sqrt(2)
(%i3) signum([minf,inf]);
(%o3)                      [- 1, 1]
@end example

Vereinfachungen der Signumfunktion.

@example
(%i3) signum(x*y);
(%o3)                  signum(x) signum(y)
(%i4) signum(-x);
(%o4)                      - signum(x)
@end example

Wird das Paket @nref{abs_integrate} geladen, kann Maxima Integrale mit der
Signumfunktion l@"osen.  Ausdr@"ucke mit der Signumfunktion k@"onnen
differenziert werden.

@example
(%i5) load(abs_integrate)$

(%i6) integrate(signum(x),x);
(%o6)                        abs(x)

(%i7) integrate(sin(x)*signum(x),x);
(%o7)               (1 - cos(x)) signum(x)

(%i7) diff(%,x);
(%o7)                  signum(x) sin(x)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur komplexe Zahlen, Funktionen der Kombinatorik, Funktionen f@"ur Zahlen, Mathematische Funktionen
@section Funktionen f@"ur komplexe Zahlen
@c -----------------------------------------------------------------------------

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{cabs}
@deffn {Funktion} cabs (@var{expr})

Berechnet den Betrag eines komplexen Ausdrucks @var{expr}.  Im Unterschied
zu der Funktion @mrefcomma{abs} zerlegt die Funktion @code{cabs} einen komplexen
Ausdruck immer in einen Realteil und Imagin@"arteil, um den komplexen Betrag zu
berechnen.  Sind @var{x} und @var{y} zwei reelle Variablen oder Ausdr@"ucke
berechnet die Funktion @code{cabs} den Betrag des komplexen Ausdrucks
@code{x + %i*y} als:
@example
                           2    2
                     sqrt(y  + x )
@end example

Die Funktion @code{cabs} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Betrag eines Ausdrucks zu berechnen.
Sind solche Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{cabs} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{cabs} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.  F@"ur das symbolische Rechnen wie der Integration oder der
Ableitung von Ausdr@"ucken muss die Betragsfunktion @code{abs} verwendet werden.

Das Ergebnis der Funktion @code{cabs} kann die Betragsfunktion @mref{abs} und
die Arcustangensfunktion @mref{atan2} enthalten.

@code{cabs} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.  Siehe @mrefdot{distribute_over}

Siehe auch die Funktionen @mrefcomma{rectform} @mrefcomma{realpart}@ 
@mrefcomma{imagpart} @mrefcomma{carg} @mrefcomma{conjugate} und 
@mref{polarform} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zwei Beispiele mit der Wurzelfunktion @mref{sqrt} und der Sinusfunktion
@mrefdot{sin}

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

Die Funktion @mref{erf} hat Spiegelsymmetrie, die hier f@"ur die Berechnung des
komplexen Betrages angwendet wird.

@example
(%i3) cabs(erf(x+%i*y));
@group
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end group
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen, um den komplexen
Betrag zu vereinfachen.  Dies ist ein Beispiel f@"ur die Besselfunktion
@mrefdot{bessel_j}

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{carg}
@deffn {Funktion} carg (@var{expr})

Gibt das komplexe Argument des Ausdrucks @var{expr} zur@"uck.  Das komplexe
Argument ist ein Winkel @code{theta} im Intervall @code{(-%pi, %pi)} derart,
dass @var{expr} = @code{r exp (theta %i)} gilt, wobei @code{r} den Betrag des
komplexen Ausdrucks @var{expr} bezeichnet.  Das ist die Polarform des Ausdrucks,
wie sie auch von der Funktion @mref{polarform} zur@"uckgegeben wird.  Der Betrag
des komplexen Ausdrucks kann mit der Funktion @mref{cabs} berechnet werden.

Das Ergebnis der Funktion @code{carg} kann die Funktion @mref{atan2} enthalten.

@code{carg} wird automatisch auf die Elemente von Listen und Matrizen sowie auf
die beiden Seiten von Gleichungen angewendet.  Siehe @mrefdot{distribute_over}

Die Funktion @code{carg} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{rectform} @mref{realpart} und
@mref{imagpart} sowie die Funktionen @mref{cabs} und @mrefdot{conjugate}

Beispiele:

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
@group
                               %pi
(%o2)                          ---
                                4
@end group
(%i3) carg (exp (%i));
(%o3)                           1

(%i4) carg (exp (3/2 * %pi * %i));
                                %pi
(%o4)                         - ---
                                 2
(%i5) carg(exp(x+%i*y));
(%o5)                atan2(sin(y), cos(y))

(%i6) carg(sqrt(x+%i*y));
                          atan2(y, x)
(%o6)                     -----------
                               2
(%i7) carg(sqrt(1+%i*y));
                            atan(y)
(%o7)                       -------
                               2
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{conjugate}
@deffn {Funktion} conjugate (@var{expr})

Gibt den konjugiert komplexen Wert des Ausdrucks @var{expr} zur@"uck.  Sind
@var{x} und @var{y} reelle Variablen oder Ausdr@"ucke, dann hat der Ausdruck
@code{x + %i*y} das Ergebnis @code{x - %i*y}.  Die Funktion @code{conjugate} ist
f@"ur numerische und symbolische Rechnungen geeignet.

Maxima kennt Regeln, um den konjugierten Wert f@"ur Summen, Produkte und
Quotienten von komplexen Ausdr@"ucken zu vereinfachen.  Weiterhin kennt Maxima
Symmetrieeigenschaften und komplexe Eigenschaften von Funktionen, um den 
konjugierten Wert mit diesen Funktionen zu vereinfachen.  Sind solche
Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der
Funktion @mref{properties} angezeigt werden.  Eigenschaften, die das Ergebnis
der Funktion @code{conjugate} bestimmen, sind: @code{mirror symmetry},
@code{conjugate function} und @code{complex characteristic}.

@code{conjugate} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

F@"ur das Rechnen mit komplexen Ausdr@"ucken siehe auch die Funktionen
@mref{cabs} und @mref{carg} sowie @mref{rectform} und @mrefdot{polarform}

Beispiele:

Beispiele mit reellen, imagin@"aren und komplexen Variablen.

@example
(%i1) declare ([x, y], real, [z1, z2], complex, j, imaginary);
(%o1)                         done
(%i2) conjugate(x + %i*y);
(%o2)                       x - %i y
(%i3) conjugate(z1*z2);
(%o3)              conjugate(z1) conjugate(z2)
(%i4) conjugate(j/z2);
                                 j
(%o4)                    - -------------
                           conjugate(z2)
@end example

Im Folgenden nutzt Maxima Symmetrieeigenschaften, um den konjugiert komplexen
Wert der Funktionen @mref{gamma} und @mref{sin} zu berechnen.  Die
Logarithmusfunktion @mref{log} hat Spiegelsymmetrie, wenn das Argument einen
positiven Realteil hat.

@example
(%i5) conjugate(gamma(x+%i*y));
(%o5)                    gamma(x - %i y)
(%i6) conjugate(sin(x+%i*y));
(%o6)                    - sin(%i y - x)
(%i7) conjugate(log(x+%i*y));
(%o7)               conjugate(log(%i y + x))
(%i8) conjugate(log(1+%i*y));
(%o8)                     log(1 - %i y)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{imagpart}
@deffn {Funktion} imagpart (@var{expr})

Gibt den Imagin@"arteil des Ausrucks @var{expr} zur@"uck.  Intern berechnet
Maxima den Imagin@"arteil mit der Funktion @mrefcomma{rectform} die einen
Ausdruck in den Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die
Ausf@"uhrungen zu @code{rectform} auch auf die Funktion @code{imagpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{imagpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{imagpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{realpart} wird der Realteil eines Ausdrucks berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) imagpart((2-%i)/(1-%i));
                                1
(%o1)                           -
                                2
(%i2) imagpart(sin(x+%i*y));
(%o2)                    cos(x) sinh(y)
(%i3) imagpart(gamma(x+%i*y));
             %i (gamma(x - %i y) - gamma(%i y + x))
(%o3)        --------------------------------------
                               2
(%i4) imagpart(bessel_j(1,%i));
(%o4)                    bessel_j(1, %i)
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{polarform}
@deffn {Funktion} polarform (@var{expr})

Gibt den Ausdruck @var{expr} in der Polarform @code{r %e^(%i theta)} zur@"uck.
@code{r} ist der Betrag des komplexen Ausdrucks, wie er auch mit der Funktion
@mref{cabs} berechnet werden kann.  @code{theta} ist das Argument des komplexen
Ausdrucks, das mit der Funktion @mref{carg} berechnet werden kann.

Maxima kennt komplexe Eigenschaften von Funktionen, die bei der Berechnung der
Polarform angewendet werden.  Siehe die Funktion @mref{cabs} f@"ur weitere
Erl@"auterungen.

Wenn mit komplexen Ausdr@"ucken in der Polarform gerechnet werden soll, ist es
hilfreich die Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.
Damit wird verhindert, dass Maxima komplexe Ausdr@"ucke mit der
Exponentialfunktion @mref{exp} automatisch in die Standardform vereinfacht.

@code{polarform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktion @code{polarform} ist eine Verbfunktion, mit der nicht symbolisch
gerechnet werden kann.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{rectform} kann ein komplexer Ausdruck in die Standardform gebracht werden.

Beispiele:

Die allgemeine Polarform eines komplexen Ausdrucks.  Die Variablen @var{x} und
@var{y} werden von Maxima als reell angenommen.

@example
(%i1) polarform(x+%i*y);
                       2    2    %i atan2(y, x)
(%o1)            sqrt(y  + x ) %e
@end example

Die Polarform einer komplexen Zahl und eines Ausdrucks mit einer reellen 
Variablen @var{x}.

@example
(%i2) polarform(4/5+3*%i/5);
                           %i atan(3/4)
(%o2)                    %e
(%i3) polarform(sqrt(1+%i*x));
                                  %i atan(x)
                                  ----------
                      2     1/4       2
(%o3)               (x  + 1)    %e
@end example

Wenn in der Polarform gerechnet werden soll, ist es hilfreich die
Optionsvariable @mref{%emode} auf den Wert @code{false} zu setzen.  Damit wird
verhindert, dass Maxima komplexe Ausdr@"ucke mit der Exponentialfunktion 
@mref{exp} automatisch in eine Standardform vereinfacht.

@example
(%i4) z:polarform(1+%i);
                                  %i %pi
                                  ------
                                    4
(%o4)                   sqrt(2) %e
(%i5) z^3;
                     3/2    %i         1
(%o5)               2    (------- - -------)
                          sqrt(2)   sqrt(2)
(%i6) %emode:false;
(%o6)                         false
(%i7) z^3;
                                3 %i %pi
                                --------
                          3/2      4
(%o7)                    2    %e
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{realpart}
@deffn {Funktion} realpart (@var{expr})

Gibt den Realteil des Ausrucks @var{expr} zur@"uck.  Intern berechnet Maxima
den Realteil mit der Funktion @mrefcomma{rectform} die einen Ausdruck in den
Realteil und in den Imagin@"arteil zerlegt.  Daher treffen die Ausf@"uhrungen
zu @code{rectform} auch auf die Funktion @code{realpart} zu.

Wie die Funktion @code{rectform} ist auch die Funktion @code{realpart} eine
Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

@code{realpart} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Mit der Funktion @mref{imagpart} wird der Imagin@"arteil eines Ausdrucks
berechnet.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.  Mit der Funktion
@mref{polarform} kann ein komplexer Ausdruck in die Polarform gebracht werden.

Beispiele:

F@"ur weitere Erl@"auterungen dieser Beispiele siehe auch die Funktion
@mrefdot{rectform}

@example
(%i1) realpart((2-%i)/(1-%i));
                                3
(%o1)                           -
                                2
(%i2) realpart(sin(x+%i*y));
(%o2)                    sin(x) cosh(y)
(%i3) realpart(gamma(x+%i*y));
                gamma(%i y + x) + gamma(x - %i y)
(%o3)           ---------------------------------
                                2
(%i4) realpart(bessel_j(1,%i));
(%o4)                           0
@end example
@end deffn

@c --- 20.02.2011 DK -----------------------------------------------------------
@anchor{rectform}
@deffn {Funktion} rectform (@var{expr})

Zerlegt den Ausdruck @var{expr} in den Realteil @code{a} und den Imagin@"arteil
@code{b} und gibt den komplexen Ausdruck in der Standardform @code{a + b %i}
zur@"uck.

Die Funktion @code{rectform} nutzt Symmetrieeigenschaften und implementierte
Eigenschaften komplexer Funktionen, um den Realteil und Imagin@"arteil eines
komplexen Ausdrucks zu berechnen.  Sind solche Eigenschaften f@"ur eine Funktion vorhanden, k@"onnen diese mit der Funktion @mref{properties} angezeigt werden.
Eigenschaften, die das Ergebnis der Funktion @code{rectform} bestimmen, sind:
@code{mirror symmetry}, @code{conjugate function} und
@code{complex characteristic}.

@code{rectform} ist eine Verbfunktion, die nicht f@"ur das symbolische Rechnen
geeignet ist.

@code{rectform} wird automatisch auf die Elemente von Listen und Matrizen sowie
auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Die Funktionen @mref{realpart} und @mref{imagpart} geben jeweils allein den
Realteil und den Imagin@"arteil eines Ausdrucks zur@"uck.  Um einen Ausdruck in
die Polarform zu bringen, kann die Funktion @mref{polarform} verwendet werden.

Siehe auch die Funktionen @mrefcomma{cabs} @mref{carg} und
@mref{conjugate} f@"ur das Rechnen mit komplexen Zahlen.

Beispiele:

Zerlegung eines komplexen Ausdrucks und der Sinusfunktion @mref{sin} in den
Realteil und Imagin@"arteil.  Maxima kennt komplexe Eigenschaften der
trigonometrischen Funktionen, um den Realteil und den Imagin@"arteil zu
bestimmen.

@example
(%i1) rectform((2-%i)/(1-%i));
@group
                             %i   3
(%o1)                        -- + -
                             2    2
@end group
(%i2) rectform(sin(x+%i*y));
(%o2)          %i cos(x) sinh(y) + sin(x) cosh(y)
@end example

Bei der Zerlegung in einen Realteil und einen Imagin@"arteil nutzt Maxima die
Spiegelsymmetrie der Gammfunktion @mrefdot{gamma}  Die Eigenschaft der 
Spiegelsymmetrie wird mit der Funktion @mref{properties} angezeigt, der Eintrag
lautet @code{mirror symmetry}.

@example
(%i3) properties(gamma);
(%o3)    [mirror symmetry, noun, rule, gradef, transfun]

(%i4) rectform(gamma(x+%i*y));
      gamma(%i y + x) + gamma(x - %i y)
(%o4) ---------------------------------
                      2
                                gamma(x - %i y) - gamma(%i y + x)
                              - ---------------------------------
                                                2
@end example

Maxima kennt komplexe Eigenschaften der Besselfunktionen.  Die Besselfunktion
@mref{bessel_j} ist f@"ur eine ganzzahlige Ordnung und einem imagin@"aren
Argument rein imagin@"ar.

@example
(%i5) rectform(bessel_j(1,%i));
(%o5)                  %i bessel_j(1, %i)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen der Kombinatorik, Wurzel-@comma{} Exponential- und Logarithmusfunktion, Funktionen f@"ur komplexe Zahlen, Mathematische Funktionen
@section Funktionen der Kombinatorik
@c -----------------------------------------------------------------------------

@c --- 25.02.2011 DK -----------------------------------------------------------
@anchor{!!}
@deffn {Operator} !!
@ifinfo
@fnindex Doppelte Fakult@"at
@end ifinfo

Ist der Operator der doppelten Fakult@"at.

F@"ur eine positive ganze Zahl @code{n}, wird @code{n!!} zu dem Produkt
@code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))} vereinfacht, wobei @code{k} gleich
@code{floor(n/2)} ist und @mref{floor} die gr@"o@ss{}te ganze Zahl liefert, die
kleiner oder gleich @code{n/2} ist.

F@"ur ein Argument @code{n}, das keine ganze positive Zahl ist, gibt @code{n!!}
die Substantivform @code{genfact(n, n/2,2)} zur@"uck.  Siehe die Funktion
@mrefdot{genfact}

Die Verallgemeinerung der doppelten Fakult@"at f@"ur reelle und komplexe Zahlen
ist als die Funktion @mref{double_factorial} implementiert.

Beispiele:

@example
(%i1) [0!!, 1!!, 2!!, 3!!, 4!!, 5!!, 6!!, 7!!, 8!!];
(%o1)           [1, 1, 2, 3, 8, 15, 48, 105, 384]
(%i2) 1.5!!;
(%o2)                  genfact(1.5, 0, 2)
(%i3) x!!;
                                   x
(%o3)                   genfact(x, -, 2)
                                   2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{binomial}
@deffn {Funktion} binomial (@var{x}, @var{y})

Ist der Binomialkoeffizient, der definiert ist als
@ifnottex
@example
                                  x!
             binomial(x, y) = -----------
                              (x - y)! y!
@end example
@end ifnottex
@tex
$${{x}\choose{y}}={{x!}\over{\left(x-y\right)!\,y!}}$$
@end tex

Die Funktion @code{binomial} ist f@"ur das numerische und symbolische Rechnen
geeignet.

Sind die Argumente @var{x} oder @var{y} ganze Zahlen, wird der
Binomialkoeffizient numerisch berechnet.  Sind die Argumente @var{x} und @var{y}
reelle oder komplexe Gleitkommazahlen, wird der Binomialkoeffizent mit der 
entsprechenden verallgemeinerten Fakult@"at berechnet.  Siehe auch
@mref{factorial} und @mrefdot{gamma}

Ist das Argument @var{y} oder die Differenz @var{x-y} eine ganz Zahl, wird
der Binomialkoeffizient zu einem Polynom vereinfacht.

Mit den Funkionen @mref{makefact} oder @mref{makegamma} wird der
Binomialkoeffizient in einen @"aquivalenten Ausdruck mit der Fakult@"at oder
der Gammafunktion transformiert.

Maxima kennt die Ableitung des Binomialkoeffizienten.

Beispiele:

@example
(%i1) binomial(11, 7);
(%o1)                          330
(%i2) binomial(%i, 1.5);
(%o2)       .3693753994635863 %i - .7573400496142132
(%i3) binomial(x, 3);
                        (x - 2) (x - 1) x
(%o3)                   -----------------
                                6
(%i4) binomial(x+3, 3);
                     (x + 1) (x + 2) (x + 3)
(%o4)                -----------------------
                                6
(%i5) makefact(binomial(x,y));
                               x!
(%o5)                      -----------
                           (x - y)! y!

(%i6) diff(binomial(x,y), y);
(%o6)  - binomial(x, y) (psi (y + 1) - psi (- y + x + 1))
                            0             0
@end example
@end deffn

@c --- 25.02.2011 DK -----------------------------------------------------------
@anchor{double_factorial}
@deffn {Funktion} double_factorial (expr)

Ist die doppelte Fakult@"at, die allgemein definiert ist als
@ifnottex
@example
               2  1/4 (1 - cos(n %pi))  n/2       n
             (---)                     2    gamma(- + 1)
              %pi                                 2
@end example
@end ifnottex
@tex
$$\left({{2}\over{\pi}}\right)^{{{1}\over{4}}\,\left(1-\cos \left(n\,
 \pi\right)\right)}\,2^{{{n}\over{2}}}\,\Gamma\left({{n}\over{2}}+1
 \right)$$
@end tex

Die Funktion @code{double_factorial} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Ist das Argument @var{expr} eine ganze Zahl, eine
Gleitkommazahl, eine gro@ss{}e Gleitkommazahl oder eine komplexe Gleitkommazahl,
dann wird ein numerisches Ergebnis berechnet.  F@"ur eine positive ganze Zahl
ist das Ergebnis gleich dem Ergebnis des Operators der doppelten Fakult@"at
@mref{!!}.  F@"ur rationale Zahlen ist das Ergebnis eine Substantivform.

F@"ur negative gerade ganze Zahlen ist die Funktion @code{double_factorial}
nicht definiert.

Hat die Optionsvariable @mref{factorial_expand} den Wert @code{true}, 
vereinfacht Maxima @code{double_factorial} f@"ur das Argument @code{n-1} und
f@"ur Argumente @code{n+2*k}, wobei @code{k} eine ganze Zahl ist.

Maxima kennt die Ableitung der Funktion @code{double_factorial}.

@code{double_factorial} wird automatisch auf die Elemente von Listen und
Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
@mrefdot{distribute_over}

Beispiele:

Numerische Ergebnisse f@"ur ganze Zahlen, Gleitkommazahlen und komplexen
Gleitkommazahlen.

@example
(%i1) double_factorial([-3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o1) [- 1, 1, 1, 1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]

(%i2) double_factorial([1.5, 1.5b0, 0.5+%i, 0.5b0+%i]);
(%o2) [1.380662681753386, 1.380662681753387b0,
.4186422526242637 - .7218816624466643 %i, 
4.186422526242633b-1 - 7.218816624466641b-1 %i]
@end example

Vereinfachungen, wenn die Optionsvariable @mref{factorial_expand} den Wert
@code{true} hat.

@example
(%i3) factorial_expand:true;
(%o3)                         true
(%i4) double_factorial(n-1);
                               n!
(%o4)                  -------------------
                       double_factorial(n)
(%i5) double_factorial(n+4);
(%o5)          (n + 2) (n + 4) double_factorial(n)
(%i6) double_factorial(n-4);
@group
                       double_factorial(n)
(%o6)                  -------------------
                            (n - 2) n
@end group
@end example

Die Ableitung der Funktion @code{double_factorial}.

@example
(%i7) diff(double_factorial(x), x);
                                     2
                            %pi log(---) sin(%pi x)
                                    %pi                    x
(%o7) (double_factorial(x) (----------------------- + psi (- + 1)
                                       2                 0 2
                                                     + log(2)))/2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factcomb}
@deffn {Funktion} factcomb (@var{expr})

Fasst Faktoren und Fakult@"aten im Ausdruck @var{expr} zusammen.  Zum Beispiel
wird @code{(n+1)*n!} zu @code{(n+1)!} zusammengefasst.

Hat die Optionsvariable @mref{sumsplitfact} den Wert @code{false}, wird nach
der Vereinfachung mit @code{factcomb} die Funktion @mref{minfactorial} auf den 
Ausdruck @var{expr} angewendet.

Beispiele:

@example
(%i1) expr: ((n+1)*n!)/(n+2)!;
                           (n + 1) n!
(%o1)                      ----------
                            (n + 2)!
(%i2) factcomb(expr);
@group
                            (n + 1)!
(%o2)                       --------
                            (n + 2)!
@end group
(%i3) factcomb(expr), sumsplitfact:false;
                                1
(%o3)                         -----
                              n + 2
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factorial}
@anchor{!}
@deffn  {Funktion} factorial (@var{x})
@deffnx {Operator} !
@ifinfo
@fnindex Fakult@"at
@end ifinfo

Die Funktion @code{factorial} ist f@"ur das numerische und symbolische Rechnen
der Fakult@"at geeignet.  Der Operator der Fakult@"at @code{!}, ist identisch
mit der Funktion @code{factorial}.

F@"ur eine ganze Zahl @code{x}, vereinfacht @code{x!} zum Produkt der ganzen 
Zahlen von 1 bis einschlie@ss{}lich @code{x}.  @code{0!} vereinfacht zu 1.
F@"ur reelle und komplexe Gleitkommazahlen wird @code{x!} mit der
Verallgemeinerung @code{gamma(x+1)} berechnet.  Siehe die Funktion
@mrefdot{gamma}  F@"ur eine halbzahlige rationale Zahl @code{n/2}, vereinfacht
@code{(n/2)!} zu einem rationalen Faktor multipliziert mit @code{sqrt(%pi)}.

Die Optionsvariable @mref{factlim} enth@"alt die gr@"o@ss{}te Zahl, f@"ur die
die Fakult@"at einer ganzen Zahl numerisch berechnet wird.  Ist das Argument
der Fakult@"at eine rationale Zahl, wird von Maxima die Funktion
@mref{gamma} f@"ur die numerische Berechnung aufgerufen.  In diesem Fall ist
@code{gammalim - 1} der gr@"o@ss{}te Nenner, f@"ur den die Fakult@"at vereinfacht
wird.  Siehe @mrefdot{gammalim}

Hat die Optionsvariable @mref{factorial_expand} den Wert @code{true}, wird die
Fakult@"at von Argumenten der Form @code{(n+k)!} oder @code{(n-k)!} vereinfacht,
wobei @code{k} eine ganze Zahl ist.

Mit den Funktionen @mref{minfactorial} und @mref{factcomb} k@"onnen Fakult@"aten
in Ausdr@"ucken vereinfacht werden.

Die Funktion @mref{makegamma} ersetzt Fakult@"aten in einem Ausdruck durch die
Gammafunktion @mrefdot{gamma}  Umgekehrt ersetzt die Funktion
@mref{makefact} Binomialkoeffizienten und die Gammafunktion in einem Ausdruck
durch Fakult@"aten.

Maxima kennt die Ableitung der Fakult@"at und die Grenzwerte der Fakult@"at
f@"ur spezielle Werte wie negative ganze Zahlen.

Siehe auch die Gammfunktion @mref{gamma} und den Binomialkoeffizienten
@mrefdot{binomial}

Beispiele:

Die Fakult@"at einer ganzen Zahl wird zu einer exakten Zahl vereinfacht, wenn
das Argument nicht gr@"o@ss{}er als @code{factlim} ist.  Die Fakult@"at f@"ur 
reelle und komplexe Zahlen wird als Gleitkommazahl berechnet.

@example
(%i1) factlim:10;
(%o1)                          10
(%i2) [0!, (7/2)!, 8!, 20!];
                     105 sqrt(%pi)
(%o2)            [1, -------------, 40320, 20!]
                          16
(%i3) [4.77!, (1.0+%i)!];
(%o3) [81.44668037931197, .3430658398165451 %i
                                             + .6529654964201663]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 3.430658398165454b-1 %i
                                          + 6.529654964201667b-1]
@end example

Die Fakult@"at von numerischen Konstanten oder eines konstanten Ausdrucks wird
numerisch berechnet, wenn die Konstante oder der Ausdruck zu einer Zahl
ausgewertet werden kann.

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165451 %i + .6529654964201663, 
         7.188082728976031, 4.260820476357003, 1.227580202486819]
@end example

Fakult@"aten werden vereinfacht und nicht ausgewertet.  Daher wird die
Fakult@"at auch dann berechnet, wenn die Auswertung mit dem Quote-Operator 
@mref{'} unterdr@"uckt ist.

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
            105 sqrt(%pi)
(%o1)   [1, -------------, 81.44668037931197, 40320, 20!]
                 16
@end example

Maxima kennt die Ableitung der Fakult@"at.

@example
(%i1) diff(x!, x);
(%o1)                    x! psi (x + 1)
                               0
@end example

Die Optionsvariable @code{factorial_expand} kontrolliert die Expansion und
Vereinfachung von Ausdr@"ucken, die die Fakult@"at enthalten.

@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                         n + 1
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factlim}
@defvr {Optionsvariable} factlim
Standardwert: 100000

Die Optionsvariable @code{factlim} spezifiziert die gr@"o@ss{}te ganze Zahl, 
f@"ur die die Fakult@"at einer ganzen Zahl numerisch berechnet wird.  Hat
@code{factlim} den Wert -1, wird die Fakult@"at f@"ur jede ganze Zahl
berechnet.  Siehe die Funktion @mrefdot{factorial}
@end defvr

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{factorial_expand}
@defvr {Optionsvariable} factorial_expand
Standardwert: @code{false}

Die Optionsvariable @code{factorial_expand} kontrolliert die Vereinfachung von
Aus@-dr@"u@-cken wie @code{(n+k)!} oder @code{(n-k)!}, wobei @code{k} eine
ganze Zahl ist.  Siehe @mref{factorial} f@"ur ein Beispiel.

Siehe auch die Funktionen @mref{minfactorial} und @mref{factcomb} f@"ur die
Vereinfachung von Ausdr@"ucken mit der Fakult@"at.
@end defvr

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{genfact}
@deffn {Funktion} genfact (@var{x}, @var{y}, @var{z})

Gibt die verallgemeinerte Fakult@"at zur@"uck, die als @code{x (x-z) (x - 2 z) 
... (x - (y - 1) z)} definiert ist.  Ist @var{x} eine ganze Zahl, dann
entspricht @code{genfact(x, x, 1)} der Fakult@"at @code{x!} und 
@code{genfact(x, x/2, 2)} der doppelten Fakult@"at @code{x!!}.  Siehe auch die 
Funktionen @mref{factorial} und @mref{double_factorial} sowie die Operatoren
@mref{!} und @mrefdot{!!}
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{minfactorial}
@deffn {Funktion} minfactorial (@var{expr})

Die Funktion @code{minfactorial} vereinfacht Fakult@"aten @mref{factorial} in
dem Ausdruck @var{epxr}, die sich um eine ganze Zahl voneinander unterscheiden.
Siehe auch die Funktion @mref{factcomb}, um Fakult@"aten zusammenzufassen,
sowie die Optionsvariable @mrefdot{factorial_expand}

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example
@end deffn

@c --- 26.02.2011 DK -----------------------------------------------------------
@anchor{sumsplitfact}
@defvr {Optionsvariable} sumsplitfact
Standardwert: @code{true}

Hat die Optionsvariable @code{sumsplitfact} den Wert @code{false}, wird von
der Funktion @code{factcomb} nach der Zusammenfassung von Fakult@"aten die
Funktion @mref{minfactorial} angewendet.  Siehe die Funktion
@mref{factcomb} f@"ur ein Beispiel.
@end defvr

@c -----------------------------------------------------------------------------
@node Wurzel-@comma{} Exponential- und Logarithmusfunktion, Winkelfunktionen, Funktionen der Kombinatorik, Mathematische Funktionen
@section Wurzel-, Exponential- und Logarithmusfunktion
@c -----------------------------------------------------------------------------

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%e_to_numlog}
@defvr {Optionsvariable} %e_to_numlog
Standardwert: @code{false}

Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck mit der Exponentialfunktion @mref{exp} der Form @code{%e^(r*log(x))}
zu @code{x^r} vereinfacht, wenn @code{r} eine rationale Zahl ist.  Ist @code{r}
eine ganze Zahl, wird die Vereinfachung von der Optionsvariablen
@mref{logsimp} kontrolliert.

Beispiel:

@example
(%i1) exp(1/2*log(x));
                              log(x)
                              ------
                                2
(%o1)                       %e
(%i2) exp(1/2*log(x)), %e_to_numlog:true;
(%o2)                        sqrt(x)
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%emode}
@defvr {Optionsvariable} %emode
Standardwert: @code{true}

Die Optionsvariable @code{%emode} kontrolliert die Vereinfachung von
Ausdr@"ucken mit der Exponentialfunktion @mref{exp} der Form
@code{%e^(%pi %i x)}.

Ist das Argument @var{x} eine ganze Zahl oder eine rationale Zahl, die ein
Vielfaches von 1/2, 1/3, 1/4 oder 1/6 ist, dann wird der Ausdruck
@code{%e^(%pi %i x)} zu einer reellen oder komplexen Zahl vereinfacht.  F@"ur
Gleitkommazahlen wird diese Vereinfachung dann ausgef@"uhrt, wenn diese eine
ganze Zahl oder halbzahlige rationale Zahl repr@"asentieren.

Eine Summe im Exponenten wie zum Beispiel @code{%e^(%pi *%i (x+n))}, wobei 
@var{n} eine der oben genannten Zahlen und @var{x} ein allgemeiner Ausdruck ist,
wird vereinfacht, indem der Faktor @code{%^(%pi %i n)} entsprechend vereinfacht
wird.

Hat @code{%emode} den Wert @code{false}, werden keine speziellen Vereinfachungen
f@"ur den Ausdruck @code{%e^(%pi %i x)} vorgenommen.

Beispiele:

@example
(%i1) exp([2*%pi*%i, 1/2*%pi*%i, 0.5*%pi*%i, 0.5b0*%pi*%i]);
(%o1)               [1, %i, 1.0 %i, 1.0b0 %i]

(%i2) exp([1/3*%pi*%i, 1/4*%pi*%i, 1/6*%pi*%i]);
         sqrt(3) %i   1    %i         1     %i   sqrt(3)
(%o2)   [---------- + -, ------- + -------, -- + -------]
             2        2  sqrt(2)   sqrt(2)  2       2

(%i3) exp((1/3+x)*%pi*%i);
                    sqrt(3) %i   1    %i %pi x
(%o3)              (---------- + -) %e
                        2        2
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{%enumer}
@defvr {Optionsvariable} %enumer
Standardwert: @code{false}

Hat @code{%enumer} den Wert @code{true}, wird die Konstante @code{%e} immer dann
durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable @mref{numer} den
Wert @code{true} hat.

Hat @code{%enumer} den Wert @code{false}, wird die Konstante @code{%e} nur dann
durch ihren nummerischen Wert ersetzt, wenn der Exponent von @code{%e^x} zu 
einer Gleitkommazahl ausgewertet wird.

Siehe auch @mref{ev} und @mrefdot{numer}

Beispiel:

@example
(%i1) %enumer:true;
(%o1)                         true
(%i2) exp(x);
                                 x
(%o2)                          %e
(%i3) exp(x),numer;
                                        x
(%o3)                  2.718281828459045
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{exp}
@deffn {Funktion} exp (@var{z})

Ist die Exponentialfunktion.  Die Exponentialfunkton @code{exp} wird von Maxima
sofort zu @code{%e^@var{z}} vereinfacht und tritt in vereinfachten
Ausdr@"ucken nicht auf.  Maxima vereinfacht die Exponentialfunktion daher wie
die allgmeine Exponentiation @mrefdot{^}  Dar@"uberhinaus kennt Maxima spezielle
Regeln f@"ur die Vereinfachung der Exponentialfunktion.

Ist das Argument @var{z} der Exponentialfunktion eine ganze oder rationale
Zahl wird ein vereinfachter Ausdruck zur@"uckgegeben.  Ist das Argument
@var{z} eine reelle oder komplexe Gleitkommazahl wird ein numerisches
Ergebnis berechnet.

Folgende Optionsvariablen kontrollieren die Vereinfachung der
Exponentialfunktion:

@table @code
@item %enumer
Hat die Optionsvariable @mref{%enumer} den Wert @code{true}, vereinfacht Maxima
die Eulersche Zahl @mref{%e} immer dann zu ihrem numerischen Wert, wenn die
Optionsvariable @mref{numer} auch den Wert @code{true} hat.

@item %emode
Hat die Optionsvariable @mref{%emode} den Wert @code{true}, wendet Maxima
Regeln an, um Ausdr@"ucke der Form @code{%e^(x*%i*%pi)} zu vereinfachen.
Der Standardwert von @code{%emode} ist @code{true}.  Wenn mit komplexen Zahlen
in der Polarform gerechnet wird, kann es hilfreich sein, die Optionsvariable
@code{%emode} auf den Wert @code{false} zu setzen.

@item %e_to_numlog
Hat die Optionsvariable @mref{%e_to_numlog} den Wert @code{true}, vereinfacht
Maxima einen Ausdruck @code{%e^(r*log(x)} zu @code{x^r}, wobei @var{r}
eine rationale Zahl ist.  Ist @var{r} eine ganze Zahl wird diese Vereinfachung
von der Optionsvariablen @mref{logsimp} kontrolliert.  F@"ur reelle oder
komplexe Gleitkommazahlen wird diese Vereinfachung nicht ausgef@"uhrt.

@item radexpand
Die Optionsvariable @mref{radexpand} kontrolliert die Vereinfachung von
Ausdr@"ucken der Form @code{(%e^a)^b}.  Ist @var{a} ein reelles Argument
vereinfacht Maxima immer zu einem Ausdruck @code{%e^(a*b)}.  Ist @var{a} ein
komplexes Argument, wird die Vereinfachung @code{%e^(a*b)} dann ausgef@"uhrt,
wenn die Optionsvariable @code{radexpand} den Wert @code{all} hat.

@item logsimp
Die Optionsvariable @mref{logsimp} kontrolliert die Vereinfachung der 
Exponentialfunktion f@"ur den Fall, dass im Argument @var{expr} die
Logarithmusfunktion @mref{log} auftritt.  Hat die @code{logsimp} den Wert
@code{true}, wird ein Ausdruck @code{%e^(n*log(x)} zu @code{x^n} vereinfacht,
wenn @var{n} eine ganze Zahl ist.  Mit der Optionsvariablen @mref{%e_to_numlog}
wird diese Vereinfachung f@"ur eine rationale Zahl @var{n} kontrolliert.

@item demoivre
Ist eine Optionsvariable und eine Funktion, die auch als Auswertungsschalter
@mref{evflag} definiert ist.  Hat die Optionsvariable @mref{demoivre} den Wert
@code{true}, wird ein Ausdruck @code{%e^(x + %i y)} zu
@code{%e^x (cos(y) + %i sin(y))} vereinfacht.  Siehe auch die Funktion
@mrefdot{exponentialize}
@end table

Maxima kennt viele spezielle unbestimmte und bestimmte Integrale mit der 
Exponentialfunktion.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{log}
@deffn {Funktion} log (@var{x})

@c Represents the natural (base @math{e}) logarithm of @var{x}.

Ist der nat@"urliche Logaritmus zur Basis @math{e}.

@c Maxima does not have a built-in function for the base 10 logarithm or other 
@c bases. @code{log10(x) := log(x) / log(10)} is a useful definition.

Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10 oder anderen 
Basen.  Eine einfache Definition ist zum Beispiel 
@code{log10(x) := log(x)/log(10)}.

@c Simplification and evaluation of logarithms is governed by several global 
@c flags:

F@"ur die Vereinfachung und Auswertung der Logarithmusfunktion hat Maxima
verschiedene Optionsvariablen:

@c @code{logexpand} - causes @code{log(a^b)} to become @code{b*log(a)}. If it 
@c is set to @code{all}, @code{log(a*b)} will also simplify to 
@c @code{log(a)+log(b)}. If it is set to @code{super}, then @code{log(a/b)} will
@c also simplify to @code{log(a)-log(b)} for rational numbers @code{a/b}, 
@c @code{a#1}.  (@code{log(1/b)}, for @code{b} integer, always simplifies.)  If
@c it is set to @code{false}, all of these simplifications will be turned off.

@table @code
@item logexpand
@code{log(a^b)} wird zu @code{b*log(a)} vereinfacht.  Hat @code{logexpand} den 
Wert @code{all}, wird zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)} 
vereinfacht.  Mit den Wert @code{super} vereinfacht Maxima weiterhin 
@code{log(a/b)} zu @code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl 
ist.  @code{log(1/b} wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.  Hat
die Optionsvariable @code{logexpand} den Wert @code{false} werden alle obigen
Vereinfachungen ausgeschaltet.

@c @code{logsimp} - if @code{false} then no simplification of @code{%e} to a 
@c power containing @code{log}'s is done.

@item logsimp
Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @code{exp}, die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.

@c @code{lognumer} - if @code{true} then negative floating point arguments to
@c @code{log} will always be converted to their absolute value before the 
@c @code{log} is taken.  If @code{numer} is also @code{true}, then negative 
@c integer arguments to @code{log} will also be converted to their absolute 
@c value.

@item lognumer
Hat die Optionsvariable @code{lognumer} den Wert @code{true}, wird von
negativen Gleitkommazahlen der Absolutwert genommen, bevor der Logarithmus
berechnet wird.

@c @code{lognegint} - if @code{true} implements the rule @code{log(-n)} ->
@c @code{log(n)+%i*%pi} for @code{n} a positive integer.

@item lognegint
Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur postive @code{n} vereinfacht.

@c @code{%e_to_numlog} - when @code{true}, @code{r} some rational number, and
@c @code{x} some expression, @code{%e^(r*log(x))} will be simplified into
@c @code{x^r}.  It should be noted that the @code{radcan} command also
@c does this transformation, and more complicated transformations of this ilk as 
@c well. The @code{logcontract} command "contracts" expressions containing 
@c @code{log}.

@item %e_to_numlog
Hat die Optionsvariable @code{%e_to_numlog} den Wert @code{true}, wird ein 
Ausdruck @code{%e^(r*log(x))} zu @code{x^r} vereinfacht.  Dabei sind @code{r}  
eine rationale Zahl und @code{x} ein beliebiger Ausdruck.  Die Funktion 
@code{radcan} f@"uhrt diese Vereinfachung ebenfalls aus.
@end table
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logabs}
@defvr {Optionsvariable} logabs
Standardwert: @code{false}

@c When doing indefinite integration where logs are generated, e.g. 
@c @code{integrate(1/x,x)}, the answer is given in terms of @code{log(abs(...))}
@c if @code{logabs} is @code{true}, but in terms of @code{log(...)} if 
@c @code{logabs} is @code{false}.  For definite integration, the 
@c @code{logabs:true} setting is used, because here "evaluation" of the 
@c indefinite integral at the endpoints is often needed.

Werden unbestimmte Integrale mit Logarithmusfunktionen erzeugt, zum Beispiel
@code{integrate(1/x,x)}, wird der Betrag der Argumente der 
Logarithmusfunktionen gebildet @code{log(abs(...))}, wenn die Optionsvariable
@code{logabs} den Wert @code{true} hat.  Ist der Wert @code{false} werden keine
Betr@"age gebildet @code{log(...)}.

Bei der Berechnung von bestimmten Integralen setzt Maxima die Optionsvariable
@code{logabs} zu den Wert @code{false}.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logarc}
@deffn  {Funktion} logarc (@var{expr})
@deffnx {Optionsvariable} logarc

@c When the global variable @code{logarc} is @code{true}, inverse circular and 
@c hyperbolic functions are replaced by equivalent logarithmic functions.
@c The default value of @code{logarc} is @code{false}.

Hat die Optionsvariable @code{logarc} den Wert @code{true}, werden inverse
Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen ersetzt.  Der 
Standardwert von @code{logarc} ist @code{false}.

@c The function @code{logarc(@var{expr})} carries out that replacement for an 
@c expression @var{expr} without setting the global variable @code{logarc}.

Die Funktion @code{logarc(@var{expr})} f@"uhrt diese Ersetzung aus, ohne dass 
die Optionsvariable @code{logarc} gesetzt wird.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logconcoeffp}
@defvr {Optionsvariable} logconcoeffp
Standardwert: @code{false}

@c Controls which coefficients are contracted when using @code{logcontract}.  
@c It may be set to the name of a predicate function of one argument.  E.g. if 
@c you like to generate SQRTs, you can do @code{logconcoeffp:'logconfun$
@c logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Then
@c @code{logcontract(1/2*log(x));} will give @code{log(sqrt(x))}.

Die Optionsvariable @code{logconcoeffp} kontrolliert, welche Koeffizienten von
der Funktion @code{logcontract} zusammengezogen werden.  Der Optionsvariablen 
kann der Name einer Aussagefunktion mit einem Argument zugewiesen werden.
Sollen zum Beispiel Wurzeln generiert werden, kann folgende Definition 
verwendet werden: 
@example
logconcoeffp:'logconfun$ 
logconfun(m) := featurep(m,integer) or ratnump(m)$
@end example
Dann hat @code{logcontract(1/2*log(x))} das Ergebnis @code{log(sqrt(x))}.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logcontract}
@deffn {Funktion} logcontract (@var{expr})

@c Recursively scans the expression @var{expr}, transforming subexpressions of 
@c the form @code{a1*log(b1) + a2*log(b2) + c} into 
@c @code{log(ratsimp(b1^a1 * b2^a2)) + c}

Der Ausdruck @var{expr} wird rekursiv nach Ausdr@"ucken der Form 
@code{a1*log(b1) + a2*log(b2) + c} abgesucht.  Diese werden zu 
@code{log(ratsimp(b1^a1 * b2^a2)) + c} transformiert.

@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )
@end example

@c If you do @code{declare(n,integer);} then @code{logcontract(2*a*n*log(x));} 
@c gives @code{a*log(x^(2*n))}.  The coefficients that "contract" in this manner 
@c are those such as the 2 and the @code{n} here which satisfy
@c @code{featurep(coeff,integer)}.  The user can control which coefficients are
@c contracted by setting the option @code{logconcoeffp} to the name of a 
@c predicate function of one argument.  E.g. if you like to generate SQRTs, you 
@c can do @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or 
@c ratnump(m)$} . Then @code{logcontract(1/2*log(x));} will give 
@c @code{log(sqrt(x))}.

Wird die Variable @var{n} mit dem Kommando @code{declare(n, integer)} als eine 
ganze Zahl deklariert, dann wird  @code{logcontract(2*a*n*log(x))} zu
@code{a*log(x^(2*n))} vereinfacht.  Die Koeffizienten, die zusammengezogen 
werden, sind in diesem Fall die Zahl 2 und die Variable @var{n}, welche
die folgende Aussage erf@"ullen @code{featurep(coeff, integer)}.
Der Nutzer kann kontrollieren, welche Koeffizienten zusammengezogen werden.
Dazu wird der Optionsvariablen @code{logconcoeffp} eine Aussagefunktion mit 
einem Argument zugewiesen.  Sollen zum Beispiel Wurzeln generiert werden, kann 
folgende Definition verwendet: @code{logconcoeffp: 'logconfun$ logconfun(m) :=
featurep(m,integer) or ratnump(m)$}.  Dann ergibt sich f@"ur 
@code{logcontract(1/2*log(x))} das Ergebnis @code{log(sqrt(x))}.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logexpand}
@defvr {Optionsvariable} logexpand
Standardwert: @code{true}

@c Causes @code{log(a^b)} to become @code{b*log(a)}. If it is set to @code{all},
@c @code{log(a*b)} will also simplify to @code{log(a)+log(b)}.  If it is set to 
@c @code{super}, then @code{log(a/b)} will also simplify to @code{log(a)-log(b)}
@c for rational numbers @code{a/b}, @code{a#1}.  (@code{log(1/b)}, for integer 
@c @code{b}, always simplifies.)  If it is set to @code{false}, all of these 
@c simplifications will be turned off.

@code{log(a^b)} wird zu @code{b*log(a)} vereinfacht.  Hat @code{logexpand} den 
Wert @code{all}, wird zus@"atzlich @code{log(a*b)} zu @code{log(a)+log(b)} 
vereinfacht.  Mit den Wert @code{super} vereinfacht Maxima weiterhin 
@code{log(a/b)} zu @code{log(a)-log(b)}, wobei @code{a/b} eine rationale Zahl 
ist.  @code{log(1/b} wird f@"ur eine ganze Zahl @code{b} immer vereinfacht.  Hat
die Optionsvariable @code{logexpand} den Wert @code{false} werden alle obigen
Vereinfachungen ausgeschaltet.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{lognegint}
@defvr {Optionsvariable} lognegint
Standardwert: @code{false}

@c If @code{true} implements the rule @code{log(-n)} -> @code{log(n)+%i*%pi} for
@c @code{n} a positive integer.

Hat die Optionsvariable @code{lognegint} den Wert @code{true}, wird
@code{log(-n)} zu @code{log(n)+%i*%pi} f@"ur postive @code{n} vereinfacht.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{lognummer}
@defvr {Optionsvariable} lognumer
Standardwert: @code{false}

@c If @code{true} then negative floating point arguments to @code{log} will 
@c always be converted to their absolute value before the @code{log} is taken.
@c If @code{numer} is also @code{true}, then negative integer arguments to 
@c @code{log} will also be converted to their absolute value.

Hat die Optionsvariable @code{lognumer} den Wert @code{true}, wird von
negativen Gleitkommazahlen der Absolutwert genommen, bevor der Logarithmus
berechnet wird.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{logsimp}
@defvr {Optionsvariable} logsimp
Standardwert: @code{true}

@c If @code{false} then no simplification of @code{%e} to a power containing 
@c @code{log}'s is done.

Hat die Optionsvariable @code{logsimp} den Wert @code{false}, werden 
Exponentialfunktionen @code{exp}, die Logarithmusfunktionen im Exponenten
enthalten, nicht vereinfacht.
@end defvr

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{plog}
@deffn {Funktion} plog (@var{x})

@c Represents the principal branch of the complex-valued natural logarithm with 
@c @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

Gibt den Hauptwert des komplexen nat@"urlichen Logarithmus im Intervall
@code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} zur@"uck.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{sqrt}
@deffn {Funktion} sqrt (@var{x})

@c The square root of @var{x}. It is represented internally by 
@c @code{@var{x}^(1/2)}.  See also @code{rootscontract}.

Ist die Wurzelfunktion.  Intern stellt Maxima die Wurzelfunktion als
@code{sqrt@var{x}^(1/2)} dar.  Siehe auch die Funktion @code{rootscontract}.

@c @code{radexpand} if @code{true} will cause nth roots of factors of a product
@c which are powers of n to be pulled outside of the radical, e.g.
@c @code{sqrt(16*x^2)} will become @code{4*x} only if @code{radexpand} is 
@c @code{true}.

Hat die Optionsvariable @code{radexpand} den Wert @code{true}, werden die
n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel herausgezogen.
So wird zum Beispiel @code{sqrt(16*x^2)} nur dann zu @code{4*x} vereinfacht,
wenn @code{radexpand} den Wert @code{true} hat.
@end deffn

@c -----------------------------------------------------------------------------
@node Winkelfunktionen, Hyperbelfunktionen, Wurzel-@comma{} Exponential- und Logarithmusfunktion, Mathematische Funktionen
@section Winkelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Winkelfunktionen::
* Funktionen und Variablen f@"ur Winkelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Winkelfunktionen, Funktionen und Variablen f@"ur Winkelfunktionen, Winkelfunktionen, Winkelfunktionen
@subsection Einf@"uhrung in Winkelfunktionen
@c -----------------------------------------------------------------------------

@c Maxima has many trigonometric functions defined.  Not all trigonometric
@c identities are programmed, but it is possible for the user to add many of 
@c them using the pattern matching capabilities of the system. The trigonometric
@c functions defined in Maxima are: 
@c @code{acos}, @code{acosh}, @code{acot}, @code{acoth}, @code{acsc},
@c @code{acsch}, @code{asec}, @code{asech}, @code{asin},
@c @code{asinh}, @code{atan}, @code{atanh}, @code{cos},
@c @code{cosh}, @code{cot}, @code{coth}, @code{csc}, @code{csch},
@c @code{sec}, @code{sech}, @code{sin}, @code{sinh}, @code{tan},
@c and @code{tanh}.  
@c There are a number of commands especially for handling trigonometric 
@c functions, see @code{trigexpand}, @code{trigreduce}, and the switch 
@c @code{trigsign}.  Two share packages extend the simplification rules built 
@c into Maxima, @code{ntrig} and @code{atrig1}. 
@c Do @code{describe(@var{command})} for details.

Maxima kennt viele Winkel- und Hyperbelfunktionen.  Nicht alle Identit@"aten 
f@"ur Winkel- und Hyperbelfunktionen sind programmiert, aber es ist m@"oglich 
weitere Identit@"aten mit der F@"ahigkeit der Erkennung von Mustern 
hinzuzuf@"ugen.

Maxima kennt die folgenden Winkel- und Hypelfunktionen sowie deren Inverse:

@verbatim
     sin       cos       tan
     sec       csc       cot
     asin      acos      atan
     asec      acsc      acot
     sinh      cosh      tanh
     sech      csch      coth
     asinh     acosh     atanh
     asech     acsch     acoth
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Winkelfunktionen, , Einf@"uhrung in Winkelfunktionen, Winkelfunktionen
@subsection Funktionen und Variablen f@"ur Winkelfunktionen
@c -----------------------------------------------------------------------------

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acos (@var{x})
-- Arkuskosinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acot (@var{x})
-- Arkuskotangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acsc (@var{x})
-- Arkuskosekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asec (@var{x})
-- Arkussekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asin (@var{x})
-- Arkussinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{atan}
@deffn {Funktion} atan (@var{x})
-- Arkustangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{atan2}
@deffn {Funktion} atan2 (@var{y}, @var{x})

@c -- yields the value of @code{atan(@var{y}/@var{x})} in the interval 
@c @code{-%pi} to @code{%pi}.

-- Gibt den Wert von @code{atan(@var{y}/@var{x})} im Intervall @code{-%pi}
bis @code{%pi} zur@"uck.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cos (@var{x})
-- Kosinus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cot (@var{x})
-- Kotangens.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} csc (@var{x})
-- Kosekans.

@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sec (@var{x})
-- Sekans.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{sin}
@deffn {Funktion} sin (@var{x})

Die Sinusfunktion.

Die Sinusfunktion kann f@"ur reelle und komplexe Gleitkommazahlen in doppelter
und in beliebiger Genauigkeit berechnet werden.  Ist das Argument eine ganze
oder rationale Zahl, wird die Sinusfunktion nicht numerisch berechnet und eine
Substantivform zur@"uckgegeben.  Die numerische Berechnung kann mit der 
Optionsvariablen @mref{numer} oder der Funktion @mref{float} erzwungen werden.

Die Sinusfunktion ist eine ungerade Funktion und hat Spiegelsymmetrie.  Maxima 
wendet diese Symmetrieeigenschaften automatisch f@"ur die Sinusfunktion an.

Ist das Argument @var{x} eine Matrix, eine Liste oder eine Gleichung wird die
Sinusfunktion auf die Elemente der Matrix, der Liste oder auf die beiden Seiten
der Gleichung angewendet.  Dieses Verhalten wird mit der Optionsvariablen
@mref{distribute_over} kontrolliert.

Die Sinusfunktion kann f@"ur symbolische Rechnungen verwendet werden.  Maxima
kann Ausdr@"ucke mit der Sinusfunktion differenzieren und integrieren, 
Grenzwerte mit der Sinusfunktion bestimmen sowie Gleichungen und 
Differentialgleichungen mit der Sinusfunktion l@"osen.

Das Argument der Sinusfunktion kann eine Taylorreihe sein.  In diesem Fall
wird die Taylorreihenentwicklung f@"ur die Sinusfunktion vollst@"andig 
ausgef@"uhrt.

Die folgenden Optionsvariablen kontrollieren die Vereinfachung der 
Sinusfunktion:

@table @code

@item distribute_over
Hat die Optionsvariable den Wert @code{true} und ist das Argument der 
Sinusfunktion eine Matrix, Liste oder Gleichung wird die Funktion auf die 
Elemente oder beiden Seiten der Gleichung angewendet.  Der Standardwert ist 
@code{true}.

@item %piargs
Hat die Optionsvariable den Wert @code{true}, vereinfacht die Sinusfunktion
f@"ur ganzahlige und halbzahlige Vielfache sowie Vielfache von @code{1/3} und 
@code{1/4} von @code{%pi}.  Der Standardwert ist @code{true}.

@item %iargs
Hat die Optionsvariable den Wert @code{true} und ist das Argument der 
Sinusfunktion ein Vielfaches von @code{%i} vereinfacht die Sinusfunktion zum 
Sinus Hyperbolicus.  Der Standardwert ist @code{true}.

@item trigsign
Hat die Optionsvariable den Wert @code{true}, wird die Eigenschaften, dass 
der Sinus eine ungerade Funktion ist, angewendet, zum Beispiel vereinfacht 
@code{sin(-x)} zu @code{-sin(x)}.  Der Standardwert ist @code{true}.

@item triginverses
Hat die Optionsvariable den Wert @code{true} und ist das Argument eine inverse
Winkelfunktion vereinfacht die Sinusfunktion zu einem einfachen algebraischen
Ausdruck, zum Beispiel vereinfacht @code{sin(acos(x))} zu @code{sqrt(1-x^2)}.
Der Standardwert ist @code{true}.

@item trigexpand
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion f@"ur 
ein Argument expandiert, das eine Summe oder ein Produkt mit einer ganzen Zahl 
ist.  Der Standardwert ist @code{false}.

@item exponentialize
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion in
die Exponentialform transformiert.  Der Standardwert ist @code{false}.

@item halfangles
Hat die Optionsvariable den Wert @code{true}, dann wird die Sinusfunktion f@"ur
halbzahlige Argumente zu einem @"aquivalenten Ausdruck transformiert.  Der 
Standardwert ist @code{false}.

@end table

F@"ur die Sinusfunktion hat Maxima die folgenden Eigenschaften definiert, die 
mit dem Kommando @code{properties(sin)} angezeigt werden:

@table @code
@item mirror symmetry
Die Sinusfunktion hat Spiegelsymmetrie.

@item deftaylor
Die Taylorreihenentwicklung der Sinusfunktion.

@item integral
Das Integral der Sinusfunktion.

@item distributes over bags
Die Sinusfunktion wird auf Elemente einer Matrix oder Liste oder auf beide
Seiten einer Gleichung angewendet.

@item rule
Die Sinusfunktion ist eine ungerade Funktion.

@item noun
Die Sinusfunktion hat eine Verbform.

@item gradef
Die Ableitung der Sinusfunktion.

@item transfun
Die Sinusfunktion ist eine kompilierte Lisp-Funktion.

@end table

Beispiele:

Numerische Berechnungen f@"ur Gleitkommazahlen:

@example
(%i1) sin(1+%i);
(%o1)                      sin(%i + 1)
(%i2) sin(1.0+%i);
(%o2)       .6349639147847361 %i + 1.298457581415977
(%i3) sin(1.0b0+%i);
(%o3)     6.349639147847361b-1 %i + 1.298457581415977b0
(%i4) sin(1.0b0),fpprec:45;
(%o4)   8.41470984807896506652502321630298999622563061b-1
@end example

Einige Vereinfachungen der Sinusfunktionen:

@example
(%i5) sin(%i*(x+y));
(%o5)                    %i sinh(y + x)
(%i6) sin(%pi/3);
                             sqrt(3)
(%o6)                        -------
                                2
(%i2) sin(x+y),trigexpand:true;
(%o2)             cos(x) sin(y) + sin(x) cos(y)
(%i3) sin(2*x+y),trigexpand:true;
           2         2
(%o3)  (cos (x) - sin (x)) sin(y) + 2 cos(x) sin(x) cos(y)
@end example

Grenzwerte, Ableitungen und Integrale mit der Sinusfunktion:

@example
(%i4) limit(sin(x)/x,x,0);
(%o4)                          1
(%i5) diff(sin(sqrt(x))/x,x);
                  cos(sqrt(x))   sin(sqrt(x))
(%o5)             ------------ - ------------
                        3/2            2
                     2 x              x
(%i6) integrate(sin(x^3),x);
@group
(%o6) 
                         1      3                     1        3
        gamma_incomplete(-, %i x ) + gamma_incomplete(-, - %i x )
                         3                            3
      - ---------------------------------------------------------
                                   12
@end group
@end example

Reihenentwicklung der Sinusfunktion:

@example
(%i7) taylor(sin(x),x,0,3);
@group
                              3
                             x
(%o7)/T/                 x - -- + . . .
                             6
@end group
@end example
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} tan (@var{x})
-- Tangens.
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%piargs}
@defvr {Optionsvariable} %piargs
Standardwert: @code{true}

@c When @code{%piargs} is @code{true}, trigonometric functions are simplified to
@c algebraic constants when the argument is an integer multiple of
@c @iftex
@c @math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4}, or @math{\pi/6}.
@c @end iftex
@c @ifnottex
@c @math{%pi}, @math{%pi/2}, @math{%pi/3}, @math{%pi/4}, or @math{%pi/6}.
@c @end ifnottex

Hat @code{%piargs} den Wert @code{true}, werden Winkel- und Hyperbelfunktionen 
sowie deren Inverse zu algebraischen Konstanten vereinfacht, wenn das Argument
ein ganzzahliges Vielfaches der folgenden Konstanten ist:
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4} oder @math{\pi/6}.
@end iftex
@ifnottex
@code{%pi}, @code{%pi/2}, @code{%pi/3}, @code{%pi/4} oder @code{%pi/6}.
@end ifnottex

@c Maxima knows some identities which can be applied when 
@c are multiplied by an integer variable (that is, a symbol declared to be 
@c integer).

Maxima kennt weiterhin einige Identit@"aten, wenn die Konstante
@iftex 
@math{\pi}
@end iftex
@ifnottex 
@code{%pi}
@end ifnottex
mit einer Variablen multipliziert wird, die als ganzzahlig deklariert wurde.

Beispiele:

@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example

@c @iftex
@c Some identities are applied when @math{\pi} and @math{\pi/2} are multiplied 
@c by an integer variable.
@c @end iftex
@c @ifnottex
@c Some identities are applied when @math{%pi} and @math{%pi/2} are multiplied 
@c by an integer variable.
@c @end ifnottex

Weitere Identit@"aten werden angewendet, wenn
@iftex 
@math{\pi} und @math{\pi/2}
@end iftex 
@ifnottex 
@code{%pi} und @code{%pi/2}
@end ifnottex
mit einer ganzzahligen Variable multipliziert werden.

@example
(%i1) declare (n, integer, m, even)$
@group
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{%iargs}
@defvr {Optionsvariable} %iargs
Standardwert: @code{true}

@c When @code{%iargs} is @code{true}, trigonometric functions are simplified to
@c hyperbolic functions
@c @iftex
@c when the argument is apparently a multiple of the imaginary unit @math{i}.
@c @end iftex
@c @ifnottex
@c when the argument is apparently a multiple of the imaginary unit @math{%i}.
@c @end ifnottex

Hat @code{%iargs} den Wert @code{true}, werden Winkelfunktionen zu 
Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches der 
imagin@"aren Einheit
@iftex
@math{i}
@end iftex
@ifnottex
@code{%i}
@end ifnottex
ist.

@c Even when the argument is demonstrably real, the simplification is applied;
@c @iftex
@c Maxima considers only whether the argument is a literal multiple of @math{i}.
@c @end iftex
@c @ifnottex
@c Maxima considers only whether the argument is a literal multiple of @math{%i}.
@c @end ifnottex

Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgef@"uhrt, wenn das
Argument offensichtlich reel ist.

Beispiele:

@example
(%i1) %iargs : false$
@group
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
@end group
(%i3) %iargs : true$
@group
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end group
@end example

@c Even when the argument is demonstrably real, the simplification is applied.

Auch wenn das Argument offensichtlich reel ist, wird zu einer Hyperbelfunktion
vereinfacht.

@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{halfangles}
@defvr {Optionsvariable} halfangles
Standardwert: @code{false}

@c When @code{halfangles} is @code{true}, trigonometric functions of arguments 
@c @code{@var{expr}/2} are simplified to functions of @var{expr}.

Hat @code{halfangles} den Wert @code{true}, werden Winkel- und 
Hyperbelfunktionen mit halbzahligen Argumenten @code{@var{expr}/2} vereinfacht.

@c For a real argument @var{x} in the interval @code{0 < x < 2*%pi} the sine of 
@c the half-angle simplifies to a simple formula:

F@"ur ein reelles Argument @var{x} im Intervall @code{0 < x < 2*%pi} vereinfacht
der Sinus f@"ur ein halbzahliges Argument zu einer einfachen Formel: 

@example
                         sqrt(1 - cos(x))
                         ----------------
                             sqrt(2)
@end example

@c A complicated factor is needed to make this formula correct for all complex 
@c arguments @var{z}:

Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt ist f@"ur ein
komplexes Argument @var{z}:

@verbatim
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                            realpart(z)            realpart(z)
                      floor(-----------) - ceiling(-----------)
                               2 %pi                  2 %pi
                ((- 1)                                          + 1))
@end verbatim

@c Maxima knows this factor and similar factors for the functions @code{sin}, 
@c @code{cos}, @code{sinh}, and @code{cosh}. For special values of the argument 
@c @math{z} these factors simplify accordingly.

Maxima kennt diesen Faktor und @"ahnliche Faktoren f@"ur die Sinus, Cosinus, 
Sinus Hyperbolicus und Cosinus Hyperbolicus Funktionen.  F@"ur spezielle 
Argumente @math{z} dieser Funktionen vereinfachen diese Funktionen entsprechend.

Beispiele:

@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{ntrig}
@defvr {Paket} ntrig

@c The @code{ntrig} package contains a set of simplification rules that are
@c used to simplify trigonometric function whose arguments are of the form
@c @code{@var{f}(@var{n} %pi/10)} where @var{f} is any of the functions
@c @code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} and @code{cot}.

Das Paket @code{ntrig} enth@"alt Regeln, um Winkelfunktionen zu vereinfachen, 
die Argumente der Form @code{@var{f}(@var{n} %pi/10)} haben.  @var{f} ist eine 
der Funktionen @code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} oder 
@code{cot}.

Das Kommando @code{load(ntrig)} l@"adt das Paket.  Die Vereinfachungen werden
dann von Maxima automatisch ausgef@"uhrt.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpand}
@deffn {Funktion} trigexpand (@var{expr})

@c Expands trigonometric and hyperbolic functions of sums of angles and of 
@c multiple angles occurring in @var{expr}. For best results, @var{expr} should
@c be expanded. To enhance user control of simplification, this function expands
@c only one level at a time, expanding sums of angles or multiple angles.  To 
@c obtain full expansion into sines and cosines immediately, set the switch 
@c @code{trigexpand: true}.

Die Funktion @code{trigexpand} expandiert Winkel- und Hyperbelfunktionen im 
Ausdruck @var{expr}, die Summen und Vielfache von Winkeln als Argument haben.
Die besten Ergebnisse werden erzielt, wenn der Ausdruck @var{expr} zun@"achst
expandiert wird.

@c @code{trigexpand} is governed by the following global flags:

Folgende Schalter kontrollieren @code{trigexpand}:

@table @code
@c @item trigexpand
@c If @code{true} causes expansion of all expressions containing sin's and 
@c cos's occurring subsequently.

@item trigexpand
Wenn @code{true}, werden Sinus- und Cosinus-Funktionen expandiert.

@c @item halfangles
@c If @code{true} causes half-angles to be simplified away.

@item halfangles
Wenn @code{true}, werden Vereinfachungen f@"ur halbzahlige Argumente angewendet.

@c @item trigexpandplus
@c Controls the "sum" rule for @code{trigexpand}, expansion of sums (e.g.
@c @code{sin(x + y)}) will take place only if @code{trigexpandplus} is 
@c @code{true}.

@item trigexpandplus
Wenn @code{true}, werden Winkelfunktionen, die eine Summe als Argument haben,
wie zum Beispiel @code{sin(x+y)}, vereinfacht.

@c @item trigexpandtimes
@c Controls the "product" rule for @code{trigexpand}, expansion of products 
@c (e.g. @code{sin(2 x)}) will take place only if @code{trigexpandtimes} is 
@c @code{true}.

@item trigexpandtimes
Wenn @code{true},  werden Winkelfunktionen, die ein Produkt als Argument haben,
wie zum Beispiel @code{sin(2 x)}, vereinfacht.

@end table

Beispiele:

@example
@group
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
@group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end group
@end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandplus}
@defvr {Optionsvariable} trigexpandplus
Standardwert: @code{true}

@c @code{trigexpandplus} controls the "sum" rule for @code{trigexpand}.  Thus, 
@c when the @code{trigexpand} command is used or the @code{trigexpand} switch 
@c set to @code{true}, expansion of sums (e.g. @code{sin(x+y))} will take place 
@c only if @code{trigexpandplus} is @code{true}.

@code{trigexpandplus} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @code{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit Summen
als Argumente auftreten.  Hat @code{trigexpandplus} den Wert @code{true},
werden zum Beispiel Winkelfunktionen wie @code{sin(x+y)} vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigexpandtimes}
@defvr {Optionsvariable} trigexpandtimes
Standardwert: @code{true}

@c @code{trigexpandtimes} controls the "product" rule for @code{trigexpand}.  
@c Thus, when the @code{trigexpand} command is used or the @code{trigexpand} 
@c switch set to @code{true}, expansion of products (e.g. @code{sin(2*x)}) will 
@c take place only if @code{trigexpandtimes} is @code{true}.

@code{trigexpandtimes} kontrolliert die Vereinfachung von Winkelfunktionen mit
der Funktion @code{trigexpand} f@"ur den Fall, dass Winkelfunktionen mit 
Produkten als Argumente auftreten.  Hat @code{trigexpandtimes} den Wert 
@code{true}, werden zum Beispiel Winkelfunktionen wie @code{sin(2 x)} 
vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{triginverses}
@defvr {Optionsvariable} triginverses
Standardwert: @code{true}

@c @code{triginverses} controls the simplification of the composition of 
@c trigonometric and hyperbolic functions with their inverse functions.

Kontrolliert die Vereinfachung, wenn das Argument einer Trigonometrischen oder
Hyperbolischen Funktion eine der inversen Funktion ist.

@c If @code{all}, both e.g. @code{atan(tan(@var{x}))} and 
@c @code{tan(atan(@var{x}))} simplify to @var{x}.

Hat @code{triginverses} den Wert @code{all}, vereinfachen beide Ausdr@"ucke
@code{atan(tan(@var{x}))} und @code{tan(atan(@var{x}))} zum Wert @var{x}.

@c If @code{true}, the @code{@var{arcfun}(@var{fun}(@var{x}))} simplification 
@c is turned off.

Hat @code{triginverses} den Wert @code{all}, wird
@code{@var{arcfun}(@var{fun}(@var{x}))} nicht vereinfacht.

@c If @code{false}, both the @code{@var{arcfun}(@var{fun}(@var{x}))} and
@c @code{@var{fun}(@var{arcfun}(@var{x}))} simplifications are turned off.

Hat @code{triginverses} den Wert @code{false}, werden
@code{@var{arcfun}(@var{fun}(@var{x}))} und 
@code{@var{fun}(@var{arcfun}(@var{x}))} nicht vereinfacht.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigreduce}
@deffn  {Funktion} trigreduce (@var{expr}, @var{x})
@deffnx {Funktion} trigreduce (@var{expr})

@c Combines products and powers of trigonometric and hyperbolic sin's and cos's 
@c of @var{x} into those of multiples of @var{x}. It also tries to eliminate 
@c these functions when they occur in denominators.  If @var{x} is omitted then 
@c all variables in @var{expr} are used.

Produkte und Potenzen von Trigonometrischen und Hyperbolischen Sinus und Cosinus
Funktionen mit dem Argument @var{x} werden zu Funktionen vereinfacht, die
Vielfache von @var{x} enthalten.  @code{trigreduce} versucht auch, Sinus und
Cosinus Funktionen in einem Nenner zu eleminieren.  Wird keine Variable @var{x}
angegeben, werden alle Variablen im Ausdruck @code{expr} betrachtet.

Siehe auch @mrefdot{poissimp}

@example
@group
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example

@c 
@c     OBSOLETE
@c     The behavior was changed in order to avoid calling expand in the core
@c     simplifier (trigi.lisp rev 1.31)
@c     See http://www.math.utexas.edu/pipermail/maxima/2008/010919.html.
@c 
@c The trigonometric simplification routines will use declared
@c information in some simple cases.  Declarations about variables are
@c used as follows, e.g.
@c 
@c ---beg---
@c declare(j, integer, e, even, o, odd)$
@c sin(x + (e + 1/2)*%pi);
@c sin(x + (o + 1/2)*%pi);
@c ---end---
@c @example
@c (%i1) declare(j, integer, e, even, o, odd)$
@c (%i2) sin(x + (e + 1/2)*%pi);
@c (%o2)                        cos(x)
@c (%i3) sin(x + (o + 1/2)*%pi);
@c (%o3)                       - cos(x)
@c @end example
@end deffn

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsign}
@defvr {Optionsvariable} trigsign
Standardwert: @code{true}

@c When @code{trigsign} is @code{true}, it permits simplification of negative
@c arguments to trigonometric functions. E.g., @code{sin(-x)} will become
@c @code{-sin(x)} only if @code{trigsign} is @code{true}.

Hat @code{trigsign} den Wert @code{true}, werden Trigonometrische Funktionen
mit einem negativem Argument vereinfacht.  Zum Beispiel vereinfacht in diesem
Fall @code{sin(-x)} zu @code{-sin(x)}.
@end defvr

@c --- 27.11.2010 DK -----------------------------------------------------------
@anchor{trigsimp}
@deffn {Funktion} trigsimp (@var{expr})

@c @iftex
@c Employs the identities
@c @tex
@c $\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@c @end tex
@c and
@c @tex
@c $\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@c @end tex
@c to simplify expressions containing @code{tan}, @code{sec},
@c etc., to @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@c @end iftex
@c @ifnottex
@c Employs the identities @math{sin(x)^2 + cos(x)^2 = 1} and
@c @math{cosh(x)^2 - sinh(x)^2 = 1} to simplify expressions containing 
@c @code{tan}, @code{sec}, etc., to @code{sin}, @code{cos}, @code{sinh}, 
@c @code{cosh}.
@c @end ifnottex

Wendet die Identit@"aten
@iftex
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{sin(x)^2 + cos(x)^2 = 1}
@end ifnottex
und
@iftex
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
@end iftex
@ifnottex
@code{cosh(x)^2 - sinh(x)^2 = 1}
@end ifnottex
an, um Ausdr@"ucke, die Funktionen wie @code{tan}, @code{sec}, usw. enthalten, 
zu Ausdr@"ucken mit den Funktionen @code{sin}, @code{cos}, @code{sinh}, 
@code{cosh} zu vereinfachen.

@c @code{trigreduce}, @code{ratsimp}, and @code{radcan} may be able to further 
@c simplify the result.

Die Anwendung von Funktionen wie @code{trigreduce}, @code{ratsimp} und 
@code{radcan} kann den Ausdruck weiter vereinfachen.

@c @code{demo ("trgsmp.dem")} displays some examples of @code{trigsimp}.

Das Kommando @code{demo(trgsmp)} zeigt einige Beispiele.

@c MERGE EXAMPLES INTO THIS ITEM
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trigrat}
@deffn {Funktion} trigrat (@var{expr})

Gives a canonical simplifyed quasilinear form of a trigonometrical expression; 
@var{expr} is a rational fraction of several @code{sin}, @code{cos} or 
@code{tan}, the arguments of them are linear forms in some variables (or 
kernels) and @code{%pi/@var{n}} (@var{n} integer) with integer coefficients.
The result is a simplified fraction with numerator and denominator linear in 
@code{sin} and @code{cos}.  Thus @code{trigrat} linearize always when it is 
possible.

@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

The following example is taken from
Davenport, Siret, and Tournier, @i{Calcul Formel}, Masson (or in English,
Addison-Wesley), section 1.5.5, Morley theorem.

@example
(%i1) c : %pi/3 - a - b$
@group
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
@group
(%i3) ba : bc, c=a, a=c;
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
@group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
@group
(%i5) trigrat (ac2);
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Hyperbelfunktionen, Zufallszahlen, Winkelfunktionen, Mathematische Funktionen
@section Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Hyperbelfunktionen::
* Funktionen und Variablen f@"ur Hyperbelfunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Hyperbelfunktionen, Funktionen und Variablen f@"ur Hyperbelfunktionen, Hyperbelfunktionen, Hyperbelfunktionen
@subsection Einf@"uhrung in Hyperbelfunktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Hyperbelfunktionen, , Einf@"uhrung in Hyperbelfunktionen, Hyperbelfunktionen
@subsection Funktionen und Variablen f@"ur Hyperbelfunktionen

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acosh (@var{x})
-- Areakosinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acoth (@var{x})
-- Areakotangens Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} acsch (@var{x})
-- Areakosekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asech (@var{x})
-- Areasekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} asinh (@var{x})
-- Areasinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} atanh (@var{x})
-- Areatangens Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} cosh (@var{x})
-- Kosinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} coth (@var{x})
-- Kotangens Hyperbolicus.

@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} csch (@var{x})
-- Kosekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sech (@var{x})
-- Sekans Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} sinh (@var{x})
-- Sinus Hyperbolicus.
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@deffn {Funktion} tanh (@var{x})
-- Tangens Hyperbolicus.
@end deffn

@c -----------------------------------------------------------------------------
@node Zufallszahlen, , Hyperbelfunktionen, Mathematische Funktionen
@section Zufallszahlen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@deffn  {Funktion} make_random_state (@var{n})
@deffnx {Funktion} make_random_state (@var{s})
@deffnx {Funktion} make_random_state (true)
@deffnx {Funktion} make_random_state (false)
@c OMIT THIS FOR NOW. SEE COMMENT BELOW.
@c @defunx make_random_state (@var{a})

@c A random state object represents the state of the random number generator.
@c The state comprises 627 32-bit words.

Ein Zufallszustand repr@"asentiert den Zustand des Zufallszahlengenerators.  Der
Zustand enth@"alt 627 32-Bit Worte.

@c @code{make_random_state (@var{n})} returns a new random state object created 
@c from an integer seed value equal to @var{n} modulo 2^32. @var{n} may be 
@c negative.

@code{make_random_state(@var{n})} gibt einen neuen Zufallszustand zur@"uck, der 
aus einer ganzen Zahl @var{n} modulo 2^32 erzeugt wird.  @var{n} kann eine 
negative Zahl sein.

 @c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
 @c @code{make_random_state (@var{a})} returns a new random state object
 @c created from an array @var{a}, which must be a Lisp array of 32 unsigned
 @c bytes.

@c @code{make_random_state (@var{s})} returns a copy of the random state 
@c @var{s}.

@code{make_random_state(@var{s})} gibt eine Kopie des Zufallszutandes @var{s}
zur@"uck.

@c @code{make_random_state (true)} returns a new random state object, using the
@c current computer clock time as the seed.

@code{make_random_state(true)} gibt einen neuen Zufallszustand zur@"uck, der aus
der aktuellen Systemzeit des Computers erzeugt wird.

@c @code{make_random_state (false)} returns a copy of the current state of the 
@c random number generator.

@code{make_random_state(false)} gibt eine Kopie des aktuellen Zustands des
Zufallszahlengenerators zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Funktion} set_random_state (@var{s})

@c Copies @var{s} to the random number generator state.

Kopiert @var{s} in den Zufallszustand des Zufallszahlengenerators.

@c @code{set_random_state} always returns @code{done}.

@code{set_random_state} gibt immer @code{done} zur@"uck.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Funktion} random (@var{x})

@c Returns a pseudorandom number. If @var{x} is an integer, @code{random 
@c (@var{x})} returns an integer from 0 through @code{@var{x} - 1} inclusive. 
@c If @var{x} is a floating point number, @code{random (@var{x})} returns a 
@c nonnegative floating point number less than @var{x}. @code{random} complains 
@c with an error if @var{x} is neither an integer nor a float, or if @var{x} is 
@c not positive.

Erzeugt eine Pseudo-Zufallszahl.  Ist @var{x} eine ganze Zahl, gibt 
@code{random(@var{x})} eine ganze Zahl im Intervall 0 bis einschlie@ss{}lich
@code{@var{x}-1} zur@"uck.  Ist @var{x} eine Gleitkommazahl, gibt
@code{random(@var{x})} eine positive Gleitkommazahl zur@"uck, die kleiner als
@var{x} ist.  @code{random} gibt eine Fehlermeldung, wenn @var{x} weder eine
ganze Zahl noch eine Gleitkommazahl ist oder wenn @var{x} eine negative Zahl 
ist.

@c The functions @code{make_random_state} and @code{set_random_state} maintain 
@c the state of the random number generator.

Die Funktionen @code{make_random_state} und @code{set_random_state} verwalten
den Zustand des Zufallszahlengenerators.

@c The Maxima random number generator is an implementation of the Mersenne 
@c twister MT 19937.

Der Maxima-Zufallszahlengenerator ist eine Implementation des Mersenne twister
MT 19937.

Beispiele:

@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn

@c --- End of file MathFunctions.de.texi ---------------------------------------

