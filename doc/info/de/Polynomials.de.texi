@c -----------------------------------------------------------------------------
@c File        : Polynomials.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Polynomials.texi revision 1.34
@c Translation : Dr. Dieter Kaiser
@c Date        : 11.12.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Introduction to Polynomials::
* Functions and Variables for Polynomials::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Polynomials, Functions and Variables for Polynomials, Polynome, Polynome
@section Introduction to Polynomials

@c Polynomials are stored in Maxima either in General Form or as Cannonical 
@c Rational Expressions (CRE) form.  The latter is a standard form, and is used 
@c internally by operations such as factor, ratsimp, and so on.

Polynome werden in einer allgemeinen Darstellung oder in einer kanonischen
Darstellung (CRE - Cannonical Rational Expressions) gespeichert.  Die 
CRE-Darstellung ist die Standardform f@"ur Operationen mit Polynomen und wird 
intern von Funktionen wie @code{factor} oder @code{ratsimp} verwendet.

@c Canonical Rational Expressions constitute a kind of representation
@c which is especially suitable for expanded polynomials and rational
@c functions (as well as for partially factored polynomials and rational
@c functions when RATFAC is set to @code{true}).  In this CRE form an
@c ordering of variables (from most to least main) is assumed for each
@c expression.  Polynomials are represented recursively by a list
@c consisting of the main variable followed by a series of pairs of
@c expressions, one for each term of the polynomial.  The first member of
@c each pair is the exponent of the main variable in that term and the
@c second member is the coefficient of that term which could be a number or
@c a polynomial in another variable again represented in this form.  Thus
@c the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that
@c of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main
@c variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
@c variable. "Main"-ness is usually determined by reverse alphabetical
@c order.  The "variables" of a CRE expression needn't be atomic.  In fact
@c any subexpression whose main operator is not + - * / or ^ with integer
@c power will be considered a "variable" of the expression (in CRE form) in
@c which it occurs.  For example the CRE variables of the expression
@c X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
@c not specify an ordering of variables by using the RATVARS function
@c Maxima will choose an alphabetic one.  

Ausdr@"ucke in einer CRE-Form sind besonders f@"ur die Darstellung von Polynomen
und rationalen Funktionen geeignet.  Die CRE-Form nimmt eine Ordnung der
Variablen an.  Polynome werden rekursiv als eine Liste definiert, die als
ersten Eintrag den Namen der Variablen und als n@"achste Eintr@"age die 
Exponenten und Koeffizienten der Variablen enthalten.  Der Koeffizient kann
eine Zahl oder wiederum ein Polynom sein.  Zum Beispiel hat das Polynom
@code{3*x^2-1} die Darstellung @code{(X 2 3 0 -1)} und das Polynom 
@code{2*x*y+x-3} die Darstellung @code{(Y 1 (X 1 2) 0 (X 1 1 0 -3))}, wenn 
@code{y} die Hauptvariable des Polynoms ist.  Ist @var{x} die Hauptvariable des
Polynoms, dann ist die Darstellung @code{(X 1 (Y 1 2 0 1) 0 -3)}.

Die Ordnung der Variablen ist in der Regel umgekehrt alphabetisch. Die Variablen
m@"ussen keine Atome sein.  Alle Ausdr@"ucke, die nicht die Operatoren @code{+},
@code{-}, @code{*}, @code{/} oder @code{^} enthalten, werden in einer 
CRE-Darstellung als "Variable" angenommen. Zum  Beispiel sind @code{x}, 
@code{sqrt(x)} und @code{sin(x+1)} die CRE-Variablen des Ausdrucks
@code{x+sin(x+1)+2*SQRT(x)+1}.  Wird vom Nutzer keine abweichende Ordnung der 
Variablen mit der Funktion @code{ratvars} definiert, nimmt Maxima eine 
alphabetische Ordnung der Variablen an.

@c In general, CRE's represent rational expressions, that is, ratios of 
@c polynomials, where the numerator and denominator have no common factors, and 
@c the denominator is positive.  The internal form is essentially a pair of 
@c polynomials (the numerator and denominator) preceded by the variable ordering
@c list.  If an expression to be displayed is in CRE form or if it contains any
@c subexpressions in CRE form, the symbol /R/ will follow the line label. See 
@c the RAT function for converting an expression to CRE form.  

Im Allgemeinen werden rationale Funktionen in einer CRE-Form dargestellt, die
keinen gemeinsamen Faktor im Z@"ahler und Nenner haben.  Die interne Darstellung
ist ein Paar von Polynomen, die jeweils den Z@"ahler und den Nenner darstellen. 
Diesem Paar geht eine Liste mit der Ordnung der Variablen im Ausdruck voraus.
Ein Ausdruck in einer CRE-Form oder der CRE-Formen enth@"alt, wird in der 
Ausgabe mit dem Symbol @code{/R/} gekennzeichnet.  Mit der Funktion @code{rat} 
k@"onnen allgemeine Ausdr@"ucke in eine CRE-Form transformiert werden.

@c An extended CRE form is used for the representation of Taylor series.  The
@c notion of a rational expression is extended so that the exponents of the
@c variables can be positive or negative rational numbers rather than just
@c positive integers and the coefficients can themselves be rational
@c expressions as described above rather than just polynomials.  These are
@c represented internally by a recursive polynomial form which is similar
@c to and is a generalization of CRE form, but carries additional
@c information such as the degree of truncation.  As with CRE form, the
@c symbol /T/ follows the line label of such expressions.

F@"ur die Darstellung von Taylor-Polynomen wird eine erweiterte CRE-Form 
verwendet.  In dieser Darstellung k@"onnen die Exponenten von Polynomen auch 
rationale Zahlen sein.  Weiterhin k@"onnen die Koeffizienten rationale
Funktionen.  Die erweiterte CRE-Form enth@"alt auch Informationen @"uber den 
Grad des Polynoms.  In der Ausgabe wird die erweiterte CRE-Form mit dem Symbol 
@code{/T/} bezeichnet.

@c -----------------------------------------------------------------------------
@node Functions and Variables for Polynomials,  , Introduction to Polynomials, Polynome
@section Functions and Variables for Polynomials

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{algebraic}
@defvr {Optionsvariable} algebraic
Standardwert: @code{false}

@c @code{algebraic} must be set to @code{true} in order for the simplification 
@c of algebraic integers to take effect.

@code{algebraic} muss den Wert @code{true} haben, damit algebraische ganze
Zahlen vereinfacht werden.

@end defvr

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{berlefact}
@defvr {Optionsvariable} berlefact
Standardwert: @code{true}

@c When @code{berlefact} is @code{false} then the Kronecker factoring
@c algorithm will be used otherwise the Berlekamp algorithm, which is the
@c default, will be used.

Hat @code{berlefact} den Wert @code{false}, dann wird der Kronecker-Algorithmus
f@"ur die Faktorisierung genutzt.  Ansonsten wird der Berlekamp-Algorithmus 
genutzt.  Das ist der Standard.

@end defvr

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{bezout}
@deffn {Funktion} bezout (@var{p1}, @var{p2}, @var{x})

@c an alternative to the @code{resultant} command.  It
@c returns a matrix. @code{determinant} of this matrix is the desired resultant.

@code{bezout} ist eine Alternative zur Funktion @code{resultant}.  Die 
R@"uckgabe ist eine Matrix.  Die Anwendung der Funktion @code{determinant} auf 
das Ergebnis liefert das gew@"unschte Ergebnis.

@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{bothcoef}
@deffn {Funktion} bothcoef (@var{expr}, @var{x})

@c Returns a list whose first member is the coefficient of @var{x} in @var{expr}
@c (as found by @code{ratcoef} if @var{expr} is in CRE form otherwise by 
@c @code{coeff}) and whose second member is the remaining part of @var{expr}.  
@c That is, @code{[A, B]} where @code{@var{expr} = A*@var{x} + B}.

Gibt eine Liste zur@"uck, deren ersten Element der Koeffizient der Variablen
@var{x} im Ausdruck @var{expr} und deren zweites Element der verbleibende
Teil des Ausdrucks @var{expr} ist.  Das Ergebnis ist also @code{[A,B]} und es
gilt @code{@var{expr} = A * @var{x} + B}.

Beispiel:

@c ===beg===
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         is (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);
@c ===end===
@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end deffn

@c --- 12.10.2010 DK -----------------------------------------------------------
@anchor{coeff}
@deffn  {Funktion} coeff (@var{expr}, @var{x}, @var{n})
@deffnx {Funktion} coeff (@var{expr}, @var{x})

@c Returns the coefficient of @code{@var{x}^@var{n}} in @var{expr},
@c where @var{expr} is a polynomial or a monomial term in @var{x}.

Gibt den Koeffizienten von @code{@var{x}^@var{n}} im Ausdruck @var{expr}
zur@"uck, wobei @var{expr} ein Polynom ist.

@c @code{coeff(@var{expr}, @var{x}^@var{n})} is equivalent to 
@c @code{coeff(@var{expr}, @var{x}, @var{n})}.
@c @code{coeff(@var{expr}, @var{x}, 0)} returns the remainder of @var{expr}
@c which is free of @var{x}. If omitted, @var{n} is assumed to be 1.

@code{coeff(@var{expr}, @var{x}^@var{n})} ist @"aquivalent zu 
@code{coeff(@var{expr}, @var{x}, @var{n})}. 
@code{coeff(@var{expr}, @var{x}, 0)} gibt den Rest des Ausdrucks @var{expr}
zur@"uck, der frei von der Variablen @var{x} ist.  Wenn nicht angegeben, wird
@var{n} als 1 angenommen.

@c @var{x} may be a simple variable or a subscripted variable, or a 
@c subexpression of @var{expr} which comprises an operator and all of its 
@c arguments.

@var{x} kann auch eine indizierte Variable oder ein Teilausdruck von @var{expr}
sein. 

@c It may be possible to compute coefficients of expressions which are 
@c equivalent to @var{expr} by applying @code{expand} or @code{factor}.
@c @code{coeff} itself does not apply @code{expand} or @code{factor} or any 
@c other function.

@code{coeff} wendet weder die Funktion @code{expand} noch die Funktion 
@code{factor} an, um einen Ausdruck zu expandieren oder zu faktorisieren.  Daher
kann es zu anderen Ergebnissen kommen, wenn zuvor diese Funktionen angewendet 
werden. 

@c @code{coeff} distributes over lists, matrices, and equations.

Wird @code{coeff} auf Listen, Matrizen oder Gleichungen angewendet, wird die
Funktion auf die Elemente bzw. beide Seiten der Gleichung angewendet.

Beispiele:

@c @code{coeff} returns the coefficient @code{@var{x}^@var{n}} in @var{expr}.

@code{coeff} gibt den Koeffizient @code{@var{x}^@var{n}} des Ausdruckes 
@var{expr} zur@"uck.

@c ===beg===
@c coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
@c ===end===
@example
(%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                3
(%o1)                          b
@end example

@c @code{coeff(@var{expr}, @var{x}^@var{n})} is equivalent
@c to @code{coeff(@var{expr}, @var{x}, @var{n})}.

@code{coeff(@var{expr}, @var{x}^@var{n})} ist @"aquivalent zu
@code{coeff(@var{expr}, @var{x}, @var{n})}.

@c ===beg===
@c coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
@c coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
@c ===end===
@example
(%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
(%o1)                         - c
                                 3
(%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
(%o2)                         - c
                                 3
@end example

@c @code{coeff(@var{expr}, @var{x}, 0)} returns the remainder of @var{expr}
@c which is free of @var{x}.

@code{coeff(@var{expr}, @var{x}, 0)} gibt den Rest des Ausdrucksw @var{expr}
zur@"uck, der frei von der Variablen @var{x} ist.

@c ===beg===
@c coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
@c ===end===
@example
(%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                            3  3
(%o1)                      c  u  + a u
@end example

@c @var{x} may be a simple variable or a subscripted variable, or a 
@c subexpression of @var{expr} which comprises an operator and all of its 
@c arguments.

@var{x} kann eine einfache Variable, eine indizierte Variable oder ein 
Teilausdruck des Ausdrucks @var{expr} sein.

@c ===beg===
@c coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
@c coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
@c coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
@c coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
@c ===end===
@example
(%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
(%o1)                        - 2 %pi
(%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
(%o2)                        - 2 %pi
(%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                3
(%o3)                        sin (x)
(%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
(%o4)                         c - d
@end example

@c @code{coeff} itself does not apply @code{expand} or @code{factor} or any 
@c other function.

@code{coeff} wendet die Funktionen @code{expand} und @code{factor} nicht an.

@c ===beg===
@c coeff (c*(a + b)^3, a);
@c expand (c*(a + b)^3);
@c coeff (%, a);
@c coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
@c factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
@c coeff (%, (a + b)^3);
@c ===end===
@example
(%i1) coeff (c*(a + b)^3, a);
(%o1)                           0
(%i2) expand (c*(a + b)^3);
                 3          2        2        3
(%o2)           b  c + 3 a b  c + 3 a  b c + a  c
(%i3) coeff (%, a);
                                2
(%o3)                        3 b  c
(%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
(%o4)                           0
(%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                  3
(%o5)                      (b + a)  c
(%i6) coeff (%, (a + b)^3);
(%o6)                           c
@end example

@c @code{coeff} distributes over lists, matrices, and equations.

@code{coeff} wird bei Listen und Matrizen auf die Elemente und bei Gleichungen
auf die beiden Seiten angewendet.

@c ===beg===
@c coeff ([4*a, -3*a, 2*a], a);
@c coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
@c coeff (a*u - b*v = 7*u + 3*v, u);
@c ===end===
@example
(%i1) coeff ([4*a, -3*a, 2*a], a);
(%o1)                      [4, - 3, 2]
(%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                          [  a    b  ]
(%o2)                     [          ]
                          [ - c  - d ]
(%i3) coeff (a*u - b*v = 7*u + 3*v, u);
(%o3)                         a = 7
@end example

@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{content}
@deffn {Funktion} content (@var{p_1}, @var{x_1}, @dots{}, @var{x_n})

@c Returns a list whose first element is the greatest common divisor of the 
@c coefficients of the terms of the polynomial @var{p_1} in the variable 
@c @var{x_n} (this is the content) and whose second element is the polynomial 
@c @var{p_1} divided by the content.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Gibt eine Liste zur@"uck, deren erstes Element der gr@"o@ss{}te gemeinsame 
Teiler der Koeffizienten des Polynoms @var{p_1} in der Variablen @var{x_n} ist 
und dessen zweites Element das durch den gr@"o@ss{}ten gemeinsamen Teiler 
dividierte Polynom ist.

Beispiel:

@c ===beg===
@c content (2*x*y + 4*x^2*y^2, y);
@c ===end===
@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{denom}
@deffn {Funktion} denom (@var{expr})

@c Returns the denominator of the rational expression @var{expr}.

Gibt den Nenner des rationalen Ausdrucks @var{expr} zur@"uck.

@end deffn

@c --- 01.12.2010 DK -----------------------------------------------------------
@anchor{divide}
@deffn {Funktion} divide (@var{p_1}, @var{p_2}, @var{x_1}, @dots{}, @var{x_n})

@c computes the quotient and remainder of the polynomial @var{p_1} divided by 
@c the polynomial @var{p_2}, in a main polynomial variable, @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
@c The other variables are as in the @code{ratvars} function. The result is a 
@c list whose first element is the quotient and whose second element is the
@c remainder.

Berechnet den Quotienten und den Rest der Division des Polynom @var{p_1} durch
das Polynom @var{p_2} f@"ur die Variable @var{x_n}.  Die anderen Variablen
@var{x_1}, ... @var{x_n-1} haben dieselbe Bedeutung wie f@"ur die Funktion
@code{ratvars}.  Das Ergebnis ist eine Liste, wobei das erste Element der
Quotient und das zweite Element der Rest ist.

Beispiele:

@c Note that @code{y} is the main variable in the second example.

Im zweiten Beispiel ist @code{y} die Hauptvariable des Ausdrucks.

@c ===beg===
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);
@c ===end===
@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@end deffn

@c --- 09.12.2010 DK -----------------------------------------------------------
@anchor{dontfactor}
@defvr {Optionsvariable} dontfactor
Standardwert: @code{[]}

@c @code{dontfactor} may be set to a list of variables with respect to which 
@c factoring is not to occur.  (The list is initially empty.) Factoring also 
@c will not take place with respect to any variables which are less important, 
@c according the variable ordering assumed for canonical rational expression 
@c (CRE) form, than those on the @code{dontfactor} list.

@code{dontfactor} kann eine Liste mit den Variablen zugewiesen werden, 
bez@"uglich der ein Ausdruck nicht faktorisiert werden soll.  Weiterhin wird
nicht bez@"uglich von Variablen faktorisiert, die gem@"a@ss{} der kanonischen 
Ordnung der Variablen von geringerer Bedeutung sind, als die Variablen in der 
Liste @code{dontfactor}.

@end defvr

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{eliminate}
@deffn {Funktion} eliminate ([@var{eqn_1}, @dots{}, @var{eqn_n}], [@var{x_1}, @dots{}, @var{x_k}])

@c Eliminates variables from equations (or expressions assumed equal to zero) by
@c taking successive resultants. This returns a list of @code{@var{n} - @var{k}} 
@c expressions with the @var{k} variables @var{x_1}, ..., @var{x_k} eliminated.  
@c First @var{x_1} is eliminated yielding @code{@var{n} - 1} expressions, then 
@c @code{x_2} is eliminated, etc.  If @code{@var{k} = @var{n}} then a single 
@c expression in a list is returned free of the variables @var{x_1}, ..., 
@c @var{x_k}.  In this case @code{solve} is called to solve the last resultant 
@c for the last variable.

Wendet ein Subresultanten-Verfahren an, um die Variablen @var{x_1}, @dots{}, 
@var{x_k} aus den Gleichungen @var{eqn_1}, ..., @var{eqn_n} zu eliminieren.  Die
R@"uckgabe ist ein Gleichungssystem mit @code{@var{n} - @var{k}} Gleichungen, 
wobei die @var{k}-Variablen @var{x_1}, @dots{}, @var{x_k} eliminiert sind.

Beispiel:

@c ===beg===
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);
@c ===end===
@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{ezgcd}
@deffn {Funktion} ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, @dots{})

@c Returns a list whose first element is the g.c.d of the polynomials @var{p_1},
@c @var{p_2}, @var{p_3}, ...  and whose remaining elements are the polynomials 
@c divided by the g.c.d.  This always uses the @code{ezgcd} algorithm.

Gibt eine Liste zur@"uck, deren ersten Element der gr@"o@ss{}te gemeinsame 
Teiler der Polynome @var{p_1}, @dots{}, @var{p_n} ist und deren weitere Elemente
die durch den gr@"o@ss{}ten gemeinsamen Teiler dividierten Polynome sind.  Der
gr@"o@ss{}te gemeinsame Teiler wird immer mit dem @code{ezgcd}-Algorithmus 
bestimmt.

@end deffn

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{facexpand}
@defvr {Optionsvariable} facexpand
Standardwert: @code{true}

@c @code{facexpand} controls whether the irreducible factors returned by 
@c @code{factor} are in expanded (the default) or recursive (normal CRE) form.

@code{facexpand} kontrolliert, ob die irreduziblen Faktoren der Faktorisierung
mit @code{factor} in einer expandierten oder in einer rekursiven (CRE-Form) 
vorliegen.  Der Standard ist, das die Faktoren expandiert werden.

@end defvr

@c --- 11.12.2010 DK -----------------------------------------------------------
@anchor{factor}
@deffn  {Funktion} factor (@var{expr})
@deffnx {Funktion} factor (@var{expr}, @var{p})

Factors the expression @var{expr}, containing any number of variables or 
functions, into factors irreducible over the integers.
@code{factor (@var{expr}, @var{p})} factors @var{expr} over the field of 
rationals with an element adjoined whose minimum polynomial is @var{p}.

@c Faktorisiert den Ausdruck @var{expr}, der eine beliebige Zahl an Variablen 
@c oder Funktionen enthalten kann, in irreduzible Faktoren @"uber die ganzen 
@c Zahlen. @code{factor(@var{expr}, @var{p}} faktorisiert @var{expr} @"uber den 
@c K@"orper der rationalen Zahlen ... TODO: HIER FEHLT DIE DEUTSCHE TERMINOLOGIE.

@code{factor} uses @code{ifactors} function for factoring integers.

@code{factorflag} if @code{false} suppresses the factoring of integer factors
of rational expressions.

@code{dontfactor} may be set to a list of variables with respect to which
factoring is not to occur.  (It is initially empty).  Factoring also
will not take place with respect to any variables which are less
important (using the variable ordering assumed for CRE form) than
those on the @code{dontfactor} list.

@code{savefactors} if @code{true} causes the factors of an expression which
is a product of factors to be saved by certain functions in order to
speed up later factorizations of expressions containing some of the
same factors.

@code{berlefact} if @code{false} then the Kronecker factoring algorithm will
be used otherwise the Berlekamp algorithm, which is the default, will
be used.

@code{intfaclim} if @code{true} maxima will give up factorization of
integers if no factor is found after trial divisions and Pollard's rho
method.  If set to @code{false} (this is the case when the user calls
@code{factor} explicitly), complete factorization of the integer will be
attempted.  The user's setting of @code{intfaclim} is used for internal
calls to @code{factor}. Thus, @code{intfaclim} may be reset to prevent
Maxima from taking an inordinately long time factoring large integers.

Examples:

@c ===beg===
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);
@c ===end===
@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end deffn

@c --- 05.01.2011 DK -----------------------------------------------------------
@anchor{factorflag}
@defvr {Optionsvariable} factorflag
Standardwert: @code{false}

@c When @code{factorflag} is @code{false}, suppresses the factoring of integer 
@c factors of rational expressions.

Hat @code{factorflag} den Wert @code{false}, wird die Faktorisierung von ganzen
Zahlen unterdr@"uckt, die im Nenner auftreten.

Beispiel:

@c ===beg===
@c factorflag:false;
@c factor(1/6*(x^2+2*x+1));
@c factorflag:true;
@c factor(1/6*(x^2+2*x+1));
@c ===end===
@example
(%i1) factorflag:false;
(%o1)                         false
(%i2) factor(1/6*(x^2+2*x+1));
                                   2
                            (x + 1)
(%o2)                       --------
                               6
(%i3) factorflag:true;
(%o3)                         true
(%i4) factor(1/6*(x^2+2*x+1));
                                   2
                            (x + 1)
(%o4)                       --------
                              2 3
@end example

@end defvr

@c -----------------------------------------------------------------------------
@anchor{factorout}
@deffn {Funktion} factorout (@var{expr}, @var{x_1}, @var{x_2}, @dots{})

 Rearranges the sum @var{expr} into a sum of terms of the form 
 @code{f (@var{x_1}, @var{x_2}, ...)*g} where @code{g} is a product of 
 expressions not containing any @var{x_i} and @code{f} is factored.
   @c NEED EXAMPLE HERE

@end deffn

@c -----------------------------------------------------------------------------
@anchor{factorsum}
@deffn {Function} factorsum (@var{expr})

 Tries to group terms in factors of @var{expr} which are sums into groups of 
 terms such that their sum is factorable.  @code{factorsum} can recover the 
 result of @code{expand ((x + y)^2 + (z + w)^2)} but it can't recover
 @code{expand ((x + 1)^2 + (x + y)^2)} because the terms have variables in 
 common.

 Example:

@c ===beg===
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);
@c ===end===
@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{fasttimes}
@deffn {Function} fasttimes (@var{p_1}, @var{p_2})

 Returns the product of the polynomials @var{p_1} and @var{p_2} by using a 
 special algorithm for multiplication of polynomials.  @code{p_1} and 
 @code{p_2} should be multivariate, dense, and nearly the same size.  
 Classical multiplication is of order @code{n_1 n_2} where @code{n_1} is the 
 degree of @code{p_1} and @code{n_2} is the degree of @code{p_2}. 
 @code{fasttimes} is of order @code{max (n_1, n_2)^1.585}.

@end deffn

@c -----------------------------------------------------------------------------
@anchor{fullratsimp}
@deffn {Function} fullratsimp (@var{expr})

 @code{fullratsimp} repeatedly applies @code{ratsimp} followed by non-rational
 simplification to an expression until no further change occurs, and returns 
 the result.

 When non-rational expressions are involved, one call to @code{ratsimp} 
 followed as is usual by non-rational ("general") simplification may not be 
 sufficient to return a simplified result. Sometimes, more than one such call 
 may be necessary. @code{fullratsimp} makes this process convenient.

 @code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} takes one or more 
 arguments similar to @code{ratsimp} and @code{rat}.

Example:

@c ===beg===
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);
@c ===end===
@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end deffn

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND lratsubst
@c THIS ITEM NEEDS MORE WORK

@c -----------------------------------------------------------------------------
@anchor{fullratsubst}
@deffn {Function} fullratsubst (@var{a}, @var{b}, @var{c})

 is the same as @code{ratsubst} except that it calls itself recursively on its
 result until that result stops changing. This function is useful when the 
 replacement expression and the replaced expression have one or more variables
 in common.

 @code{fullratsubst} will also accept its arguments in the format of
 @code{lratsubst}.  That is, the first argument may be a single substitution
 equation or a list of such equations, while the second argument is the
 expression being processed.

 @code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

 Examples:

@c ===beg===
@c load ("lrats")$
@c ===end===
@example
(%i1) load ("lrats")$
@end example

@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize

@c ===beg===
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c ===end===
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example

@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize

@c ===beg===
@c lratsubst (a^2 = b, a^3);
@c ===end===
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@itemize @bullet
@item
@code{fullratsubst} is equivalent to @code{ratsubst}
except that it recurses until its result stops changing.
@end itemize

@c ===beg===
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c ===end===
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example

@itemize @bullet
@item
@code{fullratsubst} also accepts a list of equations or a single
equation as first argument.
@end itemize

@c ===beg===
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c ==end==
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example

@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} may cause an indefinite recursion.
@end itemize

@c ===beg===
@c errcatch (fullratsubst (b*a^2, a^2, a^3));
@c ===end===
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end deffn

@c GCD IS A VARIABLE AND A FUNCTION
@c THIS ITEM NEEDS A LOT OF WORK

@c -----------------------------------------------------------------------------
@anchor{gcd}
@deffn {Function} gcd (@var{p_1}, @var{p_2}, @var{x_1}, ...)

 Returns the greatest common divisor of @var{p_1} and @var{p_2}. The flag 
 @code{gcd} determines which algorithm is employed. Setting @code{gcd} to 
 @code{ez}, @code{subres}, @code{red}, or @code{spmod} selects the 
 @code{ezgcd}, subresultant @code{prs}, reduced, or modular algorithm,
 respectively.  If @code{gcd} @code{false} then @code{gcd (@var{p_1}, 
 @var{p_2}, @var{x})} always returns 1 for all @var{x}.  Many functions (e.g. 
 @code{ratsimp}, @code{factor}, etc.) cause gcd's to be taken implicitly.  For
 homogeneous polynomials it is recommended that @code{gcd} equal to 
 @code{subres} be used.  To take the gcd when an algebraic is present, e.g., 
 @code{gcd (@var{x}^2 - 2*sqrt(2)*@var{x} + 2, @var{x} - sqrt(2))}, 
 @code{algebraic} must be @code{true} and @code{gcd} must not be @code{ez}.

 The @code{gcd} flag, default: @code{spmod}, if @code{false} will also prevent
 the greatest common divisor from being taken when expressions are converted 
 to canonical rational expression (CRE) form.  This will sometimes speed the 
 calculation if gcds are not required.
 NEEDS EXAMPLES HERE

@end deffn

@c IN NEED OF SERIOUS CLARIFICATION HERE

@c -----------------------------------------------------------------------------
@anchor{gcdex}
@deffn  {Function} gcdex (@var{f}, @var{g})
@deffnx {Function} gcdex (@var{f}, @var{g}, @var{x})

 Returns a list @code{[@var{a}, @var{b}, @var{u}]} where @var{u} is the 
 greatest common divisor (gcd) of @var{f} and @var{g}, and @var{u} is equal to
 @code{@var{a} @var{f} + @var{b} @var{g}}. The arguments @var{f} and @var{g} 
 should be univariate polynomials, or else polynomials in @var{x} a supplied 
 @b{main} variable since we need to be in a principal ideal domain for this to
 work. The gcd means the gcd regarding @var{f} and @var{g} as univariate 
 polynomials with coefficients being rational functions in the other 
 variables.

 @code{gcdex} implements the Euclidean algorithm, where we have a sequence of 
 @code{L[i]: [a[i], b[i], r[i]]} which are all perpendicular to 
 @code{[f, g, -1]} and the next one is built as if 
 @code{q = quotient(r[i]/r[i+1])} then @code{L[i+2]: L[i] - q L[i+1]}, and it
 terminates at @code{L[i+1]} when the remainder @code{r[i+2]} is zero.

Beispiel:

@c ===beg===
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];
@c ===end===
@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

   @c SORRY FOR BEING DENSE BUT WHAT IS THIS ABOUT EXACTLY
 Note that the gcd in the following is @code{1} since we work in 
 @code{k(y)[x]}, not the  @code{y+1} we would expect in @code{k[y, x]}.

@c ===beg===
@c gcdex (x*(y + 1), y^2 - 1, x);
@c ===end===
@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN 
@c INTEGERS ARE REFERENCED

@c -----------------------------------------------------------------------------
@anchor{gcfactor}
@deffn {Function} gcfactor (@var{n})

 Factors the Gaussian integer @var{n} over the Gaussian integers, i.e.,
 numbers of the form @code{@var{a} + @var{b} @code{%i}} where @var{a} and 
 @var{b} are rational integers (i.e.,  ordinary integers).  Factors are 
 normalized by making @var{a} and @var{b} non-negative.

@c NEED EXAMPLES HERE

@end deffn

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN 
@c INTEGERS ARE REFERENCED

@c -----------------------------------------------------------------------------
@deffn {Function} gfactor (@var{expr})

Factors the polynomial @var{expr} over the Gaussian integers
(that is, the integers with the imaginary unit @code{%i} adjoined).
@c "This is like" -- IS IT THE SAME OR NOT ??
This is like @code{factor (@var{expr}, @var{a}^2+1)} where @var{a} is @code{%i}.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK

@c -----------------------------------------------------------------------------
@deffn {Function} gfactorsum (@var{expr})

is similar to @code{factorsum} but applies @code{gfactor} instead
of @code{factor}.

@c @opencatbox
@c @category{Expressions}
@c @closecatbox
@end deffn

@deffn {Function} hipow (@var{expr}, @var{x})

Returns the highest explicit exponent of @var{x} in @var{expr}.
@var{x} may be a variable or a general expression.
If @var{x} does not appear in @var{expr},
@code{hipow} returns @code{0}.

@code{hipow} does not consider expressions equivalent to @code{expr}.
In particular, @code{hipow} does not expand @code{expr},
so @code{hipow (@var{expr}, @var{x})} and @code{hipow (expand (@var{expr}, @var{x}))}
may yield different results.

Examples:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@c @opencatbox
@c @category{Expressions}
@c @closecatbox
@end deffn

@c I SUSPECT THE FOLLOWING TEXT IS OUTDATED DUE TO CHANGES IN INTEGER FACTORING CODE

@c -----------------------------------------------------------------------------
@defvr {Option variable} intfaclim
Default value: true

If @code{true}, maxima will give up factorization of
integers if no factor is found after trial divisions and Pollard's rho
method and factorization will not be complete.

When @code{intfaclim} is @code{false} (this is the case when the user
calls @code{factor} explicitly), complete factorization will be
attempted.  @code{intfaclim} is set to @code{false} when factors are
computed in @code{divisors}, @code{divsum} and @code{totient}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Internal calls to @code{factor} respect the user-specified value of
@code{intfaclim}.  Setting @code{intfaclim} to @code{true} may reduce
the time spent factoring large integers.
@c NEED EXAMPLES HERE

@c @opencatbox
@c @category{Integers}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {Option variable} keepfloat
Default value: @code{false}

When @code{keepfloat} is @code{true}, prevents floating
point numbers from being rationalized when expressions which contain
them are converted to canonical rational expression (CRE) form.

Note that the function @code{solve} and those functions calling it 
(@code{eigenvalues}, for example) currently ignore this flag, converting 
floating point numbers anyway.

Examples:

@c ===beg===
@c rat(x/2.0);
@c rat(x/2.0), keepfloat;
@c ===end===
@example
(%i1) rat(x/2.0);

`rat' replaced 0.5 by 1/2 = 0.5
                                       x
(%o1)/R/                               -
                                       2
(%i2) rat(x/2.0), keepfloat;

(%o2)/R/                             0.5 x
@end example

@code{solve} ignores @code{keepfloat}:

@c ===beg===
@c solve(1.0-x,x), keepfloat;
@c ===end===
@example
(%i3) solve(1.0-x,x), keepfloat;

`rat' replaced 1.0 by 1/1 = 1.0
(%o3)                               [x = 1]
@end example

@c @opencatbox
@c @category{Numerical evaluation}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Funktion} lopow (@var{expr}, @var{x})

@c Returns the lowest exponent of @var{x} which explicitly appears in 
@c @var{expr}.  Thus

Gibt den kleinsten Exponenten von @var{x} zur@"uck, der im Ausdruck @var{expr}
auftritt.  Treten symbolische Exponententen auf, wird ein Ausdruck mit 
@code{min} zur@"uckgegeben.

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@c @opencatbox
@c @category{Ausdr@"ucke}
@c @closecatbox
@end deffn

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK

@c -----------------------------------------------------------------------------
@deffn {Function} lratsubst (@var{L}, @var{expr})

is analogous to @code{subst (@var{L}, @var{expr})}
except that it uses @code{ratsubst} instead of @code{subst}.

The first argument of
@code{lratsubst} is an equation or a list of equations identical in
format to that accepted by @code{subst}.  The
substitutions are made in the order given by the list of equations,
that is, from left to right.

@code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

Examples:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@c @opencatbox
@c @category{Polynomials} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} modulus
Default value: @code{false}

When @code{modulus} is a positive number @var{p},
operations on rational numbers (as returned by @code{rat} and related functions)
are carried out modulo @var{p},
using the so-called "balanced" modulus system
in which @code{@var{n} modulo @var{p}} is defined as 
an integer @var{k} in @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
when @var{p} is odd, or @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} when @var{p} is even,
such that @code{@var{a} @var{p} + @var{k}} equals @var{n} for some integer @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
@c "... in order to get correct results" -- WHAT DO YOU GET IF YOU DON'T RE-RAT ??
If @var{expr} is already in canonical rational expression (CRE) form when @code{modulus} is reset,
then you may need to re-rat @var{expr}, e.g., @code{expr: rat (ratdisrep (expr))},
in order to get correct results.

Typically @code{modulus} is set to a prime number.
If @code{modulus} is set to a positive non-prime integer,
this setting is accepted, but a warning message is displayed.
Maxima will allow zero or a negative integer to be assigned to @code{modulus},
although it is not clear if that has any useful consequences.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Integers}
@c @closecatbox
@end defvr

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT FUNCTION NMULTFACT
@c TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} is @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@c -----------------------------------------------------------------------------
@deffn {Function} num (@var{expr})

Returns the numerator of @var{expr} if it is a ratio.
If @var{expr} is not a ratio, @var{expr} is returned.

@code{num} evaluates its argument.

@c NEED SOME EXAMPLES HERE
@c @opencatbox
@c @category{Expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} partfrac (@var{expr}, @var{var})

Expands the expression @var{expr} in partial fractions
with respect to the main variable @var{var}.  @code{partfrac} does a complete
partial fraction decomposition.  The algorithm employed is based on
the fact that the denominators of the partial fraction expansion (the
factors of the original denominator) are relatively prime.  The
numerators can be written as linear combinations of denominators, and
the expansion falls out.

@example
(%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                      2       2        1
(%o1)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
(%i2) ratsimp (%);
                                 x
(%o2)                 - -------------------
                         3      2
                        x  + 4 x  + 5 x + 2
(%i3) partfrac (%, x);
                      2       2        1
(%o3)               ----- - ----- + --------
                    x + 2   x + 1          2
                                    (x + 1)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} polydecomp (@var{p}, @var{x})

Decomposes the polynomial @var{p} in the variable @var{x}
into the functional composition of polynomials in @var{x}.
@code{polydecomp} returns a list @code{[@var{p_1}, ..., @var{p_n}]} such that

@example
lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
  ...))
@end example

is equal to @var{p}.
The degree of @var{p_i} is greater than 1 for @var{i} less than @var{n}.

Such a decomposition is not unique.

Examples:

@c ===beg===
@c polydecomp (x^210, x);
@c p : expand (subst (x^3 - x - 1, x, x^2 - a));
@c polydecomp (p, x);
@c ===end===
@example
(%i1) polydecomp (x^210, x);
                          7   5   3   2
(%o1)                   [x , x , x , x ]
(%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                6      4      3    2
(%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
(%i3) polydecomp (p, x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

The following function composes @code{L = [e_1, ..., e_n]} as functions in @code{x};
it is the inverse of polydecomp:

@c ===beg===
@c compose (L, x) :=
@c   block ([r : x], for e in L do r : subst (e, x, r), r) $
@c ===end===
@example
compose (L, x) :=
  block ([r : x], for e in L do r : subst (e, x, r), r) $
@end example

Re-express above example using @code{compose}:

@c ===beg===
@c polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
@c ===end===
@example
(%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                        2       3
(%o3)                 [x  - a, x  - x - 1]
@end example

Note that though @code{compose (polydecomp (@var{p}, @var{x}), @var{x})}
always returns @var{p} (unexpanded),
@code{polydecomp (compose ([@var{p_1}, ..., @var{p_n}], @var{x}), @var{x})} does @i{not}
necessarily return @code{[@var{p_1}, ..., @var{p_n}]}:

@c ===beg===
@c polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
@c polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
@c ===end===
@example
(%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                          2       2
(%o4)                   [x  + 2, x  + 1]
(%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                      2       2
                     x  + 3  x  + 5
(%o5)               [------, ------, 2 x + 1]
                       4       2
@end example

@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Funktion} polymod (@var{p})
@deffnx {Function} polymod (@var{p}, @var{m})

@c Converts the polynomial @var{p} to a modular representation with respect to 
@c the current modulus which is the value of the variable @code{modulus}.

Konvertiert das Polynom @var{p} in eine modulare Darstellung bez@"uglich dem
aktuellen Modul.  Das Modul ist der Wert der Variablen @code{modulus}.

@c @code{polymod (@var{p}, @var{m})} specifies a modulus @var{m} to be used 
@c instead of the current value of @code{modulus}.

@code{polymod(@var{p}, @var{m}} konvertiert das Polynom bez@"uglich dem Modul 
@var{m}, anstatt dem aktuellen Modul @code{modulus}.

@c See @code{modulus}.

Siehe @code{modulus}.

@c @opencatbox
@c @category{Polynome}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} powers (@var{expr}, @var{x})
Gives the powers of @var{x} occuring in @var{expr}.

@code{load (powers)} loads this function.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@c @opencatbox
@c @category{Expressions} @category{Polynomials}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} quotient (@var{p_1}, @var{p_2})
@deffnx {Function} quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})

Returns the polynomial @var{p_1} divided by the polynomial @var{p_2}.
The arguments @var{x_1}, ..., @var{x_n} are interpreted as in @code{ratvars}.

@code{quotient} returns the first element of the two-element list returned by @code{divide}.

@c NEED SOME EXAMPLES HERE
@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c THIS ITEM CAN PROBABLY BE IMPROVED

@c -----------------------------------------------------------------------------
@deffn {Function} rat (@var{expr})
@deffnx {Function} rat (@var{expr}, @var{x_1}, ..., @var{x_n})

Converts @var{expr} to canonical rational expression (CRE) form by expanding and
combining all terms over a common denominator and cancelling out the
greatest common divisor of the numerator and denominator, as well as
converting floating point numbers to rational numbers within a
tolerance of @code{ratepsilon}.
The variables are ordered according
to the @var{x_1}, ..., @var{x_n}, if specified, as in @code{ratvars}.

@code{rat} does not generally simplify functions other than
addition @code{+}, subtraction @code{-}, multiplication @code{*}, division @code{/}, and
exponentiation to an integer power,
whereas @code{ratsimp} does handle those cases.
Note that atoms (numbers and variables) in CRE form are not the
same as they are in the general form.
For example, @code{rat(x)- x} yields 
@code{rat(0)} which has a different internal representation than 0.

@c WHAT'S THIS ABOUT EXACTLY ??
When @code{ratfac} is @code{true}, @code{rat} yields a partially factored form for CRE.
During rational operations the expression is
maintained as fully factored as possible without an actual call to the
factor package.  This should always save space and may save some time
in some computations.  The numerator and denominator are still made
relatively prime
(e.g.  @code{rat ((x^2 - 1)^4/(x + 1)^2)} yields @code{(x - 1)^4 (x + 1)^2)},
but the factors within each part may not be relatively prime.

@code{ratprint} if @code{false} suppresses the printout of the message
informing the user of the conversion of floating point numbers to
rational numbers.

@code{keepfloat} if @code{true} prevents floating point numbers from being
converted to rational numbers.

See also @code{ratexpand} and  @code{ratsimp}.

Examples:
@c ===beg===
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
@c       (4*y^2 + x^2);
@c rat (%, y, a, x);
@c ===end===
@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
      (4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratalgdenom
Default value: @code{true}

When @code{ratalgdenom} is @code{true}, allows rationalization of
denominators with respect to radicals to take effect.
@code{ratalgdenom} has an effect only when canonical rational expressions (CRE) are used in algebraic mode.

@c @opencatbox
@c @category{Simplification flags and variables}
@c @closecatbox
@end defvr

@c THIS ITEM NEEDS MORE WORK

@c -----------------------------------------------------------------------------
@deffn {Function} ratcoef (@var{expr}, @var{x}, @var{n})
@deffnx {Function} ratcoef (@var{expr}, @var{x})

Returns the coefficient of the expression @code{@var{x}^@var{n}}
in the expression @var{expr}.
If omitted, @var{n} is assumed to be 1.

The return value is free
(except possibly in a non-rational sense) of the variables in @var{x}.
If no coefficient of this type exists, 0 is returned.

@code{ratcoef}
expands and rationally simplifies its first argument and thus it may
produce answers different from those of @code{coeff} which is purely
syntactic.
@c MOVE THIS TO EXAMPLES SECTION
Thus @code{ratcoef ((x + 1)/y + x, x)} returns @code{(y + 1)/y} whereas @code{coeff} returns 1.

@code{ratcoef (@var{expr}, @var{x}, 0)}, viewing @var{expr} as a sum,
returns a sum of those terms which do not contain @var{x}.
@c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
Therefore if @var{x} occurs to any negative powers, @code{ratcoef} should not be used.

@c WHAT IS THE INTENT HERE ??
Since @var{expr} is rationally
simplified before it is examined, coefficients may not appear quite
the way they were envisioned.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@c @opencatbox
@c @category{Polynomials} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ratdenom (@var{expr})

Returns the denominator of @var{expr},
after coercing @var{expr} to a canonical rational expression (CRE).
The return value is a CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} is coerced to a CRE by @code{rat}
if it is not already a CRE.
This conversion may change the form of @var{expr} by putting all terms
over a common denominator.

@code{denom} is similar, but returns an ordinary expression instead of a CRE.
Also, @code{denom} does not attempt to place all terms over a common denominator,
and thus some expressions which are considered ratios by @code{ratdenom}
are not considered ratios by @code{denom}.

@c NEEDS AN EXAMPLE HERE
@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratdenomdivide
Default value: @code{true}

When @code{ratdenomdivide} is @code{true},
@code{ratexpand} expands a ratio in which the numerator is a sum 
into a sum of ratios,
all having a common denominator.
Otherwise, @code{ratexpand} collapses a sum of ratios into a single ratio,
the numerator of which is the sum of the numerators of each ratio.

Examples:

@example
(%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                            2
                           x  + x + 1
(%o1)                      ----------
                              2
                             y  + 7
(%i2) ratdenomdivide: true$
(%i3) ratexpand (expr);
                       2
                      x        x        1
(%o3)               ------ + ------ + ------
                     2        2        2
                    y  + 7   y  + 7   y  + 7
(%i4) ratdenomdivide: false$
(%i5) ratexpand (expr);
                            2
                           x  + x + 1
(%o5)                      ----------
                              2
                             y  + 7
(%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                     2
                           b        a
(%o6)                    ------ + ------
                          2        2
                         b  + 3   b  + 3
(%i7) ratexpand (expr2);
                                  2
                             b + a
(%o7)                        ------
                              2
                             b  + 3
@end example

@c @opencatbox
@c @category{Simplification flags and variables} @category{Rational expressions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} ratdiff (@var{expr}, @var{x})

Differentiates the rational expression @var{expr} with respect to @var{x}.
@var{expr} must be a ratio of polynomials or a polynomial in @var{x}.
The argument @var{x} may be a variable or a subexpression of @var{expr}.
@c NOT CLEAR (FROM READING CODE) HOW x OTHER THAN A VARIABLE IS HANDLED --
@c LOOKS LIKE (a+b), 10*(a+b), (a+b)^2 ARE ALL TREATED LIKE (a+b);
@c HOW TO DESCRIBE THAT ??

The result is equivalent to @code{diff}, although perhaps in a different form.
@code{ratdiff} may be faster than @code{diff}, for rational expressions.

@code{ratdiff} returns a canonical rational expression (CRE) if @code{expr} is a CRE.
Otherwise, @code{ratdiff} returns a general expression.

@code{ratdiff} considers only the dependence of @var{expr} on @var{x},
and ignores any dependencies established by @code{depends}.

@c WHAT THIS IS ABOUT -- ratdiff (rat (factor (expr)), x) AND ratdiff (factor (rat (expr)), x) BOTH SUCCEED
@c COMMENTING THIS OUT UNTIL SOMEONE CAN ESTABLISH SOME CRE'S FOR WHICH ratdiff FAILS
@c However, @code{ratdiff} should not be used on factored CRE forms;
@c use @code{diff} instead for such expressions.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c ratdiff (expr, x);
@c expr: f(x)^3 - f(x)^2 + 7;
@c ratdiff (expr, f(x));
@c expr: (a + b)^3 + (a + b)^2;
@c ratdiff (expr, a + b);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) ratdiff (expr, x);
                    7       5       4       2
                 8 x  + 40 x  - 55 x  - 60 x  - 50
(%o2)          - ---------------------------------
                          10       5
                         x   + 10 x  + 25
(%i3) expr: f(x)^3 - f(x)^2 + 7;
                         3       2
(%o3)                   f (x) - f (x) + 7
(%i4) ratdiff (expr, f(x));
                           2
(%o4)                   3 f (x) - 2 f(x)
(%i5) expr: (a + b)^3 + (a + b)^2;
                              3          2
(%o5)                  (b + a)  + (b + a)
(%i6) ratdiff (expr, a + b);
                    2                    2
(%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a
@end example

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ratdisrep (@var{expr})

Returns its argument as a general expression.
If @var{expr} is a general expression, it is returned unchanged.

Typically @code{ratdisrep} is called to convert a canonical rational expression (CRE)
into a general expression.
@c NOT REALLY FOND OF YOU-CAN-DO-THIS-YOU-CAN-DO-THAT STATEMENTS
This is sometimes convenient if one wishes to stop the "contagion", or
use rational functions in non-rational contexts.

See also @code{totaldisrep}.

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ratexpand (@var{expr})
@deffnx {Option variable} ratexpand

Expands @var{expr} by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
cancelling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.

The return value of @code{ratexpand} is a general expression,
even if @var{expr} is a canonical rational expression (CRE).

@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
The switch @code{ratexpand} if @code{true} will cause CRE
expressions to be fully expanded when they are converted back to
general form or displayed, while if it is @code{false} then they will be put
into a recursive form.
See also @code{ratsimp}.

When @code{ratdenomdivide} is @code{true},
@code{ratexpand} expands a ratio in which the numerator is a sum 
into a sum of ratios,
all having a common denominator.
Otherwise, @code{ratexpand} collapses a sum of ratios into a single ratio,
the numerator of which is the sum of the numerators of each ratio.

When @code{keepfloat} is @code{true}, prevents floating
point numbers from being rationalized when expressions which contain
them are converted to canonical rational expression (CRE) form.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratfac
Default value: @code{false}

When @code{ratfac} is @code{true},
canonical rational expressions (CRE) are manipulated in a partially factored form.

During rational operations the
expression is maintained as fully factored as possible without calling @code{factor}.
This should always save space and may save time in some computations.
The numerator and denominator are made relatively prime, for example
@code{rat ((x^2 - 1)^4/(x + 1)^2)} yields @code{(x - 1)^4 (x + 1)^2)},
but the factors within each part may not be relatively prime.

In the @code{ctensr} (Component Tensor Manipulation) package,
Ricci, Einstein, Riemann, and Weyl tensors and the scalar curvature 
are factored automatically when @code{ratfac} is @code{true}.
@i{@code{ratfac} should only be
set for cases where the tensorial components are known to consist of
few terms.}

The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} ratnumer (@var{expr})

Returns the numerator of @var{expr},
after coercing @var{expr} to a canonical rational expression (CRE).
The return value is a CRE.

@c ACTUALLY THE CONVERSION IS CARRIED OUT BY ratf BUT THAT'S WHAT $rat CALLS
@var{expr} is coerced to a CRE by @code{rat}
if it is not already a CRE.
This conversion may change the form of @var{expr} by putting all terms
over a common denominator.

@code{num} is similar, but returns an ordinary expression instead of a CRE.
Also, @code{num} does not attempt to place all terms over a common denominator,
and thus some expressions which are considered ratios by @code{ratnumer}
are not considered ratios by @code{num}.

@c NEEDS AN EXAMPLE HERE
@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ratnump (@var{expr})

Returns @code{true} if @var{expr} is a literal integer or ratio of literal integers,
otherwise @code{false}.

@c @opencatbox
@c @category{Predicate functions} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ratp (@var{expr})

Returns @code{true} if @var{expr} is a canonical rational expression (CRE) or extended CRE,
otherwise @code{false}.

CRE are created by @code{rat} and related functions.
Extended CRE are created by @code{taylor} and related functions.

@c @opencatbox
@c @category{Predicate functions} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratprint
Default value: @code{true}

When @code{ratprint} is @code{true},
a message informing the user of the conversion of floating point numbers
to rational numbers is displayed.

@c @opencatbox
@c @category{Rational expressions} @category{Numerical evaluation} @category{Console interaction}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} ratsimp (@var{expr})
@deffnx {Function} ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})

Simplifies the expression @var{expr} and all of its subexpressions,
including the arguments to non-rational functions.
The result is returned as the quotient of two polynomials in a recursive form,
that is, the coefficients of the main variable are polynomials in the other variables.
Variables may include non-rational functions (e.g., @code{sin (x^2 + 1)})
and the arguments to any such functions are also rationally simplified.

@code{ratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})}
enables rational simplification with the
specification of variable ordering as in @code{ratvars}.

When @code{ratsimpexpons} is @code{true},
@code{ratsimp} is applied to the exponents of expressions during simplification.

See also @code{ratexpand}.
Note that @code{ratsimp} is affected by some of the
flags which affect @code{ratexpand}.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@c @opencatbox
@c @category{Simplification functions} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratsimpexpons
Default value: @code{false}

When @code{ratsimpexpons} is @code{true},
@code{ratsimp} is applied to the exponents of expressions during simplification.

@c NEED AN EXAMPLE HERE -- RECYCLE THE ratsimpexpons EXAMPLE FROM ratsimp ABOVE
@c @opencatbox
@c @category{Simplification flags and variables} @category{Rational expressions}
@c @closecatbox
@end defvr

@c --- 06.01.2011 DK -----------------------------------------------------------
@anchor{radsubstflag}
@defvr {Optionsvariable} radsubstflag
Standardwert: @code{false}

@c @code{radsubstflag}, if @code{true}, permits @code{ratsubst} to make 
@c substitutions such as @code{u} for @code{sqrt (x)} in @code{x}.

Hat @code{radsubstflag} den Wert @code{true}, wird verhindert, dass die Funktion
@code{ratsubst} zum Beispiel @code{u} f@"ur @code{sqrt(x)} in @code{x} 
substituiert.

@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} ratsubst (@var{a}, @var{b}, @var{c})

Substitutes @var{a} for @var{b} in @var{c} and returns the resulting expression.
@c "ETC" SUGGESTS THE READER KNOWS WHAT ELSE GOES THERE -- NOT LIKELY THE CASE
@var{b} may be a sum, product, power, etc.

@c WHAT, EXACTLY, DOES ratsubst KNOW ??
@code{ratsubst} knows something of the meaning of expressions
whereas @code{subst} does a purely syntactic substitution.
Thus @code{subst (a, x + y, x + y + z)} returns @code{x + y + z}
whereas @code{ratsubst} returns @code{z + a}.

When @code{radsubstflag} is @code{true},
@code{ratsubst} makes substitutions for radicals in expressions
which don't explicitly contain them.

Examples:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c WITH SOME ADDITIONAL STUFF
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
@c radsubstflag: false$
@c ratsubst (u, sqrt(x), x);
@c radsubstflag: true$
@c ratsubst (u, sqrt(x), x);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
(%i5) radsubstflag: false$
(%i6) ratsubst (u, sqrt(x), x);
(%o6)                           x
(%i7) radsubstflag: true$
(%i8) ratsubst (u, sqrt(x), x);
                                2
(%o8)                          u
@end example

@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Function} ratvars (@var{x_1}, ..., @var{x_n})
@deffnx {Function} ratvars ()
@deffnx {System variable} ratvars

Declares main variables @var{x_1}, ..., @var{x_n} for rational expressions.
@var{x_n}, if present in a rational expression, is considered the main variable.
Otherwise, @var{x_[n-1]} is considered the main variable if present,
and so on through the preceding variables to @var{x_1},
which is considered the main variable only if none of the succeeding variables are present.

If a variable in a rational expression is not present in the @code{ratvars} list,
it is given a lower priority than @var{x_1}.

The arguments to @code{ratvars} can be either variables or non-rational functions
such as @code{sin(x)}.

The variable @code{ratvars} is a list of the arguments of 
the function @code{ratvars} when it was called most recently.
Each call to the function @code{ratvars} resets the list.
@code{ratvars ()} clears the list.

@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Function} ratweight (@var{x_1}, @var{w_1}, ..., @var{x_n}, @var{w_n})
@deffnx {Function} ratweight ()

Assigns a weight @var{w_i} to the variable @var{x_i}.
This causes a term to be replaced by 0 if its weight exceeds the
value of the variable @code{ratwtlvl} (default yields no truncation).
The weight of a term is the sum of the products of the
weight of a variable in the term times its power.
For example, the weight of @code{3 x_1^2 x_2} is @code{2 w_1 + w_2}.
Truncation according to @code{ratwtlvl} is carried out only when multiplying
or exponentiating canonical rational expressions (CRE).

@code{ratweight ()} returns the cumulative list of weight assignments.

Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} ratweights
Default value: @code{[]}

@code{ratweights} is the list of weights assigned by @code{ratweight}.
The list is cumulative:
each call to @code{ratweight} places additional items in the list.

@c DO WE REALLY NEED TO MENTION THIS ??
@code{kill (ratweights)} and @code{save (ratweights)} both work as expected.

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {Option variable} ratwtlvl
Default value: @code{false}

@code{ratwtlvl} is used in combination with the @code{ratweight}
function to control the truncation of canonical rational expressions (CRE).
For the default value of @code{false}, no truncation occurs.

@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} remainder (@var{p_1}, @var{p_2})
@deffnx {Function} remainder (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})

Returns the remainder of the polynomial @var{p_1} divided by the polynomial @var{p_2}.
The arguments @var{x_1}, ..., @var{x_n} are interpreted as in @code{ratvars}.

@code{remainder} returns the second element
of the two-element list returned by @code{divide}.

@c NEED SOME EXAMPLES HERE
@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c CAN PROBABLY BE CLARIFIED

@c -----------------------------------------------------------------------------
@deffn  {Function} resultant (@var{p_1}, @var{p_2}, @var{x})
@deffnx {Variable} resultant

Computes the resultant of the two polynomials @var{p_1} and @var{p_2},
eliminating the variable @var{x}.
The resultant is a determinant of the coefficients of @var{x}
in @var{p_1} and @var{p_2},
which equals zero
if and only if @var{p_1} and @var{p_2} have a non-constant factor in common.

If @var{p_1} or @var{p_2} can be factored,
it may be desirable to call @code{factor} before calling @code{resultant}.

The variable @code{resultant} controls which algorithm will be used to compute
the resultant.
@c WHAT DOES THE FOLLOWING MEAN EXACTLY ??
@code{subres} for subresultant prs,
@code{mod} for modular resultant algorithm,
and @code{red} for reduced prs.
On most problems @code{subres} should be best.
On some large degree univariate or bivariate problems @code{mod} may be better.

The function @code{bezout} takes the same arguments as @code{resultant} and returns
a matrix.  The determinant of the return value is the desired resultant.

@c NEED AN EXAMPLE HERE
@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} savefactors
Default value: @code{false}

@c "certain functions" -- WHICH ONES ??
When @code{savefactors} is @code{true}, causes the factors of an
expression which is a product of factors to be saved by certain
functions in order to speed up later factorizations of expressions
containing some of the same factors.

@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end defvr

@c --- 28.08.2010 DK -----------------------------------------------------------
@deffn {Function} showratvars (@var{expr})

Returns a list of the canonical rational expression (CRE) variables in 
expression @code{expr}.

See also @code{ratvars}.

@c @opencatbox
@c @category{Rational expressions} @category{Display functions}
@c @closecatbox
@end deffn

@c I CAN'T TELL WHAT THIS IS SUPPOSED TO BE ABOUT

@c -----------------------------------------------------------------------------
@deffn {Function} sqfr (@var{expr})

is similar to @code{factor} except that the polynomial factors are "square-free."
That is, they have factors only of degree one.
This algorithm, which is also used by the first stage of @code{factor}, utilizes
the fact that a polynomial has in common with its n'th derivative all
its factors of degree greater than n.  Thus by taking greatest common divisors
with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree greater than 1 can be found.

Example:
@c FOLLOWING GENERATED FROM THIS EXPRESSION
@c sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example

@c @opencatbox
@c @category{Polynomials}
@c @closecatbox
@end deffn

@c THIS ITEM STILL NEEDS WORK

@c --- 20.12.2010 DK -----------------------------------------------------------
@anchor{tellrat}
@deffn  {Funktion} tellrat (@var{p_1}, ..., @var{p_n})
@deffnx {Funktion} tellrat ()

 Adds to the ring of algebraic integers known to Maxima the elements which are 
 the solutions of the polynomials @var{p_1}, ..., @var{p_n}. Each argument 
 @var{p_i} is a polynomial with integer coefficients.

 @code{tellrat (@var{x})} effectively means substitute 0 for @var{x} in 
 rational functions.

 @code{tellrat ()} returns a list of the current substitutions.

 @code{algebraic} must be set to @code{true} in order for the simplification 
 of algebraic integers to take effect.

 Maxima initially knows about the imaginary unit @code{%i} and all roots of 
 integers.

 There is a command @code{untellrat} which takes kernels and removes 
 @code{tellrat} properties.

 When @code{tellrat}'ing a multivariate polynomial, e.g., 
 @code{tellrat (x^2 - y^2)}, there would be an ambiguity as to whether to 
 substitute @code{@var{y}^2} for @code{@var{x}^2} or vice versa. Maxima 
 picks a particular ordering, but if the user wants to specify which, e.g.
 @code{tellrat (y^2 = x^2)} provides a syntax which says replace
 @code{@var{y}^2} by @code{@var{x}^2}.


@c CAN'T TELL WHAT THIS IS ABOUT -- 
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w));
@c DOES NOT YIELD AN ERROR, SO WHAT IS THE POINT ABOUT ratalgdenom ??
@c When you @code{tellrat} reducible polynomials, you want to be careful not to
@c attempt to rationalize a denominator with a zero divisor.  E.g.
@c tellrat(w^3-1)$ algebraic:true$ rat(1/(w^2-w)); will give "quotient by
@c zero".  This error can be avoided by setting @code{ratalgdenom} to 
@c @code{false}.

Beispiele:

@c ===beg===
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);
@c ===end===
@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@c @opencatbox
@c @category{Polynomials} @category{Rational expressions}
@c @closecatbox
@end deffn

@c --- 20.10.2010 DK -----------------------------------------------------------
@anchor{totaldisrep}
@deffn {Funktion} totaldisrep (@var{expr})

@c Converts every subexpression of @var{expr} from canonical rational 
@c expressions (CRE) to general form and returns the result. If @var{expr} is 
@c itself in CRE form then @code{totaldisrep} is identical to @code{ratdisrep}.

Konvertiert alle Teilausdr@"ucke im Ausdruck @var{expr} von der CRE-Form in die
allgemeine Form und gibt das Ergebnis zur@"uck. Ist @var{expr} selbst eine
CRE-Form, dann entspricht @code{totaldisrep} der Funktion @code{ratdisrep}.

@c @code{totaldisrep} may be useful for ratdisrepping expressions such as 
@c equations, lists, matrices, etc., which have some subexpressions in CRE form.

@code{totaldisrep} ist insbesondere hilfreich, wenn Gleichungen, Listen oder
Matrizen in eine allgmeine Form zu konvertieren sind.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Rational expressions}
@c @closecatbox
@end deffn

@c --- 20.12.2010 DK -----------------------------------------------------------
@anchor{untellrat}
@deffn {Funktion} untellrat (@var{x_1}, ..., @var{x_n})

@c Removes @code{tellrat} properties from @var{x_1}, ..., @var{x_n}.

Entfernt Eigenschaften von den Symbolen @var{x_1}, ..., @var{x_n}, die mit der
Funktion @code{tellrat} zugewiesen wurden.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Polynomials} @category{Rational expressions}
@c @closecatbox
@end deffn

@c --- End of file Polynomials.de.texi -----------------------------------------

