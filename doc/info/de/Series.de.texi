@c -----------------------------------------------------------------------------
@c File        : Series.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Translation : Dr. Dieter Kaiser
@c Date        : 05.11.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Summen und Produkte::
* Einf@"uhrung in Reihen::
* Funktionen und Variablen f@"ur Reihen::
* Poisson Reihen::
* Kettenbr@"uche::
@end menu

@c -----------------------------------------------------------------------------
@node Summen und Produkte, Einf@"uhrung in Reihen, Summen Produkte und Reihen, Summen Produkte und Reihen
@section Summen und Produkte

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{bashindices}
@deffn {Funktion} bashindices (@var{expr})

@c Transforms the expression @var{expr} by giving each summation and product a
@c unique index. This gives @code{changevar} greater precision when it is 
@c working with summations or products.  The form of the unique index is 
@c @code{j@var{number}}. The quantity @var{number} is determined by referring to 
@c @code{gensumnum}, which can be changed by the user. For example, 
@c @code{gensumnum:0$} resets it.

Transformiert einen Ausdruck @var{expr} der mehrere Summen oder Produkte
enth@"alt so, dass alle Summen und Produkte einen unterschiedlichen Index haben.
Dies erleichtert Substitutionen wie zum Beispiel mit @code{changevar}.
Die neuen Indizes lauten @code{j@var{nummer}}. Die Zahl @var{nummer} ist der
Wert der Optionsvariablen @code{gensumnum}. Siehe @mrefdot{gensumnum}

Beispiel:

@c ===beg===
@c sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
@c bashindices(%);
@c ===end===
@example
(%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                       inf       inf
                       ====      ====
                       \     1   \     1
(%o1)                   >    - +  >    --
                       /     k   /      2
                       ====      ====  k
                       k = 0     k = 0
(%i2) bashindices(%);
                     inf         inf
                     ====        ====
                     \      1    \       1
(%o2)                 >     -- +  >     ---
                     /      j2   /        2
                     ====        ====   j1
                     j2 = 0      j1 = 0
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{cauchysum}
@defvr {Optionsvariable} cauchysum
Standardwert: @code{false}

@c When multiplying together sums with @code{inf} as their upper limit, if 
@c @code{sumexpand} is @code{true} and @code{cauchysum} is @code{true} then the 
@c Cauchy product will be used rather than the usual product. In the Cauchy 
@c product the index of the inner summation is a function of the index of the 
@c outer one rather than varying independently.

Werden zwei unendliche Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @code{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

Beispiele:

@c ===beg===
@c sumexpand: false$
@c cauchysum: false$
@c s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
@c sumexpand: true$
@c cauchysum: true$
@c ''s;
@c ===end===
@example
(%i1) sumexpand: false$
(%i2) cauchysum: false$
(%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                      inf         inf
                      ====        ====
                      \           \
(%o3)                ( >    f(i))  >    g(j)
                      /           /
                      ====        ====
                      i = 0       j = 0
(%i4) sumexpand: true$
(%i5) cauchysum: true$
(%i6) ''s;
                 inf     i1
                 ====   ====
                 \      \
(%o6)             >      >     g(i1 - i2) f(i2)
                 /      /
                 ====   ====
                 i1 = 0 i2 = 0
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{genindex}
@defvr {Optionsvariable} genindex
Standardwert: @code{i}

@c @code{genindex} is the alphabetic prefix used to generate the next variable 
@c of summation when necessary.

@code{genindex} enth@"alt das Zeichen f@"ur den Pr@"afix, um einen neuen Index
f@"ur eine Summe oder ein Produkt zu generieren.

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{gensumnum}
@defvr {Optionsvariable} gensumnum
Standardwert: 0

@c @code{gensumnum} is the numeric suffix used to generate the next variable
@c of summation.  If it is set to @code{false} then the index will consist only
@c of @code{genindex} with no numeric suffix.

@code{gensumnum} enth@"alt die Nummer, die an den Pr@"afix angeh@"angt wird, um 
den n@"achsten Index f@"ur eine Summe oder ein Produkt zu generieren. Hat 
@code{gensumnum} den Wert @code{false}, wird der Index nur aus dem Zeichen
@code{genindex} gebildet.

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{intosum}
@deffn {Funktion} intosum (@var{expr})

@c Moves multiplicative factors outside a summation to inside. If the index is 
@c used in the outside expression, then the function tries to find a reasonable
@c index, the same as it does for @code{sumcontract}.  This is essentially the
@c reverse idea of the @code{outative} property of summations, but note that it
@c does not remove this property, it only bypasses it.

Multipliziert Faktoren in eine Summe herein. Tritt der Index der Summe 
au@ss{}erhalb der Summe auf, wird von der Funktion @code{intosum} ein neuer 
Index gesucht. Summen haben die Eigenschaft @mrefcomma{outative} so dass 
Faktoren aus der Summe herausgezogen werden. Mit der Funktion @code{intosum} 
wird diese Vereinfachung r@"uckg@"angig gemacht.

@c In some cases, a @code{scanmap (multthru, @var{expr})} may be necessary 
@c before the @code{intosum}.

@c TODO: WAS SIND DAS FUER FAELLE ?

In einigen F@"allen kann die Vereinfachung @code{scanmap(multthru, @var{expr})} 
vor einem Aufruf von @code{intosum} notwendig sein.

Beispiel:

@c ===beg===
@c sum(2*x^2*n^k, k , 0, inf);
@c intosum(%);
@c ===end===
@example
@group
(%i1) sum(2*x^2*n^k, k , 0, inf);
                               inf
                               ====
                             2 \      k
(%o1)                     2 x   >    n
                               /
                               ====
                               k = 0
@end group
@group
(%i2) intosum(%);
                          inf
                          ====
                          \        k  2
(%o2)                      >    2 n  x
                          /
                          ====
                          k = 0
@end group
@end example

@c @opencatbox
@c @category{Ausdr@"ucke}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{lsum}
@deffn {Funktion} lsum (@var{expr}, @var{i}, @var{L})

@c Represents the sum of @var{expr} for each element @var{x} in @var{L}.
@c A noun form @code{'lsum} is returned if the argument @var{L} does not 
@c evaluate to a list.

Bildet die Summe f@"ur den Ausdruck @var{expr}. @var{i} ist der Index, dessen
Elemente in der Liste @var{L} aufgez@"ahlt sind. Kann das Argument @var{L} nicht
zu einer Liste ausgewertet werden, wird eine Substantivform zur@"uckgegeben.

Beispiele:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1)
@end example

@c @opencatbox
@c @category{Summen und Produkte}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{niceindices}
@deffn {Funktion} niceindices (@var{expr})

@c Renames the indices of sums and products in @var{expr}. @code{niceindices} 
@c attempts to rename each index to the value of @code{niceindicespref[1]},
@c unless that name appears in the summand or multiplicand, in which case 
@c @code{niceindices} tries the succeeding elements of @code{niceindicespref} 
@c in turn, until an unused variable is found. If the entire list is exhausted,
@c additional indices are constructed by appending integers to the value of
@c @code{niceindicespref[1]}, e.g., @code{i0}, @code{i1}, @code{i2}, ....

Gibt den Indizes von Summen und Produkten im Ausdruck @var{expr} einen neuen
Namen. @code{niceindices} benennt die Indizes nacheinander mit den Namen, die
in der Liste der Optionsvariablen @mref{niceindicespref} enthalten sind. Die 
Standardnamen sind @code{[i, j, k, l, m, n]}. Sind nicht gen@"ugend Namen in 
der Liste vorhanden, werden weitere Indizes durch anh@"angen einer Nummer 
gebildet.

@c @code{niceindices} returns an expression @code{niceindices} evaluates 
@c its argument.

@code{niceindices} wertet sein Argument aus.

Beispiele:

@c ===beg===
@c niceindicespref;
@c product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
@c niceindices (%);
@c ===end===
@example
(%i1) niceindicespref;
(%o1)                  [i, j, k, l, m, n]
@group
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
@end group
@group
(%i3) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j l + k)
                     ! !  /
                    l = 1 ====
                          k = 1
@end group
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{niceindicespref}
@defvr {Optionsvariable} niceindicespref
Standardwert: @code{[i, j, k, l, m, n]}

@c @code{niceindicespref} is the list from which @code{niceindices}
@c takes the names of indices for sums and products.
@c The elements of @code{niceindicespref} are typically names of variables,
@c although that is not enforced by @code{niceindices}.

@code{niceindicespref} ist die Liste der Namen, die die Funktion 
@mref{niceindices} nutzt, um die Indizes von Summen und Produkte umzubennen.

Beispiele:

@c ===beg===
@c niceindicespref: [p, q, r, s, t, u]$
@c product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
@c niceindices (%);
@c ===end===
@example
(%i1) niceindicespref: [p, q, r, s, t, u]$
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
(%i3) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j q + p)
                     ! !  /
                    q = 1 ====
                          p = 1
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{nusum}
@deffn {Funktion} nusum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Carries out indefinite hypergeometric summation of @var{expr} with
@c respect to @var{x} using a decision procedure due to R.W. Gosper.
@c @var{expr} and the result must be expressible as products of integer powers,
@c factorials, binomials, and rational functions.

Wendet den Gosper-Algorithmus der unbestimmten Summation f@"ur den Ausdruck 
@var{expr} und dem Index @var{i} an. Der Index @var{i} l@"auft von @var{i_0} 
bis @var{i_1}. Der Ausdruck @var{expr} und das Ergebnis der Summation m@"ussen 
als Produkte von ganzzahligen Exponentiationen, Fakult@"aten, Binomialen und
rationalen Funktionen ausdr@"uckbar sein.

@c UMM, DO WE REALLY NEED TO DEFINE "DEFINITE" AND "INDEFINITE" SUMMATION HERE??
@c (CAN'T WE MAKE THE POINT WITHOUT DRAGGING IN SOME NONSTANDARD TERMINOLOGY ??)

@c The terms "definite" and "indefinite summation" are used analogously to 
@c "definite" and "indefinite integration". To sum indefinitely means to give a
@c symbolic result for the sum over intervals of variable length, not just e.g. 
@c 0 to inf.  Thus, since there is no formula for the general partial sum of
@c the binomial series, @code{nusum} can't do it.

@c @code{nusum} and @code{unsum} know a little about sums and differences of 
@c finite products. See also @code{unsum}.

@code{nusum} und @code{unsum} kennen einige f@"ur Summen und Differenzen von 
endlichen Produkten. Siehe auch @mrefdot{unsum}

Beispiele:

@c ===beg===
@c nusum (n*n!, n, 0, n);
@c nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
@c unsum (%, n);
@c unsum (prod (i^2, i, 1, n), n);
@c nusum (%, n, 1, n);
@c ===end===
@example
(%i1) nusum (n*n!, n, 0, n);

Dependent equations eliminated:  (1)
(%o1)                     (n + 1)! - 1
(%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o2) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i3) unsum (%, n);
                              4  n
                             n  4
(%o3)                   ----------------
                        binomial(2 n, n)
@group
(%i4) unsum (prod (i^2, i, 1, n), n);
                    n - 1
                    /===\
                     ! !   2
(%o4)              ( ! !  i ) (n - 1) (n + 1)
                     ! !
                    i = 1
@end group
(%i5) nusum (%, n, 1, n);

Dependent equations eliminated:  (2 3)
                            n
                          /===\
                           ! !   2
(%o5)                      ! !  i  - 1
                           ! !
                          i = 1
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{product}
@deffn {Funktion} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Represents a product of the values of @var{expr} as the index @var{i} varies 
@c from @var{i_0} to @var{i_1}. The noun form @code{'product} is displayed as 
@c an uppercase letter pi.

Bildet das Produkt des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}. Die Substantivform @code{'product} wird mit einem 
gro@ss{}geschriebenen Buchstaben Pi dargestellt.

@c @code{product} evaluates @var{expr} and lower and upper limits @var{i_0} and 
@c @var{i_1}, @code{product} quotes (does not evaluate) the index @var{i}.

@code{product} wertet @var{expr} sowie die untere @var{i_0} und obere Grenze
@var{i_1} aus. Der Index @var{i} wird nicht ausgewertet.

@c If the upper and lower limits differ by an integer, @var{expr} is evaluated 
@c for each value of the index @var{i}, and the result is an explicit product.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet. Das Ergebnis ist ein explizites
Produkt.

@c Otherwise, the range of the index is indefinite. Some rules are applied to 
@c simplify the product. When the global variable @code{simpproduct} is 
@c @code{true}, additional rules are applied. In some cases, simplification 
@c yields a result which is not a product; otherwise, the result is a noun form 
@c @code{'product}.

Andernfalls ist der Bereich des Index unbestimmt. Maxima wendet einige einfache
Regeln an, um das Produkt zu vereinfachen. Hat die Optionsvariable 
@mref{simpproduct} den Wert @code{true}, wendet Maxima weitere Regeln an, um
Produkte zu vereinfachen. 

@c See also @code{nouns} and @code{evflag}.

Siehe auch @mref{nouns} und @mrefdot{evflag}

Beispiele:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===
@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@c @opencatbox
@c @category{Summen und Produkte}
@c @closecatbox
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{simpproduct}
@defvr {Optionsvariable} simpproduct
Standardwert: @code{false}

Hat @code{simpproduct} den Wert @code{true}, versucht Maxima ein Produkt weiter 
zu vereinfachen. Die Vereinfachung kann eine geschlossene Form liefern. Hat
@code{simpproduct} den Wert @code{false} oder wird das Produkt in der
Substantivform @code{'product} definiert, werden nur einige einfache Regeln von
Maxima f@"ur die Vereinfachung angewendet.

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN. Z. B. OUTATIVE?
@c TODO: IST IM ENGLISCHEN MANUAL NICHT DOKUMENTIERT.

@c @opencatbox
@c @category{Summen und Produkte} @category{Vereinfachungsflags und Variablen}
@c @closecatbox
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{simpsum}
@defvr {Optionsvariable} simpsum
Standardwert: @code{false}

@c When @code{simpsum} is @code{true}, the result of a @code{sum} is simplified.
@c This simplification may sometimes be able to produce a closed form. If 
@c @code{simpsum} is @code{false} or if the quoted form @code{'sum} is used, the
@c value is a sum noun form which is a representation of the sigma notation used
@c in mathematics.

Hat @code{simpsum} den Wert @code{true}, versucht Maxima eine Summe oder Reihe 
weiter zu vereinfachen. Die Vereinfachung kann eine geschlossene Form liefern. 
Hat @code{simpsum} den Wert @code{false} oder die Summe oder Reihe in der
Substantivform @code{'sum} definiert, werden nur einige einfache Regeln von
Maxima f@"ur die Vereinfachung angewendet.

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN. Z. B. OUTATIVE?

@c @opencatbox
@c @category{Summen und Produkte} @category{Vereinfachungsflags und Variablen}
@c @closecatbox
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{sum}
@deffn {Funktion} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Represents a summation of the values of @var{expr} as the index @var{i} 
@c varies from @var{i_0} to @var{i_1}. The noun form @code{'sum} is displayed as
@c an uppercase letter sigma.

Bildet die Summe des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}. Die Substantivform @code{'sum} wird mit einem 
gro@ss{}geschriebenen Buchstaben Sigma dargestellt.

@c @code{sum} evaluates its summand @var{expr} and lower and upper limits 
@c @var{i_0} and @var{i_1}, @code{sum} quotes (does not evaluate) the index 
@c @var{i}.

@code{sum} wertet @var{expr} sowie die untere @var{i_0} und obere Grenze
@var{i_1} aus. Der Index @var{i} wird nicht ausgewertet.

@c If the upper and lower limits differ by an integer, the summand @var{expr} 
@c is evaluated for each value of the summation index @var{i}, and the result 
@c is an explicit sum.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet. Das Ergebnis ist eine explizite
Summe.

@c Otherwise, the range of the index is indefinite. Some rules are applied to 
@c simplify the summation. When the global variable @code{simpsum} is 
@c @code{true}, additional rules are applied. In some cases, simplification 
@c yields a result which is not a summation; otherwise, the result is a noun 
@c form @code{'sum}.

Andernfalls ist der Bereich des Index unbestimmt. Maxima wendet einige einfache
Regeln an, um die Summe zu vereinfachen. Hat die Optionsvariable 
@mref{simpsum} den Wert @code{true}, wendet Maxima weitere Regeln an, um Summen
zu vereinfachen.

@c When the @code{evflag} (evaluation flag) @code{cauchysum} is @code{true},
@c a product of summations is expressed as a Cauchy product, in which the index 
@c of the inner summation is a function of the index of the outer one, rather 
@c than varying independently.

Werden zwei unendliche Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @code{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

@c The global variable @code{genindex} is the alphabetic prefix used to generate
@c the next index of summation, when an automatically generated index is needed.

Die Optionsvariable @mref{genindex} enth@"alt das Zeichen, das der Pr@"afix 
eines automatisch generierten Index ist.

@c @code{gensumnum} is the numeric suffix used to generate the next index of 
@c summation, when an automatically generated index is needed. When 
@c @code{gensumnum} is @code{false}, an automatically-generated index is only
@c @code{genindex} with no numeric suffix.

@code{gensumnum} enth@"alt eine ganze Zahl, die an den Pr@"afix @code{genindex}
angeh@"angt wird, um einen automatischen Index zu generieren. @code{gensumnum}
wird von Maxima automatisch erh@"oht. Hat @code{gensumnum} den Wert 
@code{false}, wird keine Zahl an den Pr@"afix angeh@"angt.

@c See also @code{sumcontract}, @code{intosum}, @code{bashindices}, 
@c @code{niceindices}, @code{nouns}, @code{evflag}, and @code{zeilberger}. 

Siehe auch @mrefcomma{sumcontract}  @mrefcomma{sumexpand} @mrefcomma{intosum}@ 
@mrefcomma{bashindices} @mrefcomma{niceindices} @mrefcomma{nouns}@  
@mrefcomma{evflag} @mref{cauchysum} und @mrefdot{zeilberger}

Beispiele:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===
@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
@group
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
@end group
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
@group
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
@end group
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example

@c @opencatbox
@c @category{Summen und Produkte}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sumcontract}
@deffn {Funktion} sumcontract (@var{expr})

@c TODO: UEBERSETZUNG FEHLT

Combines all sums of an addition that have upper and lower bounds that differ
by constants. The result is an expression containing one summation for each 
set of such summations added to all appropriate extra terms that had to be 
extracted to form this sum. @code{sumcontract} combines all compatible sums 
and uses one of the indices from one of the sums if it can, and then try to 
form a reasonable index if it cannot use any supplied.

@c Alle Summen einer Addition deren obere und untere Grenze sich nur eine 
@c Konstante unterscheiden werden zusammengezogen. Das Ergebnis ist ein Ausdruck
@c der eine Summe .... (wie wird das @"ubersetzt) ...

@c WHEN IS intosum NECESSARY BEFORE sumcontract ??

It may be necessary to do an @code{intosum (@var{expr})} before the 
@code{sumcontract}.

@c Es kann notwendig sein zun@"achst @code{intosum(@var{expr})} auszuf@"uhren.

@c @opencatbox
@c @category{Summen und Produkte}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sumexpand}
@defvr {Optionsvariable} sumexpand
Standardwert: @code{false}

@c When @code{sumexpand} is @code{true}, products of sums and
@c exponentiated sums simplify to nested sums.
@c See also @code{cauchysum}.

Hat die Optionsvariable @code{sumexpand} den Wert @code{true}, werden Produkte
von Summen und Potenzen von Summen zu verschachtelten Summen vereinfacht. Siehe
auch @mrefdot{cauchysum}

Beispiele:

@c ===beg===
@c sumexpand: true$
@c sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
@c sum (f (i), i, 0, m)^2;
@c ===end===
@example
(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                >      >     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                >      >     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
@end example

@c @opencatbox
@c @category{Sums and products} @category{Simplification flags and variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{unsum}
@deffn {Funktion} unsum (@var{f}, @var{n})

@c TODO: UEBERESETZUNG FEHLT

Returns the first backward difference @code{@var{f}(@var{n}) - 
@var{f}(@var{n} - 1)}. Thus @code{unsum} in a sense is the inverse of 
@code{sum}. See also @code{nusum}.

Beispiele:

@c ===beg===
@c g(p) := p*4^n/binomial(2*n,n);
@c g(n^4);
@c nusum (%, n, 0, n);
@c unsum (%, n);
@c ===end===
@example
(%i1) g(p) := p*4^n/binomial(2*n,n);
                                     n
                                  p 4
(%o1)               g(p) := ----------------
                            binomial(2 n, n)
@group
(%i2) g(n^4);
                              4  n
                             n  4
(%o2)                   ----------------
                        binomial(2 n, n)
@end group
(%i3) nusum (%, n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o3) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i4) unsum (%, n);
                              4  n
                             n  4
(%o4)                   ----------------
                        binomial(2 n, n)
@end example

@c @opencatbox
@c @category{Sums and products}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Reihen, Funktionen und Variablen f@"ur Reihen, Summen und Produkte, Summen Produkte und Reihen
@section Einf@"uhrung in Reihen

@c Maxima contains functions @code{taylor} and @code{powerseries} for finding 
@c the series of differentiable functions. It also has tools such as 
@c @code{nusum} capable of finding the closed form of some series. Operations 
@c such as addition and multiplication work as usual on series. This section 
@c presents the global variables which control the expansion.

Maxima hat die Funktionen @code{taylor} und @code{powerseries}, um die 
Reihenentwicklung von differenzierbaren Funktionen zu finden. Maxima hat
weiterhin Funktionen wie @code{nusum}, um geschlossene Formen von Reihen zu
finden. Operationen wie die Addition und Multiplikation arbeiten wie gewohnt
f@"ur Reihen. Das folgende Kapitel stellt die Variablen und Funktionen f@"ur 
eine Reihenentwicklung dar.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Reihen, Poisson Reihen, Einf@"uhrung in Reihen, Summen Produkte und Reihen
@section Funktionen und Variablen f@"ur Reihen

@c -----------------------------------------------------------------------------
@anchor{deftaylor}
@deffn {Funktion} deftaylor (@var{f_1}(@var{x_1}), @var{expr_1}, ..., @var{f_n}(@var{x_n}), @var{expr_n})

@c For each function @var{f_i} of one variable @var{x_i}, @code{deftaylor} 
@c defines @var{expr_i} as the Taylor series about zero. @var{expr_i} is 
@c typically a polynomial in @var{x_i} or a summation; more general expressions
@c are accepted by @code{deftaylor} without complaint.

F@"ur eine Funktion @var{f_i} einer Variablen @var{x_i} definiert 
@code{deftaylor} den Ausdruck @var{expr_i} als die Taylorreihe um den Nullpunkt.
@var{expr_i} ist typischerweise ein Polynom in der Variable @var{x_i} oder eine 
Summe. @code{deftaylor} aktzeptiert aber auch allgemeinere Ausdr@"ucke.

@c @code{powerseries(@var{f_i}(@var{x_i}), @var{x_i}, 0)}
@c returns the series defined by @code{deftaylor}.

@code{powerseries(@var{f_i}(@var{x_i}), @var{x_i}, 0)} gibt die Reihe zur@"uck, 
die mit @code{deftaylor} definiert wurde.

@c @code{deftaylor} returns a list of the functions @var{f_1}, ..., @var{f_n}.
@c @code{deftaylor} evaluates its arguments.

@code{deftaylor} gibt eine Liste der Funktionen @var{f_1}, ..., @var{f_n}.
@code{deftaylor} wertet seine Argumente aus.

Beispiele:

@c ===beg===
@c deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
@c powerseries (f(x), x, 0);
@c taylor (exp (sqrt (f(x))), x, 0, 4);
@c ===end===
@example
(%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
(%o1)                          [f]
(%i2) powerseries (f(x), x, 0);
                      inf
                      ====      i1
                      \        x         2
(%o2)                  >     -------- + x
                      /       i1    2
                      ====   2   i1!
                      i1 = 4
(%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                      2         3          4
                     x    3073 x    12817 x
(%o3)/T/     1 + x + -- + ------- + -------- + . . .
                     2     18432     307200
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{maytayorder}
@defvr {Option variable} maxtayorder
Default value: @code{true}

@c REPHRASE
When @code{maxtayorder} is @code{true}, then during algebraic manipulation of 
(truncated) Taylor series, @code{taylor} tries to retain as many terms as are 
known to be correct.

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end defvr

@c THIS ITEM NEEDS SERIOUS WORK

@c -----------------------------------------------------------------------------
@anchor{pade}
@deffn {Function} pade (@var{taylor_series}, @var{numer_deg_bound}, @var{denom_deg_bound})

Returns a list of all rational functions which have the given Taylor series 
expansion where the sum of the degrees of the numerator and the denominator is
less than or equal to the truncation level of the power series, i.e. are "best"
approximants, and which additionally satisfy the specified degree bounds.

@var{taylor_series} is a univariate Taylor series. @var{numer_deg_bound} and 
@var{denom_deg_bound} are positive integers specifying degree bounds on
the numerator and denominator.

@var{taylor_series} can also be a Laurent series, and the degree bounds can be 
@code{inf} which causes all rational functions whose total degree is less than 
or equal to the length of the power series to be returned.  Total degree is 
defined as @code{@var{numer_deg_bound} + @var{denom_deg_bound}}. Length of a 
power series is defined as @code{"truncation level" + 1 - min(0, "order of 
series")}.

@example
(%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                              2    3
(%o1)/T/             1 + x + x  + x  + . . .
(%i2) pade (%, 1, 1);
                                 1
(%o2)                       [- -----]
                               x - 1
(%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                   + 387072*x^7 + 86016*x^6 - 1507328*x^5
                   + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                   + 67108864*x - 134217728)
       /134217728, x, 0, 10);
                    2    3       4       5       6        7
             x   3 x    x    15 x    23 x    21 x    189 x
(%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
             2    16    32   1024    2048    32768   65536

                                  8         9          10
                            5853 x    2847 x    83787 x
                          + ------- + ------- - --------- + . . .
                            4194304   8388608   134217728
(%i4) pade (t, 4, 4);
(%o4)                          []
@end example

There is no rational function of degree 4 numerator/denominator, with this
power series expansion.  You must in general have degree of the numerator and
degree of the denominator adding up to at least the degree of the power series,
in order to have enough unknown coefficients to solve.

@example
(%i5) pade (t, 5, 5);
                     5                4                 3
(%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                  2
 - 1619100813312 x  - 2176885157888 x - 2386516803584)

               5                 4                  3
/(47041365435 x  + 381702613848 x  + 1360678489152 x

                  2
 + 2856700692480 x  + 3370143559680 x + 2386516803584)]
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{powerdisp}
@defvr {Option variable} powerdisp
Default value: @code{false}

When @code{powerdisp} is @code{true}, a sum is displayed with its terms in 
order of increasing power. Thus a polynomial is displayed as a truncated power 
series, with the constant term first and the highest power last.

By default, terms of a sum are displayed in order of decreasing power.

@c NEED AN EXAMPLE HERE
@c @opencatbox
@c @category{Display flags and variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{powerseries}
@deffn {Function} powerseries (@var{expr}, @var{x}, @var{a})

Returns the general form of the power series expansion for @var{expr} in the 
variable @var{x} about the point @var{a} (which may be @code{inf} for infinity):
@example
           inf
           ====
           \               n
            >    b  (x - a)
           /      n
           ====
           n = 0
@end example

If @code{powerseries} is unable to expand @var{expr},
@code{taylor} may give the first several terms of the series.

When @code{verbose} is @code{true},
@code{powerseries} prints progress messages. 

@example
(%i1) verbose: true$
(%i2) powerseries (log(sin(x)/x), x, 0);
can't expand 
                                 log(sin(x))
so we'll try again after applying the rule:
                                        d
                                      / -- (sin(x))
                                      [ dx
                        log(sin(x)) = i ----------- dx
                                      ]   sin(x)
                                      /
in the first simplification we have returned:
                             /
                             [
                             i cot(x) dx - log(x)
                             ]
                             /
                    inf
                    ====        i1  2 i1             2 i1
                    \      (- 1)   2     bern(2 i1) x
                     >     ------------------------------
                    /                i1 (2 i1)!
                    ====
                    i1 = 1
(%o2)                -------------------------------------
                                      2
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{psexpand}
@defvr {Option variable} psexpand
Default value: @code{false}

When @code{psexpand} is @code{true},
an extended rational function expression is displayed fully expanded.
The switch @code{ratexpand} has the same effect.

@c WE NEED TO BE EXPLICIT HERE
When @code{psexpand} is @code{false},
a multivariate expression is displayed just as in the rational function package.

@c TERMS OF WHAT ??
When @code{psexpand} is  @code{multi},
then terms with the same total degree in the variables are grouped together.

@c @opencatbox
@c @category{Display flags and variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{revert}
@anchor{revert2}
@deffn  {Function} revert (@var{expr}, @var{x})
@deffnx {Function} revert2 (@var{expr}, @var{x}, @var{n})

These functions return the reversion of @var{expr}, a Taylor series about zero 
in the variable @var{x}. @code{revert} returns a polynomial of degree equal to 
the highest power in @var{expr}. @code{revert2} returns a polynomial of degree 
@var{n}, which may be greater than, equal to, or less than the degree of 
@var{expr}.

@code{load ("revert")} loads these functions.

Examples:

@example
(%i1) load ("revert")$
(%i2) t: taylor (exp(x) - 1, x, 0, 6);
                   2    3    4    5     6
                  x    x    x    x     x
(%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                  2    6    24   120   720
(%i3) revert (t, x);
               6       5       4       3       2
           10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
(%o3)/R/ - --------------------------------------------
                                60
(%i4) ratexpand (%);
                     6    5    4    3    2
                    x    x    x    x    x
(%o4)             - -- + -- - -- + -- - -- + x
                    6    5    4    3    2
(%i5) taylor (log(x+1), x, 0, 6);
                    2    3    4    5    6
                   x    x    x    x    x
(%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                   2    3    4    5    6
(%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
(%o6)                           0
(%i7) revert2 (t, x, 4);
                          4    3    2
                         x    x    x
(%o7)                  - -- + -- - -- + x
                         4    3    2
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylor}
@deffn  {Function} taylor (@var{expr}, @var{x}, @var{a}, @var{n})
@deffnx {Function} taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})
@deffnx {Function} taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])
@deffnx {Function} taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, @var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])
@deffnx {Function} taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], ...)

@code{taylor (@var{expr}, @var{x}, @var{a}, @var{n})} expands the expression 
@var{expr} in a truncated Taylor or Laurent series in the variable @var{x}
around the point @var{a}, containing terms through @code{(@var{x} - 
@var{a})^@var{n}}.

If @var{expr} is of the form @code{@var{f}(@var{x})/@var{g}(@var{x})} and 
@code{@var{g}(@var{x})} has no terms up to degree @var{n} then @code{taylor} 
attempts to expand @code{@var{g}(@var{x})} up to degree @code{2 @var{n}}. If 
there are still no nonzero terms, @code{taylor} doubles the degree of the 
expansion of @code{@var{g}(@var{x})} so long as the degree of the expansion is 
less than or equal to @code{@var{n} 2^taylordepth}.

@code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})}
returns a truncated power series of degree @var{n} in all variables @var{x_1}, 
@var{x_2}, ... about the point @code{(@var{a}, @var{a}, ...)}.

@code{taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, 
@var{a_2}, @var{n_2}], ...)} returns a truncated power series in the variables 
@var{x_1}, @var{x_2}, ... about the point @code{(@var{a_1}, @var{a_2}, ...)},
truncated at @var{n_1}, @var{n_2}, ....

@code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, 
@var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])} returns a truncated power series 
in the variables @var{x_1}, @var{x_2}, ... about the point @code{(@var{a_1}, 
@var{a_2}, ...)}, truncated at @var{n_1}, @var{n_2}, ....

@code{taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])} returns an 
expansion of @var{expr} in negative powers of @code{@var{x} - @var{a}}. The 
highest order term is @code{(@var{x} - @var{a})^@var{-n}}.

When @code{maxtayorder} is @code{true}, then during algebraic manipulation of 
(truncated) Taylor series, @code{taylor} tries to retain as many terms as are 
known to be correct.

When @code{psexpand} is @code{true}, an extended rational function expression 
is displayed fully expanded. The switch @code{ratexpand} has the same effect.
When @code{psexpand} is @code{false}, a multivariate expression is displayed 
just as in the rational function package. When @code{psexpand} is  @code{multi},
then terms with the same total degree in the variables are grouped together.

See also the @code{taylor_logexpand} switch for controlling expansion.

Examples:

@c ===beg===
@c taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
@c %^2;
@c taylor (sqrt (x + 1), x, 0, 5);
@c %^2;
@c product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
@c ev (taylor(%, x,  0, 3), keepfloat);
@c taylor (1/log (x + 1), x, 0, 3);
@c taylor (cos(x) - sec(x), x, 0, 5);
@c taylor ((cos(x) - sec(x))^3, x, 0, 5);
@c taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
@c taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
@c taylor ((x + 1)^n, x, 0, 4);
@c taylor (sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (sin (y + x), [x, y], 0, 3);
@c taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (1/sin (y + x), [x, y], 0, 3);
@c ===end===
@example
(%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                           2             2
             (a + 1) x   (a  + 2 a + 1) x
(%o1)/T/ 1 + --------- - -----------------
                 2               8

                                   3      2             3
                               (3 a  + 9 a  + 9 a - 1) x
                             + -------------------------- + . . .
                                           48
(%i2) %^2;
                                    3
                                   x
(%o2)/T/           1 + (a + 1) x - -- + . . .
                                   6
(%i3) taylor (sqrt (x + 1), x, 0, 5);
                       2    3      4      5
                  x   x    x    5 x    7 x
(%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                  2   8    16   128    256
(%i4) %^2;
(%o4)/T/                  1 + x + . . .
(%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                         inf
                        /===\
                         ! !    i     2.5
                         ! !  (x  + 1)
                         ! !
                        i = 1
(%o5)                   -----------------
                              2
                             x  + 1
(%i6) ev (taylor(%, x,  0, 3), keepfloat);
                               2           3
(%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
(%i7) taylor (1/log (x + 1), x, 0, 3);
                               2       3
                 1   1   x    x    19 x
(%o7)/T/         - + - - -- + -- - ----- + . . .
                 x   2   12   24    720
(%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                4
                           2   x
(%o8)/T/                - x  - -- + . . .
                               6
(%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
(%o9)/T/                    0 + . . .
(%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                               2          4
            1     1       11      347    6767 x    15377 x
(%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
             6      4        2   15120   604800    7983360
            x    2 x    120 x

                                                          + . . .
(%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
               2  2       4      2   4
              k  x    (3 k  - 4 k ) x
(%o11)/T/ 1 - ----- - ----------------
                2            24

                                    6       4       2   6
                               (45 k  - 60 k  + 16 k ) x
                             - -------------------------- + . . .
                                          720
(%i12) taylor ((x + 1)^n, x, 0, 4);
                      2       2     3      2         3
                    (n  - n) x    (n  - 3 n  + 2 n) x
(%o12)/T/ 1 + n x + ----------- + --------------------
                         2                 6

                               4      3       2         4
                             (n  - 6 n  + 11 n  - 6 n) x
                           + ---------------------------- + . . .
                                          24
(%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
               3                 2
              y                 y
(%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
              6                 2

                    3                       2
               y   y            2      1   y            3
          + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
               2   12                  6   12
(%i14) taylor (sin (y + x), [x, y], 0, 3);
                     3        2      2      3
                    x  + 3 y x  + 3 y  x + y
(%o14)/T/   y + x - ------------------------- + . . .
                                6
(%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
          1   y              1    1               1            2
(%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
          y   6               2   6                3
                             y                    y

                                           1            3
                                      + (- -- + . . .) x  + . . .
                                            4
                                           y
(%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                             3         2       2        3
            1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
(%o16)/T/ ----- + ----- + ------------------------------- + . . .
          x + y     6                   360
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylordepth}
@defvr {Option variable} taylordepth
Default value: 3

@c UM, THE CONTEXT FOR THIS REMARK NEEDS TO BE ESTABLISHED
If there are still no nonzero terms, @code{taylor} doubles the degree of the 
expansion of @code{@var{g}(@var{x})} so long as the degree of the expansion is 
less than or equal to @code{@var{n} 2^taylordepth}.

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylorinfo}
@deffn {Function} taylorinfo (@var{expr})

Returns information about the Taylor series @var{expr}. The return value is a 
list of lists. Each list comprises the name of a variable, the point of 
expansion, and the degree of the expansion.

@code{taylorinfo} returns @code{false} if @var{expr} is not a Taylor series.

Example:

@example
(%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                  2                       2
(%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

         2                        2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   3
 + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
(%i2) taylorinfo(%);
(%o2)               [[y, a, inf], [x, 0, 3]]
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylorp}
@deffn {Function} taylorp (@var{expr})

Returns @code{true} if @var{expr} is a Taylor series, and @code{false} 
otherwise.

@c @opencatbox
@c @category{Predicate functions} @category{Power series}
@c @closecatbox
@end deffn

@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@anchor{taylor_logexpand}
@defvr {Option variable} taylor_logexpand
Default value: @code{true}

@code{taylor_logexpand} controls expansions of logarithms in @code{taylor} 
series.

When @code{taylor_logexpand} is @code{true}, all logarithms are expanded fully 
so that zero-recognition problems involving logarithmic identities do not
disturb the expansion process.  However, this scheme is not always
mathematically correct since it ignores branch information.

When @code{taylor_logexpand} is set to @code{false}, then the only expansion of 
logarithms that occur is that necessary to obtain a formal power series.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Power series} @category{Exponential and logarithm functions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_order_coefficients}
@defvr {Option variable} taylor_order_coefficients
Default value: @code{true}

@code{taylor_order_coefficients} controls the ordering of coefficients in a 
Taylor series.

When @code{taylor_order_coefficients} is @code{true}, coefficients of taylor 
series are ordered canonically.
@c IS MAXIMA'S NOTION OF "CANONICALLY" DESCRIBED ELSEWHERE ??
@c AND WHAT HAPPENS WHEN IT IS FALSE ??

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_simplifer}
@deffn {Function} taylor_simplifier (@var{expr})

Simplifies coefficients of the power series @var{expr}. @code{taylor} calls 
this function.

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylor_truncate_polynomials}
@defvr {Option variable} taylor_truncate_polynomials
Default value: @code{true}

@c WHAT IS THE "INPUT TRUNCATION LEVEL" ?? THE ARGUMENT n OF taylor ??
When @code{taylor_truncate_polynomials} is @code{true}, polynomials are 
truncated based upon the input truncation levels.

Otherwise, polynomials input to @code{taylor} are considered to have infinite 
precison.
@c WHAT IS "INFINITE PRECISION" IN THIS CONTEXT ??

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taytorat}
@deffn {Function} taytorat (@var{expr})

Converts @var{expr} from @code{taylor} form to canonical rational expression 
(CRE) form. The effect is the same as @code{rat (ratdisrep (@var{expr}))}, but 
faster.

@c @opencatbox
@c @category{Power series} @category{Rational expressions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trunc}
@deffn {Function} trunc (@var{expr})

Annotates the internal representation of the general expression @var{expr}
so that it is displayed as if its sums were truncated Taylor series.
@var{expr} is not otherwise modified.

Example:

@example
(%i1) expr: x^2 + x + 1;
                            2
(%o1)                      x  + x + 1
(%i2) trunc (expr);
                                2
(%o2)                  1 + x + x  + . . .
(%i3) is (expr = trunc (expr));
(%o3)                         true
@end example

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{verbose}
@defvr {Option variable} verbose
Default value: @code{false}

When @code{verbose} is @code{true}, @code{powerseries} prints progress messages.

@c @opencatbox
@c @category{Power series}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Poisson Reihen, Kettenbr@"uche, Funktionen und Variablen f@"ur Reihen, Summen Produkte und Reihen
@section Poisson Reihen

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{intopois}
@deffn {Function} intopois (@var{a})

Converts @var{a} into a Poisson encoding.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{outofpois}
@deffn {Function} outofpois (@var{a})

Converts @var{a} from Poisson encoding to general representation.  If @var{a} 
is not in Poisson form, @code{outofpois} carries out the conversion, i.e., 
the return value is @code{outofpois (intopois (@var{a}))}. This function is 
thus a canonical simplifier for sums of powers of sine and cosine terms of a 
particular type.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c NEED MORE INFO HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{poisdiff}
@deffn {Function} poisdiff (@var{a}, @var{b})

Differentiates @var{a} with respect to @var{b}. @var{b} must occur only
in the trig arguments or only in the coefficients.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c LOOKING AT THE CODE IN src/pois3.lisp, THIS FCN SEEMS TO COMPUTE THE EXPONENT
@c BY MULTIPLYING IN A LOOP
@c DUNNO HOW WE WANT TO EXPLAIN THAT
@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisexpt}
@deffn {Function} poisexpt (@var{a}, @var{b})

Functionally identical to @code{intopois (@var{a}^@var{b})}. @var{b} must be a
positive integer.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c WHAT IS THIS ABOUT ??

@c -----------------------------------------------------------------------------
@anchor{poisint}
@deffn {Function} poisint (@var{a}, @var{b})

Integrates in a similarly restricted sense (to @code{poisdiff}).  Non-periodic 
terms in @var{b} are dropped if @var{b} is in the trig arguments.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poislim}
@defvr {Option variable} poislim
Default value: 5

@code{poislim} determines the domain of the coefficients in the arguments of 
the trig functions.  The initial value of 5 corresponds to the interval 
[-2^(5-1)+1,2^(5-1)], or [-15,16], but it can be set to [-2^(n-1)+1, 2^(n-1)].

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end defvr

@c UMM, WHAT IS THIS ABOUT EXACTLY ?? EXAMPLES NEEDED

@c -----------------------------------------------------------------------------
@anchor{poismap}
@deffn {Function} poismap (@var{series}, @var{sinfn}, @var{cosfn})

will map the functions @var{sinfn} on the sine terms and @var{cosfn} on the 
cosine terms of the Poisson series given. @var{sinfn} and @var{cosfn} are 
functions of two arguments which are a coefficient and a trigonometric part 
of a term in series respectively.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisplus}
@deffn {Function} poisplus (@var{a}, @var{b})

Is functionally identical to @code{intopois (a + b)}.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poissimp}
@deffn {Function} poissimp (@var{a})

Converts @var{a} into a Poisson series for @var{a} in general representation.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c MORE INFO NEEDED HERE

@c -----------------------------------------------------------------------------
@anchor{poisson}
@defvr {Special symbol} poisson

The symbol @code{/P/} follows the line label of Poisson series expressions.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{poissubst}
@deffn {Function} poissubst (@var{a}, @var{b}, @var{c})

Substitutes @var{a} for @var{b} in @var{c}.  @var{c} is a Poisson series.

(1) Where @var{B} is a variable @var{u}, @var{v}, @var{w}, @var{x}, @var{y}, or 
@var{z}, then @var{a} must be an expression linear in those variables (e.g., 
@code{6*u + 4*v}).

(2) Where @var{b} is other than those variables, then @var{a} must also be
free of those variables, and furthermore, free of sines or cosines.

@code{poissubst (@var{a}, @var{b}, @var{c}, @var{d}, @var{n})} is a special 
type of substitution which operates on @var{a} and @var{b} as in type (1) above,
but where @var{d} is a Poisson series, expands @code{cos(@var{d})} and 
@code{sin(@var{d})} to order @var{n} so as to provide the result of substituting
@code{@var{a} + @var{d}} for @var{b} in @var{c}.  The idea is that @var{d} is an
expansion in terms of a small parameter.  For example,
@code{poissubst (u, v, cos(v), %e, 3)} yields @code{cos(u)*(1 - %e^2/2) - 
sin(u)*(%e - %e^3/6)}.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poistimes}
@deffn {Function} poistimes (@var{a}, @var{b})

Is functionally identical to @code{intopois (@var{a}*@var{b})}.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c HOW DOES THIS WORK ?? NEED MORE INFO AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{poistrim}
@deffn {Function} poistrim ()

is a reserved function name which (if the user has defined it) gets applied 
during Poisson multiplication.  It is a predicate function of 6 arguments which 
are the coefficients of the @var{u}, @var{v}, ..., @var{z} in a term.  Terms 
for which @code{poistrim} is @code{true} (for the coefficients of that term) 
are eliminated during multiplication.

@c @opencatbox
@c @category{Poisson series}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printpois}
@deffn {Function} printpois (@var{a})

Prints a Poisson series in a readable format.  In common with @code{outofpois}, 
it will convert @var{a} into a Poisson encoding first, if necessary.

@c @opencatbox
@c @category{Poisson series} @category{Display functions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Kettenbr@"uche, , Poisson Reihen, Summen Produkte und Reihen
@section Kettenbr@"uche

@c -----------------------------------------------------------------------------
@anchor{cf}
@deffn {Function} cf (@var{expr})

Converts @var{expr} into a continued fraction. @var{expr} is an expression
comprising continued fractions and square roots of integers. Operands in the 
expression may be combined with arithmetic operators. Aside from continued 
fractions and square roots, factors in the expression must be integer or 
rational numbers. Maxima does not know about operations on continued fractions 
outside of @code{cf}.

@code{cf} evaluates its arguments after binding @code{listarith} to 
@code{false}. @code{cf} returns a continued fraction, represented as a list.

A continued fraction @code{a + 1/(b + 1/(c + ...))} is represented by the list 
@code{[a, b, c, ...]}. The list elements @code{a}, @code{b}, @code{c}, ... must 
evaluate to integers. @var{expr} may also contain @code{sqrt (n)} where @code{n} 
is an integer. In this case @code{cf} will give as many terms of the continued 
fraction as the value of the variable @code{cflength} times the period.

A continued fraction can be evaluated to a number by evaluating the arithmetic 
representation returned by @code{cfdisrep}. See also @code{cfexpand} for another 
way to evaluate a continued fraction.

See also @code{cfdisrep}, @code{cfexpand}, and @code{cflength}.

Examples:

@itemize @bullet
@item
@var{expr} is an expression comprising continued fractions and square roots of integers.

@example
(%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
(%o1)               [59, 17, 2, 1, 1, 1, 27]
(%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
(%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]
@end example

@item
@code{cflength} controls how many periods of the continued fraction
are computed for algebraic, irrational numbers.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example

@item
A continued fraction can be evaluated by evaluating the arithmetic representation
returned by @code{cfdisrep}.

@example
(%i1) cflength: 3$
(%i2) cfdisrep (cf (sqrt (3)))$
(%i3) ev (%, numer);
(%o3)                   1.731707317073171
@end example

@item
Maxima does not know about operations on continued fractions outside of @code{cf}.

@example
(%i1) cf ([1,1,1,1,1,2] * 3);
(%o1)                     [4, 1, 5, 2]
(%i2) cf ([1,1,1,1,1,2]) * 3;
(%o2)                  [3, 3, 3, 3, 3, 6]
@end example

@end itemize

@c @opencatbox
@c @category{Continued fractions}
@c @closecatbox
@end deffn

@c NEEDS CLARIFICATION -- MAKE EXPLICIT HOW list IS RELATED TO a, b, c, ...
@c ALSO, CAN list CONTAIN ANYTHING OTHER THAN LITERAL INTEGERS ??

@c -----------------------------------------------------------------------------
@deffn {Function} cfdisrep (@var{list})

Constructs and returns an ordinary arithmetic expression
of the form @code{a + 1/(b + 1/(c + ...))}
from the list representation of a continued fraction @code{[a, b, c, ...]}.

@example
(%i1) cf ([1, 2, -3] + [1, -2, 1]);
(%o1)                     [1, 1, 1, 2]
(%i2) cfdisrep (%);
                                  1
(%o2)                     1 + ---------
                                    1
                              1 + -----
                                      1
                                  1 + -
                                      2
@end example

@c @opencatbox
@c @category{Continued fractions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} cfexpand (@var{x})

Returns a matrix of the numerators and denominators of the
last (column 1) and next-to-last (column 2) convergents of the continued fraction @var{x}.

@example
(%i1) cf (rat (ev (%pi, numer)));

`rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
(%o1)                  [3, 7, 15, 1, 292]
(%i2) cfexpand (%); 
                         [ 103993  355 ]
(%o2)                    [             ]
                         [ 33102   113 ]
(%i3) %[1,1]/%[2,1], numer;
(%o3)                   3.141592653011902
@end example

@c @opencatbox
@c @category{Continued fractions}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} cflength
Default value: 1

@code{cflength} controls the number of terms of the continued
fraction the function @code{cf} will give, as the value @code{cflength} times the
period.  Thus the default is to give one period.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example

@c @opencatbox
@c @category{Continued fractions}
@c @closecatbox
@end defvr

@c --- End of file Series.de.texi ----------------------------------------------

