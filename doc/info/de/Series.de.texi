@c -----------------------------------------------------------------------------
@c File        : Series.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Series.texi revision 1.21
@c Translation : Dr. Dieter Kaiser
@c Date        : 05.11.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Summen und Produkte::
* Einf@"uhrung in Reihen::
* Funktionen und Variablen f@"ur Reihen::
* Poisson Reihen::
* Kettenbr@"uche::
@end menu

@c -----------------------------------------------------------------------------
@node Summen und Produkte, Einf@"uhrung in Reihen, Summen Produkte und Reihen, Summen Produkte und Reihen
@section Summen und Produkte
@c -----------------------------------------------------------------------------

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{bashindices}
@deffn {Funktion} bashindices (@var{expr})

@c Transforms the expression @var{expr} by giving each summation and product a
@c unique index. This gives @code{changevar} greater precision when it is 
@c working with summations or products.  The form of the unique index is 
@c @code{j@var{number}}. The quantity @var{number} is determined by referring to 
@c @code{gensumnum}, which can be changed by the user. For example, 
@c @code{gensumnum:0$} resets it.

Transformiert einen Ausdruck @var{expr}, der mehrere Summen oder Produkte
enth@"alt so, dass alle Summen und Produkte einen unterschiedlichen Index haben.
Dies erleichtert zum Beispiel Substitutionen mit der Funktion @code{changevar}.
Die neuen Indizes werden mit @code{j@var{nummer}} bezeichnet, wobei die Zahl 
@var{nummer} der Wert der Optionsvariablen @code{gensumnum} ist.  Siehe 
@mrefdot{gensumnum}

Beispiel:

@c ===beg===
@c sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
@c bashindices(%);
@c ===end===
@example
(%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                       inf       inf
                       ====      ====
                       \     1   \     1
(%o1)                   >    - +  >    --
                       /     k   /      2
                       ====      ====  k
                       k = 0     k = 0
(%i2) bashindices(%);
                     inf         inf
                     ====        ====
                     \      1    \       1
(%o2)                 >     -- +  >     ---
                     /      j2   /        2
                     ====        ====   j1
                     j2 = 0      j1 = 0
@end example

@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{cauchysum}
@defvr {Optionsvariable} cauchysum
Standardwert: @code{false}

@c When multiplying together sums with @code{inf} as their upper limit, if 
@c @code{sumexpand} is @code{true} and @code{cauchysum} is @code{true} then the 
@c Cauchy product will be used rather than the usual product. In the Cauchy 
@c product the index of the inner summation is a function of the index of the 
@c outer one rather than varying independently.

Werden zwei unendliche Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @code{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

Beispiele:

@c ===beg===
@c sumexpand: false$
@c cauchysum: false$
@c s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
@c sumexpand: true$
@c cauchysum: true$
@c ''s;
@c ===end===
@example
(%i1) sumexpand: false$
(%i2) cauchysum: false$
(%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                      inf         inf
                      ====        ====
                      \           \
(%o3)                ( >    f(i))  >    g(j)
                      /           /
                      ====        ====
                      i = 0       j = 0
(%i4) sumexpand: true$
(%i5) cauchysum: true$
(%i6) ''s;
                 inf     i1
                 ====   ====
                 \      \
(%o6)             >      >     g(i1 - i2) f(i2)
                 /      /
                 ====   ====
                 i1 = 0 i2 = 0
@end example
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{genindex}
@defvr {Optionsvariable} genindex
Standardwert: @code{i}

@c @code{genindex} is the alphabetic prefix used to generate the next variable 
@c of summation when necessary.

@code{genindex} enth@"alt das Zeichen f@"ur den Pr@"afix, der verwendet wird, um
einen neuen Index f@"ur eine Summe oder ein Produkt zu generieren.  Siehe auch
@mrefdot{gensumnum}
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{gensumnum}
@defvr {Optionsvariable} gensumnum
Standardwert: 0

@c @code{gensumnum} is the numeric suffix used to generate the next variable
@c of summation.  If it is set to @code{false} then the index will consist only
@c of @code{genindex} with no numeric suffix.

@code{gensumnum} enth@"alt die Nummer, die an den Pr@"afix @code{genindex}
angeh@"angt wird, um den n@"achsten Index f@"ur eine Summe oder ein Produkt zu 
generieren.  Hat @code{gensumnum} den Wert @code{false}, wird der Index nur aus 
dem Zeichen @code{genindex} gebildet. Siehe auch @mrefdot{genindex}
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{intosum}
@deffn {Funktion} intosum (@var{expr})

@c Moves multiplicative factors outside a summation to inside. If the index is 
@c used in the outside expression, then the function tries to find a reasonable
@c index, the same as it does for @code{sumcontract}.  This is essentially the
@c reverse idea of the @code{outative} property of summations, but note that it
@c does not remove this property, it only bypasses it.

Multipliziert Faktoren in eine Summe herein.  Tritt der Index der Summe als ein
Faktor au@ss{}erhalb der Summe auf, wird von der Funktion @code{intosum} ein 
neuer Index gebildet.  Summen haben die Eigenschaft @mrefcomma{outative} so dass 
Faktoren aus der Summe herausgezogen werden.  Mit der Funktion @code{intosum} 
wird diese Vereinfachung r@"uckg@"angig gemacht.

@c TODO: NICHT UEBERSETZT, DA KEIN BEISPIELE VORHANDEN.
@c In some cases, a @code{scanmap (multthru, @var{expr})} may be necessary 
@c before the @code{intosum}.

Beispiel:

@c ===beg===
@c sum(2*x^2*n^k, k , 0, inf);
@c intosum(%);
@c ===end===
@example
@group
(%i1) sum(2*x^2*n^k, k , 0, inf);
                               inf
                               ====
                             2 \      k
(%o1)                     2 x   >    n
                               /
                               ====
                               k = 0
@end group
@group
(%i2) intosum(%);
                          inf
                          ====
                          \        k  2
(%o2)                      >    2 n  x
                          /
                          ====
                          k = 0
@end group
@end example
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{lsum}
@deffn {Funktion} lsum (@var{expr}, @var{i}, @var{L})

@c Represents the sum of @var{expr} for each element @var{x} in @var{L}.
@c A noun form @code{'lsum} is returned if the argument @var{L} does not 
@c evaluate to a list.

Bildet die Summe f@"ur den Ausdruck @var{expr} zum Index @var{i} f@"ur alle 
Elemente der Liste @var{L}.  Kann das Argument @var{L} nicht zu einer Liste 
ausgewertet werden, wird eine Substantivform zur@"uckgegeben.  Siehe auch
@mrefdot{sum}

Beispiele:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1)
@end example
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{niceindices}
@deffn {Funktion} niceindices (@var{expr})

@c Renames the indices of sums and products in @var{expr}. @code{niceindices} 
@c attempts to rename each index to the value of @code{niceindicespref[1]},
@c unless that name appears in the summand or multiplicand, in which case 
@c @code{niceindices} tries the succeeding elements of @code{niceindicespref} 
@c in turn, until an unused variable is found. If the entire list is exhausted,
@c additional indices are constructed by appending integers to the value of
@c @code{niceindicespref[1]}, e.g., @code{i0}, @code{i1}, @code{i2}, ....

Gibt den Indizes von Summen und Produkten im Ausdruck @var{expr} einen neuen
Namen.  @code{niceindices} benennt die Indizes nacheinander mit den Namen, die
in der Liste der Optionsvariablen @mref{niceindicespref} enthalten sind.  Die 
Standardnamen sind @code{[i, j, k, l, m, n]}.  Sind nicht gen@"ugend Namen in 
der Liste vorhanden, werden weitere Indizes durch das Anh@"angen einer Nummer
gebildet.

@c @code{niceindices} returns an expression @code{niceindices} evaluates 
@c its argument.

@code{niceindices} wertet das Argument aus.

Beispiele:

@c ===beg===
@c product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
@c niceindices (%);
@c ===end===
@example
@group
(%i1) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o1)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
@end group
@group
(%i2) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o2)                ! !   >    f(i j l + k)
                     ! !  /
                    l = 1 ====
                          k = 1
@end group
@end example
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{niceindicespref}
@defvr {Optionsvariable} niceindicespref
Standardwert: @code{[i, j, k, l, m, n]}

@c @code{niceindicespref} is the list from which @code{niceindices}
@c takes the names of indices for sums and products.
@c The elements of @code{niceindicespref} are typically names of variables,
@c although that is not enforced by @code{niceindices}.

@code{niceindicespref} ist die Liste mit den Namen, die die Funktion 
@mref{niceindices} nutzt, um die Indizes von Summen und Produkte umzubenennen.

Beispiele:

@c ===beg===
@c niceindicespref: [p, q, r, s, t, u]$
@c product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
@c niceindices (%);
@c ===end===
@example
(%i1) niceindicespref: [p, q, r, s, t, u]$
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
(%i3) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j q + p)
                     ! !  /
                    q = 1 ====
                          p = 1
@end example

@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{nusum}
@deffn {Funktion} nusum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Carries out indefinite hypergeometric summation of @var{expr} with
@c respect to @var{x} using a decision procedure due to R.W. Gosper.
@c @var{expr} and the result must be expressible as products of integer powers,
@c factorials, binomials, and rational functions.

Wendet den Gosper-Algorithmus der unbestimmten Summation f@"ur den Ausdruck 
@var{expr} und den Index @var{i} an.  Der Index @var{i} l@"auft von @var{i_0} 
bis @var{i_1}.  Der Ausdruck @var{expr} und das Ergebnis der Summation m@"ussen 
als Produkte von ganzzahligen Exponentiationen, Fakult@"aten, Binomialen und
rationalen Funktionen darstellbar sein.

@c UMM, DO WE REALLY NEED TO DEFINE "DEFINITE" AND "INDEFINITE" SUMMATION HERE??
@c (CAN'T WE MAKE THE POINT WITHOUT DRAGGING IN SOME NONSTANDARD TERMINOLOGY ??)

@c The terms "definite" and "indefinite summation" are used analogously to 
@c "definite" and "indefinite integration". To sum indefinitely means to give a
@c symbolic result for the sum over intervals of variable length, not just e.g. 
@c 0 to inf.  Thus, since there is no formula for the general partial sum of
@c the binomial series, @code{nusum} can't do it.

@c @code{nusum} and @code{unsum} know a little about sums and differences of 
@c finite products. See also @code{unsum}.

Die Funktionen @code{nusum} und @code{unsum} wenden einige Regeln f@"ur die
Vereinfachung von Summen und Differenzen von endlichen Produkten an.  Siehe 
auch @mrefdot{unsum}

Beispiele:

@c ===beg===
@c nusum (n*n!, n, 0, n);
@c nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
@c unsum (%, n);
@c unsum (prod (i^2, i, 1, n), n);
@c nusum (%, n, 1, n);
@c ===end===
@example
(%i1) nusum (n*n!, n, 0, n);

Dependent equations eliminated:  (1)
(%o1)                     (n + 1)! - 1
(%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o2) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i3) unsum (%, n);
                              4  n
                             n  4
(%o3)                   ----------------
                        binomial(2 n, n)
@group
(%i4) unsum (prod (i^2, i, 1, n), n);
                    n - 1
                    /===\
                     ! !   2
(%o4)              ( ! !  i ) (n - 1) (n + 1)
                     ! !
                    i = 1
@end group
(%i5) nusum (%, n, 1, n);

Dependent equations eliminated:  (2 3)
                            n
                          /===\
                           ! !   2
(%o5)                      ! !  i  - 1
                           ! !
                          i = 1
@end example
@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{product}
@deffn {Funktion} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Represents a product of the values of @var{expr} as the index @var{i} varies 
@c from @var{i_0} to @var{i_1}. The noun form @code{'product} is displayed as 
@c an uppercase letter pi.
@c @code{product} evaluates @var{expr} and lower and upper limits @var{i_0} and 
@c @var{i_1}, @code{product} quotes (does not evaluate) the index @var{i}.

Bildet das Produkt des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}.  @code{product} wertet @var{expr} sowie die untere 
Grenze @var{i_0} und obere Grenze @var{i_1} aus.  Der Index @var{i} wird nicht 
ausgewertet.

@c If the upper and lower limits differ by an integer, @var{expr} is evaluated 
@c for each value of the index @var{i}, and the result is an explicit product.
@c Otherwise, the range of the index is indefinite. Some rules are applied to 
@c simplify the product. When the global variable @code{simpproduct} is 
@c @code{true}, additional rules are applied. In some cases, simplification 
@c yields a result which is not a product; otherwise, the result is a noun form 
@c @code{'product}.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet.  Das Ergebnis ist ein explizites
Produkt.  Andernfalls ist der Bereich des Index unbestimmt.  Maxima wendet 
einige einfache Regeln an, um das Produkt zu vereinfachen.  Hat die 
Optionsvariable @mref{simpproduct} den Wert @code{true}, wendet Maxima weitere 
Regeln an, um Produkte zu vereinfachen. 

@c See also @code{nouns} and @code{evflag}.

Siehe auch @mref{nouns} und @mref{evflag} f@"ur die Auswertung von Ausdr@"ucken,
die die Substantivform eines Produktes enthalten.

Beispiele:

@c ===beg===
@c product (x + i*(i+1)/2, i, 1, 4);
@c product (i^2, i, 1, 7);
@c product (a[i], i, 1, 7);
@c product (a(i), i, 1, 7);
@c product (a(i), i, 1, n);
@c product (k, k, 1, n);
@c product (k, k, 1, n), simpproduct;
@c product (integrate (x^k, x, 0, 1), k, 1, n);
@c product (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===
@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
@group
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
@end group
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example

@end deffn

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{simpproduct}
@defvr {Optionsvariable} simpproduct
Standardwert: @code{false}

Hat @code{simpproduct} den Wert @code{true}, versucht Maxima ein Produkt weiter 
zu vereinfachen.  Die Vereinfachung kann eine geschlossene Form liefern.  Hat
@code{simpproduct} den Wert @code{false} oder wird das Produkt in der
Substantivform @code{'product} definiert, werden nur einige einfache Regeln von
Maxima f@"ur die Vereinfachung angewendet.  @code{simpproduct} ist auch ein
Auswertungsschalter.  Siehe @mrefdot{evflag}

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN. Z. B. OUTATIVE?
@c TODO: IST IM ENGLISCHEN MANUAL NICHT DOKUMENTIERT.
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{simpsum}
@defvr {Optionsvariable} simpsum
Standardwert: @code{false}

@c When @code{simpsum} is @code{true}, the result of a @code{sum} is simplified.
@c This simplification may sometimes be able to produce a closed form. If 
@c @code{simpsum} is @code{false} or if the quoted form @code{'sum} is used, the
@c value is a sum noun form which is a representation of the sigma notation used
@c in mathematics.

Hat @code{simpsum} den Wert @code{true}, versucht Maxima eine Summe oder Reihe 
weiter zu vereinfachen.  Die Vereinfachung kann eine geschlossene Form liefern. 
Hat @code{simpsum} den Wert @code{false} oder die Summe oder Reihe liegt in der
Substantivform @code{'sum} vor, werden nur einige einfache Regeln von Maxima 
f@"ur die Vereinfachung angewendet.  @code{simpsum} ist auch ein
Auswertungsschalter.  Siehe @mrefdot{evflag}

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN. Z. B. OUTATIVE?
@end defvr

@c --- 07.11.2010 DK -----------------------------------------------------------
@anchor{sum}
@deffn {Funktion} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

@c Represents a summation of the values of @var{expr} as the index @var{i} 
@c varies from @var{i_0} to @var{i_1}. The noun form @code{'sum} is displayed as
@c an uppercase letter sigma.
@c @code{sum} evaluates its summand @var{expr} and lower and upper limits 
@c @var{i_0} and @var{i_1}, @code{sum} quotes (does not evaluate) the index 
@c @var{i}.

Bildet die Summe des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}.  Die Funktion @code{sum} wertet @var{expr} sowie die 
untere Grenze @var{i_0} und obere Grenze @var{i_1} aus.  Der Index @var{i} wird 
nicht ausgewertet.

@c If the upper and lower limits differ by an integer, the summand @var{expr} 
@c is evaluated for each value of the summation index @var{i}, and the result 
@c is an explicit sum.
@c Otherwise, the range of the index is indefinite. Some rules are applied to 
@c simplify the summation. When the global variable @code{simpsum} is 
@c @code{true}, additional rules are applied. In some cases, simplification 
@c yields a result which is not a summation; otherwise, the result is a noun 
@c form @code{'sum}.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet.  Das Ergebnis ist eine explizite
Summe.  Andernfalls ist der Bereich des Index unbestimmt.  Maxima wendet einige 
einfache Regeln an, um die Summe zu vereinfachen.  Hat die Optionsvariable 
@mref{simpsum} den Wert @code{true}, wendet Maxima weitere Regeln an, um Summen
zu vereinfachen.

@c When the @code{evflag} (evaluation flag) @code{cauchysum} is @code{true},
@c a product of summations is expressed as a Cauchy product, in which the index 
@c of the inner summation is a function of the index of the outer one, rather 
@c than varying independently.

Werden zwei unendliche Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @mref{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

@c The global variable @code{genindex} is the alphabetic prefix used to generate
@c the next index of summation, when an automatically generated index is needed.
@c @code{gensumnum} is the numeric suffix used to generate the next index of 
@c summation, when an automatically generated index is needed. When 
@c @code{gensumnum} is @code{false}, an automatically-generated index is only
@c @code{genindex} with no numeric suffix.

Die Optionsvariable @mref{genindex} enth@"alt das Zeichen, das der Pr@"afix 
eines automatisch generierten Index ist.  @mref{gensumnum} enth@"alt eine ganze 
Zahl, die an den Pr@"afix @code{genindex} angeh@"angt wird, um einen 
automatischen Index zu generieren.  @code{gensumnum} wird von Maxima automatisch
erh@"oht.  Hat @code{gensumnum} den Wert @code{false}, wird keine Zahl an den 
Pr@"afix angeh@"angt.

Das Paket @code{simplify_sum} enth@"alt die Funktion @mrefcomma{simplify_sum}@ 
mit der Summen zu einer geschlossenen Form vereinfacht werden k@"onnen.

@c See also @code{sumcontract}, @code{intosum}, @code{bashindices}, 
@c @code{niceindices}, @code{nouns}, @code{evflag}, and @code{zeilberger}. 

Siehe auch @mrefcomma{sumcontract}  @mrefcomma{sumexpand} @mrefcomma{intosum}@ 
@mrefcomma{bashindices} @mrefcomma{niceindices} @mrefcomma{nouns}@  
@mrefcomma{evflag} @mref{cauchysum} und @mrefdot{zeilberger}

Beispiele:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c sum (2^i + i^2, i, 0, n);
@c sum (2^i + i^2, i, 0, n), simpsum;
@c sum (1/3^i, i, 1, inf);
@c sum (1/3^i, i, 1, inf), simpsum;
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
@c sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
@c sum (integrate (x^k, x, 0, 1), k, 1, n);
@c sum (if k <= 5 then a^k else b^k, k, 1, 10);
@c ===end===
@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
@group
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
@end group
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
@group
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
@end group
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example
@end deffn

@c --- 07.01.2011 DK -----------------------------------------------------------
@anchor{sumcontract}
@deffn {Funktion} sumcontract (@var{expr})

@c Combines all sums of an addition that have upper and lower bounds that differ
@c by constants. The result is an expression containing one summation for each 
@c set of such summations added to all appropriate extra terms that had to be 
@c extracted to form this sum. @code{sumcontract} combines all compatible sums 
@c and uses one of the indices from one of the sums if it can, and then try to 
@c form a reasonable index if it cannot use any supplied.

Fasst alle Summen zusammen, die sich in ihrem oberen und unterem Index nur um
eine Konstante voneinander unterscheiden.  Das Ergebnis ist eine Ausdruck mit
einer Summe, f@"ur die Summen, die zusammengefasst werden k@"onnen und weiteren 
Termen, die hinzu addiert werden m@"ussen, um einen @"aquivalenten Ausdruck zu 
erhalten.

@c WHEN IS intosum NECESSARY BEFORE sumcontract ??
@c It may be necessary to do an @code{intosum (@var{expr})} before the 
@c @code{sumcontract}.

Es kann notwendig sein zun@"achst @code{intosum(@var{expr})} auszuf@"uhren.  
Siehe @mrefdot{intosum}

Beispiel:

@c ===beg===
@c 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
@c sumcontract(%);
@c ===end===
@example
(%i1) 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
                         n        n + 2
                        ====      ====
                        \     1   \
(%o1)                    >    - +  >    k
                        /     l   /
                        ====      ====
                        l = 1     k = 1
(%i2) sumcontract(%);
@group
                            n
                           ====
                           \          1
(%o2)                2 n +  >    (l + -) + 3
                           /          l
                           ====
                           l = 1
@end group
@end example
@end deffn

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{sumexpand}
@defvr {Optionsvariable} sumexpand
Standardwert: @code{false}

@c When @code{sumexpand} is @code{true}, products of sums and
@c exponentiated sums simplify to nested sums.
@c See also @code{cauchysum}.

Hat die Optionsvariable @code{sumexpand} den Wert @code{true}, werden Produkte
von Summen und Potenzen von Summen zu verschachtelten Summen vereinfacht.  Siehe
auch @mrefdot{cauchysum}

Beispiele:

@c ===beg===
@c sumexpand: true$
@c sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
@c sum (f (i), i, 0, m)^2;
@c ===end===
@example
(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                >      >     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                >      >     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
@end example
@end defvr

@c --- 07.01.2011 DK -----------------------------------------------------------
@anchor{unsum}
@deffn {Funktion} unsum (@var{f}, @var{n})

@c Returns the first backward difference @code{@var{f}(@var{n}) - 
@c @var{f}(@var{n} - 1)}. Thus @code{unsum} in a sense is the inverse of 
@c @code{sum}. See also @code{nusum}.

Gibt die erste R@"uckw@"artsdifferenz @code{@var{f}(@var{n}) - 
@var{f}(@var{n}-1)} zur@"uck.  Siehe auch @mrefdot{nusum}

Beispiele:

@c ===beg===
@c g(p) := p*4^n/binomial(2*n,n);
@c g(n^4);
@c nusum (%, n, 0, n);
@c unsum (%, n);
@c ===end===
@example
(%i1) g(p) := p*4^n/binomial(2*n,n);
                                     n
                                  p 4
(%o1)               g(p) := ----------------
                            binomial(2 n, n)
@group
(%i2) g(n^4);
                              4  n
                             n  4
(%o2)                   ----------------
                        binomial(2 n, n)
@end group
(%i3) nusum (%, n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o3) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i4) unsum (%, n);
                              4  n
                             n  4
(%o4)                   ----------------
                        binomial(2 n, n)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Reihen, Funktionen und Variablen f@"ur Reihen, Summen und Produkte, Summen Produkte und Reihen
@section Einf@"uhrung in Reihen
@c -----------------------------------------------------------------------------

@c Maxima contains functions @code{taylor} and @code{powerseries} for finding 
@c the series of differentiable functions. It also has tools such as 
@c @code{nusum} capable of finding the closed form of some series. Operations 
@c such as addition and multiplication work as usual on series. This section 
@c presents the global variables which control the expansion.

Maxima kennt die Funktionen @mref{taylor} und @mrefcomma{powerseries} um die 
Reihenentwicklung von differenzierbaren Funktionen zu finden.  Maxima hat
weiterhin Funktionen wie @mrefcomma{nusum} um geschlossene Formen von Reihen zu
finden.  Operationen wie die Addition und Multiplikation arbeiten wie gewohnt
f@"ur Reihen.  Das folgende Kapitel stellt die Variablen und Funktionen f@"ur 
eine Reihenentwicklung dar.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Reihen, Poisson Reihen, Einf@"uhrung in Reihen, Summen Produkte und Reihen
@section Funktionen und Variablen f@"ur Reihen
@c -----------------------------------------------------------------------------

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{deftaylor}
@deffn {Funktion} deftaylor (@var{f_1}(@var{x_1}), @var{expr_1}, @dots{}, @var{f_n}(@var{x_n}), @var{expr_n})

@c For each function @var{f_i} of one variable @var{x_i}, @code{deftaylor} 
@c defines @var{expr_i} as the Taylor series about zero. @var{expr_i} is 
@c typically a polynomial in @var{x_i} or a summation; more general expressions
@c are accepted by @code{deftaylor} without complaint.

F@"ur eine Funktion @var{f_i} einer Variablen @var{x_i} definiert 
@code{deftaylor} den Ausdruck @var{expr_i} als die Taylorreihe um den Nullpunkt.
@var{expr_i} ist typischerweise ein Polynom in der Variable @var{x_i} oder eine 
Summe.  @code{deftaylor} akzeptiert aber auch allgemeinere Ausdr@"ucke.

@c @code{powerseries(@var{f_i}(@var{x_i}), @var{x_i}, 0)}
@c returns the series defined by @code{deftaylor}.

@code{powerseries(@var{f_i}(@var{x_i}), @var{x_i}, 0)} gibt die Reihe zur@"uck, 
die mit @code{deftaylor} definiert wurde.

@c @code{deftaylor} returns a list of the functions @var{f_1}, ..., @var{f_n}.
@c @code{deftaylor} evaluates its arguments.

@code{deftaylor} gibt eine Liste der Funktionen @var{f_1}, @dots{}, @var{f_n} 
zur@"uck.  @code{deftaylor} wertet die Argumente aus.

Beispiele:

@c ===beg===
@c deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
@c powerseries (f(x), x, 0);
@c taylor (exp (sqrt (f(x))), x, 0, 4);
@c ===end===
@example
(%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
(%o1)                          [f]
(%i2) powerseries (f(x), x, 0);
                      inf
                      ====      i1
                      \        x         2
(%o2)                  >     -------- + x
                      /       i1    2
                      ====   2   i1!
                      i1 = 4
(%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                      2         3          4
                     x    3073 x    12817 x
(%o3)/T/     1 + x + -- + ------- + -------- + . . .
                     2     18432     307200
@end example
@end deffn

@c --- 07.01.2011 DK -----------------------------------------------------------
@anchor{maxtayorder}
@defvr {Optionsvariable} maxtayorder
Standardwert: @code{true}

@c REPHRASE
@c When @code{maxtayorder} is @code{true}, then during algebraic manipulation of 
@c (truncated) Taylor series, @code{taylor} tries to retain as many terms as are 
@c known to be correct.

Hat @code{maxtayorder} den Wert @code{true}, werden bei der algebraischen
Manipulation von Taylor-Reihen, von der Funktion @code{taylor} so viele
Terme wie m@"oglich mitgef@"uhrt.
@end defvr

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{pade}
@deffn {Funktion} pade (@var{taylor_series}, @var{numer_deg_bound}, @var{denom_deg_bound})

@c Returns a list of all rational functions which have the given Taylor series 
@c expansion where the sum of the degrees of the numerator and the denominator 
@c is less than or equal to the truncation level of the power series, i.e. are 
@c "best" approximants, and which additionally satisfy the specified degree 
@c bounds.

Gibt eine Liste aller rationalen Funktionen zur@"uck, die die angegebene
Taylor-Reihenentwicklung haben und deren Summe des Nennergrads und des
Z@"ahlergrads kleiner oder gleich des Grads der Reihenentwicklung ist.

@c @var{taylor_series} is a univariate Taylor series. @var{numer_deg_bound} and 
@c @var{denom_deg_bound} are positive integers specifying degree bounds on
@c the numerator and denominator.

Das Argument @var{taylor_series} ist eine Taylor-Reihe in einer Variablen.  
Die Argumente @var{numer_deg_bound} und @var{denom_deg_bound} sind positive
ganze Zahlen, die eine Grenze f@"ur den Nennergrad und den Z@"ahlergrad der
rationalen Funktion angeben.

@c @var{taylor_series} can also be a Laurent series, and the degree bounds can 
@c be @code{inf} which causes all rational functions whose total degree is less 
@c than or equal to the length of the power series to be returned.  Total degree
@c is defined as @code{@var{numer_deg_bound} + @var{denom_deg_bound}}. Length of
@c a power series is defined as @code{"truncation level" + 1 - min(0, "order of
@c series")}.

Die Taylor-Reihe kann auch eine Laurent-Reihe sein und die Grenzen f@"ur den 
Grad k@"onnen @code{inf} sein.

Beispiele:

@c ===beg===
@c taylor (1 + x + x^2 + x^3, x, 0, 3);
@c pade (%, 1, 1);
@c t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
@c              + 387072*x^7 + 86016*x^6 - 1507328*x^5
@c              + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
@c              + 67108864*x - 134217728)
@c    /134217728, x, 0, 10);
@c pade (t, 4, 4);
@c ===end===
@example
(%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                              2    3
(%o1)/T/             1 + x + x  + x  + . . .
(%i2) pade (%, 1, 1);
                                 1
(%o2)                       [- -----]
                               x - 1
(%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                   + 387072*x^7 + 86016*x^6 - 1507328*x^5
                   + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                   + 67108864*x - 134217728)
         /134217728, x, 0, 10);
                    2    3       4       5       6        7
             x   3 x    x    15 x    23 x    21 x    189 x
(%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
             2    16    32   1024    2048    32768   65536

                                  8         9          10
                            5853 x    2847 x    83787 x
                          + ------- + ------- - --------- + . . .
                            4194304   8388608   134217728
(%i4) pade (t, 4, 4);
(%o4)                          []
@end example

@c There is no rational function of degree 4 numerator/denominator, with this
@c power series expansion.  You must in general have degree of the numerator and
@c degree of the denominator adding up to at least the degree of the power 
@c series, in order to have enough unknown coefficients to solve.

Es gibt keine rationale Funktion des Grads 4 im Z@"ahler und Nenner f@"ur die
oben angegebene Taylor-Reihenentwicklung.  Die Summe des Z@"ahlergrads und des 
Nennergrads m@"ussen mindestens gleich dem Grad der Reihenentwicklung sein. 
In diesem Fall ist der Grad der Taylor-Reihenentwicklung @code{10}.

@c ===beg===
@c pade (t, 5, 5);
@c ===end===
@example
(%i5) pade (t, 5, 5);
@group
                     5                4                 3
(%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                  2
 - 1619100813312 x  - 2176885157888 x - 2386516803584)

               5                 4                  3
/(47041365435 x  + 381702613848 x  + 1360678489152 x

                  2
 + 2856700692480 x  + 3370143559680 x + 2386516803584)]
@end group
@end example
@end deffn

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{powerseries}
@deffn {Funktion} powerseries (@var{expr}, @var{x}, @var{a})

@c Returns the general form of the power series expansion for @var{expr} in the 
@c variable @var{x} about the point @var{a} (which may be @code{inf} for 
@c infinity):

Gibt die allgemeine Form einer Reihenentwicklung f@"ur den Ausdruck @var{expr} 
in der Variablen @var{x} um den Punkt @var{a} zur@"uck.  Das Argument @var{a} 
kann die Werte @code{inf} oder @code{infinity} haben:

@example
           inf
           ====
           \               n
            >    b  (x - a)
           /      n
           ====
           n = 0
@end example

@c If @code{powerseries} is unable to expand @var{expr}, @code{taylor} may give
@c the first several terms of the series.

Kann die Funktion @code{powerseries} keine Reihenentwicklung f@"ur den Ausdruck
@var{expr} finden, ist es m@"oglich, mit der Funktion @code{taylor} die ersten 
Terme der Reihenentwicklung auszugeben.

@c When @code{verbose} is @code{true}, @code{powerseries} prints progress 
@c messages.

Hat die Optionsvariable @code{verbose} den Wert @code{true}, werden Meldungen
von der Funktion @code{powerseries} angezeigt.

Beispiel:

@c ===beg===
@c verbose: true$
@c powerseries (log(sin(x)/x), x, 0);
@c ===end===
@example
(%i1) verbose: true$

(%i2) powerseries (log(sin(x)/x), x, 0);
trigreduce: can't expand                            
                 log(sin(x))

trigreduce: try again after applying the rule:
                                 d
                               / -- (sin(x))
                               [ dx
                 log(sin(x)) = I ----------- dx
                               ]   sin(x)
                               /


powerseries: first simplification returned
@group
                                /
                                [
                     - log(x) + I cot(x) dx
                                ]
                                /
@end group

           inf
           ====        i1  - 1 + 2 i1             2 i1
           \      (- 1)   2           bern(2 i1) x
(%o2)       >     ------------------------------------
           /                   i1 (2 i1)!
           ====
           i1 = 1
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{psexpand}
@defvr {Option variable} psexpand
Default value: @code{false}

When @code{psexpand} is @code{true},
an extended rational function expression is displayed fully expanded.
The switch @code{ratexpand} has the same effect.

@c WE NEED TO BE EXPLICIT HERE
When @code{psexpand} is @code{false},
a multivariate expression is displayed just as in the rational function package.

@c TERMS OF WHAT ??
When @code{psexpand} is  @code{multi},
then terms with the same total degree in the variables are grouped together.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{revert}
@anchor{revert2}
@deffn  {Function} revert (@var{expr}, @var{x})
@deffnx {Function} revert2 (@var{expr}, @var{x}, @var{n})

These functions return the reversion of @var{expr}, a Taylor series about zero 
in the variable @var{x}. @code{revert} returns a polynomial of degree equal to 
the highest power in @var{expr}. @code{revert2} returns a polynomial of degree 
@var{n}, which may be greater than, equal to, or less than the degree of 
@var{expr}.

@code{load ("revert")} loads these functions.

Examples:

@example
(%i1) load ("revert")$
(%i2) t: taylor (exp(x) - 1, x, 0, 6);
                   2    3    4    5     6
                  x    x    x    x     x
(%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                  2    6    24   120   720
(%i3) revert (t, x);
               6       5       4       3       2
           10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
(%o3)/R/ - --------------------------------------------
                                60
(%i4) ratexpand (%);
                     6    5    4    3    2
                    x    x    x    x    x
(%o4)             - -- + -- - -- + -- - -- + x
                    6    5    4    3    2
(%i5) taylor (log(x+1), x, 0, 6);
                    2    3    4    5    6
                   x    x    x    x    x
(%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                   2    3    4    5    6
(%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
(%o6)                           0
(%i7) revert2 (t, x, 4);
                          4    3    2
                         x    x    x
(%o7)                  - -- + -- - -- + x
                         4    3    2
@end example
@end deffn

@c --- 09.01.2011 DK -----------------------------------------------------------
@anchor{taylor}
@deffn  {Funktion} taylor (@var{expr}, @var{x}, @var{a}, @var{n})
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{x_2}, @dots{}], @var{a}, @var{n})
@deffnx {Funktion} taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{x_2}, @dots{}], [@var{a_1}, @var{a_2}, @dots{}], [@var{n_1}, @var{n_2}, @dots{}])
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], @dots{})

@c @code{taylor (@var{expr}, @var{x}, @var{a}, @var{n})} expands the expression 
@c @var{expr} in a truncated Taylor or Laurent series in the variable @var{x}
@c around the point @var{a}, containing terms through @code{(@var{x} - 
@c @var{a})^@var{n}}.

@code{taylor(@var{expr}, @var{x}, @var{a}, @var{n})} entwickelt den Ausdruck
@var{expr} in eine Taylor- oder Laurent-Reihentwicklung in der Variablen @var{x}
um den Punkt @var{a}, die die Terme bis zur Ordnung @code{(@var{x} - 
@var{a})^@var{n}} enth@"alt.

@c If @var{expr} is of the form @code{@var{f}(@var{x})/@var{g}(@var{x})} and 
@c @code{@var{g}(@var{x})} has no terms up to degree @var{n} then @code{taylor} 
@c attempts to expand @code{@var{g}(@var{x})} up to degree @code{2 @var{n}}. If 
@c there are still no nonzero terms, @code{taylor} doubles the degree of the 
@c expansion of @code{@var{g}(@var{x})} so long as the degree of the expansion is 
@c less than or equal to @code{@var{n} 2^taylordepth}.

Hat der Ausdruck @var{expr} die Form @code{@var{f}(@var{x})/@var{g}(@var{x})}
und hat @code{@var{g}(@var{x})} keine Terme bis zur Ordnung @var{n}, dann 
versucht @code{taylor} den Ausdruck @code{@var{g}(@var{x})} bis zur Ordnung
@code{2 @var{n}} zu entwickeln.  Treten in der Entwicklung weiterhin keine
von Null verschiedenen Terme auf, verdoppelt @code{taylor} die Ordnung der
Entwicklung f@"ur @code{@var{g}(@var{x})} so lange, wie die Ordnung kleiner 
oder gleich @code{@var{n} 2^taylordepth} ist.

@c @code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})}
@c returns a truncated power series of degree @var{n} in all variables 
@c @var{x_1}, @var{x_2}, ... about the point @code{(@var{a}, @var{a}, ...)}.

@code{taylor(@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})} gibt
die Reihenentwicklung der Ordung n in allen Variablen @var{x_1}, @var{x_2}, 
@dots{} um den Punkt @code{(@var{a}, @var{a}, ...)} zur@"uck.

@c @code{taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, 
@c @var{a_2}, @var{n_2}], ...)} returns a truncated power series in the 
@c variables @var{x_1}, @var{x_2}, ... about the point @code{(@var{a_1}, 
@c @var{a_2}, ...)}, truncated at @var{n_1}, @var{n_2}, ....
@c @code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, 
@c @var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])} returns a truncated power 
@c series in the variables @var{x_1}, @var{x_2}, ... about the point 
@c @code{(@var{a_1}, @var{a_2}, ...)}, truncated at @var{n_1}, @var{n_2}, ....

Die beiden folgenden @"aquivalenten Kommandos @code{taylor(@var{expr}, 
[@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], ...)} und 
@code{taylor (@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, 
@var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])} geben eine Reihenentwicklung 
f@"ur die Variablen @var{x_1}, @var{x_2}, @dots{} um den Punkt @code{(@var{a_1},
@var{a_2}, ...)} mit den Ordnungen @var{n_1}, @var{n_2}, @dots{} zur@"uck.

@c @code{taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])} returns an 
@c expansion of @var{expr} in negative powers of @code{@var{x} - @var{a}}. The 
@c highest order term is @code{(@var{x} - @var{a})^@var{-n}}.

@code{taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])} entwickelt den 
Ausdruck @var{expr} in negativen Potenzen von @code{@var{x} - @var{a}}.  Der
Term mit der gr@"o@ss{}ten Ordnung ist @code{(@var{x} - @var{a})^@var{-n}}.

@c When @code{maxtayorder} is @code{true}, then during algebraic manipulation of 
@c (truncated) Taylor series, @code{taylor} tries to retain as many terms as are 
@c known to be correct.

Hat @code{maytayorder} den Wert @code{true}, werden bei der algebraischen
Manipulation von Taylor-Reihen, von der Funktion @code{taylor} so viele korrekte
Terme wie m@"oglich mitgef@"uhrt.

@c TODO: UEBERSETZUNG DES FOLGENDEN FEHLT.

When @code{psexpand} is @code{true}, an extended rational function expression 
is displayed fully expanded. The switch @code{ratexpand} has the same effect.
When @code{psexpand} is @code{false}, a multivariate expression is displayed 
just as in the rational function package. When @code{psexpand} is  @code{multi},
then terms with the same total degree in the variables are grouped together.

@c See also the @code{taylor_logexpand} switch for controlling expansion.

Siehe auch @mrefcomma{taylor_logexpand} um eine Reihenentwicklung zu 
kontrollieren.

Beispiele:

@c ===beg===
@c taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
@c %^2;
@c taylor (sqrt (x + 1), x, 0, 5);
@c %^2;
@c product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
@c ev (taylor(%, x,  0, 3), keepfloat);
@c taylor (1/log (x + 1), x, 0, 3);
@c taylor (cos(x) - sec(x), x, 0, 5);
@c taylor ((cos(x) - sec(x))^3, x, 0, 5);
@c taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
@c taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
@c taylor ((x + 1)^n, x, 0, 4);
@c taylor (sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (sin (y + x), [x, y], 0, 3);
@c taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
@c taylor (1/sin (y + x), [x, y], 0, 3);
@c ===end===
@example
(%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                           2             2
             (a + 1) x   (a  + 2 a + 1) x
(%o1)/T/ 1 + --------- - -----------------
                 2               8

                                   3      2             3
                               (3 a  + 9 a  + 9 a - 1) x
                             + -------------------------- + . . .
                                           48
(%i2) %^2;
                                    3
                                   x
(%o2)/T/           1 + (a + 1) x - -- + . . .
                                   6
(%i3) taylor (sqrt (x + 1), x, 0, 5);
                       2    3      4      5
                  x   x    x    5 x    7 x
(%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                  2   8    16   128    256
(%i4) %^2;
(%o4)/T/                  1 + x + . . .
(%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                         inf
                        /===\
                         ! !    i     2.5
                         ! !  (x  + 1)
                         ! !
                        i = 1
(%o5)                   -----------------
                              2
                             x  + 1
(%i6) ev (taylor(%, x,  0, 3), keepfloat);
                               2           3
(%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
(%i7) taylor (1/log (x + 1), x, 0, 3);
                               2       3
                 1   1   x    x    19 x
(%o7)/T/         - + - - -- + -- - ----- + . . .
                 x   2   12   24    720
(%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                4
                           2   x
(%o8)/T/                - x  - -- + . . .
                               6
(%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
(%o9)/T/                    0 + . . .
(%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                               2          4
            1     1       11      347    6767 x    15377 x
(%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
             6      4        2   15120   604800    7983360
            x    2 x    120 x

                                                          + . . .
(%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
               2  2       4      2   4
              k  x    (3 k  - 4 k ) x
(%o11)/T/ 1 - ----- - ----------------
                2            24

                                    6       4       2   6
                               (45 k  - 60 k  + 16 k ) x
                             - -------------------------- + . . .
                                          720
(%i12) taylor ((x + 1)^n, x, 0, 4);
                      2       2     3      2         3
                    (n  - n) x    (n  - 3 n  + 2 n) x
(%o12)/T/ 1 + n x + ----------- + --------------------
                         2                 6

                               4      3       2         4
                             (n  - 6 n  + 11 n  - 6 n) x
                           + ---------------------------- + . . .
                                          24
(%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
               3                 2
              y                 y
(%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
              6                 2

                    3                       2
               y   y            2      1   y            3
          + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
               2   12                  6   12
(%i14) taylor (sin (y + x), [x, y], 0, 3);
                     3        2      2      3
                    x  + 3 y x  + 3 y  x + y
(%o14)/T/   y + x - ------------------------- + . . .
                                6
(%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
          1   y              1    1               1            2
(%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
          y   6               2   6                3
                             y                    y

                                           1            3
                                      + (- -- + . . .) x  + . . .
                                            4
                                           y
(%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                             3         2       2        3
            1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
(%o16)/T/ ----- + ----- + ------------------------------- + . . .
          x + y     6                   360
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylordepth}
@defvr {Option variable} taylordepth
Default value: 3

@c UM, THE CONTEXT FOR THIS REMARK NEEDS TO BE ESTABLISHED
If there are still no nonzero terms, @code{taylor} doubles the degree of the 
expansion of @code{@var{g}(@var{x})} so long as the degree of the expansion is 
less than or equal to @code{@var{n} 2^taylordepth}.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylorinfo}
@deffn {Function} taylorinfo (@var{expr})

Returns information about the Taylor series @var{expr}. The return value is a 
list of lists. Each list comprises the name of a variable, the point of 
expansion, and the degree of the expansion.

@code{taylorinfo} returns @code{false} if @var{expr} is not a Taylor series.

Example:

@example
(%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                  2                       2
(%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

         2                        2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   3
 + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
(%i2) taylorinfo(%);
(%o2)               [[y, a, inf], [x, 0, 3]]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylorp}
@deffn {Function} taylorp (@var{expr})

Returns @code{true} if @var{expr} is a Taylor series, and @code{false} 
otherwise.
@end deffn

@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@anchor{taylor_logexpand}
@defvr {Option variable} taylor_logexpand
Default value: @code{true}

@code{taylor_logexpand} controls expansions of logarithms in @code{taylor} 
series.

When @code{taylor_logexpand} is @code{true}, all logarithms are expanded fully 
so that zero-recognition problems involving logarithmic identities do not
disturb the expansion process.  However, this scheme is not always
mathematically correct since it ignores branch information.

When @code{taylor_logexpand} is set to @code{false}, then the only expansion of 
logarithms that occur is that necessary to obtain a formal power series.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_order_coefficients}
@defvr {Option variable} taylor_order_coefficients
Default value: @code{true}

@code{taylor_order_coefficients} controls the ordering of coefficients in a 
Taylor series.

When @code{taylor_order_coefficients} is @code{true}, coefficients of taylor 
series are ordered canonically.
@c IS MAXIMA'S NOTION OF "CANONICALLY" DESCRIBED ELSEWHERE ??
@c AND WHAT HAPPENS WHEN IT IS FALSE ??
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taylor_simplifer}
@deffn {Function} taylor_simplifier (@var{expr})

Simplifies coefficients of the power series @var{expr}. @code{taylor} calls 
this function.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{taylor_truncate_polynomials}
@defvr {Option variable} taylor_truncate_polynomials
Default value: @code{true}

@c WHAT IS THE "INPUT TRUNCATION LEVEL" ?? THE ARGUMENT n OF taylor ??
When @code{taylor_truncate_polynomials} is @code{true}, polynomials are 
truncated based upon the input truncation levels.

Otherwise, polynomials input to @code{taylor} are considered to have infinite 
precison.
@c WHAT IS "INFINITE PRECISION" IN THIS CONTEXT ??
@end defvr

@c -----------------------------------------------------------------------------
@anchor{taytorat}
@deffn {Function} taytorat (@var{expr})

Converts @var{expr} from @code{taylor} form to canonical rational expression 
(CRE) form. The effect is the same as @code{rat (ratdisrep (@var{expr}))}, but 
faster.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{trunc}
@deffn {Function} trunc (@var{expr})

Annotates the internal representation of the general expression @var{expr}
so that it is displayed as if its sums were truncated Taylor series.
@var{expr} is not otherwise modified.

Example:

@example
(%i1) expr: x^2 + x + 1;
                            2
(%o1)                      x  + x + 1
(%i2) trunc (expr);
                                2
(%o2)                  1 + x + x  + . . .
(%i3) is (expr = trunc (expr));
(%o3)                         true
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{verbose}
@defvr {Option variable} verbose
Default value: @code{false}

When @code{verbose} is @code{true}, @code{powerseries} prints progress messages.
@end defvr

@c -----------------------------------------------------------------------------
@node Poisson Reihen, Kettenbr@"uche, Funktionen und Variablen f@"ur Reihen, Summen Produkte und Reihen
@section Poisson Reihen

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{intopois}
@deffn {Function} intopois (@var{a})

Converts @var{a} into a Poisson encoding.
@end deffn

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{outofpois}
@deffn {Function} outofpois (@var{a})

Converts @var{a} from Poisson encoding to general representation.  If @var{a} 
is not in Poisson form, @code{outofpois} carries out the conversion, i.e., 
the return value is @code{outofpois (intopois (@var{a}))}. This function is 
thus a canonical simplifier for sums of powers of sine and cosine terms of a 
particular type.
@end deffn

@c NEED MORE INFO HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{poisdiff}
@deffn {Function} poisdiff (@var{a}, @var{b})

Differentiates @var{a} with respect to @var{b}. @var{b} must occur only
in the trig arguments or only in the coefficients.
@end deffn

@c LOOKING AT THE CODE IN src/pois3.lisp, THIS FCN SEEMS TO COMPUTE THE EXPONENT
@c BY MULTIPLYING IN A LOOP
@c DUNNO HOW WE WANT TO EXPLAIN THAT
@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisexpt}
@deffn {Function} poisexpt (@var{a}, @var{b})

Functionally identical to @code{intopois (@var{a}^@var{b})}. @var{b} must be a
positive integer.
@end deffn

@c WHAT IS THIS ABOUT ??

@c -----------------------------------------------------------------------------
@anchor{poisint}
@deffn {Function} poisint (@var{a}, @var{b})

Integrates in a similarly restricted sense (to @code{poisdiff}).  Non-periodic 
terms in @var{b} are dropped if @var{b} is in the trig arguments.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poislim}
@defvr {Option variable} poislim
Default value: 5

@code{poislim} determines the domain of the coefficients in the arguments of 
the trig functions.  The initial value of 5 corresponds to the interval 
[-2^(5-1)+1,2^(5-1)], or [-15,16], but it can be set to [-2^(n-1)+1, 2^(n-1)].
@end defvr

@c UMM, WHAT IS THIS ABOUT EXACTLY ?? EXAMPLES NEEDED

@c -----------------------------------------------------------------------------
@anchor{poismap}
@deffn {Function} poismap (@var{series}, @var{sinfn}, @var{cosfn})

will map the functions @var{sinfn} on the sine terms and @var{cosfn} on the 
cosine terms of the Poisson series given. @var{sinfn} and @var{cosfn} are 
functions of two arguments which are a coefficient and a trigonometric part 
of a term in series respectively.
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisplus}
@deffn {Function} poisplus (@var{a}, @var{b})

Is functionally identical to @code{intopois (a + b)}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poissimp}
@deffn {Function} poissimp (@var{a})

Converts @var{a} into a Poisson series for @var{a} in general representation.
@end deffn

@c MORE INFO NEEDED HERE

@c -----------------------------------------------------------------------------
@anchor{poisson}
@defvr {Special symbol} poisson

The symbol @code{/P/} follows the line label of Poisson series expressions.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{poissubst}
@deffn {Function} poissubst (@var{a}, @var{b}, @var{c})

Substitutes @var{a} for @var{b} in @var{c}.  @var{c} is a Poisson series.

(1) Where @var{B} is a variable @var{u}, @var{v}, @var{w}, @var{x}, @var{y}, or 
@var{z}, then @var{a} must be an expression linear in those variables (e.g., 
@code{6*u + 4*v}).

(2) Where @var{b} is other than those variables, then @var{a} must also be
free of those variables, and furthermore, free of sines or cosines.

@code{poissubst (@var{a}, @var{b}, @var{c}, @var{d}, @var{n})} is a special 
type of substitution which operates on @var{a} and @var{b} as in type (1) above,
but where @var{d} is a Poisson series, expands @code{cos(@var{d})} and 
@code{sin(@var{d})} to order @var{n} so as to provide the result of substituting
@code{@var{a} + @var{d}} for @var{b} in @var{c}.  The idea is that @var{d} is an
expansion in terms of a small parameter.  For example,
@code{poissubst (u, v, cos(v), %e, 3)} yields @code{cos(u)*(1 - %e^2/2) - 
sin(u)*(%e - %e^3/6)}.
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poistimes}
@deffn {Function} poistimes (@var{a}, @var{b})

Is functionally identical to @code{intopois (@var{a}*@var{b})}.
@end deffn

@c HOW DOES THIS WORK ?? NEED MORE INFO AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{poistrim}
@deffn {Function} poistrim ()

is a reserved function name which (if the user has defined it) gets applied 
during Poisson multiplication.  It is a predicate function of 6 arguments which 
are the coefficients of the @var{u}, @var{v}, ..., @var{z} in a term.  Terms 
for which @code{poistrim} is @code{true} (for the coefficients of that term) 
are eliminated during multiplication.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printpois}
@deffn {Function} printpois (@var{a})

Prints a Poisson series in a readable format.  In common with @code{outofpois}, 
it will convert @var{a} into a Poisson encoding first, if necessary.
@end deffn

@c -----------------------------------------------------------------------------
@node Kettenbr@"uche, , Poisson Reihen, Summen Produkte und Reihen
@section Kettenbr@"uche
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{cf}
@deffn {Function} cf (@var{expr})

Converts @var{expr} into a continued fraction. @var{expr} is an expression
comprising continued fractions and square roots of integers. Operands in the 
expression may be combined with arithmetic operators. Aside from continued 
fractions and square roots, factors in the expression must be integer or 
rational numbers. Maxima does not know about operations on continued fractions 
outside of @code{cf}.

@code{cf} evaluates its arguments after binding @code{listarith} to 
@code{false}. @code{cf} returns a continued fraction, represented as a list.

A continued fraction @code{a + 1/(b + 1/(c + ...))} is represented by the list 
@code{[a, b, c, ...]}. The list elements @code{a}, @code{b}, @code{c}, ... must 
evaluate to integers. @var{expr} may also contain @code{sqrt (n)} where @code{n} 
is an integer. In this case @code{cf} will give as many terms of the continued 
fraction as the value of the variable @code{cflength} times the period.

A continued fraction can be evaluated to a number by evaluating the arithmetic 
representation returned by @code{cfdisrep}. See also @code{cfexpand} for another 
way to evaluate a continued fraction.

See also @code{cfdisrep}, @code{cfexpand}, and @code{cflength}.

Examples:

@itemize @bullet
@item
@var{expr} is an expression comprising continued fractions and square roots of integers.

@example
(%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
(%o1)               [59, 17, 2, 1, 1, 1, 27]
(%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
(%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]
@end example

@item
@code{cflength} controls how many periods of the continued fraction
are computed for algebraic, irrational numbers.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example

@item
A continued fraction can be evaluated by evaluating the arithmetic representation
returned by @code{cfdisrep}.

@example
(%i1) cflength: 3$
(%i2) cfdisrep (cf (sqrt (3)))$
(%i3) ev (%, numer);
(%o3)                   1.731707317073171
@end example

@item
Maxima does not know about operations on continued fractions outside of @code{cf}.

@example
(%i1) cf ([1,1,1,1,1,2] * 3);
(%o1)                     [4, 1, 5, 2]
(%i2) cf ([1,1,1,1,1,2]) * 3;
(%o2)                  [3, 3, 3, 3, 3, 6]
@end example

@end itemize
@end deffn

@c NEEDS CLARIFICATION -- MAKE EXPLICIT HOW list IS RELATED TO a, b, c, ...
@c ALSO, CAN list CONTAIN ANYTHING OTHER THAN LITERAL INTEGERS ??

@c -----------------------------------------------------------------------------
@deffn {Function} cfdisrep (@var{list})

Constructs and returns an ordinary arithmetic expression
of the form @code{a + 1/(b + 1/(c + ...))}
from the list representation of a continued fraction @code{[a, b, c, ...]}.

@example
(%i1) cf ([1, 2, -3] + [1, -2, 1]);
(%o1)                     [1, 1, 1, 2]
(%i2) cfdisrep (%);
                                  1
(%o2)                     1 + ---------
                                    1
                              1 + -----
                                      1
                                  1 + -
                                      2
@end example
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} cfexpand (@var{x})

Returns a matrix of the numerators and denominators of the
last (column 1) and next-to-last (column 2) convergents of the continued fraction @var{x}.

@example
(%i1) cf (rat (ev (%pi, numer)));

`rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
(%o1)                  [3, 7, 15, 1, 292]
(%i2) cfexpand (%); 
                         [ 103993  355 ]
(%o2)                    [             ]
                         [ 33102   113 ]
(%i3) %[1,1]/%[2,1], numer;
(%o3)                   3.141592653011902
@end example
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} cflength
Default value: 1

@code{cflength} controls the number of terms of the continued
fraction the function @code{cf} will give, as the value @code{cflength} times the
period.  Thus the default is to give one period.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example
@end defvr

@c --- End of file Series.de.texi ----------------------------------------------

