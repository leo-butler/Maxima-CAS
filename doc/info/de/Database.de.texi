@c -----------------------------------------------------------------------------
@c File        : Declarations.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Translation : Dr. Dieter Kaiser
@c Date        : 22.10.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Maximas Datenbank::
* Funktionen und Variablen f@"ur Eigenschaften::
* Funktionen und Variablen f@"ur Fakten::
* Funktionen und Variablen f@"ur Aussagen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Maximas Datenbank, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank, Maximas Datenbank
@section Einf@"uhrung in Maximas Datenbank

@subheading Eigenschaften

Variablen und Funktionen k@"onnen mit der Funktion @code{declare} Eigenschaften
zugewiesen werden. Diese Eigenschaften werden in eine Datenbank abgelegt oder 
in eine von Lisp bereitgestellte Eigenschaftsliste eingetragen.

@noindent
Variablen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden:

@verbatim
   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex
@end verbatim

@noindent
Funktionen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden:

@verbatim
   increasing     decreasing
   posfun         integervalued
@end verbatim

@noindent
Die folgenden Eigenschaften k@"onnen f@"ur Funktionen definiert werden und wirken
sich auf die Vereinfachung dieser Funktionen aus:

@verbatim
   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
@end verbatim

@noindent
Weitere Eigenschaften, die Variablen und Funktionen erhalten k@"onnen, sind:

@verbatim
   bindtest       feature        alphabetic
   scalar         nonscalar
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Eigenschaften, Funktionen und Variablen f@"ur Fakten, Einf@"uhrung in Maximas Datenbank, Maximas Datenbank
@section Funktionen und Variablen f@"ur Eigenschaften

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{alphabetic}
@defvr {Eigenschaft} alphabetic

@c @code{alphabetic} is a declaration type recognized by @code{declare}.
@c The expression @code{declare(@var{s}, alphabetic)} tells Maxima to recognize
@c as alphabetic all of the characters in @var{s}, which must be a string.

@c See also @ref{Identifiers}.

Das Kommando @code{declare(s, alphabetic)} deklariert alle Zeichen der 
Zeichenkette @var{s} als alphabetisch. Das Argument @var{s} muss eine 
Zeichenkette sein. Siehe auch @mrefdot{Bezeichner}

Beispiele:

@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

@c @opencatbox
@c @category{Declarations and inferences}
@c @closecatbox
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{bindtest}
@deffn {Eigenschaft} bindtest

@c Tells Maxima to trigger an error when @var{a_i} is evaluated unbound.

Hat ein Symbol @var{x} die Eigenschaft @code{bindtest} und wird es ausgewertet,
ohne das dem Symbol bisher ein Wert zugewiesen wurde, signalisiert Maxima einen 
Fehler. Siehe @mrefdot{declare}

@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constant}
@deffn {Eigenschaft} constant

@c @code{declare (@var{a}, constant)} declares @var{a} to be a constant.
@c See @code{declare}.
   @c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@code{declare(@var{a}, constant)} deklariert ein Symbol @var{a} als konstant.
Siehe @mrefdot{declare}

@c @opencatbox
@c @category{Deklarationen und Inferenzen} @category{Konstante}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constantp}
@deffn {Funktion} constantp (@var{expr})

@c Returns @code{true} if @var{expr} is a constant expression, otherwise returns
@c @code{false}.
   @c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Gibt f@"ur einen konstanten Ausdruck @var{expr} den Wert @code{true} zur@"uck,
andernfalls @code{false}.

@c An expression is considered a constant expression if its arguments are 
@c numbers (including rational numbers, as displayed with @code{/R/}), symbolic
@c constants such as @code{%pi}, @code{%e}, and @code{%i}, variables bound to a
@c constant or declared constant by @code{declare}, or functions whose arguments
@c are constant.

Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt, wenn seine 
Argumente Zahlen sind (einschlie@ss{}lich von Zahlen in einer CRE-Darstellung), 
symbolische Konstanten wie @code{%pi}, @code{%e} und @code{%i}, 
Variablen, die einen konstanten Wert haben oder die mit @code{declare} als 
konstant deklariert sind, oder Funktionen, deren Argumente konstant sind.

@c @code{constantp} evaluates its arguments.

Die Funktion @code{constantp} wertet ihre Argument aus.

Beispiele:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===
@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example

@c @opencatbox
@c @category{Aussagefunktionen} @category{Konstante}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{declare}
@deffn {Funktion} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, ...)

@c Assigns the atom or list of atoms @var{a_i} the property or list of 
@c properties @var{p_i}. When @var{a_i} and/or @var{p_i} are lists, each of the 
@c atoms gets all of the properties.

Weist dem Atom oder den Atomen einer Liste @var{a_i} die Eigenschaft oder die 
Eigenschaften in einer Liste @var{p_i} zu. Ist @var{a_i} und/oder @var{p_i} eine
Liste, erh@"alt jedes Atom die aufgef@"uhrten Eigenschaften.

@c @code{declare} quotes its arguments. @code{declare} always returns 
@c @code{done}.

Die Funktion @code{declare} wertet ihre Argumente nicht aus. @code{declare} gibt
stets @code{done} zur@"uck.

@c As noted in the description for each declaration flag, for some flags
@c @code{featurep(@var{object}, @var{feature})} returns @code{true} if 
@c @var{object} has been declared to have @var{feature}. However, 
@c @code{featurep} does not recognize some flags; this is a bug.

Wie in den folgenden Beschreibungen ausgef@"uhrt, gibt
@code{featurep(@var{object}, @var{feature})} f@"ur einige Schalter @code{true}
zur@"uck, wenn @var{object} die Eigenschaft @var{feature} erhalten hat.

@c @code{declare} recognizes the following properties:

Die Funktion @code{declare} kennt die folgenden Eigenschaften:

@table @asis

@c Makes @var{a_i} known to @code{ev} so that the function named by @var{a_i}
@c is applied when @var{a_i} appears as a flag argument of @code{ev}. 
@c See @code{evfun}.

@item @code{evfun}
Deklariert @var{a_i} als eine Auswertungsfunktion. Tritt die Funktion @var{a_i} 
als Argument der Funktion @code{ev} auf, so wird die Funktion angewendet. Siehe
@code{evfun}.

@c Makes @var{a_i} known to the @code{ev} function so that @var{a_i} is bound to
@c @code{true} during the execution of @code{ev} when @var{a_i} appears as a 
@c flag argument of @code{ev}. See @code{evflag}.

@item @code{evflag}
Deklariert @code{a_i} als ein Auswertungsflag. W@"ahrend der Auswertung von
@code{ev} erh@"alt das Auswertungsflag @code{a_i} den Wert @code{true}. Siehe 
@code{evflag}.

@c OBSOLETE @code{special} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)
@c OBSOLETE @code{nonarray} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)

@c Tells Maxima to trigger an error when @var{a_i} is evaluated unbound.

@item @code{bindtest}
Wird das Symbol @var{a_i} ausgewertet, ohne das dem Symbol bisher ein Wert
zugewiesen wurde, signalisiert Maxima einen Fehler.  

@c Tells Maxima to parse @var{a_i} as a noun. 
@c The effect of this is to replace instances of @var{a_i} with 
@c @code{'@var{a_i}} or @code{nounify(@var{a_i})}, depending on the context.

@item @code{noun}
@var{a_i} wird als Substantivform interpretiert. Abh@"angig vom Kontext wird 
@var{a_i} durch @code{'@var{a_i}} oder @code{nounify(@var{a_i})} ersetzt.

@c Tells Maxima to consider @var{a_i} a symbolic constant.
   @c WHAT MAXIMA KNOWS ABOUT SYMBOLIC CONSTANTS IS PRETTY LIMITED
   @c DUNNO IF WE WANT TO GET INTO DETAILS HERE. 
   @c MAYBE IN THE DOCUMENTATION FOR CONSTANT (IF THERE IS SUCH)

@item @code{constant}
@var{a_i} wird als eine symbolische Konstante interpretiert.

@c Tells Maxima to consider @var{a_i} a scalar variable.

@item @code{scalar}
@var{a_i} wird als skalare Variable interpretiert.

@c Tells Maxima to consider @var{a_i} a nonscalar variable. The usual 
@c application is to declare a variable as a symbolic vector or matrix.

@item @code{nonscalar}
@var{a_i} wird als eine nicht-skalare Variable interpretiert. @"Uberlicherweise
wird damit ein symbolischer Vektor oder eine Matrix deklariert.

@c Tells Maxima to consider @var{a_i} not an array. This declaration prevents
@c multiple evaluation of a subscripted variable name.

@item @code{nonarray}
@var{a_i} wird nicht als ein Array interpretiert. Diese Deklaration verhindert
die mehrfache Auswertung, wenn @var{a_i} als indizierte Variable genutzt wird.

@c Tells Maxima to consider @var{a_i} a "main variable". A main variable 
@c succeeds all other constants and variables in the canonical ordering of 
@c Maxima expressions, as determined by @code{ordergreatp}.

@item @code{mainvar}
@var{mainvar} wird als eine "Hauptvariable" interpretiert. Eine Hauptvariable
wird vor allen Konstanten und Variablen in einer kanonischen Ordnung eines
Maxima-Ausdr@"uckes angeordnet. Die Anordnung wird durch die Funktion 
@code{ordergreatp} bestimmt.

@c Tells Maxima to recognize all characters in @var{a_i} (which must be a 
@c string) as alphabetic characters.

@item @code{alphabetic}
@var{a_i} is ein String, dessen Zeichen von Maxima als alphabetische Zeichen 
interpretiert werden.

@c Tells Maxima to recognize @var{a_i} as the name of a feature. Other atoms 
@c may then be declared to have the @var{a_i} property.

@item @code{feature}
@var{a_i} wird als eine Eigenschaft @code{feature} interpretiert. Andere 
Symbole k@"onnen dann diese Eigenschaft erhalten.

@c Tells Maxima to recognize @var{a_i} as a right-associative or 
@c left-associative function.

@item @code{rassociative}, @code{lassociative}
@var{a_i} wird als eine rechts- oder links-assoziative Funktion interpretiert.

@c Tells Maxima to recognize @var{a_i} as an n-ary function.

@c The @code{nary} declaration is not the same as calling the @code{nary} 
@c function. The sole effect of @code{declare(foo, nary)} is to instruct the 
@c Maxima simplifier to flatten nested expressions, for example, to simplify 
@c @code{foo(x, foo(y, z))} to @code{foo(x, y, z)}.

@item @code{nary}
@var{a_i} wird als eine Nary-Funktion interpretiert.
Verschachtelte Ausdr@"ucke wie @code{foo(x, foo(y,z))} werden zu 
@code{foo(x, y, z)} vereinfacht. Die Deklaration @code{nary} unterscheidet sich
von der Funktion @code{nary}. W@"ahrend der Funktionsaufruf einen neuen Operator
definiert, wirkt sich die Deklaration nur auf die Vereinfachung aus.

@c Tells Maxima to recognize @var{a_i} as a symmetric or antisymmetric function.
@c @code{commutative} is the same as @code{symmetric}.

@item @code{symmetric}, @code{antisymmetric}, @code{commutative}
@var{a_i} wird als eine symmetrische, antisymmetrische oder kommutative Funktion
interpretiert. @code{commutative} und @code{symmtric} sind @"aquivalent.

@c Tells Maxima to recognize @var{a_i} as an odd or even function.

@item @code{oddfun}, @code{evenfun}
@var{a_i} wird als eine ungerade oder gerade Funktion interpretiert.

@c Tells Maxima to simplify @var{a_i} expressions by pulling constant factors 
@c out of the first argument.
@c When @var{a_i} has one argument, a factor is considered constant if it is a
@c literal or declared constant.
@c When @var{a_i} has two or more arguments, a factor is considered constant
@c if the second argument is a symbol and the factor is free of the second 
@c argument.

@item @code{outative}
Ausdr@"ucke mit der Funktion @var{a_i} werden so vereinfacht, dass konstante 
Faktoren aus dem Argument herausgezogen werden. Hat die Funktion @var{a_i} ein 
Argument, wird ein Faktor dann als konstant angesehen, wenn er ein Symbol oder 
eine deklarierte Konstante ist. Hat die Funktion @var{a_i} zwei oder mehr 
Argumente, wird ein Faktor dann als konstant angesehen, wenn das zweite Argument
ein Symbol und der Faktor unabh@"angig vom zweiten Argument ist.

@c Tells Maxima to simplify @var{a_i} expressions by the substitution 
@c @code{@var{a_i}(x * y * z * ...)} @code{-->} @code{@var{a_i}(x) * 
@c @var{a_i}(y) * @var{a_i}(z) * ...}. The substitution is carried out on the 
@c first argument only.

@item @code{multiplicative}
Ausdr@"ucke @code{@var{a_i}(x * y * z * ...)} werden durch @code{@var{a_i}(x) * 
@var{a_i}(y) * @var{a_i}(z) * ...} ersetzt. Die Ersetzung wird nur f@"ur das
Argument der Funktion @var{a_i} ausgef@"uhrt.

@c Tells Maxima to simplify @var{a_i} expressions by the substitution 
@c @code{@var{a_i}(x + y + z + ...)} @code{-->} @code{@var{a_i}(x) + 
@c @var{a_i}(y) + @var{a_i}(z) + ...}. The substitution is carried out on the 
@c first argument only.

@item @code{additive}
Ausdr@"ucke @code{@var{a_i}(x + y + z + ...)} werden  durch @code{@var{a_i}(x) + 
@var{a_i}(y) + @var{a_i}(z) + ...} ersetzt. Die Ersetzung wird nur f@"ur das 
Argument ausgef@"uhrt. 

@c Equivalent to declaring @var{a_i} both @code{outative} and @code{additive}.

@item @code{linear}
Entspricht der Deklaration einer Funktion als @code{outative} und 
@code{additive}.

@c OBSOLETE @code{analytic} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)

@c Tells Maxima to recognize @var{a_i} as an integer or noninteger variable.

@item @code{integer}, @code{noninteger}
@var{a_i} wird als eine ganzzahlige oder nichtganzzahlige Variable 
interpretiert.

@c Tells Maxima to recognize @var{a_i} as an even or odd integer variable.

@item @code{even}, @code{odd}
@var{a_i} wird als eine gerade oder ungerade ganze Zahl interpretiert.

@c Tells Maxima to recognize @var{a_i} as a rational or irrational real 
@c variable.

@item @code{rational}, @code{irrational}
@var{a_i} wird als eine rationale oder irrationale Zahl interpretiert.

@c Tells Maxima to recognize @var{a_i} as a real, pure imaginary, or complex 
@c variable.

@item @code{real}, @code{imaginary}, @code{complex}
@var{a_i} wird als eine reelle, imagin@"are oder komplexe Zahl interpretiert.

@c Tells Maxima to recognize @var{a_i} as an increasing or decreasing function.
   @c MAXIMA FAILS TO DEDUCE F(2) > F(1) FOR INCREASING FUNCTION F
   @c AND FAILS TO DEDUCE ANYTHING AT ALL ABOUT DECREASING FUNCTIONS
   @c REPORTED AS SF BUG # 1483194

@item @code{increasing}, @code{decreasing}
@var{a_i} wird als eine steigende oder fallende Funktion interpretiert.

@c Tells Maxima to recognize @var{a_i} as a positive function.

@item @code{posfun}
@var{a_i} wird als eine positive Funktion interpretiert.

@c Tells Maxima to recognize @var{a_i} as an integer-valued function.

@item @code{integervalued}
@var{a_i} wird als Funktion mit ganzzahligen Werten interpretiert.

@end table

Beispiele:

@code{evfun} und @code{evflag} Deklarationen.

@c ===beg===
@c declare (expand, evfun);
@c (a + b)^3;
@c (a + b)^3, expand;
@c declare (demoivre, evflag);
@c exp (a + b*%i);
@c exp (a + b*%i), demoivre;
@c ===end===
@example
(%i1) declare (expand, evfun);
(%o1)                         done
(%i2) (a + b)^3;
                                   3
(%o2)                       (b + a)
(%i3) (a + b)^3, expand;
                     3        2      2      3
(%o3)               b  + 3 a b  + 3 a  b + a
(%i4) declare (demoivre, evflag);
(%o4)                         done
(%i5) exp (a + b*%i);
                             %i b + a
(%o5)                      %e
(%i6) exp (a + b*%i), demoivre;
                      a
(%o6)               %e  (%i sin(b) + cos(b))
@end example

@code{bindtest} Deklaration.

@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example

@code{noun} Deklaration.

@c ===beg===
@c factor (12345678);
@c declare (factor, noun);
@c factor (12345678);
@c ''%, nouns;
@c ===end===
@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example

@code{alphabetic} Deklaration.

@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

@code{feature} Deklaration.

@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example

@code{nary} Deklaration.

@c ===beg===
@c H (H (a, b), H (c, H (d, e)));
@c declare (H, nary);
@c H (H (a, b), H (c, H (d, e)));
@c ===end===
@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example

@code{symmetric} und @code{antisymmetric} Deklarationen.

@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end example

@code{oddfun} und @code{evenfun} Deklarationen.

@c ===beg===
@c o (- u) + o (u);
@c declare (o, oddfun);
@c o (- u) + o (u);
@c e (- u) - e (u);
@c declare (e, evenfun);
@c e (- u) - e (u);
@c ===end===
@example
(%i1) o (- u) + o (u);
(%o1)                     o(u) + o(- u)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- u) + o (u);
(%o3)                           0
(%i4) e (- u) - e (u);
(%o4)                     e(- u) - e(u)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- u) - e (u);
(%o6)                           0
@end example

@code{outative} Deklaration.

@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end example

@code{multiplicative} Deklaration.

@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end example

@code{additive} Deklaration.

@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end example

@code{linear} Deklaration.

@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end example

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{feature}
@defvr {Eigenschaft} feature

@c Maxima understands two distinct types of features, system features and 
@c features which apply to mathematical expressions. See also @code{status} for 
@c information about system features. See also @code{features} and 
@c @code{featurep} for information about mathematical features.

Maxima kennt Systemeigenschaften und mathematische Eigenschaften, die Symbole 
und Ausdr@"ucke haben k@"onnen. F@"ur Systemeigenschaften siehe die Funktion 
@mrefdot{status} F@"ur mathematische Eigenschaften siehe die Funktionen
@mref{declare} und @mrefdot{featurep}

@c PROPERTIES, DECLARATIONS FALL UNDER THIS HEADING AS WELL
@c OTHER STUFF ??

@c @code{feature}  itself is not the name of a function or variable.

@code{feature} ist eine Eigenschaft, die ein Symbol @var{sym} mit der Funktion 
@code{declare} erhalten kann. In diesem Fall ist das Symbol selbst eine
Eigenschaft, so dass das Kommando @code{declare(x, sym)} einem Symobl @var{x}
die neu definierte Eigenschaft @code{sym} gibt.

@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{featurep}
@deffn {Funktion} featurep (@var{a}, @var{f})

@c Attempts to determine whether the object @var{a} has the feature @var{f} on 
@c the basis of the facts in the current database.  If so, it returns 
@c @code{true}, else @code{false}.

Stellt fest, ob das Symbol oder der Ausdruck @var{a} die Eigenschaft @var{f} 
hat. Maxima nutzt daf@"ur die Fakten der Datenbank und die definierten 
Eigenschaften f@"ur Symbole und Funktionen.

@c Note that @code{featurep} returns @code{false} when neither @var{f} nor the 
@c negation of @var{f} can be established.

@code{featurep} gibt sowohl f@"ur den Fall @code{false} zur@"uck, dass das 
Argument @var{a} nicht die Eigenschaft @var{f} hat, als auch f@"ur den Fall, 
dass Maxima dies nicht anhand der bekannten Fakten und Eigenschaften entscheiden
kann.

@c @code{featurep} evaluates its argument.

@code{featurep} wertet seine Argumente aus.

@c See also @code{declare} and @code{features}.

Siehe auch @mref{declare} und @mrefdot{featurep}.

Beispiele:

@example
(%i1) declare (j, even)$
(%i2) featurep (j, integer);
(%o2)                           true
@end example

@c @opencatbox
@c @category{Predicate functions} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{features}
@defvr {Systemvariable} features
Standardwert: @code{[]}

@c Maxima recognizes certain mathematical properties of functions and variables.
@c These are called "features".

Maxima erkennt spezielle mathematische Eigenschaften von Funktionen und 
Variablen.

@c @code{declare (@var{x}, @var{foo})} gives the property @var{foo} to the 
@c function or variable @var{x}.

@code{declare(@var{x})}, @var{foo} gibt der Funktion oder Variablen @var{x} die
Eigenschaft @var{foo}.

@c @code{declare (@var{foo}, feature)} declares a new feature @var{foo}. For 
@c example, @code{declare ([red, green, blue], feature)} declares three new 
@c features, @code{red}, @code{green}, and @code{blue}.

@code{declare(@var{foo}, feature)} deklariert die neue Eigenschaft @var{foo}. 
Zum  Beispiel deklariert @code{declare([red, green, blue], feature)} die drei 
neuen Eigenschaften @code{red}, @code{green} und @code{blue}.
 
@c The predicate @code{featurep (@var{x}, @var{foo})} returns @code{true} if 
@c @var{x} has the @var{foo} property, and @code{false} otherwise.

@code{featurep(@var{x}, @var{foo})} hat die R@"uckgabe @code{true}, wenn @var{x} 
die Eigenschaft @var{foo} hat. Ansonsten wird @code{false} zur@"uckgegeben.

@c The infolist @code{features} is a list of known features. These are

Die Informationsliste @code{features} enth@"alt eine Liste der Eigenschaften, 
die Funktionen und Variablen erhalten k@"onnen und in die Datenbank eingetragen 
werden:

@flushleft
@code{integer}, @code{noninteger}, @code{even}, @code{odd}, @code{rational},
@code{irrational}, @code{real}, @code{imaginary}, @code{complex},
@code{analytic}, @code{increasing}, @code{decreasing}, @code{oddfun},
@code{evenfun}, @code{posfun}, @code{commutative}, @code{lassociative},
@code{rassociative}, @code{symmetric}, und @code{antisymmetric}.
@end flushleft

@c plus any user-defined features.

Hinzu kommen die vom Nutzer definierten Eigenschaften.

@c @code{features} is a list of mathematical features. There is also a list of 
@c non-mathematical, system-dependent features. See @code{status}.

@code{features} ist eine Liste der mathematischen Eigenschaften. Es gibt 
weitere Eigenschaften. Siehe @mref{declare} und @mrefdot{status}

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 22.11.2010 DK -----------------------------------------------------------
@anchor{nonarray}
@deffn {Eigenschaft} nonarray

@c The command @code{declare(a, nonarray)} tells Maxima to consider @var{a} not 
@c an array. This declaration prevents multiple evaluation, if @var{a} is a
@c subscripted variable.

@code{declare(a, nonarray)} gibt dem Symbol @var{a} die Eigenschaft nicht ein
Array zu sein. Dies verhindert die mehrfache Auswertung, wenn das Symbol
@var{a} als indizierte Variable genutzt wird.

Beispiel:

@c ===beg===
@c a:'b$ b:'c$ c:'d$
@c a[x];
@c declare(a, nonarray);
@c a[x];
@c ===end===
@example
(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
@end example

@c @opencatbox
@c @category{Expressions}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalar}
@defvr {Eigenschaft} nonscalar

@c Makes atoms behave as does a list or matrix with respect to the dot operator.

Hat ein Symbol die Eigenschaft @code{nonscalar}, verh@"alt es sich wie eine
Matrix oder Liste bei nicht-kommutativen Rechenoperationen.

@c @opencatbox
@c @category{Declarations and inferences} @category{Vectors} @category{Matrices}
@c @closecatbox
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalarp}
@deffn {Funktion} nonscalarp (@var{expr})

@c Returns @code{true} if @var{expr} is a non-scalar, i.e., it contains atoms 
@c declared as non-scalars, lists, or matrices.

Gibt @code{true} zur@"uck, wenn der Ausdruck @var{expr} kein Skalar ist. Der
Ausdruck enth@"alt dann Matrizen, Listen oder Symbole, die als @code{nonscalar}
deklariert wurden.

@c @opencatbox
@c @category{Predicate functions} @category{Vectors} @category{Matrices}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{posfun}
@defvr {Eigenschaft} posfun

@c @code{declare (f, posfun)} declares @code{f} to be a positive function.
@c @code{is (f(x) > 0)} yields @code{true}.

@code{declare(f, posfun)} deklariert die Funktion @code{f} als positive
Funktion. @code{is (f(x) > 0)} gibt dann @code{true} zur@"uck.

@c @opencatbox
@c @category{Deklarationen und Inferenzen} @category{Operatoren}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{printprops}
@deffn  {Funktion} printprops (@var{a}, @var{i})
@deffnx {Funktion} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Funktion} printprops (all, @var{i})

@c Displays the property with the indicator @var{i} associated with the 
@c atom @var{a}. @var{a} may also be a list of atoms or the atom @code{all} in 
@c which case all of the atoms with the given property will be used.  For 
@c example, @code{printprops ([f, g], atvalue)}.  @code{printprops} is for
@c properties that cannot otherwise be displayed, i.e. for @code{atvalue}, 
@c @code{atomgrad}, @code{gradef}, and @code{matchdeclare}.

Zeigt die zum Kennzeichen @var{i} zugeordnete Eigenschaft des Atoms @var{a} an. 
@var{a} kann sowohl eine Liste von Atomen, als auch das Atom @code{all} sein. In
diesem Fall werden alle Atome angezeigt, die eine Eigenschaft zum Kennzeichen 
@var{i} haben. @code{printprops} zeigt die Eigenschaften von Atomen, die auf 
andere Weise nicht angezeigt werden k@"onnen, zum Beispiel f@"ur @code{atvalue}, 
@code{atomgrad}, @code{gradef} und @code{matchdeclare}.

@c @opencatbox
@c @category{Deklarationen und Inferenzen} @category{Anzeigefunktionen}
@c @closecatbox
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{scalar}
@defvr {Eigenschaft} scalar

Hat ein Symbol die Eigenschaft @code{scalar}, verh@"alt es sich wie ein Skalar 
bei nicht-kommutativen Rechenoperationen.

@c @opencatbox
@c @category{Declarations and inferences} @category{Vectors} @category{Matrices}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Fakten, Funktionen und Variablen f@"ur Aussagen, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank
@section Funktionen und Variablen f@"ur Fakten

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{activate}
@deffn {Funktion} activate (@var{context_1}, ..., @var{context_n})

@c Activates the contexts @var{context_1}, ..., @var{context_n}. The facts in 
@c these contexts are then available to make deductions and retrieve 
@c information. The facts in these contexts are not listed by @code{facts ()}.

Die Funktion @code{activate(@var{context})} aktiviert den Kontext @var{context}.
Der Funktion @code{activate} k@"onnen auch mehrere Kontexte @var{context_1}, ..., 
@var{context_n} @"ubergeben werden. Nur die Fakten eines aktiven Kontextes stehen 
f@"ur die Auswertung von Aussagen zur Verf@"ugung.

Maxima gibt @code{done} zur@"uck, wenn der Kontext erfolgreich aktiviert werden
konnte oder wenn der Kontext bereits aktiv ist. Wird versucht, einen nicht 
existierenden Kontext zu aktivieren, gibt Maxima eine Fehlermeldung aus. 

Das Kommando @code{facts()} gibt immer die Fakten des aktuellen Kontextes aus. 
Die Fakten anderer Kontexte k@"onnen zwar aktiv sein, sind aber in der 
R@"uckgabe von @code{facts} nicht enthalten. Um die Fakten eines anderen 
Kontextes @var{context} auszugeben, kann das Kommando 
@code{facts(@var{context})} ausgef@"uhrt werden.

@c The variable @code{activecontexts} is the list of contexts which are active 
@c by way of the @code{activate} function.

Die Systemvariable @mref{activecontexts} enth@"alt eine Liste der aktiven
Kontexte.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn
 
@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{activecontexts}
@defvr {Systemvariable} activecontexts
Standardwert: @code{[]}

@c @code{activecontexts} is a list of the contexts which are active by way of 
@c the @code{activate} function, as opposed to being active because they are 
@c subcontexts of the current context.

Die Systemvariable @code{activecontexts} enth@"alt eine Liste der Kontexte, die 
mit der Funktion @code{activate} aktiviert wurden. Subkontexte eines Kontexts 
sind aktiv, ohne dass die Funktion @code{activate} aufgerufen werden muss und 
sind daher nicht in der Liste @code{activecontexts} enthalten. Siehe auch die
Funktion @mrefdot{activate}

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{askexp}
@defvr {Systemvariable} askexp

@c TODO: KANN DIESE DOKUMENTATION ENTFERNT WERDEN?

@c When @code{asksign} is called, @code{askexp} is the expression @code{asksign}
@c is testing.

Wenn @code{asksign} aufgerufen wird, enth@"alt @code{askexp} den Ausdruck, der von
@code{asksign} getestet wird.

@c At one time, it was possible for a user to inspect @code{askexp} by entering
@c a Maxima break with control-A.

Es war einmal m@"oglich, die Variable @code{askexp} nach einer Unterbrechnung mit
Control-A zu inspezieren.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr


@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{askinteger}
@deffn  {Funktion} askinteger (@var{expr}, integer)
@deffnx {Funktion} askinteger (@var{expr})
@deffnx {Funktion} askinteger (@var{expr}, even)
@deffnx {Funktion} askinteger (@var{expr}, odd)

@c @code{askinteger (@var{expr}, integer)} attempts to determine from the 
@c @code{assume} database whether @var{expr} is an integer. @code{askinteger} 
@c prompts the user if it cannot tell otherwise,
@c UMM, askinteger AND asksign DO NOT APPEAR TO HAVE ANY EFFECT ON THE assume 
@c DATABASE !!!
@c and attempt to install the information in the database if possible.
@c @code{askinteger (@var{expr})} is equivalent to @code{askinteger (@var{expr},
@c integer)}.

@code{askinteger(@var{expr}, integer)} versucht anhand der Fakten in der 
@code{assume}-Datenbank zu entscheiden, ob @var{expr} eine ganze Zahl ist. Kann 
@code{askinteger} die Frage nicht beantworten, fragt Maxima den Nutzer. Die 
erhaltene Anwort wird in die Datenbank eingetragen. 
@code{askinteger(@var{expr})} ist @"aquivalent zu 
@code{askinteger(@var{expr}, integer)}.

@c @code{askinteger (@var{expr}, even)} and @code{askinteger (@var{expr}, odd)}
@c likewise attempt to determine if @var{expr} is an even integer or odd 
@c integer, respectively.

@code{askinteger(@var{expr}, even)} und @code{askinteger(@var{expr}, odd)}
versuchen zu entscheiden, ob @var{expr} eine gerade oder gerade ganze Zahl ist. 
Kann Maxima dies nicht entscheiden, wird der Nutzer gefragt. Die Antwort 
wird jedoch nur dann in die Datenbank eingetragen, wenn bereits eingetragen 
ist, dass @var{expr} eine ganze Zahl ist.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{asksign}
@deffn {Funktion} asksign (@var{expr})

@c First attempts to determine whether the specified expression is positive, 
@c negative, or zero.  If it cannot, it asks the user the necessary questions to
@c complete its deduction.  The user's answer is recorded in the data base for 
@c the duration of the current computation. The return value of @code{asksign} 
@c is one of @code{pos}, @code{neg}, or @code{zero}.

Die Funktion @code{asksign} versucht zu entscheiden, ob der Ausdruck @var{expr}
positiv, negativ oder null ist. Kann Maxima dies nicht feststellen, wird der 
Nutzer nach weiteren Informationen gefragt, um die Frage zu entscheiden. Die 
Antworten des Nutzers werden f@"ur die laufende Auswertung in die Datenbank 
eingetragen. Der R@"uckgabewert von @code{asksign} ist @code{pos}, @code{neg} 
oder @code{zero}.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 26.08.2010 DK -----------------------------------------------------------
@anchor{assume}
@deffn {Funktion} assume (@var{pred_1}, ..., @var{pred_n})

@c Adds predicates @var{pred_1}, ..., @var{pred_n} to the current context. If a 
@c predicate is inconsistent or redundant with the predicates in the current 
@c context, it is not added to the context. The context accumulates predicates 
@c from each call to @code{assume}.

F@"ugt die Aussagen @var{pred_1}, ..., @var{pred_n} dem gegenw@"artigen Kontext
hinzu. Eine inkonsistente oder redunante Aussage wird dem Kontext nicht 
hinzugef@"ugt. Jeder Aufruf von @code{assume} f@"ugt dem Kontext weitere 
Aussagen hinzu.

@c @code{assume} returns a list whose elements are the predicates added to the 
@c context or the atoms @code{redundant} or @code{inconsistent} where 
@c applicable.

@code{assume} gibt eine Liste mit den Aussagen zur@"uck, die dem Kontext 
hinzugef@"ugt wurden, oder die Symbole @code{redunant} sowie @code{inconsistent}.

@c The predicates @var{pred_1}, ..., @var{pred_n} can only be expressions with 
@c the relational operators @code{< <= equal notequal >=} and @code{>}. 
@c Predicates cannot be literal equality @code{=} or literal inequality @code{#}
@c expressions, nor can they be predicate functions such as @code{integerp}.

Die Aussagen @var{pred_1}, ..., @var{pred_n} k@"onnen nur Ausdr@"ucke mit den 
Relationalen Operatoren @code{< <= equal notequal >=} und @code{>} sein.
Aussagen k@"onnen nicht die Operatoren @code{=} f@"ur die Gleichheit oder @code{#}
f@"ur die Ungleichheit enthalten. Auch k@"onnen keine Aussagefunktionen wie
@code{integerp} verwendet werden.

@c Compound predicates of the form @code{@var{pred_1} and ... and @var{pred_n}}
@c are recognized, but not @code{@var{pred_1} or ... or @var{pred_n}}.
@c @code{not @var{pred_k}} is recognized if @var{pred_k} is a relational 
@c predicate. Expressions of the form @code{not (@var{pred_1} and @var{pred_2})}
@c and @code{not (@var{pred_1} or @var{pred_2})} are not recognized.

Zusammengesetzte Aussagen der Form @code{@var{pred_1} and ... and @var{pred_n}}
werden erkannt, nicht dagegen Aussagen der Form @code{@var{pred_1} or ... or 
@var{pred_n}}. @code{not(@var{pred_k}} wird erkannt, wenn @var{pred_k} eine 
relationale Aussage ist. Aussagen der Form @code{not (@var{pred_1} and 
@var{pred_2})} and @code{not (@var{pred_1} or @var{pred_2})} werden nicht 
erkannt.

@c Maxima's deduction mechanism is not very strong; there are many obvious 
@c consequences which cannot be determined by @code{is}. This is a known 
@c weakness.

Der Folgerungsmechanismus von Maxima ist nicht sehr stark. Viele 
offensichtlichen Schlu@ss{}folgerungen k@"onnen von Maxima nicht abgeleitet werden.
Dies ist eine bekannte Schw@"ache von Maxima.

@c @code{assume} does not handle predicates with complex numbers. If a predicate
@c contains a complex number @code{assume} returns @code{inconsistent} or 
@c @code{redunant}

@code{assume} behandelt keine Aussagen mit komplexen Zahlen. Enth@"alt eine
Aussage eine komplexe Zahl, gibt @code{assume} den Wert @code{inconsistent}
oder @code{redunant} zur@"uck.

@c @code{assume} evaluates its arguments.

@code{assume} wertet seine Argumente aus.

Siehe auch @mrefcomma{is}, @mrefcomma{facts}, @mrefcomma{forget}, 
@mref{context} und @mrefdot{declare}

Beispiele:

@c ===beg===
@c assume (xx > 0, yy < -1, zz >= 0);
@c assume (aa < bb and bb < cc);
@c facts ();
@c is (xx > yy);
@c is (yy < -yy);
@c is (sinh (bb - aa) > 0);
@c forget (bb > aa);
@c prederror : false;
@c is (sinh (bb - aa) > 0);
@c is (bb^2 < cc^2);
@c ===end===
@example
(%i1) assume (xx > 0, yy < -1, zz >= 0);
(%o1)              [xx > 0, yy < - 1, zz >= 0]
(%i2) assume (aa < bb and bb < cc);
(%o2)                  [bb > aa, cc > bb]
(%i3) facts ();
(%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
(%i4) is (xx > yy);
(%o4)                         true
(%i5) is (yy < -yy);
(%o5)                         true
(%i6) is (sinh (bb - aa) > 0);
(%o6)                         true
(%i7) forget (bb > aa);
(%o7)                       [bb > aa]
(%i8) prederror : false;
(%o8)                         false
(%i9) is (sinh (bb - aa) > 0);
(%o9)                        unknown
(%i10) is (bb^2 < cc^2);
(%o10)                       unknown
@end example

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 26.08.2010 DK -----------------------------------------------------------
@anchor{assumescalar}
@defvr {Optionsvariable} assumescalar
Standardwert: @code{true}

@c @code{assumescalar} helps govern whether expressions @code{expr} for which 
@c @code{nonscalarp (expr)} is @code{false} are assumed to behave like scalars
@c for certain transformations.

Hat die Optionsvariable @code{assumescalar} den Wert @code{true}, werden 
Ausdr@"ucke die mit @code{nonscalarp(expr)} den Wert @code{false} haben, in 
bestimmten Transformationen als ein Skalar behandelt.

@c Let @code{expr} represent any expression other than a list or a matrix, and 
@c let @code{[1, 2, 3]} represent any list or matrix. Then 
@c @code{expr . [1, 2, 3]} yields @code{[expr, 2 expr, 3 expr]} if 
@c @code{assumescalar} is @code{true}, or @code{scalarp (expr)} is @code{true}, 
@c or @code{constantp (expr)} is @code{true}.

Ist @code{expr} ein Ausdruck bis auf eine Liste oder eine Matrix und
@code{[1, 2, 3]} re@-pr@"a@-sen@-tiert eine Liste oder eine Matrix.  Dann ergibt
@code{expr . [1, 2, 3]} das Ergebnis @code{[expr, 2 expr, 3 expr]}, wenn
@code{assumescalar}, @code{scalarp(expr)} oder @code{constantp(expr)} den Wert 
@code{true} haben.

@c If @code{assumescalar} is @code{true}, such expressions will behave like 
@c scalars only for commutative operators, but not for noncommutative 
@c multiplication @code{.}.

Hat @code{assumescalar} den Wert @code{true}, solche Ausdr@"ucke verhalten sich
wie Skalare nur f@"ur kommutative Operatoren, aber nicht f@"ur die nicht-kommutative
Multiplikation @code{.}.

@c When @code{assumescalar} is @code{false}, such expressions will behave like 
@c non-scalars.

Hat @code{assumescalar} den Wert @code{false}, verhalten sich solche Ausdr@"ucke 
wie Nicht-Skalare.

@c When @code{assumescalar} is @code{all}, such expressions will behave like 
@c scalars for all the operators listed above.

Hat @code{assumescalar} den Wert @code{all}, verhalten sich solche Ausdr@"ucke
wie Skalare f@"ur alle oben genannten Operatoren.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 26.08.2010 --------------------------------------------------------------
@anchor{assume_pos}
@defvr {Optionsvariable} assume_pos
Standardwert: @code{false}

@c When @code{assume_pos} is @code{true} and the sign of a parameter @var{x} 
@c cannot be determined from the current context
@c @c WHAT ARE THOSE OTHER CONSIDERATIONS ??
@c or other considerations, @code{sign} and @code{asksign (@var{x})} return 
@c @code{true}. This may forestall some automatically-generated @code{asksign} 
@c queries, such as may arise from @code{integrate} or other computations.

Hat die Optionsvariable @code{assume_pos} den Wert @code{true} und das
Vorzeichen eines Parameters @var{x} kann nicht bestimmt werden vom gegenw@"artigen
Kontext oder aus anderen Zusammenh@"angen, geben @code{sign(@var{x})} und 
@code{asksign(@var{x})} das Ergebnis @code{true}. Dadurch k@"onnen automatische
Abfragen wie sie von @code{integrate} ausgef@"uhrt werden, vermieden werden.

@c By default, a parameter is @var{x} such that @code{symbolp (@var{x})} or 
@c @code{subvarp (@var{x})}. The class of expressions considered parameters can
@c be modified to some extent via the variable @code{assume_pos_pred}.

Standardm@"a@ss{}ig ist ein Parameter @var{x}, so dass @code{symbolp(@var{x})} oder
@code{subvarp(@var{x})}. Die Klasse an Ausdr@"ucken, die als Parameter betrachtet
werden, kann mit der Optionsvariablen @code{assume_pos_pred} erweitert werden.

@c @code{sign} and @code{asksign} attempt to deduce the sign of expressions from
@c the sign of operands within the expression. For example, if @code{a} and 
@c @code{b} are both positive, then @code{a + b} is also positive.

@code{sign} und @code{asksing} versuchen das Vorzeichen eines Ausdruckes vom
Vorzeichen der Operanten eines Ausdruckes zu ermitteln. Sind zum Beispiel
@code{a} und @code{b} beide postive, dann hat auch @code{a+b} ein positives
Vorzeichen.

@c However, there is no way to bypass all @code{asksign} queries. In particular,
@c when the @code{asksign} argument is a difference @code{@var{x} - @var{y}} or 
@c a logarithm @code{log(@var{x})}, @code{asksign} always requests an input from
@c the user, even when @code{assume_pos} is @code{true} and 
@c @code{assume_pos_pred} is a function which returns @code{true} for all 
@c arguments.

Jedoch gibt es keine M@"oglichkeit, alle Fragen von @code{asksign} zu vermeiden.
So fragt @code{asksign} auf jeden Fall nach dem Vorzeichen f@"ur eine Differenz
@code{@var{x} - @var{y}} oder einen Logarithmus @code{log(@var{x})}, auch wenn
@code{assume_pos} den Wert @code{true} hat und @code{assume_pos_pred} eine
Funktion ist, die f@"ur alle Argumente den Wert @code{true} zur@"uckgibt.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 26.08.2010 DK -----------------------------------------------------------
@anchor{assume_pos_pred}
@defvr {Optionsvariable} assume_pos_pred
Standardwert: @code{false}

@c When @code{assume_pos_pred} is assigned the name of a function or a lambda 
@c expression of one argument @var{x}, that function is called to determine
@c whether @var{x} is considered a parameter for the purpose of 
@c @code{assume_pos}. @code{assume_pos_pred} is ignored when @code{assume_pos} 
@c is @code{false}.

Wird der Optionsvariablen @code{assume_pos_pred} der Name einer Funktion oder
ein Lambda-Ausdruck mit einem Argument @var{x} zugewiesen, wird diese Funktion
aufgerufen, um festzustellen, ob @var{x} als ein Parameter im Zusammenhang
mit @code{assume_pos} behandelt wird. @code{assume_pos_pred} wird ignoriert,
wenn die Optionsvariable @code{assume_pos} den Wert @code{false} hat.

@c The @code{assume_pos_pred} function is called by @code{sign} and 
@c @code{asksign} with an argument @var{x} which is either an atom, a 
@c subscripted variable, or a function call expression. If the 
@c @code{assume_pos_pred} function returns @code{true}, @var{x} is considered a 
@c parameter for the purpose of @code{assume_pos}.

Die @code{assume_pos_pred}-Funktion wird von den Funktionen @code{sign} und
@code{asksign} mit einem Argument @var{x} aufgerufen, welches entweder ein 
Symbol, eine indizierte Variable oder ein Funktionsaufruf ist. Gibt
@code{assume_pos_pred} den Wert @code{true} zur@"uck, wird @var{x} als ein
Parameter f@"ur @code{assuem_pos} betrachtet.

@c By default, a parameter is @var{x} such that @code{symbolp (@var{x})} or 
@c @code{subvarp (@var{x})}.

Standardm@"a@ss{}ig ist ein Parameter @var{x}, so dass @code{symbolp(@var{x})} oder
@code{subvarp(@var{x})}.

Siehe auch @code{assume} und @code{assume_pos}.

Beispiele:

@c ===beg===
@c assume_pos: true$
@c assume_pos_pred: symbolp$
@c sign (a);
@c sign (a[1]);
@c assume_pos_pred: lambda ([x], display (x), true)$
@c asksign (a);
@c asksign (a[1]);
@c asksign (foo (a));
@c asksign (foo (a) + bar (b));
@c asksign (log (a));
@c asksign (a - b);
@c ===end===
@example
(%i1) assume_pos: true$
(%i2) assume_pos_pred: symbolp$
(%i3) sign (a);
(%o3)                          pos
(%i4) sign (a[1]);
(%o4)                          pnz
(%i5) assume_pos_pred: lambda ([x], display (x), true)$
(%i6) asksign (a);
                              x = a

(%o6)                          pos
(%i7) asksign (a[1]);
                             x = a
                                  1

(%o7)                          pos
(%i8) asksign (foo (a));
                           x = foo(a)

(%o8)                          pos
(%i9) asksign (foo (a) + bar (b));
                           x = foo(a)

                           x = bar(b)

(%o9)                          pos
(%i10) asksign (log (a));
                              x = a

Is  a - 1  positive, negative, or zero?

p;
(%o10)                         pos
(%i11) asksign (a - b);
                              x = a

                              x = b

                              x = a

                              x = b

Is  b - a  positive, negative, or zero?

p;
(%o11)                         neg
@end example

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 27.08.2010 --------------------------------------------------------------
@anchor{context}
@defvr {Optionsvariable} context
Standardwert: @code{initial}

@c @code{context} names the collection of facts maintained by @code{assume} and 
@c @code{forget}. @code{assume} adds facts to the collection named by 
@c @code{context}, while @code{forget} removes facts.

Die Optionsvariable @code{context} enth@"alt den Namen des aktuellen Kontexts. Das
ist der Kontext, der die Fakten der Funktion @code{assume} aufnimmt oder aus dem
Fakten mit der Funktion @code{forget} gel@"oscht werden.

@c Binding @code{context} to a name @var{foo} changes the current context to 
@c @var{foo}. If the specified context @var{foo} does not yet exist, it is 
@c created automatically by a call to @code{newcontext}.
   @c ISN'T THIS NEXT BIT EQUIVALENT TO THE FIRST ??
@c The specified context is activated automatically.

Wird der Optionsvariable @code{context} der Name @var{foo} zugewiesen, wird der
Kontext @var{foo} zum aktuellen Kontext. Existiert dieser Kontext noch nicht,
wird er automatisch durch Aufruf der Funktion @code{newcontext} erzeugt.

@c See @code{contexts} for a general description of the context mechanism.

Siehe auch @mref{contexts} f@"ur eine allgemeinere Beschreibung von Kontexten.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{contexts}
@defvr {Optionsvariable} contexts
Standardwert: @code{[initial, global]}

@c @code{contexts} is a list of the contexts which currently exist, including 
@c the currently active context.

Die Optionsvariable @code{contexts} enth@"alt eine Liste der Kontexte, die aktuell
vorhanden sind. Darin sind auch die Kontexte enthalten, die aktuell nicht aktiv 
sind.

@c The context mechanism makes it possible for a user to bind together and name 
@c a collection of facts, called a context. Once this is done, the user can have
@c Maxima assume or forget large numbers of facts merely by activating or
@c deactivating their context.

Kontexte k@"onnen genutzt werden, um eine Vielzahl von Fakten zusammenzustellen.
Diese Fakten k@"onnen dann durch Aktivierung oder Deaktivierung des Kontextes f@"ur
die Auswertung von Aussagen verf@"ugbar gemacht und wieder ausgeschaltet werden.

@c Any symbolic atom can be a context, and the facts contained in that context 
@c will be retained in storage until destroyed one by one by calling 
@c @code{forget} or destroyed as a whole by calling @code{kill} to destroy the 
@c context to which they belong.

Der Name eines Kontextes kann irgendein Symbol sein. Die Fakten in einem Kontext
bleiben so lange verf@"ugbar, bis sie entweder einzeln mit der Funktion 
@code{forget} oder der gesamte Kontext mit der Funktion @code{kill} gel@"oscht
werden.

@c Contexts exist in a hierarchy, with the root always being the context 
@c @code{global}, which contains information about Maxima that some functions 
@c need.  When in a given context, all the facts in that context are "active" 
@c (meaning that they are used in deductions and retrievals) as are all the 
@c facts in any context which is a subcontext of the active context.

Kontexte haben eine Hierarchie. Die Wurzel ist immer der Kontext @code{global},
welcher Informationen enth@"alt, die Maxima f@"ur die Auswertung und Vereinfachung
von Funktionen ben@"otigt. Neben den Fakten des aktuellen Kontextes sind immer 
auch alle Fakten alle Subkontexte verf@"ugbar.

@c When a fresh Maxima is started up, the user is in a context called 
@c @code{initial}, which has @code{global} as a subcontext.

Wird Maxima gestarted, ist der aktuelle und aktive Kontext @code{initial}. 
Dieser enth@"alt den Subkontext @code{global}.

Siehe auch @code{facts}, @code{newcontext}, @code{supcontext}, 
@code{killcontext}, @code{activate}, @code{deactivate}, @code{assume}, 
und @code{forget}.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{deactivate}
@deffn {Funktion} deactivate (@var{context_1}, ..., @var{context_n})

@c Deactivates the specified contexts @var{context_1}, ..., @var{context_n}.

Die Kontexte @var{context_1}, ..., @var{context_n} werden deaktiviert. Die
Fakten dieser Kontexte stehen f@"ur die Auswertung von Aussagen nicht mehr zur
Verf@"ugung. Die Kontexte werden jedoch nicht gel@"oscht und k@"onnen mit der Funktion
@code{activate} wieder aktiviert werden.

Die deaktivierten Kontexte werden aus der Liste @code{activecontexts} entfernt.

Siehe auch @mref{activate} und @mrefdot{activecontexts}

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{facts}
@deffn  {Funktion} facts (@var{item})
@deffnx {Funktion} facts ()

@c If @var{item} is the name of a context, @code{facts (@var{item})} returns a 
@c list of the facts in the specified context.

Ist @var{item} der Name eines Kontexts, gibt @code{facts(@var{item})} eine
Liste aller Fakten des Kontextes zur@"uck.

@c If @var{item} is not the name of a context, @code{facts (@var{item})} returns
@c a list of the facts known about @var{item} in the current context.  Facts 
@c that are active, but in a different context, are not listed.

Ist @var{item} nicht der Name eines Kontexts, gibt @code{facts (@var{item})} 
eine List der Fakten zur@"uck, die zu @var{item} im aktuellen Kontext bekannt 
sind. Fakten, die aktiv sind, aber zu einem anderen Kontext geh@"oren, sind nicht
in der Liste enthalten.

@c @code{facts ()} (i.e., without an argument) lists the current context.

@code{facts()} gibt eine Liste der Fakten des aktuellen Kontextes zur@"uck.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{forget}
@deffn  {Funktion} forget (@var{pred_1}, ..., @var{pred_n})
@deffnx {Funktion} forget (@var{L})

@c Removes predicates established by @code{assume}. The predicates may be 
@c expressions equivalent to (but not necessarily identical to) those previously
@c assumed.

Entfernt Fakten die mit @code{assume} einem Kontext hinzugef@"ugt wurden. Die
Fakten k@"onnen Ausdr@"ucke sein, die @"aquivalent aber nicht unbedingt identisch zu
vorherigen Fakten sind.

@c @code{forget (@var{L})}, where @var{L} is a list of predicates, forgets each
@c item on the list.

@code{forget(@var{L})} entfernt alle Fakten, die in der Liste @var{L} enthalten
sind.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{is}
@deffn {Funktion} is (@var{expr})

@c Attempts to determine whether the predicate @var{expr} is provable from the 
@c facts in the @code{assume} database.

versucht festzustellen, ob die Aussage @var{expr} mit Hilfe der Fakten in der
Datenbank entschieden werden kann.

@c If the predicate is provably @code{true} or @code{false}, @code{is} returns 
@c @code{true} or @code{false}, respectively. Otherwise, the return value is 
@c governed by the global flag @code{prederror}. When @code{prederror} is 
@c @code{true}, @code{is} complains with an error message. Otherwise, @code{is} 
@c returns @code{unknown}.

Kann die Aussage zu @code{true} oder @code{false} entschieden werden, wird
das entsprechende zur@"uck gegeben. Andernfalls wird der R@"uckgabewert durch das
globale Flag @code{prederror} bestimmt. Hat @code{prederror} den Wert 
@code{true}, wird eine Fehlermeldung erzeugt. Andernfalls wird @code{unknown}
zur@"uck gegeben.

@c @code{ev(@var{expr}, pred)} (which can be written  @code{@var{expr}, pred} 
@c at the interactive prompt) is equivalent to @code{is(@var{expr})}.

@c See also @code{assume}, @code{facts}, and @code{maybe}.

Siehe auch @code{assume}, @code{facts} und @code{maybe}.

Beispiele:

@c @code{is} causes evaluation of predicates.

@code{is} wertet Aussagen aus:

@c ===beg===
@c %pi > %e;
@c is (%pi > %e);
@c ===end===
@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@c @code{is} attempts to derive predicates from the @code{assume} database.

@code{is} versucht Aussagen anhand der Fakten der Datenbank zu entscheiden.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c is (a < b);
@c is (a > c);
@c is (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

@c If @code{is} can neither prove nor disprove a predicate from the 
@c @code{assume} database, the global flag @code{prederror} governs the behavior
@c of @code{is}.

Wenn @code{is} eine Aussage anhand der Fakten der Datenbank nicht entscheiden
kann, wird der R@"uckgabewert vom Wert des globalen Flags @code{prederror}
bestimmt.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c is (a > 0);
@c prederror: false$
@c is (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example

@c @opencatbox
@c @category{Aussagefunktionen} @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{killcontext}
@deffn {Funktion} killcontext (@var{context_1}, ..., @var{context_n})

@c Kills the contexts @var{context_1}, ..., @var{context_n}.

Das Kommando @code{killcontext(@var{context})} l@"oscht den Kontext @var{context}.

@c If one of the contexts is the current context, the new current context will 
@c become the first available subcontext of the current context which has not 
@c been killed.  If the first available unkilled context is @code{global} then 
@c @code{initial} is used instead.  If the @code{initial} context is killed, a 
@c new, empty @code{initial} context is created.

Ist einer der Kontexte der aktuelle Kontext, wird der erste vorhandene 
Subkontext zum aktuellen Kontext. Ist der erste verf@"ugbare Kontext der Kontext
@code{global}, dann wird der Kontext @code{initial} zum aktuellen Kontext. Wird
der Kontext @code{initial} gel@"oscht, dann wird eine neuer leerer Kontext
@code{initial} erzeugt.

@c @code{killcontext} refuses to kill a context which is currently active, 
@c either because it is a subcontext of the current context, or by use of the 
@c function @code{activate}.

@code{killcontext} l@"oscht einen Kontext nicht, wenn dieser ein Subkontext des
aktuellen Kontextes ist oder wenn der Kontext mit der Funktion @code{activate}
aktiviert wurde.

@c @code{killcontext} evaluates its arguments. @code{killcontext} returns 
@c @code{done}.

@code{killcontext} wertet seine Argumente aus. @code{killcontext} gibt 
@code{done} zur@"uck.

@c @opencatbox
@c @category{Deklaratonen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{maybe}
@deffn {Funktion} maybe (@var{expr})

@c Attempts to determine whether the predicate @var{expr} is provable from the 
@c facts in the @code{assume} database.

Versucht festzustellen, ob die Aussage @var{expr} anhand der @code{assume} 
Datenbank beweisbar ist.

@c If the predicate is provably @code{true} or @code{false}, @code{maybe} 
@c returns @code{true} or @code{false}, respectively. Otherwise, @code{maybe} 
@c returns @code{unknown}.

Kann die Aussage als @code{true} oder @code{false} bewiesen werden, gibt 
@code{maybe} entsprechend @code{true} oder @code{false} zur@"uck. Andernfalls
gibt @code{maybe} den Wert @code{unknown} zur@"uck.

@c @code{maybe} is functionally equivalent to @code{is} with @code{prederror: 
@c false}, but the result is computed without actually assigning a value to 
@c @code{prederror}.

@code{maybe} entspricht der Funktion @code{is} mit @code{prederror: false}. 
Dabei wird @code{maybe} ausgef@"uhrt, ohne dass @code{prederror} einen Wert 
erh@"alt.

@c See also @code{assume}, @code{facts}, and @code{is}.

Siehe auch @code{assume}, @code{facts} und @code{is}.

Beispiele:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@c @opencatbox
@c @category{Aussagefunktionen} @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{newcontext}
@deffn {Funktion} newcontext (@var{name})

@c Creates a new, empty context, called @var{name}, which has @code{global} as 
@c its only subcontext.  The newly-created context becomes the currently active
@c context.

@code{newcontext(@var{name})} erzeugt einen neuen, leeren Kontext mit dem 
Namen @var{name}. Der neue Kontext hat den Kontext @code{global} als Subkontext
und wird zum aktuellen Kontext.

@c @code{newcontext} evaluates its argument. @code{newcontext} returns 
@c @var{name}.

@code{newcontext} wertet seine Argumente aus. @code{newcontext} gibt @code{name}
zur@"uck.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{prederror}
@defvr {Optionsvariable} prederror
Standardwert: @code{false}

@c When @code{prederror} is @code{true}, an error message is displayed whenever 
@c the predicate of an @code{if} statement or an @code{is} function fails to
@c evaluate to either @code{true} or @code{false}.

Hat @code{prederror} den Wert @code{true}, wird eine Fehlermeldung ausgegeben,
wenn eine Aussage mit einer @code{if}-Anweisung oder der Funktion @code{is} 
nicht zu @code{true} oder @code{false} ausgewertet werden kann.

@c If @code{false}, @code{unknown} is returned instead in this case.  The 
@c @code{prederror: false} mode is not supported in translated code; however, 
@c @code{maybe} is supported in translated code.

Hat @code{prederror} den Wert @code{false}, wird f@"ur diese F@"alle 
@code{unknown} zur@"uckgegeben. 

@c See also @code{is} and @code{maybe}.

Siehe auch @mref{is} und @mrefdot{maybe}

@c @opencatbox
@c @category{Programming} @category{Predicate functions}
@c @closecatbox
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{sign}
@deffn {Funktion} sign (@var{expr})

@c Attempts to determine the sign of @var{expr} on the basis of the facts in the
@c current data base.  It returns one of the following answers: @code{pos} 
@c (positive), @code{neg} (negative), @code{zero}, @code{pz} (positive or zero),
@c @code{nz} (negative or zero), @code{pn} (positive or negative), or @code{pnz}
@c (positive, negative, or zero, i.e. nothing known).

Versucht das Vorzeichen des Ausdrucks @var{expr} auf Grundlage der Fakten der
aktuellen Datenbank zu finden. @code{sign} gibt eine der folgende Antworten 
zur@"uck: @code{pos} (positiv), @code{neg} (negative), @code{zero} (null),
@code{pz} (positive oder null), @code{nz} (negative oder null), @code{pn}
(positiv oder negative) oder @code{pnz} (positiv, negative oder null, f@"ur den
Fall das Vorzeichen nicht bekannt ist).

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{supcontext}
@deffn  {Funktion} supcontext (@var{name}, @var{context})
@deffnx {FunKtion} supcontext (@var{name}) 

@c Creates a new context, called @var{name}, which has @var{context} as a 
@c subcontext. @var{context} must exist.

erzeugt einen neuen Kontext, mit dem Namen @code{name}, der den Kontext 
@code{context} als eine Subkontext enth@"alt. Der Kontext @var{context} muss
existieren.

@c If @var{context} is not specified, the current context is assumed.

Wird @var{context} nicht spezifiziert, wird der aktuelle Kontext zum Subkontext.

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Aussagen, , Funktionen und Variablen f@"ur Fakten, Maximas Datenbank
@section Funktionen und Variablen f@"ur Aussagen

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{charfun}
@deffn {Funktion} charfun (@var{p})

@c Return 0 when the predicate @var{p} evaluates to @code{false}; return 1 when 
@c the predicate evaluates to @code{true}.  When the predicate evaluates to 
@c something other than @code{true} or @code{false} (unknown), return a noun 
@c form.

Gibt den Wert 0 zur@"uck, wenn die Aussage @var{p} zu @code{false} ausgewertet
werden kann und den Wert 1, wenn die Auswertung @code{true} liefert. Kann
die Aussage weder zu @code{false} oder @code{true} ausgewertet werden, wird eine
Substantiv-Form zur@"uck gegeben.

Beispiele:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example

@c @opencatbox
@c @category{Mathematische Funktionen}
@c @closecatbox
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{compare}
@deffn {Funktion} compare (@var{x}, @var{y})

@c Return a comparison operator @var{op} (@code{<}, @code{<=}, @code{>}, 
@c @code{>=}, @code{=}, or @code{#}) such that @code{is (@var{x} @var{op} 
@c @var{y})} evaluates to @code{true}; when either @var{x} or @var{y} depends 
@c on @code{%i} and @code{@var{x} # @var{y}}, return @code{notcomparable}; when 
@c there is no such operator or Maxima isn't able to determine the operator, 
@c return @code{unknown}.

Liefert den Vergleichsoperator @var{op} (@code{<}, @code{<=}, @code{>}, 
@code{>=}, @code{=} oder @code{#}), so dass der Ausdruck @code{is(@var{x}
@var{op} @var{y})} zu @code{true} ausgewertet werden kann. Ist eines der
Argumente eine komplexe Zahl, dann wird @code{notcomparable} zur@"uckgegeben.
Kann Maxima keinen Vergleichsoperator bestimmen, wird @code{unknown}
zur@"uckgegeben.

Beispiele:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

@c The function @code{compare} doesn't try to determine whether the real domains
@c of its arguments are nonempty; thus
@c @c IT IS NOT QUITE TRUE, WHAT ABOUT x=0 ?
@c The real domain of @code{acos (x^2 + 1)} is empty.

Die Funktion @code{compare} versucht nicht festzustellen, ob der Wertebereich
einer Funktion reelle Zahlen enth@"alt. Obwohl der Wertebereich von 
@code{acos(x^2+1)} bis auf Null keine reellen Zahlen enth@"alt, gibt 
@code{compare} das folgende Ergebnis zur@"uck:

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example

@c @opencatbox
@c @category{Deklarationen und Inferenzen}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{equal}
@deffn {Funktion} equal (@var{a}, @var{b})

@c Represents equivalence, that is, equal value.

Repr@"asentiert die @"Aquivalenz, das hei@ss{}t den gleichen Wert.

@c By itself, @code{equal} does not evaluate or simplify. The function @code{is}
@c attempts to evaluate @code{equal} to a Boolean value. @code{is(equal(@var{a},
@c @var{b}))} returns @code{true} (or @code{false}) if and only if @var{a} and 
@c @var{b} are equal (or not equal) for all possible values of their variables, 
@c as determined by evaluating @code{ratsimp(@var{a} - @var{b})}; if 
@c @code{ratsimp} returns 0, the two expressions are considered equivalent. Two 
@c expressions may be equivalent even if they are not syntactically equal (i.e.,
@c identical).

@code{equal} wird nicht ausgewertet oder vereinfacht. Die Funktion @code{is}
versucht einen Ausdruck mit @code{equal} zu einem boolschen Wert auszuwerten.
@code{is(equal(@var{a}, @var{b}))} gibt @code{true} oder @code{false} zur@"uck, 
wenn und nur wenn @var{a} und @var{b} gleich oder ungleich sind f@"ur alle Werte
ihrer Variablen, was mit @code{ratsimp(@var{a} - @var{b})} bestimmt wird. Gibt
@code{ratsimp} das Ergebnis 0 zur@"uck, werden die beiden Ausdr@"ucke als 
@"aquivalent betracht. Zwei Ausdr@"ucke k@"onnen @"aquivalent sein, obwohl sie 
nicht syntaktisch gleich (im allgemeinen identisch) sind.

@c When @code{is} fails to reduce @code{equal} to @code{true} or @code{false},
@c the result is governed by the global flag @code{prederror}. When 
@c @code{prederror} is @code{true}, @code{is} complains with an error message.
@c Otherwise, @code{is} returns @code{unknown}.

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder 
@code{false} auswerten, h@"angt das Ergebnis vom Wert des globalen Flags 
@code{prederror} ab. Hat @code{prederror} den Wert @code{true}, gibt @code{is}
eine Fehlermeldung zur@"uck. Ansonsten wird @code{unknown} zur@"uckgegeben.

@c In addition to @code{is}, some other operators evaluate @code{equal} and 
@c @code{notequal} to @code{true} or @code{false}, namely @code{if}, @code{and},
@c @code{or}, and @code{not}.

Es gibt weitere Operatoren, die einen Ausdruck mit @code{equal} zu @code{true}
oder @code{false} auswerten k@"onnen. Dazu geh@"oren @code{if}, @code{and}, 
@code{or} und @code{not}.

  @c FOLLOWING STATEMENT IS MORE OR LESS TRUE BUT I DON'T THINK THE DETAILS ARE
  @c CORRECT
  @c Declarations (integer, complex, etc)
  @c for variables appearing in @var{a} and @var{b} are ignored by @code{equal}.
  @c All variables are effectively assumed to be real-valued.

@c The negation of @code{equal} is @code{notequal}.

Die Umkehrung von @code{equal} ist @code{notequal}.

Beispiele:

@c By itself, @code{equal} does not evaluate or simplify.

@code{equal} wird von allein weder ausgewertet noch vereinfacht:

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

@c The function @code{is} attempts to evaluate @code{equal} to a Boolean value.
@c @code{is(equal(@var{a}, @var{b}))} returns @code{true} when 
@c @code{ratsimp(@var{a} - @var{b})} returns 0. Two expressions may be 
@c equivalent even if they are not syntactically equal (i.e., identical).

Die Funktion @code{is} versucht, @code{equal} zu einem boolschen Wert 
auszuwerten. @code{is(equal(@var{a}, @var{b}))} gibt den Wert @code{true} 
zur@"uck, when @code{ratsimp(@var{a} - @var{b})} den Wert 0 hat. Zwei 
Ausdr@"ucke k@"onnen @"aquivalent sein, obwohl sie nicht syntaktisch gleich 
sind.

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example

@c When @code{is} fails to reduce @code{equal} to @code{true} or @code{false},
@c the result is governed by the global flag @code{prederror}.

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder
@code{false} vereinfachen, h@"angt das Ergebnis vom Wert des globalen Flags
@code{prederror} ab.

@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
@example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

@c Some operators evaluate @code{equal} and @code{notequal} to @code{true} or 
@c @code{false}.

Einige weitere Operatoren werten @code{equal} und @code{notequal} zu einem
boolschen Wert aus.

@c ===beg===
@c if equal (y, y - 1) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

@c Because @code{not @var{expr}} causes evaluation of @var{expr}, 
@c @code{not equal(@var{a}, @var{b})} is equivalent to 
@c @code{is(notequal(@var{a}, @var{b}))}.

Da @code{not @var{expr}} den Ausdruck @var{expr} auswertet, ist 
@code{not equal(@var{a}, @var{b})} @"aquivalent zu 
@code{is(notequal(@var{a}, @var{b}))}

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example

@c @opencatbox
@c @category{Operatoren}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{notequal}
@deffn {Funktion} notequal (@var{a}, @var{b})

@c Represents the negation of @code{equal(@var{a}, @var{b})}.

Repr@"asentiert die Verneinung von @code{equal(@var{a}, @var{b})}.

Beispiele:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c maybe (notequal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example

@c @opencatbox
@c @category{Operatoren}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{unknown}
@deffn {Funktion} unknown (@var{expr})

@c Returns @code{true} if and only if @var{expr} contains an operator or 
@c function not recognized by the Maxima simplifier.

@c TODO: FORMULIERUNG?

Gibt den Wert @code{true} zur@"uck, wenn der Ausdruck @var{expr} einen Operator
oder eine Funktion enth@"alt, die nicht von Maximas Vereinfacher erkannt wird.

@c @opencatbox
@c @category{Predicate functions} @category{Simplification functions}
@c @closecatbox
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{zeroequiv}
@deffn {Funktion} zeroequiv (@var{expr}, @var{v})

@c Tests whether the expression @var{expr} in the variable @var{v} is equivalent
@c to zero, returning @code{true}, @code{false}, or @code{dontknow}.

Testet, ob ein Ausdruck @var{expr} mit der Variablen @var{v} @"aquivalent zu 
Null ist. Die Funktion gibt @code{true}, @code{false} oder @code{dontknow} 
zur@"uck.

@c @code{zeroequiv} has these restrictions:

@code{zeroequiv} hat Einschr@"ankungen:

@enumerate

@c Do not use functions that Maxima does not know how to differentiate and 
@c evaluate.

@item
Funktionen im Ausdruck @var{expr} m@"ussen von Maxima differenzierbar und 
auswertbar sein.

@c If the expression has poles on the real line, there may be errors in the 
@c result (but this is unlikely to occur).

@item
Hat der Ausdruck Pole auf der reellen Achse, k@"onnen Fehler auftreten.

@c If the expression contains functions which are not solutions to first order
@c differential equations (e.g.  Bessel functions) there may be incorrect 
@c results.

@item
Enth@"alt der Ausdruck Funktionen, die nicht L@"osung einer 
Differentialgleichung erster Ordnung sind (zum Beispiel Bessel Funktionen), 
k@"onnen die Ergebnisse fehlerhaft sein.

@c The algorithm uses evaluation at randomly chosen points for carefully 
@c selected subexpressions.  This is always a somewhat hazardous business, 
@c although the algorithm tries to minimize the potential for error.

@item
Der Algorithmus wertet die Funktion an zuf@"allig Punkten f@"ur ausgew@"ahlte
Teilausdr@"ucke aus. Dies ist ein riskantes Verfahren und kann zu Fehlern 
f@"uhren.
@end enumerate

@c For example @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} returns 
@c @code{true} and @code{zeroequiv (%e^x + x, x)} returns @code{false}. 
@c On the other hand @code{zeroequiv (log(a*b) - log(a) - log(b), a)} returns 
@c @code{dontknow} because of the presence of an extra parameter @code{b}.

@code{zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)} hat zum Beispiel das Ergebnis 
@code{true} und  @code{zeroequiv (%e^x + x, x)} hat das Ergebnis @code{false}.
Andererseits hat @code{zeroequiv (log(a*b) - log(a) - log(b), a)} das Ergebnis
@code{dontknow}, wegen dem zus@"atzlichem Parameter @code{b}.

@c @opencatbox
@c @category{Aussagefunktionen}
@c @closecatbox
@end deffn

@c --- End of Database.de.texi -------------------------------------------------

