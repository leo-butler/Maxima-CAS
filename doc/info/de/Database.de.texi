@c -----------------------------------------------------------------------------
@c File        : Database.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 22.10.2010
@c Revision    : 12.02.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Maximas Datenbank::
* Funktionen und Variablen f@"ur Eigenschaften::
* Funktionen und Variablen f@"ur Fakten::
* Funktionen und Variablen f@"ur Aussagen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Maximas Datenbank, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank, Maximas Datenbank
@section Einf@"uhrung in Maximas Datenbank
@c -----------------------------------------------------------------------------

@subheading Eigenschaften

Variablen und Funktionen k@"onnen mit der Funktion @mref{declare} Eigenschaften
zugewiesen werden.  Diese Eigenschaften werden in eine Datenbank abgelegt oder 
in eine von Lisp bereitgestellte Eigenschaftsliste eingetragen.  Mit der 
Funktion @mref{featurep} kann gepr@"uft werden, ob ein Symbol eine bestimmte
Eigenschaft hat und mit der Funktion @mref{properties} k@"onnen alle 
Eigenschaften eines Symbols angezeigt werden.  Die Funktion @mref{remove}@ 
l@"oscht Eigenschaften aus der Datenbank oder von der Eigenschaftsliste.  Wird 
mit der Funktion @mref{kill} ein Symbol entfernt, werden auch die zugewiesenen 
Eigenschaften gel@"oscht.

@noindent
Variablen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden:

@verbatim
   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex
@end verbatim

@noindent
Funktionen k@"onnen die folgenden Eigenschaften erhalten, die in die Datenbank
eingetragen werden:

@verbatim
   increasing     decreasing
   posfun         integervalued
@end verbatim

@noindent
Die folgenden Eigenschaften k@"onnen f@"ur Funktionen definiert werden und 
wirken sich auf die Vereinfachung dieser Funktionen aus:

@verbatim
   linear         additive       multiplicative
   outative       commutative    symmetric      
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun
@end verbatim

@noindent
Weitere Eigenschaften, die Variablen und Funktionen erhalten k@"onnen, und
die in die Lisp-Eigenschaftsliste des Symbols abgelegt werden, sind:

@verbatim
   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray
@end verbatim

@noindent
Weiterhin k@"onnen mit den Funktion @mref{put} und @mref{qput} beliebige
vom Nutzer vorgesehene Eigenschaften in die Eigenschaftsliste zu einem Symbol
abgelegt werden.  Mit der Funktion @mref{get} werden die Eigenschaften von
der Eigenschaftsliste gelesen und mit der Funktion @mref{rem} gel@"oscht.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Eigenschaften, Funktionen und Variablen f@"ur Fakten, Einf@"uhrung in Maximas Datenbank, Maximas Datenbank
@section Funktionen und Variablen f@"ur Eigenschaften
@c -----------------------------------------------------------------------------

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{alphabetic}
@defvr {Eigenschaft} alphabetic

@c @code{alphabetic} is a declaration type recognized by @code{declare}.
@c The expression @code{declare(@var{s}, alphabetic)} tells Maxima to recognize
@c as alphabetic all of the characters in @var{s}, which must be a string.
@c See also @ref{Identifiers}.

Das Kommando @code{declare(string, alphabetic)} deklariert die Zeichen der 
Zeichenkette @var{string} als alphabetisch.  Das Argument @var{string} muss eine
Zeichenkette sein.  Zeichen, die als alphabetisch deklariert sind, k@"onnen in
Maxima-Bezeichnern verwendet werden.  Siehe auch @mrefdot{Bezeichner}

Beispiele:

@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{bindtest}
@deffn {Eigenschaft} bindtest

@c Tells Maxima to trigger an error when @var{a_i} is evaluated unbound.

Hat ein Symbol @var{x} die Eigenschaft @code{bindtest} und wird es ausgewertet,
ohne das dem Symbol bisher ein Wert zugewiesen wurde, signalisiert Maxima einen 
Fehler.  Siehe auch @mrefdot{declare}

Beispiel:

@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constant}
@deffn {Eigenschaft} constant

@c @code{declare (@var{a}, constant)} declares @var{a} to be a constant.
@c See @code{declare}.
   @c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@code{declare(@var{a}, constant)} deklariert ein Symbol @var{a} als konstant.
Siehe @mref{declare} und @mrefdot{constantp}
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{constantp}
@deffn {Funktion} constantp (@var{expr})

@c Returns @code{true} if @var{expr} is a constant expression, otherwise returns
@c @code{false}.
   @c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Gibt f@"ur einen konstanten Ausdruck @var{expr} den Wert @code{true} zur@"uck,
andernfalls @code{false}.

@c An expression is considered a constant expression if its arguments are 
@c numbers (including rational numbers, as displayed with @code{/R/}), symbolic
@c constants such as @code{%pi}, @code{%e}, and @code{%i}, variables bound to a
@c constant or declared constant by @code{declare}, or functions whose arguments
@c are constant.

Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt, wenn seine 
Argumente Zahlen sind (einschlie@ss{}lich von Zahlen in einer CRE-Darstellung), 
symbolische Konstanten wie @code{%pi}, @code{%e} und @code{%i}, 
Variablen, die einen konstanten Wert haben, Variablen, die mit 
@code{declare} als konstant deklariert sind, oder Funktionen, deren Argumente 
konstant sind.

@c @code{constantp} evaluates its arguments.

Die Funktion @code{constantp} wertet das Argument aus.

Beispiele:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===
@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{declare}
@deffn {Funktion} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, @dots{})

@c Assigns the atom or list of atoms @var{a_i} the property or list of 
@c properties @var{p_i}. When @var{a_i} and/or @var{p_i} are lists, each of the 
@c atoms gets all of the properties.
@c @code{declare} quotes its arguments. @code{declare} always returns 
@c @code{done}.

Weist dem Symbol oder den Symbolen einer Liste @var{a_i} die Eigenschaft oder 
die Eigenschaften der Liste @var{p_i} zu.  Ist @var{a_i} oder @var{p_i}
eine Liste, erh@"alt jedes Atom die aufgef@"uhrten Eigenschaften.  Die Funktion
@code{declare} wertet die Argumente nicht aus.  @code{declare} gibt stets 
@code{done} zur@"uck.

@c As noted in the description for each declaration flag, for some flags
@c @code{featurep(@var{object}, @var{feature})} returns @code{true} if 
@c @var{object} has been declared to have @var{feature}. However, 
@c @code{featurep} does not recognize some flags; this is a bug.

Hat ein Symbol @var{sym} die Eigenschaft @var{prop} mit der Funktion 
@code{declare} erhalten, dann hat das Kommando @code{featurep(@var{sym}, 
@var{prop})} das Ergebnis @code{true}.  Mit der Funktion @code{properties}
k"onnen alle Eigenschaften eines Symbols angzeigt werden.

@c @code{declare} recognizes the following properties:

Die Funktion @code{declare} kennt die folgenden Eigenschaften:

@table @code
@item additive
Hat eine Funktion @code{f} die Eigenschaft @code{additive}, wird ein Ausdruck
@code{f(x + y + z + ...} zu @code{f(x) + f(y) + f(z) + ...} vereinfacht.
Siehe @mrefdot{additive}

@item alphabetic
@var{a_i} ist eine Zeichenkette, deren Zeichen als alphabetische Zeichen 
deklariert werden.  Die Zeichen k@"onnen dann in Maxima-Bezeichnern verwendet
werden.  Siehe @mref{alphabetic} f@"ur Beispiele.

@item antisymmetric, commutative, symmetric
@var{a_i} wird als eine symmetrische, antisymmetrische oder kommutative Funktion
interpretiert.  @code{commutative} und @code{symmtric} sind @"aquivalent.
Siehe @mrefcomma{antisymmetric} @mref{commutative} und @mrefdot{symmetric}

@item bindtest
Hat ein Symbol die Eigenschaft @code{bindtest} und wird es ausgewertet, ohne 
das dem Symbol bisher ein Wert zugewiesen wurde, signalisiert Maxima einen 
Fehler.  Siehe @mref{bindtest} f@"ur Beispiele.

@item constant
Hat ein Symbol die Eigenschaft @code{constant}, wird es von Maxima als eine 
Konstante interpretiert.  Siehe auch @mrefdot{constant}

@item even, odd
Erh@"alt eine Variable die Eigenschaft @code{even} oder @code{odd}, wird sie als
gerade oder ungerade interpretiert.

@item evenfun, oddfun
Erh@"alt eine Funktion oder ein Operator die Eigenschaft @code{evenfun} oder 
@code{oddfun} wird die Funktion oder der Operator von Maxima als gerade und 
ungerade interpretiert.  Diese Eigenschaft wird bei der Vereinfachung von 
Ausdr@"ucken von Maxima angewendet.  Siehe @mref{evenfun} und @mrefdot{oddfun}

@item evflag
Deklariert die Variable @code{a_i} als einen Auswertungsschalter.  W@"ahrend der
Auswertung eines Ausdrucks mit der Funktion @code{ev}, erh@"alt der 
Auswertungsschalter @code{a_i} den Wert @code{true}.  Siehe @mref{evflag} f@"ur 
Beispiele.

@item evfun
Deklariert eine Funktion @var{a_i} als eine Auswertungsfunktion.  Tritt die 
Funktion @var{a_i} als Argument der Funktion @code{ev} auf, so wird die Funktion
auf den Ausdruck angewendet.  Siehe @mref{evfun} f@"ur Beispiele.

@item feature
@var{a_i} wird als eine Eigenschaft @code{feature} interpretiert.  Andere 
Symbole k@"onnen dann diese Eigenschaft erhalten.  Siehe @mrefdot{feature}

@item increasing, decreasing
Erh@"alt eine Funktion die Eigenschaft @code{decreasing} oder @code{increasing}, 
wird die Funktion als eine steigende oder fallende Funktion interpretiert.
Siehe @mref{decreasing} und @mrefdot{increasing}

@item integer, noninteger
@var{a_i} wird als eine ganzzahlige oder nichtganzzahlige Variable 
interpretiert.  Siehe @mref{integer} und @mrefdot{noninteger}

@item integervalued
Erh@"alt eine Funktion die Eigenschaft @code{integervalued}, nimmt Maxima f@"ur
Vereinfachungen an, dass die Funktionen einen ganzzahligen Wertebereich hat.
F@"ur ein Beispiel siehe @mrefdot{integervalued}

@item lassociative, rassociative
@var{a_i} wird als eine rechts- oder links-assoziative Funktion interpretiert.
Siehe @mref{lassociative} und @mrefdot{rassociative}

@item linear
Entspricht der Deklaration einer Funktion als @code{outative} und 
@code{additive}.  Siehe auch @mrefdot{linear}

@item mainvar
Wird eine Variable als @var{mainvar} deklariert, wird sie als eine 
"Hauptvariable" interpretiert.  Eine Hauptvariable wird vor allen Konstanten und
Variablen in einer kanonischen Ordnung eines Maxima-Ausdr@"uckes angeordnet.
Die Anordnung wird durch die Funktion @code{ordergreatp} bestimmt.  Siehe auch
@mrefdot{mainvar}

@item multiplicative
Ausdr@"ucke @code{@var{a_i}(x * y * z * ...)} werden durch @code{@var{a_i}(x) * 
@var{a_i}(y) * @var{a_i}(z) * ...} ersetzt.  Die Ersetzung wird nur f@"ur das
Argument der Funktion @var{a_i} ausgef@"uhrt.  Siehe @mrefdot{multiplicative}

@item nary
Erh@"alt eine Funktion oder ein Operator die Eigenschaft @code{nary}, wird die
Funktion oder der Operator bei der Vereinfachung als Nary-Funktion oder
Nary-Operator interpretiert.  Verschachtelte Ausdr@"ucke wie 
@code{foo(x, foo(y, z))} werden zum Beispiel zu @code{foo(x, y, z)} vereinfacht.
Die Deklaration @code{nary} unterscheidet sich von der Funktion @code{nary}.
W@"ahrend der Funktionsaufruf einen neuen Operator definiert, wirkt sich die 
Deklaration nur auf die Vereinfachung aus.  Siehe auch 
@mrefdot{property_nary, nary}

@item nonarray
@var{a_i} wird nicht als ein Array interpretiert.  Diese Deklaration verhindert
die mehrfache Auswertung, wenn @var{a_i} als indizierte Variable genutzt wird.
Siehe  @mrefdot{nonarray}

@item nonscalar
@var{a_i} wird als eine nicht-skalare Variable interpretiert.  @"Uberlicherweise
wird damit ein symbolischer Vektor oder eine Matrix deklariert.  Siehe
@mrefdot{nonscalar}

@item noun
@var{a_i} wird als Substantivform interpretiert.  Abh@"angig vom Kontext wird 
@var{a_i} durch @code{'@var{a_i}} oder @code{nounify(@var{a_i})} ersetzt.
Siehe auch @mrefdot{noun} f@"ur ein Beispiel.

@item outative
Ausdr@"ucke mit der Funktion @var{a_i} werden so vereinfacht, dass konstante 
Faktoren aus dem Argument herausgezogen werden.  Hat die Funktion @var{a_i} ein 
Argument, wird ein Faktor dann als konstant angesehen, wenn er ein Symbol oder 
eine deklarierte Konstante ist.  Hat die Funktion @var{a_i} zwei oder mehr 
Argumente, wird ein Faktor dann als konstant angesehen, wenn das zweite Argument
ein Symbol und der Faktor unabh@"angig vom zweiten Argument ist.  Siehe auch
@mrefdot{outative}

@item posfun
@var{a_i} wird als eine positive Funktion interpretiert.  Siehe @mrefdot{posfun}

@item rational, irrational
@var{a_i} wird als eine rationale oder irrationale Zahl interpretiert.  Siehe
@mref{rational} und @mrefdot{irrational}

@item real, imaginary, complex
@var{a_i} wird als eine reelle, imagin@"are oder komplexe Zahl interpretiert.
Siehe @mrefcomma{real} @mref{imaginary} und @mrefdot{complex}

@item scalar
@var{a_i} wird als skalare Variable interpretiert.  Siehe @mrefdot{scalar}
@end table
@end deffn

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{decreasing}
@anchor{increasing}
@defvr  {Eigenschaft} decreasing
@defvrx {Eigenschaft} increasing

Erh@"alt eine Funktion mit der Funktion @mref{declare} die Eigenschaft 
@code{decreasing} oder @code{increasing} wird die Funktion als eine steigende 
oder fallende Funktion interpretiert.

@c TODO: KEIN BEISPIEL:
@c       DIE EIGENSCHAFT WIRD VON ASSUME GETESTET, ABER WIR HABEN ANSCHEINEND
@c       EINEN BUG.

@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{even}
@anchor{odd}
@defvr  {Eigenschaften} even
@defvrx {Eigenschaften} odd

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{even}
oder @code{odd} erhalten, wird sie von Maxima als gerade oder ungerade
interpretiert.
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{feature}
@defvr {Eigenschaft} feature

@c @code{feature}  itself is not the name of a function or variable.
@c Maxima understands two distinct types of features, system features and 
@c features which apply to mathematical expressions. See also @code{status} for 
@c information about system features. See also @code{features} and 
@c @code{featurep} for information about mathematical features.

@code{feature} ist eine Eigenschaft, die ein Symbol @var{sym} mit der Funktion 
@code{declare} erhalten kann.  In diesem Fall ist das Symbol @var{sym} selbst 
eine Eigenschaft, so dass das Kommando @code{declare(x, sym)} einem Symobl 
@var{x} die neu definierte Eigenschaft @code{sym} gibt.

Maxima unterscheidet Systemeigenschaften und mathematische Eigenschaften, die 
Symbole und Ausdr@"ucke haben k@"onnen.  F@"ur Systemeigenschaften siehe die 
Funktion @mrefdot{status}  F@"ur mathematische Eigenschaften siehe die 
Funktionen @mref{declare} und @mrefdot{featurep}

Beispiel:

@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{featurep}
@deffn {Funktion} featurep (@var{a}, @var{f})

@c Attempts to determine whether the object @var{a} has the feature @var{f} on 
@c the basis of the facts in the current database.  If so, it returns 
@c @code{true}, else @code{false}.

Stellt fest, ob das Symbol oder der Ausdruck @var{a} die Eigenschaft @var{f} 
hat.  Maxima nutzt daf@"ur die Fakten der Datenbank und die definierten 
Eigenschaften f@"ur Symbole und Funktionen.

@c Note that @code{featurep} returns @code{false} when neither @var{f} nor the 
@c negation of @var{f} can be established.

@code{featurep} gibt sowohl f@"ur den Fall @code{false} zur@"uck, dass das 
Argument @var{a} nicht die Eigenschaft @var{f} hat, als auch f@"ur den Fall, 
dass Maxima dies nicht anhand der bekannten Fakten und Eigenschaften entscheiden
kann.

@c @code{featurep} evaluates its argument.

@code{featurep} wertet seine Argumente aus.

@c See also @code{declare} and @code{features}.

Siehe auch @mref{declare} und @mrefdot{featurep}.

Beispiele:

@example
(%i1) declare (j, even)$
(%i2) featurep (j, integer);
(%o2)                           true
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{features}
@defvr {Systemvariable} features
Standardwert: @code{[]}

@c Maxima recognizes certain mathematical properties of functions and variables.
@c These are called "features".

Maxima erkennt spezielle mathematische Eigenschaften von Funktionen und 
Variablen.

@c @code{declare (@var{x}, @var{foo})} gives the property @var{foo} to the 
@c function or variable @var{x}.

@code{declare(@var{x})}, @var{foo} gibt der Funktion oder Variablen @var{x} die
Eigenschaft @var{foo}.

@c @code{declare (@var{foo}, feature)} declares a new feature @var{foo}. For 
@c example, @code{declare ([red, green, blue], feature)} declares three new 
@c features, @code{red}, @code{green}, and @code{blue}.

@code{declare(@var{foo}, feature)} deklariert die neue Eigenschaft @var{foo}. 
Zum  Beispiel deklariert @code{declare([red, green, blue], feature)} die drei 
neuen Eigenschaften @code{red}, @code{green} und @code{blue}.
 
@c The predicate @code{featurep (@var{x}, @var{foo})} returns @code{true} if 
@c @var{x} has the @var{foo} property, and @code{false} otherwise.

@code{featurep(@var{x}, @var{foo})} hat die R@"uckgabe @code{true}, wenn @var{x} 
die Eigenschaft @var{foo} hat.  Ansonsten wird @code{false} zur@"uckgegeben.

@c The infolist @code{features} is a list of known features. These are

Die Informationsliste @code{features} enth@"alt eine Liste der Eigenschaften, 
die Funktionen und Variablen erhalten k@"onnen und in die Datenbank eingetragen 
werden:

@flushleft
@code{integer}, @code{noninteger}, @code{even}, @code{odd}, @code{rational},
@code{irrational}, @code{real}, @code{imaginary}, @code{complex},
@code{analytic}, @code{increasing}, @code{decreasing}, @code{oddfun},
@code{evenfun}, @code{posfun}, @code{commutative}, @code{lassociative},
@code{rassociative}, @code{symmetric}, und @code{antisymmetric}.
@end flushleft

@c plus any user-defined features.

Hinzu kommen die vom Nutzer definierten Eigenschaften.

@c @code{features} is a list of mathematical features. There is also a list of 
@c non-mathematical, system-dependent features. See @code{status}.

@code{features} ist eine Liste der mathematischen Eigenschaften.  Es gibt 
weitere Eigenschaften.  Siehe @mref{declare} und @mrefdot{status}
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{integer}
@anchor{noninteger}
@defvr  {Eigenschaften} integer
@defvrx {Eigenschaften} noninteger

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{integer}
oder @code{noninteger} erhalten, wird sie von Maxima als eine ganze Zahl oder 
als nicht ganze Zahl interpretiert.
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{integervalued}
@defvr {Eigenschaft} integervalued

Erh@"alt eine Funktion mit @mref{declare} die Eigenschaft @code{integervalued},
nimmt Maxima f@"ur Vereinfachungen an, dass der Wertebereich der Funktion
ganzzahlig ist.

Beispiel:

@c ===beg===
@c exp(%i)^f(x);
@c declare(f, integervalued);
@c ===end===
@example
(%i1) exp(%i)^f(x);
                              %i f(x)
(%o1)                      (%e  )
(%i2) declare(f, integervalued);
(%o2)                         done
(%i3) exp(%i)^f(x);
                              %i f(x)
(%o3)                       %e
@end example
@end defvr

@c --- 22.11.2010 DK -----------------------------------------------------------
@anchor{nonarray}
@deffn {Eigenschaft} nonarray

@c The command @code{declare(a, nonarray)} tells Maxima to consider @var{a} not 
@c an array. This declaration prevents multiple evaluation, if @var{a} is a
@c subscripted variable.

@code{declare(a, nonarray)} gibt dem Symbol @var{a} die Eigenschaft nicht ein
Array zu sein.  Dies verhindert die mehrfache Auswertung, wenn das Symbol
@var{a} als indizierte Variable genutzt wird.

Beispiel:

@c ===beg===
@c a:'b$ b:'c$ c:'d$
@c a[x];
@c declare(a, nonarray);
@c a[x];
@c ===end===
@example
(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
@end example
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalar}
@defvr {Eigenschaft} nonscalar

@c Makes atoms behave as does a list or matrix with respect to the dot operator.

Hat ein Symbol die Eigenschaft @code{nonscalar}, verh@"alt es sich wie eine
Matrix oder Liste bei nicht-kommutativen Rechenoperationen.
@end defvr

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{nonscalarp}
@deffn {Funktion} nonscalarp (@var{expr})

@c Returns @code{true} if @var{expr} is a non-scalar, i.e., it contains atoms 
@c declared as non-scalars, lists, or matrices.

Gibt @code{true} zur@"uck, wenn der Ausdruck @var{expr} kein Skalar ist.  Der
Ausdruck enth@"alt dann Matrizen, Listen oder Symbole, die als @code{nonscalar}
deklariert wurden.
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{posfun}
@defvr {Eigenschaft} posfun

@c @code{declare (f, posfun)} declares @code{f} to be a positive function.
@c @code{is (f(x) > 0)} yields @code{true}.

@code{declare(f, posfun)} deklariert die Funktion @code{f} als positive
Funktion.  @code{is (f(x) > 0)} gibt dann @code{true} zur@"uck.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{printprops}
@deffn  {Funktion} printprops (@var{a}, @var{i})
@deffnx {Funktion} printprops ([@var{a_1}, @dots{}, @var{a_n}], @var{i})
@deffnx {Funktion} printprops (all, @var{i})

@c Displays the property with the indicator @var{i} associated with the 
@c atom @var{a}. @var{a} may also be a list of atoms or the atom @code{all} in 
@c which case all of the atoms with the given property will be used.  For 
@c example, @code{printprops ([f, g], atvalue)}.  @code{printprops} is for
@c properties that cannot otherwise be displayed, i.e. for @code{atvalue}, 
@c @code{atomgrad}, @code{gradef}, and @code{matchdeclare}.

Zeigt die zum Kennzeichen @var{i} zugeordnete Eigenschaft des Atoms @var{a} an. 
@var{a} kann sowohl eine Liste von Atomen, als auch das Atom @code{all} sein. 
In diesem Fall werden alle Atome angezeigt, die eine Eigenschaft zum Kennzeichen
@var{i} haben.  @code{printprops} zeigt die Eigenschaften von Atomen, die auf 
andere Weise nicht angezeigt werden k@"onnen, zum Beispiel f@"ur @code{atvalue}, 
@code{atomgrad}, @code{gradef} und @code{matchdeclare}.
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{properties}
@deffn {Funktion} properties (@var{a})

Gibt eine Liste mit den Eigenschaften zur@"uck, die das Atom @var{a} von Maxima
oder dem Nutzer erhalten hat.

@c TODO: HIER FEHLT EINE AUFLISTUNG DER MOEGLICHEN EIGENSCHAFTEN.

@end deffn

@c --- 19.11.2010 DK -----------------------------------------------------------
@anchor{props}
@defvr {Systemvariable} props
Standardwert: @code{[]}

@code{props} ist eine Liste der Symbole, die eine Eigenschaft mit den Funktionen
@code{declare}, @code{atvaule} oder @code{matchdeclare} erhalten haben.
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{propvars}
@deffn {Funktion} propvars (@var{prop})

Gibt eine Liste mit den Atomen zur@"uck, die in der Informationsliste 
@code{props} eingetragen sind und die die Eigenschaft @var{prop} haben.  Zum 
Beispiel gibt @code{propvars(atvalue)} eine Liste der Atome zur@"uck, die die 
Eigenschaft @code{atvalue} haben.
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{put}
@deffn {Funktion} put (@var{atom}, @var{value}, @var{indicator})

Weist den Wert @var{value} der Eigenschaft @var{indicator} des Atoms @var{atom}
zu.  @var{indicator} kann eine beliebige Eigenschaft sein und beschr@"ankt sich
nicht auf die vom System definierten Eigenschaften.  @code{put} wertet die 
Argumente aus.  @code{put} gibt @var{value} zur@"uck.

Beispiele:

@c ===beg===
@c put (foo, (a+b)^5, expr);
@c put (foo, "Hello", str);
@c properties (foo);
@c get (foo, expr);
@c get (foo, str);
@c ===end===
@example
(%i1) put (foo, (a+b)^5, expr);
                                   5
(%o1)                       (b + a)
(%i2) put (foo, "Hello", str);
(%o2)                         Hello
(%i3) properties (foo);
(%o3)            [[user properties, str, expr]]
(%i4) get (foo, expr);
@group
                                   5
(%o4)                       (b + a)
@end group
(%i5) get (foo, str);
(%o5)                         Hello
@end example
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{qput}
@deffn {Funktion} qput (@var{atom}, @var{value}, @var{indicator})

Arbeit wie die Funktion @code{put} mit dem Unterschied, dass @code{qput} die
Argumente nicht auswertet.

Beispiele:

@c ===beg===
@c foo: aa$ 
@c bar: bb$
@c baz: cc$
@c put (foo, bar, baz);
@c properties (aa);
@c get (aa, cc);
@c qput (foo, bar, baz);
@c properties (foo);
@c get ('foo, 'baz);
@c ===end===
@example
(%i1) foo: aa$ 
(%i2) bar: bb$
(%i3) baz: cc$
(%i4) put (foo, bar, baz);
(%o4)                          bb
(%i5) properties (aa);
(%o5)                [[user properties, cc]]
(%i6) get (aa, cc);
(%o6)                          bb
(%i7) qput (foo, bar, baz);
(%o7)                          bar
(%i8) properties (foo);
(%o8)            [value, [user properties, baz]]
(%i9) get ('foo, 'baz);
(%o9)                          bar
@end example
@end deffn

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{rational}
@anchor{irrational}
@defvr  {Eigenschaft} rational
@defvrx {Eigenschaft} irrational

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft 
@code{rational} oder @code{irrational} erhalten, wird sie von Maxima als eine 
rationale Zahl oder als eine nicht rationale Zahl interpretiert.
@end defvr

@c --- 06.02.2011 DK -----------------------------------------------------------
@anchor{real}
@anchor{imaginary}
@anchor{complex}
@defvr  {Eigenschaft} real
@defvrx {Eigenschaft} imaginary
@defvrx {Eigenschaft} complex

Hat eine Variable mit der Funktion @mref{declare} die Eigenschaft @code{real},
@code{imaginary} oder @code{complex} erhalten, wird sie von Maxima als eine 
reelle Zahl, imagin@"are Zahl oder als eine komplexe Zahl interpretiert.
@end defvr

@c --- 03.01.2011 DK -----------------------------------------------------------
@anchor{rem}
@deffn {Funktion} rem (@var{atom}, @var{indicator})

Entfernt die Eigenschaft @var{indicator} vom Atom @var{atom}.
@end deffn

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{remove}
@deffn  {Funktion} remove (@var{a_1}, @var{p_1}, @dots{}, @var{a_n}, @var{p_n})
@deffnx {Funktion} remove ([@var{a_1}, @dots{}, @var{a_m}], [@var{p_1}, @dots{}, @var{p_n}], @dots{})
@deffnx {Funktion} remove ("@var{a}", operator)
@deffnx {Funktion} remove (@var{a}, transfun)
@deffnx {Funktion} remove (all, @var{p})

Entfernt Eigenschaften von Atomen.

@code{remove(@var{a_1}, @var{p_1}, ..., @var{a_n}, @var{p_n})} entfernt die
Eigenschaft @code{p_k} von dem Atom @code{a_k}.

@code{remove([@var{a_1}, ..., @var{a_m}], [@var{p_1}, ..., @var{p_n}], ...)}
entfernt die Eigenschaften @var{p_1}, @dots{}, @var{p_n} von den Atomen 
@var{a_1}, @dots{}, @var{a_m}.  Es k@"onnen mehrere Paare an Listen angegeben 
werden.

@code{remove(all, @var{p})} entfernt die Eigenschaft @var{p} von allen Atomen, 
die diese Eigenschaft aufweisen.

Die zu entfernenden Eigenschaften k@"onnen vom System definierte Eigenschaften
wie @code{function}, @code{macro}, @code{mode_declare} oder nutzerdefinierte
Eigenschaften sein.

@code{remove("@var{a}", operator)} oder @code{remove("@var{a}", op)}
entfernen vom atom @var{a} die Operatoreigenschaften, die mit den Funktionen 
@code{prefix}, @code{infix}, @code{nary}, @code{postfix}, @code{matchfix} oder
@code{nofix} definiert wurden.  Die Namen von Operatoren m@"ussen als eine 
Zeichenkette angegeben werden.

@code{remove} gibt immer @code{done} zur@"uck.
@end deffn

@c --- 22.10.2010 DK -----------------------------------------------------------
@anchor{scalar}
@defvr {Eigenschaft} scalar

Hat ein Symbol die Eigenschaft @code{scalar}, verh@"alt es sich wie ein Skalar 
bei nicht-kommutativen Rechenoperationen.
@end defvr

@c --- 29.12.2010 DK -----------------------------------------------------------
@anchor{scalarp}
@deffn {Funktion} scalarp (@var{expr})

Gibt @code{true} zur@"uck, wenn der Ausdruck @var{expr} eine Zahl, Konstante, 
ein als Skalar definiertes Symbol oder ein aus diesen Objekten zusammengesetzter
Ausdruck ist.  Der Ausdruck darf jedoch keine Liste oder eine Matrix sein.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Fakten, Funktionen und Variablen f@"ur Aussagen, Funktionen und Variablen f@"ur Eigenschaften, Maximas Datenbank
@section Funktionen und Variablen f@"ur Fakten
@c -----------------------------------------------------------------------------

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{activate}
@deffn {Funktion} activate (@var{context_1}, @dots{}, @var{context_n})

@c Activates the contexts @var{context_1}, ..., @var{context_n}. The facts in 
@c these contexts are then available to make deductions and retrieve 
@c information. The facts in these contexts are not listed by @code{facts ()}.

Das Kommando @code{activate(@var{context})} aktiviert den Kontext @var{context}.
Der Funktion @code{activate} k@"onnen mehrere Kontexte @var{context_1}, @dots{},
@var{context_n} @"ubergeben werden.  Nur die Aussagen und Fakten eines aktiven
Kontextes stehen f@"ur die Auswertung von Aussagen zur Verf@"ugung.

Maxima gibt @code{done} zur@"uck, wenn der Kontext erfolgreich aktiviert werden
konnte oder wenn der Kontext bereits aktiv ist.  Wird versucht einen nicht 
existierenden Kontext zu aktivieren, gibt Maxima eine Fehlermeldung aus.

Das Kommando @code{facts()} gibt die Fakten und Aussagen des aktuellen Kontextes
aus.  Die Aussagen und Fakten anderer Kontexte k@"onnen zwar aktiv sein, sind 
aber in der R@"uckgabe von @code{facts} nicht enthalten.  Um die Aussagen und 
Fakten eines anderen als des aktuellen Kontexts auszugeben, kann das Kommando 
@code{facts(@var{context})} ausgef@"uhrt werden.

@c The variable @code{activecontexts} is the list of contexts which are active 
@c by way of the @code{activate} function.

Die Systemvariable @mref{activecontexts} enth@"alt eine Liste der aktiven
Kontexte.  Siehe auch die Systemvariable @mref{contexts} f@"ur eine Liste
aller Kontexte, die Maxima kennt.
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{activecontexts}
@defvr {Systemvariable} activecontexts
Standardwert: @code{[]}

@c @code{activecontexts} is a list of the contexts which are active by way of 
@c the @code{activate} function, as opposed to being active because they are 
@c subcontexts of the current context.

Die Systemvariable @code{activecontexts} enth@"alt eine Liste der Kontexte, die
mit der Funktion @code{activate} aktiviert wurden.  Unterkontexte sind aktiv,
ohne dass die Funktion @code{activate} aufgerufen werden muss und sind nicht in
der Liste @code{activecontexts} enthalten.  Siehe auch die Funktion
@mref{activate} f@"ur die Aktivierung eines Kontextes und die Systemvariable
@mref{contexts} f@"ur eine Liste aller vorhandenen Kontexte.
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{askinteger}
@deffn  {Funktion} askinteger (@var{expr}, integer)
@deffnx {Funktion} askinteger (@var{expr})
@deffnx {Funktion} askinteger (@var{expr}, even)
@deffnx {Funktion} askinteger (@var{expr}, odd)

@c @code{askinteger (@var{expr}, integer)} attempts to determine from the 
@c @code{assume} database whether @var{expr} is an integer. @code{askinteger} 
@c prompts the user if it cannot tell otherwise,
@c UMM, askinteger AND asksign DO NOT APPEAR TO HAVE ANY EFFECT ON THE assume 
@c DATABASE !!!
@c and attempt to install the information in the database if possible.
@c @code{askinteger (@var{expr})} is equivalent to @code{askinteger (@var{expr},
@c integer)}.

Das Kommando @code{askinteger(@var{expr}, integer)} versucht anhand der Aussagen
und Fakten der aktiven Kontexte zu entscheiden, ob @var{expr} eine ganze Zahl
repr@"asentiert.  Kann @code{askinteger} die Frage nicht entscheiden, fragt 
Maxima den Nutzer.  Die Antwort wird dem aktuellen Kontext hinzugef@"ugt.  
@code{askinteger(@var{expr})} ist @"aquivalent zu 
@code{askinteger(@var{expr}, integer)}.

@c @code{askinteger (@var{expr}, even)} and @code{askinteger (@var{expr}, odd)}
@c likewise attempt to determine if @var{expr} is an even integer or odd 
@c integer, respectively.

@code{askinteger(@var{expr}, even)} und @code{askinteger(@var{expr}, odd)}
versuchen zu entscheiden, ob @var{expr} eine gerade oder ungerade ganze Zahl
repr@"asentiert.  Kann Maxima dies nicht entscheiden, wird der Nutzer gefragt.
Die Antwort wird dem aktuellen Kontext hinzugef@"ugt.

@c ===beg===
@c askinteger(n,integer);
@c askinteger(e,even);
@c declare(f,integervalued);
@c askinteger(f(x));
@c ===end===
@example
(%i1) askinteger(n,integer);
Is n an integer?
yes;
(%o1)                          yes
(%i2) askinteger(e,even);
Is e an even number?
yes;
(%o2)                          yes
(%i3) facts();
(%o3)           [kind(n, integer), kind(e, even)]
(%i4) declare(f,integervalued);
(%o4)                         done
(%i5) askinteger(f(x));
(%o5)                          yes
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{asksign}
@deffn {Funktion} asksign (@var{expr})

@c First attempts to determine whether the specified expression is positive, 
@c negative, or zero.  If it cannot, it asks the user the necessary questions to
@c complete its deduction.  The user's answer is recorded in the data base for 
@c the duration of the current computation. The return value of @code{asksign} 
@c is one of @code{pos}, @code{neg}, or @code{zero}.

Die Funktion @code{asksign} versucht zu entscheiden, ob der Ausdruck @var{expr}
einen positiven, negativen oder den Wert Null repr@"asentiert.  Kann Maxima dies
nicht feststellen, wird der Nutzer nach weiteren Informationen gefragt, um die 
Frage zu entscheiden.  Die Antworten des Nutzers werden f@"ur die laufende 
Auswertung dem aktuellen Kontext hinzugef@"ugt.  Der R@"uckgabewert der 
Funktion @code{asksign} ist @code{pos}, @code{neg} oder @code{zero} f@"ur einen
positiven, negativen oder den Wert Null.
@end deffn

@c --- 26.08.2010 DK -----------------------------------------------------------
@anchor{assume}
@deffn {Funktion} assume (@var{pred_1}, @dots{}, @var{pred_n})

@c Adds predicates @var{pred_1}, ..., @var{pred_n} to the current context. If a 
@c predicate is inconsistent or redundant with the predicates in the current 
@c context, it is not added to the context. The context accumulates predicates 
@c from each call to @code{assume}.
@c @code{assume} returns a list whose elements are the predicates added to the 
@c context or the atoms @code{redundant} or @code{inconsistent} where 
@c applicable.

F@"ugt die Aussagen @var{pred_1}, @dots{}, @var{pred_n} dem aktuellen Kontext 
hinzu.  Eine inkonsistente oder redundante Aussage wird dem Kontext nicht
hinzugef@"ugt.  @code{assume} gibt eine Liste mit den Aussagen zur@"uck, die dem
Kontext hinzugef@"ugt wurden, oder die Symbole @code{redunant} und 
@code{inconsistent}.

@c The predicates @var{pred_1}, ..., @var{pred_n} can only be expressions with 
@c the relational operators @code{< <= equal notequal >=} and @code{>}. 
@c Predicates cannot be literal equality @code{=} or literal inequality @code{#}
@c expressions, nor can they be predicate functions such as @code{integerp}.

Die Aussagen @var{pred_1}, @dots{}, @var{pred_n} k@"onnen nur Ausdr@"ucke mit 
den relationalen Operatoren @code{"<"}, @code{"<="}, @code{equal}, 
@code{notequal}, @code{">="} und @code{">"} sein.  Aussagen k@"onnen nicht die
Operatoren @code{"="} f@"ur Gleichungen oder @code{"#"} f@"ur Ungleichungen 
enthalten.  Auch k@"onnen keine Aussagefunktionen wie @code{integerp} verwendet
werden.

@c Compound predicates of the form @code{@var{pred_1} and ... and @var{pred_n}}
@c are recognized, but not @code{@var{pred_1} or ... or @var{pred_n}}.
@c @code{not @var{pred_k}} is recognized if @var{pred_k} is a relational 
@c predicate. Expressions of the form @code{not (@var{pred_1} and @var{pred_2})}
@c and @code{not (@var{pred_1} or @var{pred_2})} are not recognized.

Zusammengesetzte Aussagen mit dem Operator @code{and} der Form 
@code{@var{pred_1} and ... and @var{pred_n}} sind m@"oglich, nicht dagegen 
Aussagen mit dem Operator @code{or} der Form @code{@var{pred_1} or ... or 
@var{pred_n}}.  Ein Ausdruck mit dem Operator @code{not} der Form 
@code{not(@var{pred_k})} ist dann m@"oglich, wenn @var{pred_k} eine 
relationale Aussage ist.  Aussagen der Form @code{not (@var{pred_1} and
@var{pred_2})} und @code{not (@var{pred_1} or @var{pred_2})} sind dagegen nicht
m@"oglich.

@c Maxima's deduction mechanism is not very strong; there are many obvious 
@c consequences which cannot be determined by @code{is}. This is a known 
@c weakness.

Der Folgerungsmechanismus von Maxima ist nicht sehr stark.  Viele 
Schlu@ss{}folgerungen k@"onnen von Maxima nicht abgeleitet werden.  Dies ist 
eine bekannte Schw@"ache von Maxima.

@c @code{assume} does not handle predicates with complex numbers. If a predicate
@c contains a complex number @code{assume} returns @code{inconsistent} or 
@c @code{redunant}

@code{assume} behandelt keine Aussagen mit komplexen Zahlen.  Enth@"alt eine
Aussage eine komplexe Zahl, gibt @code{assume} den Wert @code{inconsistent}
oder @code{redunant} zur@"uck.

@c @code{assume} evaluates its arguments.

@code{assume} wertet die Argumente aus.

Siehe auch @mrefcomma{is} @mrefcomma{facts} @mrefcomma{forget} @mref{context}@ 
und @mrefdot{declare}

Beispiele:

@c ===beg===
@c assume (xx > 0, yy < -1, zz >= 0);
@c assume (aa < bb and bb < cc);
@c facts ();
@c is (xx > yy);
@c is (yy < -yy);
@c is (sinh (bb - aa) > 0);
@c forget (bb > aa);
@c prederror : false;
@c is (sinh (bb - aa) > 0);
@c is (bb^2 < cc^2);
@c ===end===
@example
(%i1) assume (xx > 0, yy < -1, zz >= 0);
(%o1)              [xx > 0, yy < - 1, zz >= 0]
(%i2) assume (aa < bb and bb < cc);
(%o2)                  [bb > aa, cc > bb]
(%i3) facts ();
(%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
(%i4) is (xx > yy);
(%o4)                         true
(%i5) is (yy < -yy);
(%o5)                         true
(%i6) is (sinh (bb - aa) > 0);
(%o6)                         true
(%i7) forget (bb > aa);
(%o7)                       [bb > aa]
(%i8) prederror : false;
(%o8)                         false
(%i9) is (sinh (bb - aa) > 0);
(%o9)                        unknown
(%i10) is (bb^2 < cc^2);
(%o10)                       unknown
@end example
@end deffn

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assumescalar}
@defvr {Optionsvariable} assumescalar
Standardwert: @code{true}

@c @code{assumescalar} helps govern whether expressions @code{expr} for which 
@c @code{nonscalarp (expr)} is @code{false} are assumed to behave like scalars
@c for certain transformations.
@c Let @code{expr} represent any expression other than a list or a matrix, and 
@c let @code{[1, 2, 3]} represent any list or matrix. Then 
@c @code{expr . [1, 2, 3]} yields @code{[expr, 2 expr, 3 expr]} if 
@c @code{assumescalar} is @code{true}, or @code{scalarp (expr)} is @code{true}, 
@c or @code{constantp (expr)} is @code{true}.
@c If @code{assumescalar} is @code{true}, such expressions will behave like 
@c scalars only for commutative operators, but not for noncommutative 
@c multiplication @code{.}.
@c When @code{assumescalar} is @code{false}, such expressions will behave like 
@c non-scalars.
@c When @code{assumescalar} is @code{all}, such expressions will behave like 
@c scalars for all the operators listed above.

Die Optionsvariable @code{assumescalar} kontrolliert, wie ein Ausdruck von den
arithmetischen Operatoren @code{"+"}, @code{"*"}, @code{"^"}, @code{"."} und
@code{"^^"} behandelt wird, wenn Maxima nicht ermitteln kann, ob der Ausdruck
ein Skalar oder Nicht-Skalar ist.  @code{assumescalar} hat drei m@"ogliche
Werte:

@table @code
@item false
Unbekannte Ausdr@"ucke werden als ein Nicht-Skalar behandelt.

@item true
Unbekannte Ausdr@"ucke werden als ein Skalar f@"ur die kommutativen 
arithmetischen Operatoren @code{"+"}, @code{"*"} und @code{"^"} behandelt.

@item all
Unbekannte Ausdr@"ucke werden f@"ur alle arithmetischen Operatoren als ein
Skalar behandelt.
@end table

Es ist besser Variablen als ein Skalar oder Nicht-Skalar mit der Funktion
@mref{declare} zu deklarieren, anstatt die Vereinfachung mit der 
Optionsvariablen @code{assumescalar} zu kontrollieren.  Siehe auch die 
Eigenschaften @mref{scalar} und @mref{nonscalar} sowie die Funktionen 
@mref{scalarp} und @mrefdot{nonscalarp}

Beispiele:

Maxima kann nicht ermitteln, ob das Symbol @code{x} ein Skalar oder ein
Nicht-Skalar ist.

@c ===beg===
@c scalarp(x);
@c nonscalarp(x);
@c ===end===
@example
(%i1) scalarp(x);
(%o1)                         false
(%i2) nonscalarp(x);
(%o2)                         false
@end example

Hat @code{assumescalar} den Wert @code{true}, behandelt Maxima das Symbol 
@code{x} als einen Skalar f@"ur die kommutative Multiplikation.

@c ===beg===
@c x * [a,b,c], assumescalar:false;
@c x * [a,b,c], assumescalar:true;
@c ===end===
@example
(%i3) x * [a,b,c], assumescalar:false;
(%o3)                      x [a, b, c]
(%i4) x * [a,b,c], assumescalar:true;
(%o4)                    [a x, b x, c x]
@end example

F@"ur die nicht kommutative Multiplikation behandelt Maxima das Symbol @code{x}
dann als einen Skalar, wenn @code{assumescalar} den Wert @code{all} hat.

@c ===beg===
@c x . [a,b,c], assumescalar:false;
@c x . [a,b,c], assumescalar:true;
@c ===end===
@example
(%i5) x . [a,b,c], assumescalar:false;
(%o5)                     x . [a, b, c]
(%i6) x . [a,b,c], assumescalar:true;
(%o6)                     x . [a, b, c]
(%i7) x . [a,b,c], assumescalar:all;
(%o7)                 [x . a, x . b, x . c]
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assume_pos}
@defvr {Optionsvariable} assume_pos
Standardwert: @code{false}

@c When @code{assume_pos} is @code{true} and the sign of a parameter @var{x} 
@c cannot be determined from the current context
@c @c WHAT ARE THOSE OTHER CONSIDERATIONS ??
@c or other considerations, @code{sign} and @code{asksign (@var{x})} return 
@c @code{true}. This may forestall some automatically-generated @code{asksign} 
@c queries, such as may arise from @code{integrate} or other computations.
@c By default, a parameter is @var{x} such that @code{symbolp (@var{x})} or 
@c @code{subvarp (@var{x})}. The class of expressions considered parameters can
@c be modified to some extent via the variable @code{assume_pos_pred}.

Die Optionsvariable @code{assume_pos} kontrolliert das Ergebnis der Funktionen
@mref{sign} und @mrefcomma{asksign} f@"ur den Fall, dass Maxima das Vorzeichen
einer Variablen oder indizierten Variablen nicht aus den aktiven Kontexten 
ermitteln kann.  Hat @code{assume_pos} den Wert @code{true}, dann wird f@"ur 
Variable oder indizierte Variable, immer das Ergebnis @code{pos} ermittelt, wenn
die Optionsvariable @code{assume_pos_pred} den Standardwert @code{false} hat und
das Vorzeichen nicht aus den aktiven Kontexten ermittelt werden kann.

Die Optionsvariable @mref{assume_pos_pred} hat den Standardwert @code{false}.
In diesem Fall werden von Maxima Variablen und indizierte Variablen als positiv
angenommen, wenn @code{assume_pos} den Wert @code{true} hat.  Der 
Optionsvariablen @mref{assume_pos_pred} kann eine Aussagefunktion mit einem
Argument zugewiesen werden.  Hat die Aussagefunktion f@"ur ein Argument 
@var{expr} das Ergebnis @code{true}, wird das Argument als positiv 
angenommen, wenn die Optionsvariable @code{assume_pos} den Wert @code{true} hat
und Maxima das Vorzeichen nicht aus den aktiven Kontexten ermitteln kann.

@c @code{sign} and @code{asksign} attempt to deduce the sign of expressions from
@c the sign of operands within the expression. For example, if @code{a} and 
@c @code{b} are both positive, then @code{a + b} is also positive.
@c However, there is no way to bypass all @code{asksign} queries. In particular,
@c when the @code{asksign} argument is a difference @code{@var{x} - @var{y}} or 
@c a logarithm @code{log(@var{x})}, @code{asksign} always requests an input from
@c the user, even when @code{assume_pos} is @code{true} and 
@c @code{assume_pos_pred} is a function which returns @code{true} for all 
@c arguments.

Die Funktionen @code{sign} und @code{asksign} versuchen das Vorzeichen eines
Ausdrucks anhand der Vorzeichen der Argumente zu ermitteln.  Sind zum Beispiel
@code{a} und @code{b} beide positiv, dann wird f@"ur den Ausdruck @code{a+b} ein
positives Vorzeichen ermittelt.  Auch wenn die Vorzeichen der Variablen @code{a}
und @code{b} nicht bekannt sind, hat daher @code{asksign(a+b)} das Ergebnis
@code{pos}, wenn @code{assume_pos} den Wert @code{true} hat, da in diesem Fall
die Variablen als positiv angenommen werden.

Es gibt jedoch keine M@"oglichkeit, alle Ausdr@"ucke grunds@"atzlich als positiv
zu erkl@"aren.  Selbst wenn der Optionsvariablen @code{assume_pos_pred} eine 
Aussagefunktion zugewiesen wird, die alle Ausdr@"ucke als positiv erkl@"art,
werden Differenzen @code{a-b} oder das Vorzeichen der Logarithmusfunktion 
@code{log(a)} nicht als positiv ermittelt.  Die Fragen der Funktion 
@code{asksign} an den Nutzer k@"onnen daher nie vollst@"andig mit dem 
Mechanismus der Optionsvariablen @code{assume_pos} unterdr@"uckt werden.

Siehe f@"ur weitere Beispiele die Optionsvariable @mrefdot{assume_pos_pred}

Beispiele:

Das Vorzeichen der Variablen @code{x} ist nicht bekannt.  Erh@"alt die
Optionsvariable @code{assume_pos} den Wert @code{true}, wird f@"ur die Variable
@code{x} und die indizierte Variable @code{x[1]} ein positives Vorzeichen
ermittelt.

@example
(%i1) sign(x);
(%o1)                          pnz
(%i2) assume_pos:true;
(%o2)                         true
(%i3) sign(x);
(%o3)                          pos
(%i4) sign(x[1]);
(%o4)                          pos
@end example

Die Vorzeichen der Variablen @code{a} und @code{b} sind nicht bekannt.  Maxima
ermittelt ein positives Vorzeichen f@"ur die Summe der Variablen.  Das
Vorzeichen der Differenz ist dagegen weiterhin nicht bekannt.

@example
(%i5) sign(a+b);
(%o5)                          pos
(%i6) sign(a-b);
(%o6)                          pnz
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{assume_pos_pred}
@defvr {Optionsvariable} assume_pos_pred
Standardwert: @code{false}

@c When @code{assume_pos_pred} is assigned the name of a function or a lambda 
@c expression of one argument @var{x}, that function is called to determine
@c whether @var{x} is considered a parameter for the purpose of 
@c @code{assume_pos}. @code{assume_pos_pred} is ignored when @code{assume_pos} 
@c is @code{false}.
@c The @code{assume_pos_pred} function is called by @code{sign} and 
@c @code{asksign} with an argument @var{x} which is either an atom, a 
@c subscripted variable, or a function call expression. If the 
@c @code{assume_pos_pred} function returns @code{true}, @var{x} is considered a 
@c parameter for the purpose of @code{assume_pos}.
@c By default, a parameter is @var{x} such that @code{symbolp (@var{x})} or 
@c @code{subvarp (@var{x})}.

Der Optionsvariablen @code{assume_pos_pred} kann eine Aussagefunktion wie zum
Beispiel @mref{symbolp} oder ein Lambda-Ausdruck mit einem Argument @code{x}
zugewiesen werden.  Hat die Optionsvariable @mref{assume_pos} den Wert
@code{true}, werden Variablen, indizierte Variablen oder die Werte von 
Funktionen dann als positiv angenommen, wenn die Aussagefunktion das Ergebnis 
@code{true} hat.

Die Aussagefunktion wird intern von den Funktionen @mref{sign} und 
@mref{asksign} aufgerufen, wenn die Optionsvariable @code{assume_pos} den Wert
@code{true} hat und das Vorzeichen einer Variablen, indizierten Variablen oder
f@"ur den Wert einer Funktion nicht ermittelt werden konnte.  Gibt die
Aussagefunktion das Ergebnis @code{true} zur@"uck, wird das Argument als
positiv angenommen.

Hat die Optionsvariable @code{assume_pos_pred} den Standardwert @code{false}
werden Variablen und indizierte Variablen von Maxima als positiv angenommen,
wenn die Optionsvariable @code{assume_pos} den Wert @code{true} hat.  Das 
entspricht einer Aussagefunktion, die als @code{lambda([x], symbolp(x) or
subvarp(x))} definiert wird.

Siehe auch @mref{assume} und @mrefdot{assume_pos}

Beispiele:

Der Optionsvariablen @code{assume_pos_pred} wird der Name der Aussagefunktion
@code{symbolp} zugewiesen.  Indizierte Variablen werden nun nicht mehr als 
positiv angenommen, wie es f@"ur den Standartwert @code{false} gilt.

@c ===beg===
@c assume_pos: true$
@c assume_pos_pred: symbolp$
@c sign (a);
@c sign (a[1]);
@c ===end===
@example
(%i1) assume_pos: true$
(%i2) assume_pos_pred: symbolp$
(%i3) sign (a);
(%o3)                          pos
(%i4) sign (a[1]);
(%o4)                          pnz
@end example

Der Optionsvariablen @code{assume_pos_pred} wird ein Lambda-Ausdruck zugewiesen,
der f@"ur alle Argumente das Ergebnis @code{true} hat.  Die Funktion @code{sign}
ermittelt nun f@"ur Variablen, indizierte Variablen und den Werten von 
Funktionen ein positives Vorzeichen.  Dies trifft jedoch nicht f@"ur die 
Logarithmusfunktion oder eine Differenz zu.

@c ===beg===
@c assume_pos: true$
@c assume_pos_pred: lambda([x], true);
@c sign(a);
@c sign(a[1]);
@c sign(foo(x));
@c sign(foo(x)+foo(y));
@c sign(log(x));
@c sign(x-y);
@c ===end===
@example
(%i1) assume_pos: true$
(%i2) assume_pos_pred: lambda([x], true);
(%o2)                   lambda([x], true)
(%i3) sign(a);
(%o3)                          pos
(%i4) sign(a[1]);
(%o4)                          pos
(%i5) sign(foo(x));
(%o5)                          pos
(%i6) sign(foo(x)+foo(y));
(%o6)                          pos
(%i7) sign(log(x));
(%o7)                          pnz
(%i8) sign(x-y);
(%o8)                          pnz
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{context}
@defvr {Optionsvariable} context
Standardwert: @code{initial}

@c @code{context} names the collection of facts maintained by @code{assume} and 
@c @code{forget}. @code{assume} adds facts to the collection named by 
@c @code{context}, while @code{forget} removes facts.

Die Optionsvariable @code{context} enth@"alt den Namen des aktuellen Kontextes.
Das ist der Kontext, der die Aussagen der Funktion @mref{assume} oder die mit 
der Funktion @mref{declare} definierten Eigenschaften aufnimmt und aus dem die 
Aussagen mit der Funktion @mref{forget} oder die Eigenschaften mit der Funktion
@mref{remove} gel@"oscht werden.

@c Binding @code{context} to a name @var{foo} changes the current context to 
@c @var{foo}. If the specified context @var{foo} does not yet exist, it is 
@c created automatically by a call to @code{newcontext}.
   @c ISN'T THIS NEXT BIT EQUIVALENT TO THE FIRST ??
@c The specified context is activated automatically.

Wird der Optionsvariablen @code{context} der Name eines existierenden Kontextes
zugewiesen, wird dieser zum aktuellen Kontext.  Existiert der Kontext noch 
nicht, wird er durch Aufruf der Funktion @mref{newcontext} erzeugt.

@c See @code{contexts} for a general description of the context mechanism.

Siehe auch @mref{contexts} f@"ur eine allgemeinere Beschreibung von Kontexten.

Beispiele:

Der Standardkontext ist @code{initial}.  Es wird ein neuer Kontext
@code{mycontext} generiert, der die Aussagen und Eigenschaften aufnimmt.

@c ===beg===
@c context;
@c context:mycontext;
@c contexts;
@c assume(a>0);
@c declare(b,integer);
@c facts(mycontext);
@c ===end===
@example
(%i1) context;
(%o1)                        initial
(%i2) context:mycontext;
(%o2)                       mycontext
(%i3) contexts;
(%o3)             [mycontext, initial, global]
(%i4) assume(a>0);
(%o4)                        [a > 0]
(%i5) declare(b,integer);
(%o5)                         done
(%i6) facts(mycontext);
(%o6)               [a > 0, kind(b, integer)]
@end example
@end defvr

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{contexts}
@defvr {Systemvariable} contexts
Standardwert: @code{[initial, global]}

@c @code{contexts} is a list of the contexts which currently exist, including 
@c the currently active context.
@c The context mechanism makes it possible for a user to bind together and name 
@c a collection of facts, called a context. Once this is done, the user can have
@c Maxima assume or forget large numbers of facts merely by activating or
@c deactivating their context.
@c Any symbolic atom can be a context, and the facts contained in that context 
@c will be retained in storage until destroyed one by one by calling 
@c @code{forget} or destroyed as a whole by calling @code{kill} to destroy the 
@c context to which they belong.
@c Contexts exist in a hierarchy, with the root always being the context 
@c @code{global}, which contains information about Maxima that some functions 
@c need.  When in a given context, all the facts in that context are "active" 
@c (meaning that they are used in deductions and retrievals) as are all the 
@c facts in any context which is a subcontext of the active context.
@c When a fresh Maxima is started up, the user is in a context called 
@c @code{initial}, which has @code{global} as a subcontext.

Die Systemvariable @code{contexts} enth@"alt eine Liste der Kontexte, die 
Maxima bekannt sind.  Die Liste enth@"alt auch die nicht aktiven Kontexte.

Die Kontexte @code{global} und @code{initial} sind immer vorhanden.  Diese 
werden von Maxima initialisiert und k@"onnen nicht entfernt werden.  Der Kontext
@code{global} enth@"alt Aussagen und Fakten f@"ur Systemvariablen und
Systemfunktionen.  Mit den Funktionen @mref{newcontext} oder @mref{supcontext}@ 
kann der Nutzer weitere Kontexte anlegen.

Die Kontexte haben eine Hierarchie.  Die Wurzel ist immer der Kontext
@code{global}, der damit ein Unterkontext aller anderen Kontexte und immer aktiv
ist.  Der Kontext @code{initial} ist anfangs leer und nimmt, sofern kein 
weiterer Kontext angelegt wurde, die Aussagen und Fakten des Nutzers auf, die 
mit den Funktionen @mref{assume} und @mref{declare} definiert werden.  Mit der
Funktion @mref{facts} k@"onnen die Aussagen und Fakten von Kontexten angezeigt
werden.

Die Verwaltung verschiedener Kontexte erm@"oglicht es, Aussagen und Fakten in
einem Kontext zusammenzustellen.  Durch das Aktivieren mit der Funktion
@mref{activate} oder Deaktivieren mit der Funktion @mref{deactivate} k@"onnen
diese Aussagen und Fakten f@"ur Maxima verf@"ugbar gemacht oder wieder
ausgeschaltet werden.

Die Aussagen und Fakten in einem Kontext bleiben so lange verf@"ugbar, bis sie 
mit den Funktionen @mref{forget} oder @mref{remove} gel@"oscht werden.
Weiterhin kann der gesamte Kontext mit der Funktion @mref{killcontext} entfernt
werden.

Beispiel:

Das folgende Beispiel zeigt wie ein Kontext @code{mycontext} angelegt wird.  Der
Kontext enth@"alt die Aussage @code{[a>0]}.  Der Kontext kann mit der Funktion
@code{activate} aktiviert werden, um die Aussage verf@"ugbar zu machen.

@c ===beg===
@c newcontext(mycontext);
@c context;
@c assume(a>0);
@c context:initial;
@c is(a>0);
@c activate(mycontext);
@c is(a>0);
@c ===end===
@example
(%i1) newcontext(mycontext);
(%o1)                       mycontext
(%i2) context;
(%o2)                       mycontext
(%i3) assume(a>0);
(%o3)                        [a > 0]
(%i4) context:initial;
(%o4)                        initial
(%i5) is(a>0);
(%o5)                        unknown
(%i6) activate(mycontext);
(%o6)                         done
(%i7) is(a>0);
(%o7)                         true
@end example
@end defvr

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{deactivate}
@deffn {Funktion} deactivate (@var{context_1}, @dots{}, @var{context_n})

@c Deactivates the specified contexts @var{context_1}, ..., @var{context_n}.

Die Kontexte @var{context_1}, @dots{}, @var{context_n} werden deaktiviert.  Die
Aussagen und Fakten dieser Kontexte stehen f@"ur die Auswertung von Aussagen 
nicht mehr zur Verf@"ugung.  Die Kontexte werden nicht gel@"oscht und k@"onnen 
mit der Funktion @mref{activate} wieder aktiviert werden.

Die deaktivierten Kontexte werden aus der Liste @mref{activecontexts} entfernt.
@end deffn

@c --- 12.02.2011 DK -----------------------------------------------------------
@anchor{facts}
@deffn  {Funktion} facts (@var{item})
@deffnx {Funktion} facts ()

@c If @var{item} is the name of a context, @code{facts (@var{item})} returns a 
@c list of the facts in the specified context.

Ist @var{item} der Name eines Kontextes, gibt @code{facts(@var{item})} eine
Liste der Aussagen und Fakten des Kontextes @code{item} zur@"uck.

@c If @var{item} is not the name of a context, @code{facts (@var{item})} returns
@c a list of the facts known about @var{item} in the current context.  Facts 
@c that are active, but in a different context, are not listed.

Ist @var{item} nicht der Name eines Kontextes, gibt @code{facts(@var{item})} 
eine Liste mit den Aussagen und Fakten zur@"uck, die zu @var{item} im aktuellen
Kontext bekannt sind.  Aussagen und Fakten die zu einem anderen aktiven Kontext
geh@"oren einschlie@ss{}lich der Unterkontexte, sind nicht in der Liste 
enthalten.

@c @code{facts ()} (i.e., without an argument) lists the current context.

@code{facts()} gibt eine Liste der Fakten des aktuellen Kontextes zur@"uck.

Beispiel:

@c ===beg===
@c context:mycontext;
@c assume(a>0, a+b>0, x<0);
@c facts();
@c facts(a);
@c facts(x);
@c context:initial;
@c activate(mycontext);
@c facts();
@c facts(mycontext);
@c ===end===
@example
(%i1) context:mycontext;
(%o1)                       mycontext
(%i2) assume(a>0, a+b>0, x<0);
(%o2)               [a > 0, b + a > 0, x < 0]
(%i3) facts();
(%o3)               [a > 0, b + a > 0, 0 > x]
(%i4) facts(a);
(%o4)                  [a > 0, b + a > 0]
(%i5) facts(x);
(%o5)                        [0 > x]
(%i6) context:initial;
(%o6)                        initial
(%i7) activate(mycontext);
(%o7)                         done
(%i8) facts();
(%o8)                          []
(%i9) facts(mycontext);
(%o9)               [a > 0, b + a > 0, 0 > x]
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{forget}
@deffn  {Funktion} forget (@var{pred_1}, @dots{}, @var{pred_n})
@deffnx {Funktion} forget (@var{L})

@c Removes predicates established by @code{assume}. The predicates may be 
@c expressions equivalent to (but not necessarily identical to) those previously
@c assumed.
@c @code{forget (@var{L})}, where @var{L} is a list of predicates, forgets each
@c item on the list.

Entfernt Aussagen, die mit @code{assume} einem Kontext hinzugef@"ugt wurden.
Die Aussagen k@"onnen Ausdr@"ucke sein, die @"aquivalent aber nicht unbedingt
identisch zu vorherigen Fakten sind.

@code{forget(@var{L})} entfernt alle Aussagen, die in der Liste @var{L}
enthalten sind.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{is}
@deffn {Funktion} is (@var{expr})

@c Attempts to determine whether the predicate @var{expr} is provable from the 
@c facts in the @code{assume} database.
@c If the predicate is provably @code{true} or @code{false}, @code{is} returns 
@c @code{true} or @code{false}, respectively. Otherwise, the return value is 
@c governed by the global flag @code{prederror}. When @code{prederror} is 
@c @code{true}, @code{is} complains with an error message. Otherwise, @code{is} 
@c returns @code{unknown}.

Versucht festzustellen, ob die Aussage @var{expr} mit Hilfe der Aussagen und 
Fakten der aktiven Kontexte entschieden werden kann.

Kann die Aussage @var{expr} zu @code{true} oder @code{false} entschieden werden,
wird das entsprechende zur@"uck gegeben.  Andernfalls wird der R@"uckgabewert
durch den Schalter @code{prederror} bestimmt.  Hat @code{prederror} den Wert 
@code{true}, wird eine Fehlermeldung ausgegeben.  Andernfalls wird
@code{unknown} zur@"uckgegeben.

@c @code{ev(@var{expr}, pred)} (which can be written  @code{@var{expr}, pred} 
@c at the interactive prompt) is equivalent to @code{is(@var{expr})}.

@c See also @code{assume}, @code{facts}, and @code{maybe}.

Siehe auch @mrefcomma{assume} @mref{facts} und @mrefdot{maybe}

Beispiele:

@c @code{is} causes evaluation of predicates.

@code{is} wertet Aussagen aus.

@c ===beg===
@c %pi > %e;
@c is (%pi > %e);
@c ===end===
@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@c @code{is} attempts to derive predicates from the @code{assume} database.

@code{is} versucht Aussagen anhand der Aussagen und Fakten der aktiven
Kontexte zu entscheiden.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c is (a < b);
@c is (a > c);
@c is (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

@c If @code{is} can neither prove nor disprove a predicate from the 
@c @code{assume} database, the global flag @code{prederror} governs the behavior
@c of @code{is}.

Wenn @code{is} eine Aussage anhand der Aussagen und Fakten der aktiven Kontexte 
nicht entscheiden kann, wird der R@"uckgabewert vom Wert des Schalters 
@code{prederror} bestimmt.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c is (a > 0);
@c prederror: false$
@c is (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{killcontext}
@deffn {Funktion} killcontext (@var{context_1}, @dots{}, @var{context_n})

@c Kills the contexts @var{context_1}, ..., @var{context_n}.

Das Kommando @code{killcontext(@var{context})} l@"oscht den Kontext 
@var{context}.

@c If one of the contexts is the current context, the new current context will 
@c become the first available subcontext of the current context which has not 
@c been killed.  If the first available unkilled context is @code{global} then 
@c @code{initial} is used instead.  If the @code{initial} context is killed, a 
@c new, empty @code{initial} context is created.

Ist einer der Kontexte der aktuelle Kontext, wird der erste vorhandene 
Unterkontext zum aktuellen Kontext.  Ist der erste verf@"ugbare Kontext der 
Kontext @code{global}, dann wird der Kontext @code{initial} zum aktuellen 
Kontext.  Wird der Kontext @code{initial} gel@"oscht, dann wird eine neuer 
leerer Kontext @code{initial} erzeugt.

@c @code{killcontext} refuses to kill a context which is currently active, 
@c either because it is a subcontext of the current context, or by use of the 
@c function @code{activate}.

@code{killcontext} l@"oscht einen Kontext nicht, wenn dieser ein Unterkontext 
des aktuellen Kontextes ist oder wenn der Kontext mit der Funktion 
@code{activate} aktiviert wurde.

@c @code{killcontext} evaluates its arguments. @code{killcontext} returns 
@c @code{done}.

@code{killcontext} wertet die Argumente aus.  @code{killcontext} gibt 
@code{done} zur@"uck.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{maybe}
@deffn {Funktion} maybe (@var{expr})

@c Attempts to determine whether the predicate @var{expr} is provable from the 
@c facts in the @code{assume} database.

Versucht festzustellen, ob die Aussage @var{expr} anhand der Aussagen und
Fakten der aktive Kontexte entschieden werden kann.

@c If the predicate is provably @code{true} or @code{false}, @code{maybe} 
@c returns @code{true} or @code{false}, respectively. Otherwise, @code{maybe} 
@c returns @code{unknown}.

Kann die Aussage als @code{true} oder @code{false} entschieden werden, gibt 
@code{maybe} entsprechend @code{true} oder @code{false} zur@"uck.  Andernfalls
gibt @code{maybe} den Wert @code{unknown} zur@"uck.

@c @code{maybe} is functionally equivalent to @code{is} with @code{prederror: 
@c false}, but the result is computed without actually assigning a value to 
@c @code{prederror}.

@code{maybe} entspricht der Funktion @code{is} mit @code{prederror: false}.
Dabei wird @code{maybe} ausgef@"uhrt, ohne dass @code{prederror} einen Wert 
erh@"alt.

@c See also @code{assume}, @code{facts}, and @code{is}.

Siehe auch @mrefcomma{assume} @mref{facts} und @mrefdot{is}

Beispiele:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{newcontext}
@deffn {Funktion} newcontext (@var{name})

@c Creates a new, empty context, called @var{name}, which has @code{global} as 
@c its only subcontext.  The newly-created context becomes the currently active
@c context.

@code{newcontext(@var{name})} erzeugt einen neuen, leeren Kontext mit dem 
Namen @var{name}. Der neue Kontext hat den Kontext @code{global} als Subkontext
und wird zum aktuellen Kontext.

@c @code{newcontext} evaluates its argument. @code{newcontext} returns 
@c @var{name}.

@code{newcontext} wertet seine Argumente aus.  @code{newcontext} gibt 
@code{name} zur@"uck.
@end deffn

@c --- 28.12.2010 DK -----------------------------------------------------------
@anchor{prederror}
@defvr {Optionsvariable} prederror
Standardwert: @code{false}

@c When @code{prederror} is @code{true}, an error message is displayed whenever 
@c the predicate of an @code{if} statement or an @code{is} function fails to
@c evaluate to either @code{true} or @code{false}.

Hat @code{prederror} den Wert @code{true}, wird eine Fehlermeldung ausgegeben,
wenn eine Aussage mit einer @code{if}-Anweisung oder der Funktion @code{is} 
nicht zu @code{true} oder @code{false} ausgewertet werden kann.

@c If @code{false}, @code{unknown} is returned instead in this case.  The 
@c @code{prederror: false} mode is not supported in translated code; however, 
@c @code{maybe} is supported in translated code.

Hat @code{prederror} den Wert @code{false}, wird f@"ur diese F@"alle 
@code{unknown} zur@"uckgegeben.

@c See also @code{is} and @code{maybe}.

Siehe auch @mref{is} und @mrefdot{maybe}
@end defvr

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{sign}
@deffn {Funktion} sign (@var{expr})

@c Attempts to determine the sign of @var{expr} on the basis of the facts in the
@c current data base.  It returns one of the following answers: @code{pos} 
@c (positive), @code{neg} (negative), @code{zero}, @code{pz} (positive or zero),
@c @code{nz} (negative or zero), @code{pn} (positive or negative), or @code{pnz}
@c (positive, negative, or zero, i.e. nothing known).

Versucht das Vorzeichen des Ausdrucks @var{expr} auf Grundlage der Fakten der
aktuellen Datenbank zu finden.  @code{sign} gibt eine der folgende Antworten 
zur@"uck: @code{pos} (positiv), @code{neg} (negative), @code{zero} (null),
@code{pz} (positive oder null), @code{nz} (negative oder null), @code{pn}
(positiv oder negative) oder @code{pnz} (positiv, negative oder null, f@"ur den
Fall das Vorzeichen nicht bekannt ist).
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{supcontext}
@deffn  {Funktion} supcontext (@var{name}, @var{context})
@deffnx {FunKtion} supcontext (@var{name}) 

@c Creates a new context, called @var{name}, which has @var{context} as a 
@c subcontext. @var{context} must exist.

Erzeugt einen neuen Kontext, mit dem Namen @code{name}, der den Kontext 
@code{context} als einen Unterkontext enth@"alt.  Der Kontext @var{context} muss
existieren.

@c If @var{context} is not specified, the current context is assumed.

Wird @var{context} nicht angegeben, wird der aktuelle Kontext angenommen.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Aussagen, , Funktionen und Variablen f@"ur Fakten, Maximas Datenbank
@section Funktionen und Variablen f@"ur Aussagen
@c -----------------------------------------------------------------------------

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{charfun}
@deffn {Funktion} charfun (@var{p})

@c Return 0 when the predicate @var{p} evaluates to @code{false}; return 1 when 
@c the predicate evaluates to @code{true}.  When the predicate evaluates to 
@c something other than @code{true} or @code{false} (unknown), return a noun 
@c form.

Gibt den Wert 0 zur@"uck, wenn die Aussage @var{p} zu @code{false} ausgewertet
werden kann und den Wert 1, wenn die Auswertung @code{true} liefert.  Kann
die Aussage weder zu @code{false} oder @code{true} ausgewertet werden, wird eine
Substantiv-Form zur@"uck gegeben.

Beispiele:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example
@end deffn

@c --- 27.08.2010 DK -----------------------------------------------------------
@anchor{compare}
@deffn {Funktion} compare (@var{x}, @var{y})

@c Return a comparison operator @var{op} (@code{<}, @code{<=}, @code{>}, 
@c @code{>=}, @code{=}, or @code{#}) such that @code{is (@var{x} @var{op} 
@c @var{y})} evaluates to @code{true}; when either @var{x} or @var{y} depends 
@c on @code{%i} and @code{@var{x} # @var{y}}, return @code{notcomparable}; when 
@c there is no such operator or Maxima isn't able to determine the operator, 
@c return @code{unknown}.

Liefert den Vergleichsoperator @var{op} (@code{<}, @code{<=}, @code{>}, 
@code{>=}, @code{=} oder @code{#}), so dass der Ausdruck @code{is(@var{x}
@var{op} @var{y})} zu @code{true} ausgewertet werden kann.  Ist eines der
Argumente eine komplexe Zahl, dann wird @code{notcomparable} zur@"uckgegeben.
Kann Maxima keinen Vergleichsoperator bestimmen, wird @code{unknown}
zur@"uckgegeben.

Beispiele:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

@c The function @code{compare} doesn't try to determine whether the real domains
@c of its arguments are nonempty; thus
@c @c IT IS NOT QUITE TRUE, WHAT ABOUT x=0 ?
@c The real domain of @code{acos (x^2 + 1)} is empty.

Die Funktion @code{compare} versucht nicht festzustellen, ob der Wertebereich
einer Funktion reelle Zahlen enth@"alt.  Obwohl der Wertebereich von 
@code{acos(x^2+1)} bis auf Null keine reellen Zahlen enth@"alt, gibt 
@code{compare} das folgende Ergebnis zur@"uck:

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{equal}
@deffn {Funktion} equal (@var{a}, @var{b})

@c Represents equivalence, that is, equal value.

Repr@"asentiert die @"Aquivalenz, das hei@ss{}t den gleichen Wert.

@c By itself, @code{equal} does not evaluate or simplify. The function @code{is}
@c attempts to evaluate @code{equal} to a Boolean value. @code{is(equal(@var{a},
@c @var{b}))} returns @code{true} (or @code{false}) if and only if @var{a} and 
@c @var{b} are equal (or not equal) for all possible values of their variables, 
@c as determined by evaluating @code{ratsimp(@var{a} - @var{b})}; if 
@c @code{ratsimp} returns 0, the two expressions are considered equivalent. Two 
@c expressions may be equivalent even if they are not syntactically equal (i.e.,
@c identical).

@code{equal} wird nicht ausgewertet oder vereinfacht.  Die Funktion @code{is}
versucht einen Ausdruck mit @code{equal} zu einem boolschen Wert auszuwerten.
@code{is(equal(@var{a}, @var{b}))} gibt @code{true} oder @code{false} zur@"uck, 
wenn und nur wenn @var{a} und @var{b} gleich oder ungleich sind f@"ur alle Werte
ihrer Variablen, was mit @code{ratsimp(@var{a} - @var{b})} bestimmt wird.  Gibt
@code{ratsimp} das Ergebnis 0 zur@"uck, werden die beiden Ausdr@"ucke als 
@"aquivalent betracht.  Zwei Ausdr@"ucke k@"onnen @"aquivalent sein, obwohl sie 
nicht syntaktisch gleich (im allgemeinen identisch) sind.

@c When @code{is} fails to reduce @code{equal} to @code{true} or @code{false},
@c the result is governed by the global flag @code{prederror}. When 
@c @code{prederror} is @code{true}, @code{is} complains with an error message.
@c Otherwise, @code{is} returns @code{unknown}.

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder 
@code{false} auswerten, h@"angt das Ergebnis vom Wert des globalen Flags 
@code{prederror} ab.  Hat @code{prederror} den Wert @code{true}, gibt @code{is}
eine Fehlermeldung zur@"uck.  Ansonsten wird @code{unknown} zur@"uckgegeben.

@c In addition to @code{is}, some other operators evaluate @code{equal} and 
@c @code{notequal} to @code{true} or @code{false}, namely @code{if}, @code{and},
@c @code{or}, and @code{not}.

Es gibt weitere Operatoren, die einen Ausdruck mit @code{equal} zu @code{true}
oder @code{false} auswerten k@"onnen.  Dazu geh@"oren @code{if}, @code{and}, 
@code{or} und @code{not}.

  @c FOLLOWING STATEMENT IS MORE OR LESS TRUE BUT I DON'T THINK THE DETAILS ARE
  @c CORRECT
  @c Declarations (integer, complex, etc)
  @c for variables appearing in @var{a} and @var{b} are ignored by @code{equal}.
  @c All variables are effectively assumed to be real-valued.

@c The negation of @code{equal} is @code{notequal}.

Die Umkehrung von @code{equal} ist @code{notequal}.

Beispiele:

@c By itself, @code{equal} does not evaluate or simplify.

@code{equal} wird von allein weder ausgewertet noch vereinfacht:

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

@c The function @code{is} attempts to evaluate @code{equal} to a Boolean value.
@c @code{is(equal(@var{a}, @var{b}))} returns @code{true} when 
@c @code{ratsimp(@var{a} - @var{b})} returns 0. Two expressions may be 
@c equivalent even if they are not syntactically equal (i.e., identical).

Die Funktion @code{is} versucht, @code{equal} zu einem boolschen Wert 
auszuwerten.  @code{is(equal(@var{a}, @var{b}))} gibt den Wert @code{true} 
zur@"uck, when @code{ratsimp(@var{a} - @var{b})} den Wert 0 hat.  Zwei 
Ausdr@"ucke k@"onnen @"aquivalent sein, obwohl sie nicht syntaktisch gleich 
sind.

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example

@c When @code{is} fails to reduce @code{equal} to @code{true} or @code{false},
@c the result is governed by the global flag @code{prederror}.

Kann @code{is} einen Ausdruck mit @code{equal} nicht zu @code{true} oder
@code{false} vereinfachen, h@"angt das Ergebnis vom Wert des globalen Flags
@code{prederror} ab.

@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
@example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

@c Some operators evaluate @code{equal} and @code{notequal} to @code{true} or 
@c @code{false}.

Einige weitere Operatoren werten @code{equal} und @code{notequal} zu einem
boolschen Wert aus.

@c ===beg===
@c if equal (y, y - 1) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

@c Because @code{not @var{expr}} causes evaluation of @var{expr}, 
@c @code{not equal(@var{a}, @var{b})} is equivalent to 
@c @code{is(notequal(@var{a}, @var{b}))}.

Da @code{not @var{expr}} den Ausdruck @var{expr} auswertet, ist 
@code{not equal(@var{a}, @var{b})} @"aquivalent zu 
@code{is(notequal(@var{a}, @var{b}))}

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{notequal}
@deffn {Funktion} notequal (@var{a}, @var{b})

@c Represents the negation of @code{equal(@var{a}, @var{b})}.

Repr@"asentiert die Verneinung von @code{equal(@var{a}, @var{b})}.

Beispiele:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c maybe (notequal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{unknown}
@deffn {Funktion} unknown (@var{expr})

@c Returns @code{true} if and only if @var{expr} contains an operator or 
@c function not recognized by the Maxima simplifier.

@c TODO: FORMULIERUNG?

Gibt den Wert @code{true} zur@"uck, wenn der Ausdruck @var{expr} einen Operator
oder eine Funktion enth@"alt, die nicht von Maximas Vereinfacher erkannt wird.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{zeroequiv}
@deffn {Funktion} zeroequiv (@var{expr}, @var{v})

@c Tests whether the expression @var{expr} in the variable @var{v} is equivalent
@c to zero, returning @code{true}, @code{false}, or @code{dontknow}.

Testet, ob ein Ausdruck @var{expr} mit der Variablen @var{v} @"aquivalent zu 
Null ist.  Die Funktion gibt @code{true}, @code{false} oder @code{dontknow} 
zur@"uck.

@c @code{zeroequiv} has these restrictions:

@code{zeroequiv} hat Einschr@"ankungen:

@enumerate

@c Do not use functions that Maxima does not know how to differentiate and 
@c evaluate.

@item
Funktionen im Ausdruck @var{expr} m@"ussen von Maxima differenzierbar und 
auswertbar sein.

@c If the expression has poles on the real line, there may be errors in the 
@c result (but this is unlikely to occur).

@item
Hat der Ausdruck Pole auf der reellen Achse, k@"onnen Fehler auftreten.

@c If the expression contains functions which are not solutions to first order
@c differential equations (e.g.  Bessel functions) there may be incorrect 
@c results.

@item
Enth@"alt der Ausdruck Funktionen, die nicht L@"osung einer 
Differentialgleichung erster Ordnung sind (zum Beispiel Bessel Funktionen), 
k@"onnen die Ergebnisse fehlerhaft sein.

@c The algorithm uses evaluation at randomly chosen points for carefully 
@c selected subexpressions.  This is always a somewhat hazardous business, 
@c although the algorithm tries to minimize the potential for error.

@item
Der Algorithmus wertet die Funktion an zuf@"allig Punkten f@"ur ausgew@"ahlte
Teilausdr@"ucke aus.  Dies ist ein riskantes Verfahren und kann zu Fehlern 
f@"uhren.
@end enumerate

@c For example @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} returns 
@c @code{true} and @code{zeroequiv (%e^x + x, x)} returns @code{false}. 
@c On the other hand @code{zeroequiv (log(a*b) - log(a) - log(b), a)} returns 
@c @code{dontknow} because of the presence of an extra parameter @code{b}.

@code{zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)} hat zum Beispiel das Ergebnis 
@code{true} und  @code{zeroequiv (%e^x + x, x)} hat das Ergebnis @code{false}.
Andererseits hat @code{zeroequiv (log(a*b) - log(a) - log(b), a)} das Ergebnis
@code{dontknow}, wegen dem zus@"atzlichem Parameter @code{b}.
@end deffn

@c --- End of Database.de.texi -------------------------------------------------

