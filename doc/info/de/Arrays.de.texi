@c -----------------------------------------------------------------------------
@c File        : DataTypes.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Arrays.texi revision 1.17
@c Translation : Dr. Dieter Kaiser
@c Date        : 14.03.2011
@c Revision    : 14.03.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@page
@c -----------------------------------------------------------------------------
@node Arrays, Einf@"uhrung in Arrays, Listen, Datentypen und -strukturen
@section Arrays
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Arrays::
* Funktionen und Variablen f@"ur Arrays::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Arrays, Funktionen und Variablen f@"ur Arrays, Arrays, Arrays
@subsection Einf@"uhrung in Arrays
@c -----------------------------------------------------------------------------



@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Arrays, , Einf@"uhrung in Arrays, Arrays
@subsection Funktionen und Variablen f@"ur Arrays
@c -----------------------------------------------------------------------------

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{array}
@deffn  {Funktion} array (@var{name}, @var{dim_1}, @dots{}, @var{dim_n})
@deffnx {Funktion} array (@var{name}, @var{type}, @var{dim_1}, @dots{}, @var{dim_n})
@deffnx {Funktion} array ([@var{name_1}, @dots{}, @var{name_m}], @var{dim_1}, @dots{}, @var{dim_n})

Erzeugt ein @math{n}-dimensionales Array.  @math{n} kann kleiner oder gleich 5 
Dimensionen sein.  Die Indizes der @math{i}-ten Dimension sind ganze Zahlen
in einem Bereich von 0 bis @var{dim_i}.

@code{array(@var{name}, @var{dim_1}, ..., @var{dim_n})} erzeugt ein allgemeines 
Array.

@code{array(@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})} erzeugt 
ein Array mit Elementen, die vom Typ @var{type} sind.  @var{type} kann 
@code{fixnum} f@"ur ganze Zahlen oder @code{flonum} f@"ur Gleitkommazahlen sein.
 
@code{array([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})}
erzeugt @math{m} Arrays, die alle die gleiche Dimension haben.

Wird einer indizierten Variablen ein Wert zugewiesen, bevor das entsprechende
Array definiert wird, so wird ein undeklariertes Array erzeugt.  Undeklarierte
Arrays, auch Hashed-Arrays genannt, sind allgemeiner als deklarierte Arrays.
Diese Arrays haben keine feste Gr@"o@ss{}e und wachsen dynamisch mit der 
Zuweisung von Werten.  Die Indizes eines undeklarierten Arrays m@"ussen keine 
ganze Zahlen sein.  Deklarierte Arrays sind im Allgemeinen effizienter, 
so dass Arrays falls m@"oglich deklariert werden sollten.  Die Funktion 
@code{array} kann genutzt werden, um ein undeklariertes Array in ein 
deklariertes Array umzuwandeln.

Beispiele:

Es werden zwei verschiedene Arrays definiert.  Im ersten Fall erh@"alt das Array
keinen Typ.  Elemente, denen noch kein Wert zugewiesen wurde, werden mit dem
Symbol @code{#####} initialisiert.  Im zweiten Fall ist das Array vom Typ 
@code{fixnum}.  Jetzt wird das Array mit dem Wert @code{0} initialisiert.

@example
(%i1) array(a, 2, 2);
(%o1)                           a
(%i2) a[0,0]: 0; a[1,1]:11; a[2,2]:22;
(%o2)                           0
(%o3)                          11
(%o4)                          22
(%i5) listarray(a);
(%o5) [0, #####, #####, #####, 11, #####, #####, #####, 22]
(%i6) array(b, fixnum, 2, 2);
(%o6)                           b
(%i7) b[0,0]: 0; b[1,1]:11; b[2,2]:22;
(%o7)                           0
(%o8)                          11
(%o9)                          22
(%i10) listarray(b);
(%o10)            [0, 0, 0, 0, 11, 0, 0, 0, 22]
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{arrayapply}
@deffn {Funktion} arrayapply (@var{A}, [@var{i_1}, @dots{}, @var{i_n}])

Wertet @code{@var{A}[@var{i_1}, ... , @var{i_n}]} aus, wobei @var{A} ein Array
und @var{i_1}, @dots{}, @var{i_n} die Indizes eines Array-Elementes sind.

Beispiele:

@example
(%i1) arrayapply('a,[x, y]);
(%o1)                         a
                               x, y
(%i2) arrayapply('a,[1, 2, 3]);
(%o2)                       a
                             1, 2, 3
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{arrayinfo}
@deffn {Funktion} arrayinfo (@var{A})

Gibt Information @"uber das Array @var{A} zur@"uck.  Das Argument @var{A} kann
ein deklariertes oder ein undeklariertes Array sowie eine Array-Funktion oder
eine indizierte Funktion sein.

F@"ur ein deklarierte Array gibt @code{arryinfo} eine Liste zur@"uck, die 
@code{declared}, die Zahl der Dimensionen und die Gr@"o@ss{}e der Dimensionen 
enh@"alt.  Die Elemente des Arrays werden von der Funktion @mref{listarray}@ 
zur@"uckgegeben.

F@"ur ein undeklariertes Array (Hashed-Array) gibt @code{arrayinfo} eine Liste
zur@"uck, die @code{hashed}, die Zahl der Indizes und die Indizes enth@"alt,
deren Elemente einen Wert haben.  Die Werte der Elemente werden mit der Funktion 
@mref{listarray} zur@"uckgegeben.

F@"ur Array-Funktionen gibt @code{arrayinfo} eine Liste zur@"uck, die 
@code{hashed} die Zahl der Indizes und die Indizes enth@"alt, f@"ur die 
Funktionen im Array enthalten sind.  Die Funktionen werden mit der Funktion 
@mref{listarray} angezeigt.

F@"ur indizierte Funktionen gibt @code{arrayinfo} eine Liste zur@"uck, die 
@code{hashed}, die Zahl der Indizes und die Indizies enth@"alt, f@"ur die 
Lambda-Ausdr@"ucke vorhanden sind.  Die Lambda-Ausdr@"ucke werden von der 
Funktion @mref{listarray} angezeigt.

Beispiele:

@code{arrayinfo} und @code{listarray} angewendet auf ein deklariertes Array.

@example
@group
(%i1) array (aa, 2, 3);
(%o1)                          aa
@end group
@group
(%i2) aa [2, 3] : %pi;
(%o2)                          %pi
@end group
@group
(%i3) aa [1, 2] : %e;
(%o3)                          %e
@end group
@group
(%i4) arrayinfo (aa);
(%o4)                 [declared, 2, [2, 3]]
@end group
@group
(%i5) listarray (aa);
(%o5) [#####, #####, #####, #####, #####, #####, %e, #####, 
                                        #####, #####, #####, %pi]
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf ein undeklariertes Array.

@example
@group
(%i1) bb [FOO] : (a + b)^2;
                                   2
(%o1)                       (b + a)
@end group
@group
(%i2) bb [BAR] : (c - d)^3;
                                   3
(%o2)                       (c - d)
@end group
@group
(%i3) arrayinfo (bb);
(%o3)               [hashed, 1, [BAR], [FOO]]
@end group
@group
(%i4) listarray (bb);
                              3         2
(%o4)                 [(c - d) , (b + a) ]
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf eine Array-Funktion.

@example
@group
(%i1) cc [x, y] := y / x;
                                     y
(%o1)                      cc     := -
                             x, y    x
@end group
@group
(%i2) cc [u, v];
                                v
(%o2)                           -
                                u
@end group
@group
(%i3) cc [4, z];
                                z
(%o3)                           -
                                4
@end group
@group
(%i4) arrayinfo (cc);
(%o4)              [hashed, 2, [4, z], [u, v]]
@end group
@group
(%i5) listarray (cc);
                              z  v
(%o5)                        [-, -]
                              4  u
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf eine indizierte Funktion.

@example
@group
(%i1) dd [x] (y) := y ^ x;
                                     x
(%o1)                     dd (y) := y
                            x
@end group
@group
(%i2) dd [a + b];
                                    b + a
(%o2)                  lambda([y], y     )
@end group
@group
(%i3) dd [v - u];
                                    v - u
(%o3)                  lambda([y], y     )
@end group
@group
(%i4) arrayinfo (dd);
(%o4)             [hashed, 1, [b + a], [v - u]]
@end group
@group
(%i5) listarray (dd);
                         b + a                v - u
(%o5)      [lambda([y], y     ), lambda([y], y     )]
@end group
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{arraymake}
@deffn {Funktion} arraymake (@var{A}, [@var{i_1}, @dots{}, @var{i_n}])

Gibt den Ausdruck @code{@var{A}[@var{i_1}, ..., @var{i_n}]} zur@"uck.  Das 
Ergebnis ist eine nicht ausgewertete Referenz auf ein Element des Arrays.

@code{arraymake} entspricht der Funktion @mrefdot{funmake}

Beispiele:

@example
@group
(%i1) arraymake (A, [1]);
(%o1)                          A
                                1
@end group
@group
(%i2) arraymake (A, [k]);
(%o2)                          A
                                k
@end group
@group
(%i3) arraymake (A, [i, j, 3]);
(%o3)                       A
                             i, j, 3
@end group
@group
(%i4) array (A, fixnum, 10);
(%o4)                           A
@end group
@group
(%i5) fillarray (A, makelist (i^2, i, 1, 11));
(%o5)                           A
@end group
@group
(%i6) arraymake (A, [5]);
(%o6)                          A
                                5
@end group
@group
(%i7) ''%;
(%o7)                          36
@end group
@group
(%i8) L : [a, b, c, d, e];
(%o8)                    [a, b, c, d, e]
@end group
@group
(%i9) arraymake ('L, [n]);
(%o9)                          L
                                n
@end group
@group
(%i10) ''%, n = 3;
(%o10)                          c
@end group
@group
(%i11) A2 : make_array (fixnum, 10);
(%o11)          @{Array:  #(0 0 0 0 0 0 0 0 0 0)@}
@end group
@group
(%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o12)          @{Array:  #(1 2 3 4 5 6 7 8 9 10)@}
@end group
@group
(%i13) arraymake ('A2, [8]);
(%o13)                         A2
                                 8
@end group
@group
(%i14) ''%;
(%o14)                          9
@end group
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{arrays}
@defvr {Systemvariable} arrays
Standardwert: @code{[]}

@code{arrays} ist eine Informationsliste @mref{infolists} der Arrays, die 
definiert sind.  Die Liste enth@"alt deklarierte Arrays, undedeklarierte Arrays 
und Array-Funktionen, die mit @mref{:=} oder @mref{define} definiert sind.
Arrays die mit @mref{make_array} definiert sind, sind nicht in der Liste 
enthalten.

Siehe auch @mrefcomma{array} @mrefcomma{arrayapply} @mrefcomma{arrayinfo}@ 
@mrefcomma{arraymake} @mrefcomma{fillarray} @mref{listarray} und 
@mrefdot{rearray}

Beispiele:

@example
@group
(%i1) array (aa, 5, 7);
(%o1)                          aa
@end group
@group
(%i2) bb [FOO] : (a + b)^2;
                                   2
(%o2)                       (b + a)
@end group
@group
(%i3) cc [x] := x/100;
                                   x
(%o3)                      cc  := ---
                             x    100
@end group
@group
(%i4) dd : make_array ('any, 7);
(%o4)       @{Array:  #(NIL NIL NIL NIL NIL NIL NIL)@}
@end group
@group
(%i5) arrays;
(%o5)                     [aa, bb, cc]
@end group
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{fillarray}
@deffn {Funktion} fillarray (@var{A}, @var{B})

F@"ullt das Array @var{A} mit den Werten aus @var{B}.  Das Argument @var{B} ist 
eine Liste oder ein Array.

Ist das Array @var{A} mit einem Typ deklariert, dann kann es nur mit Elementen
gef@"ullt werden, die den gleichen Typ haben.

Sind die Dimensionen von @var{A} und @var{B} verschieden, werden in @var{A}
zun@"achst die Zeilen aufgef@"ullt.  Hat @var{B} nicht gen@"ugend Elemente um 
das Array @var{A} aufzuf@"ullen, werden die restlichen Elemente mit dem letzten 
Wert von @var{B} aufgef@"ullt.  @"Uberz@"ahlige Elemente in @var{B} werden 
ignoriert.

@code{fillarray} gibt das erste Argument zur@"uck.

Beispiele:

Erzeuge ein Array mit 9 Elementen und f@"ulle es mit den Elementen einer Liste.

@example
@group
(%i1) array (a1, fixnum, 8);
(%o1)                          a1
@end group
@group
(%i2) listarray (a1);
(%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
@end group
@group
(%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
(%o3)                          a1
@end group
@group
(%i4) listarray (a1);
(%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]
@end group
@end example

Sind zu wenige Elemente vorhanden, um das Array aufzuf@"ullen, wird das Array
mit dem letzten Element aufgef@"ullt.  @"Uberz@"ahlige Elemente werden 
ignoriert.

@example
@group
(%i1) a2 : make_array (fixnum, 8);
(%o1)             @{Array:  #(0 0 0 0 0 0 0 0)@}
@end group
@group
(%i2) fillarray (a2, [1, 2, 3, 4, 5]);
(%o2)             @{Array:  #(1 2 3 4 5 5 5 5)@}
@end group
@group
(%i3) fillarray (a2, [4]);
(%o3)             @{Array:  #(4 4 4 4 4 4 4 4)@}
@end group
@group
(%i4) fillarray (a2, makelist (i, i, 1, 100));
(%o4)             @{Array:  #(1 2 3 4 5 6 7 8)@}
@end group
@end example

Arrays werden zeilenweise aufgef@"ulllt.

@example
@group
(%i1) a3 : make_array (fixnum, 2, 5);
(%o1)        @{Array:  #2A((0 0 0 0 0) (0 0 0 0 0))@}
@end group
@group
(%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o2)        @{Array:  #2A((1 2 3 4 5) (6 7 8 9 10))@}
@end group
@group
(%i3) a4 : make_array (fixnum, 5, 2);
(%o3)     @{Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))@}
@end group
@group
(%i4) fillarray (a4, a3);
(%o4)     @{Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))@}
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{listarray}
@deffn {Funktion} listarray (@var{A})

Gibt eine Liste mit den Elementen des Arrays @var{A} zur@"uck.  Das Argument 
@var{A} kann ein deklariertes, undeklariertes, eine Array-Funktion oder eine
indizierte Funktion sein.

Die Elemente werden zeilenweise ausgegeben.  F@"ur Hashed-Arrays mit Indizes, 
die keine ganze Zahlen sind, wird die Sortierung von der Funktion 
@mref{orderless} bestimmt.

F@"ur undeklarierte Arrays, Array-Funktionen und indizierte Funktionen werden
die Elemente in der Reihenfolge wie von der Funktion 
@mref{arrayinfo} zur@"uckgegeben.

Elemente von deklarierten Arrays, denen noch kein Wert zugewiesen wurde und die
keinen Typ haben, werden als @code{#####} zur@"uckgegeben.  Elemente von
deklarierten Arrays mit einem Typ, geben den Wert 0 f@"ur den Typ @code{fixnum}
und 0.0 f@"ur den Typ @code{flonum} zur@"uck.

Beispiele:

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
deklariertes Array.

@example
@group
(%i1) array (aa, 2, 3);
(%o1)                          aa
@end group
@group
(%i2) aa [2, 3] : %pi;
(%o2)                          %pi
@end group
@group
(%i3) aa [1, 2] : %e;
(%o3)                          %e
@end group
@group
(%i4) listarray (aa);
(%o4) [#####, #####, #####, #####, #####, #####, %e, #####, 
                                        #####, #####, #####, %pi]
@end group
@group
(%i5) arrayinfo (aa);
(%o5)                 [declared, 2, [2, 3]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
undeklariertes Array.

@example
@group
(%i1) bb [FOO] : (a + b)^2;
                                   2
(%o1)                       (b + a)
@end group
@group
(%i2) bb [BAR] : (c - d)^3;
                                   3
(%o2)                       (c - d)
@end group
@group
(%i3) listarray (bb);
                              3         2
(%o3)                 [(c - d) , (b + a) ]
@end group
@group
(%i4) arrayinfo (bb);
(%o4)               [hashed, 1, [BAR], [FOO]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur eine
Array-Funktion.

@example
@group
(%i1) cc [x, y] := y / x;
                                     y
(%o1)                      cc     := -
                             x, y    x
@end group
@group
(%i2) cc [u, v];
                                v
(%o2)                           -
                                u
@end group
@group
(%i3) cc [4, z];
                                z
(%o3)                           -
                                4
@end group
@group
(%i4) listarray (cc);
                              z  v
(%o4)                        [-, -]
                              4  u
@end group
@group
(%i5) arrayinfo (cc);
(%o5)              [hashed, 2, [4, z], [u, v]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
indizierte Funktion.

@example
@group
(%i1) dd [x] (y) := y ^ x;
                                     x
(%o1)                     dd (y) := y
                            x
@end group
@group
(%i2) dd [a + b];
                                    b + a
(%o2)                  lambda([y], y     )
@end group
@group
(%i3) dd [v - u];
                                    v - u
(%o3)                  lambda([y], y     )
@end group
@group
(%i4) listarray (dd);
                         b + a                v - u
(%o4)      [lambda([y], y     ), lambda([y], y     )]
@end group
@group
(%i5) arrayinfo (dd);
(%o5)             [hashed, 1, [b + a], [v - u]]
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{make_array}
@deffn {Funktion} make_array (@var{type}, @var{dim_1}, @dots{}, @var{dim_n})

Erzeugt ein Lisp-Array.  Das Argument @var{type} kann die Werte @code{any},
@code{flonum}, @code{fixnum}, @code{hashed} oder @code{functional} haben.
Das Array hat @math{i} Dimensionen und der Index @math{i} l@"auft von 0 bis
@math{@var{dim_i}-1}.

@c TODO: ES FEHLT EINE UEBERSETZUNG, DIE WENIGER TECHNISCH SEIN SOLLTE.

@c 'FUNCTIONAL ARGUMENT IN MAKE_ARRAY APPEARS TO BE BROKEN
@c EVEN AFTER READING THE CODE (SRC/AR.LISP) I CAN'T TELL HOW THIS IS SUPPOSED 
@c TO WORK COMMENTING OUT THIS STUFF TO PREVENT CONFUSION AND HEARTBREAK
@c RESTORE IT WHEN MAKE_ARRAY ('FUNCTIONAL, ...) IS FIXED
@c @code{y: make_array ('functional, 'f, 'hashed, 1)} - the second argument to
@c @code{make_array} in this case is the function to call to calculate array
@c elements, and the rest of the arguments are passed recursively to
@c @code{make_array} to generate the "memory" for the array function object.

Beispiele:

@example
@group
(%i1) A1 : make_array (fixnum, 10);
(%o1)           @{Array:  #(0 0 0 0 0 0 0 0 0 0)@}
@end group
@group
(%i2) A1 [8] : 1729;
(%o2)                         1729
@end group
@group
(%i3) A1;
(%o3)          @{Array:  #(0 0 0 0 0 0 0 0 1729 0)@}
@end group
@group
(%i4) A2 : make_array (flonum, 10);
(%o4) @{Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)@}
@end group
@group
(%i5) A2 [2] : 2.718281828;
(%o5)                      2.718281828
@end group
@group
(%i6) A2;
(%o6) 
     @{Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)@}
@end group
@group
(%i7) A3 : make_array (any, 10);
(%o7) @{Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)@}
@end group
@group
(%i8) A3 [4] : x - y - z;
(%o8)                      - z - y + x
@end group
@group
(%i9) A3;
(%o9) @{Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
 -1 $Y) ((MTIMES SIMP) -1 $Z))
  NIL NIL NIL NIL NIL)@}
@end group
@group
(%i10) A4 : make_array (fixnum, 2, 3, 5);
(%o10) @{Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
0 0 0) (0 0 0 0 0) (0 0 0 0 0)))@}
@end group
@group
(%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
(%o11) @{Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
    ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))@}
@end group
@group
(%i12) A4 [0, 2, 1];
(%o12)                         12
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{rearray}
@deffn {Funktion} rearray (@var{A}, @var{dim_1}, @dots{}, @var{dim_n})

@"Andert die Dimension eines Arrays.  Das neue Array wird zeilenweise mit den 
Werten des alten Arrays aufgef@"ullt.  Hat das alte Array nicht gen@"ugend 
Elemente werden die restlichen Elemente entsprechend dem Typ des Arrays mit 
@code{false}, @code{0.0} oder @code{0} aufgef@"ullt.  Der Typ des Arrays kann 
nicht ge@"andert werden.
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{remarray}
@deffn  {Funktion} remarray (@var{A_1}, @dots{}, @var{A_n})
@deffnx {Funktion} remarray (all)

Entfernt Arrays und Array-Funktionen.  Der vom Array belegte Speicher wird
freigegeben.  Die Argumente k@"onnen deklarierte und undeklarierte Arrays sowie 
Array-Funktionen und indizierte Funktionen sein.

@code{remarray(all)} entfernt alle Arrays, die in der Informationsliste
@mref{arrays} enthalten sind.

@code{remarray} gibt eine Liste der Arrays zur@"uck, die entfernt wurden.
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{subvar}
@deffn {Funktion} subvar (@var{x}, @var{i})

Wertet den indizierten Ausdruck @code{@var{x}[@var{i}]} aus.  @code{subvar}
wertet die Argumente aus.

@code{arraymake(@var{x}, [@var{i}]} generiert den Ausdruck 
@code{@var{x}[@var{i}]}, ohne diesen auszuwerten.  Siehe @mrefdot{arraymake}

Beispiele:

@example
(%i1) x : foo $
(%i2) i : 3 $
@group
(%i3) subvar (x, i);
(%o3)                         foo
                                 3
@end group
(%i4) foo : [aa, bb, cc, dd, ee]$
@group
(%i5) subvar (x, i);
(%o5)                          cc
@end group
@group
(%i6) arraymake (x, [i]);
(%o6)                         foo
                                 3
@end group
@group
(%i7) ''%;
(%o7)                          cc
@end group
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{subvarp}
@deffn {Funktion} subvarp (@var{expr})

Gibt @code{true} zur@"uck, wenn @var{expr} eine indizierte Variable wie zum
Beispiel @code{a[i]} ist.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{use_fast_arrays}
@defvr {Optionsvariable} use_fast_arrays

Hat die Optionsvariable @code{use_fast_arrays} den Wert @code{true}, werden nur
die folgenden zwei Typen von Arrays erkannt:

@enumerate
@item
Ein Array, das mehrere Dimensionen haben kann und ganzzahligen Indizes.  Den
Elementen kann jedes Lisp oder Maxima-Objekt zugewiesen werden.  Zum Beispiel
weist das Kommando @code{a:make_array(any,3,4)} der Variablen @var{a} ein
Array zu, das @code{12} Elemente hat.

@item
Ein undeklariertes Array, welches standardm@"a@ss{}ig erzeugt wird, wenn zum 
Beispiel einer indizierten Variablen @code{b[x+1]:y^2} ein Wert zugewiesen wird 
und @code{b} nicht bereits ein deklariertes Array oder eine Liste ist.  Ist 
@var{b} bereits deklariert, wird eine Fehlermeldung ausgeben, da der Index 
@var{x+1} keine ganze Zahl ist.  Der Index eines undeklarierten Arrays kann ein 
beliebiger Ausdruck sein.
@end enumerate

@c TODO: VEREINFACHE DIE TECHNISCHE BESCHREIBUNG.

@c An advantage of storing the arrays as values of the symbol is that the
@c usual conventions about local variables of a function apply to arrays as
@c well.  The Hash_table type also uses less consing and is more efficient
@c than the old type of Maxima hashar.  To obtain consistent behaviour in
@c translated and compiled code set @code{translate_fast_arrays} to be 
@c @code{true}.
@end defvr

@c --- End of file Arrays.de.texi ----------------------------------------------

