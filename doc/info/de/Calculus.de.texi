@c -----------------------------------------------------------------------------
@c File     : Calculus.de.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 06.11.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Funktionen und Variablen f@"ur Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Grenzwerte, Funktionen und Variablen der Differentiation, Analysis, Analysis
@section Funktionen und Variablen f@"ur Grenzwerte

@c -----------------------------------------------------------------------------
@defvr {Option variable} lhospitallim
Default: 4

@code{lhospitallim} is the maximum number of times L'Hospital's
rule is used in @code{limit}.  This prevents infinite looping in cases like
@code{limit (cot(x)/csc(x), x, 0)}.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn  {Function} limit (@var{expr}, @var{x}, @var{val}, @var{dir})
@deffnx {Function} limit (@var{expr}, @var{x}, @var{val})
@deffnx {Function} limit (@var{expr})

Computes the limit of @var{expr} as the real variable
@var{x} approaches the value @var{val} from the direction @var{dir}.  @var{dir} may have the
value @code{plus} for a limit from above, @code{minus} for a limit from below, or
may be omitted (implying a two-sided limit is to be computed).

@code{limit} uses the
following special symbols: @code{inf} (positive infinity) and @code{minf} (negative
infinity).  On output it may also use @code{und} (undefined), @code{ind} (indefinite
but bounded) and @code{infinity} (complex infinity).

@code{infinity} (complex infinity) is returned when the limit of
the absolute value of the expression is positive infinity, but
the limit of the expression itself is not positive infinity or
negative infinity.  This includes cases where the limit of the
complex argument is a constant, as in @code{limit(log(x), x, minf)}, 
cases where the complex argument oscillates, as in
@code{limit((-2)^x, x, inf)}, and cases where the complex
argument is different for either side of a two-sided limit, as in
@code{limit(1/x, x, 0)} and @code{limit(log(x), x, 0)}.

@code{lhospitallim} is the maximum number of times L'Hospital's rule
is used in @code{limit}.  This prevents infinite looping in cases like
@code{limit (cot(x)/csc(x), x, 0)}.

@code{tlimswitch} when true will allow the @code{limit} command to use
Taylor series expansion when necessary.

@code{limsubst} prevents @code{limit} from attempting substitutions on
unknown forms.  This is to avoid bugs like @code{limit (f(n)/f(n+1), n, inf)}
giving 1.  Setting @code{limsubst} to @code{true} will allow such
substitutions.

@code{limit} with one argument is often called upon to simplify constant expressions,
for example, @code{limit (inf-1)}.

@c MERGE EXAMPLES INTO THIS FILE
@code{example (limit)} displays some examples.

For the method see Wang, P., "Evaluation of Definite Integrals by Symbolic
Manipulation", Ph.D. thesis, MAC TR-92, October 1971.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} limsubst

default value: @code{false} - prevents @code{limit} from attempting substitutions on
unknown forms.  This is to avoid bugs like @code{limit (f(n)/f(n+1), n, inf)}
giving 1.  Setting @code{limsubst} to @code{true} will allow such
substitutions.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn  {Function} tlimit (@var{expr}, @var{x}, @var{val}, @var{dir})
@deffnx {Function} tlimit (@var{expr}, @var{x}, @var{val})
@deffnx {Function} tlimit (@var{expr})

Take the limit of the Taylor series expansion of @code{expr} in @code{x}
at @code{val} from direction @code{dir}.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} tlimswitch
Default value: @code{true}

When @code{tlimswitch} is @code{true}, the @code{limit} command will
use a Taylor series expansion if the limit of the input expression cannot be computed directly.
This allows evaluation of limits such as @code{limit(x/(x-1)-1/log(x),x,1,plus)}.
When @code{tlimswitch} is @code{false} and the limit of input expression 
cannot be computed directly, @code{limit} will return an unevaluated limit expression.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Differentiation, Integration, Funktionen und Variablen f@"ur Grenzwerte, Analysis
@section Funktionen und Variablen der Differentiation

@c -----------------------------------------------------------------------------
@deffn  {Funktion} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Funktion} at (@var{expr}, @var{eqn})

@c Evaluates the expression @var{expr} with the variables assuming the values as
@c specified for them in the list of equations @code{[@var{eqn_1}, ..., 
@c @var{eqn_n}]} or the single equation @var{eqn}.

Wertet den Ausdruck @var{expr} aus, wobei dessen Variablen die Werte annehmen, 
die in der Liste der Gleichungen @code{[@var{eqn_1}, ..., @var{eqn_n}]} 
oder in der einzelnen Gleichung @var{eqn} angegeben sind.

@c If a subexpression depends on any of the variables for which a value is 
@c specified but there is no atvalue specified and it can't be otherwise 
@c evaluated, then a noun form of the @code{at} is returned which displays in a 
@c two-dimensional form.

Wenn ein Teilausdruck von einer Variablen abhängt, für die ein Wert angegeben 
ist, aber kein @code{atvalue}, und er auch sonst nicht ausgewertet werden kann, 
dann wird von @code{at} eine Substantivform zurückgegeben, dargestellt in einer 
zweidimensionalen Form.

@c @code{at} carries out multiple substitutions in series, not parallel.

@code{at} führt mehrfache Ersetzungen nacheinander und nicht nicht parallel 
durch.

@c See also @code{atvalue}. For other functions which carry out substitutions,
@c see also @code{subst} and @code{ev}.

Siehe auch @code{atvalue}. Für andere Funktionen, die Ersetzungen durchführen,
siehe weiterhin @code{subst} und @code{ev}.

Beispiele:

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@c @opencatbox
@c @category{Auswertung} @category{Differentialgleichungen}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} antid (@var{expr}, @var{x}, @var{u(x)}) 

Returns a two-element list,
such that an antiderivative of @var{expr} with respect to @var{x}
can be constructed from the list.
The expression @var{expr} may contain an unknown function @var{u} and its derivatives.

Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
is an antiderivative of @var{expr} with respect to @var{x}.

When @code{antid} succeeds entirely,
the second element of the return value is zero.
Otherwise, the second element is nonzero,
and the first element is nonzero or zero.
If @code{antid} cannot make any progress,
the first element is zero and the second nonzero.

@code{load ("antid")} loads this function.
The @code{antid} package also defines the functions @code{nonzeroandfreeof} and @code{linear}.

@code{antid} is related to @code{antidiff} as follows.
Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then the return value of @code{antidiff} is equal to @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
where @var{x} is the variable of integration.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THESE INPUTS
@c load ("antid")$
@c expr: exp (z(x)) * diff (z(x), x) * y(x);
@c a1: antid (expr, x, z(x));
@c a2: antidiff (expr, x, z(x));
@c a2 - (first (a1) + 'integrate (second (a1), x));
@c antid (expr, x, y(x));
@c antidiff (expr, x, y(x));
@c THERE IS A DEMO FILE share/integration/antid.dem, EXECUTED BY demo('antid)
@c BUT I THINK THE FOLLOWING ILLUSTRATES THE BASIC FUNCTIONALITY MORE CLEARLY
@c MAYBE MERGE IN THE DEMO PROBLEMS LATER

@example
(%i1) load ("antid")$
(%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                            z(x)  d
(%o2)                y(x) %e     (-- (z(x)))
                                  dx
(%i3) a1: antid (expr, x, z(x));
                       z(x)      z(x)  d
(%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                       dx
(%i4) a2: antidiff (expr, x, z(x));
                            /
                     z(x)   [   z(x)  d
(%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                            ]         dx
                            /
(%i5) a2 - (first (a1) + 'integrate (second (a1), x));
(%o5)                           0
(%i6) antid (expr, x, y(x));
                             z(x)  d
(%o6)             [0, y(x) %e     (-- (z(x)))]
                                   dx
(%i7) antidiff (expr, x, y(x));
                  /
                  [        z(x)  d
(%o7)             I y(x) %e     (-- (z(x))) dx
                  ]              dx
                  /
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} antidiff (@var{expr}, @var{x}, @var{u}(@var{x}))

Returns an antiderivative of @var{expr} with respect to @var{x}.
The expression @var{expr} may contain an unknown function @var{u} and its derivatives.

When @code{antidiff} succeeds entirely,
the resulting expression is free of integral signs (that is, free of the @code{integrate} noun).
Otherwise, @code{antidiff} returns an expression
which is partly or entirely within an integral sign.
If @code{antidiff} cannot make any progress,
the return value is entirely within an integral sign.

@code{load ("antid")} loads this function.
The @code{antid} package also defines the functions @code{nonzeroandfreeof} and @code{linear}.

@code{antidiff} is related to @code{antid} as follows.
Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then the return value of @code{antidiff} is equal to @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
where @var{x} is the variable of integration.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THESE INPUTS
@c load ("antid")$
@c expr: exp (z(x)) * diff (z(x), x) * y(x);
@c a1: antid (expr, x, z(x));
@c a2: antidiff (expr, x, z(x));
@c a2 - (first (a1) + 'integrate (second (a1), x));
@c antid (expr, x, y(x));
@c antidiff (expr, x, y(x));
@c THERE IS A DEMO FILE share/integration/antid.dem, EXECUTED BY demo('antid)
@c BUT I THINK THE FOLLOWING ILLUSTRATES THE BASIC FUNCTIONALITY MORE CLEARLY
@c MAYBE MERGE IN THE DEMO PROBLEMS LATER

@example
(%i1) load ("antid")$
(%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                            z(x)  d
(%o2)                y(x) %e     (-- (z(x)))
                                  dx
(%i3) a1: antid (expr, x, z(x));
                       z(x)      z(x)  d
(%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                       dx
(%i4) a2: antidiff (expr, x, z(x));
                            /
                     z(x)   [   z(x)  d
(%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                            ]         dx
                            /
(%i5) a2 - (first (a1) + 'integrate (second (a1), x));
(%o5)                           0
(%i6) antid (expr, x, y(x));
                             z(x)  d
(%o6)             [0, y(x) %e     (-- (z(x)))]
                                   dx
(%i7) antidiff (expr, x, y(x));
                  /
                  [        z(x)  d
(%o7)             I y(x) %e     (-- (z(x))) dx
                  ]              dx
                  /
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c I SUSPECT THERE IS MORE TO BE SAID HERE

@c -----------------------------------------------------------------------------
@defvr {Property} atomgrad

@code{atomgrad} is the atomic gradient property of an expression.
This property is assigned by @code{gradef}.

@c NEED EXAMPLE HERE
@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} atvalue (@var{expr}, [@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}], @var{c})
@deffnx {Function} atvalue (@var{expr}, @var{x_1} = @var{a_1}, @var{c})

Assigns the value @var{c} to @var{expr} at the point @code{@var{x} = @var{a}}.
Typically boundary values are established by this mechanism.

@var{expr} is a function evaluation,
@code{@var{f}(@var{x_1}, ..., @var{x_m})},
or a derivative,
@code{diff (@var{f}(@var{x_1}, ..., @var{x_m}), @var{x_1}, @var{n_1}, ..., @var{x_n}, @var{n_m})}
@c HMM, WHAT IS THIS NEXT PHRASE GETTING AT ??
@c DOES IT INTEND TO IMPLY THAT IMPLICIT DEPENDENCIES ARE IGNORED ??
in which the function arguments explicitly appear.
@var{n_i} is the order of differentiation with respect to @var{x_i}.

The point at which the atvalue is established is given by the list of equations
@code{[@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}]}.
If there is a single variable @var{x_1},
the sole equation may be given without enclosing it in a list.

@code{printprops ([@var{f_1}, @var{f_2}, ...], atvalue)} displays the atvalues of
the functions @code{@var{f_1}, @var{f_2}, ...}
as specified by calls to @code{atvalue}.
@code{printprops (@var{f}, atvalue)} displays the atvalues of one function @var{f}.
@code{printprops (all, atvalue)} displays the atvalues of all functions for which atvalues are defined.

The symbols @code{@@1}, @code{@@2}, ... represent the 
variables @var{x_1}, @var{x_2}, ... when atvalues are displayed.

@code{atvalue} evaluates its arguments.
@code{atvalue} returns @var{c}, the atvalue.

Examples:
@c FOLLOWING ADAPTED FROM example (atvalue)
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x,y)^2 - u(x,y)^2, x);
@c at (%, [x = 0, y = 1]);

@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@c @opencatbox
@c @category{Differential equations} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c LOOKS LIKE cartan IS THE NAME OF A PACKAGE AND NOT A FUNCTION OR VARIABLE
@c PROBABLY SHOULD SPLIT OUT cartan AND ITS CONTENTS INTO ITS OWN TEXINFO FILE
@c ext_diff AND lie_diff NOT DOCUMENTED (OTHER THAN HERE)

@c -----------------------------------------------------------------------------
@deffn {Function} cartan  -

The exterior calculus of differential forms is a basic tool
of differential geometry developed by Elie Cartan and has important
applications in the theory of partial differential equations.
The @code{cartan} package
implements the functions @code{ext_diff} and @code{lie_diff},
along with the operators @code{~} (wedge product) and @code{|} (contraction
of a form with a vector.)
Type @code{demo (tensor)} to see a brief
description of these commands along with examples.

@code{cartan} was implemented by F.B. Estabrook and H.D. Wahlquist.

@c @opencatbox
@c @category{Differential geometry}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} del (@var{x})

@code{del (@var{x})} represents the differential of the variable @math{x}.

@code{diff} returns an expression containing @code{del}
if an independent variable is not specified.
In this case, the return value is the so-called "total differential".

Examples:
@c GENERATED FROM THE FOLLOWING
@c diff (log (x));
@c diff (exp (x*y));
@c diff (x*y*z);

@example
(%i1) diff (log (x));
                             del(x)
(%o1)                        ------
                               x
(%i2) diff (exp (x*y));
                     x y              x y
(%o2)            x %e    del(y) + y %e    del(x)
(%i3) diff (x*y*z);
(%o3)         x y del(z) + x z del(y) + y z del(x)
@end example

@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} delta (@var{t})

The Dirac Delta function.

Currently only @code{laplace} knows about the @code{delta} function.

Example:

@example
(%i1) laplace (delta (t - a) * sin(b*t), t, s);
Is  a  positive, negative, or zero?

p;
                                   - a s
(%o1)                   sin(a b) %e
@end example

@c @opencatbox
@c @category{Mathematical functions} @category{Laplace transform}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} dependencies
Default value: @code{[]}

@code{dependencies} is the list of atoms which have functional
dependencies, assigned by @code{depends} or @code{gradef}.
The @code{dependencies} list is cumulative:
each call to @code{depends} or @code{gradef} appends additional items.

See @code{depends} and @code{gradef}.

@c @opencatbox
@c @category{Declarations and inferences} @category{Global variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} depends (@var{f_1}, @var{x_1}, ..., @var{f_n}, @var{x_n})

Declares functional dependencies among variables for the purpose of computing derivatives.
In the absence of declared dependence,
@code{diff (f, x)} yields zero.
If @code{depends (f, x)} is declared,
@code{diff (f, x)} yields a symbolic derivative (that is, a @code{diff} noun).

Each argument @var{f_1}, @var{x_1}, etc., can be the name of a variable or array,
or a list of names.
Every element of @var{f_i} (perhaps just a single element)
is declared to depend
on every element of @var{x_i} (perhaps just a single element).
If some @var{f_i} is the name of an array or contains the name of an array,
all elements of the array depend on @var{x_i}.

@code{diff} recognizes indirect dependencies established by @code{depends}
and applies the chain rule in these cases.

@code{remove (@var{f}, dependency)} removes all dependencies declared for @var{f}.

@code{depends} returns a list of the dependencies established.
The dependencies are appended to the global variable @code{dependencies}.
@code{depends} evaluates its arguments.

@code{diff} is the only Maxima command which recognizes dependencies established by @code{depends}.
Other functions (@code{integrate}, @code{laplace}, etc.)
only recognize dependencies explicitly represented by their arguments.
For example, @code{integrate} does not recognize the dependence of @code{f} on @code{x}
unless explicitly represented as @code{integrate (f(x), x)}.

@c GENERATED BY THE FOLLOWING
@c depends ([f, g], x);
@c depends ([r, s], [u, v, w]);
@c depends (u, t);
@c dependencies;
@c diff (r.s, u);
@example
(%i1) depends ([f, g], x);
(%o1)                     [f(x), g(x)]
(%i2) depends ([r, s], [u, v, w]);
(%o2)               [r(u, v, w), s(u, v, w)]
(%i3) depends (u, t);
(%o3)                        [u(t)]
(%i4) dependencies;
(%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
(%i5) diff (r.s, u);
                         dr           ds
(%o5)                    -- . s + r . --
                         du           du
@end example

@c GENERATED BY THE FOLLOWING
@c diff (r.s, t);
@example
(%i6) diff (r.s, t);
                      dr du           ds du
(%o6)                 -- -- . s + r . -- --
                      du dt           du dt
@end example

@c GENERATED BY THE FOLLOWING
@c remove (r, dependency);
@c diff (r.s, t);
@example
(%i7) remove (r, dependency);
(%o7)                         done
(%i8) diff (r.s, t);
                                ds du
(%o8)                       r . -- --
                                du dt
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} derivabbrev
Default value: @code{false}

When @code{derivabbrev} is @code{true},
symbolic derivatives (that is, @code{diff} nouns) are displayed as subscripts.
Otherwise, derivatives are displayed in the Leibniz notation @code{dy/dx}.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Differential calculus} @category{Global flags}
@c @closecatbox
@end defvr

@c SEEMS LIKE THIS STATEMENT COULD BE LESS CLUMSY

@c -----------------------------------------------------------------------------
@deffn {Function} derivdegree (@var{expr}, @var{y}, @var{x})

Returns the highest degree of the derivative
of the dependent variable @var{y} with respect to the independent variable
@var{x} occuring in @var{expr}.

Example:
@c GENERATED FROM THE FOLLOWING
@c 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
@c derivdegree (%, y, x);
@example
(%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                         3     2
                        d y   d y    2 dy
(%o1)                   --- + --- + x  --
                          3     2      dx
                        dz    dx
(%i2) derivdegree (%, y, x);
(%o2)                           2
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Expressions}
@c @closecatbox
@end deffn

@c I HAVE NO IDEA WHAT THIS DOES

@c -----------------------------------------------------------------------------
@deffn {Function} derivlist (@var{var_1}, ..., @var{var_k})

Causes only differentiations with respect to
the indicated variables, within the @code{ev} command.

@c @opencatbox
@c @category{Differential calculus} @category{Evaluation}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} derivsubst
Default value: @code{false}

When @code{derivsubst} is @code{true}, a non-syntactic substitution such as
@code{subst (x, 'diff (y, t), 'diff (y, t, 2))} yields @code{'diff (x, t)}.

@c @opencatbox
@c @category{Differential calculus} @category{Expressions}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn  {Function} diff (@var{expr}, @var{x_1}, @var{n_1}, ..., @var{x_m}, @var{n_m})
@deffnx {Function} diff (@var{expr}, @var{x}, @var{n})
@deffnx {Function} diff (@var{expr}, @var{x})
@deffnx {Function} diff (@var{expr})

Returns the derivative or differential of @var{expr} with respect to some or all variables in @var{expr}.

@code{diff (@var{expr}, @var{x}, @var{n})} returns the @var{n}'th derivative of @var{expr}
with respect to @var{x}.

@code{diff (@var{expr}, @var{x_1}, @var{n_1}, ..., @var{x_m}, @var{n_m})}
returns the mixed partial derivative of @var{expr} with respect to @var{x_1}, ..., @var{x_m}.
It is equivalent to @code{diff (... (diff (@var{expr}, @var{x_m}, @var{n_m}) ...), @var{x_1}, @var{n_1})}.

@code{diff (@var{expr}, @var{x})}
returns the first derivative of @var{expr} with respect to
the variable @var{x}.

@code{diff (@var{expr})} returns the total differential of @var{expr},
that is, the sum of the derivatives of @var{expr} with respect to each its variables
times the differential @code{del} of each variable.
@c WHAT DOES THIS NEXT STATEMENT MEAN, EXACTLY ??
No further simplification of @code{del} is offered.

The noun form of @code{diff} is required in some contexts,
such as stating a differential equation.
In these cases, @code{diff} may be quoted (as @code{'diff}) to yield the noun form
instead of carrying out the differentiation.

When @code{derivabbrev} is @code{true}, derivatives are displayed as subscripts.
Otherwise, derivatives are displayed in the Leibniz notation, @code{dy/dx}.

Examples:
@c GENERATED FROM THE FOLLOWING
@c diff (exp (f(x)), x, 2);
@c derivabbrev: true$
@c 'integrate (f(x, y), y, g(x), h(x));
@c diff (%, x);

@example
(%i1) diff (exp (f(x)), x, 2);
                     2
              f(x)  d               f(x)  d         2
(%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                      2                   dx
                    dx
(%i2) derivabbrev: true$
(%i3) 'integrate (f(x, y), y, g(x), h(x));
                         h(x)
                        /
                        [
(%o3)                   I     f(x, y) dy
                        ]
                        /
                         g(x)
(%i4) diff (%, x);
       h(x)
      /
      [
(%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
      ]            x                     x                  x
      /
       g(x)
@end example

For the tensor package, the following modifications have been
incorporated:

(1) The derivatives of any indexed objects in @var{expr} will have the
variables @var{x_i} appended as additional arguments.  Then all the
derivative indices will be sorted.

(2) The @var{x_i} may be integers from 1 up to the value of the variable
@code{dimension} [default value: 4].  This will cause the differentiation to
be carried out with respect to the @var{x_i}'th member of the list @code{coordinates} which
should be set to a list of the names of the coordinates, e.g.,
@code{[x, y, z, t]}. If @code{coordinates} is bound to an atomic variable, then that
variable subscripted by @var{x_i} will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like @code{X[1]}, @code{X[2]}, ... to be used.  If @code{coordinates} has
not been assigned a value, then the variables will be treated as in (1)
above.

@c NEED EXAMPLES FOR TENSOR STUFF
@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end deffn

@c MERGE THIS INTO @defun diff

@c -----------------------------------------------------------------------------
@defvr {Special symbol} diff

When @code{diff} is present as an @code{evflag} in call to @code{ev},
all differentiations indicated in @code{expr} are carried out.

@c NEED EXAMPLE HERE
@end defvr

@c NOT SURE HOW THIS IS SUPPOSED TO WORK

@c -----------------------------------------------------------------------------
@deffn {Function} dscalar (@var{f})

Applies the scalar d'Alembertian to the scalar function @var{f}.

@c APPARENTLY dscalar DOESN'T EXIST IN THE CORE FILES ANYMORE
@c ctensor HAS THE ONLY DEFN I FOUND (OUTSIDE OF archive/)
@code{load ("ctensor")} loads this function.

@c FOLLOWING EXAMPLE DOESN'T WORK; I GET dscalar (field) ==> 0
@c (I GET 0 FOR THE ctensor VERSION OF dscalar, AND SAME FOR
@c THE DEFN OF dscalar GIVEN IN archive/share/lisp/ctensr.trl)
@c INCIDENTALLY dependencies IS DOCUMENTED ONLY AS A VARIABLE

@c @example
@c (%i41) dependencies(field(r));
@c (%o41)                           [field(r)]
@c (%i42) dscalar(field);
@c (%o43)
@c     -m
@c   %e  ((field  n - field  m + 2 field   ) r + 4 field )
@c              r  r       r  r         r r             r
@c 
@c - -----------------------------------------------------
@c                              2 r
@c @end example

@c @opencatbox
@c @category{Differential calculus} @category{Package ctensor}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} express (@var{expr})

@c HERE IS THE PREVIOUS TEXT. WHAT IS THE POINT ABOUT depends ?? I'M NOT GETTING IT
@c The result uses the noun form of any
@c derivatives arising from expansion of the vector differential
@c operators.  To force evaluation of these derivatives, the built-in @code{ev}
@c function can be used together with the @code{diff} evflag, after using the
@c built-in @code{depends} function to establish any new implicit dependencies.

Expands differential operator nouns into expressions in terms of partial derivatives.
@code{express} recognizes the operators @code{grad}, @code{div}, @code{curl}, @code{laplacian}.
@code{express} also expands the cross product @code{~}.

Symbolic derivatives (that is, @code{diff} nouns)
in the return value of express may be evaluated by including @code{diff}
in the @code{ev} function call or command line.
In this context, @code{diff} acts as an @code{evfun}.

@code{load ("vect")} loads this function.
@c IN POINT OF FACT, express IS A SIMPLIFICATION RULE, AND express1 IS THE FCN WHICH DOES ALL THE WORK

Examples:
@c GENERATED FROM THE FOLLOWING
@c load ("vect")$
@c grad (x^2 + y^2 + z^2);
@c express (%);
@c ev (%, diff);
@c div ([x^2, y^2, z^2]);
@c express (%);
@c ev (%, diff);
@c curl ([x^2, y^2, z^2]);
@c express (%);
@c ev (%, diff);
@c laplacian (x^2 * y^2 * z^2);
@c express (%);
@c ev (%, diff);
@c [a, b, c] ~ [x, y, z];
@c express (%);

@example
(%i1) load ("vect")$
(%i2) grad (x^2 + y^2 + z^2);
                              2    2    2
(%o2)                  grad (z  + y  + x )
(%i3) express (%);
       d    2    2    2   d    2    2    2   d    2    2    2
(%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
       dx                 dy                 dz
(%i4) ev (%, diff);
(%o4)                    [2 x, 2 y, 2 z]
(%i5) div ([x^2, y^2, z^2]);
                              2   2   2
(%o5)                   div [x , y , z ]
(%i6) express (%);
                   d    2    d    2    d    2
(%o6)              -- (z ) + -- (y ) + -- (x )
                   dz        dy        dx
(%i7) ev (%, diff);
(%o7)                    2 z + 2 y + 2 x
(%i8) curl ([x^2, y^2, z^2]);
                               2   2   2
(%o8)                   curl [x , y , z ]
(%i9) express (%);
       d    2    d    2   d    2    d    2   d    2    d    2
(%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
       dy        dz       dz        dx       dx        dy
(%i10) ev (%, diff);
(%o10)                      [0, 0, 0]
(%i11) laplacian (x^2 * y^2 * z^2);
                                  2  2  2
(%o11)                laplacian (x  y  z )
(%i12) express (%);
         2                2                2
        d     2  2  2    d     2  2  2    d     2  2  2
(%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
          2                2                2
        dz               dy               dx
(%i13) ev (%, diff);
                      2  2      2  2      2  2
(%o13)             2 y  z  + 2 x  z  + 2 x  y
(%i14) [a, b, c] ~ [x, y, z];
(%o14)                [a, b, c] ~ [x, y, z]
(%i15) express (%);
(%o15)          [b z - c y, c x - a z, a y - b x]
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Vectors} @category{Operators}
@c @closecatbox
@end deffn

@c COMMENTING OUT THIS TEXT PENDING RESOLUTION OF BUG REPORT # 836704:
@c "gendiff is all bugs: should be deprecated"
@c @defun gendiff
@c Sometimes @code{diff(e,x,n)} can be reduced even though N is
@c symbolic.
@c 
@c @example
@c batch("gendif")$
@c @end example
@c 
@c and you can try, for example,
@c 
@c @example
@c diff(%e^(a*x),x,q)
@c @end example
@c 
@c by using @code{gendiff} rather than @code{diff}.  Unevaluable
@c items come out quoted.  Some items are in terms of @code{genfact}, which
@c see.
@c 
@c @end defun

@c -----------------------------------------------------------------------------
@deffn {Function}  gradef (@var{f}(@var{x_1}, ..., @var{x_n}), @var{g_1}, ..., @var{g_m})
@deffnx {Function} gradef (@var{a}, @var{x}, @var{expr})

Defines the partial derivatives (i.e., the components of the gradient) of the function @var{f}
or variable @var{a}.

@code{gradef (@var{f}(@var{x_1}, ..., @var{x_n}), @var{g_1}, ..., @var{g_m})}
defines @code{d@var{f}/d@var{x_i}} as @var{g_i}, 
where @var{g_i} is an expression; @var{g_i} may be a function call, but not the name of a function.
The number of partial derivatives @var{m} may be less than the number of arguments @var{n},
in which case derivatives are defined with respect to @var{x_1} through @var{x_m} only.

@code{gradef (@var{a}, @var{x}, @var{expr})} defines the derivative of variable @var{a}
with respect to @var{x} as @var{expr}.
This also establishes the dependence of @var{a} on @var{x} (via @code{depends (@var{a}, @var{x})}).

The first argument @code{@var{f}(@var{x_1}, ..., @var{x_n})} or @var{a} is quoted,
but the remaining arguments @var{g_1}, ..., @var{g_m} are evaluated.
@code{gradef} returns the function or variable for which the partial derivatives are defined.

@code{gradef} can redefine the derivatives of Maxima's built-in functions.
For example, @code{gradef (sin(x), sqrt (1 - sin(x)^2))} redefines the derivative of @code{sin}.

@code{gradef} cannot define partial derivatives for a subscripted function.

@code{printprops ([@var{f_1}, ..., @var{f_n}], gradef)} displays the partial derivatives
of the functions @var{f_1}, ..., @var{f_n}, as defined by @code{gradef}.

@code{printprops ([@var{a_n}, ..., @var{a_n}], atomgrad)} displays the partial derivatives
of the variables @var{a_n}, ..., @var{a_n}, as defined by @code{gradef}.

@code{gradefs} is the list of the functions
for which partial derivatives have been defined by @code{gradef}.
@code{gradefs} does not include any variables
for which partial derivatives have been defined by @code{gradef}.

@c REPHRASE THIS NEXT BIT
Gradients are needed when, for example, a function is not known
explicitly but its first derivatives are and it is desired to obtain
higher order derivatives.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} gradefs
Default value: @code{[]}

@code{gradefs} is the list of the functions
for which partial derivatives have been defined by @code{gradef}.
@code{gradefs} does not include any variables
for which partial derivatives have been defined by @code{gradef}.

@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {Function} laplace (@var{expr}, @var{t}, @var{s})

Attempts to compute the Laplace transform of @var{expr} with respect to the 
variable @var{t} and transform parameter @var{s}.

@code{laplace} recognizes in @var{expr} the functions @code{delta}, @code{exp},
@code{log}, @code{sin}, @code{cos}, @code{sinh}, @code{cosh}, and @code{erf},
as well as @code{derivative}, @code{integrate}, @code{sum}, and @code{ilt}. If
laplace fails to find a transform the function @code{specint} is called.
@code{specint} can find the laplace transform for expressions with special
functions like the bessel functions @code{bessel_j}, @code{bessel_i}, ... and
can handle the @code{unit_step} function. See also @code{specint}.

If @code{specint} cannot find a solution too, a noun @code{laplace} is returned.

@c REPHRASE THIS
@var{expr} may also be a linear, constant coefficient differential equation in
which case @code{atvalue} of the dependent variable is used.
@c "used" -- USED HOW ??
The required atvalue may be supplied either before or after the transform is computed.
Since the initial conditions must be specified at zero, if one has boundary
conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution
for them and substituting their values back.

@code{laplace} recognizes convolution integrals of the form
@code{integrate (f(x) * g(t - x), x, 0, t)};
other kinds of convolutions are not recognized.

Functional relations must be explicitly represented in @var{expr};
implicit relations, established by @code{depends}, are not recognized.
That is, if @var{f} depends on @var{x} and @var{y},
@code{f (x, y)} must appear in @var{expr}.

See also @code{ilt}, the inverse Laplace transform.

Examples:
@c GENERATED FROM THE FOLLOWING:
@c laplace (exp (2*t + a) * sin(t) * t, t, s);
@c laplace ('diff (f (x), x), x, s);
@c diff (diff (delta (t), t), t);
@c laplace (%, t, s);

@example
(%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                            a
                          %e  (2 s - 4)
(%o1)                    ---------------
                           2           2
                         (s  - 4 s + 5)
(%i2) laplace ('diff (f (x), x), x, s);
(%o2)             s laplace(f(x), x, s) - f(0)
(%i3) diff (diff (delta (t), t), t);
                          2
                         d
(%o3)                    --- (delta(t))
                           2
                         dt
(%i4) laplace (%, t, s);
                            !
               d            !         2
(%o4)        - -- (delta(t))!      + s  - delta(0) s
               dt           !
                            !t = 0
(%i5) assume(a>0)$
(%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                              - a - 1
                         gamma(a)   gamma(a) s
(%o6)                    -------- - -----------------
                            s            1     a
                                        (- + 1)
                                         s
(%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                              s + 1
                      sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                s
(%o7)                 -----------------------------------
                                3/2      s + 1
                               s    sqrt(-----)
                                           s
(%i8) assume(exp(%pi*s)>1)$
(%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s),simpsum;
                         %i                         %i
              ------------------------ - ------------------------
                              - %pi s                    - %pi s
              (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
(%o9)         ---------------------------------------------------
                                       2
(%i9) factor(%);
                                      %pi s
                                    %e
(%o9)                   -------------------------------
                                             %pi s
                        (s - %i) (s + %i) (%e      - 1)

@end example

@c @opencatbox
@c @category{Laplace transform} @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Integration, Einf@"uhrung in die Integration, Funktionen und Variablen der Differentiation, Analysis
@section Integration

@c -----------------------------------------------------------------------------
@menu
* Einf@"uhrung in die Integration::
* Funktionen und Variablen der Integration::
* Einf@"uhrung in QUADPACK::
* Funktionen und Variablen f@"ur QUADPACK::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Integration, Funktionen und Variablen der Integration, Integration
@subsection Einf@"uhrung in die Integration

Maxima has several routines for handling integration.
The @code{integrate} function makes use of most of them.  There is also the
@code{antid} package, which handles an unspecified function (and its
derivatives, of course).  For numerical uses,
there is a set of adaptive integrators from QUADPACK,
named @code{quad_qag}, @code{quad_qags}, etc., which are described under the heading @code{QUADPACK}.
Hypergeometric functions are being worked on,
see @code{specint} for details.
Generally speaking, Maxima only handles integrals which are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as @code{g(x)} and @code{h(x)}.

@c end concepts Integration

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Integration, Einf@"uhrung in QUADPACK, Einf@"uhrung in die Integration, Integration
@subsection Funktionen und Variablen der Integration

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@deffn {Function} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})
Makes the change of variable given by
@code{@var{f(x,y)} = 0} in all integrals occurring in @var{expr} with integration with
respect to @var{x}.
The new variable is @var{y}.

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
@group
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
@end group
@group
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end group
@end example

An expression containing a noun form, such as the instances of @code{'integrate} above,
may be evaluated by @code{ev} with the @code{nouns} flag.
For example, the expression returned by @code{changevar} above may be evaluated
by @code{ev (%o3, nouns)}.

@code{changevar} may also be used to changes in the indices of a sum or
product.  However, it must be realized that when a change is made in a
sum or product, this change must be a shift, i.e., @code{i = j+ ...}, not a
higher degree function.  E.g.,

@example
@group
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
@end group
@group
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE

@c -----------------------------------------------------------------------------
@deffn {Function} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})

A double-integral routine which was written in
top-level Maxima and then translated and compiled to machine code.
Use @code{load (dblint)} to access this package.  It uses the Simpson's rule
method in both the x and y directions to calculate

@tex
$$\int_a^b \int_{r\left(x\right)}^{s\left(x\right)} f\left(x,y\right) \, dy \, dx.$$
@end tex
@ifnottex
@example
@group
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end group
@end example
@end ifnottex

The function @var{f} must be a translated or compiled function of two
variables, and @var{r} and @var{s} must each be a translated or compiled
function of one variable, while @var{a} and @var{b} must be floating point
numbers. The routine has two global variables which determine the
number of divisions of the x and y intervals: @code{dblint_x} and @code{dblint_y},
both of which are initially 10, and can be changed independently to
other integer values (there are @code{2*dblint_x+1} points computed in the x
direction, and @code{2*dblint_y+1} in the y direction).
The routine subdivides the X axis and then for each value of X it
first computes @code{@var{r}(x)} and @code{@var{s}(x)}; then the Y axis between @code{@var{r}(x)} and @code{@var{s}(x)} is
subdivided and the integral along the Y axis is performed using
Simpson's rule; then the integral along the X axis is done using
Simpson's rule with the function values being the Y-integrals. This
procedure may be numerically unstable for a great variety of reasons,
but is reasonably fast: avoid using it on highly oscillatory functions
and functions with singularities (poles or branch points in the
region).  The Y integrals depend on how far apart @code{@var{r}(x)} and @code{@var{s}(x)} are,
so if the distance @code{@var{s}(x) - @var{r}(x)} varies rapidly with X, there may be
substantial errors arising from truncation with different step-sizes
in the various Y integrals. One can increase @code{dblint_x} and @code{dblint_y} in
an effort to improve the coverage of the region, at the expense of
computation time. The function values are not saved, so if the
function is very time-consuming, you will have to wait for
re-computation if you change anything (sorry).
It is required that the functions @var{f}, @var{r}, and @var{s} be either translated or
compiled prior to calling @code{dblint}. This will result in orders of
magnitude speed improvement over interpreted code in many cases!

@code{demo (dblint)} executes a demonstration of @code{dblint} applied to an example problem.
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT. !!!
@c @code{demo (dblint_1)} executes another demonstration.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} defint (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to compute a definite integral.
@code{defint} is called by @code{integrate} when limits of integration are specified,
i.e., when @code{integrate} is called as @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
Thus from the user's point of view, it is sufficient to call @code{integrate}.
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

@code{defint} returns a symbolic expression,
either the computed integral or the noun form of the integral.
See @code{quad_qag} and related functions for numerical approximation of definite integrals.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} erfflag
Default value: @code{true}

When @code{erfflag} is @code{false}, prevents @code{risch} from introducing the
@code{erf} function in the answer if there were none in the integrand to
begin with.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@deffn {Function} ilt (@var{expr}, @var{s}, @var{t})

Computes the inverse Laplace transform of @var{expr} with
respect to @var{s} and parameter @var{t}.  @var{expr} must be a ratio of
polynomials whose denominator has only linear and quadratic factors.
By using the functions @code{laplace} and @code{ilt} together with the @code{solve} or
@code{linsolve} functions the user can solve a single differential or
convolution integral equation or a set of them.

@example
@group
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
@end group
@group
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
@end group
@group
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
@end group
@group
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end group
@end example

@c @opencatbox
@c @category{Laplace transform}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} intanalysis
Default value: @code{true}

When @code{true}, definite integration tries to find poles in the integrand in 
the interval of integration. If there are, then the integral is evaluated
appropriately as a principal value integral. If intanalysis is @code{false}, 
this check is not performed and integration is done assuming there are no poles.

See also @code{ldefint}.

Examples:

Maxima can solve the following integrals, when @code{intanalysis} is set to
@code{false}:

@c ===beg===
@c integrate(1/(sqrt(x+1)+1),x,0,1);
@c integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
@c integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
@c intanalysis:false$
@c integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
@c ===end===
@example
(%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                1
                               /
                               [       1
(%o1)                          I  ----------- dx
                               ]  sqrt(x) + 1
                               /
                                0

(%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
(%o2)                            2 - 2 log(2)

(%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
The number 1 isn't in the domain of atanh
 -- an error. To debug this try: debugmode(true);

(%i4) intanalysis:false$
(%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                      %pi
(%o5)                                 ---
                                       2
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn  {Function} integrate (@var{expr}, @var{x})
@deffnx {Function} integrate (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to symbolically compute the integral of @var{expr} with respect to @var{x}.
@code{integrate (@var{expr}, @var{x})} is an indefinite integral,
while @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})} is a definite integral,
with limits of integration @var{a} and @var{b}.
The limits should not contain @var{x}, although @code{integrate} does not enforce this restriction.
@var{a} need not be less than @var{b}.
If @var{b} is equal to @var{a}, @code{integrate} returns zero.

See @code{quad_qag} and related functions for numerical approximation of definite integrals.
See @code{residue} for computation of residues (complex integration).
See @code{antid} for an alternative means of computing indefinite integrals.

The integral (an expression free of @code{integrate}) is returned if @code{integrate} succeeds.
Otherwise the return value is
the noun form of the integral (the quoted operator @code{'integrate})
or an expression containing one or more noun forms.
The noun form of @code{integrate} is displayed with an integral sign.

In some circumstances it is useful to construct a noun form by hand,
by quoting @code{integrate} with a single quote, e.g., @code{'integrate (@var{expr}, @var{x})}.
For example, the integral may depend on some parameters which are not yet computed.
The noun may be applied to its arguments by @code{ev (@var{i}, nouns)}
where @var{i} is the noun form of interest.

@c BEGIN EXPOSITION ON HEURISTICS
@code{integrate} handles definite integrals separately from indefinite,
and employs a range of heuristics to handle each case.
Special cases of definite integrals include limits of integration equal to
zero or infinity (@code{inf} or @code{minf}),
trigonometric functions with limits of integration equal to zero and @code{%pi} or @code{2 %pi},
rational functions,
integrals related to the definitions of the @code{beta} and @code{psi} functions,
and some logarithmic and trigonometric integrals.
Processing rational functions may include computation of residues.
If an applicable special case is not found,
an attempt will be made to compute the indefinite integral and evaluate it at the limits of integration.
This may include taking a limit as a limit of integration goes to infinity or negative infinity;
see also @code{ldefint}.

Special cases of indefinite integrals include trigonometric functions,
exponential and logarithmic functions,
and rational functions.
@code{integrate} may also make use of a short table of elementary integrals.

@code{integrate} may carry out a change of variable
if the integrand has the form @code{f(g(x)) * diff(g(x), x)}.
@code{integrate} attempts to find a subexpression @code{g(x)} such that
the derivative of @code{g(x)} divides the integrand.
This search may make use of derivatives defined by the @code{gradef} function.
See also @code{changevar} and @code{antid}.

If none of the preceding heuristics find the indefinite integral,
the Risch algorithm is executed.
The flag @code{risch} may be set as an @code{evflag},
in a call to @code{ev} or on the command line,
e.g., @code{ev (integrate (@var{expr}, @var{x}), risch)} or @code{integrate (@var{expr}, @var{x}), risch}.
If @code{risch} is present, @code{integrate} calls the @code{risch} function
without attempting heuristics first. See also @code{risch}.
@c END EXPOSITION ON HEURISTICS

@code{integrate} works only with functional relations represented explicitly with the @code{f(x)} notation.
@code{integrate} does not respect implicit dependencies established by the @code{depends} function.

@code{integrate} may need to know some property of a parameter in the integrand.
@code{integrate} will first consult the @code{assume} database,
and, if the variable of interest is not there,
@code{integrate} will ask the user.
Depending on the question,
suitable responses are @code{yes;} or @code{no;},
or @code{pos;}, @code{zero;}, or @code{neg;}.

@code{integrate} is not, by default, declared to be linear. See @code{declare} and @code{linear}.

@code{integrate} attempts integration by parts only in a few special cases.

Examples:

@itemize @bullet
@item
Elementary indefinite and definite integrals.

@example
@group
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
@end group
@group
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
@end group
@group
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
@end group
@group
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end group
@end example

@item
Use of @code{assume} and interactive query.

@example
(%i1) assume (a > 1)$
@group
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end group
@end example

@item
Change of variable. There are two changes of variable in this example:
one using a derivative established by @code{gradef},
and one using the derivation @code{diff(r(x))} of an unspecified function @code{r(x)}.

@example
@group
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
@end group
@group
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
@end group
@group
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end group
@end example

@item
Return value contains the @code{'integrate} noun form.
In this example, Maxima can extract one factor of the denominator
of a rational function, but cannot factor the remainder or otherwise find its integral.
@code{grind} shows the noun form @code{'integrate} in the result.
See also @code{integrate_use_rootsof} for more on integrals of rational functions.

@example
@group
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
@end group
@group
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
@end group
@group
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end group
@end example

@item
Defining a function in terms of an integral.
The body of a function is not evaluated when the function is defined.
Thus the body of @code{f_1} in this example contains the noun form of @code{integrate}.
The quote-quote operator @code{'@w{}'} causes the integral to be evaluated,
and the result becomes the body of @code{f_2}.

@example
@group
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
@end group
@group
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
@end group
@group
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
@end group
@group
(%i4) f_2 (7);
(%o4)                          600
@end group
@end example
@end itemize

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} integration_constant
Default value: @code{%c}

When a constant of integration is introduced by indefinite integration of an equation,
the name of the constant is constructed by concatenating @code{integration_constant}
and @code{integration_constant_counter}.

@code{integration_constant} may be assigned any symbol.

Examples:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integration_constant : 'k;
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integration_constant : 'k;
(%o2)                           k
@end group
@group
(%i3) integrate (x^2 = 1, x);
                            3
                           x
(%o3)                      -- = x + k2
                           3
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {System variable} integration_constant_counter
Default value: 0

When a constant of integration is introduced by indefinite integration of an equation,
the name of the constant is constructed by concatenating @code{integration_constant}
and @code{integration_constant_counter}.

@code{integration_constant_counter} is incremented before constructing the next integration constant.

Examples:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c reset (integration_constant_counter);
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integrate (x^2 = 1, x);
                           3
                          x
(%o2)                     -- = x + %c2
                          3
@end group
@group
(%i3) integrate (x^2 = 1, x);
                           3
                          x
(%o3)                     -- = x + %c3
                          3
@end group
@group
(%i4) reset (integration_constant_counter);
(%o4)            [integration_constant_counter]
@end group
@group
(%i5) integrate (x^2 = 1, x);
                           3
                          x
(%o5)                     -- = x + %c1
                          3
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {Option variable} integrate_use_rootsof
Default value: @code{false}

When @code{integrate_use_rootsof} is @code{true} and the denominator of
a rational function cannot be factored, @code{integrate} returns the integral
in a form which is a sum over the roots (not yet known) of the denominator.

For example, with @code{integrate_use_rootsof} set to @code{false},
@code{integrate} returns an unsolved integral of a rational function in noun form:

@example
(%i1) integrate_use_rootsof: false$
@group
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end group
@end example

Now we set the flag to be true and the unsolved part of the
integral will be expressed as a summation over the roots of the denominator of the rational function:

@example
(%i3) integrate_use_rootsof: true$
@group
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                      3    2
      %r4 in rootsof(x  - x  + 1)
(%o4) ----------------------------------------------------------
               7

                                                      2 x + 1
                                  2            5 atan(-------)
                             log(x  + x + 1)          sqrt(3)
                           - --------------- + ---------------
                                   14             7 sqrt(3)
@end group
@end example

Alternatively the user may compute the roots of the denominator separately,
and then express the integrand in terms of these roots,
e.g., @code{1/((x - a)*(x - b)*(x - c))} or @code{1/((x^2 - (a+b)*x + a*b)*(x - c))}
if the denominator is a cubic polynomial.
Sometimes this will help Maxima obtain a more useful result.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@deffn {Function} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to compute the definite integral of @var{expr} by using
@code{limit} to evaluate the indefinite integral of @var{expr} with respect to @var{x}
at the upper limit @var{b} and at the lower limit @var{a}.
If it fails to compute the definite integral,
@code{ldefint} returns an expression containing limits as noun forms.

@code{ldefint} is not called from @code{integrate},
so executing @code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})} may yield a different result than
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
@code{ldefint} always uses the same method to evaluate the definite integral,
while @code{integrate} may employ various heuristics and may recognize some special cases.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@deffn {Function} potential (@var{givengradient})

The calculation makes use of the global variable @code{potentialzeroloc[0]}
which must be @code{nonlist} or of the form

@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example

the
former being equivalent to the nonlist expression for all right-hand
sides in the latter.  The indicated right-hand sides are used as the
lower limit of integration.  The success of the integrations may
depend upon their values and order. @code{potentialzeroloc} is initially set
to 0.

@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} residue (@var{expr}, @var{z}, @var{z_0})

Computes the residue in the complex plane of
the expression @var{expr} when the variable @var{z} assumes the value @var{z_0}.  The
residue is the coefficient of @code{(@var{z} - @var{z_0})^(-1)} in the Laurent series
for @var{expr}.

@example
@group
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
@end group
@group
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end group
@end example

@c @opencatbox
@c @category{Integral calculus} @category{Complex variables}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} risch (@var{expr}, @var{x})

Integrates @var{expr} with respect to @var{x} using the
transcendental case of the Risch algorithm.  (The algebraic case of
the Risch algorithm has not been implemented.)  This currently
handles the cases of nested exponentials and logarithms which the main
part of @code{integrate} can't do.  @code{integrate} will automatically apply @code{risch}
if given these cases.

@code{erfflag}, if @code{false}, prevents @code{risch} from introducing the @code{erf}
function in the answer if there were none in the integrand to begin
with.

@example
@group
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
@end group
@group
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES

@c -----------------------------------------------------------------------------
@deffn {Function} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})

Equivalent to @code{ldefint} with @code{tlimswitch} set to @code{true}.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@footnotestyle end

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in QUADPACK, Funktionen und Variablen f@"ur QUADPACK, Funktionen und Variablen der Integration, Integration
@subsection Einf@"uhrung in QUADPACK

@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACK is a collection of functions for the numerical
computation of one-dimensional definite integrals.
It originated from a joint project of
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"ur Mathematik, T.U. Wien},
and D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.

The QUADPACK library included in Maxima is an automatic translation
(via the program @code{f2cl}) of the Fortran source code of QUADPACK as it appears in
the SLATEC Common Mathematical Library, Version 4.1 @footnote{@url{http://www.netlib.org/slatec}}.
The SLATEC library is dated July 1993, but the QUADPACK functions
were written some years before.
There is another version of QUADPACK at Netlib @footnote{@url{http://www.netlib.org/quadpack}};
it is not clear how that version differs from the SLATEC version.

The QUADPACK functions included in Maxima are all automatic,
in the sense that these functions attempt to compute a result to a specified accuracy,
requiring an unspecified number of function evaluations.
Maxima's Lisp translation of QUADPACK also includes some non-automatic functions,
but they are not exposed at the Maxima level.

Further information about QUADPACK can be found in the QUADPACK book
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}.

@c -----------------------------------------------------------------------------
@subsubheading Overview

@table @code
@item quad_qag
Integration of a general function over a finite interval.
@code{quad_qag} implements a simple globally adaptive integrator using the strategy of Aind (Piessens, 1973).
The caller may choose among 6 pairs of Gauss-Kronrod quadrature
formulae for the rule evaluation component.
The high-degree rules are suitable for strongly oscillating integrands.

@item quad_qags
Integration of a general function over a finite interval.
@code{quad_qags} implements globally adaptive interval subdivision with extrapolation
(de Doncker, 1978) by the Epsilon algorithm (Wynn, 1956).

@item quad_qagi
Integration of a general function over an infinite or semi-infinite interval.
The interval is mapped onto a finite interval and
then the same strategy as in @code{quad_qags} is applied.

@item quad_qawo
@ifnottex
Integration of @math{cos(omega x) f(x)} or @math{sin(omega x) f(x)} over a finite interval,
where @math{omega} is a constant.
@end ifnottex
@tex
Integration of $\cos\left(\omega \, x\right) \, f\left(x\right)$ or
$\sin\left(\omega \, x\right) \, f\left(x\right)$ over a finite interval,
where $\omega$ is a constant.
@end tex
The rule evaluation component is based on the modified Clenshaw-Curtis technique.
@code{quad_qawo} applies adaptive subdivision with extrapolation, similar to @code{quad_qags}.

@item quad_qawf
Calculates a Fourier cosine or Fourier sine transform on a semi-infinite interval.
The same approach as in @code{quad_qawo} is applied on successive finite intervals,
and convergence acceleration by means of the Epsilon algorithm (Wynn, 1956)
is applied to the series of the integral contributions.

@item quad_qaws
@ifnottex
Integration of @math{w(x) f(x)} over a finite interval @math{[a, b]},
where @math{w} is a function of the form @math{(x - a)^alpha (b - x)^beta v(x)}
and @math{v(x)} is 1 or @math{log(x - a)} or @math{log(b - x)} or @math{log(x - a) log(b - x)},
and @math{alpha > -1} and @math{beta > -1}.
@end ifnottex
@tex
Integration of $w\left(x\right) \, f\left(x\right)$ over a finite interval
$\left[a, b\right]$, where $w$ is a function of the form
$\left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, v\left(x\right)$
and $v\left(x\right)$ is $1$ or $\log\left(x - a\right)$
or $\log\left(b - x\right)$ or $\log\left(x - a\right) \, \log\left(b - x\right)$,
and $\alpha > -1$ and $\beta > -1$.
@end tex

A globally adaptive subdivision strategy is applied,
with modified Clenshaw-Curtis integration on the subintervals which contain @math{a} or @math{b}.

@item quad_qawc
Computes the Cauchy principal value of @math{f(x)/(x - c)} over a finite interval @math{(a, b)}
and specified @math{c}.
The strategy is globally adaptive, and modified
Clenshaw-Curtis integration is used on the subranges
which contain the point @math{x = c}.
@end table

@c @opencatbox
@c @category{Integral calculus} @category{Numerical methods} @category{Share packages} @category{Package quadpack}
@c @closecatbox

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur QUADPACK, , Einf@"uhrung in QUADPACK, Integration
@subsection Funktionen und Variablen f@"ur QUADPACK

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qag (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qag (@var{f}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over a finite interval.
@code{quad_qag} implements a simple globally adaptive integrator using the strategy of Aind (Piessens, 1973).
The caller may choose among 6 pairs of Gauss-Kronrod quadrature
formulae for the rule evaluation component.
The high-degree rules are suitable for strongly oscillating integrands.

@code{quad_qag} computes the integral

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex

The function to be integrated is @var{f(x)}, with dependent
variable @var{x}, and the function is to be integrated between the
limits @var{a} and @var{b}.  @var{key} is the integrator to be used
and should be an integer between 1 and 6, inclusive.  The value of
@var{key} selects the order of the Gauss-Kronrod integration rule.
High-order rules are suitable for strongly oscillating integrands.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The numerical integration is done adaptively by subdividing the
integration region into sub-intervals until the desired accuracy is
achieved.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qag} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
if no problems were encountered;
@item 1
if too many sub-intervals were done;
@item 2
if excessive roundoff error is detected;
@item 3
if extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
@end group
@group
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qags (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qags (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over a finite interval.
@code{quad_qags} implements globally adaptive interval subdivision with extrapolation
(de Doncker, 1978) by the Epsilon algorithm (Wynn, 1956).

@code{quad_qags} computes the integral

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex

The function to be integrated is @var{f(x)}, with
dependent variable @var{x}, and the function is to be integrated
between the limits @var{a} and @var{b}.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qags} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end group
@end example

Note that @code{quad_qags} is more accurate and efficient than @code{quad_qag} for this integrand.

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qagi (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qagi (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over an infinite or semi-infinite interval.
The interval is mapped onto a finite interval and
then the same strategy as in @code{quad_qags} is applied.

@code{quad_qagi} evaluates one of the following integrals

@ifnottex
@math{integrate (f(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, a)}
@end ifnottex
@tex
$$\int_\infty^a {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, inf)}
@end ifnottex
@tex
$$\int_{-\infty}^\infty {f(x) \, dx}$$
@end tex

using the Quadpack QAGI routine.  The function to be integrated is
@var{f(x)}, with dependent variable @var{x}, and the function is to
be integrated over an infinite range.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

One of the limits of integration must be infinity.  If not, then
@code{quad_qagi} will just return the noun form.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qagi} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
@end group
@group
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawc (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qawc (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Computes the Cauchy principal value of @math{f(x)/(x - c)} over a finite interval.
The strategy is globally adaptive, and modified
Clenshaw-Curtis integration is used on the subranges
which contain the point @math{x = c}.

@code{quad_qawc} computes the Cauchy principal value of

@ifnottex
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifnottex
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

using the Quadpack QAWC routine.  The function to be integrated is
@code{@var{f(x)}/(@var{x} - @var{c})}, with dependent variable @var{x}, and the function
is to be integrated over the interval @var{a} to @var{b}.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qawc} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                 'epsrel=1d-7);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
@end group
@group
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
      x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

       3 alpha                       3 alpha
       -------                       -------
          2            alpha/2          2          alpha/2
    2 4        atan(4 4       )   2 4        atan(4       )   alpha
  - --------------------------- - -------------------------)/2
              alpha                        alpha
           2 4      + 2                 2 4      + 2
@end group
@group
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawf (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Function} quad_qawf (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

Calculates a Fourier cosine or Fourier sine transform on a semi-infinite interval
using the Quadpack QAWF function.
The same approach as in @code{quad_qawo} is applied on successive finite intervals,
and convergence acceleration by means of the Epsilon algorithm (Wynn, 1956)
is applied to the series of the integral contributions.

@code{quad_qawf} computes the integral

@ifnottex
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsabs
Desired absolute error of approximation.  Default is 1d-10.
@item limit
Size of internal work array.  (@var{limit} - @var{limlst})/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table

@code{quad_qawf} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
@end group
@group
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
@end group
@group
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawo (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Function} quad_qawo (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

Integration of
@ifnottex
@math{cos (omega x) f(x)}
@end ifnottex
@tex
$\cos \left(\omega \, x\right) \, f\left(x\right)$
@end tex
or
@ifnottex
@math{sin (omega x) f(x)}
@end ifnottex
@tex
$\sin \left(\omega \, x\right) \, f\left(x\right)$
@end tex
over a finite interval,
where
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
is a constant.
The rule evaluation component is based on the modified Clenshaw-Curtis technique.
@code{quad_qawo} applies adaptive subdivision with extrapolation, similar to @code{quad_qags}.

@code{quad_qawo} computes the integral using the Quadpack QAWO
routine:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{trig}:

@table @code
@item cos
@ifnottex
@math{w(x) = cos (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \cos \left(\omega \, x\right)$
@end tex
@item sin
@ifnottex
@math{w(x) = sin (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \sin \left(\omega \, x\right)$
@end tex
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit}/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table

@code{quad_qawo} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
@end group
@group
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
      x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
@end group
@group
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qaws (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qaws (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of @math{w(x) f(x)} over a finite interval,
where @math{w(x)} is a certain algebraic or logarithmic function.
A globally adaptive subdivision strategy is applied,
with modified Clenshaw-Curtis integration on the subintervals which contain the endpoints
of the interval of integration.

@code{quad_qaws} computes the integral using the Quadpack QAWS
routine:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{wfun}:

@table @code
@item 1
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta$
@end tex
@item 2
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right)$
@end tex
@item 3
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(b - x\right)$
@end tex
@item 4
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit}is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qaws} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                 'epsabs=1d-9);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
@end group
@group
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
@end group
@group
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Differentialgleichungen, Integration, , Analysis
@section Differentialgleichungen

@c -----------------------------------------------------------------------------
@menu
* Einf@"uhrung in Differentialgleichungen::  
* Funktionen und Variablen f@"ur Differentialgleichungen::  
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Differentialgleichungen, Funktionen und Variablen f@"ur Differentialgleichungen, Differentialgleichungen, Analysis
@subsection Einf@"uhrung in Differentialgleichungen

This section describes the functions available in Maxima to obtain
analytic solutions for some specific types of first and second-order
equations. To obtain a numerical solution for a system of differential
equations, see the additional package @code{dynamics}. For graphical
representations in phase space, see the additional package
@code{plotdf}.


@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Differentialgleichungen,  , Einf@"uhrung in Differentialgleichungen, Differentialgleichungen
@subsection Funktionen und Variablen f@"ur Differentialgleichungen

@c -----------------------------------------------------------------------------
@deffn {Function} bc2 (@var{solution}, @var{xval1}, @var{yval1}, @var{xval2}, @var{yval2})
Solves a boundary value problem for a second order differential equation.
Here: @var{solution} is a general solution to the equation, as found by
@code{ode2}; @var{xval1} specifies the value of the independent variable
in a first point, in the form @code{@var{x} = @var{x1}}, and @var{yval1}
gives the value of the dependent variable in that point, in the form
@code{@var{y} = @var{y1}}. The expressions @var{xval2} and @var{yval2}
give the values for these variables at a second point, using the same
form.

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} desolve (@var{eqn}, @var{x})
@deffnx {Function} desolve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
The function @code{desolve} solves systems of linear ordinary
differential equations using Laplace transform.  Here the @var{eqn}'s
are differential equations in the dependent variables @var{x_1}, ...,
@var{x_n}.  The functional dependence of @var{x_1}, ..., @var{x_n} on an
independent variable, for instance @var{x}, must be explicitly indicated
in the variables and its derivatives. For example, this would not be the
correct way to define two equations:

@example
eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);
@end example

The correct way would be:

@example
eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);
@end example

The call to the function @code{desolve} would then be
@example
desolve([eqn_1, eqn_2], [f(x),g(x)]);
@end example

If initial conditions at @code{x=0} are known, they can be supplied before
calling @code{desolve} by using @code{atvalue}.

@c ===beg===
@c 'diff(f(x),x)='diff(g(x),x)+sin(x);
@c 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
@c atvalue('diff(g(x),x),x=0,a);
@c atvalue(f(x),x=0,1);
@c desolve([%o1,%o2],[f(x),g(x)]);
@c [%o1,%o2],%o5,diff;
@c ===end===
@example
(%i1) @b{@t{'diff(f(x),x)='diff(g(x),x)+sin(x);}}
                 d           d
(%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                 dx          dx
(%i2) @b{@t{'diff(g(x),x,2)='diff(f(x),x)-cos(x);}}
                  2
                 d            d
(%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                   2          dx
                 dx
(%i3) @b{@t{atvalue('diff(g(x),x),x=0,a);}}
(%o3)                           a
(%i4) @b{@t{atvalue(f(x),x=0,1);}}
(%o4)                           1
(%i5) @b{@t{desolve([%o1,%o2],[f(x),g(x)]);}}
                  x
(%o5) [f(x) = a %e  - a + 1, g(x) = 

                                                x
                                   cos(x) + a %e  - a + g(0) - 1]
(%i6) @b{@t{[%o1,%o2],%o5,diff;}}
             x       x      x                x
(%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

@end example

If @code{desolve} cannot obtain a solution, it returns @code{false}.

@c @opencatbox
@c @category{Differential equations} @category{Laplace transform}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ic1 (@var{solution}, @var{xval}, @var{yval})

Solves initial value problems for first order differential equations.
Here @var{solution} is a general solution to the equation, as found by
@code{ode2}, @var{xval} gives an initial value for the independent
variable in the form @code{@var{x} = @var{x0}}, and @var{yval} gives the
initial value for the dependent variable in the form @code{@var{y} =
@var{y0}}.

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ic2 (@var{solution}, @var{xval}, @var{yval}, @var{dval})

Solves initial value problems for second-order differential equations.
Here @var{solution} is a general solution to the equation, as found by
@code{ode2}, @var{xval} gives the initial value for the independent
variable in the form @code{@var{x} = @var{x0}}, @var{yval} gives the
initial value of the dependent variable in the form @code{@var{y} =
@var{y0}}, and @var{dval} gives the initial value for the first
derivative of the dependent variable with respect to independent
variable, in the form @code{diff(@var{y},@var{x}) = @var{dy0}}
(@code{diff} does not have to be quoted).

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ode2 (@var{eqn}, @var{dvar}, @var{ivar})

The function @code{ode2} solves an ordinary differential equation (ODE)
of first or second order. It takes three arguments: an ODE given by
@var{eqn}, the dependent variable @var{dvar}, and the independent
variable @var{ivar}. When successful, it returns either an explicit or
implicit solution for the dependent variable. @code{%c} is used to
represent the integration constant in the case of first-order equations,
and @code{%k1} and @code{%k2} the constants for second-order
equations. The dependence of the dependent variable on the independent
variable does not have to be written explicitly, as in the case of
@code{desolve}, but the independent variable must always be given as the
third argument.

If @code{ode2} cannot obtain a solution for whatever reason, it returns
@code{false}, after perhaps printing out an error message. The methods
implemented for first order equations in the order in which they are
tested are: linear, separable, exact - perhaps requiring an integrating
factor, homogeneous, Bernoulli's equation, and a generalized homogeneous
method. The types of second-order equations which can be solved are:
constant coefficients, exact, linear homogeneous with non-constant
coefficients which can be transformed to constant coefficients, the
Euler or equi-dimensional equation, equations solvable by the method of
variation of parameters, and equations which are free of either the
independent or of the dependent variable so that they can be reduced to
two first order linear equations to be solved sequentially.

In the course of solving ODE's, several variables are set purely for
informational purposes: @code{method} denotes the method of solution
used (e.g., @code{linear}), @code{intfactor} denotes any integrating
factor used, @code{odeindex} denotes the index for Bernoulli's method or
for the generalized homogeneous method, and @code{yp} denotes the
particular solution for the variation of parameters technique.

In order to solve initial value problems (IVP) functions @code{ic1} and
@code{ic2} are available for first and second order equations, and to
solve second-order boundary value problems (BVP) the function @code{bc2}
can be used.

Example:

@c ===beg===
@c x^2*'diff(y,x) + 3*y*x = sin(x)/x;
@c ode2(%,y,x);
@c ic1(%o2,x=%pi,y=0);
@c 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
@c ode2(%,y,x);
@c ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
@c bc2(%o5,x=0,y=1,x=1,y=3);
@c ===end===
@example
(%i1) @b{@t{x^2*'diff(y,x) + 3*y*x = sin(x)/x;}}
                      2 dy           sin(x)
(%o1)                x  -- + 3 x y = ------
                        dx             x
(%i2) @b{@t{ode2(%,y,x);}}
                             %c - cos(x)
(%o2)                    y = -----------
                                  3
                                 x
(%i3) @b{@t{ic1(%o2,x=%pi,y=0);}}
                              cos(x) + 1
(%o3)                   y = - ----------
                                   3
                                  x
(%i4) @b{@t{'diff(y,x,2) + y*'diff(y,x)^3 = 0;}}
                         2
                        d y      dy 3
(%o4)                   --- + y (--)  = 0
                          2      dx
                        dx
(%i5) @b{@t{ode2(%,y,x);}}
                      3
                     y  + 6 %k1 y
(%o5)                ------------ = x + %k2
                          6
(%i6) @b{@t{ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));}}
                             3
                          2 y  - 3 y
(%o6)                   - ---------- = x
                              6
(%i7) @b{@t{bc2(%o5,x=0,y=1,x=1,y=3);}}
                         3
                        y  - 10 y       3
(%o7)                   --------- = x - -
                            6           2

@end example

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c --- End of file Calculus.de.texi --------------------------------------------

