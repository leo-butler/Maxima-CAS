@c -----------------------------------------------------------------------------
@c File        : Calculus.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Translation : Dr. Dieter Kaiser
@c Date        : 06.11.2010
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Funktionen und Variablen f@"ur Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Grenzwerte, Funktionen und Variablen der Differentiation, Analysis
@section Funktionen und Variablen f@"ur Grenzwerte

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{lhospitallim}
@defvr {Optionsvariable} lhospitallim
Standardwert: 4

@c @code{lhospitallim} is the maximum number of times L'Hospital's rule is used 
@c in @code{limit}.  This prevents infinite looping in cases like
@c @code{limit (cot(x)/csc(x), x, 0)}.

@code{lhospitallim} enth@"alt die maximale Zahl an Iterationen f@"ur die die 
L'Hospitalsche Regel von der Funktion @code{limit} angewendet wird. Damit
wird verhindert, dass @code{limit} in eine unendliche Schleife f@"ur Grenzwerte
wie @code{limit(cot(x)/csc(x), x, 0)} ger@"at.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{limit}
@deffn  {Funktion} limit (@var{expr}, @var{x}, @var{val}, @var{dir})
@deffnx {Funktion} limit (@var{expr}, @var{x}, @var{val})
@deffnx {Funktion} limit (@var{expr})

@c Computes the limit of @var{expr} as the real variable @var{x} approaches the 
@c value @var{val} from the direction @var{dir}.  @var{dir} may have the value 
@c @code{plus} for a limit from above, @code{minus} for a limit from below, or
@c may be omitted (implying a two-sided limit is to be computed).

Berechnet den Grenzwert des Ausdrucks @var{expr}, wenn die reelle Variable
@var{x} gegen den Wert @var{val} in Richtung @var{dir} geht. Die Richtung
@var{dir} kann die Werte @var{plus} f@"ur einen Grenzwert von oben und 
@var{minus} f@"ur einen Grenzwert von unten haben. F@"ur einen zweiseitigen 
Grenzwert braucht die Richtung nicht angegeben werden.

@c @code{limit} uses the following special symbols: @code{inf} (positive 
@c infinity) and @code{minf} (negative infinity).  On output it may also use 
@c @code{und} (undefined), @code{ind} (indefinite but bounded) and 
@c @code{infinity} (complex infinity).

@code{limit} nutzt die folgenden speziellen Symbole: @code{inf} (positiv 
unendlich) und @code{minf} (negativ unendlich). In der Ausgabe k@"onnen die
Symbole @code{und} (nicht definiert), @code{ind} (unbestimmt) und 
@code{infinity} (komplex unendlich) auftreten.

@c @code{infinity} (complex infinity) is returned when the limit of
@c the absolute value of the expression is positive infinity, but
@c the limit of the expression itself is not positive infinity or
@c negative infinity.  This includes cases where the limit of the
@c complex argument is a constant, as in @code{limit(log(x), x, minf)}, 
@c cases where the complex argument oscillates, as in
@c @code{limit((-2)^x, x, inf)}, and cases where the complex
@c argument is different for either side of a two-sided limit, as in
@c @code{limit(1/x, x, 0)} and @code{limit(log(x), x, 0)}.

@code{infinity} (komplex unendlich) wird zur@"uckgegeben, wenn der Grenzwert
des Betrags des Ausdrucks positiv unendlich ist, aber der Grenzwert des
Ausdrucks selbst weder positive noch negativ unendlich ist. Dies schlie@ss{}t 
F@"alle ein, wo der Grenzwert eines komplexen Arguments eine Konstante ist, wie
zum Beispiel in @code{limit(log(x),x, minf)}, F@"alle in denen das komplexe
Argument oszilliert, wie zum Beispiel in @code{limit((-2)^x, x, inf)} und 
F@"alle, wo das komlexe Argument f@"ur die beiden Seiten des Grenzwertes 
verschieden ist, wie zum Beispiel in @code{limit(1/x, x, 0)} und 
@code{limit(log(x), x, 0)}.

@c @code{lhospitallim} is the maximum number of times L'Hospital's rule
@c is used in @code{limit}.  This prevents infinite looping in cases like
@c @code{limit (cot(x)/csc(x), x, 0)}.

@code{lhospitallim} enth@"alt die maximale Zahl an Iterationen f@"ur die die 
L'Hospitalsche Regel von der Funktion @code{limit} angewendet wird. Damit
wird verhindert, dass @code{limit} in eine unendliche Schleife f@"ur Grenzwerte
wie @code{limit(cot(x)/csc(x), x, 0)} ger@"at.

@c @code{tlimswitch} when true will allow the @code{limit} command to use
@c Taylor series expansion when necessary.

Hat @code{tlimswitch} den Wert @code{true}, nutzt die Funktion @code{limit} eine
Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen Methoden bestimmt
werden kann.

@c @code{limsubst} prevents @code{limit} from attempting substitutions on
@c unknown forms.  This is to avoid bugs like @code{limit (f(n)/f(n+1), n, inf)}
@c giving 1.  Setting @code{limsubst} to @code{true} will allow such
@c substitutions.

Die Optionsvariable @code{limsubst} verhindet Substitution der Funktion 
@code{limit} f@"ur unbekannte Ausdr@"ucke. Dies vermeidet Fehler wie zum 
Beispiel ein Ergebnis von 1 f@"ur den Grenzwert 
@code{limit (f(n)/f(n+1), n, inf)}. Erh@"alt @code{limsubst} den Wert 
@code{true}, sind solche Substitution gestattet.

@c @code{limit} with one argument is often called upon to simplify constant 
@c expressions, for example, @code{limit (inf-1)}.

@code{limit} kann mit einem Argument aufgerufen werden, um konstante Ausdr@"ucke
zu vereinfachen. Zum Beispiel @code{limit (inf-1)}.

@c MERGE EXAMPLES INTO THIS FILE
@c @code{example (limit)} displays some examples.

Das Kommando @code{example(limit)} zeigt einige Beispiele.

@c For the method see Wang, P., "Evaluation of Definite Integrals by Symbolic
@c Manipulation", Ph.D. thesis, MAC TR-92, October 1971.

Der Algorithmus ist in der folgenden Arbeit beschrieben: Wang, P., "Evaluation 
of Definite Integrals by Symbolic Manipulation", Ph.D. thesis, MAC TR-92, 
October 1971.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{limsubst}
@defvr {Optionsvariable} limsubst
Standardwert: @code{false}

@c Prevents @code{limit} from attempting substitutions on unknown forms.  This
@c is to avoid bugs like @code{limit (f(n)/f(n+1), n, inf)} giving 1.  Setting
@c @code{limsubst} to @code{true} will allow such substitutions.

Die Optionsvariable @code{limsubst} verhindet Substitution der Funktion 
@code{limit} f@"ur unbekannte Ausdr@"ucke. Dies vermeidet Fehler wie zum 
Beispiel ein Ergebnis von 1 f@"ur den Grenzwert 
@code{limit (f(n)/f(n+1), n, inf)}. Erh@"alt @code{limsubst} den Wert 
@code{true}, sind solche Substitution gestattet.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{tlimit}
@deffn  {Funktion} tlimit (@var{expr}, @var{x}, @var{val}, @var{dir})
@deffnx {Funktion} tlimit (@var{expr}, @var{x}, @var{val})
@deffnx {Funktion} tlimit (@var{expr})

@c Take the limit of the Taylor series expansion of @code{expr} in @code{x}
@c at @code{val} from direction @code{dir}.

Nimmt den Grenzwert der Taylor-Reihenwicklung des Ausdrucks @code{expr}, wenn
die Variable @var{x} gegen den Wert @code{val} aus der Richtung @var{dir} geht.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{tlimswitch}
@defvr {Optionsvariable} tlimswitch
Standardwert: @code{true}

@c When @code{tlimswitch} is @code{true}, the @code{limit} command will use a 
@c Taylor series expansion if the limit of the input expression cannot be 
@c computed directly. This allows evaluation of limits such as 
@c @code{limit(x/(x-1)-1/log(x),x,1,plus)}. When @code{tlimswitch} is 
@c @code{false} and the limit of input expression cannot be computed directly, 
@c @code{limit} will return an unevaluated limit expression.

Hat @code{tlimswitch} den Wert @code{true}, nutzt die Funktion @code{limit} eine
Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen Methoden bestimmt
werden kann. Dies erlaubt die Bestimmung von Grenzwerten wie
@code{limit(x/(x-1)-1/log(x),x,1,plus)}.

@c @opencatbox
@c @category{Limits}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Differentiation, Integration, Funktionen und Variablen f@"ur Grenzwerte, Analysis
@section Funktionen und Variablen der Differentiation

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{at}
@deffn  {Funktion} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Funktion} at (@var{expr}, @var{eqn})

@c Evaluates the expression @var{expr} with the variables assuming the values as
@c specified for them in the list of equations @code{[@var{eqn_1}, ..., 
@c @var{eqn_n}]} or the single equation @var{eqn}.

Wertet den Ausdruck @var{expr} aus, wobei dessen Variablen die Werte annehmen, 
die in der Liste der Gleichungen @code{[@var{eqn_1}, ..., @var{eqn_n}]} 
oder in der einzelnen Gleichung @var{eqn} angegeben sind.

@c If a subexpression depends on any of the variables for which a value is 
@c specified but there is no atvalue specified and it can't be otherwise 
@c evaluated, then a noun form of the @code{at} is returned which displays in a 
@c two-dimensional form.

Wenn ein Teilausdruck von einer Variablen abh@"angt, f@"ur die ein Wert 
angegeben ist, aber kein @code{atvalue}, und er auch sonst nicht ausgewertet 
werden kann, dann wird von @code{at} eine Substantivform zur@"uckgegeben, 
dargestellt in einer zweidimensionalen Form.

@c @code{at} carries out multiple substitutions in series, not parallel.

@code{at} f@"uhrt mehrfache Ersetzungen nacheinander und nicht nicht parallel 
durch.

@c See also @code{atvalue}. For other functions which carry out substitutions,
@c see also @code{subst} and @code{ev}.

Siehe auch @code{atvalue}. F@"ur andere Funktionen, die Ersetzungen 
durchf@"uhren, siehe weiterhin @code{subst} und @code{ev}.

Beispiele:

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@c @opencatbox
@c @category{Auswertung} @category{Differentialgleichungen}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{antid}
@deffn {Funktion} antid (@var{expr}, @var{x}, @var{u(x)})

@c Returns a two-element list, such that an antiderivative of @var{expr} with 
@c respect to @var{x} can be constructed from the list. The expression 
@c @var{expr} may contain an unknown function @var{u} and its derivatives.

Gibt eine Liste mit zwei Elementen zur@"uck aus denen die Stammfunktion des 
Ausdrucks @var{expr} mit der Variablen @var{x} konstruiert werden kann. Der
Ausdruck @var{expr} kann eine unbekannte Funktion @var{u} und deren Ableitungen
enthalten.

@c Let @var{L}, a list of two elements, be the return value of @code{antid}.
@c Then @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})} is an 
@c antiderivative of @var{expr} with respect to @var{x}.

Ist @var{L} das Ergebnis der Funktion @code{antid}, dann ist der Ausdruck
@code{@var{L}[1]+ 'integrate(@var{L}[2], @var{x})} der gesuchte Stammfunktion
des Ausdrucks @var{expr} mit der Variablen @var{x}.

@c When @code{antid} succeeds entirely, the second element of the return value 
@c is zero. Otherwise, the second element is nonzero, and the first element is 
@c nonzero or zero. If @code{antid} cannot make any progress, the first element 
@c is zero and the second nonzero.

Kann @code{antid} die Stammfunktion vollst@"andig bestimmen, ist das zweite
Element der Liste Null. Hat @code{antid} keinerlei Erfolg, ist das erste 
Element der Liste Null. In anderen F@"allen enth@"alt das erste Elemente den
integrierbaren Anteil des Ausdrucks @var{expr} und das zweite Element den nicht
integrierbaren Anteil des Ausdrucks.

@c @code{load ("antid")} loads this function. The @code{antid} package also 
@c defines the functions @code{nonzeroandfreeof} and @code{linear}.

Mit dem Kommando @code{load(antid)} wird die Funktion geladen.

@c @code{antid} is related to @code{antidiff} as follows. Let @var{L}, a list of
@c two elements, be the return value of @code{antid}. Then the return value of 
@c @code{antidiff} is equal to @code{@var{L}[1]+'integrate(@var{L}[2], @var{x})}
@c where @var{x} is the variable of integration.

@code{antid} steht in folgender Beziehung zur Funktion @code{antidiff}: Ist 
@var{L} die Liste mit den Ergebnissen der Funktion @code{antid}, dann hat die
Funktion @code{antidiff} das Ergebnis @code{@var{L}[1] + 'integrate(@var{L}[2], 
@var{x})} mit @var{x} als der Variablen des Ausdrucks @var{expr}.

Beispiele:

@c ===beg===
@c load ("antid")$
@c expr: exp (z(x)) * diff (z(x), x) * y(x);
@c a1: antid (expr, x, z(x));
@c a2: antidiff (expr, x, z(x));
@c a2 - (first (a1) + 'integrate (second (a1), x));
@c antid (expr, x, y(x));
@c antidiff (expr, x, y(x));
@c ===end===
@example
(%i1) load ("antid")$
(%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                            z(x)  d
(%o2)                y(x) %e     (-- (z(x)))
                                  dx
(%i3) a1: antid (expr, x, z(x));
                       z(x)      z(x)  d
(%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                       dx
(%i4) a2: antidiff (expr, x, z(x));
                            /
                     z(x)   [   z(x)  d
(%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                            ]         dx
                            /
(%i5) a2 - (first (a1) + 'integrate (second (a1), x));
(%o5)                           0
(%i6) antid (expr, x, y(x));
                             z(x)  d
(%o6)             [0, y(x) %e     (-- (z(x)))]
                                   dx
(%i7) antidiff (expr, x, y(x));
                  /
                  [        z(x)  d
(%o7)             I y(x) %e     (-- (z(x))) dx
                  ]              dx
                  /
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{antidiff}
@deffn {Funktion} antidiff (@var{expr}, @var{x}, @var{u}(@var{x}))

@c Returns an antiderivative of @var{expr} with respect to @var{x}. The 
@c expression @var{expr} may contain an unknown function @var{u} and its 
@c derivatives.

Gibt die Stammfunktion des Ausdrucks @var{expr} mit der Variablen @var{x} 
zur@"uck. Der Ausdruck @var{expr} kann eine unbekannte Funktion @var{u} und 
deren Ableitungen enthalten.

@c When @code{antidiff} succeeds entirely, the resulting expression is free of 
@c integral signs (that is, free of the @code{integrate} noun). Otherwise, 
@c @code{antidiff} returns an expression which is partly or entirely within an 
@c integral sign. If @code{antidiff} cannot make any progress, the return value 
@c is entirely within an integral sign.

Kann @code{antidiff} die Stammfunktion nicht oder nur teilweise bestimmen,
enth@"alt das Ergebnis das Integral des nicht bestimmbaren Anteils.

@c @code{load ("antid")} loads this function. The @code{antid} package also 
@c defines the functions @code{nonzeroandfreeof} and @code{linear}.

Mit dem Kommando @code{load(antid)} wird die Funktion geladen.

@c @code{antidiff} is related to @code{antid} as follows. Let @var{L}, a list of
@c two elements, be the return value of @code{antid}. Then the return value of 
@c @code{antidiff} is equal to @code{@var{L}[1] + 'integrate (@var{L}[2], 
@c @var{x})} where @var{x} is the variable of integration.

@code{antidiff} steht in folgender Beziehung zur Funktion @code{antid}: Ist 
@var{L} die Liste mit den Ergebnissen der Funktion @code{antid}, dann hat die
Funktion @code{antidiff} das Ergebnis @code{@var{L}[1] + 'integrate(@var{L}[2], 
@var{x})} mit @var{x} als der Variablen des Ausdrucks @var{expr}.

F@"ur Beispiele und weitere Ausf@"uhrungen siehe die Funktion @mrefdot{antid}

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c I SUSPECT THERE IS MORE TO BE SAID HERE

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{atomgrad}
@defvr {Eigenschaft} atomgrad

@c @code{atomgrad} is the atomic gradient property of an expression.
@c This property is assigned by @code{gradef}.

Wird f@"ur ein Symbol eine Ableitung mit der Funktion @code{gradef} definiert,
dann erh@"alt das Symbol die Eigenschaft @code{atomgrad}.

@c NEED EXAMPLE HERE
@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end defvr

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{atvalue}
@deffn  {Funktion} atvalue (@var{expr}, [@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}], @var{c})
@deffnx {Funktion} atvalue (@var{expr}, @var{x_1} = @var{a_1}, @var{c})

@c Assigns the value @var{c} to @var{expr} at the point @code{@var{x}=@var{a}}.
@c Typically boundary values are established by this mechanism.

Dem Ausdruck @var{expr} wird der Wert @var{c} am Punkt @code{@var{x} = @var{a}}
zugewiesen. Typischerweise werden Randwerte mit der Funktion @code{atvalue}
definiert.

@c @var{expr} is a function evaluation, @code{@var{f}(@var{x_1},...,@var{x_m})},
@c or a derivative, @code{diff (@var{f}(@var{x_1}, ..., @var{x_m}), @var{x_1}, 
@c @var{n_1}, ..., @var{x_n}, @var{n_m})}
@c HMM, WHAT IS THIS NEXT PHRASE GETTING AT ??
@c DOES IT INTEND TO IMPLY THAT IMPLICIT DEPENDENCIES ARE IGNORED ??
@c in which the function arguments explicitly appear. @var{n_i} is the order of
@c differentiation with respect to @var{x_i}.

Der Ausdruck @var{expr} ist entweder eine Funktion @code{@var{f}(@var{x_1}, ..., 
@var{x_m})} oder die Ableitung einer Funktion @code{diff(@var{f}(@var{x_1}, ...,
@var{x_m}), @var{x_1}, @var{n_1}, ..., @var{x_n}, @var{n_m})}. Die Argumente
m@"ussen explizit auftreten. @var{n_i} ist die Ordnung der Ableitung bez@"uglich
der Variablen @var{x_i}.

@c The point at which the atvalue is established is given by the list of 
@c equations @code{[@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}]}. If 
@c there is a single variable @var{x_1}, the sole equation may be given without 
@c enclosing it in a list.

Die Randwerte werden durch die Liste @code{[@var{x_1} = @var{a_1}, ..., 
@var{x_m} = @var{a_m}]} definiert. Eine einzelne Gleichung muss nicht als Liste 
angegeben werden.

@c @code{printprops ([@var{f_1}, @var{f_2}, ...], atvalue)} displays the 
@c atvalues of the functions @code{@var{f_1}, @var{f_2}, ...} as specified by 
@c calls to @code{atvalue}. @code{printprops (@var{f}, atvalue)} displays the 
@c atvalues of one function @var{f}. @code{printprops (all, atvalue)} displays 
@c the atvalues of all functions for which atvalues are defined.

@code{printprops([@var{f_1}, @var{f_2}, ...], atvalue)} zeigt die Randwerte der
Funktionen @code{@var{f_1}, @var{f_2}, ...} wie sie mit der Funktion 
@code{atvalue} definiert wurden. @code{printprops (@var{f}, atvalue)} zeigt
nur die Randwerte f@"ur die Funktion @var{f}. @code{printprops (all, atvalue)}
zeigt die Randwerte aller Funktionen.

@c The symbols @code{@@1}, @code{@@2}, ... represent the variables @var{x_1}, 
@c @var{x_2}, ... when atvalues are displayed.

Die Symbole @code{@@1}, @code{@@2}, ... repr@"asentieren die Variablen 
@var{x_1}, @var{x_2}, ..., wenn die Randwerte angezeigt werden.

@c @code{atvalue} evaluates its arguments. @code{atvalue} returns @var{c}, the 
@c atvalue.

@code{atvalue} wertet die Argumente aus. @code{atvalue} gibt den Randwert
@var{c} zur@"uck.

Beispiele:

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x,y)^2 - u(x,y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@c @opencatbox
@c @category{Differential equations} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c LOOKS LIKE cartan IS THE NAME OF A PACKAGE AND NOT A FUNCTION OR VARIABLE
@c PROBABLY SHOULD SPLIT OUT cartan AND ITS CONTENTS INTO ITS OWN TEXINFO FILE
@c ext_diff AND lie_diff NOT DOCUMENTED (OTHER THAN HERE)

@c -----------------------------------------------------------------------------
@deffn {Packet} cartan

The exterior calculus of differential forms is a basic tool of differential 
geometry developed by Elie Cartan and has important applications in the theory 
of partial differential equations. The @code{cartan} package implements the 
functions @code{ext_diff} and @code{lie_diff}, along with the operators 
@code{~} (wedge product) and @code{|} (contraction of a form with a vector.)
Type @code{demo (tensor)} to see a brief description of these commands along 
with examples.

@code{cartan} was implemented by F.B. Estabrook and H.D. Wahlquist.

@c @opencatbox
@c @category{Differential geometry}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{del}
@deffn {Funktion} del (@var{x})

@c @code{del(@var{x})} represents the differential of the variable @math{x}.

@code{del(@var{x})} repr@"asentiert das Differential der Variablen @var{x}.

@c @code{diff} returns an expression containing @code{del} if an independent 
@c variable is not specified. In this case, the return value is the so-called 
@c "total differential".

@code{diff} gibt Ausdr@"ucke zur@"uck, die Differentiale enthalten, wenn keine 
Variablen angegeben sind, nach denen abgeleitet werden soll. In diesem Fall
gibt @code{diff} das totale Differential zur@"uck. 

Beispiele:

@c ===beg===
@c diff (log (x));
@c diff (exp (x*y));
@c diff (x*y*z);
@c ===end===
@example
(%i1) diff (log (x));
                             del(x)
(%o1)                        ------
                               x
(%i2) diff (exp (x*y));
                     x y              x y
(%o2)            x %e    del(y) + y %e    del(x)
(%i3) diff (x*y*z);
(%o3)         x y del(z) + x z del(y) + y z del(x)
@end example

@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{delta}
@deffn {Funktion} delta (@var{t})

@c The Dirac Delta function.

Die Diracsche Delta-Funktion.

@c Currently only @code{laplace} knows about the @code{delta} function.

Maxima kennt die Delta-Funktion nur im Zusammenhang mit 
Laplace-Transformationen. Siehe @mrefdot{laplace}

Beispiel:

@c TODO: DAS FOLGENDE BEISPIEL GIBT EIN ANDERES ERGEBNIS. WARUM? EIN BUG?

@example
(%i1) laplace (delta (t - a) * sin(b*t), t, s);
Is  a  positive, negative, or zero?

p;
                                   - a s
(%o1)                   sin(a b) %e
@end example

@c @opencatbox
@c @category{Mathematical functions} @category{Laplace transform}
@c @closecatbox
@end deffn

@c --- 19.11.2010 DK -----------------------------------------------------------
@anchor{dependencies}
@defvr {Systemvariable} dependencies
Standardwert: @code{[]}

@c @code{dependencies} is the list of atoms which have functional dependencies, 
@c assigned by @code{depends} or @code{gradef}. The @code{dependencies} list is 
@c cumulative: each call to @code{depends} or @code{gradef} appends additional 
@c items.
@c See @code{depends} and @code{gradef}.

@code{dependencies} ist eine Liste der Symbole, f@"ur die eine Abh@"angigkeit 
mit den Funktionen @code{depends} oder @code{gradef} definiert wurde. Siehe
@mref{depends} und @mrefdot{gradef}

@c @opencatbox
@c @category{Declarations and inferences} @category{Global variables}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{depends}
@deffn {Funktion} depends (@var{f_1}, @var{x_1}, ..., @var{f_n}, @var{x_n})

@c Declares functional dependencies among variables for the purpose of computing 
@c derivatives. In the absence of declared dependence, @code{diff(f, x)} yields 
@c zero. If @code{depends (f, x)} is declared, @code{diff(f, x)} yields a 
@c symbolic derivative (that is, a @code{diff} noun).

Definiert die Abh@"angigkeit einer Funktion @var{f} von einer Variablen @var{x}. 
Ist keine Abh@"angigkeit definiert, dann hat die Ableitung @code{diff(f, x)} das 
Ergebnis Null. Wird mit dem Kommando @code{depends(f, x)} definiert, dass die
Funktion @var{f} von der Variablen @var{x} abh@"angt, dann ist das Ergebnis der
Ableitung die Substantivform @code{'diff(f,x,1)}.

@c Each argument @var{f_1}, @var{x_1}, etc., can be the name of a variable or 
@c array, or a list of names. Every element of @var{f_i} (perhaps just a single 
@c element) is declared to depend on every element of @var{x_i} (perhaps just a 
@c single element). If some @var{f_i} is the name of an array or contains the 
@c name of an array, all elements of the array depend on @var{x_i}.

Jedes Argument @var{f_1}, @var{x_1}, ... kann der Name einer Variablen, eines
Arrays oder eine Liste mit Namen sein. Jedes Symbol @var{f_i} h@"angt ab von
den Symbolen der Liste @var{x_i}. Ist eines der Symbole @var{f_i} der Name
eines Arrays, dann h@"angen alle Elemente des Arrays von @var{x_i} ab.

@c @code{diff} recognizes indirect dependencies established by @code{depends}
@c and applies the chain rule in these cases.

@code{diff} erkennt indirekte Abh@"angigkeiten und wendet f@"ur diesen Fall
die Kettenregel an.

@c @code{remove(@var{f}, dependency)} removes all dependencies declared for 
@c @var{f}.

@code{remove(@var{f}, dependency)} entfernt alle Abh@"angigkeiten, die f@"ur
@var{f} definiert wurden.

@c @code{depends} returns a list of the dependencies established. The 
@c dependencies are appended to the global variable @code{dependencies}. 
@c @code{depends} evaluates its arguments.

@code{depends} gibt eine Liste der Abh@"angigkeiten zur@"uck. Die 
Abh@"angigkeiten werden in die Informationsliste @code{dependencies} 
eingetragen. @code{depends} wertet die Argumente aus.

@c @code{diff} is the only Maxima command which recognizes dependencies 
@c established by @code{depends}. Other functions (@code{integrate}, 
@c @code{laplace}, etc.) only recognize dependencies explicitly represented by 
@c their arguments. For example, @code{integrate} does not recognize the 
@c dependence of @code{f} on @code{x} unless explicitly represented as 
@c @code{integrate (f(x), x)}.

Die Funktion @code{diff} ist die einzige Maxima-Funktion, die Abh@"angigkeiten
erkennt, die mit @code{depends} definiert wurden. Andere Funktionen wie
@code{integrate} oder @code{laplace} erkennen eine Abh@"angigkeiten die mit der
@code{depends} definiert wurden. F@"ur diese Funktionen m@"ussen die 
Abh@"angigkeiten explizit angegeben werden, zum Beispiel 
@code{integrate(f(x), x)}.

Beispiele:

@c ===beg===
@c depends ([f, g], x);
@c depends ([r, s], [u, v, w]);
@c depends (u, t);
@c dependencies;
@c diff (r.s, u);
@c ===end===
@example
(%i1) depends ([f, g], x);
(%o1)                     [f(x), g(x)]
(%i2) depends ([r, s], [u, v, w]);
(%o2)               [r(u, v, w), s(u, v, w)]
(%i3) depends (u, t);
(%o3)                        [u(t)]
(%i4) dependencies;
(%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
(%i5) diff (r.s, u);
                         dr           ds
(%o5)                    -- . s + r . --
                         du           du
@end example

@c ===beg==
@c diff (r.s, t);
@c ===end===
@example
(%i6) diff (r.s, t);
                      dr du           ds du
(%o6)                 -- -- . s + r . -- --
                      du dt           du dt
@end example

@c ===beg===
@c remove (r, dependency);
@c diff (r.s, t);
@c ===end===
@example
(%i7) remove (r, dependency);
(%o7)                         done
(%i8) diff (r.s, t);
                                ds du
(%o8)                       r . -- --
                                du dt
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{derivabbrev}
@defvr {Optionsvariable} derivabbrev
Standardwert: @code{false}

@c When @code{derivabbrev} is @code{true}, symbolic derivatives (that is, 
@c @code{diff} nouns) are displayed as subscripts. Otherwise, derivatives are 
@c displayed in the Leibniz notation @code{dy/dx}.

Hat @code{derivabbrev} den Wert @code{true}, werden symbolische Ableitungen
mit einem tiefgestelltem Index angezeigt. Ansonsten werden Ableitungen als
@code{dy/dy} angezeigt.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Differential calculus} @category{Global flags}
@c @closecatbox
@end defvr

@c SEEMS LIKE THIS STATEMENT COULD BE LESS CLUMSY

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{derivdegree}
@deffn {Funktion} derivdegree (@var{expr}, @var{y}, @var{x})

@c Returns the highest degree of the derivative of the dependent variable 
@c @var{y} with respect to the independent variable @var{x} occuring in 
@c @var{expr}.

Gibt die h@"ochste Ableitung des Arguments @var{y} in Bezug auf die Variable
@var{x} zur@"uck, die in dem Ausdruck @var{expr} enthalten ist.

Beispiel:

@c ===beg===
@c 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
@c derivdegree (%, y, x);
@c ===end===
@example
(%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                         3     2
                        d y   d y    2 dy
(%o1)                   --- + --- + x  --
                          3     2      dx
                        dz    dx
(%i2) derivdegree (%, y, x);
(%o2)                           2
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Expressions}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@deffn {Auswertungsschalter} derivlist (@var{var_1}, ..., @var{var_k})

@c Causes only differentiations with respect to the indicated variables, within
@c the @code{ev} command.

@code{derivlist} ist ein Auswertungsschalter f@"ur die Funktion @code{ev}. 
@code{ev} f@"uhrt nur die Ableitungen in Bezug auf die angegebenen Variablen
@var{var_1}, ..., @var{var_k} aus.

@c @opencatbox
@c @category{Differential calculus} @category{Evaluation}
@c @closecatbox
@end deffn

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{derivsubst}
@defvr {Optionsvariable} derivsubst
Standardwert: @code{false}

@c When @code{derivsubst} is @code{true}, a non-syntactic substitution such as
@c @code{subst (x, 'diff (y, t), 'diff (y, t, 2))} yields @code{'diff (x, t)}.

Hat @code{derivsubst} den Wert @code{true}, werden Substitutionen auch in 
Ausdr@"ucke mit Ableitungen ausgef@"uhrt. Zum Beispiel hat dann
@code{subst(x, 'diff(y, t), 'diff(y, t, 2))} das Ergebnis @code{'diff(x, t)}.

@c @opencatbox
@c @category{Differential calculus} @category{Expressions}
@c @closecatbox
@end defvr

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{diff}
@deffn  {Funktion} diff (@var{expr}, @var{x_1}, @var{n_1}, ..., @var{x_m}, @var{n_m})
@deffnx {Funktion} diff (@var{expr}, @var{x}, @var{n})
@deffnx {Funktion} diff (@var{expr}, @var{x})
@deffnx {Funktion} diff (@var{expr})

@c Returns the derivative or differential of @var{expr} with respect to some or 
@c all variables in @var{expr}.

Gibt die Ableitungen oder Differentiale des Ausdrucks @var{expr} in Bezug auf
alle oder einige der Variablen des Ausdrucks zur@"uck.

@c @code{diff (@var{expr}, @var{x}, @var{n})} returns the @var{n}'th derivative 
@c of @var{expr} with respect to @var{x}.

@code{diff(@var{expr}, @var{x}, @var{n})} gibt die n-te Ableitung des Ausdrucks
@var{expr} in Bezug auf die Variable @var{x} zur@"uck.

@c @code{diff (@var{expr}, @var{x_1}, @var{n_1}, ..., @var{x_m}, @var{n_m})}
@c returns the mixed partial derivative of @var{expr} with respect to @var{x_1},
@c ..., @var{x_m}. It is equivalent to @code{diff (... (diff (@var{expr}, 
@c @var{x_m}, @var{n_m}) ...), @var{x_1}, @var{n_1})}.

@code{diff(@var{expr}, @var{x_1}, @var{n_1}, ..., @var{x_m}, @var{n_m})} gibt
die partielle Ableitung des Ausdrucks @var{expr} in Bezug auf die Variablen
@var{x_1}, ..., @var{x_m} zur@"uck. Dies ist @"aquivalent zu @code{diff(... 
(diff(@var{expr}, @var{x_m}, @var{n_m}) ...), @var{x_1}, @var{n_1})}.

@c @code{diff (@var{expr}, @var{x})} returns the first derivative of @var{expr} 
@c with respect to the variable @var{x}.

@code{diff(@var{expr}, @var{x})} gibt die erste Ableitung des Ausdrucks 
@var{expr} in Bezug auf die Variable @var{x} zur@"uck.

@c @code{diff (@var{expr})} returns the total differential of @var{expr}, that 
@c is, the sum of the derivatives of @var{expr} with respect to each its 
@c variables times the differential @code{del} of each variable.
@c WHAT DOES THIS NEXT STATEMENT MEAN, EXACTLY ??
@c No further simplification of @code{del} is offered.

@code{diff(@var{expr})} gibt das totale Differential des Ausdrucks @var{expr}
zur@"uck. Siehe auch @mrefdot{del}

@c The noun form of @code{diff} is required in some contexts, such as stating a
@c differential equation. In these cases, @code{diff} may be quoted (as 
@c @code{'diff}) to yield the noun form instead of carrying out the 
@c differentiation.

Wenn die Ableitungen nicht ausgef@"uhrt werden sollen, kann der Quote-Operator
verwendet werden, um eine Substantivform der Ableitung zu erhalten.

@c When @code{derivabbrev} is @code{true}, derivatives are displayed as 
@c subscripts. Otherwise, derivatives are displayed in the Leibniz notation, 
@c @code{dy/dx}.

Hat @code{derivabbrev} den Wert @code{true}, werden symbolische Ableitungen
mit einem tiefgestelltem Index angezeigt. Ansonsten werden Ableitungen als
@code{dy/dy} angezeigt.

Beispiele:

@c ===beg===
@c diff (exp (f(x)), x, 2);
@c derivabbrev: true$
@c 'integrate (f(x, y), y, g(x), h(x));
@c diff (%, x);
@c ===end===
@example
(%i1) diff (exp (f(x)), x, 2);
                     2
              f(x)  d               f(x)  d         2
(%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                      2                   dx
                    dx
(%i2) derivabbrev: true$
(%i3) 'integrate (f(x, y), y, g(x), h(x));
                         h(x)
                        /
                        [
(%o3)                   I     f(x, y) dy
                        ]
                        /
                         g(x)
(%i4) diff (%, x);
       h(x)
      /
      [
(%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
      ]            x                     x                  x
      /
       g(x)
@end example

@c TODO: DAS FOLGENDE BETRIFFT TENSOREN UND SOLLTE IN DAS ENTSPRECHENDE
@c       KAPITEL VERSCHOBEN WERDEN!? DIE UEBERSETZUNG FEHLT.

For the tensor package, the following modifications have been incorporated:

@enumerate
@item
The derivatives of any indexed objects in @var{expr} will have the 
variables @var{x_i} appended as additional arguments.  Then all the 
derivative indices will be sorted.

@item
The @var{x_i} may be integers from 1 up to the value of the variable
@code{dimension} [default value: 4].  This will cause the differentiation to
be carried out with respect to the @var{x_i}'th member of the list 
@code{coordinates} which should be set to a list of the names of the 
coordinates, e.g., @code{[x, y, z, t]}. If @code{coordinates} is bound to an 
atomic variable, then that variable subscripted by @var{x_i} will be used for
the variable of differentiation.  This permits an array of coordinate names 
or subscripted names like @code{X[1]}, @code{X[2]}, ... to be used.  If 
@code{coordinates} has not been assigned a value, then the variables will be 
treated as in (1) above.
@end enumerate

@c NEED EXAMPLES FOR TENSOR STUFF
@c @opencatbox
@c @category{Differential calculus}
@c @closecatbox
@end deffn

@c MERGE THIS INTO @defun diff

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{flag_diff}
@defvr {Auswertungsschalter} diff

@c When @code{diff} is present as an @code{evflag} in call to @code{ev},
@c all differentiations indicated in @code{expr} are carried out.

@code{diff} ist ein Auswertungsschalter f@"ur die Funktion @code{ev}. Das 
Kommando @code{ev(expr), diff} bewirkt, dass alle Ableitungen ausgef@"uhrt 
werden, die im Ausdruck @var{expr} enhalten sind. Siehe auch die Funktion 
@mrefdot{ev}

@end defvr

@c TODO: IN DAS KAPITEL TENSOREN VERSCHIEBEN?!
@c       WIE UNTEN AUSGEFUEHRT FUNKTIONIERT DAS BEISPIEL NICHT. 

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{dscalar}
@deffn {Funktion} dscalar (@var{f})

@c Applies the scalar d'Alembertian to the scalar function @var{f}.
@c APPARENTLY dscalar DOESN'T EXIST IN THE CORE FILES ANYMORE
@c ctensor HAS THE ONLY DEFN I FOUND (OUTSIDE OF archive/)
@c @code{load ("ctensor")} loads this function.

Wendet den d'Alembert-Operator auf eine skalare Funktion @var{f} an. Der
d'Alembert-Operator ist die Verallgemeinerung des Gradienten auf den
vierdimensionalen Minkowski-Raum.

Das Kommando @code{load(ctensor)} l@"adt die Funktion.

@c FOLLOWING EXAMPLE DOESN'T WORK; I GET dscalar (field) ==> 0
@c (I GET 0 FOR THE ctensor VERSION OF dscalar, AND SAME FOR
@c THE DEFN OF dscalar GIVEN IN archive/share/lisp/ctensr.trl)
@c INCIDENTALLY dependencies IS DOCUMENTED ONLY AS A VARIABLE

@c @example
@c (%i41) dependencies(field(r));
@c (%o41)                           [field(r)]
@c (%i42) dscalar(field);
@c (%o43)
@c     -m
@c   %e  ((field  n - field  m + 2 field   ) r + 4 field )
@c              r  r       r  r         r r             r
@c 
@c - -----------------------------------------------------
@c                              2 r
@c @end example

@c @opencatbox
@c @category{Differential calculus} @category{Package ctensor}
@c @closecatbox
@end deffn

@c TODO: FOLGENDE FUNKTION IST IM PACKET VECT DEFINIERT. VERSCHIEBEN?!

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{express}
@deffn {Funktion} express (@var{expr})

@c HERE IS THE PREVIOUS TEXT. WHAT IS THE POINT ABOUT depends ?? 
@c I'M NOT GETTING IT
@c The result uses the noun form of any
@c derivatives arising from expansion of the vector differential
@c operators.  To force evaluation of these derivatives, the built-in @code{ev}
@c function can be used together with the @code{diff} evflag, after using the
@c built-in @code{depends} function to establish any new implicit dependencies.

Expands differential operator nouns into expressions in terms of partial 
derivatives. @code{express} recognizes the operators @code{grad}, @code{div}, 
@code{curl}, @code{laplacian}. @code{express} also expands the cross product 
@code{~}.

Symbolic derivatives (that is, @code{diff} nouns) in the return value of express
may be evaluated by including @code{diff} in the @code{ev} function call or 
command line. In this context, @code{diff} acts as an @code{evfun}.

@code{load ("vect")} loads this function.
@c IN POINT OF FACT, express IS A SIMPLIFICATION RULE, AND express1 IS THE FCN 
@c WHICH DOES ALL THE WORK

Beispiele:

@c ===beg===
@c load ("vect")$
@c grad (x^2 + y^2 + z^2);
@c express (%);
@c ev (%, diff);
@c div ([x^2, y^2, z^2]);
@c express (%);
@c ev (%, diff);
@c curl ([x^2, y^2, z^2]);
@c express (%);
@c ev (%, diff);
@c laplacian (x^2 * y^2 * z^2);
@c express (%);
@c ev (%, diff);
@c [a, b, c] ~ [x, y, z];
@c express (%);
@c ===end===
@example
(%i1) load ("vect")$
(%i2) grad (x^2 + y^2 + z^2);
                              2    2    2
(%o2)                  grad (z  + y  + x )
(%i3) express (%);
       d    2    2    2   d    2    2    2   d    2    2    2
(%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
       dx                 dy                 dz
(%i4) ev (%, diff);
(%o4)                    [2 x, 2 y, 2 z]
(%i5) div ([x^2, y^2, z^2]);
                              2   2   2
(%o5)                   div [x , y , z ]
(%i6) express (%);
                   d    2    d    2    d    2
(%o6)              -- (z ) + -- (y ) + -- (x )
                   dz        dy        dx
(%i7) ev (%, diff);
(%o7)                    2 z + 2 y + 2 x
(%i8) curl ([x^2, y^2, z^2]);
                               2   2   2
(%o8)                   curl [x , y , z ]
(%i9) express (%);
       d    2    d    2   d    2    d    2   d    2    d    2
(%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
       dy        dz       dz        dx       dx        dy
(%i10) ev (%, diff);
(%o10)                      [0, 0, 0]
(%i11) laplacian (x^2 * y^2 * z^2);
                                  2  2  2
(%o11)                laplacian (x  y  z )
(%i12) express (%);
         2                2                2
        d     2  2  2    d     2  2  2    d     2  2  2
(%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
          2                2                2
        dz               dy               dx
(%i13) ev (%, diff);
                      2  2      2  2      2  2
(%o13)             2 y  z  + 2 x  z  + 2 x  y
(%i14) [a, b, c] ~ [x, y, z];
(%o14)                [a, b, c] ~ [x, y, z]
(%i15) express (%);
(%o15)          [b z - c y, c x - a z, a y - b x]
@end example

@c @opencatbox
@c @category{Differential calculus} @category{Vectors} @category{Operators}
@c @closecatbox
@end deffn

@c COMMENTING OUT THIS TEXT PENDING RESOLUTION OF BUG REPORT # 836704:
@c "gendiff is all bugs: should be deprecated"
@c @defun gendiff
@c Sometimes @code{diff(e,x,n)} can be reduced even though N is
@c symbolic.
@c 
@c @example
@c batch("gendif")$
@c @end example
@c 
@c and you can try, for example,
@c 
@c @example
@c diff(%e^(a*x),x,q)
@c @end example
@c 
@c by using @code{gendiff} rather than @code{diff}.  Unevaluable
@c items come out quoted.  Some items are in terms of @code{genfact}, which
@c see.
@c 
@c @end defun

@c --- 20.11.2010 DK -----------------------------------------------------------
@anchor{gradef}
@deffn  {Funktion} gradef (@var{f}(@var{x_1}, ..., @var{x_n}), @var{g_1}, ..., @var{g_m})
@deffnx {Funktion} gradef (@var{a}, @var{x}, @var{expr})

@c Defines the partial derivatives (i.e., the components of the gradient) of the 
@c function @var{f} or variable @var{a}.

Definiert eine partielle Ableitung der Funktion @var{f} oder Variablen @var{a}.

@c @code{gradef (@var{f}(@var{x_1}, ..., @var{x_n}), @var{g_1}, ..., @var{g_m})}
@c defines @code{d@var{f}/d@var{x_i}} as @var{g_i}, where @var{g_i} is an 
@c expression; @var{g_i} may be a function call, but not the name of a function.
@c The number of partial derivatives @var{m} may be less than the number of 
@c arguments @var{n}, in which case derivatives are defined with respect to 
@c @var{x_1} through @var{x_m} only.

@code{gradef(@var{f}(@var{x_1}, ..., @var{x_n}), @var{g_1}, ..., @var{g_m})}
definiert die partielle Ableitung @code{d@var{f}/d@var{x_i}} als @var{g_i}.
@var{g_i} ist ein Ausdruck. @var{g_i} kann ein Funktionsaufruf sein, aber nicht
der Name einer Funktion. Die Anzahl der partiellen Ableitungen @var{m} kann
kleiner sein als die Anzahl der Argumente @var{n}.

@c @code{gradef (@var{a}, @var{x}, @var{expr})} defines the derivative of 
@c variable @var{a} with respect to @var{x} as @var{expr}. This also establishes
@c the dependence of @var{a} on @var{x} (via @code{depends (@var{a}, @var{x})}).

@code{gradef(@var{a}, @var{x}, @var{expr})} definierte die Ableitung der
Variablen @var{a} in Bezug auf die Variable @var{x} als @var{expr}. Wie mit der
Funktion @code{depends} wird @var{a} als abh@"angig von @var{x} deklariert. Die
Abh@"angigkeit wird in die Liste @code{dependencies} eingetragen. Siehe auch
@mrefdot{depends}

@c The first argument @code{@var{f}(@var{x_1}, ..., @var{x_n})} or @var{a} is 
@c quoted, but the remaining arguments @var{g_1}, ..., @var{g_m} are evaluated.
@c @code{gradef} returns the function or variable for which the partial 
@c derivatives are defined.

Bis auf erste Argument werden die Argumente der Funktion @code{gradef} 
ausgewertet. @code{gradef} gibt die Funktion oder Variable zur@"uck, f@"ur die eine
partielle Ableitung definiert wurde.

@c @code{gradef} can redefine the derivatives of Maxima's built-in functions.
@c For example, @code{gradef (sin(x), sqrt (1 - sin(x)^2))} redefines the 
@c derivative of @code{sin}.

@code{gradef} kann die Ableitungen von vorhandenen Maxima-Funktionen neu 
definieren. Zum Beispiel definiert @code{gradef(sin(x), sqrt (1 - sin(x)^2))}
eine neue Ableitung der Sinusfunktion.

@c @code{gradef} cannot define partial derivatives for a subscripted function.

@code{gradef} kann keine partiellen Ableitungen f@"ur indizierte Funktionen
definieren.

@c @code{printprops ([@var{f_1}, ..., @var{f_n}], gradef)} displays the partial
@c derivatives of the functions @var{f_1}, ..., @var{f_n}, as defined by 
@c @code{gradef}.

@code{printprops([@var{f_1}, ..., @var{f_n}], gradef)} zeigt die mit 
@code{gradef} definierten partiellen Ableitungen der Funktionen @var{f_1}, ...,
@var{f_n} an.

@c @code{printprops([@var{a_n}, ..., @var{a_n}], atomgrad)} displays the partial 
@c derivatives of the variables @var{a_n}, ..., @var{a_n}, as defined by 
@c @code{gradef}.

@code{printprops([@var{a_n}, ..., @var{a_n}], atomgrad)} zeigt die mit 
@code{gradef} definierten partiellen Ableitungen der Variablen @var{a_n}, ..., 
@var{a_n} an.

@c @code{gradefs} is the list of the functions for which partial derivatives 
@c have been defined by @code{gradef}. @code{gradefs} does not include any 
@c variables for which partial derivatives have been defined by @code{gradef}.

@code{gradefs} ist eine Informationsliste, die die Funktionen enth@"alt, f@"ur die
mit @code{gradef} eine Ableitung definierte wurde. Die Liste enth@"alt keine
Variablen, f@"ur die Ableitungen definiert wurden.

@c REPHRASE THIS NEXT BIT
@c Gradients are needed when, for example, a function is not known explicitly 
@c but its first derivatives are and it is desired to obtain higher order 
@c derivatives.

@c NEED EXAMPLES HERE
@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end deffn

@c --- 19.11.2010 DK -----------------------------------------------------------
@anchor{gradefs}
@defvr {Systemvariable} gradefs
Standardwert: @code{[]}

@c @code{gradefs} is the list of the functions for which partial derivatives 
@c have been defined by @code{gradef}. @code{gradefs} does not include any 
@c variables for which partial derivatives have been defined by @code{gradef}.

@code{gradefs} ist eine Liste der Funktionen, f@"ur die eine Ableitung definiert
wurde.

@c @opencatbox
@c @category{Differential calculus} @category{Declarations and inferences}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@node Integration, Einf@"uhrung in die Integration, Funktionen und Variablen der Differentiation, Analysis
@section Integration

@c -----------------------------------------------------------------------------
@menu
* Einf@"uhrung in die Integration::
* Funktionen und Variablen der Integration::
* Einf@"uhrung in QUADPACK::
* Funktionen und Variablen f@"ur QUADPACK::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Integration, Funktionen und Variablen der Integration, Integration
@subsection Einf@"uhrung in die Integration

Maxima has several routines for handling integration.
The @code{integrate} function makes use of most of them.  There is also the
@code{antid} package, which handles an unspecified function (and its
derivatives, of course).  For numerical uses,
there is a set of adaptive integrators from QUADPACK,
named @code{quad_qag}, @code{quad_qags}, etc., which are described under the heading @code{QUADPACK}.
Hypergeometric functions are being worked on,
see @code{specint} for details.
Generally speaking, Maxima only handles integrals which are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as @code{g(x)} and @code{h(x)}.

@c end concepts Integration

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen der Integration, Einf@"uhrung in QUADPACK, Einf@"uhrung in die Integration, Integration
@subsection Funktionen und Variablen der Integration

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@deffn {Function} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})
Makes the change of variable given by
@code{@var{f(x,y)} = 0} in all integrals occurring in @var{expr} with integration with
respect to @var{x}.
The new variable is @var{y}.

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
@group
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
@end group
@group
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end group
@end example

An expression containing a noun form, such as the instances of @code{'integrate} above,
may be evaluated by @code{ev} with the @code{nouns} flag.
For example, the expression returned by @code{changevar} above may be evaluated
by @code{ev (%o3, nouns)}.

@code{changevar} may also be used to changes in the indices of a sum or
product.  However, it must be realized that when a change is made in a
sum or product, this change must be a shift, i.e., @code{i = j+ ...}, not a
higher degree function.  E.g.,

@example
@group
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
@end group
@group
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE

@c -----------------------------------------------------------------------------
@deffn {Function} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})

A double-integral routine which was written in
top-level Maxima and then translated and compiled to machine code.
Use @code{load (dblint)} to access this package.  It uses the Simpson's rule
method in both the x and y directions to calculate

@tex
$$\int_a^b \int_{r\left(x\right)}^{s\left(x\right)} f\left(x,y\right) \, dy \, dx.$$
@end tex
@ifnottex
@example
@group
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end group
@end example
@end ifnottex

The function @var{f} must be a translated or compiled function of two
variables, and @var{r} and @var{s} must each be a translated or compiled
function of one variable, while @var{a} and @var{b} must be floating point
numbers. The routine has two global variables which determine the
number of divisions of the x and y intervals: @code{dblint_x} and @code{dblint_y},
both of which are initially 10, and can be changed independently to
other integer values (there are @code{2*dblint_x+1} points computed in the x
direction, and @code{2*dblint_y+1} in the y direction).
The routine subdivides the X axis and then for each value of X it
first computes @code{@var{r}(x)} and @code{@var{s}(x)}; then the Y axis between @code{@var{r}(x)} and @code{@var{s}(x)} is
subdivided and the integral along the Y axis is performed using
Simpson's rule; then the integral along the X axis is done using
Simpson's rule with the function values being the Y-integrals. This
procedure may be numerically unstable for a great variety of reasons,
but is reasonably fast: avoid using it on highly oscillatory functions
and functions with singularities (poles or branch points in the
region).  The Y integrals depend on how far apart @code{@var{r}(x)} and @code{@var{s}(x)} are,
so if the distance @code{@var{s}(x) - @var{r}(x)} varies rapidly with X, there may be
substantial errors arising from truncation with different step-sizes
in the various Y integrals. One can increase @code{dblint_x} and @code{dblint_y} in
an effort to improve the coverage of the region, at the expense of
computation time. The function values are not saved, so if the
function is very time-consuming, you will have to wait for
re-computation if you change anything (sorry).
It is required that the functions @var{f}, @var{r}, and @var{s} be either translated or
compiled prior to calling @code{dblint}. This will result in orders of
magnitude speed improvement over interpreted code in many cases!

@code{demo (dblint)} executes a demonstration of @code{dblint} applied to an example problem.
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT. !!!
@c @code{demo (dblint_1)} executes another demonstration.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} defint (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to compute a definite integral.
@code{defint} is called by @code{integrate} when limits of integration are specified,
i.e., when @code{integrate} is called as @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
Thus from the user's point of view, it is sufficient to call @code{integrate}.
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

@code{defint} returns a symbolic expression,
either the computed integral or the noun form of the integral.
See @code{quad_qag} and related functions for numerical approximation of definite integrals.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} erfflag
Default value: @code{true}

When @code{erfflag} is @code{false}, prevents @code{risch} from introducing the
@code{erf} function in the answer if there were none in the integrand to
begin with.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@deffn {Function} ilt (@var{expr}, @var{s}, @var{t})

Computes the inverse Laplace transform of @var{expr} with
respect to @var{s} and parameter @var{t}.  @var{expr} must be a ratio of
polynomials whose denominator has only linear and quadratic factors.
By using the functions @code{laplace} and @code{ilt} together with the @code{solve} or
@code{linsolve} functions the user can solve a single differential or
convolution integral equation or a set of them.

@example
@group
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
@end group
@group
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
@end group
@group
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
@end group
@group
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end group
@end example

@c @opencatbox
@c @category{Laplace transform}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} intanalysis
Default value: @code{true}

When @code{true}, definite integration tries to find poles in the integrand in 
the interval of integration. If there are, then the integral is evaluated
appropriately as a principal value integral. If intanalysis is @code{false}, 
this check is not performed and integration is done assuming there are no poles.

See also @code{ldefint}.

Examples:

Maxima can solve the following integrals, when @code{intanalysis} is set to
@code{false}:

@c ===beg===
@c integrate(1/(sqrt(x+1)+1),x,0,1);
@c integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
@c integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
@c intanalysis:false$
@c integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
@c ===end===
@example
(%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                1
                               /
                               [       1
(%o1)                          I  ----------- dx
                               ]  sqrt(x) + 1
                               /
                                0

(%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
(%o2)                            2 - 2 log(2)

(%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
The number 1 isn't in the domain of atanh
 -- an error. To debug this try: debugmode(true);

(%i4) intanalysis:false$
(%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                      %pi
(%o5)                                 ---
                                       2
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn  {Function} integrate (@var{expr}, @var{x})
@deffnx {Function} integrate (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to symbolically compute the integral of @var{expr} with respect to @var{x}.
@code{integrate (@var{expr}, @var{x})} is an indefinite integral,
while @code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})} is a definite integral,
with limits of integration @var{a} and @var{b}.
The limits should not contain @var{x}, although @code{integrate} does not enforce this restriction.
@var{a} need not be less than @var{b}.
If @var{b} is equal to @var{a}, @code{integrate} returns zero.

See @code{quad_qag} and related functions for numerical approximation of definite integrals.
See @code{residue} for computation of residues (complex integration).
See @code{antid} for an alternative means of computing indefinite integrals.

The integral (an expression free of @code{integrate}) is returned if @code{integrate} succeeds.
Otherwise the return value is
the noun form of the integral (the quoted operator @code{'integrate})
or an expression containing one or more noun forms.
The noun form of @code{integrate} is displayed with an integral sign.

In some circumstances it is useful to construct a noun form by hand,
by quoting @code{integrate} with a single quote, e.g., @code{'integrate (@var{expr}, @var{x})}.
For example, the integral may depend on some parameters which are not yet computed.
The noun may be applied to its arguments by @code{ev (@var{i}, nouns)}
where @var{i} is the noun form of interest.

@c BEGIN EXPOSITION ON HEURISTICS
@code{integrate} handles definite integrals separately from indefinite,
and employs a range of heuristics to handle each case.
Special cases of definite integrals include limits of integration equal to
zero or infinity (@code{inf} or @code{minf}),
trigonometric functions with limits of integration equal to zero and @code{%pi} or @code{2 %pi},
rational functions,
integrals related to the definitions of the @code{beta} and @code{psi} functions,
and some logarithmic and trigonometric integrals.
Processing rational functions may include computation of residues.
If an applicable special case is not found,
an attempt will be made to compute the indefinite integral and evaluate it at the limits of integration.
This may include taking a limit as a limit of integration goes to infinity or negative infinity;
see also @code{ldefint}.

Special cases of indefinite integrals include trigonometric functions,
exponential and logarithmic functions,
and rational functions.
@code{integrate} may also make use of a short table of elementary integrals.

@code{integrate} may carry out a change of variable
if the integrand has the form @code{f(g(x)) * diff(g(x), x)}.
@code{integrate} attempts to find a subexpression @code{g(x)} such that
the derivative of @code{g(x)} divides the integrand.
This search may make use of derivatives defined by the @code{gradef} function.
See also @code{changevar} and @code{antid}.

If none of the preceding heuristics find the indefinite integral,
the Risch algorithm is executed.
The flag @code{risch} may be set as an @code{evflag},
in a call to @code{ev} or on the command line,
e.g., @code{ev (integrate (@var{expr}, @var{x}), risch)} or @code{integrate (@var{expr}, @var{x}), risch}.
If @code{risch} is present, @code{integrate} calls the @code{risch} function
without attempting heuristics first. See also @code{risch}.
@c END EXPOSITION ON HEURISTICS

@code{integrate} works only with functional relations represented explicitly with the @code{f(x)} notation.
@code{integrate} does not respect implicit dependencies established by the @code{depends} function.

@code{integrate} may need to know some property of a parameter in the integrand.
@code{integrate} will first consult the @code{assume} database,
and, if the variable of interest is not there,
@code{integrate} will ask the user.
Depending on the question,
suitable responses are @code{yes;} or @code{no;},
or @code{pos;}, @code{zero;}, or @code{neg;}.

@code{integrate} is not, by default, declared to be linear. See @code{declare} and @code{linear}.

@code{integrate} attempts integration by parts only in a few special cases.

Examples:

@itemize @bullet
@item
Elementary indefinite and definite integrals.

@example
@group
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
@end group
@group
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
@end group
@group
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
@end group
@group
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end group
@end example

@item
Use of @code{assume} and interactive query.

@example
(%i1) assume (a > 1)$
@group
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end group
@end example

@item
Change of variable. There are two changes of variable in this example:
one using a derivative established by @code{gradef},
and one using the derivation @code{diff(r(x))} of an unspecified function @code{r(x)}.

@example
@group
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
@end group
@group
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
@end group
@group
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end group
@end example

@item
Return value contains the @code{'integrate} noun form.
In this example, Maxima can extract one factor of the denominator
of a rational function, but cannot factor the remainder or otherwise find its integral.
@code{grind} shows the noun form @code{'integrate} in the result.
See also @code{integrate_use_rootsof} for more on integrals of rational functions.

@example
@group
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
@end group
@group
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
@end group
@group
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end group
@end example

@item
Defining a function in terms of an integral.
The body of a function is not evaluated when the function is defined.
Thus the body of @code{f_1} in this example contains the noun form of @code{integrate}.
The quote-quote operator @code{'@w{}'} causes the integral to be evaluated,
and the result becomes the body of @code{f_2}.

@example
@group
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
@end group
@group
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
@end group
@group
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
@end group
@group
(%i4) f_2 (7);
(%o4)                          600
@end group
@end example
@end itemize

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@defvr {System variable} integration_constant
Default value: @code{%c}

When a constant of integration is introduced by indefinite integration of an equation,
the name of the constant is constructed by concatenating @code{integration_constant}
and @code{integration_constant_counter}.

@code{integration_constant} may be assigned any symbol.

Examples:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integration_constant : 'k;
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integration_constant : 'k;
(%o2)                           k
@end group
@group
(%i3) integrate (x^2 = 1, x);
                            3
                           x
(%o3)                      -- = x + k2
                           3
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {System variable} integration_constant_counter
Default value: 0

When a constant of integration is introduced by indefinite integration of an equation,
the name of the constant is constructed by concatenating @code{integration_constant}
and @code{integration_constant_counter}.

@code{integration_constant_counter} is incremented before constructing the next integration constant.

Examples:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c reset (integration_constant_counter);
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integrate (x^2 = 1, x);
                           3
                          x
(%o2)                     -- = x + %c2
                          3
@end group
@group
(%i3) integrate (x^2 = 1, x);
                           3
                          x
(%o3)                     -- = x + %c3
                          3
@end group
@group
(%i4) reset (integration_constant_counter);
(%o4)            [integration_constant_counter]
@end group
@group
(%i5) integrate (x^2 = 1, x);
                           3
                          x
(%o5)                     -- = x + %c1
                          3
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@defvr {Option variable} integrate_use_rootsof
Default value: @code{false}

When @code{integrate_use_rootsof} is @code{true} and the denominator of
a rational function cannot be factored, @code{integrate} returns the integral
in a form which is a sum over the roots (not yet known) of the denominator.

For example, with @code{integrate_use_rootsof} set to @code{false},
@code{integrate} returns an unsolved integral of a rational function in noun form:

@example
(%i1) integrate_use_rootsof: false$
@group
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end group
@end example

Now we set the flag to be true and the unsolved part of the
integral will be expressed as a summation over the roots of the denominator of the rational function:

@example
(%i3) integrate_use_rootsof: true$
@group
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                      3    2
      %r4 in rootsof(x  - x  + 1)
(%o4) ----------------------------------------------------------
               7

                                                      2 x + 1
                                  2            5 atan(-------)
                             log(x  + x + 1)          sqrt(3)
                           - --------------- + ---------------
                                   14             7 sqrt(3)
@end group
@end example

Alternatively the user may compute the roots of the denominator separately,
and then express the integrand in terms of these roots,
e.g., @code{1/((x - a)*(x - b)*(x - c))} or @code{1/((x^2 - (a+b)*x + a*b)*(x - c))}
if the denominator is a cubic polynomial.
Sometimes this will help Maxima obtain a more useful result.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{laplace}
@deffn {Function} laplace (@var{expr}, @var{t}, @var{s})

Attempts to compute the Laplace transform of @var{expr} with respect to the 
variable @var{t} and transform parameter @var{s}.

@code{laplace} recognizes in @var{expr} the functions @code{delta}, @code{exp},
@code{log}, @code{sin}, @code{cos}, @code{sinh}, @code{cosh}, and @code{erf},
as well as @code{derivative}, @code{integrate}, @code{sum}, and @code{ilt}. If
laplace fails to find a transform the function @code{specint} is called.
@code{specint} can find the laplace transform for expressions with special
functions like the bessel functions @code{bessel_j}, @code{bessel_i}, ... and
can handle the @code{unit_step} function. See also @code{specint}.

If @code{specint} cannot find a solution too, a noun @code{laplace} is returned.

@c REPHRASE THIS
@var{expr} may also be a linear, constant coefficient differential equation in
which case @code{atvalue} of the dependent variable is used.
@c "used" -- USED HOW ??
The required atvalue may be supplied either before or after the transform is computed.
Since the initial conditions must be specified at zero, if one has boundary
conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution
for them and substituting their values back.

@code{laplace} recognizes convolution integrals of the form
@code{integrate (f(x) * g(t - x), x, 0, t)};
other kinds of convolutions are not recognized.

Functional relations must be explicitly represented in @var{expr};
implicit relations, established by @code{depends}, are not recognized.
That is, if @var{f} depends on @var{x} and @var{y},
@code{f (x, y)} must appear in @var{expr}.

See also @code{ilt}, the inverse Laplace transform.

Examples:
@c GENERATED FROM THE FOLLOWING:
@c laplace (exp (2*t + a) * sin(t) * t, t, s);
@c laplace ('diff (f (x), x), x, s);
@c diff (diff (delta (t), t), t);
@c laplace (%, t, s);

@example
(%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                            a
                          %e  (2 s - 4)
(%o1)                    ---------------
                           2           2
                         (s  - 4 s + 5)
(%i2) laplace ('diff (f (x), x), x, s);
(%o2)             s laplace(f(x), x, s) - f(0)
(%i3) diff (diff (delta (t), t), t);
                          2
                         d
(%o3)                    --- (delta(t))
                           2
                         dt
(%i4) laplace (%, t, s);
                            !
               d            !         2
(%o4)        - -- (delta(t))!      + s  - delta(0) s
               dt           !
                            !t = 0
(%i5) assume(a>0)$
(%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                              - a - 1
                         gamma(a)   gamma(a) s
(%o6)                    -------- - -----------------
                            s            1     a
                                        (- + 1)
                                         s
(%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                              s + 1
                      sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                s
(%o7)                 -----------------------------------
                                3/2      s + 1
                               s    sqrt(-----)
                                           s
(%i8) assume(exp(%pi*s)>1)$
(%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s),simpsum;
                         %i                         %i
              ------------------------ - ------------------------
                              - %pi s                    - %pi s
              (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
(%o9)         ---------------------------------------------------
                                       2
(%i9) factor(%);
                                      %pi s
                                    %e
(%o9)                   -------------------------------
                                             %pi s
                        (s - %i) (s + %i) (%e      - 1)

@end example

@c @opencatbox
@c @category{Laplace transform} @category{Differential equations}
@c @closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@deffn {Function} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})

Attempts to compute the definite integral of @var{expr} by using
@code{limit} to evaluate the indefinite integral of @var{expr} with respect to @var{x}
at the upper limit @var{b} and at the lower limit @var{a}.
If it fails to compute the definite integral,
@code{ldefint} returns an expression containing limits as noun forms.

@code{ldefint} is not called from @code{integrate},
so executing @code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})} may yield a different result than
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}.
@code{ldefint} always uses the same method to evaluate the definite integral,
while @code{integrate} may employ various heuristics and may recognize some special cases.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@deffn {Function} potential (@var{givengradient})

The calculation makes use of the global variable @code{potentialzeroloc[0]}
which must be @code{nonlist} or of the form

@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example

the
former being equivalent to the nonlist expression for all right-hand
sides in the latter.  The indicated right-hand sides are used as the
lower limit of integration.  The success of the integrations may
depend upon their values and order. @code{potentialzeroloc} is initially set
to 0.

@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} residue (@var{expr}, @var{z}, @var{z_0})

Computes the residue in the complex plane of
the expression @var{expr} when the variable @var{z} assumes the value @var{z_0}.  The
residue is the coefficient of @code{(@var{z} - @var{z_0})^(-1)} in the Laurent series
for @var{expr}.

@example
@group
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
@end group
@group
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end group
@end example

@c @opencatbox
@c @category{Integral calculus} @category{Complex variables}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} risch (@var{expr}, @var{x})

Integrates @var{expr} with respect to @var{x} using the
transcendental case of the Risch algorithm.  (The algebraic case of
the Risch algorithm has not been implemented.)  This currently
handles the cases of nested exponentials and logarithms which the main
part of @code{integrate} can't do.  @code{integrate} will automatically apply @code{risch}
if given these cases.

@code{erfflag}, if @code{false}, prevents @code{risch} from introducing the @code{erf}
function in the answer if there were none in the integrand to begin
with.

@example
@group
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
@end group
@group
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end group
@end example

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES

@c -----------------------------------------------------------------------------
@deffn {Function} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})

Equivalent to @code{ldefint} with @code{tlimswitch} set to @code{true}.

@c @opencatbox
@c @category{Integral calculus}
@c @closecatbox
@end deffn

@footnotestyle end

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in QUADPACK, Funktionen und Variablen f@"ur QUADPACK, Funktionen und Variablen der Integration, Integration
@subsection Einf@"uhrung in QUADPACK

@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACK is a collection of functions for the numerical
computation of one-dimensional definite integrals.
It originated from a joint project of
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"ur Mathematik, T.U. Wien},
and D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.

The QUADPACK library included in Maxima is an automatic translation
(via the program @code{f2cl}) of the Fortran source code of QUADPACK as it appears in
the SLATEC Common Mathematical Library, Version 4.1 @footnote{@url{http://www.netlib.org/slatec}}.
The SLATEC library is dated July 1993, but the QUADPACK functions
were written some years before.
There is another version of QUADPACK at Netlib @footnote{@url{http://www.netlib.org/quadpack}};
it is not clear how that version differs from the SLATEC version.

The QUADPACK functions included in Maxima are all automatic,
in the sense that these functions attempt to compute a result to a specified accuracy,
requiring an unspecified number of function evaluations.
Maxima's Lisp translation of QUADPACK also includes some non-automatic functions,
but they are not exposed at the Maxima level.

Further information about QUADPACK can be found in the QUADPACK book
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}.

@c -----------------------------------------------------------------------------
@subsubheading Overview

@table @code
@item quad_qag
Integration of a general function over a finite interval.
@code{quad_qag} implements a simple globally adaptive integrator using the strategy of Aind (Piessens, 1973).
The caller may choose among 6 pairs of Gauss-Kronrod quadrature
formulae for the rule evaluation component.
The high-degree rules are suitable for strongly oscillating integrands.

@item quad_qags
Integration of a general function over a finite interval.
@code{quad_qags} implements globally adaptive interval subdivision with extrapolation
(de Doncker, 1978) by the Epsilon algorithm (Wynn, 1956).

@item quad_qagi
Integration of a general function over an infinite or semi-infinite interval.
The interval is mapped onto a finite interval and
then the same strategy as in @code{quad_qags} is applied.

@item quad_qawo
@ifnottex
Integration of @math{cos(omega x) f(x)} or @math{sin(omega x) f(x)} over a finite interval,
where @math{omega} is a constant.
@end ifnottex
@tex
Integration of $\cos\left(\omega \, x\right) \, f\left(x\right)$ or
$\sin\left(\omega \, x\right) \, f\left(x\right)$ over a finite interval,
where $\omega$ is a constant.
@end tex
The rule evaluation component is based on the modified Clenshaw-Curtis technique.
@code{quad_qawo} applies adaptive subdivision with extrapolation, similar to @code{quad_qags}.

@item quad_qawf
Calculates a Fourier cosine or Fourier sine transform on a semi-infinite interval.
The same approach as in @code{quad_qawo} is applied on successive finite intervals,
and convergence acceleration by means of the Epsilon algorithm (Wynn, 1956)
is applied to the series of the integral contributions.

@item quad_qaws
@ifnottex
Integration of @math{w(x) f(x)} over a finite interval @math{[a, b]},
where @math{w} is a function of the form @math{(x - a)^alpha (b - x)^beta v(x)}
and @math{v(x)} is 1 or @math{log(x - a)} or @math{log(b - x)} or @math{log(x - a) log(b - x)},
and @math{alpha > -1} and @math{beta > -1}.
@end ifnottex
@tex
Integration of $w\left(x\right) \, f\left(x\right)$ over a finite interval
$\left[a, b\right]$, where $w$ is a function of the form
$\left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, v\left(x\right)$
and $v\left(x\right)$ is $1$ or $\log\left(x - a\right)$
or $\log\left(b - x\right)$ or $\log\left(x - a\right) \, \log\left(b - x\right)$,
and $\alpha > -1$ and $\beta > -1$.
@end tex

A globally adaptive subdivision strategy is applied,
with modified Clenshaw-Curtis integration on the subintervals which contain @math{a} or @math{b}.

@item quad_qawc
Computes the Cauchy principal value of @math{f(x)/(x - c)} over a finite interval @math{(a, b)}
and specified @math{c}.
The strategy is globally adaptive, and modified
Clenshaw-Curtis integration is used on the subranges
which contain the point @math{x = c}.
@end table

@c @opencatbox
@c @category{Integral calculus} @category{Numerical methods} @category{Share packages} @category{Package quadpack}
@c @closecatbox

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur QUADPACK, , Einf@"uhrung in QUADPACK, Integration
@subsection Funktionen und Variablen f@"ur QUADPACK

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qag (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qag (@var{f}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over a finite interval.
@code{quad_qag} implements a simple globally adaptive integrator using the strategy of Aind (Piessens, 1973).
The caller may choose among 6 pairs of Gauss-Kronrod quadrature
formulae for the rule evaluation component.
The high-degree rules are suitable for strongly oscillating integrands.

@code{quad_qag} computes the integral

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex

The function to be integrated is @var{f(x)}, with dependent
variable @var{x}, and the function is to be integrated between the
limits @var{a} and @var{b}.  @var{key} is the integrator to be used
and should be an integer between 1 and 6, inclusive.  The value of
@var{key} selects the order of the Gauss-Kronrod integration rule.
High-order rules are suitable for strongly oscillating integrands.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The numerical integration is done adaptively by subdividing the
integration region into sub-intervals until the desired accuracy is
achieved.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qag} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
if no problems were encountered;
@item 1
if too many sub-intervals were done;
@item 2
if excessive roundoff error is detected;
@item 3
if extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
@end group
@group
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qags (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qags (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over a finite interval.
@code{quad_qags} implements globally adaptive interval subdivision with extrapolation
(de Doncker, 1978) by the Epsilon algorithm (Wynn, 1956).

@code{quad_qags} computes the integral

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex

The function to be integrated is @var{f(x)}, with
dependent variable @var{x}, and the function is to be integrated
between the limits @var{a} and @var{b}.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qags} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end group
@end example

Note that @code{quad_qags} is more accurate and efficient than @code{quad_qag} for this integrand.

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qagi (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qagi (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of a general function over an infinite or semi-infinite interval.
The interval is mapped onto a finite interval and
then the same strategy as in @code{quad_qags} is applied.

@code{quad_qagi} evaluates one of the following integrals

@ifnottex
@math{integrate (f(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, a)}
@end ifnottex
@tex
$$\int_\infty^a {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, inf)}
@end ifnottex
@tex
$$\int_{-\infty}^\infty {f(x) \, dx}$$
@end tex

using the Quadpack QAGI routine.  The function to be integrated is
@var{f(x)}, with dependent variable @var{x}, and the function is to
be integrated over an infinite range.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

One of the limits of integration must be infinity.  If not, then
@code{quad_qagi} will just return the noun form.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qagi} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

Examples:

@example
@group
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
@end group
@group
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawc (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qawc (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Computes the Cauchy principal value of @math{f(x)/(x - c)} over a finite interval.
The strategy is globally adaptive, and modified
Clenshaw-Curtis integration is used on the subranges
which contain the point @math{x = c}.

@code{quad_qawc} computes the Cauchy principal value of

@ifnottex
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifnottex
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

using the Quadpack QAWC routine.  The function to be integrated is
@code{@var{f(x)}/(@var{x} - @var{c})}, with dependent variable @var{x}, and the function
is to be integrated over the interval @var{a} to @var{b}.

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit} is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qawc} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                 'epsrel=1d-7);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
@end group
@group
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
      x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

       3 alpha                       3 alpha
       -------                       -------
          2            alpha/2          2          alpha/2
    2 4        atan(4 4       )   2 4        atan(4       )   alpha
  - --------------------------- - -------------------------)/2
              alpha                        alpha
           2 4      + 2                 2 4      + 2
@end group
@group
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawf (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Function} quad_qawf (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

Calculates a Fourier cosine or Fourier sine transform on a semi-infinite interval
using the Quadpack QAWF function.
The same approach as in @code{quad_qawo} is applied on successive finite intervals,
and convergence acceleration by means of the Epsilon algorithm (Wynn, 1956)
is applied to the series of the integral contributions.

@code{quad_qawf} computes the integral

@ifnottex
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{trig}:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsabs
Desired absolute error of approximation.  Default is 1d-10.
@item limit
Size of internal work array.  (@var{limit} - @var{limlst})/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table

@code{quad_qawf} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
@end group
@group
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
@end group
@group
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qawo (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {Function} quad_qawo (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

Integration of
@ifnottex
@math{cos (omega x) f(x)}
@end ifnottex
@tex
$\cos \left(\omega \, x\right) \, f\left(x\right)$
@end tex
or
@ifnottex
@math{sin (omega x) f(x)}
@end ifnottex
@tex
$\sin \left(\omega \, x\right) \, f\left(x\right)$
@end tex
over a finite interval,
where
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
is a constant.
The rule evaluation component is based on the modified Clenshaw-Curtis technique.
@code{quad_qawo} applies adaptive subdivision with extrapolation, similar to @code{quad_qags}.

@code{quad_qawo} computes the integral using the Quadpack QAWO
routine:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{trig}:

@table @code
@item cos
@ifnottex
@math{w(x) = cos (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \cos \left(\omega \, x\right)$
@end tex
@item sin
@ifnottex
@math{w(x) = sin (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \sin \left(\omega \, x\right)$
@end tex
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit}/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table

@code{quad_qawo} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
@end group
@group
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
      x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
@end group
@group
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@deffn {Function} quad_qaws (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {Function} quad_qaws (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])

Integration of @math{w(x) f(x)} over a finite interval,
where @math{w(x)} is a certain algebraic or logarithmic function.
A globally adaptive subdivision strategy is applied,
with modified Clenshaw-Curtis integration on the subintervals which contain the endpoints
of the interval of integration.

@code{quad_qaws} computes the integral using the Quadpack QAWS
routine:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

The weight function @math{w} is selected by @var{wfun}:

@table @code
@item 1
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta$
@end tex
@item 2
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right)$
@end tex
@item 3
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(b - x\right)$
@end tex
@item 4
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
@end table

The integrand may be specified as the name of a Maxima or Lisp function or operator,
a Maxima lambda expression, or a general Maxima expression.

The keyword arguments are optional and may be specified in any order.
They all take the form @code{key=val}.  The keyword arguments are:

@table @var
@item epsrel
Desired relative error of approximation.  Default is 1d-8.
@item epsabs
Desired absolute error of approximation.  Default is 0.
@item limit
Size of internal work array.  @var{limit}is the
maximum number of subintervals to use.  Default is 200.
@end table

@code{quad_qaws} returns a list of four elements:

@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation,
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code (fourth element of the return value) can have the values:

@table @code
@item 0
no problems were encountered;
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:

@example
@group
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                 'epsabs=1d-9);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
@end group
@group
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
@end group
@group
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end group
@end example

@c @opencatbox
@c @category{Numerical methods} @category{Package quadpack}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Differentialgleichungen, Integration, , Analysis
@section Differentialgleichungen

@c -----------------------------------------------------------------------------
@menu
* Einf@"uhrung in Differentialgleichungen::  
* Funktionen und Variablen f@"ur Differentialgleichungen::  
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Differentialgleichungen, Funktionen und Variablen f@"ur Differentialgleichungen, Differentialgleichungen
@subsection Einf@"uhrung in Differentialgleichungen

This section describes the functions available in Maxima to obtain
analytic solutions for some specific types of first and second-order
equations. To obtain a numerical solution for a system of differential
equations, see the additional package @code{dynamics}. For graphical
representations in phase space, see the additional package
@code{plotdf}.


@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Differentialgleichungen,  , Einf@"uhrung in Differentialgleichungen, Differentialgleichungen
@subsection Funktionen und Variablen f@"ur Differentialgleichungen

@c -----------------------------------------------------------------------------
@deffn {Function} bc2 (@var{solution}, @var{xval1}, @var{yval1}, @var{xval2}, @var{yval2})

Solves a boundary value problem for a second order differential equation.
Here: @var{solution} is a general solution to the equation, as found by
@code{ode2}; @var{xval1} specifies the value of the independent variable
in a first point, in the form @code{@var{x} = @var{x1}}, and @var{yval1}
gives the value of the dependent variable in that point, in the form
@code{@var{y} = @var{y1}}. The expressions @var{xval2} and @var{yval2}
give the values for these variables at a second point, using the same
form.

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn  {Function} desolve (@var{eqn}, @var{x})
@deffnx {Function} desolve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])

The function @code{desolve} solves systems of linear ordinary
differential equations using Laplace transform.  Here the @var{eqn}'s
are differential equations in the dependent variables @var{x_1}, ...,
@var{x_n}.  The functional dependence of @var{x_1}, ..., @var{x_n} on an
independent variable, for instance @var{x}, must be explicitly indicated
in the variables and its derivatives. For example, this would not be the
correct way to define two equations:

@example
eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);
@end example

The correct way would be:

@example
eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);
@end example

The call to the function @code{desolve} would then be
@example
desolve([eqn_1, eqn_2], [f(x),g(x)]);
@end example

If initial conditions at @code{x=0} are known, they can be supplied before
calling @code{desolve} by using @code{atvalue}.

@c ===beg===
@c 'diff(f(x),x)='diff(g(x),x)+sin(x);
@c 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
@c atvalue('diff(g(x),x),x=0,a);
@c atvalue(f(x),x=0,1);
@c desolve([%o1,%o2],[f(x),g(x)]);
@c [%o1,%o2],%o5,diff;
@c ===end===
@example
(%i1) @b{@t{'diff(f(x),x)='diff(g(x),x)+sin(x);}}
                 d           d
(%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                 dx          dx
(%i2) @b{@t{'diff(g(x),x,2)='diff(f(x),x)-cos(x);}}
                  2
                 d            d
(%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                   2          dx
                 dx
(%i3) @b{@t{atvalue('diff(g(x),x),x=0,a);}}
(%o3)                           a
(%i4) @b{@t{atvalue(f(x),x=0,1);}}
(%o4)                           1
(%i5) @b{@t{desolve([%o1,%o2],[f(x),g(x)]);}}
                  x
(%o5) [f(x) = a %e  - a + 1, g(x) = 

                                                x
                                   cos(x) + a %e  - a + g(0) - 1]
(%i6) @b{@t{[%o1,%o2],%o5,diff;}}
             x       x      x                x
(%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

@end example

If @code{desolve} cannot obtain a solution, it returns @code{false}.

@c @opencatbox
@c @category{Differential equations} @category{Laplace transform}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ic1 (@var{solution}, @var{xval}, @var{yval})

Solves initial value problems for first order differential equations.
Here @var{solution} is a general solution to the equation, as found by
@code{ode2}, @var{xval} gives an initial value for the independent
variable in the form @code{@var{x} = @var{x0}}, and @var{yval} gives the
initial value for the dependent variable in the form @code{@var{y} =
@var{y0}}.

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ic2 (@var{solution}, @var{xval}, @var{yval}, @var{dval})

Solves initial value problems for second-order differential equations.
Here @var{solution} is a general solution to the equation, as found by
@code{ode2}, @var{xval} gives the initial value for the independent
variable in the form @code{@var{x} = @var{x0}}, @var{yval} gives the
initial value of the dependent variable in the form @code{@var{y} =
@var{y0}}, and @var{dval} gives the initial value for the first
derivative of the dependent variable with respect to independent
variable, in the form @code{diff(@var{y},@var{x}) = @var{dy0}}
(@code{diff} does not have to be quoted).

See @code{ode2} for an example of its usage.

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} ode2 (@var{eqn}, @var{dvar}, @var{ivar})

The function @code{ode2} solves an ordinary differential equation (ODE)
of first or second order. It takes three arguments: an ODE given by
@var{eqn}, the dependent variable @var{dvar}, and the independent
variable @var{ivar}. When successful, it returns either an explicit or
implicit solution for the dependent variable. @code{%c} is used to
represent the integration constant in the case of first-order equations,
and @code{%k1} and @code{%k2} the constants for second-order
equations. The dependence of the dependent variable on the independent
variable does not have to be written explicitly, as in the case of
@code{desolve}, but the independent variable must always be given as the
third argument.

If @code{ode2} cannot obtain a solution for whatever reason, it returns
@code{false}, after perhaps printing out an error message. The methods
implemented for first order equations in the order in which they are
tested are: linear, separable, exact - perhaps requiring an integrating
factor, homogeneous, Bernoulli's equation, and a generalized homogeneous
method. The types of second-order equations which can be solved are:
constant coefficients, exact, linear homogeneous with non-constant
coefficients which can be transformed to constant coefficients, the
Euler or equi-dimensional equation, equations solvable by the method of
variation of parameters, and equations which are free of either the
independent or of the dependent variable so that they can be reduced to
two first order linear equations to be solved sequentially.

In the course of solving ODE's, several variables are set purely for
informational purposes: @code{method} denotes the method of solution
used (e.g., @code{linear}), @code{intfactor} denotes any integrating
factor used, @code{odeindex} denotes the index for Bernoulli's method or
for the generalized homogeneous method, and @code{yp} denotes the
particular solution for the variation of parameters technique.

In order to solve initial value problems (IVP) functions @code{ic1} and
@code{ic2} are available for first and second order equations, and to
solve second-order boundary value problems (BVP) the function @code{bc2}
can be used.

Example:

@c ===beg===
@c x^2*'diff(y,x) + 3*y*x = sin(x)/x;
@c ode2(%,y,x);
@c ic1(%o2,x=%pi,y=0);
@c 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
@c ode2(%,y,x);
@c ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
@c bc2(%o5,x=0,y=1,x=1,y=3);
@c ===end===
@example
(%i1) @b{@t{x^2*'diff(y,x) + 3*y*x = sin(x)/x;}}
                      2 dy           sin(x)
(%o1)                x  -- + 3 x y = ------
                        dx             x
(%i2) @b{@t{ode2(%,y,x);}}
                             %c - cos(x)
(%o2)                    y = -----------
                                  3
                                 x
(%i3) @b{@t{ic1(%o2,x=%pi,y=0);}}
                              cos(x) + 1
(%o3)                   y = - ----------
                                   3
                                  x
(%i4) @b{@t{'diff(y,x,2) + y*'diff(y,x)^3 = 0;}}
                         2
                        d y      dy 3
(%o4)                   --- + y (--)  = 0
                          2      dx
                        dx
(%i5) @b{@t{ode2(%,y,x);}}
                      3
                     y  + 6 %k1 y
(%o5)                ------------ = x + %k2
                          6
(%i6) @b{@t{ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));}}
                             3
                          2 y  - 3 y
(%o6)                   - ---------- = x
                              6
(%i7) @b{@t{bc2(%o5,x=0,y=1,x=1,y=3);}}
                         3
                        y  - 10 y       3
(%o7)                   --------- = x - -
                            6           2

@end example

@c @opencatbox
@c @category{Differential equations}
@c @closecatbox
@end deffn

@c --- End of file Calculus.de.texi --------------------------------------------

