@c -----------------------------------------------------------------------------
@c File        : DataTypes.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : New file
@c Translation : Dr. Dieter Kaiser
@c Date        : 15.10.2010
@c Revision    : 18.02.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Maxima Zahlen::
* Zeichenketten::
* Funktionen und Variablen f@"ur Zahlen::
* Funktionen und Variablen f@"ur Zeichenketten::
* Funktionen und Variablen f@"ur Konstante::
* Funktionen und Variablen f@"ur Arrays::
* Einf@"uhrung in Listen::
* Funktionen und Variablen f@"ur Listen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Maxima Zahlen, Zeichenketten, Datentypen und -strukturen, Datentypen und -strukturen
@section Einf@"uhrung in Maxima Zahlen
@c -----------------------------------------------------------------------------

@subheading Ganze und rationale Zahlen

Arithmetische Rechnungen mit ganzen oder rationalen Zahlen sind exakt.
Prinzipell k@"onnen die ganzen und rationalen Zahlen eine beliebige Anzahl an 
Stellen haben.  Eine Obergrenze ist allein der zur Verf@"ugung stehende
Speicherplatz.

@example
(%i1) 1/3+5/4+3;
                               55
(%o1)                          --
                               12
(%i2) 100!;
(%o2) 9332621544394415268169923885626670049071596826438162146859\
2963895217599993229915608941463976156518286253697920827223758251\
185210916864000000000000000000000000
(%i3) 100!/101!;
                                1
(%o3)                          ---
                               101
@end example

Funktionen f@"ur ganze und rationale Zahlen:

@verbatim
   integerp       numberp       nonnegintegerp     
   oddp           evenp
   ratnump        rationalize
@end verbatim

@subheading Gleitkommazahlen

Maxima rechnet mit Gleitkommazahlen in doppelter Genauigkeit.  Weiterhin kann
Maxima mit gro@ss{}en Gleitkommazahlen rechnen, die prinzipell eine beliebige
Genauigkeit haben.

Gleitkommazahlen werden mit einem Dezimalpunkt eingegeben.  Der Exponent kann 
mit "f", "e" oder "d" angegeben werden.  Intern rechnet Maxima
ausschlie@ss{}lich mit Gleitkommazahlen in doppelter Genauigkeit, die immer mit
"e" f@"ur den Exponenten angezeigt werden.  Gro@ss{}e Gleitkommazahlen werden
mit dem Exponenten "b" bezeichnet.  Gro@ss{}- und Kleinschreibung werden bei der
Schreibweise des Exponenten nicht unterschieden.

@example
(%i1) [2.0,1f10,1,e10,1d10,1d300];
(%o1)        [2.0, 1.e+10, 1, e10, 1.e+10, 1.e+300]
(%i2) [2.0b0,1b10,1b300];
(%o2)               [2.0b0, 1.0b10, 1.0b300]
@end example

@noindent
Ist mindestens eine Zahl in einer Rechnung eine Gleitkommazahl, werden die 
Argumente in Gleitkommazahlen umgewandelt und eine Gleitkommazahl als Ergebnis
zur@"uckgegeben.  Dies wird auch f@"ur gro@ss{}e Gleitkommazahlen ausgef@"uhrt.

@example
(%i1) 2.0+1/2+3;
(%o1)                                 5.5
(%i2) 2.0b0+1/2+3;
(%o2)                                5.5b0
@end example

@noindent
Mit den Funktionen @mref{float} und @mref{bfloat} werden Zahlen in
Gleitkommazahlen und gro@ss{}e Gleitkommazahlen umgewandelt:

@example
(%i1) float([2,1/2,1/3,2.0b0]);
(%o1)          [2.0, 0.5, .3333333333333333, 2.0]
(%i2) bfloat([2,1/2,1/3,2.0b0]);
(%o2)     [2.0b0, 5.0b-1, 3.333333333333333b-1, 2.0b0]
@end example

@noindent
Funktionen und Variablen f@"ur Gleitkommazahlen:

@verbatim
   float        floatnump     
   bfloat       bfloatp       fpprec
   float2bf     bftorat       ratepsilon

   number_pbranch 
   m1pbranch
@end verbatim

@subheading Komplexe Zahlen

Maxima kennt keinen eigenen Typ f@"ur komplexe Zahlen.  Komplexe Zahlen werden 
von Maxima intern als die Addition von Realteil und dem mit der Imagin@"aren 
Einheit @mref{%i} multiplizierten Imagin@"arteil dargestellt.  Zum Beispiel sind
die komplexen Zahlen @code{2 + 3*%i} und @code{2 - 3*%i} die Wurzeln der 
Gleichung @code{x^2 - 4*x + 13 = 0}.

Maxima vereinfacht Produkte, Quotienten, Wurzeln und andere Ausdr@"ucke mit 
komplexen Zahlen nicht automatisch zu einer komplexen Zahl.  Um Produkte mit
komplexen Zahlen zu vereinfachen, kann der Ausdruck mit der Funktion 
@mref{expand} expandiert werden.

Funktionen f@"ur komplexe Zahlen:

@verbatim
   realpart     imagpart      rectform     polarform
   cabs         carg          conjugate    csign
@end verbatim

@c -----------------------------------------------------------------------------
@node Zeichenketten, Funktionen und Variablen f@"ur Zahlen, Einf@"uhrung in Maxima Zahlen, Datentypen und -strukturen
@section Zeichenketten
@c -----------------------------------------------------------------------------

Zeichenketten werden bei der Eingabe in Anf@"uhrungszeichen gesetzt.  Sie werden 
standardm@"a@ss{}ig ohne Anf@"uhrungszeichen ausgegeben.  Hat die 
Optionsvariable @mref{stringdisp} den Wert @code{true}, werden Zeichenketten mit
Anf@"uhrungszeichen dargestellt.

Zeichenketten k@"onnen jedes Zeichen einschlie@ss{}lich Tabulator-, 
Zeilenvorschub- oder Wagenr@"ucklauf-Zeichen enthalten.  Das Anf@"uhrungszeichen 
wird innerhalb einer Zeichenkette durch @code{\"} und der Backslash durch 
@code{\\} dargestellt.  Ein Backslash am Ende einer Eingabezeile erlaubt die
Fortsetzung einer Zeichenkette in der n@"achsten Zeile.  Maxima kennt keine 
weiteren Kombinationen mit einem Backslash.  Daher wird der Backslash an anderer
Stelle ignoriert.  Maxima kennt keine andere M@"oglichkeit, als spezielle
Zeichen wie ein Tabulator-, Zeilenvorschub- oder Wagenr@"ucklaufzeichen in einer
Zeichenkette darzustellen.

Maxima hat keinen Typ f@"ur ein einzelnes Zeichen.  Einzelne Zeichen werden
daher als eine Zeichenkette mit einem Zeichen dargestellt.  Folgende Funktionen
und Variablen arbeiten mit Zeichenketten:

@verbatim
   concat   sconcat   string   stringdisp
@end verbatim

@noindent
Das Zusatzpaket @nref{stringproc} enth@"alt eine umfangreiche Bibliothek an 
Funktionen f@"ur Zeichenketten.

Beispiele:

@example
(%i1) s_1 : "This is a string.";
(%o1)               This is a string.
(%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
(%o2) Embedded "double quotes" and backslash \ characters.
(%i3) s_3 : "Embedded line termination
in this string.";
(%o3) Embedded line termination
in this string.
(%i4) s_4 : "Ignore the \
line termination \
characters in \
this string.";
(%o4) Ignore the line termination characters in this string.
(%i5) stringdisp : false;
(%o5)                         false
(%i6) s_1;
(%o6)                   This is a string.
(%i7) stringdisp : true;
(%o7)                         true
(%i8) s_1;
(%o8)                  "This is a string."
@end example

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Zahlen, Funktionen und Variablen f@"ur Zeichenketten, Zeichenketten, Datentypen und -strukturen
@section Funktionen und Variablen f@"ur Zahlen
@c -----------------------------------------------------------------------------

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{bfloat}
@deffn {Funktion} bfloat (@var{expr})

Konvertiert alle Zahlen im Ausdruck @var{expr} in gro@ss{}e Gleitkommazahlen.
Die Anzahl der Stellen wird durch die Optionsvariable 
@mref{fpprec} spezifiziert.

Hat die Optionsvariable @mref{float2bf} den Wert @code{false}, gibt Maxima eine
Warnung aus, wenn eine Gleitkommazahl mit doppelter Genauigkeit in eine 
gro@ss{}e Gleitkommazahl umgewandelt wird.

Siehe auch die Funktion und den Auswertungsschalter @mref{float} f@"ur die
Umwandlung von Zahlen in Gleitkommazahlen mit doppelter Genauigkeit.

Beispiele:

@example
(%i1) bfloat([2, 3/2, 1.5]);
(%o1)                 [2.0b0, 1.5b0, 1.5b0]
(%i2) bfloat(sin(1/2));
(%o2)                  4.79425538604203b-1
(%i3) bfloat(%pi),fpprec:45;
(%o3)    3.1415926535897932384626433832795028841971694b0
@end example
@end deffn

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{bfloatp}
@deffn {Funktion} bfloatp (@var{expr})

Gibt den Wert @code{true} zur@"uck, wenn @var{expr} eine gro@ss{}e 
Gleitkommazahl ist, ansonsten den Wert @code{false}.

Siehe auch die Funktionen @mrefcomma{numberp} @mrefcomma{floatnump}@ 
@mref{ratnump} und @mrefdot{integerp}

Beispiele:

@example
(%i1) bfloatp(1.5b0);
(%o1)                         true
(%i2) a:bfloat(%e);
(%o2)                  2.718281828459045b0
(%i3) bfloatp(a);
(%o3)                         true
(%i4) bfloatp(1.5);
(%o4)                         false
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{bftorat}
@defvr {Optionsvariable} bftorat
Standardwert: @code{false}

@c TODO: DIE GENAUE FUNTIONSWEISE IST UNKKLAR.  ES FEHLT EIN BEISPIEL.

Die Optionsvariable @code{bftorat} kontrolliert die Umwandlung von gro@ss{}en
Gleitkommazahlen in rationale Zahlen.  Hat @code{bftorat} den Wert @code{true},
wird die Genauigkeit der Umwandlung von der Optionsvariablen @mref{ratepsilon}@ 
kontrolliert.  In diesem Fall ist das Ergebnis der Umwandlung eine relativ
kleine rationale Zahl.  Hat dagegen @code{bftorat} den Wert @code{false}, wird
die gro@ss{}e Gleitkommazahl exakt durch die rationale Zahl repr@"asentiert.
@end defvr

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{bftrunc}
@defvr {Optionsvariable} bftrunc
Standardwert: @code{true}

Hat die Optionsvariable @code{bftrunc} den Wert @code{true}, werden bei der
Ausgabe einer gro@ss{}en Gleitkommazahl nachfolgende Nullen nicht angezeigt.

Beispiele:

@example
(%i1) bftrunc:true;
(%o1)                         true
(%i2) bfloat(1);
(%o2)                         1.0b0
(%i3) bftrunc:false;
(%o3)                         false
(%i4) bfloat(1);
(%o4)                  1.000000000000000b0
@end example
@end defvr

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{evenp}
@deffn {Funktion} evenp (@var{expr})

Ist @var{expr} eine gerade ganze Zahl, wird @code{true} zur@"uckgegeben.  In 
allen anderen F@"allen wird @code{false} zur@"uckgegeben.

@code{evenp} gibt f@"ur Symbole oder Ausdr@"ucke immer den Wert @code{false} 
zur@"uck, auch wenn das Symbol als gerade ganze Zahl deklariert ist oder der 
Ausdruck eine gerade ganze Zahl repr@"asentiert.  Siehe die Funktion
@mrefcomma{featurep} um zu testen, ob ein Symbol oder Ausdruck eine gerade
ganze Zahl repr@"asentiert.

Beispiele:

@example
(%i1) evenp(2);
(%o1)                         true
(%i2) evenp(3);
(%o2)                         false
(%i3) declare(n, even);
(%o3)                         done
(%i4) evenp(n);
(%o4)                         false
(%i5) featurep(n, even);
(%o5)                         true
@end example
@end deffn

@c --- 08.03.2011 DK -----------------------------------------------------------
@anchor{float}
@deffn  {Funktion} float (@var{expr})
@deffnx {Optionsvariable} float

Die Funktion @code{float} konvertiert ganze, rationale und gro@ss{}e
Gleitkommazahlen, die im Argument @var{expr} enthalten sind, in Gleitkommazahlen
mit doppelter Genauigkeit.

@code{float} ist auch eine Optionsvariable mit dem Standardwert @code{false} und
ein Auswertungsschalter f@"ur die Funktion @mrefdot{ev}  Erh@"alt die
Optionsvariable @code{float} den Wert @code{true} werden rationale und gro@ss{}e
Gleitkommazahlen sofort in Gleitkommazahlen umgewandelt.  Als
Auswertungsschalter der Funktion @code{ev} hat @code{float} denselben Effekt,
ohne dass die Optionsvariable @code{float} ihren Wert @"andert.  Im Unterschied
zur Funktion @code{float} werden durch das Setzen der Optionsvariablen oder bei
Verwendung als Auswertungsschalter keine ganze Zahlen in Gleitkommazahlen
umgewandelt.  Daher k@"onnen die beiden Kommandos @code{ev(expr, float)} und
@code{float(expr)} ein unterschiedliches Ergebnis haben.

Siehe auch die Optionsvariable @mrefdot{numer}

Beispiele:

In den ersten zwei Beispielen werden die Zahlen @code{1/2} und @code{1} in eine
Gleitkommazahl umgewandelt.  Die Sinusfunktion vereinfacht sodann zu einem
numerischen Wert.  Das Auswertungsflag @code{float} wandelt ganze Zahlen nicht
in eine Gleitkommazahl um.  Daher wird @code{sin(1)} nicht zu einem numerischen
Wert vereinfacht.

@example
(%i1) float(sin(1/2));
(%o1)                   0.479425538604203
(%i2) float(sin(1));
(%o2)                   .8414709848078965
(%i3) sin(1/2),float;
(%o3)                   0.479425538604203
(%i4) sin(1),float;
(%o4)                        sin(1)
@end example
@end deffn

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{float2bf}
@defvr {Optionsvariable} float2bf
Standardwert: @code{true}
 
Hat die Optionsvariable @code{float2bf} den Wert @code{false}, wird eine
Warnung ausgegeben, wenn eine Gleitkommazahl in eine gro@ss{}e Gleitkommazahl 
umgewandelt wird, da die Umwandlung zu einem Verlust an Genauigkeit f@"uhren 
kann.

Beispiel:

@example
(%i1) float2bf:true;
(%o1)                         true
(%i2) bfloat(1.5);
(%o2)                         1.5b0
(%i3) float2bf:false;
(%o3)                         false
(%i4) bfloat(1.5);
bfloat: converting float 1.5 to bigfloat.
(%o4)                         1.5b0
@end example
@end defvr

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{floatnump}
@deffn {Funktion} floatnump (@var{number})

Gibt den Wert @code{true} zur@"uck, wenn das Argument @var{number} eine 
Gleitkommazahl ist.  Ansonsten wird @code{false} zur@"uckgegeben.  Auch wenn 
@var{number} eine gro@ss{}e Gleitkommazahl ist, ist das Ergebnis @code{false}.

Siehe auch die Funktionen @mrefcomma{numberp} @mrefcomma{bfloatp}@ 
@mref{ratnump} und @mrefdot{integerp}

Beispiele:

@example
(%i1) floatnump(1.5);
(%o1)                         true
(%i2) floatnump(1.5b0);
(%o2)                         false
@end example
@end deffn

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{fpprec}
@defvr {Optionsvariable} fpprec
Standardwert: 16

@code{ffprec} ist die Zahl der Stellen f@"ur das Rechnen mit gro@ss{}en 
Gleitkommazahlen.  @code{ffprec} hat keinen Einflu@ss{} auf das Rechnen mit
Gleitkommazahlen in doppelter Genauigkeit.  Siehe auch @mref{bfloat} und 
@mrefdot{fpprintprec}

Beispiele:

@example
(%i1) fpprec:16;
(%o1)                          16
(%i2) bfloat(%pi);
(%o2)                  3.141592653589793b0
(%i3) fpprec:45;
(%o3)                          45
(%i4) bfloat(%pi);
(%o4)    3.1415926535897932384626433832795028841971694b0
(%i5) sin(1.5b0);
(%o5)   9.97494986604054430941723371141487322706651426b-1
@end example
@end defvr

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{fpprintprec}
@defvr {Optionsvariable} fpprintprec
Standardwert: 0

@code{fpprintprec} ist die Anzahl der Stellen, die angezeigt wird, wenn eine
Gleitkommazahl ausgegeben wird.

Hat @code{fpprintprec} einen Wert zwischen 2 und 16, ist die Anzahl der 
angezeigten Stellen f@"ur einfache Gleitkommazahlen gleich dem Wert von 
@code{fpprintprec}.  Hat @code{fpprintprec} den Wert 0 oder ist gr@"o@ss{}er als
16 werden 16 Stellen angezeigt.

Hat f@"ur gro@ss{}e Gleitkommazahlen @code{fpprintprec} einen Wert zwischen 2 
und @mrefcomma{fpprec} ist die Anzahl der angezeigten Stellen gleich
@code{fpprintprec}.  Ist der Wert von @code{fpprintprec} gleich 0 oder 
gr@"o@ss{}er als @code{fpprec} werden @code{fpprec} Stellen angezeigt.

@code{fpprintprec} kann nicht den Wert 1 erhalten.

Beispiele:

@example
(%i1) fpprec:16;
(%o1)                          16
(%i2) fpprintprec:5;
(%o2)                           5
(%i3) float(%pi);
(%o3)                        3.1416
(%i4) bfloat(%pi);
(%o4)                       3.1415b0
(%i5) fpprintprec:25;
(%o5)                          25
(%i6) bfloat(%pi);
(%o6)                  3.141592653589793b0
(%i7) bfloat(%pi);
(%o7)                  3.141592653589793b0
(%i8) fpprec:45;
(%o8)                          45
(%i9) bfloat(%pi);
(%o9)             3.141592653589793238462643b0
(%i10) fpprintprec:45;
(%o10)                         45
(%i11) bfloat(%pi);
(%o11)   3.1415926535897932384626433832795028841971694b0
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{integerp}
@deffn {Funktion} integerp (@var{number})

Hat den R@"uckgabewert @code{true}, wenn das Argument @var{number} eine ganze 
Zahl ist.  In allen anderen F@"allen gibt @code{integerp} den Wert @code{false} 
zur@"uck.

@code{integerp} gibt f@"ur Symbole oder Ausdr@"ucke immer den Wert @code{false} 
zur@"uck, auch wenn das Symbol als ganze Zahl deklariert ist oder der Ausdruck 
eine ganze Zahl repr@"asentiert.  Siehe die Funktion @mrefcomma{featurep} um zu
testen, ob ein Symbol oder Ausdruck eine ganze Zahl repr@"asentiert.

Beispiele:

@example
(%i1) integerp (1);
(%o1)                         true
(%i2) integerp (1.0);
(%o2)                         false
(%i3) integerp (%pi);
(%o3)                         false
(%i4) declare (n, integer)$
(%i5) integerp (n);
(%o5)                         false
@end example
@end deffn

@c --- 08.10.2010 --------------------------------------------------------------
@anchor{m1pbranch}
@defvr {Optionsvariable} m1pbranch
Standardwert: @code{false}

Die Optionsvariable @code{m1pbranch} kontrolliert die Vereinfachung der
Exponentiation von @code{-1} f@"ur den Fall, dass die Optionsvariable
@mref{domain} den Wert @code{complex} hat.  Hat @code{m1pbranch} f@"ur diesen
Fall den Wert @code{true}, wird die Exponentiation von @code{-1} zu einem
Ausdruck vereinfacht, der dem Hauptwert entspricht.  Die Auswirkung der
Optionsvariable @code{m1pbranch} ist in der folgenden Tabelle gezeigt.

@example
@group
              domain:real
                            
(-1)^(1/3):      -1         
(-1)^(1/4):   (-1)^(1/4)   

             domain:complex              
m1pbranch:false          m1pbranch:true
(-1)^(1/3)               1/2+%i*sqrt(3)/2
(-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2
@end group
@end example

Siehe auch die Optionsvariable @mrefdot{numer_pbranch}
@end defvr

@c --- 17.02.2011 DK -----------------------------------------------------------
@anchor{nonnegintegerp}
@deffn {Funktion} nonnegintegerp (@var{number})

Gibt den Wert @code{true} zur@"uck, wenn @code{number} eine ganze positive Zahl
oder Null ist.  Siehe auch @mrefdot{integerp}

Beispiele:

@example
(%i1) nonnegintegerp(2);
(%o1)                         true
(%i2) nonnegintegerp(-2);
(%o2)                         false
@end example
@end deffn

@c --- 21.08.2010 --------------------------------------------------------------
@anchor{numberp}
@deffn {Funktion} numberp (@var{number})

Hat das Ergebnis @code{true}, wenn @var{number} eine ganze, rationale, eine
Gleitkommazahl oder eine gro@ss{}e Gleitkommazahl ist.  Ansonsten ist das 
Ergebnis @code{false}.

@code{numberp} gibt f@"ur ein Symbol immer das Ergebnis @code{false} zur@"uck.
Dies ist auch dann der Fall, wenn das Symbol eine numerische Konstante wie 
@mref{%pi} ist oder wenn das Symbol mit der Funktion @mref{declare} eine 
Eigenschaft wie @mrefcomma{integer} @mref{real} oder @mref{complex} erhalten
hat.

Beispiele:

@example
(%i1) numberp (42);
(%o1)                         true
(%i2) numberp (-13/19);
(%o2)                         true
(%i3) numberp (3.14159);
(%o3)                         true
(%i4) numberp (-1729b-4);
(%o4)                         true
(%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
(%o5)      [false, false, false, false, false, false]
(%i6) declare(a,even, b,odd, c,integer, d,rational, e,real);
(%o6)                         done
(%i7) map (numberp, [a, b, c, d, e]);
(%o7) [false, false, false, false, false]
@end example
@end deffn

@c --- 08.03.2011 DK -----------------------------------------------------------
@anchor{numer}
@defvr {Optionsvariable} numer
Standardwert: @code{false}

Hat die Optionsvariable @code{numer} den Wert @code{true}, werden rationale
Zahlen und gro@ss{}e Gleitkommazahlen in Gleitkommazahlen umgewandelt.
Weiterhin werden Konstante wie zum Beispiel @mrefcomma{%pi} die einen
numerischen Wert haben, durch diesen ersetzt.  Mathematische Funktionen mit
numerischen Argumenten vereinfachen zu einer Gleitkommazahl.  Wird die
Optionsvariable @code{numer} gesetzt, erh@"alt die Optionsvariable
@mref{float} denselben Wert.  Im Unterschied zur Optionsvariablen @code{float}
vereinfachen auch mathematische Funktionen mit einem ganzzahligen Wert wie zum
Beispiel @code{sin(1)} zu einem numerischen Wert.

@code{numer} ist auch ein Auswertungsschalter der Funktion @mrefdot{ev}  Der
Auswertungsschalter hat die gleiche funktionsweise wie die Optionsvariable, 
ohne dass die Optionsvariable ihren Wert @"andert.

Siehe auch @mref{float} und @mrefdot{%enumer}

Beispiele:

Erh@"alt @code{numer} den Wert @code{true}, werden rationale Zahlen, Konstante
mit einem numerischen Wert und mathematische Funktionen mit numerischen
Argumenten zu einer Gleitkommazahl ausgewertet oder vereinfacht.

@example
(%i1) numer:false;
(%o1)                         false
(%i2) [1, 1/3, %pi, sin(1)];
                           1
(%o2)                  [1, -, %pi, sin(1)]
                           3
(%i3) numer:true;
(%o3)                         true
(%i4) [1, 1/3, %pi, sin(1)];
(%o4) [1, .3333333333333333, 3.141592653589793, 
                                               .8414709848078965]
@end example

@code{numer} ist auch ein Auswertungsschalter der Funktion @code{ev}.  Hier wird
die Kurzschreibweise der Funktion @code{ev} verwendet.

@example
(%i1) [sqrt(2), sin(1), 1/(1+sqrt(3))];
                                        1
(%o1)            [sqrt(2), sin(1), -----------]
                                   sqrt(3) + 1

(%i2) [sqrt(2), sin(1), 1/(1+sqrt(3))],numer;
(%o2) [1.414213562373095, .8414709848078965, .3660254037844387]
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{numer_pbranch}
@defvr {Optionsvariable} numer_pbranch
Standardwert: @code{false}

Die Optionsvariable @code{numer_pbranch} kontrolliert die Vereinfachung der
Exponentiation einer negativen ganzen, rationalen oder Gleitkommazahl.
Hat @code{numer_pbranch} den Wert @code{true} und ist der Exponent eine 
Gleitkommazahl oder hat die Optionsvariable @mref{numer} den Wert @code{true}, 
dann berechnet Maxima den Hauptwert der Exponentiation.  Ansonsten wird ein 
vereinfachter Ausdruck, aber nicht numerischer Wert zur@"uckgegeben.  Siehe auch
die Optionsvariable @mrefdot{m1pbranch}

Beispiele:

@example
(%i1) (-2)^0.75;
(%o1) (-2)^0.75

(%i2) (-2)^0.75,numer_pbranch:true;
(%o2) 1.189207115002721*%i-1.189207115002721

(%i3) (-2)^(3/4);
(%o3) (-1)^(3/4)*2^(3/4)

(%i4) (-2)^(3/4),numer;
(%o4) 1.681792830507429*(-1)^0.75

(%i5) (-2)^(3/4),numer,numer_pbranch:true;
(%o5) 1.189207115002721*%i-1.189207115002721
@end example
@end defvr

@c --- 08.03.2011 DK -----------------------------------------------------------
@anchor{numerval}
@deffn {Funktion} numerval (@var{x_1}, @var{expr_1}, @dots{}, @var{var_n}, @var{expr_n})

Die Variablen @code{x_1}, @dots{}, @code{x_n} erhalten die numerischen Werte
@code{expr_1}, ..., @code{expr_n}.  Die numerischen Werte werden immer dann
f@"ur die Variablen in Ausdr@"ucke eingesetzt, wenn der Schalter @mref{numer}
den Wert @code{true} hat.  Siehe auch @mrefdot{ev}

Die Ausdr@"ucke @code{expr1_1}, ..., @code{expr_n} k@"onnen auch Ausdr@"ucke
sein und m@"ussen nicht numerische Werte sein.

Beispiele:

@example
(%i1) numerval(a, 123, b, x^2)$

(%i2) [a, b];
(%o2)                        [a, b]
(%i3) numer:true;
(%o3)                         true
(%i4) [a, b];
                                   2
(%o4)                       [123, x ]
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{oddp}
@deffn {Funktion} oddp (@var{expr})

Gibt @code{true} zur@"uck, wenn @var{expr} eine ungerade ganze Zahl ist.  In 
allen anderen F@"allen wird @code{false} zur@"uckgegeben.

@code{oddp} gibt f@"ur Symbole oder Ausdr@"ucke immer den Wert @code{false} 
zur@"uck, auch wenn das Symbol als ungerade ganze Zahl deklariert ist oder der 
Ausdruck eine ungerade ganze Zahl repr@"asentiert.  Siehe die Funktion 
@mrefcomma{featurep} um zu testen, ob ein Symbol oder Ausdruck eine ungerade 
ganze Zahl repr@"asentiert.

Beispiele:

@example
(%i1) oddp(3);
(%o1)                         true
(%i2) oddp(2);
(%o2)                         false
(%i3) declare(n,odd);
(%o3)                         done
(%i4) oddp(n);
(%o4)                         false
(%i5) featurep(n,odd);
(%o5)                         true
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{ratepsilon}
@defvr {Optionsvariable} ratepsilon
Standardwert: 2.0e-8

@code{ratepsilon} kontrolliert die Genauigkeit, mit der Gleitkommazahlen in
rationale Zahlen umgewandelt werden.  Siehe auch @mrefdot{bftorat}

@c TODO: HIER FEHLT EIN BEISPIEL
@end defvr

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{rationalize}
@deffn {Funktion} rationalize (@var{expr})

Konvertiert alle Gleitkommazahlen einschlie@ss{}lich gro@ss{}er 
Gleitkommazahlen, die in dem Ausdruck @var{expr} auftreten, in rationale Zahlen.

Es mag @"uberraschend sein, dass @code{rationalize(0.1)} nicht das Ergebnis
@code{1/10} hat.  Dies ist nicht speziell f@"ur Maxima.  Ursache ist, dass die 
gebrochene Zahl @code{1/10} in der internen Darstellung als bin@"are Zahl keine
endliche Darstellung hat.

Siehe auch die Funktion @mref{float} sowie die Auswertungsschalter
@mref{float} und @mrefcomma{numer} um eine rationale Zahl in eine Gleitkommazahl
umzuwandeln.

Beispiele:

@example
(%i1) rationalize (0.5);
                                1
(%o1)                           -
                                2
(%i2) rationalize (0.1);
                        3602879701896397
(%o2)                   -----------------
                        36028797018963968
(%i3) fpprec : 5$
(%i4) rationalize (0.1b0);
                             209715
(%o4)                        -------
                             2097152
(%i5) fpprec : 20$
@group
(%i6) rationalize (0.1b0);
                     236118324143482260685
(%o6)                ----------------------
                     2361183241434822606848
@end group
(%i7) rationalize (sin (0.1*x + 5.6));
               3602879701896397 x   3152519739159347
(%o7)      sin(------------------ + ----------------)
               36028797018963968    562949953421312

(%i8) float(%);
(%o8)                          sin(0.1 x + 5.6)
@end example
@end deffn

@c --- 08.10.2010 DK -----------------------------------------------------------
@anchor{ratnump}
@deffn {Funktion} ratnump (@var{number})

Gibt @code{true} zur@"uck, wenn @var{number} eine ganze oder rationale Zahl ist.
In allen anderen F@"allen ist das Ergebnis @code{false}.

Beispiele:

@example
(%i1) ratnump(1/2);
(%o1)                         true
(%i2) ratnump(3);
(%o2)                         true
(%i3) ratnump(3.0);
(%o3)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Zeichenketten, Funktionen und Variablen f@"ur Konstante, Funktionen und Variablen f@"ur Zahlen, Datentypen und -strukturen
@section Funktionen und Variablen f@"ur Zeichenketten
@c -----------------------------------------------------------------------------

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{concat}
@deffn {Funktion} concat (@var{arg_1}, @var{arg_2}, @dots{})

Verkettet die Argumente @var{arg_1}, @var{arg_2}, @dots{} zu einer Zeichenkette 
oder einem Symbol.  Die Argumente m@"ussen sich zu einem Atom auswerten lassen.
Der R@"uckgabewert ist ein Symbol, wenn das erste Argument ein Symbol ist.
Ansonsten wird eine Zeichenkette zur@"uckgegeben.

@code{concat} wertet die Argumente aus.  Der Quote-Operator verhindert die
Auswertung.  Siehe auch die Funktion @mrefdot{sconcat}

Beispiele:

@example
(%i1) y: 7$
(%i2) z: 88$
(%i3) stringdisp:true$
(%i4) concat(y, z/2);
(%o4)                         "744"
(%i5) concat('y, z/2);
(%o5)                          y44
@end example

Einem Symbol, das mit @code{concat} konstruiert wird, kann ein Wert zugewiesen
werden und es kann in Ausdr@"ucken auftreten.

@example
(%i6) a: concat ('y, z/2);
(%o6)                          y44
@group
(%i7) a:: 123;
(%o7)                          123
@end group
(%i8) y44;
(%o8)                          123
(%i9) b^a;
                               y44
(%o9)                         b
(%i10) %, numer;
                                123
(%o11)                         b
@end example

@code{concat(1, 2)} gibt eine Zeichenkette als Ergebnis zur@"uck.

@example
(%i12) concat (1, 2) + 3;
(%o12)                       "12" + 3
@end example
@end deffn

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{sconcat}
@deffn {Funktion} sconcat (@var{arg_1}, @var{arg_2}, @dots{})

Verkettet die Argumente @var{arg_1}, @var{arg_2}, @dots{} zu einer Zeichenkette.
Im Unterschied zu der Funktion @mref{concat} m@"ussen die Argumente @i{nicht} 
Atome sein.  Der R@"uckgabewert ist eine Zeichenkette.

Beispiel:

@example
(%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
(%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{string}
@deffn {Funktion} string (@var{expr})

Konvertiert @code{expr} in eine lineare Darstellung, wie sie auch vom Parser
von der Eingabe eingelesen wird.  Die R@"uckgabe von @code{string} ist eine
Zeichenkette.  Diese kann nicht f@"ur eine Berechnung genutzt werden.

@example
(%i1) stringdisp:true;
(%o1)                         true
(%i2) string(expand((a+b)^2));
(%o2)                    "b^2+2*a*b+a^2"
(%i3) stringp(%);
(%o3)                         true
@end example
@end deffn

@c TODO: DIE FOLGENDE FUNKTION IN DAS KAPITEL KOMMANDOZEILE VERSCHIEBEN ???

@c --- 28.08.2010 DK -----------------------------------------------------------
@anchor{stringdisp}
@defvr {Optionsvariable} stringdisp
Standardwert: @code{false}

Hat @code{stringdisp} den Wert @code{true}, werden Zeichenketten mit
Anf@"uhrungszeichen ausgegeben.  Ansonsten werden keine Anf@"uhrungszeichen
ausgegeben.

Wird die Definition einer Funktion ausgegeben, werden enthaltene Zeichenketten
unabh@"angig vom Wert der Optionsvariablen @code{stringdisp} immer in 
Anf@"uhrungszeichen ausgegeben.

Beispiele:

@example
(%i1) stringdisp: false$
(%i2) "This is an example string.";
(%o2)              This is an example string.
(%i3) foo () :=
      print ("This is a string in a function definition.");
(%o3) foo() := 
              print("This is a string in a function definition.")
(%i4) stringdisp: true$
(%i5) "This is an example string.";
(%o5)             "This is an example string."
@end example
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Konstante,  Funktionen und Variablen f@"ur Arrays, Funktionen und Variablen f@"ur Zeichenketten, Datentypen und -strukturen
@section Funktionen und Variablen f@"ur Konstante
@c -----------------------------------------------------------------------------

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{%e}
@defvr {Konstante} %e
@ifinfo
@vrindex e
@vrindex Eulersche Zahl
@vrindex Basis des nat@"urlichen Logarithmus
@end ifinfo

@code{%e} ist die Basis des nat@"urlichen Logarithmus, auch Eulersche Zahl 
genannt.  Der numerische Wert der Konstanten als Gleitkommazahl mit doppelter
Genauigkeit ist 2.718281828459045d0.

Die Funktion @mref{bfloat} kann @code{%e} mit einer beliebigen Genauigkeit
berechnen.

Beispiel:

@example
(%i1) fpprec:48$
(%i2) bfloat(%e);
(%o2)  2.7182818284590452353602874713526624977572470937b0
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{%i}
@defvr {Konstante} %i
@ifinfo
@vrindex i
@vrindex Imagin@"are Einheit
@end ifinfo

@code{%i} ist die imagin@"are Einheit.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{false}
@defvr {Konstante} false

Repr@"asentiert den logischen Wert @code{falsch}.  @code{false} wird intern von 
Maxima durch die Lisp-Konstante @code{NIL} dargestellt.
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{%gamma}
@defvr {Konstante} %gamma
@ifinfo
@vrindex Euler-Mascheroni-Konstante
@end ifinfo

Die Euler-Mascheroni-Konstante mit dem Wert @code{0.5772156649015329} als
Gleitkommazahl in doppelter Genauigkeit.

Die Funktion @mref{bfloat} kann @code{%gamma} mit einer beliebigen Genauigkeit
berechnen.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{ind}
@defvr {Konstante} ind
@ifinfo
@vrindex Unbestimmt
@end ifinfo

@code{ind} repr@"asentiert ein unbestimmtes Ergebnis.  Siehe auch 
@mrefdot{limit}

Beispiel:

@example
(%i1) limit (sin(1/x), x, 0);
(%o1)                          ind
@end example
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{inf}
@defvr {Konstante} inf
@ifinfo
@vrindex positiv unendlich
@end ifinfo

@code{inf} repr@"asentiert einen positiven unendlich gro@ss{}en Wert.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{infinity}
@defvr {Konstante} infinity
@ifinfo
@vrindex komplex unendlich
@end ifinfo

@code{infinity} repr@"asentiert einen komplexen unendlichen Wert.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{minf}
@defvr {Konstante} minf
@ifinfo
@vrindex negativ unendlich
@vrindex minus unendlich
@end ifinfo

@code{minf} repr@"asentiert einen negativen unendlichen Wert.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{%phi}
@defvr {Konstante} %phi
@ifinfo
@vrindex phi
@vrindex Goldene Zahl
@end ifinfo

@code{%phi} repr@"asentiert die @i{Goldene Zahl} @math{(1 + sqrt(5))/2}.  Der
Gleitkommawert in doppelter Genauigkeit ist 1.618033988749895d0.

Die Funktion @mref{fibtophi} dr@"uckt Fibonacci-Zahlen @code{fib(n)} durch die
Goldene Zahl @code{%phi} aus.  Stan@-dard@-m@"a@ss{}ig kennt Maxima keine
algebraischen Eigenschaften der Konstanten @code{%phi}.  Mit den Eingaben
@code{tellrat, tellrat(%phi^2-%phi-1)} und @code{algebraic, algebraic:true} kann
die Funktion @mref{ratsimp} einige Vereinfachungen ausf@"uhren.

Beispiele:

@code{fibtophi} dr@"uckt Fibonacci-Zahlen @code{fib(n)} durch @code{%phi} aus.

@example
(%i1) fibtophi (fib (n));
                           n             n
                       %phi  - (1 - %phi)
(%o1)                  -------------------
                           2 %phi - 1
(%i2) fib (n-1) + fib (n) - fib (n+1);
(%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
(%i3) fibtophi (%);
@group
            n + 1             n + 1       n             n
        %phi      - (1 - %phi)        %phi  - (1 - %phi)
(%o3) - --------------------------- + -------------------
                2 %phi - 1                2 %phi - 1
                                          n - 1             n - 1
                                      %phi      - (1 - %phi)
                                    + ---------------------------
                                              2 %phi - 1
@end group
(%i4) ratsimp (%);
(%o4)                           0
@end example

Mit den Eingaben @code{tellrat(%phi^2-%phi-1)} und @code{algebraic:true} kann 
die Funktion @code{ratsimp} einige Vereinfachungen f@"ur Ausdr@"ucke 
ausf@"uhren, die @code{%phi} enthalten.

@example
(%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                 2                      2
(%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
(%i2) ratsimp (e);
                  2                     2
(%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
(%i3) tellrat (%phi^2 - %phi - 1);
                            2
(%o3)                  [%phi  - %phi - 1]
(%i4) algebraic : true;
(%o4)                         true
(%i5) ratsimp (e);
(%o5)                           0
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{%pi}
@defvr {Konstante} %pi
@ifinfo
@vrindex Pi
@end ifinfo

@code{%pi} repr@"asentiert die Kreiszahl.  Der numerische Wert in doppelter
Gleitkommagenauigkeit ist @code{3.141592653589793d0}.

Die Funktion @mref{bfloat} kann @code{%pi} mit einer beliebigen Genauigkeit
berechnen.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{true}
@defvr {Konstante} true

@code{true} repr@"asentiert den logischen Wert @code{wahr}.  Intern ist 
@code{true} als die Lisp-Konstante @code{T} implementiert.
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{und}
@defvr {Konstante} und
@ifinfo
@vrindex nicht definiert
@end ifinfo

@code{und} repr@"asentiert ein nicht definiertes Ergebnis.  Siehe auch 
@mrefdot{limit}

Beispiel:

@example
(%i1) limit (x*sin(x), x, inf);
(%o1)                          und
@end example
@end defvr

@c --- 21.08.2010 DK -----------------------------------------------------------
@anchor{zeroa}
@defvr {Konstante} zeroa

@code{zeroa} repr@"asentiert eine positive unendlich kleine Zahl.  @code{zeroa}
kann in Ausdr@"ucken benutzt werden.  Die Funktion @code{limit} vereinfacht
Ausdr@"ucke, die infinitesimale Gr@"o@ss{}en enthalten.

Siehe auch @mref{zerob} und @mrefdot{limit}

Beispiele:

@code{limit} vereinfacht Ausdr@"ucke, die infinitesimale Gr@"o@ss{}en enthalten:

@example
(%i1) limit(zeroa);
(%o1)                           0
(%i2) limit(x+zeroa);
(%o2)                           x
@end example
@end defvr

@c --- 15.10.2010 DK -----------------------------------------------------------
@anchor{zerob}
@defvr {Konstante} zerob

@code{zerob} repr@"asentiert eine negative unendlich kleine Zahl.  @code{zerob}
kann in Ausdr@"ucken benutzt werden.  Die Funktion @code{limit} vereinfacht
Ausdr@"ucke, die infinitesimale Gr@"o@ss{}en enthalten.

Siehe auch @mref{zeroa} und @mrefdot{limit}
@end defvr

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Arrays, Einf@"uhrung in Listen, Funktionen und Variablen f@"ur Konstante, Datentypen und -strukturen
@section Funktionen und Variablen f@"ur Arrays
@c -----------------------------------------------------------------------------

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{array}
@deffn  {Funktion} array (@var{name}, @var{dim_1}, @dots{}, @var{dim_n})
@deffnx {Funktion} array (@var{name}, @var{type}, @var{dim_1}, @dots{}, @var{dim_n})
@deffnx {Funktion} array ([@var{name_1}, @dots{}, @var{name_m}], @var{dim_1}, @dots{}, @var{dim_n})

Erzeugt ein @math{n}-dimensionales Array.  @math{n} kann kleiner oder gleich 5 
Dimensionen sein.  Die Indizes der @math{i}-ten Dimension sind ganze Zahlen
in einem Bereich von 0 bis @var{dim_i}.

@code{array(@var{name}, @var{dim_1}, ..., @var{dim_n})} erzeugt ein allgemeines 
Array.

@code{array(@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})} erzeugt 
ein Array mit Elementen, die vom Typ @var{type} sind.  @var{type} kann 
@code{fixnum} f@"ur ganze Zahlen oder @code{flonum} f@"ur Gleitkommazahlen sein.
 
@code{array([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})}
erzeugt @math{m} Arrays, die alle die gleiche Dimension haben.

Wird einer indizierten Variablen ein Wert zugewiesen, bevor das entsprechende
Array definiert wird, so wird ein undeklariertes Array erzeugt.  Undeklarierte
Arrays, auch Hashed-Arrays genannt, sind allgemeiner als deklarierte Arrays.
Diese Arrays haben keine feste Gr@"o@ss{}e und wachsen dynamisch mit der 
Zuweisung von Werten.  Die Indizes eines undeklarierten Arrays m@"ussen keine 
ganze Zahlen sein.  Deklarierte Arrays sind im Allgemeinen effizienter, 
so dass Arrays falls m@"oglich deklariert werden sollten.  Die Funktion 
@code{array} kann genutzt werden, um ein undeklariertes Array in ein 
deklariertes Array umzuwandeln.

Beispiele:

Es werden zwei verschiedene Arrays definiert.  Im ersten Fall erh@"alt das Array
keinen Typ.  Elemente, denen noch kein Wert zugewiesen wurde, werden mit dem
Symbol @code{#####} initialisiert.  Im zweiten Fall ist das Array vom Typ 
@code{fixnum}.  Jetzt wird das Array mit dem Wert @code{0} initialisiert.

@example
(%i1) array(a, 2, 2);
(%o1)                           a
(%i2) a[0,0]: 0; a[1,1]:11; a[2,2]:22;
(%o2)                           0
(%o3)                          11
(%o4)                          22
(%i5) listarray(a);
(%o5) [0, #####, #####, #####, 11, #####, #####, #####, 22]
(%i6) array(b, fixnum, 2, 2);
(%o6)                           b
(%i7) b[0,0]: 0; b[1,1]:11; b[2,2]:22;
(%o7)                           0
(%o8)                          11
(%o9)                          22
(%i10) listarray(b);
(%o10)            [0, 0, 0, 0, 11, 0, 0, 0, 22]
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{arrayapply}
@deffn {Funktion} arrayapply (@var{A}, [@var{i_1}, @dots{}, @var{i_n}])

Wertet @code{@var{A}[@var{i_1}, ... , @var{i_n}]} aus, wobei @var{A} ein Array
und @var{i_1}, @dots{}, @var{i_n} die Indizes eines Array-Elementes sind.

Beispiele:

@example
(%i1) arrayapply('a,[x, y]);
(%o1)                         a
                               x, y
(%i2) arrayapply('a,[1, 2, 3]);
(%o2)                       a
                             1, 2, 3
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{arrayinfo}
@deffn {Funktion} arrayinfo (@var{A})

Gibt Information @"uber das Array @var{A} zur@"uck.  Das Argument @var{A} kann
ein deklariertes oder ein undeklariertes Array sowie eine Array-Funktion oder
eine indizierte Funktion sein.

F@"ur ein deklarierte Array gibt @code{arryinfo} eine Liste zur@"uck, die 
@code{declared}, die Zahl der Dimensionen und die Gr@"o@ss{}e der Dimensionen 
enh@"alt.  Die Elemente des Arrays werden von der Funktion @mref{listarray}@ 
zur@"uckgegeben.

F@"ur ein undeklariertes Array (Hashed-Array) gibt @code{arrayinfo} eine Liste
zur@"uck, die @code{hashed}, die Zahl der Indizes und die Indizes enth@"alt,
deren Elemente einen Wert haben.  Die Werte der Elemente werden mit der Funktion 
@mref{listarray} zur@"uckgegeben.

F@"ur Array-Funktionen gibt @code{arrayinfo} eine Liste zur@"uck, die 
@code{hashed} die Zahl der Indizes und die Indizes enth@"alt, f@"ur die 
Funktionen im Array enthalten sind.  Die Funktionen werden mit der Funktion 
@mref{listarray} angezeigt.

F@"ur indizierte Funktionen gibt @code{arrayinfo} eine Liste zur@"uck, die 
@code{hashed}, die Zahl der Indizes und die Indizies enth@"alt, f@"ur die 
Lambda-Ausdr@"ucke vorhanden sind.  Die Lambda-Ausdr@"ucke werden von der 
Funktion @mref{listarray} angezeigt.

Beispiele:

@code{arrayinfo} und @code{listarray} angewendet auf ein deklariertes Array.

@example
@group
(%i1) array (aa, 2, 3);
(%o1)                          aa
@end group
@group
(%i2) aa [2, 3] : %pi;
(%o2)                          %pi
@end group
@group
(%i3) aa [1, 2] : %e;
(%o3)                          %e
@end group
@group
(%i4) arrayinfo (aa);
(%o4)                 [declared, 2, [2, 3]]
@end group
@group
(%i5) listarray (aa);
(%o5) [#####, #####, #####, #####, #####, #####, %e, #####, 
                                        #####, #####, #####, %pi]
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf ein undeklariertes Array.

@example
@group
(%i1) bb [FOO] : (a + b)^2;
                                   2
(%o1)                       (b + a)
@end group
@group
(%i2) bb [BAR] : (c - d)^3;
                                   3
(%o2)                       (c - d)
@end group
@group
(%i3) arrayinfo (bb);
(%o3)               [hashed, 1, [BAR], [FOO]]
@end group
@group
(%i4) listarray (bb);
                              3         2
(%o4)                 [(c - d) , (b + a) ]
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf eine Array-Funktion.

@example
@group
(%i1) cc [x, y] := y / x;
                                     y
(%o1)                      cc     := -
                             x, y    x
@end group
@group
(%i2) cc [u, v];
                                v
(%o2)                           -
                                u
@end group
@group
(%i3) cc [4, z];
                                z
(%o3)                           -
                                4
@end group
@group
(%i4) arrayinfo (cc);
(%o4)              [hashed, 2, [4, z], [u, v]]
@end group
@group
(%i5) listarray (cc);
                              z  v
(%o5)                        [-, -]
                              4  u
@end group
@end example

@code{arrayinfo} und @code{listarray} angewendet auf eine indizierte Funktion.

@example
@group
(%i1) dd [x] (y) := y ^ x;
                                     x
(%o1)                     dd (y) := y
                            x
@end group
@group
(%i2) dd [a + b];
                                    b + a
(%o2)                  lambda([y], y     )
@end group
@group
(%i3) dd [v - u];
                                    v - u
(%o3)                  lambda([y], y     )
@end group
@group
(%i4) arrayinfo (dd);
(%o4)             [hashed, 1, [b + a], [v - u]]
@end group
@group
(%i5) listarray (dd);
                         b + a                v - u
(%o5)      [lambda([y], y     ), lambda([y], y     )]
@end group
@end example
@end deffn

@c --- 18.02.2011 DK -----------------------------------------------------------
@anchor{arraymake}
@deffn {Funktion} arraymake (@var{A}, [@var{i_1}, @dots{}, @var{i_n}])

Gibt den Ausdruck @code{@var{A}[@var{i_1}, ..., @var{i_n}]} zur@"uck.  Das 
Ergebnis ist eine nicht ausgewertete Referenz auf ein Element des Arrays.

@code{arraymake} entspricht der Funktion @mrefdot{funmake}

Beispiele:

@example
@group
(%i1) arraymake (A, [1]);
(%o1)                          A
                                1
@end group
@group
(%i2) arraymake (A, [k]);
(%o2)                          A
                                k
@end group
@group
(%i3) arraymake (A, [i, j, 3]);
(%o3)                       A
                             i, j, 3
@end group
@group
(%i4) array (A, fixnum, 10);
(%o4)                           A
@end group
@group
(%i5) fillarray (A, makelist (i^2, i, 1, 11));
(%o5)                           A
@end group
@group
(%i6) arraymake (A, [5]);
(%o6)                          A
                                5
@end group
@group
(%i7) ''%;
(%o7)                          36
@end group
@group
(%i8) L : [a, b, c, d, e];
(%o8)                    [a, b, c, d, e]
@end group
@group
(%i9) arraymake ('L, [n]);
(%o9)                          L
                                n
@end group
@group
(%i10) ''%, n = 3;
(%o10)                          c
@end group
@group
(%i11) A2 : make_array (fixnum, 10);
(%o11)          @{Array:  #(0 0 0 0 0 0 0 0 0 0)@}
@end group
@group
(%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o12)          @{Array:  #(1 2 3 4 5 6 7 8 9 10)@}
@end group
@group
(%i13) arraymake ('A2, [8]);
(%o13)                         A2
                                 8
@end group
@group
(%i14) ''%;
(%o14)                          9
@end group
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{arrays}
@defvr {Systemvariable} arrays
Standardwert: @code{[]}

@code{arrays} ist eine Informationsliste @mref{infolists} der Arrays, die 
definiert sind.  Die Liste enth@"alt deklarierte Arrays, undedeklarierte Arrays 
und Array-Funktionen, die mit @mref{:=} oder @mref{define} definiert sind.
Arrays die mit @mref{make_array} definiert sind, sind nicht in der Liste 
enthalten.

Siehe auch @mrefcomma{array} @mrefcomma{arrayapply} @mrefcomma{arrayinfo}@ 
@mrefcomma{arraymake} @mrefcomma{fillarray} @mref{listarray} und 
@mrefdot{rearray}

Beispiele:

@example
@group
(%i1) array (aa, 5, 7);
(%o1)                          aa
@end group
@group
(%i2) bb [FOO] : (a + b)^2;
                                   2
(%o2)                       (b + a)
@end group
@group
(%i3) cc [x] := x/100;
                                   x
(%o3)                      cc  := ---
                             x    100
@end group
@group
(%i4) dd : make_array ('any, 7);
(%o4)       @{Array:  #(NIL NIL NIL NIL NIL NIL NIL)@}
@end group
@group
(%i5) arrays;
(%o5)                     [aa, bb, cc]
@end group
@end example
@end defvr

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{fillarray}
@deffn {Funktion} fillarray (@var{A}, @var{B})

F@"ullt das Array @var{A} mit den Werten aus @var{B}.  Das Argument @var{B} ist 
eine Liste oder ein Array.

Ist das Array @var{A} mit einem Typ deklariert, dann kann es nur mit Elementen
gef@"ullt werden, die den gleichen Typ haben.

Sind die Dimensionen von @var{A} und @var{B} verschieden, werden in @var{A}
zun@"achst die Zeilen aufgef@"ullt.  Hat @var{B} nicht gen@"ugend Elemente um 
das Array @var{A} aufzuf@"ullen, werden die restlichen Elemente mit dem letzten 
Wert von @var{B} aufgef@"ullt.  @"Uberz@"ahlige Elemente in @var{B} werden 
ignoriert.

@code{fillarray} gibt das erste Argument zur@"uck.

Beispiele:

Erzeuge ein Array mit 9 Elementen und f@"ulle es mit den Elementen einer Liste.

@example
@group
(%i1) array (a1, fixnum, 8);
(%o1)                          a1
@end group
@group
(%i2) listarray (a1);
(%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
@end group
@group
(%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
(%o3)                          a1
@end group
@group
(%i4) listarray (a1);
(%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]
@end group
@end example

Sind zu wenige Elemente vorhanden, um das Array aufzuf@"ullen, wird das Array
mit dem letzten Element aufgef@"ullt.  @"Uberz@"ahlige Elemente werden 
ignoriert.

@example
@group
(%i1) a2 : make_array (fixnum, 8);
(%o1)             @{Array:  #(0 0 0 0 0 0 0 0)@}
@end group
@group
(%i2) fillarray (a2, [1, 2, 3, 4, 5]);
(%o2)             @{Array:  #(1 2 3 4 5 5 5 5)@}
@end group
@group
(%i3) fillarray (a2, [4]);
(%o3)             @{Array:  #(4 4 4 4 4 4 4 4)@}
@end group
@group
(%i4) fillarray (a2, makelist (i, i, 1, 100));
(%o4)             @{Array:  #(1 2 3 4 5 6 7 8)@}
@end group
@end example

Arrays werden zeilenweise aufgef@"ulllt.

@example
@group
(%i1) a3 : make_array (fixnum, 2, 5);
(%o1)        @{Array:  #2A((0 0 0 0 0) (0 0 0 0 0))@}
@end group
@group
(%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
(%o2)        @{Array:  #2A((1 2 3 4 5) (6 7 8 9 10))@}
@end group
@group
(%i3) a4 : make_array (fixnum, 5, 2);
(%o3)     @{Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))@}
@end group
@group
(%i4) fillarray (a4, a3);
(%o4)     @{Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))@}
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{listarray}
@deffn {Funktion} listarray (@var{A})

Gibt eine Liste mit den Elementen des Arrays @var{A} zur@"uck.  Das Argument 
@var{A} kann ein deklariertes, undeklariertes, eine Array-Funktion oder eine
indizierte Funktion sein.

Die Elemente werden zeilenweise ausgegeben.  F@"ur Hashed-Arrays mit Indizes, 
die keine ganze Zahlen sind, wird die Sortierung von der Funktion 
@mref{orderless} bestimmt.

F@"ur undeklarierte Arrays, Array-Funktionen und indizierte Funktionen werden
die Elemente in der Reihenfolge wie von der Funktion 
@mref{arrayinfo} zur@"uckgegeben.

Elemente von deklarierten Arrays, denen noch kein Wert zugewiesen wurde und die
keinen Typ haben, werden als @code{#####} zur@"uckgegeben.  Elemente von
deklarierten Arrays mit einem Typ, geben den Wert 0 f@"ur den Typ @code{fixnum}
und 0.0 f@"ur den Typ @code{flonum} zur@"uck.

Beispiele:

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
deklariertes Array.

@example
@group
(%i1) array (aa, 2, 3);
(%o1)                          aa
@end group
@group
(%i2) aa [2, 3] : %pi;
(%o2)                          %pi
@end group
@group
(%i3) aa [1, 2] : %e;
(%o3)                          %e
@end group
@group
(%i4) listarray (aa);
(%o4) [#####, #####, #####, #####, #####, #####, %e, #####, 
                                        #####, #####, #####, %pi]
@end group
@group
(%i5) arrayinfo (aa);
(%o5)                 [declared, 2, [2, 3]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
undeklariertes Array.

@example
@group
(%i1) bb [FOO] : (a + b)^2;
                                   2
(%o1)                       (b + a)
@end group
@group
(%i2) bb [BAR] : (c - d)^3;
                                   3
(%o2)                       (c - d)
@end group
@group
(%i3) listarray (bb);
                              3         2
(%o3)                 [(c - d) , (b + a) ]
@end group
@group
(%i4) arrayinfo (bb);
(%o4)               [hashed, 1, [BAR], [FOO]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur eine
Array-Funktion.

@example
@group
(%i1) cc [x, y] := y / x;
                                     y
(%o1)                      cc     := -
                             x, y    x
@end group
@group
(%i2) cc [u, v];
                                v
(%o2)                           -
                                u
@end group
@group
(%i3) cc [4, z];
                                z
(%o3)                           -
                                4
@end group
@group
(%i4) listarray (cc);
                              z  v
(%o4)                        [-, -]
                              4  u
@end group
@group
(%i5) arrayinfo (cc);
(%o5)              [hashed, 2, [4, z], [u, v]]
@end group
@end example

Anwendung der Funktionen @code{listarray} und @code{arryinfo} f@"ur ein
indizierte Funktion.

@example
@group
(%i1) dd [x] (y) := y ^ x;
                                     x
(%o1)                     dd (y) := y
                            x
@end group
@group
(%i2) dd [a + b];
                                    b + a
(%o2)                  lambda([y], y     )
@end group
@group
(%i3) dd [v - u];
                                    v - u
(%o3)                  lambda([y], y     )
@end group
@group
(%i4) listarray (dd);
                         b + a                v - u
(%o4)      [lambda([y], y     ), lambda([y], y     )]
@end group
@group
(%i5) arrayinfo (dd);
(%o5)             [hashed, 1, [b + a], [v - u]]
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{make_array}
@deffn {Funktion} make_array (@var{type}, @var{dim_1}, @dots{}, @var{dim_n})

Erzeugt ein Lisp-Array.  Das Argument @var{type} kann die Werte @code{any},
@code{flonum}, @code{fixnum}, @code{hashed} oder @code{functional} haben.
Das Array hat @math{i} Dimensionen und der Index @math{i} l@"auft von 0 bis
@math{@var{dim_i}-1}.

@c TODO: ES FEHLT EINE UEBERSETZUNG, DIE WENIGER TECHNISCH SEIN SOLLTE.

@c 'FUNCTIONAL ARGUMENT IN MAKE_ARRAY APPEARS TO BE BROKEN
@c EVEN AFTER READING THE CODE (SRC/AR.LISP) I CAN'T TELL HOW THIS IS SUPPOSED 
@c TO WORK COMMENTING OUT THIS STUFF TO PREVENT CONFUSION AND HEARTBREAK
@c RESTORE IT WHEN MAKE_ARRAY ('FUNCTIONAL, ...) IS FIXED
@c @code{y: make_array ('functional, 'f, 'hashed, 1)} - the second argument to
@c @code{make_array} in this case is the function to call to calculate array
@c elements, and the rest of the arguments are passed recursively to
@c @code{make_array} to generate the "memory" for the array function object.

Beispiele:

@example
@group
(%i1) A1 : make_array (fixnum, 10);
(%o1)           @{Array:  #(0 0 0 0 0 0 0 0 0 0)@}
@end group
@group
(%i2) A1 [8] : 1729;
(%o2)                         1729
@end group
@group
(%i3) A1;
(%o3)          @{Array:  #(0 0 0 0 0 0 0 0 1729 0)@}
@end group
@group
(%i4) A2 : make_array (flonum, 10);
(%o4) @{Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)@}
@end group
@group
(%i5) A2 [2] : 2.718281828;
(%o5)                      2.718281828
@end group
@group
(%i6) A2;
(%o6) 
     @{Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)@}
@end group
@group
(%i7) A3 : make_array (any, 10);
(%o7) @{Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)@}
@end group
@group
(%i8) A3 [4] : x - y - z;
(%o8)                      - z - y + x
@end group
@group
(%i9) A3;
(%o9) @{Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
 -1 $Y) ((MTIMES SIMP) -1 $Z))
  NIL NIL NIL NIL NIL)@}
@end group
@group
(%i10) A4 : make_array (fixnum, 2, 3, 5);
(%o10) @{Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
0 0 0) (0 0 0 0 0) (0 0 0 0 0)))@}
@end group
@group
(%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
(%o11) @{Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
    ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))@}
@end group
@group
(%i12) A4 [0, 2, 1];
(%o12)                         12
@end group
@end example
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{rearray}
@deffn {Funktion} rearray (@var{A}, @var{dim_1}, @dots{}, @var{dim_n})

@"Andert die Dimension eines Arrays.  Das neue Array wird zeilenweise mit den 
Werten des alten Arrays aufgef@"ullt.  Hat das alte Array nicht gen@"ugend 
Elemente werden die restlichen Elemente entsprechend dem Typ des Arrays mit 
@code{false}, @code{0.0} oder @code{0} aufgef@"ullt.  Der Typ des Arrays kann 
nicht ge@"andert werden.
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{remarray}
@deffn  {Funktion} remarray (@var{A_1}, @dots{}, @var{A_n})
@deffnx {Funktion} remarray (all)

Entfernt Arrays und Array-Funktionen.  Der vom Array belegte Speicher wird
freigegeben.  Die Argumente k@"onnen deklarierte und undeklarierte Arrays sowie 
Array-Funktionen und indizierte Funktionen sein.

@code{remarray(all)} entfernt alle Arrays, die in der Informationsliste
@mref{arrays} enthalten sind.

@code{remarray} gibt eine Liste der Arrays zur@"uck, die entfernt wurden.
@end deffn

@c --- 13.11.2010 DK -----------------------------------------------------------
@anchor{subvar}
@deffn {Funktion} subvar (@var{x}, @var{i})

Wertet den indizierten Ausdruck @code{@var{x}[@var{i}]} aus.  @code{subvar}
wertet die Argumente aus.

@code{arraymake(@var{x}, [@var{i}]} generiert den Ausdruck 
@code{@var{x}[@var{i}]}, ohne diesen auszuwerten.  Siehe @mrefdot{arraymake}

Beispiele:

@example
(%i1) x : foo $
(%i2) i : 3 $
@group
(%i3) subvar (x, i);
(%o3)                         foo
                                 3
@end group
(%i4) foo : [aa, bb, cc, dd, ee]$
@group
(%i5) subvar (x, i);
(%o5)                          cc
@end group
@group
(%i6) arraymake (x, [i]);
(%o6)                         foo
                                 3
@end group
@group
(%i7) ''%;
(%o7)                          cc
@end group
@end example
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{subvarp}
@deffn {Funktion} subvarp (@var{expr})

Gibt @code{true} zur@"uck, wenn @var{expr} eine indizierte Variable wie zum
Beispiel @code{a[i]} ist.
@end deffn

@c --- 12.11.2010 DK -----------------------------------------------------------
@anchor{use_fast_arrays}
@defvr {Optionsvariable} use_fast_arrays

Hat die Optionsvariable @code{use_fast_arrays} den Wert @code{true}, werden nur
die folgenden zwei Typen von Arrays erkannt:

@enumerate
@item
Ein Array, das mehrere Dimensionen haben kann und ganzzahligen Indizes.  Den
Elementen kann jedes Lisp oder Maxima-Objekt zugewiesen werden.  Zum Beispiel
weist das Kommando @code{a:make_array(any,3,4)} der Variablen @var{a} ein
Array zu, das @code{12} Elemente hat.

@item
Ein undeklariertes Array, welches standardm@"a@ss{}ig erzeugt wird, wenn zum 
Beispiel einer indizierten Variablen @code{b[x+1]:y^2} ein Wert zugewiesen wird 
und @code{b} nicht bereits ein deklariertes Array oder eine Liste ist.  Ist 
@var{b} bereits deklariert, wird eine Fehlermeldung ausgeben, da der Index 
@var{x+1} keine ganze Zahl ist.  Der Index eines undeklarierten Arrays kann ein 
beliebiger Ausdruck sein.
@end enumerate

@c TODO: VEREINFACHE DIE TECHNISCHE BESCHREIBUNG.

@c An advantage of storing the arrays as values of the symbol is that the
@c usual conventions about local variables of a function apply to arrays as
@c well.  The Hash_table type also uses less consing and is more efficient
@c than the old type of Maxima hashar.  To obtain consistent behaviour in
@c translated and compiled code set @code{translate_fast_arrays} to be 
@c @code{true}.
@end defvr

@c --- End of file DataTypes.de.texi -------------------------------------------

