@c end concepts Equations
@menu
* Definitions for Equations::   
@end menu

@node Definitions for Equations,  , Equations, Equations
@section Definitions for Equations

@c NEED A DESCRIPTION OF %rnum AS WELL
@defvar %rnum_list
Default value: []

@code{%rnum_list} is the list of variables introduced in solutions
by @code{algsys}.
@code{%r} variables are added to @code{%rnum_list} in the order they
are created.
This is convenient for doing substitutions into the
solution later on.
@c WHAT DOES THIS STATEMENT MEAN ??
It's recommended to use this list rather than
doing @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvar

@defvar algexact
Default value: @code{false}

@code{algexact} affects the behavior of @code{algsys} as follows:

If @code{algexact} is @code{true},
@code{algsys} always calls @code{solve} and then uses @code{realroots}
on @code{solve}'s failures.

If @code{algexact} is @code{false}, @code{solve} is called only if
the eliminant was not univariate, or if it was a quadratic or
biquadratic.

Thus @code{algexact: true} doesn't guarantee only exact
solutions, just that @code{algsys} will first try as hard as it can to give
exact solutions, and only yield approximations when all else fails.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvar

@defun algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@defunx algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Solves the simultaneous polynomials @var{expr_1}, ..., @var{expr_m}
or polynomial equations @var{eqn_1}, ..., @var{eqn_m}
for the variables @var{x_1}, ..., @var{x_n}.
An expression @var{expr} is equivalent to an equation @code{@var{expr} = 0}.
There may be more equations than variables or vice versa.

@code{algsys} returns a list of solutions,
with each solution given as a list of equations stating values of
the variables @var{x_1}, ..., @var{x_n} which satisfy the system of equations.
If @code{algsys} cannot find a solution, an empty list @code{[]} is returned.

The symbols @code{%r1}, @code{%r2}, ...,
are introduced as needed to represent arbitrary parameters in the solution;
these variables are also appended to the list @code{%rnum_list}.

The method is as follows:

(1) First the equations are factored and split into subsystems.

(2) For each subsystem @var{S_i}, an equation @var{E} and a variable @var{x} are
selected.
The variable is chosen to have lowest nonzero degree.
Then the resultant of @var{E} and @var{E_j} with respect to @var{x} is computed for each of the
remaining equations @var{E_j} in the subsystem @var{S_i}.
This yields a new subsystem @var{S_i'} in one fewer variables, as @var{x} has been eliminated.
The process now returns to (1).

(3) Eventually, a subsystem consisting of a single equation is
obtained.  If the equation is multivariate and no approximations in
the form of floating point numbers have been introduced, then @code{solve} is
called to find an exact solution.

In some cases, @code{solve} is not be able to find a solution,
or if it does the solution may be a very large expression.

@c REMAINDER OF (3) IS PRETTY COMPLEX. HOW CAN IT BE CLARIFIED ??
If the equation is univariate and is either linear, quadratic, or
biquadratic, then again @code{solve} is called if no approximations have
been introduced.  If approximations have been introduced or the
equation is not univariate and neither linear, quadratic, or
biquadratic, then if the switch @code{realonly} is @code{true}, the function
@code{realroots} is called to find the real-valued solutions.  If
@code{realonly} is @code{false}, then @code{allroots} is called which looks for real and
complex-valued solutions.

If @code{algsys} produces a solution which has
fewer significant digits than required, the user can change the value
of @code{algepsilon} to a higher value.

If @code{algexact} is set to
@code{true}, @code{solve} will always be called.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finally, the solutions obtained in step (3) are substituted into
previous levels and the solution process returns to (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

When @code{algsys} encounters a multivariate equation which contains
floating point approximations (usually due to its failing to find
exact solutions at an earlier stage), then it does not attempt to
apply exact methods to such equations and instead prints the message:
"@code{algsys} cannot solve - system too complicated."

Interactions with @code{radcan} can produce large or complicated
expressions.
In that case, it may be possible to isolate parts of the result
with @code{pickapart} or @code{reveal}.

Occasionally, @code{radcan} may introduce an imaginary unit
@code{%i} into a solution which is actually real-valued.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THIS CODE, ADAPTED FROM example(algsys)
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
@c e2: a2 - a1; 
@c e3: a1*(-y - x^2 + 1); 
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);

@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end defun

@defun allroots (@var{expr})
@defunx allroots (@var{eqn})
Computes numerical approximations of the real and complex roots of the
polynomial @var{expr} or polynomial equation @var{eqn} of one variable.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
The flag @code{polyfactor} when @code{true} causes
@code{allroots} to factor the polynomial over the real numbers if the
polynomial is real, or over the complex numbers, if the polynomial is
complex.

@code{allroots} may give inaccurate results in case of multiple roots.
If the polynomial is real, @code{allroots (%i*@var{p})}) may yield
more accurate approximations than @code{allroots (@var{p})},
as @code{allroots} invokes a different algorithm in that case.

@code{allroots} rejects non-polynomials.  It requires that the numerator
after @code{rat}'ing should be a polynomial, and it requires that the
denominator be at most a complex number.  As a result of this @code{allroots}
will always return an equivalent (but factored) expression, if
@code{polyfactor} is @code{true}.

For complex polynomials an algorithm by Jenkins and Traub is
used (Algorithm 419, @i{Comm. ACM}, vol. 15, (1972), p. 97).
For real polynomials the algorithm used is due to Jenkins (Algorithm 493, @i{ACM TOMS},
vol. 1, (1975), p.178).

Examples:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end defun

@defvar backsubst
Default value: @code{true}

@c WHAT IS THE CONTEXT HERE ?? (TO WHICH OTHER FUNCTION DOES THIS APPLY ??)
When @code{backsubst} is @code{false}, prevents back
substitution after the equations have been triangularized.  This may
be helpful in very big problems where back substitution would cause
the generation of extremely large expressions.

@end defvar

@defvar breakup
Default value: @code{true}

When @code{breakup} is @code{true}, @code{solve} expresses solutions
of cubic and quartic equations in terms of common subexpressions,
which are assigned to intermediate expression labels (@code{%t1}, @code{%t2}, etc.).
Otherwise, common subexpressions are not identified.

@code{breakup: true} has an effect only when @code{programmode} is @code{false}.

Examples:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example

@end defvar

@defun dimension (equation or list of equations)
@code{dimen} is a package for dimensional analysis.
@code{load ("dimen")} loads this package.
@code{demo ("dimen")} displays a short demonstration.
@c I GUESS THIS SHOULD BE EXPANDED TO COVER EACH FUNCTION IN THE PACKAGE

@end defun

@defvar dispflag
Default value: @code{true}

@c WHAT DOES THIS MEAN ??
If set to @code{false} within a @code{block} will inhibit
the display of output generated by the solve functions called from
within  the @code{block}.  Termination of the @code{block} with a dollar sign, $, sets
@code{dispflag} to @code{false}.

@end defvar

@c THIS COULD BENEFIT FROM REPHRASING
@defun funcsolve (@var{eqn}, @var{g}(@var{t}))
Returns @code{[@var{g}(@var{t}) = ...]}  or @code{[]}, depending on whether
or not there exists a rational function @code{@var{g}(@var{t})} satisfying @var{eqn},
which must be a first order, linear polynomial in (for this case) 
@code{@var{g}(@var{t})} and @code{@var{g}(@var{t}+1)}

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Dependent equations eliminated:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example

Warning: this is a very rudimentary implementation -- many safety checks
and obvious generalizations are missing.

@end defun

@defvar globalsolve
Default value: @code{false}

When @code{globalsolve} is @code{true}, solved-for variables
are assigned the solution values found by @code{solve}.
@c DOES ANY OTHER FUNCTION RESPECT globalsolve ??

Examples:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example

@end defvar

@c THIS DESCRIPTION NEEDS WORK AND EXAMPLES
@c MERGE IN TEXT FROM share/integequations/inteqn.usg
@c AND EXAMPLES FROM .../intexs.mac
@defun ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
@code{inteqn} is a package for solving integral equations.
@code{load ("inteqn")} loads this package.

@var{ie} is the integral equation; @var{unk} is the unknown function; @var{tech} is the
technique to be tried from those given above (@var{tech} = @code{first} means: try
the first technique which finds a solution; @var{tech} = @code{all} means: try all
applicable techniques); @var{n} is the maximum number of terms to take for
@code{taylor}, @code{neumann}, @code{firstkindseries}, or @code{fredseries} (it is also the
maximum depth of recursion for the differentiation method); @var{guess} is
the initial guess for @code{neumann} or @code{firstkindseries}.

Default values for the 2nd thru 5th parameters are:

@var{unk}: @code{@var{p}(@var{x})}, where @var{p} is the first function encountered in an integrand
which is unknown to Maxima and @var{x} is the variable which occurs as an
argument to the first occurrence of @var{p} found outside of an integral in
the case of @code{secondkind} equations, or is the only other variable
besides the variable of integration in @code{firstkind} equations.  If the
attempt to search for @var{x} fails, the user will be asked to supply the
independent variable.

tech: @code{first}

n: 1

guess: @code{none} which will cause @code{neumann} and @code{firstkindseries} to use
@code{@var{f}(@var{x})} as an initial guess.

@end defun

@defvar ieqnprint
Default value: @code{true}

@code{ieqnprint} governs the behavior of the result
returned by the @code{ieqn} command. When @code{ieqnprint} is
@code{false}, the lists returned by the @code{ieqn} function are of the form

   [@var{solution}, @var{technique used}, @var{nterms}, @var{flag}]

where @var{flag} is absent if the solution is exact.

Otherwise, it is the
word @code{approximate} or @code{incomplete} corresponding to an inexact or
non-closed form solution, respectively. If a series method was used,
@var{nterms} gives the number of terms taken (which could be less than the n
given to @code{ieqn} if an error prevented generation of further terms).

@end defvar

@defun lhs (@var{eqn})
Returns the left side of the equation @var{eqn}.

If the argument is not an equation, @code{lhs} returns the argument.

See also @code{rhs}.

Example:

@example
(%i1) e: x^2 + y^2 = z^2;
                           2    2    2
(%o1)                     y  + x  = z
(%i2) lhs (e);
                              2    2
(%o2)                        y  + x
(%i3) rhs (e);
                                2
(%o3)                          z
@end example

@end defun

@c REVISIT -- THERE'S PROBABLY MORE TO SAY HERE
@defun linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
Solves the list of
simultaneous linear equations for the list of variables.  The expressions
must each be polynomials in the variables and may be equations.

When @code{globalsolve} is @code{true} then variables which are solved
for will be set to the solution of the set of simultaneous equations.

When @code{backsubst} is @code{false}, @code{linsolve}
does not carry out back substitution after
the equations have been triangularized.  This may be necessary in very
big problems where back substitution would cause the generation of
extremely large expressions.

When @code{linsolve_params} is @code{true},
@code{linsolve} also generates the @code{%r} symbols
used to represent arbitrary parameters described in the manual under
@code{algsys}.
Otherwise, @code{linsolve} solves an under-determined system of
equations with some variables expressed in terms of others.

@example
(%i1) e1: x + z = y$
(%i2) e2: 2*a*x - y = 2*a^2$
(%i3) e3: y - 2*z = 2$
(%i4) linsolve ([e1, e2, e3], [x, y, z]);
(%o4)            [x = a + 1, y = 2 a, z = a - 1]
@end example

@end defun

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??
@defvar linsolvewarn
Default value: @code{true}

When @code{linsolvewarn} is @code{true},
@code{linsolve} prints a message "Dependent equations eliminated".

@end defvar

@defvar linsolve_params
Default value: @code{true}

When @code{linsolve_params} is @code{true}, @code{linsolve} also generates
the @code{%r} symbols used to represent arbitrary parameters described in
the manual under @code{algsys}.
Otherwise, @code{linsolve} solves an under-determined system of
equations with some variables expressed in terms of others.

@end defvar

@defvar multiplicities
Default value: @code{not_set_yet}

@code{multiplicities} is set to a list of the
multiplicities of the individual solutions returned by @code{solve} or
@code{realroots}.
@c NEED AN EXAMPLE HERE

@end defvar

@defun nroots (@var{p}, @var{low}, @var{high})
Returns the number of real roots of the real
univariate polynomial @var{p} in the half-open interval
@code{(@var{low}, @var{high}]}.
The endpoints of the interval may be @code{minf} or @code{inf}.
infinity and plus infinity.

@code{nroots} uses the method of Sturm sequences.

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example

@end defun

@c NEEDS WORK
@defun nthroot (@var{p}, @var{n})
where p is a polynomial with integer coefficients and
n is a positive integer returns q, a polynomial over the integers, such
that q^n=p or prints an error message indicating that p is not a perfect
nth power. This routine is much faster than @code{factor} or even @code{sqfr}.

@end defun

@defvar programmode
Default value: @code{true}

When @code{programmode} is @code{true},
@code{solve}, @code{realroots}, @code{allroots}, and @code{linsolve}
return solutions as elements in a list.
@c WHAT DOES BACKSUBSTITUTION HAVE TO DO WITH RETURN VALUES ??
(Except when @code{backsubst} is set to @code{false}, in which case
@code{programmode: false} is assumed.)

When @code{programmode} is @code{false}, @code{solve}, etc.
create intermediate expression labels
@code{%t1}, @code{t2}, etc., and assign the solutions to them.
@c NEED AN EXAMPLE HERE

@end defvar

@defvar realonly
Default value: @code{false}

When @code{realonly} is @code{true}, @code{algsys} returns only
those solutions which are free of @code{%i}.

@end defvar

@c NEEDS WORK
@defun realroots (@var{poly}, @var{bound})
Finds all of the real roots of the real
univariate polynomial poly within a tolerance of bound which, if less
than 1, causes all integral roots to be found exactly.  The parameter
bound may be arbitrarily small in order to achieve any desired
accuracy.  The first argument may also be an equation.  @code{realroots} sets
@code{multiplicities}, useful in case of multiple roots.  @code{realroots (@var{p})} is
equivalent to @code{realroots (@var{p}, rootsepsilon)}.  @code{rootsepsilon} is a
real number used to establish the confidence interval for the roots.
Do @code{example (realroots)} for an example.

@end defun

@defun rhs (@var{eqn})
Returns the right side of the equation @var{eqn}.

If the argument is not an equation, @code{rhs} returns @code{0}.

See also @code{lhs}.

Example:

@example
(%i1) e: x^2 + y^2 = z^2;
                           2    2    2
(%o1)                     y  + x  = z
(%i2) lhs (e);
                              2    2
(%o2)                        y  + x
(%i3) rhs (e);
                                2
(%o3)                          z
@end example

@end defun

@defvar rootsconmode
Default value: @code{true} - Determines the behavior of the
@code{rootscontract} command.  See @code{rootscontract} for details.

@end defvar

@c NEEDS WORK
@defun rootscontract (@var{expr})
Converts products of roots into roots of products.
For example,
@code{rootscontract (sqrt(x)*y^(3/2))} yields @code{sqrt(x*y^3)}.

When @code{radexpand} is @code{true} and @code{domain} is @code{real},
@code{rootscontract} converts @code{abs} into @code{sqrt}, e.g.,
@code{rootscontract (abs(x)*sqrt(y))} yields @code{sqrt(x^2*y)}.

There is an option @code{rootsconmode}
affecting @code{rootscontract} as follows:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

When @code{rootsconmode} is @code{false}, @code{rootscontract} contracts only with respect to rational 
number exponents whose denominators are the same.  The key to the 
@code{rootsconmode: true} examples is simply that 2 divides into 4 but not 
into 3.  @code{rootsconmode: all} involves taking the least common multiple
of the denominators of the exponents.

@code{rootscontract} uses @code{ratsimp} in a manner similar to @code{logcontract}.

Examples:
@c FOLLOWING ADAPTED FROM example (rootscontract)
@c rootsconmode: false$
@c rootscontract (x^(1/2)*y^(3/2));
@c rootscontract (x^(1/2)*y^(1/4));
@c rootsconmode: true$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: all$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: false$
@c rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
@c                     *sqrt(sqrt(1 + x) - sqrt(x)));
@c rootsconmode: true$
@c rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
@end example

@end defun

@defvar rootsepsilon
Default value: 1.0e-7

@code{rootsepsilon} is the tolerance which establishes the
confidence interval for the roots found by the @code{realroots} function.
@c IS IT GUARANTEED THAT |ACTUAL - ESTIMATE| < rootepsilon OR IS IT SOME OTHER NOTION ??
@c NEED EXAMPLE HERE

@end defvar

@c NEEDS WORK
@defun solve (@var{expr}, @var{x})
@defunx solve (@var{expr})
@defunx solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
Solves the algebraic equation @var{expr} for the variable
@var{x} and returns a list of solution equations in @var{x}.  If @var{expr} is not an
equation, the equation @code{@var{expr} = 0} is assumed in its place.
@var{x} may be a function (e.g. @code{f(x)}), or other non-atomic expression
except a sum or product. @var{x} may be omitted if @var{expr} contains only one
variable.  @var{expr} may be a rational expression, and may contain
trigonometric functions, exponentials, etc.

The following method is used:

Let @var{E} be the expression and @var{X} be the variable.  If @var{E} is linear in @var{X}
then it is trivially solved for @var{X}.  Otherwise if @var{E} is of the form
@code{A*X^N + B} then the result is @code{(-B/A)^1/N)} times the @code{N}'th roots of
unity.

If @var{E} is not linear in @var{X} then the gcd of the exponents of @var{X} in @var{E} (say
@var{N}) is divided into the exponents and the multiplicity of the roots is
multiplied by @var{N}.  Then @code{solve} is called again on the result.
If @var{E} factors then @code{solve} is called on each of the factors.  Finally
@code{solve} will use the quadratic, cubic, or quartic formulas where
necessary.

In the case where @var{E} is a polynomial in some function of the variable
to be solved for, say @code{F(X)}, then it is first solved for @code{F(X)} (call the
result @var{C}), then the equation @code{F(X)=C} can be solved for @var{X} provided the
inverse of the function @var{F} is known.

@code{breakup} if @code{false} will cause @code{solve} to express the solutions of
cubic or quartic equations as single expressions rather than as made
up of several common subexpressions which is the default.

@code{multiplicities} - will be set to a list of the multiplicities of
the individual solutions returned by @code{solve}, @code{realroots}, or @code{allroots}.
Try @code{apropos (solve)} for the switches which affect @code{solve}.  @code{describe} may
then by used on the individual switch names if their purpose is not
clear.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
solves a system of simultaneous
(linear or non-linear) polynomial equations by calling @code{linsolve} or
@code{algsys} and returns a list of the solution lists in the variables.  In
the case of @code{linsolve} this list would contain a single list of
solutions.  It takes two lists as arguments.  The first list
represents the equations to be solved; the second list is a
list of the unknowns to be determined.  If the total number of
variables in the equations is equal to the number of equations, the
second argument-list may be omitted.  For linear systems if the given
equations are not compatible, the message @code{inconsistent} will be
displayed (see the @code{solve_inconsistent_error} switch); if no unique
solution exists, then @code{singular} will be displayed.

Examples:
@c FOLLOWING ADAPTED FROM example (solve)
@c solve (asin (cos (3*x))*(f(x) - 1), x);
@c ev (solve (5^f(x) = 125, f(x)), solveradcan);
@c [4*x^2 - y^2 = 12, x*y - x = 2];
@c solve (%, [x, y]);
@c solve (1 + a*x + x^3, x);
@c solve (x^3 - 1);
@c solve (x^6 - 1);
@c ev (x^6 - 1, %[1]);
@c expand (%);
@c x^2 - 1;
@c solve (%, x);
@c ev (%th(2), %[1]);

@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

@end defun

@defvar solvedecomposes
Default value: @code{true}

When @code{solvedecomposes} is @code{true}, @code{solve} calls
@code{polydecomp} if asked to solve polynomials.
@c OTHERWISE WHAT HAPPENS -- CAN'T SOLVE POLYNOMIALS, OR SOME OTHER METHOD IS USED ??

@end defvar

@defvar solveexplicit
Default value: @code{false}

When @code{solveexplicit} is @code{true}, inhibits @code{solve} from
returning implicit solutions, that is, solutions of the form @code{F(x) = 0}
where @code{F} is some function.
@c NEED AN EXAMPLE HERE

@end defvar

@defvar solvefactors
Default value: @code{true}

@c WHAT IS THIS ABOUT EXACTLY ??
When @code{solvefactors} is @code{false}, @code{solve} does not try to
factor the expression.  The @code{false} setting may be desired in some cases
where factoring is not necessary.
@c NEED AN EXAMPLE HERE

@end defvar

@defvar solvenullwarn
Default value: @code{true}

When @code{solvenullwarn} is @code{true}, 
@code{solve} prints a warning message if called with either a null equation list or a null variable list.
For example, @code{solve ([], [])} would print two warning messages and return @code{[]}.

@end defvar

@defvar solveradcan
Default value: @code{false}

When @code{solveradcan} is @code{true}, @code{solve} calls @code{radcan}
which makes @code{solve} slower but will allow certain problems
containing exponentials and logarithms to be solved.
@c NEED AN EXAMPLE HERE

@end defvar

@defvar solvetrigwarn
Default value: @code{true}

@c MAYBE THIS CAN BE CLARIFIED
When @code{solvetrigwarn} is @code{true},
@code{solve} may print a message saying that it is using inverse
trigonometric functions to solve the equation, and thereby losing
solutions.
@c NEED AN EXAMPLE HERE

@end defvar

@defvar solve_inconsistent_error
Default value: @code{true}

When @code{solve_inconsistent_error} is @code{true}, @code{solve} and
@code{linsolve} give an error if the equations to be solved are inconsistent.

If @code{false}, @code{solve} and @code{linsolve} return an empty list @code{[]} 
if the equations are inconsistent.

Example:

@example
(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equations:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
@end example

@end defvar
