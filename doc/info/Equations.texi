@c end concepts Equations
@menu
* Definitions for Equations::   
@end menu

@node Definitions for Equations,  , Equations, Equations
@section Definitions for Equations

@defvar %rnum_list
Default value: []

@code{%rnum_list} is the list of variables introduced in solutions
by @code{algsys}.
@code{%r} variables are added to @code{%rnum_list} in the order they
are created.
This is convenient for doing substitutions into the
solution later on.
@c WHAT DOES THIS STATEMENT MEAN ??
It's recommended to use this list rather than
doing @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvar

@defvar algexact
Default value: @code{false}

@code{algexact} affects the behavior of @code{algsys} as follows:

If @code{algexact} is @code{true},
@code{algsys} always calls @code{solve} and then uses @code{realroots}
on @code{solve}'s failures.

If @code{algexact} is @code{false}, @code{solve} is called only if
the eliminant was not univariate, or if it was a quadratic or
biquadratic.

Thus @code{algexact: true} doesn't guarantee only exact
solutions, just that @code{algsys} will first try as hard as it can to give
exact solutions, and only yield approximations when all else fails.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvar

@defun algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@defunx algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Solves the simultaneous polynomials @var{expr_1}, ..., @var{expr_m}
or polynomial equations @var{eqn_1}, ..., @var{eqn_m}
for the variables @var{x_1}, ..., @var{x_n}.
An expression @var{expr} is equivalent to an equation @code{@var{expr} = 0}.
There may be more equations than variables or vice versa.

@code{algsys} returns a list of solutions,
with each solution given as a list of equations stating values of
the variables @var{x_1}, ..., @var{x_n} which satisfy the system of equations.
If @code{algsys} cannot find a solution, an empty list @code{[]} is returned.

The symbols @code{%r1}, @code{%r2}, ...,
are introduced as needed to represent arbitrary parameters in the solution;
these variables are also appended to the list @code{%rnum_list}.

The method is as follows:

(1) First the equations are factored and split into subsystems.

(2) For each subsystem @var{S_i}, an equation @var{E} and a variable @var{x} are
selected.
The variable is chosen to have lowest nonzero degree.
Then the resultant of @var{E} and @var{E_j} with respect to @var{x} is computed for each of the
remaining equations @var{E_j} in the subsystem @var{S_i}.
This yields a new subsystem @var{S_i'} in one fewer variables, as @var{x} has been eliminated.
The process now returns to (1).

(3) Eventually, a subsystem consisting of a single equation is
obtained.  If the equation is multivariate and no approximations in
the form of floating point numbers have been introduced, then @code{solve} is
called to find an exact solution.

In some cases, @code{solve} is not be able to find a solution,
or if it does the solution may be a very large expression.

@c REMAINDER OF (3) IS PRETTY COMPLEX. HOW CAN IT BE CLARIFIED ??
If the equation is univariate and is either linear, quadratic, or
biquadratic, then again @code{solve} is called if no approximations have
been introduced.  If approximations have been introduced or the
equation is not univariate and neither linear, quadratic, or
biquadratic, then if the switch @code{realonly} is @code{true}, the function
@code{realroots} is called to find the real-valued solutions.  If
@code{realonly} is @code{false}, then @code{allroots} is called which looks for real and
complex-valued solutions.

If @code{algsys} produces a solution which has
fewer significant digits than required, the user can change the value
of @code{algepsilon} to a higher value.

If @code{algexact} is set to
@code{true}, @code{solve} will always be called.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finally, the solutions obtained in step (3) are substituted into
previous levels and the solution process returns to (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

When @code{algsys} encounters a multivariate equation which contains
floating point approximations (usually due to its failing to find
exact solutions at an earlier stage), then it does not attempt to
apply exact methods to such equations and instead prints the message:
"@code{algsys} cannot solve - system too complicated."

Interactions with @code{radcan} can produce large or complicated
expressions.
In that case, it may be possible to isolate parts of the result
with @code{pickapart} or @code{reveal}.

Occasionally, @code{radcan} may introduce an imaginary unit
@code{%i} into a solution which is actually real-valued.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THIS CODE, ADAPTED FROM example(algsys)
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
@c e2: a2 - a1; 
@c e3: a1*(-y - x^2 + 1); 
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);

@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end defun

@defun allroots (@var{expr})
@defunx allroots (@var{eqn})
Finds all the real and complex roots of the
polynomial @var{expr} or polynomial equation @var{eqn} of one variable.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
The flag @code{polyfactor} when @code{true} causes
@code{allroots} to factor the polynomial over the real numbers if the
polynomial is real, or over the complex numbers, if the polynomial is
complex.

@code{allroots} may give inaccurate results in case of multiple
roots.  (If poly is real and you get inaccurate answers, you may want
to try @code{allroots (%i*@var{poly})})

@code{allroots} rejects non-polynomials.  It requires that the numerator
after @code{rat}'ing should be a polynomial, and it requires that the
denominator be at most a complex number.  As a result of this @code{allroots}
will always return an equivalent (but factored) expression, if
@code{polyfactor} is @code{true}.

For complex polynomials an algorithm by Jenkins and Traub is
used (Algorithm 419, @i{Comm. ACM}, vol. 15, (1972), p. 97).
For real polynomials the algorithm used is due to Jenkins (Algorithm 493, @i{ACM TOMS},
vol. 1, (1975), p.178).

Examples:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end defun

@defvar backsubst
Default value: @code{true} if set to @code{false} will prevent back
substitution after the equations have been triangularized.  This may
be necessary in very big problems where back substitution would cause
the generation of extremely large expressions.

@end defvar

@defvar breakup
Default value: @code{true} if @code{false} will cause @code{solve} to express the
solutions of cubic or quartic equations as single expressions rather
than as made up of several common subexpressions which is the default.
@code{breakup: true} only works when @code{programmode} is @code{false}.

@end defvar

@defun dimension (equation or list of equations)
The file "share1/dimen.mc"
contains functions for automatic dimensional analysis.  @code{load (dimen)}
will load it up for you.  There is a demonstration available in
share1/dimen.dem.  Do @code{demo ("dimen")} to run it.

@end defun

@defvar dispflag
Default value: @code{true} if set to @code{false} within a @code{block} will inhibit
the display of output generated by the solve functions called from
within  the @code{block}.  Termination of the @code{block} with a dollar sign, $, sets
@code{dispflag} to @code{false}.

@end defvar

@defun funcsolve (@var{eqn}, @var{g}(@var{t}))
gives [g(t) = ...]  or [], depending on whether
or not there exists a rational fcn g(t) satisfying eqn, which must be
a first order, linear polynomial in (for this case) g(t) and g(t+1).

@example
(%i1) funcsolve((n+1)*foo(n)-(n+3)*foo(n+1)/(n+1) =
    (n-1)/(n+2),foo(n));
                                   n
(%o1)               foo(n) = ---------------
                            (n + 1) (n + 2)
@end example

Warning: this is a very rudimentary implementation--many safety checks
and obvious generalizations are missing.

@end defun

@defvar globalsolve
Default value: @code{false} if set to @code{true} then variables which are
solved for will be set to the solution of the set of simultaneous
equations.

@end defvar

@defun ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
Integral Equation solving routine.  Do
@code{load (inteqn)} to access it.
ie is the integral equation; unk is the unknown function; tech is the
technique to be tried from those given above (tech = @code{first} means: try
the first technique which finds a solution; tech = @code{all} means: try all
applicable techniques); n is the maximum number of terms to take for
@code{taylor}, @code{neumann}, @code{firstkindseries}, or @code{fredseries} (it is also the
maximum depth of recursion for the differentiation method); guess is
the initial guess for @code{neumann} or @code{firstkindseries}.

Default values for the 2nd thru 5th parameters are:

unk: P(X), where P is the first function encountered in an integrand
which is unknown to Maxima and X is the variable which occurs as an
argument to the first occurrence of P found outside of an integral in
the case of @code{secondkind} equations, or is the only other variable
besides the variable of integration in @code{firstkind} equations.  If the
attempt to search for X fails, the user will be asked to supply the
independent variable;

tech: @code{first}

n: 1

guess: @code{none} which will cause @code{neumann} and @code{firstkindseries} to use F(X)
as an initial guess.

@end defun

@defvar ieqnprint
Default value: @code{true} - governs the behavior of the result
returned by the @code{ieqn} command (which see).  If @code{ieqnprint} is set to
@code{false}, the lists returned by the @code{ieqn} function are of the form

   [@var{solution}, @var{technique used}, @var{nterms}, @var{flag}]

where @var{flag} is absent if the solution is exact.  Otherwise, it is the
word @code{approximate} or @code{incomplete} corresponding to an inexact or
non-closed form solution, respectively. If a series method was used,
@var{nterms} gives the number of terms taken (which could be less than the n
given to @code{ieqn} if an error prevented generation of further terms).

@end defvar

@defun lhs (@var{eqn})
the left side of the equation eqn.

@end defun

@defun linsolve ([@var{expr_1}, @var{expr_2}, ...], [@var{x_1}, @var{x_2}, ...])
solves the list of
simultaneous linear equations for the list of variables.  The expi
must each be polynomials in the variables and may be equations.
If @code{globalsolve} is set to @code{true} then variables which are solved
for will be set to the solution of the set of simultaneous equations.

@code{backsubst} if set to @code{false} will prevent back substitution after
the equations have been triangularized.  This may be necessary in very
big problems where back substitution would cause the generation of
extremely large expressions.

@code{linsolve_params} If @code{true}, @code{linsolve} also generates the @code{%ri} symbols
used to represent arbitrary parameters described in the manual under
@code{algsys}.  If @code{false}, @code{linsolve} behaves as before, i.e. when it meets up
with an under-determined system of equations, it solves for some of
the variables in terms of others.

@example
(%i1) x+z=y$
(%i2) 2*a*x-y=2*a**2$
(%i3) y-2*z=2$
(%i4) linsolve([%o1,%o2,%o3],[x,y,z]),globalsolve:true;
solution
(%t4)                            x : a + 1
(%t5)                             y : 2 a
(%t6)                            z : a - 1
(%o6)                          [%t4, %t5, %t6]
@end example

@end defun

@defvar linsolvewarn
Default value: @code{true} - if @code{false} will cause the message
"Dependent equations eliminated" to be suppressed.

@end defvar

@defvar linsolve_params
Default value: @code{true} - If @code{true}, @code{linsolve} also generates
the @code{%ri} symbols used to represent arbitrary parameters described in
the manual under @code{algsys}.  If @code{false}, @code{linsolve} behaves as before, i.e.
when it meets up with an under-determined system of equations, it
solves for some of the variables in terms of others.

@end defvar

@defvar multiplicities
Default value: @code{not_set_yet} - will be set to a list of the
multiplicities of the individual solutions returned by @code{solve} or
@code{realroots}.

@end defvar

@defun nroots (@var{poly}, @var{low}, @var{high})
finds the number of real roots of the real
univariate polynomial poly in the half-open interval (low,high].  The
endpoints of the interval may also be @code{minf} or @code{inf} respectively for minus
infinity and plus infinity.  The method of Sturm sequences is used.

@example
(%i1) poly1:x**10-2*x**4+1/2$
(%i2) nroots(poly1,-6,9.1);
rat replaced 0.5 by 1/2 = 0.5
(%o2)                               4
@end example

@end defun

@defun nthroot (@var{p}, @var{n})
where p is a polynomial with integer coefficients and
n is a positive integer returns q, a polynomial over the integers, such
that q^n=p or prints an error message indicating that p is not a perfect
nth power. This routine is much faster than @code{factor} or even @code{sqfr}.

@end defun

@defvar programmode
Default value: @code{true} - when @code{false} will cause @code{solve}, @code{realroots},
@code{allroots}, and @code{linsolve} to print E-labels (intermediate line labels) to
label answers.  When @code{true}, @code{solve}, etc. return answers as elements in a
list.  (Except when @code{backsubst} is set to @code{false}, in which case
@code{programmode: false} is also used.)

@end defvar

@defvar realonly
Default value: @code{false} - if @code{true} causes @code{algsys} to return only
those solutions which are free of @code{%i}.

@end defvar

@defun realroots (@var{poly}, @var{bound})
finds all of the real roots of the real
univariate polynomial poly within a tolerance of bound which, if less
than 1, causes all integral roots to be found exactly.  The parameter
bound may be arbitrarily small in order to achieve any desired
accuracy.  The first argument may also be an equation.  @code{realroots} sets
@code{multiplicities}, useful in case of multiple roots.  @code{realroots (@var{p})} is
equivalent to @code{realroots (@var{p}, rootsepsilon)}.  @code{rootsepsilon} is a
real number used to establish the confidence interval for the roots.
Do @code{example (realroots)} for an example.

@end defun

@defun rhs (@var{eqn})
the right side of the equation eqn.

@end defun

@defvar rootsconmode
Default value: @code{true} - Determines the behavior of the
@code{rootscontract} command.  See @code{rootscontract} for details.

@end defvar

@defun rootscontract (@var{expr})
converts products of roots into roots of products.
For example,

@example
rootscontract(sqrt(x)*y^(3/2)) ==> sqrt(x*y^3)
@end example

When
@code{radexpand} is @code{true} and @code{domain} is @code{real} (their defaults), 
@code{rootscontract}
converts @code{abs} into @code{sqrt}, e.g.

@example
rootscontract(abs(x)*sqrt(y)) ==> sqrt(x^2*y)
@end example

There is an option @code{rootsconmode}
affecting @code{rootscontract} as follows:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

The above examples and more may be tried out by typing 

@example
example(rootscontract);
@end example

When @code{rootsconmode} is @code{false}, @code{rootscontract} contracts only wrt rational 
number exponents whose denominators are the same.  The key to the 
@code{rootsconmode: true} examples is simply that 2 divides into 4 but not 
into 3.  @code{rootsconmode: all} involves taking the lcm (least common multiple)
of the denominators of the exponents.

@code{rootscontract} uses @code{ratsimp} in a manner similar to @code{logcontract} (see the 
manual).  

@end defun

@defvar rootsepsilon
Default value: 1.0e-7 - a real number used to establish the
confidence interval for the roots found by the @code{realroots} function.

@end defvar

@defun solve (@var{expr}, @var{var})
solves the algebraic equation exp for the variable
var and returns a list of solution equations in var.  If exp is not an
equation, it is assumed to be an expression to be set equal to zero.
Var may be a function (e.g. F(X)), or other non-atomic expression
except a sum or product. It may be omitted if exp contains only one
variable.  Exp may be a rational expression, and may contain
trigonometric functions, exponentials, etc.

The following method is used:

Let E be the expression and X be the variable.  If E is linear in X
then it is trivially solved for X.  Otherwise if E is of the form
A*X**N+B then the result is (-B/A)**(1/N) times the Nth roots of
unity.

If E is not linear in X then the gcd of the exponents of X in E (say
N) is divided into the exponents and the multiplicity of the roots is
multiplied by N.  Then @code{solve} is called again on the result.
If E factors then @code{solve} is called on each of the factors.  Finally
@code{solve} will use the quadratic, cubic, or quartic formulas where
necessary.

In the case where E is a polynomial in some function of the variable
to be solved for, say F(X), then it is first solved for F(X) (call the
result C), then the equation F(X)=C can be solved for X provided the
inverse of the function F is known.

@code{breakup} if @code{false} will cause @code{solve} to express the solutions of
cubic or quartic equations as single expressions rather than as made
up of several common subexpressions which is the default.

@code{multiplicities} - will be set to a list of the multiplicities of
the individual solutions returned by @code{solve}, @code{realroots}, or @code{allroots}.
Try @code{apropos (solve)} for the switches which affect @code{solve}.  @code{describe} may
then by used on the individual switch names if their purpose is not
clear.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
solves a system of simultaneous
(linear or non-linear) polynomial equations by calling @code{linsolve} or
@code{algsys} and returns a list of the solution lists in the variables.  In
the case of @code{linsolve} this list would contain a single list of
solutions.  It takes two lists as arguments.  The first list (eqi,
i=1,...,n) represents the equations to be solved; the second list is a
list of the unknowns to be determined.  If the total number of
variables in the equations is equal to the number of equations, the
second argument-list may be omitted.  For linear systems if the given
equations are not compatible, the message @code{inconsistent} will be
displayed (see the @code{solve_inconsistent_error} switch); if no unique
solution exists, then @code{singular} will be displayed.

For examples, do @code{example (solve)}.

@end defun

@defvar solvedecomposes
Default value: @code{true} - if @code{true}, will induce @code{solve} to use
@code{polydecomp} (see @code{polydecomp}) in attempting to solve polynomials.

@end defvar

@defvar solveexplicit
Default value: @code{false} - if @code{true}, inhibits @code{solve} from
returning implicit solutions i.e. of the form F(x)=0.

@end defvar

@defvar solvefactors
Default value: @code{true} - if @code{false} then @code{solve} will not try to
factor the expression.  The @code{false} setting may be desired in some cases
where factoring is not necessary.

@end defvar

@defvar solvenullwarn
Default value: @code{true} - if @code{true} the user will be warned if he
calls @code{solve} with either a null equation list or a null variable list.
For example, @code{solve ([], [])} would print two warning messages and return
[].

@end defvar

@defvar solveradcan
Default value: @code{false} - if @code{true} then @code{solve} will use @code{radcan}
which will make @code{solve} slower but will allow certain problems
containing exponentials and logs to be solved.

@end defvar

@defvar solvetrigwarn
Default value: @code{true} - if set to @code{false} will inhibit printing
by @code{solve} of the warning message saying that it is using inverse
trigonometric functions to solve the equation, and thereby losing
solutions.

@end defvar

@defvar solve_inconsistent_error
Default value: @code{true} - If @code{true}, @code{solve} and
@code{linsolve} give an error if they meet up with a set of inconsistent
linear equations, e.g. @code{solve ([a + b = 1, a + b = 2])}.  If @code{false}, they return []
in this case.  (This is the new mode, previously gotten only by
calling @code{algsys}.)

@end defvar
