@menu
* Introduction to Rules and Patterns::  
* Definitions for Rules and Patterns::  
@end menu

@node Introduction to Rules and Patterns, Definitions for Rules and Patterns, Rules and Patterns, Rules and Patterns
@section Introduction to Rules and Patterns

This section describes user-defined pattern matching and
simplification rules.
There are two groups of functions which implement somewhat different pattern matching schemes.
In one group are @code{tellsimp}, @code{tellsimpafter}, @code{defmatch}, @code{defrule},
@code{apply1}, @code{applyb1}, and @code{apply2}.
In the other group are @code{let} and @code{letsimp}.
Both schemes define patterns in terms of pattern variables declared by @code{matchdeclare}.

Pattern-matching rules defined by @code{tellsimp} and @code{tellsimpafter} are applied automatically
by the Maxima simplifier.
Rules defined by @code{defmatch}, @code{defrule}, and @code{let} are applied
by an explicit function call.

There are additional mechanisms for rules applied to polynomials by @code{tellrat},
and for commutative and noncommutative algebra in @code{affine} package. 

@c end concepts Rules and Patterns
@node Definitions for Rules and Patterns,  , Introduction to Rules and Patterns, Rules and Patterns
@section Definitions for Rules and Patterns

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} apply1 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
Repeatedly applies @var{rule_1} to
@var{expr} until it fails, then repeatedly applies the same rule to all
subexpressions of @var{expr}, left to right, until @var{rule_1} has failed
on all subexpressions.  Call the result of transforming @var{expr} in this
manner @var{expr_2}.  Then @var{rule_2} is applied in the same fashion
starting at the top of @var{expr_2}.  When @var{rule_n} fails on the final
subexpression, the result is returned.

@code{maxapplydepth} is the depth of the deepest subexpressions processed by
@code{apply1} and @code{apply2}.

See also @code{applyb1}, @code{apply2}, and @code{let}.

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} apply2 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
If @var{rule_1} fails on a given subexpression, then @var{rule_2} is
repeatedly applied, etc.  Only if all rules fail on a given
subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same
subexpression is reprocessed, starting with the first rule.

@code{maxapplydepth} is the depth of the deepest subexpressions processed by
@code{apply1} and @code{apply2}.

See also @code{apply1} and @code{let}.

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} applyb1 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
Repeatedly applies @var{rule_1} to the deepest subexpression of @var{expr} until it fails,
then repeatedly applies the same rule one level higher (i.e., larger subexpressions),
until @var{rule_1} has failed on the top-level expression.
Then @var{rule_2} is applied in the same fashion to the result of @var{rule_1}.
After @var{rule_n} has been applied to the top-level expression,
the result is returned.

@code{applyb1} is similar to @code{apply1} but works from
the bottom up instead of from the top down.

@code{maxapplyheight} is the maximum height which @code{applyb1} reaches
before giving up.

See also @code{apply1}, @code{apply2}, and @code{let}.

@end deffn

@defvr {Option variable} current_let_rule_package
Default value: @code{default_let_rule_package}

@code{current_let_rule_package} is the name of the rule package that is used by
functions in the @code{let} package (@code{letsimp}, etc.) @c NEED TO GIVE AN EXPLICIT LIST HERE (NOT "ETC")
if no other rule package is specified.
This variable may be assigned the name of any rule package defined
via the @code{let} command.

If a call such as @code{letsimp (expr, rule_pkg_name)} is made,
the rule package @code{rule_pkg_name} is used for that function call only,
and the value of @code{current_let_rule_package} is not changed.

@end defvr

@defvr {Option variable} default_let_rule_package
@c DEFAULT BINDING OF default_let_rule_package IS default_let_rule_package (BOUND TO ITSELF)
Default value: @code{default_let_rule_package}

@c THIS IS SORT OF CONFUSING. PROBABLY NEED TO GIVE MORE DETAIL HERE
@code{default_let_rule_package} is the name of the rule package used when one
is not explicitly set by the user with @code{let} or by changing the value of
@code{current_let_rule_package}.

@end defvr

@deffn {Function} defmatch (@var{progname}, @var{pattern}, @var{x_1}, ..., @var{x_n})
Creates a function @code{@var{progname} (@var{expr}, @var{y_1}, ..., @var{y_n})}
which tests @var{expr} to see if it matches @var{pattern}.

@var{pattern} is an expression
containing the pattern variables @var{x_1}, ..., @var{x_n}
and pattern parameters, if any.
The pattern variables are given
explicitly as arguments to @code{defmatch} while the pattern parameters
are declared by the @code{matchdeclare} function.
@c DOES matchdeclare HAVE TO GO BEFORE defmatch ?? OR CAN IT GO AFTER ??

The first argument to the created function @var{progname} is an expression
to be matched against the pattern and the other arguments are the
actual variables @var{y_1}, ..., @var{y_n}
in the expression which correspond to
the dummy variables @var{x_1}, ..., @var{x_n}
in the pattern.

If the match is successful, @var{progname} returns
a list of equations whose left sides are the
pattern variables and pattern parameters, and whose right sides are the expressions
which the pattern variables and parameters matched.
The pattern parameters, but not the variables, are assigned the subexpressions they match.
If the match fails, @var{progname} returns @code{false}.  

Any variables not declared as pattern parameters in @code{matchdeclare} or as
variables in @code{defmatch} match only themselves.

A pattern which contains no pattern variables or parameters
returns @code{true} if the match succeeds.

See also @code{matchdeclare}, @code{defrule}, @code{tellsimp}, and @code{tellsimpafter}.

Examples:

This @code{defmatch} defines the function @code{linearp (expr, y)}, which
tests @code{expr} to see if it is of the form @code{a*y + b}
such that @code{a} and @code{b} do not contain @code{y}.
@c HOW HARD WILL MAXIMA TRY TO COLLECT TERMS AND DO OTHER MUNGEING TO FIT THE PATTERN ??

@example
(%i1) matchdeclare (a, freeof(x), b, freeof(x))$
(%i2) defmatch (linearp, a*x + b, x)$
(%i3) linearp (3*z + (y+1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
@end example

If the third argument to @code{defmatch} in line (%i2) had
been omitted, then @code{linear} would only match expressions linear in @var{x},
not in any other variable.
@c SHOW THAT IN AN EXAMPLE

@example
(%i1) matchdeclare ([a, f], true)$
(%i2) constinterval (l, h) := constantp (h - l)$
(%i3) matchdeclare (b, constinterval (a))$
(%i4) matchdeclare (x, atom)$
(%i5) (remove (integrate, outative),
          defmatch (checklimits, 'integrate (f, x, a, b)),
          declare (integrate, outative))$
(%i6) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o6)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i7) checklimits (%);
(%o7)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
(%i8) a;
(%o8)                        x + %pi
(%i9) b;
(%o9)                       x + 2 %pi
(%i10) f;
(%o10)                       sin(t)
(%i11) x;
(%o11)                          t
@end example

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} defrule (@var{rulename}, @var{pattern}, @var{replacement})
Defines and names a
replacement rule for the given pattern.  If the rule named @var{rulename} is
applied to an expression (by @code{apply1}, @code{applyb1}, or @code{apply2}), every
subexpression matching the pattern will be replaced by the
replacement. All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.

The rules themselves can be
treated as functions which transform an expression by one
operation of the pattern match and replacement.
If the match fails, the original expression is returned.

@end deffn

@c NEEDS EXAMPLES
@deffn {Function} disprule (@var{rulename_1}, ..., @var{rulename_2})
@deffnx {Function} disprule (all)
Display rules with the names @var{rulename_1}, ..., @var{rulename_n},
as returned by @code{defrule}, @code{tellsimp}, or @code{tellsimpafter},
or a pattern defined by @code{defmatch}.

@c STRIKE THIS AND MAKE IT AN EXAMPLE INSTEAD
For example, the first rule modifying @code{sin} is named @code{sinrule1}.

@code{disprule (all)} displays all rules.

See also @code{letrules}, which displays rules defined by @code{let}.

@end deffn

@deffn {Function} let (@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, ..., @var{arg_n})
@deffnx {Function} let ([@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, ..., @var{arg_n}], @var{package_name})
Defines a substitution rule for @code{letsimp} such that @var{prod} is replaced by @var{repl}.
@var{prod} is a product of positive or negative powers of the following terms:

@itemize @bullet
@item
Atoms which @code{letsimp} will search for literally unless previous
to calling @code{letsimp} the @code{matchdeclare} function is used to associate a
predicate with the atom.  In this case @code{letsimp} will match the atom to
any term of a product satisfying the predicate.
@item
Kernels such as @code{sin(x)}, @code{n!}, @code{f(x,y)}, etc.  As with atoms above
@code{letsimp} will look for a literal match unless @code{matchdeclare} is used to
associate a predicate with the argument of the kernel.
@end itemize

A term to a positive power will only match a term having at least that
power.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in @var{prod} the switch
@code{letrat} must be set to @code{true}.
See also @code{letrat}.

If a predicate is included in the @code{let} function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the
predicate were omitted) is accepted only if
@code{predname (arg_1', ..., arg_n')} evaluates to @code{true} where @var{arg_i'} is the value
matched to @var{arg_i}.  The @var{arg_i} may be the name of any atom or the argument
of any kernel appearing in @var{prod}.
@var{repl} may be any rational expression. @c ONLY RATIONAL -- REALLY ??
If any of the atoms or arguments from @var{prod} appear in @var{repl} the
appropriate substitutions are made. @c SPELL OUT "APPROPRIATE" IN THIS CONTEXT

The global flag @code{letrat} controls the simplification of quotients by @code{letsimp}.
When @code{letrat} is @code{false},
@code{letsimp} simplifies the numerator and
denominator of @var{expr} separately, and does not simplify the quotient.
Substitutions such as @code{n!/n} goes to @code{(n-1)!} then fail.
When @code{letrat} is @code{true}, then the numerator,
denominator, and the quotient are simplified in that order.

These substitution functions allow you to work with several rule packages at once.
Each rule package can contain any number of @code{let}
rules and is referenced by a user-defined name.
@code{let ([@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, ..., @var{arg_n}], @var{package_name})}
adds the rule @var{predname} to the rule package @var{package_name}.
@code{letsimp (@var{expr}, @var{package_name})} 
applies the rules in @var{package_name}.
@code{letsimp (@var{expr}, @var{package_name1}, @var{package_name2}, ...)}
is equivalent to @code{letsimp (@var{expr}, @var{package_name1})}
followed by @code{letsimp (%, @var{package_name2})}, ....

@code{current_let_rule_package} is the name of the rule package that is
presently being used.
This variable may be assigned the name of
any rule package defined via the @code{let} command.
Whenever any of the functions comprising the @code{let} package are called with no package name,
the package named by @code{current_let_rule_package} is used.
If a call such as @code{letsimp (@var{expr}, @var{rule_pkg_name})} is made,
the rule package @var{rule_pkg_name} is used for that @code{letsimp} command only,
and @code{current_let_rule_package} is not changed.
If not otherwise specified,
@code{current_let_rule_package} defaults to @code{default_let_rule_package}.

@example
(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --> a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --> (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --> 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
@end example

@c NEEDS ADDITIONAL EXAMPLES
@end deffn

@defvr {Option variable} letrat
Default value: @code{false}

When @code{letrat} is @code{false}, @code{letsimp} simplifies the
numerator and denominator of a ratio separately,
and does not simplify the quotient.

When @code{letrat} is @code{true},
the numerator, denominator, and their quotient are simplified in that order.

@example
(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --> (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
@end example

@end defvr

@c NEEDS EXAMPLES
@deffn {Function} letrules ()
@deffnx {Function} letrules (@var{package_name})
Displays the rules in a rule package.
@code{letrules ()} displays the rules in the current rule package.
@code{letrules (@var{package_name})} displays the rules in @code{package_name}.

The current rule package is named by @code{current_let_rule_package}.
If not otherwise specified, @code{current_let_rule_package}
defaults to @code{default_let_rule_package}.

See also @code{disprule}, which displays rules defined by @code{tellsimp} and @code{tellsimpafter}.
@c WHAT ABOUT defmatch AND defrule ??

@end deffn

@deffn {Function} letsimp (@var{expr})
@deffnx {Function} letsimp (@var{expr}, @var{package_name})
@deffnx {Function} letsimp (@var{expr}, @var{package_name_1}, ..., @var{package_name_n})
Repeatedly applies the substitution rules defined by @code{let}
until no further change is made to @var{expr}.

@code{letsimp (@var{expr})} uses the rules from @code{current_let_rule_package}.

@code{letsimp (@var{expr}, @var{package_name})} uses the rules from @var{package_name}
without changing @code{current_let_rule_package}.

@code{letsimp (@var{expr}, @var{package_name_1}, ..., @var{package_name_n})}
is equivalent to @code{letsimp (@var{expr}, @var{package_name_1}},
followed by @code{letsimp (%, @var{package_name_2})}, and so on.

@c NEEDS EXAMPLES
@end deffn

@defvr {Option variable} let_rule_packages
Default value: @code{[default_let_rule_package]}

@code{let_rule_packages} is a list of all user-defined let rule packages
plus the default package @code{default_let_rule_package}.

@end defvr

@deffn {Function} matchdeclare (@var{a_1}, @var{pred_1}, ..., @var{a_n}, @var{pred_n})
Associates a predicate @var{pred_k} 
with a variable or list of variables @var{a_k}
so that @var{a_k} matches expressions
for which the predicate returns anything other than @code{false}.

The predicate is the name of a function,
a function call missing the last argument,
or @code{true}.
Any expression matches @code{true}.
If the predicate is specified as a function call,
the expression to be tested is appended to the list of arguments;
the arguments are evaluated at the time the match is evaluated.
Otherwise, the predicate is specified as a function name,
and the expression to be tested is the sole argument.
A predicate function need not be defined when @code{matchdeclare} is called;
the predicate is not evaluated until a match is attempted.

A @code{matchdeclare} predicate cannot be any kind of expression other than a function name or function call.
In particular, a predicate cannot be a @code{lambda} or @code{block}.
@c defrule, defmatch, tellsimp/tellsimpafter, let ALL BARF ON LAMBDAS AND OTHER EXPRESSIONS
@c BUT NOT ENFORCED BY matchdeclare -- THIS IS A BUG

If an expression satisfies a match predicate,
the match variable is assigned the expression,
except for match variables which are operands of addition @code{+} or multiplication @code{*}.
Only addition and multiplication are handled specially;
other n-ary operators (both built-in and user-defined) are treated like ordinary functions.
@c WOULD BE GREAT TO EXTEND PART+/PART* PROCESSING TO ALL N-ARY OPERATORS

In the case of addition and multiplication,
the match variable may be assigned a single expression which satisfies the match predicate,
or a sum or product (respectively) of such expressions.
Such multiple-term matching is greedy:
predicates are evaluated in the order in which their associated variables
appear in the match pattern,
and a term which satisfies more than one predicate is taken by the first
predicate which it satisfies.
Each predicate is tested against all operands of the sum or product before the next predicate is evaluated.
In addition,
if 0 or 1 (respectively) satisfies a match predicate,
and there are no other terms which satisfy the predicate,
0 or 1 is assigned to the match variable associated with the predicate.

The algorithm for processing addition and multiplication patterns makes some match results
(for example, a pattern in which a "match anything" variable appears)
dependent on the ordering of terms in the match pattern and in the expression to be matched.
However,
if all match predicates are mutually exclusive,
the match result is insensitive to ordering,
as one match predicate cannot accept terms matched by another.

Calling @code{matchdeclare} with a variable @var{a} as an argument
changes the @code{matchdeclare} property for @var{a}, if one was already declared;
only the most recent @code{matchdeclare} is in effect when a rule is defined,
Later changes to the @code{matchdeclare} property
(via @code{matchdeclare} or @code{remove})
do not affect existing rules.

@code{propvars (matchdeclare)} returns the list of all variables
for which there is a @code{matchdeclare} property.
@code{printprops (@var{a}, matchdeclare)} returns the predicate for variable @code{a}.
@code{printprops (all, matchdeclare)} returns the list of predicates for all @code{matchdeclare} variables.
@code{remove (@var{a}, matchdeclare)} removes the @code{matchdeclare} property from @var{a}.

The functions
@code{defmatch}, @code{defrule}, @code{tellsimp}, @code{tellsimpafter}, and @code{let}
construct rules which test expressions against patterns.

@code{matchdeclare} quotes its arguments.
@code{matchdeclare} always returns @code{done}.

Examples:

@itemize @bullet
@item
@code{q} matches an expression not containing @code{x} or @code{%e}.
@end itemize
@example
(%i1) matchdeclare (q, freeof (x, %e))$
@end example

@end deffn

@deffn {Function} matchfix (@var{ldelimiter}, @var{rdelimiter})
@deffnx {Function} matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})
Declares a matchfix operator with left and right delimiters @var{ldelimiter} and @var{rdelimiter}.
The delimiters are specified as strings.

A "matchfix" operator is a function of any number of arguments,
such that the arguments occur between matching left and right delimiters.
The delimiters may be any strings, so long as the parser can
distinguish the delimiters from the operands 
and other expressions and operators.
In practice this rules out unparseable delimiters such as
@code{%}, @code{,}, @code{$} and @code{;}, 
and may require isolating the delimiters with white space.
The right delimiter can be the same or different from the left delimiter.

A left delimiter can be associated with only one right delimiter;
two different matchfix operators cannot have the same left delimiter.

An existing operator may be redeclared as a matchfix operator
without changing its other properties.
In particular, built-in operators such as addition @code{+} can
be declared matchfix,
but operator functions cannot be defined for built-in operators.

@code{matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})} 
declares the argument part-of-speech @var{arg_pos} 
and result part-of-speech @var{pos}, 
and the delimiters @var{ldelimiter} and @var{rdelimiter}.

@c DUNNO IF WE REALLY NEED TO MENTION BINDING POWER HERE -- AS NOTED IT'S IRRELEVANT
@c An operator declared by @code{matchfix} is assigned a low binding power.
@c Since a matchfix operator must be evaluated before any expression
@c which contains it,
@c binding power is effectively irrelevant
@c to the declaration of a matchfix operator.

The function to carry out a matchfix operation is an ordinary
user-defined function.
The operator function is defined
in the usual way
with the function definition operator @code{:=} or @code{define}.
The arguments may be written between the delimiters,
or with the left delimiter as a quoted string and the arguments
following in parentheses.
@code{dispfun (@var{ldelimiter})} displays the function definition.

The only built-in matchfix operator is the list constructor @code{[ ]}.
Parentheses @code{( )} and double-quotes @code{" "} 
act like matchfix operators,
but are not treated as such by the Maxima parser.

@code{matchfix} evaluates its arguments.
@code{matchfix} returns its first argument, @var{ldelimiter}.
@c HOW TO TAKE AWAY THE MATCHFIX PROPERTY ??

Examples:

@itemize @bullet
@item
Delimiters may be almost any strings.
@end itemize
@example
(%i1) matchfix ("@@", "~");
(%o1)                          "@@"
(%i2) @@ a, b, c ~;
(%o2)                       @@a, b, c~
(%i3) matchfix (">>", "<<");
(%o3)                         ">>"
(%i4) >> a, b, c <<;
(%o4)                      >>a, b, c<<
(%i5) matchfix ("foo", "oof");
(%o5)                         "foo"
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                     >>z + foox, yoof + w<<
(%o7)                ----------------------
                             @@p, q~
@end example

@itemize @bullet
@item
Matchfix operators are ordinary user-defined functions.
@end itemize
@example
(%i1) matchfix ("!-", "-!");
(%o1)                         "!-"
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define ("!-" (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun ("!-");
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) "!-" (3, 5);
                                16
(%o7)                         - --
                                15
@end example

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Function} remlet (@var{prod}, @var{name})
@deffnx {Function} remlet ()
@deffnx {Function} remlet (all)
@deffnx {Function} remlet (all, @var{name})
Deletes the substitution rule, prod --> repl, most
recently defined by the @code{let} function.  If name is supplied the rule is
deleted from the rule package name.

@code{remlet()} and @code{remlet(all)} delete all substitution rules from the current rule package.
If the name of a rule package is supplied,
e.g. @code{remlet (all, @var{name})}, the rule package @var{name} is also deleted.

If a substitution is to be changed using the same
product, @code{remlet} need not be called, just redefine the substitution
using the same product (literally) with the @code{let} function and the new
replacement and/or predicate name.  Should @code{remlet (@var{prod})} now be
called the original substitution rule is revived.

See also @code{remrule}, which removes a rule defined by @code{tellsimp} or @code{tellsimpafter}.

@end deffn

@deffn {Function} remrule (@var{op}, @var{rulename})
@deffnx {Function} remrule (@var{op}, all)
Removes rules defined by @code{defrule}, @code{defmatch}, @code{tellsimp}, or @code{tellsimpafter}.

@code{remrule (@var{op}, @var{rulename})}
removes the rule with the name @code{rulename} from the operator @var{op}.

@code{remrule (@var{function}, all)} removes all rules for the operator @var{op}.

See also @code{remlet}, which removes a rule defined by @code{let}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION OR MAYBE JUST APPROPRIATE REFS TO tellsimpafter
@deffn {Function} tellsimp (@var{pattern}, @var{replacement})
is similar to @code{tellsimpafter} but places
new information before old so that it is applied before the built-in
simplification rules.

@code{tellsimp} is used when it is important to modify
the expression before the simplifier works on it, for instance if the
simplifier "knows" something about the expression, but what it returns
is not to your liking.
If the simplifier "knows" something about the
main operator of the expression, but is simply not doing enough for
you, you probably want to use @code{tellsimpafter}.

The pattern may not be a
sum, product, single variable, or number.

@code{rules} is the list of rules defined by
@code{defrule}, @code{defmatch}, @code{tellsimp}, and @code{tellsimpafter}.

Examples:

@example
(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule ("^", %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
@end example

@end deffn

@deffn {Function} tellsimpafter (@var{pattern}, @var{replacement})
Defines a simplification rule which the Maxima simplifier
applies after built-in simplification rules.
@var{pattern} is an expression, comprising pattern variables (declared by @code{matchdeclare})
and other atoms and operators, considered literals for the purpose of pattern matching.
@var{replacement} is substituted for an actual expression which matches @var{pattern};
pattern variables in @var{replacement} are assigned the values matched in the actual expression.

@var{pattern} may be any nonatomic expression
in which the main operator is not a pattern variable;
the simplification rule is associated with the main operator.
The names of functions (with one exception, described below), lists, and arrays
may appear in @var{pattern} as the main operator only as literals (not pattern variables);
this rules out expressions such as @code{aa(x)} and @code{bb[y]} as patterns,
if @code{aa} and @code{bb} are pattern variables.
Names of functions, lists, and arrays which are pattern variables may appear as operators
other than the main operator in @var{pattern}.

There is one exception to the above rule concerning names of functions.
The name of a subscripted function in an expression such as @code{aa[x](y)}
may be a pattern variable,
because the main operator is not @code{aa} but rather the Lisp atom @code{mqapply}.
This is a consequence of the representation of expressions involving subscripted functions.

@c LET'S NOT GO INTO DETAILS ABOUT MAIN OPERATORS HERE; BUT PRESERVE THIS FOR REFERENCE
@c The main operator of an expression @code{expr} is @code{caar $expr}.
@c For most kinds of expressions,
@c the main operator is the operator returned by @code{op (@var{pattern})};
@c the sole exception is the operator @code{mqapply},
@c which appears in indexed function expressions (e.g., @code{foo[i](x)}).

@c NEED TO REVIEW THIS PARAGRAPH FOR ACCURACY
Simplification rules are applied after evaluation 
(if not suppressed through quotation or the flag @code{noeval}).
Rules established by @code{tellsimpafter} are applied in the order they were defined,
and after any built-in rules.
Rules are applied bottom-up, that is,
applied first to subexpressions before application to the whole expression.
@c NO IT IS MORE COMPLICATED THAN THIS, ALTHOUGH IN SOME CIRCUMSTANCE IT APPEARS TO BE THE CASE:
@c For a given expression, at most one rule per operator is applied.
It may be necessary to repeatedly simplify a result
(for example, via the quote-quote operator @code{'@w{}'} or the flag @code{infeval})
to ensure that all rules are applied.

Pattern variables are treated as local variables in simplification rules.
Once a rule is defined, the value of a pattern variable
does not affect the rule, and is not affected by the rule.
An assignment to a pattern variable which results from a successful rule match
does not affect the current assignment (or lack of it) of the pattern variable.
However,
as with all atoms in Maxima,
the properties of pattern variables (as declared by @code{put} and related functions) are global.

The rule constructed by @code{tellsimpafter} is named after the main operator of @code{pattern}.
Rules for built-in operators, 
and user-defined operators 
defined by @code{infix}, @code{prefix}, @code{postfix}, @code{matchfix}, and @code{nofix},
have names which are Maxima strings.
@c SLIGHTLY TOO MUCH DETAIL
@c (that is, the name begins with ampersand @code{&}).
Rules for other functions have names which are ordinary Maxima identifiers.
@c SLIGHTLY TOO MUCH DETAIL
@c (that is, the name begins with dollar sign @code{$}).

The treatment of noun and verb forms is slightly confused. @c THIS IS A BUG.
If a rule is defined for a noun (or verb) form
and a rule for the corresponding verb (or noun) form already exists, 
the newly-defined rule applies to both forms (noun and verb).
If a rule for the corresponding verb (or noun) form does not exist,
the newly-defined rule applies only to the noun (or verb) form.

The rule constructed by @code{tellsimpafter} is an ordinary Lisp function.
If the name of the rule is @code{$foorule1},
the construct @code{:lisp (trace $foorule1)} traces the function,
and @code{:lisp (symbol-function '$foorule1} displays its definition.

@code{tellsimpafter} quotes its arguments.
@code{tellsimpafter} returns the list of rules for the main operator of @var{pattern},
including the newly established rule.
@c WHAT IS simpfoo THAT SOMETIMES APPEARS, AND WHY DOES false SOMETIMES APPEAR IN RETURN VALUE ??

See also @code{matchdeclare}, @code{defmatch}, @code{defrule}, @code{tellsimp}, @code{let},
@code{kill}, @code{remrule}, and @code{clear_rules}.

Examples:

@var{pattern} may be any nonatomic expression in which the 
main operator is not a pattern variable.

@c ===beg===
@c matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
@c tellsimpafter (sin (ll), map (sin, ll));
@c sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
@c tellsimpafter (ll^mm, map ("^", ll, mm));
@c [a, b, c]^[1, 2, 3];
@c tellsimpafter (foo (aa (xx)), aa (foo (xx)));
@c foo (bar (u - v));
@c ===end===
@example
(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
@end example

Rules are applied in the order they were defined.
If two rules can match an expression,
the rule which was defined first is applied.

@c ===beg===
@c matchdeclare (aa, integerp);
@c tellsimpafter (foo (aa), bar_1 (aa));
@c tellsimpafter (foo (aa), bar_2 (aa));
@c foo (42);
@c ===end===
@example
(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
@end example

Pattern variables are treated as local variables in simplification rules.
(Compare to @code{defmatch}, which treats pattern variables as global variables.)

@c ===beg===
@c matchdeclare (aa, integerp, bb, atom);
@c tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
@c bb: 12345;
@c foo (42, %e);
@c bb;
@c ===end===
@example
(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
@end example

As with all atoms, properties of pattern variables are global even though values are local.
In this example, an assignment property is declared via @code{define_variable}.
This is a property of the atom @code{bb} throughout Maxima.

@c ===beg===
@c matchdeclare (aa, integerp, bb, atom);
@c tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
@c foo (42, %e);
@c define_variable (bb, true, boolean);
@c foo (42, %e);
@c ===end===
@example
(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example

Rules are named after main operators.
Names of rules for built-in and user-defined operators are strings,
while names for other functions are ordinary identifiers.

@c ===beg===
@c tellsimpafter (foo (%pi + %e), 3*%pi);
@c tellsimpafter (foo (%pi * %e), 17*%e);
@c tellsimpafter (foo (%i ^ %e), -42*%i);
@c tellsimpafter (foo (9) + foo (13), quux (22));
@c tellsimpafter (foo (9) * foo (13), blurf (22));
@c tellsimpafter (foo (9) ^ foo (13), mumble (22));
@c rules;
@c foorule_name: first (%o1);
@c plusrule_name: first (%o4);
@c [?mstringp (foorule_name), symbolp (foorule_name)];
@c [?mstringp (plusrule_name), symbolp (plusrule_name)];
@c remrule (foo, foorule1);
@c remrule ("^", "^rule1");
@c ===end===
@example
(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4, 
htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1, 
foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
(%o10)                    [false, true]
(%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
(%o11)                    [true, true]
(%i12) remrule (foo, foorule1);
(%o12)                         foo
(%i13) remrule ("^", "^rule1");
(%o13)                          ^
@end example

@end deffn

@deffn {Function} clear_rules ()
Executes @code{kill (rules)} and then resets the next rule number to 1
for addition @code{+}, multiplication @code{*}, and exponentiation @code{^}.

@end deffn
