@menu
* Introduction to Rules and Patterns::  
* Definitions for Rules and Patterns::  
@end menu

@node Introduction to Rules and Patterns, Definitions for Rules and Patterns, Rules and Patterns, Rules and Patterns
@section Introduction to Rules and Patterns

   This section discusses user defined pattern matching and
simplification rules (set up by @code{tellsimp}, @code{tellsimpafter}, @code{defmatch}, or,
@code{defrule}.)  You may affect the main simplification procedures, or 
else have your rules applied explicityly using @code{apply1} and @code{apply2}.
   There are additional mechanisms for polynomials rules under @code{tellrat},
and for commutative and non commutative algebra in chapter on @code{affine}. 

@c end concepts Rules and Patterns
@node Definitions for Rules and Patterns,  , Introduction to Rules and Patterns, Rules and Patterns
@section Definitions for Rules and Patterns

@defun apply1 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
repeatedly applies the first rule to
exp until it fails, then repeatedly applies the same rule to all
subexpressions of exp, left-to-right, until the first rule has failed
on all subexpressions.  Call the result of transforming exp in this
manner exp'.  Then the second rule is applied in the same fashion
starting at the top of exp'.  When the final rule fails on the final
subexpression, the application is finished.

@end defun

@defun apply2 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
differs from @code{apply1} in that if the
first rule fails on a given subexpression, then the second rule is
repeatedly applied, etc.  Only if they all fail on a given
subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same
subexpression is reprocessed, starting with the first rule.
@code{maxapplydepth} is the maximum depth to which @code{apply1} and @code{apply2}
will delve.

@end defun

@defun applyb1 (@var{expr}, @var{rule_1}, ..., @var{rule_n})
is similar to @code{apply1} but works from
the "bottom up" instead of from the "top down".  That is, it processes
the smallest subexpression of exp, then the next smallest, etc.
@code{maxapplyheight} is the maximum height to which @code{applyb1} will
reach before giving up.

@end defun

@defvar current_let_rule_package
 default:[@code{default_let_rule_package}] - the
name of the rule package that is presently being used.  The user may
reset this variable to the name of any rule package previously defined
via the @code{let} command.  Whenever any of the functions comprising the let
package are called with no package name the value of
@example
current_let_rule_package
@end example
is used.  If a call such as
@code{letsimp (expr, rule_pkg_name)} is made, the rule package rule_pkg_name
is used for that @code{letsimp} command only, i.e.  the value of
@code{current_let_rule_package} is not changed.

@end defvar

@defvar default_let_rule_package
 - the name of the rule package used when one
is not explicitly set by the user with @code{let} or by changing the value of
@code{current_let_rule_package}.

@end defvar

@defun defmatch (@var{progname}, @var{pattern}, @var{x_1}, ..., @var{x_n})
Creates a function @code{@var{progname} (@var{expr}, @var{y_1}, ..., @var{y_n})}
which tests @var{expr} to see if it matches @var{pattern}.

@var{pattern} is an expression
containing the pattern variables @var{x_1}, ..., @var{x_n}
and pattern parameters, if any.
The pattern variables are given
explicitly as arguments to @code{defmatch} while the pattern parameters
are declared by the @code{matchdeclare} function.
@c DOES matchdeclare HAVE TO GO BEFORE defmatch ?? OR CAN IT GO AFTER ??

The first argument to the created function @var{progname} is an expression
to be matched against the pattern and the other arguments are the
actual variables @var{y_1}, ..., @var{y_n}
in the expression which correspond to
the dummy variables @var{x_1}, ..., @var{x_n}
in the pattern.

If the match is successful, @var{progname} returns
a list of equations whose left sides are the
pattern variables and pattern parameters, and whose right sides are the expressions
which the pattern variables and parameters matched.
The pattern parameters, but not the variables, are assigned the subexpressions they match.
If the match fails, @var{progname} returns @code{false}.  

Any variables not declared as pattern parameters in @code{matchdeclare} or as
variables in @code{defmatch} match only themselves.

A pattern which contains no pattern variables or parameters
returns @code{true} if the match succeeds.

Examples:

@example
(%i1) matchdeclare (a, freeof(x), b, freeof(x))$
(%i2) defmatch (linearp, a*x + b, x)$
@end example

This @code{defmatch} defines the function @code{linearp (expr, y)}, which
tests @code{expr} to see if it is of the form @code{a*y + b}
such that @code{a} and @code{b} do not contain @code{y}.

@c HOW HARD WILL MAXIMA TRY TO COLLECT TERMS AND DO OTHER MUNGEING TO FIT THE PATTERN ??
@example
(%i3) linearp (3*z + (y+1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
@end example

If the third argument to the @code{defmatch} in (%i4) had
been omitted, then @code{linear} would only match expressions linear in X,
not in any other variable.
@c SHOW THAT IN AN EXAMPLE

@example
(%i1) matchdeclare ([a, f], true)$
(%i2) constinterval (l, h) := constantp (h - l)$
(%i3) matchdeclare (b, constinterval (a))$
(%i4) matchdeclare (x, atom)$
(%i5) (remove (integrate, outative),
          defmatch (checklimits, 'integrate (f, x, a, b)),
          declare (integrate, outative))$
(%i6) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o6)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i7) checklimits (%);
(%o7)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
(%i8) a;
(%o8)                        x + %pi
(%i9) b;
(%o9)                       x + 2 %pi
(%i10) f;
(%o10)                       sin(t)
(%i11) x;
(%o11)                          t
@end example

@end defun

@defun defrule (@var{rulename}, @var{pattern}, @var{replacement})
defines and names a
replacement rule for the given pattern.  If the rule named rulename is
applied to an expression (by one of the @code{apply} functions below), every
subexpression matching the pattern will be replaced by the
replacement.  All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.  The rules themselves can be
treated as functions which will transform an expression by one
operation of the pattern match and replacement.  If the pattern fails,
the original expression is returned.

@end defun

@defun disprule (@var{rulename_1}, @var{rulename_2}, ...)
will display rules with the names
rulename1, rulename2, as were given by @code{defrule}, @code{tellsimp}, or
@code{tellsimpafter} or a pattern defined by @code{defmatch}.  For example, the
first rule modifying @code{sin} will be called @code{sinrule1}.  @code{disprule (all)}
will display all rules.

@end defun

@defun let (@var{prod}, @var{repl}, @var{predname}, @var{arg_1}, ..., @var{arg_n})
defines a
substitution rule for @code{letsimp} such that prod gets replaced by repl.
prod is a product of positive or negative powers of the following
types of terms:
@itemize @bullet
@item
    (1) Atoms which @code{letsimp} will search for literally unless previous
to calling @code{letsimp} the @code{matchdeclare} function is used to associate a
predicate with the atom.  In this case @code{letsimp} will match the atom to
any term of a product satisfying the predicate.
@item
    (2) Kernels such as SIN(X), N!, F(X,Y), etc.  As with atoms above
@code{letsimp} will look for a literal match unless @code{matchdeclare} is used to
associate a predicate with the argument of the kernel.
A term to a positive power will only match a term having at least that
power in the expression being @code{letsimp}'ed.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in "product" the switch
@code{letrat} must be set to @code{true} (see below).
If a predicate is included in the @code{let} function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the
predicate were omitted) will be accepted only if
predname(arg1',...,argn') evaluates to @code{true} where argi' is the value
matched to argi.  The argi may be the name of any atom or the argument
of any kernel appearing in prod.  repl may be any rational expression.
If any of the atoms or arguments from prod appear in repl the
appropriate substitutions will be made.
@end itemize
    @code{letrat}[@code{false}] when @code{false}, @code{letsimp} will simplify the numerator and
denominator of expr independently and return the result.
Substitutions such as N!/N goes to (N-1)!  will fail.  To handle such
situations @code{letrat} should be set to @code{true}, then the numerator,
denominator, and their quotient will be simplified in that order.
    These substitution functions allow you to work with several
rulepackages at once. Each rulepackage can contain any number of @code{let}'ed
rules and is referred to by a user supplied name.  To insert a rule
into the rulepackage name, do LET([prod,repl,pred,arg1,...],name).  To
apply the rules in rulepackage name, do LETSIMP(expr, name).  The
function LETSIMP(expr,name1,name2,...)  is equivalent to doing
LETSIMP(expr,name1) followed by LETSIMP(%,name2) etc.
@code{current_let_rule_package} is the name of the rule package that is
presently being used.  The user may reset this variable to the name of
any rule package previously defined via the @code{let} command.  Whenever any
of the functions comprising the let package are called with no package
name the value of @code{current_let_rule_package} is used.  If a call such as
LETSIMP(expr,rule_pkg_name); is made, the rule package rule_pkg_name
is used for that @code{letsimp} command only, i.e.  the value of
@code{current_let_rule_package} is not changed.
There is a @code{default_let_rule_package} which is assumed when no other
name is supplied to any of the functions.  Whenever a @code{let} includes a
rulepackage name that is used as the @code{current_let_rule_package}.

@end defun

@defvar letrat
 default: [@code{false}] - when @code{false}, @code{letsimp} will simplify the
numerator and denominator of expr independently and return the result.
Substitutions such as N!/N goes to (N-1)! will fail.  To handle such
situations @code{letrat} should be set to @code{true}, then the numerator,
denominator, and their quotient will be simplified in that order.

@end defvar

@defun letrules ()
displays the rules in the current rulepackage.
LETRULES(name) displays the rules in the
named rulepackage.
The current rulepackage is the value of
@example
current_let_rule_package
@end example
The initial value of the rules is
@example
default_let_rule_package
@end example

@end defun

@defun letsimp (@var{expr})
will continually apply the substitution rules previously
defined by the function @code{let} until no further change is made to exp.
LETSIMP(expr,rule_pkg_name); will cause the rule package rule_pkg_name
to be used for that @code{letsimp} command only, i.e.  the value of
@code{current_let_rule_package} is not changed.

@end defun

@defvar let_rule_packages
 default:[@code{default_let_rule_package}] - The value of
@code{let_rule_packages} is a list of all the user-defined let rule packages
plus the special package
@example
default_let_rule_package
@end example
This is the name of the rule package used when one
is not explicitly set by the user.

@end defvar

@defun matchdeclare (@var{patternvar}, @var{predicate}, ...)
associates a predicate with
a pattern variable so that the variable will only match expressions
for which the predicate is not @code{false}.  (The matching is accomplished
by one of the functions described below).  For example after
@example
matchdeclare(q,freeof(x,%e))
@end example
is executed, Q will match any expression
not containing X or %E.  If the match succeeds then the variable is
set to the matched expression.  The predicate (in this case @code{freeof}) is
written without the last argument which should be the one against
which the pattern variable is to be tested.  Note that the patternvar
and the arguments to the predicate are evaluated at the time the match
is performed.
The odd numbered argument may also be a list of pattern variables all
of which are to have the associated predicate.  Any even number of
arguments may be given.
For pattern matching, predicates refer to functions which are either
@code{false} or not @code{false} (any non @code{false} value acts like @code{true}).
MATCHDECLARE(var,TRUE) will permit var to match any expression.

@end defun

@defun matchfix (@var{ldelimiter}, @var{rdelimiter})
@defunx matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})
Declares a matchfix operator with left and right delimiters @var{ldelimiter} and @var{rdelimiter}.
The delimiters are specified as strings.

A "matchfix" operator is a function of any number of arguments,
such that the arguments occur between matching left and right delimiters.
The delimiters may be any strings, so long as the parser can
distinguish the delimiters from the operands 
and other expressions and operators.
In practice this rules out unparseable delimiters such as
@code{%}, @code{,}, @code{$} and @code{;}, 
and may require isolating the delimiters with white space.
The right delimiter can be the same or different from the left delimiter.

A left delimiter can be associated with only one right delimiter;
two different matchfix operators cannot have the same left delimiter.

An existing operator may be redeclared as a matchfix operator
without changing its other properties.
In particular, built-in operators such as addition @code{+} can
be declared matchfix,
but operator functions cannot be defined for built-in operators.

@code{matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})} 
declares the argument part-of-speech @var{arg_pos} 
and result part-of-speech @var{pos}, 
and the delimiters @var{ldelimiter} and @var{rdelimiter}.

@c DUNNO IF WE REALLY NEED TO MENTION BINDING POWER HERE -- AS NOTED IT'S IRRELEVANT
@c An operator declared by @code{matchfix} is assigned a low binding power.
@c Since a matchfix operator must be evaluated before any expression
@c which contains it,
@c binding power is effectively irrelevant
@c to the declaration of a matchfix operator.

The function to carry out a matchfix operation is an ordinary
user-defined function.
The operator function is defined
in the usual way
with the function definition operator @code{:=} or @code{define}.
The arguments may be written between the delimiters,
or with the left delimiter as a quoted string and the arguments
following in parentheses.
@code{dispfun (@var{ldelimiter})} displays the function definition.

The only built-in matchfix operator is the list constructor @code{[ ]}.
Parentheses @code{( )} and double-quotes @code{" "} 
act like matchfix operators,
but are not treated as such by the Maxima parser.

@code{matchfix} evaluates its arguments.
@code{matchfix} returns its first argument, @var{ldelimiter}.
@c HOW TO TAKE AWAY THE MATCHFIX PROPERTY ??

Examples:

@itemize @bullet
@item
Delimiters may be almost any strings.
@end itemize
@example
(%i1) matchfix ("@@", "~");
(%o1)                          "@@"
(%i2) @@ a, b, c ~;
(%o2)                       @@a, b, c~
(%i3) matchfix (">>", "<<");
(%o3)                         ">>"
(%i4) >> a, b, c <<;
(%o4)                      >>a, b, c<<
(%i5) matchfix ("foo", "oof");
(%o5)                         "foo"
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                     >>z + foox, yoof + w<<
(%o7)                ----------------------
                             @@p, q~
@end example

@itemize @bullet
@item
Matchfix operators are ordinary user-defined functions.
@end itemize
@example
(%i1) matchfix ("!-", "-!");
(%o1)                         "!-"
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define ("!-" (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun ("!-");
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) "!-" (3, 5);
                                16
(%o7)                         - --
                                15
@end example

@end defun

@defun remlet (@var{prod}, @var{name})
deletes the substitution rule, prod --> repl, most
recently defined by the @code{let} function.  If name is supplied the rule is
deleted from the rule package name.  REMLET() and REMLET(ALL) delete
all substitution rules from the current rulepackage. If the name of a
rulepackage is supplied, e.g. REMLET(ALL,name), the rulepackage, name,
is also deleted.  If a substitution is to be changed using the same
product, @code{remlet} need not be called, just redefine the substitution
using the same product (literally) with the @code{let} function and the new
replacement and/or predicate name.  Should REMLET(product) now be
called the original substitution rule will be revived.

@end defun

@defun remrule (@var{function}, @var{rulename})
will remove a rule with the name rulename
from the function which was placed there by @code{defrule}, @code{defmatch},
@code{tellsimp}, or @code{tellsimpafter}.  If rule-name is @code{all}, then all rules will
be removed.

@end defun

@defun tellsimp (@var{pattern}, @var{replacement})
is similar to @code{tellsimpafter} but places
new information before old so that it is applied before the built-in
simplification rules.  @code{tellsimp} is used when it is important to modify
the expression before the simplifier works on it, for instance if the
simplifier "knows" something about the expression, but what it returns
is not to your liking.  If the simplifier "knows" something about the
main operator of the expression, but is simply not doing enough for
you, you probably want to use @code{tellsimpafter}.  The pattern may not be a
sum, product, single variable, or number.  @code{rules} is a list of names
having simplification rules added to them by @code{defrule}, @code{defmatch},
@code{tellsimp}, or @code{tellsimpafter}.

Examples:

@example
(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule ("^", %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
@end example

@end defun

@defun tellsimpafter (@var{pattern}, @var{replacement})
defines a replacement for pattern
which the Maxima simplifier uses after it applies the built-in
simplification rules.  The pattern may be anything but a single
variable or a number.

@end defun
