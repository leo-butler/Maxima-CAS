@c Language=Russian
@c Encoding=CP1251
@c File=Arrays.texi
@c OriginalRevision=1.11

@menu
* Definitions for Arrays and Tables::
@end menu

@node Definitions for Arrays and Tables,  , Arrays and Tables, Arrays and Tables
@section Функции для работы с массивами и таблицами

@deffn {Function} array (@var{name}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Function} array (@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Function} array ([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})

Создаёт @math{n}-мерный массив.
Значение @math{n} должно быть меньше или равно 5.
@math{i}-й индекс может принимать целочисленное значение от
0 до @var{dim_i}.

@code{array (@var{name}, @var{dim_1}, ..., @var{dim_n})} -- создаёт
массив общего вида.

@code{array (@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})}
-- создаёт массив, элементы которого имеют определённый тип.
@var{type} может быть @code{fixnum} для целых чисел ограниченной
точности и @code{flonum} для чисел с плавающей точкой.

@code{array ([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})}
-- создаёт  @math{m} массивов одинаковой размерности.
@c SAME TYPE AS WELL ??

@c THIS DISCUSSION OF UNDECLARED ARRAYS REALLY WANTS TO BE SOMEWHERE ELSE
Если пользователь присваивает значение переменной с индексом
до того, как соосветствующий массив объявлен, тогда создаётся
необъявленный массив.  Необъявленные массивы, также известные как
хеш-массивы (т.к. для хранения элементов применяется
хеширование), являются более общими чем объявленные массивы.
Пользователь не определяет их максимальный размер, и они
растут динамически по мере присваивания значений их элементам.
Индексы необъявленых массивов даже не обязаны быть целочисленными.
Однако, за исключением случая когда массив сильно разряжен,
объявленный массив, обычно, более эффективен чем неоюъявленный.
Функция @code{array} может преобразовать необъявленный массив
в объявленный.
@c HOW DOES ONE CHANGE AN UNDECLARED ARRAY INTO A DECLARED ARRAY EXACTLY ??

@end deffn

@deffn {Function} arrayapply (@var{A}, [@var{i_1}, ..., @var{i_n}])
Вычисляет значение @code{@var{A} [@var{i_1}, ..., @var{i_n}]},
где  @var{A} -- массив, а @var{i_1}, ..., @var{i_n} целые числа.

Данная функция похожа на @code{apply}, только первый аргумент является
массивом а не функцией.

@end deffn

@deffn {Function} arrayinfo (@var{A})
Возвращает список, содержащий информацию о массиве @var{A}.
Для хешированного массива возвращается: @code{hashed}, число индексов и
список всех индексов имеющих значение.
Для объявленного массива возвращается: @code{declared}, число
индексов и граничные значения индексов, которые были указаны при
создании массива функцией @code{array}.
См. пример @code{example(arrayinfo);}.

@end deffn

@deffn {Function} arraymake (@var{name}, [@var{i_1}, ..., @var{i_n}])
Возвращает выражение @code{@var{name} [@var{i_1}, ..., @var{i_n}]}.

Эта функция похожа на @code{funmake}, за исключением
того, что возвращает невычисленный элемент массива
в отличии от невычисленной функции.

@end deffn

@defvr {System variable} arrays
Значение по умолчанию: @code{[]}

@code{arrays} содержит список всех массивов, как объявленных,
так и хешируемых.

См. также
@code{array}, @code{arrayapply}, @code{arrayinfo}, @code{arraymake},
@code{fillarray}, @code{listarray}, and @code{rearray}.
@c IS THIS AN EXHAUSTIVE LIST ??

@end defvr

@deffn {Function} bashindices (@var{expr})
Преобразут выражение @var{expr} присваивая каждому суммированию или
произведению уникальный индекс.  Индекс имеет форму
@code{j@var{number}}.  Величина @var{number} определяется
значением переменной @code{gensumnum}, которое может быть установлено
пользователем.  Например @code{gensumnum:0$}, инициализирует
эту переменную.

@end deffn

@deffn {Function} fillarray (@var{A}, @var{B})
Заполняет массив @var{A} элементами @var{B}.
@var{B} является списком или массивом.

Если @var{A} является целочисленным массивом или массивом
чисел с плавающей точкой, тогда элементы списка или массив @var{B}
должен иметь соответствующий тип.

Если размерность массивов не совпадает, тогда @var{A}
заполняется построчно.  Если число элементов @var{B} недостаточто, то
последний элемент используется для заполнения остатка @var{A}.
Если число элементов @var{B} слишком велико, тогда излишние отбрасываются.

@code{fillarray} возвращает свой первый аргумент.

@end deffn

@deffn {Function} listarray (@var{A})
Возвращает список элементов объявленного или необъявленного
(хешируемого) массива @var{A}.  Порядок элементов построчный.
Элементы объявленного массива, не имеющие значения, выводятся
как @code{#####}.

@end deffn

@c NEEDS CLARIFICATION, EXAMPLES
@deffn {Function} make_array (@var{type}, @var{dim_1}, ..., @var{dim_n})
Создаёт и возвращает Lisp-массив.  @var{type} может быть
@code{any}, @code{flonum}, @code{fixnum}, @code{hashed} или
@code{functional}.

Массив имеет @math{n} индексов, @math{i}-й индекс может принимать
значение от 0 до @math{@var{dim_i}-1}.

Преимущество @code{make_array} по сравнению с @code{array} состоит в
том, что возвращаемый Lisp-массив не имеет имени.  И как только ссылка
на него исчезает, занимаемое им место освобождается.
Например, если @code{y: make_array (...)}, тогда @code{y} ссылается
на объект (массив), занимающий место в памяти.
Но после присваивания @code{y: false}, @code{y} больше не ссылается
на данный массив и занимаемое им место будет освобождено
при сборке мусора.

@c NEEDS CLARIFICATION HERE
@code{y: make_array ('functional, 'f, 'hashed, 1)} -- здесь второй
аргумент @code{make_array} представляет собой функцию, используюмую
для вычисления элементов массива.  Остальные параметры снова
передаются @code{make_array} для создания необходимого пространства
для хранения функционального массива.

@end deffn

@c DOES THIS MODIFY A OR DOES IT CREATE A NEW ARRAY ??
@deffn {Function} rearray (@var{A}, @var{dim_1}, ..., @var{dim_n})
Изменяет размерность массива.  Новый массив будет заполнен элементами
старого построчно.  Если исходный массив слишком мал, тогда
остаток заполняется @code{false}, @code{0.0} или @code{0},
в зависимости от типа массива.  Тип массива не может быть изменён.

@end deffn

@deffn {Function} remarray (@var{A_1}, ..., @var{A_n})
@deffnx {Function} remarray (all)
Удаляет массив, все ассоциированные с ним функции и
освобождает занимаемую им память.

@code{remarray (all)} удаляет все массивы в глобальном списке @code{arrays}.

@c WHAT DOES THIS MEAN EXACTLY ??
Использование @code{remarray} может требоваться если
необходимо переопределить значения элементов
хешируемого массива.

@code{remarray} возвращает список удалённых массивов.

@end deffn

@c THIS IS REALLY CONFUSING
@defvr {Option variable} use_fast_arrays
-- если @code{true}, тогда используются только два типа массивов.

1) Art-q массивы (t в Common Lisp), которые имеют несколько
целочисленных индексов, и могут содержать любые Lisp или Maxima
объекты.  Для создания таких массивов используется функция
@code{make_array}.  Например @code{a:make_array(any,3,4);}.
Зчачение @code{a} -- массив из 12 элементо. Отсчет индексов
ведётся с 0.

2) Hash_table массивы, создающиеся по умолчанию если выполняется
присваивания @code{b[x+1]:y^2} если @code{b} ещё пока не является
массивом, списком или матрицей (во всех этих случаях должна возникнуть
ошибка т.к. @code{x+1} в общем случае не является допустимым индексом
для art-q массива, списка или матрицы).  Индексом такого массива
(также называется ключем) может быть произвольный объект.
Используется только один ключ одновременно, так в @code{b[x+1,u]:y}
игнорирует @code{u} а оответствие устанавливается по
@code{b[x+1] ==> y^2}.  Разумеется ключ может быть списком, например
@code{b[[x+1,u]]:y} вполне допустимо.  Это не совместимо со старыми
хешируемыми массивами, но экономит память.

Преимущество хранения массивов в значении переменной состоит в том,
что в этом случае массивы следуют обычным соглашениям о локальных
переменных.  Кроме того Hash_table массивы более эффективны и
используют меньше памяти, чем старые хешируемые массивы.  Для
одинакового поведения в интерпретируемом и компилируемом коде
необходимо установить значение @code{translate_fast_arrays} равным
@code{true}.

@end defvr
