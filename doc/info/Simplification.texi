@c end concepts Simplification
@menu
* Definitions for Simplification::  
@end menu

@node Definitions for Simplification,  , Simplification, Simplification
@section Definitions for Simplification
@menu
@end menu

@c After studying src/compar.lisp, it appears that askexp would
@c work as advertised, except that it doesn't appear to be possible
@c to open a break prompt with ^A or any other character.
@c What should we do about askexp ???
@defvar askexp
When @code{asksign} is called,
@code{askexp} is the expression @code{asksign} is testing.

At one time, it was possible for a user to inspect @code{askexp}
by entering a Maxima break with control-A.
@end defvar



@defun askinteger (expr, integer)
@defunx askinteger (expr)
@defunx askinteger (expr, even)
@defunx askinteger (expr, odd)

@code{askinteger (expr, integer)} attempts to determine from the @code{assume} database
whether @code{expr} is an integer.
@code{askinteger} will ask the user if it cannot tell otherwise,
@c UMM, askinteger AND asksign DO NOT APPEAR TO HAVE ANY EFFECT ON THE assume DATABASE !!!
and attempt to install the information in the database if possible.
@code{askinteger (expr)} is equivalent to @code{askinteger (expr, integer)}.

@code{askinteger (expr, even)} and @code{askinteger (expr, odd)}
likewise attempt to determine if @code{expr} is an even integer or odd integer, respectively.

@end defun


@defun asksign (expr)
First attempts to determine whether the specified
expression is positive, negative, or zero.  If it cannot, it asks the
user the necessary questions to complete its deduction.  The user's
answer is recorded in the data base for the duration of the current
computation. The return value of @code{asksign} is one of @code{pos}, @code{neg},
or @code{zero}.

@end defun


@defvar demoivre
@defvarx demoivre (expr)
Default value: @code{false}

When @code{demoivre} is @code{true},
complex exponentials are converted into equivalent expressions in terms of circular functions.
In general,
@code{exp (a + b*%i)} yields @code{%e^a * (cos(b) + %i*sin(b))}
if @code{b} is free of @code{%i}.
@code{a} and @code{b} are not expanded.

@code{demoivre (expr)} converts one expression
without setting the global variable @code{demoivre}.

@code{exponentialize} converts circular and hyperbolic functions to exponential form.
@code{demoivre} and @code{exponentialize} cannot
both be true at the same time.

@end defvar


@defvar domain
Default value: @code{real}

When @code{domain} is set to @code{complex}, @code{sqrt (x^2)} will remain
@code{sqrt (x^2)} instead of returning @code{abs(x)}.

@c PRESERVE EDITORIAL COMMENT -- MAY HAVE SOME SIGNIFICANCE NOT YET UNDERSTOOD !!!
@c The notion of a "domain" of simplification is still in its infancy,
@c and controls little more than this at the moment.

@end defvar


@defun expand (expr)
Expand expression @code{expr}.
Products of sums and exponentiated sums are
multiplied out, numerators of rational expressions which are sums are
split into their respective terms, and multiplication (commutative
and non-commutative) are distributed over addition at all levels of
@code{expr}.

For polynomials one should usually use @code{ratexpand} which uses a
more efficient algorithm.

@code{maxnegex} and @code{maxposex} control the maximum negative and
positive exponents, respectively, which will expand.

@code{expand (expr, p, n)} expands @code{expr}, 
using @code{p} for @code{maxposex} and @code{n} for @code{maxnegex}.
This is useful in order to expand part but not all of an expression.

@code{expon} - the exponent of the largest negative power which is
automatically expanded (independent of calls to @code{expand}).  For example
if @code{expon} is 4 then @code{(x+1)^(-5)} will not be automatically expanded.

@code{expop} - the highest positive exponent which is automatically
expanded.  Thus @code{(x+1)^3}, when typed, will be automatically expanded
only if @code{expop} is greater than or equal to 3.  If it is desired to have
@code{(x+1)^n} expanded where @code{n} is greater than @code{expop} then executing
@code{expand ((x+1)^n)} will work only if @code{maxposex} is not less than @code{n}.

The @code{expand} flag used with @code{ev} causes expansion.

The file @file{simplification/facexp.mac}
@c I should really use a macro which expands to something like
@c @uref{file://...,,simplification/facexp.mac}.  But texi2html
@c currently supports @uref only with one argument.
@c Worse, the `file:' scheme is OS and browser dependent.
contains several related functions (in particular @code{facsum}, @code{factorfacsum}
and @code{collectterms}, which are autoloaded) and variables (@code{nextlayerfactor}
and @code{facsum_combine}) that provide the user with the ability to structure
expressions by controlled expansion.  Brief function descriptions are
available in @file{simplification/facexp.usg}.  A demo is available by
doing @code{demo("facexp")$}.

@end defun


@defun expandwrt (expr, var_1, var_2, var_3, ...)
expands expression @code{expr} with respect to the 
variables @code{var_1}, @code{var_2}, @code{var_3}, ....
All products involving the variables appear explicitly.  The form returned
will be free of products of sums of expressions that are not free of
the variables.   @code{var_1}, @code{var_2}, @code{var_3}, ...
may be variables, operators, or expressions.

By default, denominators are not expanded, but this can be controlled by
means of the switch @code{expandwrt_denom}.

This function is autoloaded from
@file{simplification/stopex.mac}.

@end defun


@defvar expandwrt_denom
Default value: @code{false}

@code{expandwrt_denom} controls the treatment of rational
expressions by @code{expandwrt}.  If @code{true}, then both the numerator and
denominator of the expression will be expanded according to the
arguments of @code{expandwrt}, but if @code{expandwrt_denom} is @code{false}, then only the
numerator will be expanded in that way.

@end defvar


@defun expandwrt_factored (expr, var_1, var_2, var_3, ...)
is similar to
@code{expandwrt}, but treats expressions that are products somewhat
differently.  @code{expandwrt_factored} will perform the required expansion
only on those factors of @code{expr} that contain the variables in its argument list
argument list.  This function is autoloaded from
@file{simplification/stopex.mac}.

@end defun


@defvar expon
Default value: 0

@code{expon} is the exponent of the largest negative power which
is automatically expanded (independent of calls to @code{expand}).  For
example, if @code{expon} is 4 then @code{(x+1)^(-5)} will not be automatically
expanded.

@end defvar


@defvar exponentialize
@defvarx exponentialize (expr)
Default value: @code{false}

When @code{exponentialize} is @code{true},
all circular and hyperbolic functions are converted to exponential form.

@code{exponentialize (expr)} converts one expression
without setting the global variable @code{exponentialize}.

@code{demoivre} converts complex exponentials into circular functions.
@code{exponentialize} and @code{demoivre} cannot
both be true at the same time.

@end defvar


@defvar expop
Default value: 0

@code{expop} is the highest positive exponent which is
automatically expanded.  Thus @code{(x+1)^3}, when typed, will be
automatically expanded only if @code{expop} is greater than or equal to 3.
If it is desired to have @code{(x+1)^n} expanded where @code{n} is greater than
@code{expop} then executing @code{expand ((x+1)^n)} will work only if @code{maxposex} is
not less than n.

@end defvar


@defvar factlim
Default value: -1

@code{factlim} gives the highest factorial which is
automatically expanded.  If it is -1 then all integers are expanded.

@end defvar


@defun intosum (expr)
will take all things that a summation is multiplied
by, and put them inside the summation. If the index is used in the
outside expression, then the function tries to find a reasonable
index, the same as it does for @code{sumcontract}.  This is essentially the
reverse idea of the @code{outative} property of summations, but note that it
does not remove this property, it only bypasses it.  In some cases, a
@code{scanmap (multthru, expr)} may be necessary before the @code{intosum}.

@end defun


@defvr declaration lassociative
@code{declare (g, lassociative)} tells the
Maxima simplifier that @code{g} is left-associative.  E.g., @code{g (g (a, b), g (c, d))} will
simplify to @code{g (g (g (a, b), c), d)}.

@end defvr


@defvr declaration linear
One of Maxima's operator properties.  For univariate @code{f} so
declared, "expansion" @code{f(x+y)} yields @code{f(x)+f(y)},
@code{f(a*x)} yields @code{a*f(x)} takes
place where @code{a} is a "constant".  For functions of two or more arguments,
"linearity" is defined to be as in the case of @code{sum} or @code{integrate},
i.e., @code{f (a*x + b, x)} yields @code{a*f(x,x) + b*f(1,x)}
for @code{a} and @code{b} free of @code{x}.

@code{linear} is equivalent to @code{additive} plus @code{outative}.
See also @code{opproperties}.

@end defvr


@defvr declaration mainvar
You may declare variables to be @code{mainvar}.  The ordering
scale for atoms is essentially: numbers < constants (e.g., @code{%e}, @code{%pi}) <
scalars < other variables < mainvars.  E.g., compare @code{expand ((X+Y)^4)}
with @code{(declare (x, mainvar), expand ((x+y)^4))}.  (Note: Care should be
taken if you elect to use the above feature.  E.g., if you subtract an
expression in which @code{x} is a @code{mainvar} from one in which @code{x} isn't a
@code{mainvar}, resimplification e.g. with @code{ev (expr, simp)} may be
necessary if cancellation is to occur.  Also, if you save an
expression in which @code{x} is a @code{mainvar}, you probably should also save @code{x}.)

@end defvr


@defvar maxapplydepth
Default value: 10000

@code{maxapplydepth} is the maximum depth to which @code{apply1}
and @code{apply2} will delve.

@end defvar


@defvar maxapplyheight
Default value: 10000

@code{maxapplyheight} is the maximum height to which @code{applyb1}
will reach before giving up.

@end defvar


@defvar maxnegex
Default value: 1000

@code{maxnegex} is the largest negative exponent which will
be expanded by the @code{expand} command (see also @code{maxposex}).

@end defvar


@defvar maxposex
Default value: 1000

@code{maxposex} is the largest exponent which will be
expanded with the @code{expand} command (see also @code{maxnegex}).

@end defvar


@defvr declaration multiplicative
@code{declare (f, multiplicative)} tells the Maxima simplifier that @code{f} is multiplicative.

@enumerate
@item
If @code{f} is univariate, whenever the simplifier encounters @code{f} applied
to a product, @code{f} will be distributed over that product.  E.g., @code{f(x*y)}
will simplify to @code{f(x)*f(y)}.
@item
If @code{f} is a function of 2 or more arguments, multiplicativity is
defined as multiplicativity in the first argument to @code{f}, e.g.,
@code{f (g(x) * h(x), x)} will simplify to @code{f (g(x) ,x) * f (h(x), x)}.
@end enumerate

This simplification does not occur when @code{f} is applied to expressions of
the form @code{product (x[i], i, m, n)}.

@end defvr


@defvar negdistrib
Default value: @code{true}

When @code{negdistrib} is @code{true}, -1 will be distributed
over an expression.  E.g., @code{-(x+y)} becomes @code{-y-x}.  Setting it to @code{false}
will allow @code{-(x+y)} to be displayed like that.  This is sometimes useful
but be very careful: like the @code{simp} flag, this is one flag you do not
want to set to @code{false} as a matter of course or necessarily for other
than local use in your Maxima.

@end defvar


@defvar negsumdispflag
Default value: @code{true}

When @code{negsumdispflag} is @code{true}, @code{x-y} displays as @code{x-y}
instead of as @code{-y+x}.  Setting it to @code{false} causes the special check in
display for the difference of two expressions to not be done.  One
application is that thus @code{a + %i*b} and @code{a - %i*b} may both be displayed the
same way.

@end defvar


@defvr {special symbol} noeval
@code{noeval} suppresses the evaluation phase of @code{ev}.  This is useful in
conjunction with other switches and in causing expressions      
to be resimplified without being reevaluated.

@end defvr


@defvr declaration noun
@code{noun} is one of the options of the @code{declare} command.  It makes a
function so declared a "noun", meaning that it won't be evaluated
automatically.

@end defvr


@defvar noundisp
Default value: @code{false}

When @code{noundisp} is @code{true}, nouns display with
a single quote.  This switch is always @code{true} when displaying function
definitions.

@end defvar


@defvr {special symbol} nouns
@code{nouns} is an @code{evflag}. When used as an option to the @code{ev} command,
@code{nouns} converts all
"noun" forms occurring in the expression being @code{ev}'d to "verbs", i.e.,
evaluates them.  See also @code{noun}, @code{nounify}, @code{verb}, and @code{verbify}.

@end defvr


@defvr {special symbol} numer
@code{numer} causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point. It causes
variables in @code{expr} which have been given numervals to be replaced by
their values.  It also sets the @code{float} switch on.

@end defvr


@c NEEDS CLARIFICATION !!!
@defun numerval (var_1, expr_1, var_2, expr_2, ...)
declares the variables @code{var_1}, @code{var_2}, ..., to have
numeric values equal to @code{expr_1}, @code{expr_2}, ....
The numeric value is is evaluated and substituted for the variable
in any expressions in which the variable occurs if the @code{numer} flag is
@code{true}. See also @code{ev}.

The expressions @code{expr_1}, @code{expr_2}, ..., can be any expressions,
not necessarily numeric.
@end defun


@defvar opproperties

@code{opproperties} is the list of the special operator properties handled by
the Maxima simplifier:
@code{linear}, @code{additive}, @code{multiplicative}, @code{outative}, @code{evenfun},
@code{oddfun}, @code{commutative}, @code{symmetric}, @code{antisymmetric}, @code{nary}, 
@code{lassociative}, @code{rassociative}.

@end defvar


@defvar opsubst
Default value: @code{true}

When @code{opsubst} is @code{false}, @code{subst} will not attempt to
substitute into the operator of an expression.  E.g., 
@code{(opsubst: false, subst (x^2, r, r+r[0]))} will work.

@end defvar


@defvr declaration outative
@code{declare (f, outative)} tells the Maxima simplifier that constant factors
in the argument of @code{f} can be pulled out.

@enumerate
@item
If @code{f} is univariate, whenever the simplifier encounters @code{f} applied
to a product, that product will be partitioned into factors that are
constant and factors that are not and the constant factors will be
pulled out.  E.g., @code{f(a*x)} will simplify to @code{a*f(x)} where @code{a} is a
constant.  Non-atomic constant factors will not be pulled out.
@item
If @code{f} is a function of 2 or more arguments, outativity is defined
as in the case of @code{sum} or @code{integrate}, i.e., @code{f (a*g(x), x)} will simplify
to @code{a * f(g(x), x)} for @code{a} free of @code{x}.
@end enumerate

Initially, @code{sum}, @code{integrate}, and @code{limit} are declared to be @code{outative}.

@end defvr


@defvr declaration posfun
@code{declare (f, posfun)} declares @code{f} to be a positive function.
@code{is (f(x) > 0)} yields @code{true}.

@end defvr


@defvar prodhack
Default value: @code{false}

When @code{prodhack} is @code{true}, the identity 
@code{product (f(i), i, a, b) = 1/product (f(i), i, b+1, a-1)} is applied 
if @code{a} is greater than @code{b}.
For example, @code{product (f(i), i, 3, 1)} will yield @code{1/f(2)}.

@end defvar


@defun radcan (expr)
Simplifies @code{expr}, which can contain logs, exponentials, and
radicals, by converting it into a form which is canonical over a large
class of expressions and a given ordering of variables; that is, all
functionally equivalent forms are mapped into a unique form.  For a
somewhat larger class of expressions, @code{radcan} produces a regular form.
Two equivalent expressions in this class will not necessarily have the
same appearance, but their difference will be simplified by @code{radcan} to
zero.

For some expressions @code{radcan} is quite time consuming.  This
is the cost of exploring certain relationships among the components of
the expression for simplifications based on factoring and
partial-fraction expansions of exponents.  

@c %e_to_numlog NEEDS ITS OWN @defvar !!!
@c DOESN'T APPEAR TO AFFECT radcan !!!
When @code{%e_to_numlog} is @code{true}, 
@code{%e^(r*log(expr))} will be simplified into @code{expr^r} if @code{r} is a rational number.

When @code{radexpand} is @code{false}, certain transformations are inhibited.
@code{radcan (sqrt (1-x))} will remain @code{sqrt (1-x)} and will not
become @code{%i sqrt (x-1)}. 
@code{radcan (sqrt (x^2 - 2*x + 11))} will remain @code{sqrt (x^2 - 2*x + 1)}
and will not be transformed to @code{x - 1}.

@code{example (radcan)} will display some examples.

@end defun


@defvar radexpand
Default value: @code{true}

@code{radexpand}, if set to @code{all}, causes nth roots of
factors of a product which are powers of n to be pulled outside of the
radical.  E.g. if @code{radexpand} is @code{all}, @code{sqrt (16*x^2)} will become @code{4*x}.

More particularly, consider @code{sqrt (x^2)}.
@itemize @bullet
@item
If @code{radexpand} is @code{all} or @code{assume (x > 0)} has been executed, 
@code{sqrt(x^2)} will become @code{x}.
@item
If @code{radexpand} is @code{true} and @code{domain} is @code{real} (its default), 
@code{sqrt(x^2)} will become @code{abs(x)}.
@item
If @code{radexpand} is @code{false}, or @code{radexpand} is @code{true} and @code{domain} is @code{complex}, 
@code{sqrt(x^2)} will be returned.
@end itemize

@c CORRECT STATEMENT HERE ???
Note that @code{domain} only matters when @code{radexpand} is @code{true}.

@end defvar


@defvar radsubstflag
Default value: @code{false}

@code{radsubstflag}, if @code{true}, permits @code{ratsubst} to make
substitutions such as @code{u} for @code{sqrt (x)} in @code{x}.

@end defvar


@defvr declaration rassociative
@code{declare (g, rassociative)} tells the Maxima
simplifier that @code{g} is right-associative.  E.g.,
@code{g(g(a, b), g(c, d))} simplifies to @code{g(a, g(b, g(c, d)))}.

@end defvr


@defun scsimp (expr, rule_1, rule_2, rule_3, ...)
Sequential Comparative Simplification (method due to Stoute).
@code{scsimp} takes an expression (its first argument) and
a set of identities, or rules (its other arguments) and tries
simplifying.  If a smaller expression is obtained, the process
repeats.  Otherwise after all simplifications are tried, it returns
the original answer.  @code{example (scsimp)} displays some examples.

@end defun


@defvar simpsum
Default value: @code{false}

When @code{simpsum} is @code{true}, the result of a @code{sum} is
simplified.  This simplification may sometimes be able to produce a
closed form.  If @code{simpsum} is @code{false} or if the quoted form @code{'sum} is used, the value is a
sum noun form which is a representation of the sigma notation used in
mathematics.

@end defvar


@defun sumcontract (expr)
will combine all sums of an addition that have
upper and lower bounds that differ by constants. The result will be an
expression containing one summation for each set of such summations
added to all appropriate extra terms that had to be extracted to form
this sum.  @code{sumcontract} will combine all compatible sums and use one of
the indices from one of the sums if it can, and then try to form a
reasonable index if it cannot use any supplied.  It may be necessary
to do an @code{intosum (expr)} before the @code{sumcontract}.

@end defun


@defvar sumexpand
Default value: @code{false}

When @code{sumexpand} is @code{true}, products of sums and
exponentiated sums are converted into nested sums. For example:

@example
(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                >      >     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                >      >     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
@end example

@noindent
If @code{false}, they are left alone.  See also @code{cauchysum}.

@end defvar


@defvar sumhack
Default value: @code{false}

When @code{sumhack} is @code{true}, 
the identity @code{sum (f(i), i, a, b) = - sum (f(i), i, b+1, a-1)} is applied
if @code{a} is greater than @code{b}.
For example, @code{(sumhack: true, sum (f(i), i, 3, 1))} yields @code{-f(2)}.

@end defvar


@defvar sumsplitfact
Default value: @code{true}

When @code{sumsplitfact} is @code{false},
@code{minfactorial} is applied after a @code{factcomb}.

@end defvar


@defvr declaration symmetric
@code{declare (h, symmetric)} tells the Maxima
simplifier that @code{h} is a symmetric function.  E.g., @code{h (x, z, y)} will
simplify to @code{h (x, y, z)}.

@code{commutative} is synonymous with @code{symmetric}.

@end defvr


@defun unknown (expr)
returns @code{true} iff @code{expr} contains an operator or function
not known to the built-in simplifier.

@end defun
