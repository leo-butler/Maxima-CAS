@menu
* Introduction to Sets::       
* Definitions for Sets::       
@end menu

@node Introduction to Sets, Definitions for Sets, Sets, Sets
@section Introduction to Sets

Maxima provides set functions, such as intersection and 
union, for finite sets that are defined by explicit enumeration.
Maxima treats 
lists and sets as distinct objects. This feature makes it possible to
work with sets that have members that are either lists or sets.

In addition to functions for finite sets, Maxima provides some
functions related to combinatorics; these include the Stirling
numbers of the first and second kind, the Bell numbers, multinomial
coefficients, partitions of nonnegative integers, and a few others. 
Maxima also defines a Kronecker delta function.

@subsection Usage

To construct a set with members @code{a_1, ..., a_n}, write
@code{set(a_1, ..., a_n)} or @code{@{a_1, ..., a_n@}};
to construct the empty set, write @code{set()} or @code{@{@}}.
In input, @code{set (...)} and @code{@{ ... @}} are equivalent.
Sets are always displayed with curly braces.

If a member is listed more than
once, the simplification process eliminates the redundant member.

@c ===beg===
@c set();
@c set(a, b, a);
@c set(a, set(b));
@c set(a, [b]);
@c {};
@c {a, b, a};
@c {a, {b}};
@c {a, [b]};
@c ===end===
@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example

Two would-be elements @var{x} and @var{y} are redundant
(i.e., considered the same for the purposes of set construction)
if and only if @code{is (@var{x} = @var{y})} yields @code{true}.
@c THAT IS BECAUSE THE SET SIMPLIFICATION CODE CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
Note that @code{is (equal (@var{x}, @var{y}))} can yield @code{true}
while @code{is (@var{x} = @var{y})} yields @code{false};
in that case the elements @var{x} and @var{y} are considered distinct.

@c ===beg===
@c x: a/c + b/c;
@c y: a/c + b/c;
@c z: (a + b)/c;
@c is (x = y);
@c is (y = z);
@c is (equal (y, z));
@c y - z;
@c ratsimp (%);
@c set (x, y, z);
@c ===end===
@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) set (x, y, z);
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example

To construct a set from the elements of a list, use  @code{setify}.

@c ===beg===
@c setify([b, a]);
@c ===end===
@example
(%i1) setify([b, a]);
(%o1)                        @{a, b@}
@end example

Set members @code{x} and @code{y} are equal provided @code{is(x = y)} 
evaluates to true. Thus @code{rat(x)} and @code{x} are equal as set members;
consequently, 

@c ===beg===
@c set(x, rat(x));
@c ===end===
@example
(%i1) set(x, rat(x));
(%o1)                          @{x@}
@end example

Further, since @code{is((x-1)*(x+1) = x^2 - 1)} evaluates to false, 
@code{(x-1)*(x+1)} and @code{x^2-1} are distinct set members; thus 

@c ===beg===
@c set((x - 1)*(x + 1), x^2 - 1);
@c ===end===
@example
(%i1) set((x - 1)*(x + 1), x^2 - 1);
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

To reduce this set to a singleton set, apply @code{rat} to each set member:

@c ===beg===
@c set((x - 1)*(x + 1), x^2 - 1);
@c map(rat, %);
@c ===end===
@example
(%i1) set((x - 1)*(x + 1), x^2 - 1);
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map(rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

To remove redundancies from other sets, you may need to use other
simplification functions.  Here is an example that uses @code{trigsimp}:

@c ===beg===
@c set(1, cos(x)^2 + sin(x)^2);
@c map(trigsimp, %);
@c ===end===
@example
(%i1) set(1, cos(x)^2 + sin(x)^2);
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map(trigsimp, %);
(%o2)                          @{1@}
@end example

A set is simplified when its members are non-redundant and
sorted. The current version of the set functions uses the Maxima function
@code{orderlessp} to order sets; however, @i{future versions of 
the set functions might use a different ordering function}.

Some operations on sets, such as substitution, automatically force a 
re-simplification; for example,

@c ===beg===
@c s: set (a, b, c)$
@c subst (c=a, s);
@c subst ([a=x, b=x, c=x], s);
@c map (lambda ([x], x^2), set (-1, 0, 1));
@c ===end===
@example
(%i1) s: set (a, b, c)$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

@c NAME HERE ANY FUNCTIONS WHICH AUTOMATICALLY COERCE SETS TO LISTS OR VV
Maxima treats lists and sets as distinct objects;
functions such as @code{union} and @code{intersection} will signal
an error if any argument is a list.  If you need to apply a set
function to a list, use the @code{setify} function to convert it
to a set.  Thus

@c ===beg===
@c union ([1, 2], set (a, b));
@c union (setify ([1, 2]), set (a, b));
@c ===end===
@example
(%i1) union ([1, 2], set (a, b));
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), set (a, b));
(%o2)                     @{1, 2, a, b@}
@end example

To extract all set elements of a set @code{s} that satisfy a predicate
@code{f}, use @code{subset(s,f)}. (A @i{predicate} is a 
boolean-valued function.) For example, to find the equations 
in a given set that do not depend on a variable @code{z}, use

@c ===beg===
@c subset (set (x + y + z, x - y + 4, x + y - 5), lambda ([e], freeof (z, e)));
@c ===end===
@example
(%i1) subset (set (x + y + z, x - y + 4, x + y - 5), lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

The section @ref{Definitions for Sets} has a complete list of
the set functions in Maxima.

@subsection Set Member Iteration

There two ways to to iterate over set members.  One way is the use
@code{map}; for example:

@c ===beg===
@c map (f, set (a, b, c));
@c ===end===
@example
(%i1) map (f, set (a, b, c));
(%o1)                  @{f(a), f(b), f(c)@}
@end example

The other way is to use @code{for @var{x} in @var{s} do}

@c ===beg===
@c s: set (a, b, c);
@c for si in s do print (concat (si, 1));
@c ===end===
@example
(%i1) s: set (a, b, c);
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

The Maxima functions @code{first} and @code{rest} work
correctly on sets.  Applied to a set, @code{first} returns the first
displayed element of a set; which element that is may be
implementation-dependent. If @code{s} is a set, then 
@code{rest(s)} is equivalent to @code{disjoin (first(s), s)}.  
Currently, there are other Maxima functions that work correctly
on sets.
In future versions of the set functions,
@code{first} and @code{rest} may function differently or not at all.

@subsection Bugs

The set functions use the Maxima function @code{orderlessp} to 
order set members and the (Lisp-level) function @code{like} to test for set
member equality.  Both of these functions have known bugs
that may manifest if you attempt to use
sets with members that are lists or matrices that contain expressions
in CRE form. An example is

@c ===beg===
@c set ([x], [rat (x)]);
@c ===end===
@example
(%i1) set ([x], [rat (x)]);
Maxima encountered a Lisp error:

 CAR: #:X13129 is not a LIST

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

This command causes Maxima to halt with an error (the error message
depends on which version of Lisp your Maxima uses). Another
example is

@c ===beg===
@c setify ([[rat(a)], [rat(b)]]);
@c ===end===
@example
(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

 CAR: #:A13129 is not a LIST

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

These bugs are caused by bugs in @code{orderlessp} and @code{like}; they
are not caused by bugs in the set functions. To illustrate, try the commands

@c ===beg===
@c orderlessp ([rat(a)], [rat(b)]);
@c is ([rat(a)] = [rat(a)]);
@c ===end===
@example
(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

 CAR: #:B13130 is not a LIST

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
@end example

Until these bugs are fixed, do not construct sets with members that
are lists or matrices containing expressions in CRE form; a set with a 
member in CRE form, however, shouldn't be a problem:

@c ===beg===
@c set (x, rat (x));
@c ===end===
@example
(%i1) set (x, rat (x));
(%o1)                          @{x@}
@end example

Maxima's @code{orderlessp} has another bug that can cause problems
with set functions, namely that the ordering predicate @code{orderlessp} is
not transitive. The simplest known example that shows this is

@c ===beg===
@c q: x^2$
@c r: (x + 1)^2$
@c s: x*(x + 2)$
@c orderlessp (q, r);
@c orderlessp (r, s);
@c orderlessp (q, s);
@c ===end===
@example
(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
@end example

This bug can cause trouble will all set functions as well as with
Maxima functions in general. It's likely, but not certain, that 
if all set members are either in CRE form or have been simplified
using @code{ratsimp}, this bug will not manifest.

@c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON THE SET FUNCTIONS ??
Maxima's @code{orderless} and @code{ordergreat} mechanisms are 
incompatible with the set functions. If you need to use either @code{orderless}
or @code{ordergreat}, issue these commands before constructing any sets
and do not use the @code{unorder} command. 

Maxima's sign function has a bug that may cause the Kronecker
delta function to misbehave; for example:

@c ===beg===
@c kron_delta (1/sqrt(2), sqrt(2)/2);
@c ===end===
@example
(%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
(%o1)                           0
@end example

The correct value is 1; the bug is related to the @code{sign} bug

@c ===beg===
@c sign (1/sqrt(2) - sqrt(2)/2);
@c ===end===
@example
(%i1) sign (1/sqrt(2) - sqrt(2)/2);
(%o1)                          pos
@end example

If you find something that you think might be a set function bug, please 
report it to the Maxima bug database. See @code{bug_report}.

@subsection Authors

Stavros Macrakis of Cambridge, Massachusetts and Barton Willis of the
University of Nebraska at Kearney (UNK) wrote the Maxima set functions and their
documentation. 

@node Definitions for Sets,  , Introduction to Sets, Sets
@section Definitions for Sets

@anchor{adjoin}
@deffn {Function} adjoin (@var{x}, @var{a}) 
Adjoin @var{x} to the set @var{a} and return a set. Thus @code{adjoin(@var{x}, @var{a})} 
and @code{union(set(x),a)} are equivalent; however, using @code{adjoin}
may be somewhat faster than using @code{union}. If @var{a} isn't a 
set, signal an error.

@c ===beg===
@c adjoin (c, set (a, b));
@c adjoin (a, set (a, b));
@c ===end===
@example
(%i1) adjoin (c, set (a, b));
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, set (a, b));
(%o2)                        @{a, b@}
@end example

See also @code{disjoin}.
@end deffn

@anchor{belln}
@deffn {Function} belln (@var{n})
For nonnegative integers @var{n}, return the n-th Bell number. If
@code{s} is a set with @code{n} members,  @code{belln(n)} is the number 
of partitions of @code{s}.  For example:

@c ===beg===
@c makelist (belln (i), i, 0, 6);
@c is (cardinality (set_partitions (set ())) = belln (0));
@c is (cardinality (set_partitions (set (1, 2, 3, 4, 5, 6))) = belln (6));
@c ===end===
@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (set ())) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (set (1, 2, 3, 4, 5, 6))) = belln (6));
(%o3)                         true
@end example

When @var{n} isn't a nonnegative integer, @code{belln(n)} doesn't
simplify.

@c ===beg===
@c [belln (x), belln (sqrt(3)), belln (-9)];
@c ===end===
@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example

@c WHAT DOES "THREAD" MEAN IN THIS CONTEXT ??
The function @code{belln} threads over equalities, lists, matrices, and 
sets.
@end deffn

@anchor{cardinality}
@deffn {Function} cardinality (@var{a})
Return the number of distinct elements of the set @var{a}. 

@c ===beg===
@c cardinality (set ());
@c cardinality (set (a, a, b, c));
@c cardinality (set (a, a, b, c)), simp: false;
@c ===end===
@example
(%i1) cardinality (set ());
(%o1)                           0
(%i2) cardinality (set (a, a, b, c));
(%o2)                           3
(%i3) cardinality (set (a, a, b, c)), simp: false;
(%o3)                           3
@end example

In line (%o3), we see that cardinality works correctly even when simplification
has been turned off. 
@end deffn

@anchor{cartesian_product}
@deffn {Function} cartesian_product (@var{b_1}, ... , @var{b_n})
Return a set of lists of the form @code{[@var{x_1}, ..., @var{x_n}]}, where
@code{@var{x_1} in @var{b_1}}, ..., @code{@var{x_n} in @var{b_n}}. 
Signal an error when any @var{b_k} isn't a set.

@c ===beg===
@c cartesian_product (set (0, 1));
@c cartesian_product (set (0, 1), set (0, 1));
@c cartesian_product (set (x), set (y), set (z));
@c cartesian_product (set (x), set (-1, 0, 1));
@c ===end===
@example
(%i1) cartesian_product (set (0, 1));
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (set (0, 1), set (0, 1));
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (set (x), set (y), set (z));
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (set (x), set (-1, 0, 1));
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn


@anchor{disjoin}
@deffn {Function} disjoin (@var{x}, @var{a})
Remove @var{x} from the set @var{a} and return a set.
If @var{x} isn't a member of @var{a}, return @var{a}. Each of the 
following do the same thing: @code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x}, @var{a})}, and
@code{setdifference(@var{a},set(@var{x}))}; however, @code{disjoin} is generally
the fastest way to remove a member from a set.
Signal an error if @var{a} isn't a set.
@end deffn

@anchor{disjointp}
@deffn {Function} disjointp (@var{a}, @var{b}) 
Return @code{true} if the sets @var{a} and @var{b} are disjoint. Signal an 
error if either @var{a} or @var{b} isn't a set.
@end deffn

@anchor{divisors}
@deffn {Function} divisors (@var{n})
When @var{n} is a nonzero integer, return the set of its divisors. 
The set of divisors includes the members 1 and @var{n}.
The divisors of a negative integer are the divisors of its absolute value.

We can verify that 28 is a perfect number.

@c ===beg===
@c s: divisors(28);
@c lreduce ("+", args(s)) - 28;
@c ===end===
@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

The function divisors works by simplification; you shouldn't need to
manually re-evaluate after a substitution. For example:

@c ===beg===
@c divisors (a);
@c subst (8, a, %);
@c ===end===
@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

@c WHAT DOES "THREADING" MEAN IN THIS CONTEXT ??
The function divisors threads over equalities, lists, matrices, and 
sets. Here is an example of threading over a list and an equality.

@c ===beg===
@c divisors ([a, b, c=d]);
@c ===end===
@example
(%i1) divisors ([a, b, c=d]);
(%o1) [divisors(a), divisors(b), divisors(c) = divisors(d)]
@end example
@end deffn

@anchor{elementp}
@deffn {Function} elementp (@var{x}, @var{a})
Return @code{true} if and only if  @var{x} is a member of the 
set @var{a}.  Signal an error if @var{a} isn't a set.  
@end deffn

@anchor{emptyp}
@deffn {Function} emptyp (@var{a})
Return @code{true} if and only if @var{a} is the empty set or
the empty list.

@c ===beg===
@c map (emptyp, [set (), []]);
@c map (emptyp, [a + b, set (set ()), %pi]);
@c ===end===
@example
(%i1) map (emptyp, [set (), []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, set (set ()), %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn
       
@anchor{equiv_classes}
@deffn {Function} equiv_classes (@var{s}, @var{f})
Return a set of the equivalence classes of @var{s} with respect
to the equivalence relation @var{f}. The function @var{f} should
be a boolean-valued function defined on the cartesian product
of @var{s} with @var{s}. Further, the function @var{f} should 
be an equivalence relation; @code{equiv_classes}, however, doesn't 
check that it is. 

@c ===beg===
@c equiv_classes (set (a, b, c), lambda ([x, y], is (x=y)));
@c ===end===
@example
(%i1) equiv_classes (set (a, b, c), lambda ([x, y], is (x=y)));
(%o1)                    @{@{a@}, @{b@}, @{c@}@}
@end example

Actually, @code{equiv_classes (@var{s}, @var{f})} automatically applies the Maxima 
function @code{is} after applying the function @var{f}; accordingly,
we can restate the previous example more briefly.

@c ===beg===
@c equiv_classes (set (a, b, c), "=");
@c ===end===
@example
(%i1) equiv_classes (set (a, b, c), "=");
(%o1)                    @{@{a@}, @{b@}, @{c@}@}
@end example

Here is another example.

@c ===beg===
@c equiv_classes (set (1, 2, 3, 4, 5, 6, 7), lambda ([x, y], remainder (x - y, 3) = 0));
@c ===end===
@example
(%i1) equiv_classes (set (1, 2, 3, 4, 5, 6, 7), lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn

@anchor{every}
@deffn {Function} every (@var{f}, @var{a})
@deffnx {Function} every (@var{f}, @var{L_1}, ..., @var{L_n})

The first argument @var{f} should be a predicate (a function that evaluates to
true, false, or unknown). 

Given one set as the second argument, 
@code{every (@var{f}, @var{a})} returns @code{true}
if @code{@var{f}(@var{a_i})} returns @code{true} for all @var{a_i} in @var{a}.
Since sets are unordered, @code{every} is free to evaluate @code{@var{f}(@var{a_i})} in any
order. @code{every} may or may not evaluate @var{f} for all @var{a_i} in @var{a}. Because the
order of evaluation isn't specified, the predicate @var{f} should
not have side-effects or signal errors for any input. 

Given one or more lists as arguments,
@code{every (@var{f}, @var{L_1}, ..., @var{L_n})} returns @code{true}
if @code{@var{f}(@var{x_1}, ..., @var{x_n})} returns @code{true} 
for all @var{x_1}, ..., @var{x_n} in @var{L_1}, ..., @var{L_n}, respectively.
@code{every} may or may not evaluate 
@var{f} for every combination @var{x_1}, ..., @var{x_n}.
@c FOLLOWING STATEMENT IS AMBIGUOUS: IS f(L_1[1], L_2[2]) EVALUATED BEFORE OR AFTER f(L_1[2], L_2[2]) ??
Since lists are ordered, @code{every} evaluates in the order of increasing index.

To use @code{every} on multiple set arguments, they should first be converted
to an ordered sequence so that their relative alignment becomes well-defined.

If the global flag @code{maperror} is @code{true} (the default), all lists 
@var{L_1}, ..., @var{L_n} must have equal lengths -- otherwise, @code{every} signals an error.
When @code{maperror} is false, the list arguments are
effectively truncated each to the length of the shortest list. 

The Maxima function @code{is} automatically applied after evaluating the
predicate @var{f}.

@c ===beg===
@c every ("=", [a, b], [a, b]);
@c every ("#", [a, b], [a, b]);
@c ===end===
@example
(%i1) every ("=", [a, b], [a, b]);
(%o1)                         true
(%i2) every ("#", [a, b], [a, b]);
(%o2)                         false
@end example
@end deffn
 
@anchor{extremal_subset}
@deffn {Function} extremal_subset (@var{s}, @var{f}, max)
@deffnx {Function} extremal_subset (@var{s}, @var{f}, min)
When the third argument is max, return the subset of the set or 
list @var{s} for which the real-valued function @var{f} takes 
on its greatest value; when the third argument is min, return the 
subset for which @var{f} takes on its least value.

@c ===beg===
@c extremal_subset (set (-2, -1, 0, 1, 2), abs, max);
@c extremal_subset (set (sqrt(2), 1.57, %pi/2), sin, min);
@c ===end===
@example
(%i1) extremal_subset (set (-2, -1, 0, 1, 2), abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (set (sqrt(2), 1.57, %pi/2), sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn

@anchor{flatten}
@deffn {Function} flatten (@var{e})
Flatten essentially evaluates an expression as if its main operator had 
been declared n-ary; there is, however, one difference -- flatten doesn't 
recurse into other function arguments.  For example:

@c ===beg===
@c expr: flatten (f (g (f (f (x)))));
@c declare (f, nary);
@c ev (expr);
@c ===end===
@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

Applied to a set, flatten gathers all members of set elements that
are sets; for example:

@c ===beg===
@c flatten (set (a, set (b), set (set (c))));
@c flatten (set (a, set ([a], set (a))));
@c ===end===
@example
(%i1) flatten (set (a, set (b), set (set (c))));
(%o1)                       @{a, b, c@}
(%i2) flatten (set (a, set ([a], set (a))));
(%o2)                       @{a, [a]@}
@end example

Flatten works correctly when the main operator is a subscripted function

@c ===beg===
@c flatten (f[5] (f[5] (x)));
@c ===end===
@example
(%i1) flatten (f[5] (f[5] (x)));
(%o1)                         f (x)
                               5
@end example

To flatten an expression, the main operator must be defined for zero or 
more arguments;  if this isn't the case, Maxima will halt with an error. 
Expressions with special representations, for example CRE expressions, 
can't be flattened; in this case, flatten returns its argument
unchanged.
@end deffn

@anchor{full_listify}
@deffn {Function} full_listify (@var{a})
If @var{a} is a set, convert @var{a} to a list
and apply @code{full_listify} to each list element.

To convert just the top-level operator of a set to a list,
see @ref{listify}.
@end deffn

@anchor{fullsetify}
@deffn {Function} fullsetify (@var{a})
If @var{a} is a list, convert @var{a} to a set and apply 
@code{fullsetify} to each set member. 

@c ===beg===
@c fullsetify ([a, [a]]);
@c fullsetify ([a, f([b])]);
@c ===end===
@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example

In line (%o2), the argument of @code{f} isn't converted to a set
because the main operator of @code{f([b])} isn't a list.

To convert just the top-level operator of a list to a set, see
@ref{setify}.
@end deffn

@anchor{identity}
@deffn {Function} identity (@var{x})

The identity function evaluates to its argument for all inputs.  To 
determine if every member of a set is @code{true}, you can use

@c ===beg===
@c every (identity, [true, true]);
@c ===end===
@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn

@anchor{integer_partitions}
@deffn {Function} integer_partitions (@var{n})
@deffnx {Function} integer_partitions (@var{n}, @var{len})
If the optional second argument @var{len} isn't specified, return the set of
all partitions of the integer @var{n}.  When @var{len} is specified,
return all partitions that have length @var{len} or less; in this
case, zeros are appended to each partition with fewer than @var{len}
terms to make each partition have exactly @var{len} terms.  In either
case, each partition is a list sorted from greatest to least.

We say a list @math{[a_1, ..., a_m]} is a partition of a nonnegative integer
@math{n} provided (1) each @math{a_i} is a nonzero integer and (2) 
@math{a_1 + ... + a_m  = n.}  Thus 0 has no partitions.  

@c ===beg===
@c integer_partitions (3);
@c s: integer_partitions (25)$
@c cardinality (s);
@c map (lambda ([x], apply ("+", x)), s);
@c integer_partitions (5, 3);
@c integer_partitions (5, 2);
@c ===end===
@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

To find all partitions that satisfy a condition, use the function @code{subset};
here is an example that finds all partitions of 10 that consist of prime numbers.

@c ===beg===
@c s: integer_partitions (10)$
@c xprimep(x) := integerp(x) and (x > 1) and primep(x)$
@c subset (s, lambda ([x], every (xprimep, x)));
@c ===end===
@example
(%i1) s: integer_partitions (10)$
(%i2) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i3) subset (s, lambda ([x], every (xprimep, x)));
(%o3) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example

@c SEE SF BUG REPORT # 779053
(Notice that @code{primep(1)} is true in Maxima. This disagrees with
most definitions of prime.)
@end deffn

@c intersect IS AN ALIAS FOR intersection -- JUST REFER TO THE LATTER HERE
@anchor{intersect}
@deffn {Function} intersect (@var{a_1}, ..., @var{a_n})
Return a set containing the elements that are common to the
sets @var{a_1} through @var{a_n}. The function @code{intersect}
must receive one or more arguments. Signal an error if any of
@var{a_1} through @var{a_n} isn't a set.  See also @ref{intersection}.
@end deffn

@anchor{intersection}
@deffn {Function} intersection (@var{a_1}, ..., @var{a_n})
Return a set containing the elements that are common to the 
sets @var{a_1} through @var{a_n}. The function @code{intersection}
must receive one or more arguments. Signal an error if any of
@var{a_1} through @var{a_n} isn't a set.  See also @ref{intersect}.
@end deffn

@deffn {Function} kron_delta (@var{x}, @var{y})
The Kronecker delta function; @code{kron_delta (@var{x}, @var{y})} simplifies to
1 when @code{is(x = y)} is true and it simplifies to zero when 
@code{sign (|@var{x} - @var{y}|)} is @code{pos}.  When @code{sign (|@var{x} - @var{y}|)} is zero
and @code{@var{x} - @var{y}} isn't a floating point number (neither a double nor
a bfloat), return 0. Otherwise, return a noun form.

The function, @code{kron_delta} is declared to be 
symmetric; thus, for example, @code{kron_delta(x, y) - kron_delta(y, x)} 
simplifies to zero.

Here are a few examples.

@c ===beg===
@c [kron_delta (a, a), kron_delta (a + 1, a)];
@c kron_delta (a, b);
@c ===end===
@example
(%i1) [kron_delta (a, a), kron_delta (a + 1, a)];
(%o1)                        [1, 0]
(%i2) kron_delta (a, b);
(%o2)                   kron_delta(a, b)
@end example

Assuming that @code{a > b} makes @code{sign (|a - b|)} evaluate to @code{pos};
thus

@c ===beg===
@c assume (a > b)$
@c kron_delta (a, b);
@c ===end===
@example
(%i1) assume (a > b)$
(%i2) kron_delta (a, b);
(%o2)                           0
@end example

If we instead assume that @code{x >= y}, then @code{sign (|x - y|)} evaluates
to @code{pz}; in this case, @code{kron_delta (x, y)} doesn't simplify

@c ===beg===
@c assume(x >= y)$
@c kron_delta (x, y);
@c ===end===
@example
(%i1) assume(x >= y)$
(%i2) kron_delta (x, y);
(%o2)                   kron_delta(x, y)
@end example

Finally, since @code{1/10 - 0.1} evaluates to a floating point
number, we have 

@c ===beg===
@c kron_delta (1/10, 0.1);
@c ===end===
@example
(%i1) kron_delta (1/10, 0.1);
                                  1
(%o1)                  kron_delta(--, 0.1)
                                  10
@end example

If you want @code{kron_delta (1/10, 0.1)} to evaluate to 1, apply @code{float}.

@c ===beg===
@c float (kron_delta (1/10, 0.1));
@c ===end===
@example
(%i1) float (kron_delta (1/10, 0.1));
(%o1)                           1
@end example
@end deffn

@anchor{listify}
@deffn {Function} listify (@var{a})
If @var{a} is a set, return a list containing the members of @var{a};
when @var{a} isn't a set, return @var{a}.  To convert a set and all
of its members to lists, see @ref{full_listify}.

@c NEED TO PUT SOMETHING HERE
@c ===beg===
@c ===end===
@example
@end example
@end deffn

@anchor{lreduce}
@deffn {Function} lreduce (@var{f}, @var{s})
@deffnx {Function} lreduce (@var{f}, @var{s}, @var{init})
The function @code{lreduce} (left reduce) extends a 2-arity 
function to an n-arity function by composition; an example should 
make this clear. When the optional argument @var{init} isn't defined, we have

@c ===beg===
@c lreduce (f, [1, 2, 3]);
@c lreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

Notice that the function @var{f} is first applied to the
@code{leftmost} list elements (thus the name lreduce). 
When @var{init} is defined, the second argument to the inner most function 
evaluation is @var{init}; for example:

@c ===beg===
@c lreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

The function @code{lreduce} makes it easy to find the product or
sum of the elements of a list.

@c ===beg===
@c lreduce ("+", args (set (a, b)));
@c lreduce ("*", args (set (1, 2, 3, 4, 5)));
@c ===end===
@example
(%i1) lreduce ("+", args (set (a, b)));
(%o1)                         b + a
(%i2) lreduce ("*", args (set (1, 2, 3, 4, 5)));
(%o2)                          120
@end example

See also @ref{rreduce}, @ref{xreduce}, and @ref{tree_reduce}.
@end deffn

@anchor{makeset}
@deffn {Function} makeset (@var{e}, @var{v}, @var{s})
This function is similar to @code{makelist}, but @code{makeset} allows
multiple substitutions. The first argument @var{e} is an expression; the
second argument @var{v} is a list of variables; and @var{s} is a list or 
set of values for the variables @var{v}. Each member of @var{s} must
have the same length as @var{v}. We have @code{makeset (@var{e}, @var{v}, @var{s})}
@c FOLLOWING STATEMENT NEEDS CLARIFICATION
is the set @code{@{z | z = substitute(v -> s_i) and s_i in s@}}.

@c ===beg===
@c makeset (i/j, [i, j], [[a, b], [c, d]]);
@c ind: set (0, 1, 2, 3)$
@c makeset (i^2 + j^2 + k^2, [i, j, k], cartesian_product (ind, ind, ind));
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[a, b], [c, d]]);
                              a  c
(%o1)                        @{-, -@}
                              b  d
(%i2) ind: set (0, 1, 2, 3)$
(%i3) makeset (i^2 + j^2 + k^2, [i, j, k], cartesian_product (ind, ind, ind));
(%o3) @{0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 17, 18, 
                                                      19, 22, 27@}
@end example
@end deffn

@anchor{moebius}
@deffn {Function} moebius (@var{n})
The Moebius function; when @var{n} is product of @math{k} distinct
primes, @code{moebius(@var{n})} evaluates to @math{(-1)^k}; it evaluates to 1 when
@math{@var{n} = 1}; and it evaluates to 0 for all other positive integers. 
The Moebius function threads over equalities, lists, matrices, and 
sets.
@end deffn
 
@anchor{multinomial_coeff}
@deffn {Function} multinomial_coeff (@var{a_1}, ..., @var{a_n})
@deffnx {Function} multinomial_coeff ()
Return the multinomial coefficient.  When each @var{a_k} is
a nonnegative integer, the multinomial coefficient
gives the number of ways of placing @code{@var{a_1} + ... + @var{a_n}} 
distinct objects into @math{n} boxes with @var{a_k} elements in the 
@math{k}'th box. In general, @code{multinomial (@var{a_1}, ..., @var{a_n})}
evaluates to @code{(@var{a_1} + ... + @var{a_n})!/(@var{a_1}! ... @var{a_n}!)}. Given no
arguments, @code{multinomial()} evaluates to 1. A user may use
@code{minfactorial} to simplify the value returned by @code{multinomial_coeff};
for example:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn

@anchor{num_distinct_partitions}
@deffn {Function} num_distinct_partitions (@var{n})
@deffnx {Function} num_distinct_partitions (@var{n}, @var{a})

When @var{n} is a nonnegative integer, return the number of 
distinct integer partitions of @var{n}.

If the optional parameter @var{a} has the value @code{list}, return a 
list of the number of distinct partitions of 1,2,3, ... , n. 
If @var{n} isn't a nonnegative integer, return a noun form.

Definition: If @math{@var{n} = k_1 + ... + k_m}, where @math{k_1} 
through @math{k_m}  are distinct positive integers, we call 
@math{k_1 + ... + k_m} a distinct partition of @var{n}.
@end deffn

@anchor{num_partitions}
@deffn {Function} num_partitions (@var{n})
@deffnx {Function} num_partitions (@var{n}, @var{a})
When @var{n} is a nonnegative integer, return the number of partitions 
of @var{n}. If the optional parameter @var{a} has the value @code{list}, 
return a list of the number of partitions of 1,2,3, ... , n.  If @var{n} 
isn't a nonnegative integer, return a noun form.

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example

For a nonnegative integer @var{n}, @code{num_partitions (@var{n})} is equal to
@code{cardinality (integer_partitions (@var{n}))}; however, calling @code{num_partitions} 
is much faster.
@end deffn



@anchor{partition_set}
@deffn {Function} partition_set (@var{a}, @var{f})
Return a list of two sets; the first set is the subset of @var{a} for which
the predicate @var{f} evaluates to false and the second is the subset of 
@var{a} for which @var{f} evaluates to true.
If @var{a} isn't a set, signal an error.
See also @ref{subset}.

@c ===beg===
@c partition_set (set (2, 7, 1, 8, 2, 8), evenp);
@c partition_set (set (x, rat(y), rat(y) + z, 1), lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (set (2, 7, 1, 8, 2, 8), evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (set (x, rat(y), rat(y) + z, 1), lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn

@anchor{permutations}
@deffn {Function} permutations (@var{a})
Return a set of all @i{distinct} permutations of the members of 
the list or set @var{a}. (Each permutation is a list, not a set.) 
When @var{a} is a list, duplicate members of @var{a} are @i{not} deleted 
before finding the permutations. Thus

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example

If @var{a} isn't a list or set, signal an error.
@end deffn

@anchor{powerset}
@deffn {Function} powerset (@var{a})
@deffnx {Function} powerset (@var{a}, @var{n})
When the optional second argument @var{n} isn't defined, return the set 
of all subsets of the set @var{a}.
@code{powerset(@var{a})} has @code{2^cardinality(@var{a})} members.  Given a second argument,
@code{powerset(@var{a},@var{n})} returns the set of all subsets of @var{a} that have 
cardinality @var{n}. Signal an error if @var{a} isn't a set;
additionally signal an error if @var{n} isn't a positive integer.
@end deffn

@anchor{rreduce}
@deffn {Function} rreduce (@var{f}, @var{s})
@deffnx {Function} rreduce (@var{f}, @var{s}, @var{init})
The function @code{rreduce} (right reduce) extends a 2-arity 
function to an n-arity function by composition; an example should 
make this clear. When the optional argument @var{init} isn't defined, we have

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

Notice that the function @var{f} is first applied to the rightmost list
elements (thus the name rreduce). When @var{init} is defined, the
second argument to the inner most function 
evaluation is @var{init}; for example:

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

The function @code{rreduce} makes it easy to find the product or
sum of the elements of a list.

@c ===beg===
@c rreduce ("+", args (set (a, b)));
@c rreduce ("*", args (set (1, 2, 3, 4, 5)));
@c ===end===
@example
(%i1) rreduce ("+", args (set (a, b)));
(%o1)                         b + a
(%i2) rreduce ("*", args (set (1, 2, 3, 4, 5)));
(%o2)                          120
@end example

See also @ref{lreduce}, @ref{tree_reduce}, and @ref{xreduce}.
@end deffn

@anchor{setdifference}
@deffn {Function}  setdifference (@var{a}, @var{b})
Return a set containing the elements in the set @var{a} that are
not in the set @var{b}.  Signal an error if @var{a} or @var{b} is not a set.
@end deffn

@anchor{setequalp}
@deffn {Function} setequalp (@var{a}, @var{b})
Returns @code{true} if sets @var{a} and @var{b} have the same number of elements
@c $SETEQUALP CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
and @code{is (@var{x} = @var{y})} is @code{true}
for @code{x} in the elements of @var{a}
and @code{y} in the elements of @var{b},
considered in the order determined by @code{listify}.
Otherwise, @code{setequalp} returns @code{false}.

@code{setequalp} complains when @var{a} or @var{b} is not a set.

@end deffn

@anchor{setify}
@deffn {Function} setify (@var{a})
Construct a set from the elements of the list @var{a}.  Duplicate
elements of the list @var{a} are deleted and the elements
are sorted according to the predicate @code{orderlessp}.  
Signal an error if @code{a} isn't a list. 
@end deffn

@anchor{setp}
@deffn {Function} setp (@var{a})
Return true if and only if @var{a} is a Maxima set.  The function
@code{setp} checks that the operator of its argument is set; it doesn't
check that its argument is a @i{simplified} set. Thus

@c ===beg===
@c setp (set (a, a)), simp: false;
@c ===end===
@example
(%i1) setp (set (a, a)), simp: false;
(%o1)                         true
@end example

@c IF THE FOLLOWING STATEMENT IMPLIES setp IS EQUIVALENT TO setp(a) := is (inpart (a, 0) = set), SAY SO.
@c OTHERWISE THIS IS JUST A DISTRACTION SO CUT IT.
The function @code{setp} could be coded in Maxima as 
@code{setp(a) := is (inpart (a, 0) = set)}.

@end deffn

@anchor{set_partitions}
@deffn {Function} set_partitions (@var{a})
@deffnx {Function} set_partitions (@var{a}, @var{n})
When the optional argument @var{n} is defined, return a set of all
decompositions of @var{a} into @var{n} @var{nonempty} disjoint 
subsets. When @var{n} isn't defined, return the set of all partitions.

We say a set @math{P} is a partition of a set @math{S} provided

@enumerate
@item
each member of @math{P} is a nonempty set,
@item
distinct members of @math{P} are disjoint,
@item
the union of the members of @math{P} equals @math{S}.
@end enumerate

The empty set is a partition of itself (the conditions 1 and 2 being
vacuously true); thus

@c ===beg===
@c set_partitions (set ());
@c ===end===
@example
(%i1) set_partitions (set ());
(%o1)                         @{@{@}@}
@end example

The cardinality of the set of partitions of a set can be found using @code{stirling2}; thus

@c ===beg===
@c s: set (0, 1, 2, 3, 4, 5)$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: set (0, 1, 2, 3, 4, 5)$
(%i2) p: set_partitions (s, 3)$ 
(%o3)                        90 = 90
(%i4) cardinality(p) = stirling2 (6, 3);
@end example

Each member of @code{p} should have 3 members; let's check.

@c ===beg===
@c s: set (0, 1, 2, 3, 4, 5)$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: set (0, 1, 2, 3, 4, 5)$
(%i2) p: set_partitions (s, 3)$ 
(%o3)                          @{3@}
(%i4) map (cardinality, p);
@end example

Finally, for each member of @code{p}, the union of its members should 
equal @code{s}; again let's check.

@c ===beg===
@c s: set (0, 1, 2, 3, 4, 5)$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: set (0, 1, 2, 3, 4, 5)$
(%i2) p: set_partitions (s, 3)$ 
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
(%i4) map (lambda ([x], apply (union, listify (x))), p);
@end example
@end deffn

@anchor{some}
@deffn {Function} some (@var{f}, @var{a})
@deffnx {Function} some (@var{f}, @var{L_1}, ..., @var{L_n})

The first argument @var{f} should be a predicate (a function that evaluates to
true, false, or unknown). 

Given one set as the second argument, 
@code{some (@var{f}, @var{a})} returns @code{true}
if @code{@var{f}(@var{a_i})} returns @code{true} for at least one @var{a_i} in @var{a}.
Since sets are unordered, @code{some} is free to evaluate @code{@var{f}(@var{a_i})} in any
order. @code{some} may or may not evaluate  @var{f} for all @var{a_i} in @var{a}. Because the
order of evaluation isn't specified, the predicate @var{f} should
not have side-effects or signal errors for any input. 
To use @code{some} on multiple set arguments, they should first be converted
to an ordered sequence so that their relative alignment becomes well-defined.

Given one or more lists as arguments,
@code{some (@var{f}, @var{L_1}, ..., @var{L_n})} returns @code{true}
if @code{@var{f}(@var{x_1}, ..., @var{x_n})} returns @code{true} 
for at least one @var{x_1}, ..., @var{x_n} in @var{L_1}, ..., @var{L_n}, respectively.
@code{some} may or may not evaluate 
@var{f} for every combination @var{x_1}, ..., @var{x_n}.
@c FOLLOWING STATEMENT IS AMBIGUOUS: IS f(L_1[1], L_2[2]) EVALUATED BEFORE OR AFTER f(L_1[2], L_2[2]) ??
Since lists are ordered, @code{some} evaluates in the order of increasing index.

If the global flag @code{maperror} is true (the default), all lists 
@var{L_1}, ..., @var{L_n} must have equal lengths -- otherwise, @code{some} signals an error.
When @code{maperror} is false, the list arguments are
effectively truncated each to the length of the shortest list. 

The Maxima function @code{is} is automatically applied after evaluating the
predicate @var{f}.

@c ===beg===
@c some ("<", [a, b, 5], [1, 2, 8]);
@c some ("=", [2, 3], [2, 7]);
@c ===end===
@example
(%i1) some ("<", [a, b, 5], [1, 2, 8]);
(%o1)                         true
(%i2) some ("=", [2, 3], [2, 7]);
(%o2)                         true
@end example
@end deffn

@anchor{stirling1}
@deffn {Function} stirling1 (@var{n}, @var{m})
The Stirling number of the first kind.  When @var{n} and @var{m} are nonnegative 
integers, the magnitude of @code{stirling1 (@var{n}, @var{m})} is the number of 
permutations of a set with @var{n} members that have @var{m} cycles.
For details, see Graham, Knuth and Patashnik @i{Concrete Mathematics}.
We use a recursion relation to define @code{stirling1 (@var{n}, @var{m})} for
@var{m} less than 0; we do not extend it for @var{n} less than 0 or for non-integer
arguments.

The function @code{stirling1} works by simplification; it knows the 
basic special values (see Donald Knuth, @i{The Art of Computer Programming,}
third edition, Volume 1,  Section 1.2.6, Equations 48, 49, and 50).  
For Maxima to apply these rules, the arguments must be declared to 
be integer and the first argument must nonnegative. For example:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

@code{stirling1} does not simplify for non-integer arguments.

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima knows a few other special values; for example:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn

@anchor{stirling2}
@deffn {Function} stirling2 (@var{n}, @var{m})
The Stirling number of the second kind. When @var{n} and @var{m} are nonnegative 
integers, @code{stirling2 (@var{n}, @var{m})} is the number of ways a set with 
cardinality @var{n} can be partitioned into @var{m} disjoint subsets.
We use a recursion relation to define @code{stirling2 (@var{n}, @var{m})} for
@var{m} less than 0; we do not extend it for @var{n} less than 0 or for non-integer
arguments.

The function @code{stirling2} works by simplification; it knows the 
basic special values (see Donald Knuth, @i{The Art of Computer Programming,}
third edition, Volume 1,  Section 1.2.6, Equations 48, 49, and 50).  
For Maxima to apply these rules, the arguments must be declared to 
be integer and the first argument must nonnegative. For example:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

@code{stirling2} does not simplify for non-integer arguments.

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

@c ENUMERATE OR OTHERWISE DESCRIBE LIST OF KNOWN SPECIAL VALUES
Maxima knows a few other special values.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn

@anchor{subset}
@deffn {Function} subset (@var{a}, @var{f})
Return the subset of the set @var{a} that satisfies the predicate @var{f}. 
For example:

@c ===beg===
@c subset (set (1, 2, x, x + y, z, x + y + z), atom);
@c subset (set (1, 2, 7, 8, 9, 14), evenp);
@c ===end===
@example
(%i1) subset (set (1, 2, x, x + y, z, x + y + z), atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (set (1, 2, 7, 8, 9, 14), evenp);
(%o2)                      @{2, 8, 14@}
@end example

The second argument to @code{subset} must be a predicate
(a boolean-valued function of one argument) if the first argument to 
@code{subset} isn't a set, signal an error. See also
@ref{partition_set}.
@end deffn

@anchor{subsetp}
@deffn {Function} subsetp (@var{a}, @var{b})
Return true if and only if the set @var{a} is a subset of @var{b}.
Signal an error if @var{a} or @var{b} is not a set.
@end deffn

@anchor{symmdifference}
@deffn {Function} symmdifference (@var{a_1}, ..., @var{a_n})
Return the set of members that occur in exactly one
set @var{a_k}. Signal an error if any argument @var{a_k} isn't a
set. Given two arguments, @code{symmdifference (@var{a}, @var{b})} is
the same as @code{union (setdifference (@var{a}, @var{b}), setdifference (@var{b}, @var{a}))}.
@end deffn

@c tree_reduce ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT rreduce AND lreduce WANT ONLY LISTS; STRANGE
@anchor{tree_reduce}
@deffn {Function} tree_reduce (@var{f}, @var{s})
@deffnx {Function} tree_reduce (@var{f}, @var{s}, @var{init})

The function @code{tree_reduce} extends a associative binary operator @math{f : S x S -> S}
from two arguments to any number of arguments using a minimum
depth tree.  An example should make this clear.

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

Given an odd number of arguments, @code{tree_reduce} favors the left
side of the tree; for example:

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example

For addition of floating point numbers, using @code{tree_reduce} may
give a sum that has a smaller rounding error than using either
@code{rreduce} or @code{lreduce}.
@end deffn

@anchor{union}
@deffn {Function} union (@var{a_1}, ..., @var{a_n})
Return the union of the sets @var{a_1} through @var{a_n}. 
When @code{union} receives no arguments, it returns the
empty set. Signal an error when one or more arguments to 
@code{union} is not a set.
@end deffn

@c xreduce ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT rreduce AND lreduce WANT ONLY LISTS; STRANGE
@anchor{xreduce}
@deffn {Function} xreduce (@var{f}, @var{s})
@deffnx {Function} xreduce (@var{f}, @var{s}, @var{init})

This function is similar to both @code{lreduce} and @code{rreduce} except
that @code{xreduce} is free to use either left or right associativity; 
in particular when @var{f} is an associative function and Maxima 
has a built-in evaluator for it, @code{xreduce} may use the n-ary
function; these n-ary functions include 
addition @code{+}, multiplication @code{*}, @code{and}, @code{or}, @code{max},
@code{min}, and @code{append}. For these operators, we generally expect
using @code{xreduce} to be faster than using either @code{rreduce} or
@code{lreduce}.  When @var{f} isn't n-ary, @code{xreduce} uses
left-associativity.

Floating point addition is not associative; nevertheless, @code{xreduce}
uses Maxima's n-ary addition when the set or list @var{s} contains
floating point numbers.

@end deffn







