@menu
* Introduction to Tensor::
* Definitions for Tensor::
@end menu

@node Introduction to Tensor, Definitions for Tensor, Tensor, Tensor
@section Introduction to Tensor

 - Indicial Tensor Manipulation package.  It may be loaded by
@code{load(itensor)}. Demos are also available: try @code{demo(itensor)}.

 - There are two tensor packages in Maxima, CTENSOR and
ITENSOR.  CTENSOR is Component Tensor Manipulation, and may be accessed
with @code{load(ctensor)}.

In ITENSOR a tensor is represented as an "indexed object" .  This is a
function of 3 groups of indices which represent the covariant,
contravariant and derivative indices.  The covariant indices are
specified by a list as the first argument to the indexed object, and
the contravariant indices by a list as the second argument. If the
indexed object lacks either of these groups of indices then the empty
list [] is given as the corresponding argument.  Thus, @code{g([a,b],[c])}
represents an indexed object called @code{g} which has two covariant indices
@code{(a,b)}, one contravariant index (@code{c}) and no derivative indices.

The derivative indices, if they are present, are appended as
additional arguments to the symbolic function representing the tensor.
They can be explicitly specified by the user or be created in the
process of differentiation with respect to some coordinate variable.
Since ordinary differentiation is commutative, the derivative indices
are sorted alphanumerically, unless @code{iframe_flag} is set to @code{true},
indicating that a frame metric is being used.. This canonical ordering makes it
possible for MAXIMA to recognize that, for example, @code{t([a],[b],i,j)} is
the same as @code{t([a],[b],j,i)}.  Differentiation of an indexed object with
respect to some coordinate whose index does not appear as an argument
to the indexed object would normally yield zero. This is because
MAXIMA would not know that the tensor represented by the indexed
object might depend implicitly on the corresponding coordinate.  By
modifying the existing MAXIMA function @code{diff} in ITENSOR, MAXIMA now
assumes that all indexed objects depend on any variable of
differentiation unless otherwise stated.  This makes it possible for
the summation convention to be extended to derivative indices. It
should be noted that ITENSOR does not possess the capabilities of
raising derivative indices, and so they are always treated as
covariant.

The following functions are available in the tensor package for
manipulating indexed objects.  At present, with respect to the
simplification routines, it is assumed that indexed objects do not
by default possess symmetry properties. This can be overridden by
setting the variable @code{allsym[false]} to @code{true}, which will
result in treating all indexed objects completely symmetric in their
lists of covariant indices and symmetric in their lists of
contravariant indices.

The ITENSOR package generally treats tensors as opaque objects. Tensorial
equations are manipulated based on algebraic rules, specifically symmetry
and contraction rules. In addition, the ITENSOR package understands
covariant differentiation, curvature, and torsion. Calculations can be
performed relative to a metric of moving frame, depending on the setting
of the @code{iframe_flag} variable.

A sample session below demonstrates how to load the ITENSOR package,
specify the name of the metric, and perform some simple calculations.

@example
(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);

(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$

(%i4) ishow(g([k,l],[]))$

(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$

(%t5)                                  0
(%i6) depends(v,t);

(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$

                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$

(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$

(%t9)                             v    - v
                                   j,i    i,j
(%i10) ishow(liediff(v,w([i],[])))$

                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$

                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$

               %4 %5
(%t12) v    - g      v   (e p       + e   p     - e p       - e    p
        i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                + e p       + e   p    )/2
                                                     i %5,j    ,j  i %5
(%i13) iframe_flag:true;

(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$

                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$

                                        %6         %6
(%t15)                  v    - v   (ifc2    + ichr2   )
                         i,j    %6      i j        i j
(%i16) ishow(radcan(ev(%,ifc2)))$

               %1               %1     %3 %2    %1
(%t16) (v   ifb    - 2 v   ichr2    + g      ifb     v   g     + 2 v
         %1    i j      %1      i j             %2 j  %3  i %1      i,j

                                                %3 %1    %2
                                             - g      ifb     g     v  )/2
                                                         %1 i  %2 j  %3
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$

(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);

(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$

(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$

(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);

(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$

(%t22)                                 0
@end example



@c end concepts Tensor

@node Definitions for Tensor,  , Introduction to Tensor, Tensor

@section Managing Indexed Objects

@c @node entertensor
@c @unnumberedsec phony
@defun entertensor (name)

is a function which, by prompting, allows one to create an indexed
object called @code{name} with any number of tensorial and derivative
indices. Either a single index or a list of indices (which may be
null) is acceptable input (see the example under @code{covdiff}).

@end defun

@c @node changename
@c @unnumberedsec phony
@defun changename (old,new,exp)

will change the name of all indexed objects called @code{old} to @code{new}
in @code{exp}. @code{old} may be either a symbol or a list of the form
@code{[name, m, n]} in which case only those indexed objects called
@code{name} with @code{m} covariant and @code{n} contravariant indices will be
renamed to @code{new}.

@end defun

@c @node listoftens
@c @unnumberedsec phony
@defun listoftens

Lists all tensors in a tensorial expression, complete with their indices. E.g.,

@example

(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$

                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$

                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

@end example

@end defun

@c @node ishow
@c @unnumberedsec phony
@defun ishow (exp)

displays @code{exp} with the indexed objects in it shown having their
covariant indices as subscripts and contravariant indices as
superscripts. The derivative indices are displayed as subscripts,
separated from the covariant indices by a comma (see the examples
throughout this document).

@end defun

@c @node indices
@c @unnumberedsec phony
@defun indices (exp)

Returns a list of two elements.  The first is a list of the free
indices in @code{exp} (those that occur only once). The second is the
list of the dummy indices in @code{exp} (those that occur exactly twice)
as the following example demonstrates.

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$

                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);

(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

@end example

A tensor product containing the same index more than twice is syntactically
illegal. @code{indices} attempts to deal with these expressions in a
reasonable manner; however, when it is called to operate upon such an
illegal expression, its behavior should be considered undefined.


@end defun

@c @node rename (exp[, count])
@c @unnumberedsec phony
@defun rename

Returns an expression equivalent to @code{exp} but with the dummy indices
in each term chosen from the set @code{[%1, %2,...]}, if the optional second
argument is omitted. Otherwise, the dummy indices are indexed
beginning at the value of @code{count}.  Each dummy index in a product
will be different. For a sum, @code{rename} will operate upon each term in
the sum resetting the counter with each term. In this way @code{rename} can
serve as a tensorial simplifier. In addition, the indices will be
sorted alphanumerically (if @code{allsym} is @code{true}) with respect to
covariant or contravariant indices depending upon the value of @code{flipflag}.
If @code{flipflag} is @code{false} then the indices will be renamed according
to the order of the contravariant indices. If @code{flipflag} is @code{true}
the renaming will occur according to the to the order of the contravariant
indices. It often happens that the combined effect of the two renamings will
reduce an expression more than either one by itself.

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;

(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$

(%i4) exp:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;

(%o5)                                true
(%i6) ishow(rename(exp))$

       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

              %4 %5  %6 %7      u          %1         %3         %2
           - g      g      ichr2      ichr2      ichr2      ichr2
                                %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;

(%o7)                                false
(%i8) rename(%th(2));

(%o8)                                  0
(%i9) ishow(rename(exp))$

       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

              %1 %2  %3 %4      %6         %5         %7        u
           - g      g      ichr2      ichr2      ichr2     ichr2
                                %1 %3      %2 %6      %4 r      %5 %7
@end example

@end defun

@c @node flipflag
@c @unnumberedsec phony
@defvar flipflag

Default: @code{false}. if @code{false} then the indices will be
renamed according to the order of the contravariant indices,
otherwise according to the order of the covariant indices.
The function influences @code{rename()} in the following way:
If @code{flipflag} is @code{false} then @code{rename} forms a list
of the contravariant indices as they are encountered from left to right
(if @code{true} then of the covariant indices). The first dummy
index in the list is renamed to @code{%1}, the next to @code{%2}, etc.
Then sorting occurs after the @code{rename()}-ing (see the example
under @code{rename()}).

@end defvar

@c @node defcon
@c @unnumberedsec phony
@defun defcon (tensor1,<tensor2,tensor3>)
gives @code{tensor1} the property that the
contraction of a product of @code{tensor1} and @code{tensor2} results in @code{tensor3}
with the appropriate indices.  If only one argument, @code{tensor1}, is
given, then the contraction of the product of tensor1 with any indexed
object having the appropriate indices (say @code{tensor}) will yield an
indexed object with that name, i.e. @code{tensor}, and with a new set of
indices reflecting the contractions performed.
    For example, if @code{imetric:g}, then @code{defcon(g)} will implement the
raising and lowering of indices through contraction with the metric
tensor.
    More than one @code{defcon} can be given for the same indexed object; the
latest one given which applies in a particular contraction will be
used.
@code{contractions} is a list of those indexed objects which have been given
contraction properties with @code{defcon}.

@end defun

@c @node remcon
@c @unnumberedsec phony
@defun remcon (tensor1,tensor2,...)
removes all the contraction properties
from the @code{tensori}. @code{remcon(all)} removes all contraction
properties from all indexed objects.

@end defun

@c @node contract
@c @unnumberedsec phony
@defun contract (exp)

Carries out the tensorial contractions in @code{exp} which may be any
combination of sums and products.  This function uses the information
given to the @code{defcon} function.  When using @code{contract}, @code{exp}
must be fully expanded. Also see the function @code{imetric} and the
 example under @code{dim}.


@end defun

@c @node indexed_tensor
@c @unnumberedsec phony
@defun indexed_tensor (tensor)

Must be executed before assigning components to a @code{tensor} for which
a built in value already exists as with @code{ichr1}, @code{ichr2},
@code{icurvature}. See the example under @code{icurvature}.

@end defun

@c @node components
@c @unnumberedsec phony
@defun components (tensor, exp)

permits one to assign an indicial value to an expression
@code{exp} giving the values of the components of @code{tensor}. These
are automatically substituted for the tensor whenever it occurs with
all of its indices. The tensor must be of the form @code{t([...],[...])}
where either list may be empty. @code{exp} can be any indexed expression
involving other objects with the same free indices as @code{tensor}. When
used to assign values to the metric tensor wherein the components
contain dummy indices one must be careful to define these indices to
avoid the generation of multiple dummy indices. Removal of this
assignment is given to the function @code{remcomps}.

The example under @code{defcon} demonstrates the use of the
@code{components} function to define an algebraically special metric and
also shows how the null property of the vector field can be given
with the property assignment functions. The example above under @code{ichr2}
gives the basic syntax used in the @code{components} statement.


@end defun

@c @node remcomps
@c @unnumberedsec phony
@defun remcomps (tensor)

Unbinds all values from @code{tensor} which were assigned with the
@code{components} function.

@end defun

@c @node showcomps
@c @unnumberedsec phony
@defun showcomps

Shows component assignments of a tensor, as made using the @code{components}
command. This command can be particularly useful when a matrix is assigned
to an indicial tensor using @code{components}, as demonstrated by the
following example:

@example

(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);

(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);

               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);

(%o4)                                done
(%i5) showcomps(g([i,j],[]));

                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false


@end example

The @code{showcomps} command can also display components of a tensor of
rank higher than 2.

@end defun

@c @node idummy
@c @unnumberedsec phony
@defun idummy ()

Increments @code{icounter} and returns as its value an index of the form
@code{%n} where n is a positive integer.  This guarantees that dummy indices
which are needed in forming expressions will not conflict with indices
already in use (see the example under @code{indices}).

@end defun

@c @node idummyx
@c @unnumberedsec phony
@defvar idummyx

Is the prefix for dummy indices (see the example under @code{indices}).

@end defvar

@c @node icounter
@c @unnumberedsec phony
@defvar icounter
 default: [1] determines the numerical suffix to be used in
generating the next dummy index in the tensor package.  The prefix is
determined by the option @code{idummy} (default: %).
@end defvar

@c @node kdelta
@c @unnumberedsec phony
@defun kdelta (l1,l2)
is the generalized Kronecker delta function defined in
the Tensor package with @code{l1} the list of covariant indices and @code{l2}
the list of contravariant indices.  @code{kdelta([i],[j])} returns the ordinary
Kronecker delta.  The command @code{ev(exp,kdelta)} causes the evaluation of
an expression containing @code{kdelta([],[])} to the dimension of the
manifold.

@end defun

@c @node kdels
@c @unnumberedsec phony
@defun kdels (l1,l2)

Symmetricized Kronecker delta, used in some calculations. For instance:

@example

(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);

(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);

(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$

                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$

                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

@end example

@end defun

@c @node levi_civita
@c @unnumberedsec phony
@defun levi_civita (l)
is the permutation (or Levi-Civita) tensor which yields 1 if
the list @code{l} consists of an even permutation of integers, -1 if it
consists of an odd permutation, and 0 if some indices in @code{l} are
repeated.

@end defun

@c @node lc_l
@c @unnumberedsec phony
@defun lc_l

Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (@code{levi-civita}). Along with @code{lc_u}, it can be used to simplify
many expressions more efficiently than the evaluation of @code{levi-civita}.
For example:

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$

                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$

                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$

(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$

(%t5)                                  0

@end example

@end defun

@c @node lc_u
@c @unnumberedsec phony
@defun lc_u

Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (@code{levi-civita}). Along with @code{lc_u}, it can be used to simplify
many expressions more efficiently than the evaluation of @code{levi-civita}.
For details, see @code{lc_l}.

@end defun

@c @node canten
@c @unnumberedsec phony
@defun canten (exp)
[Tensor Package] Simplifies exp by renaming (see @code{rename})
and permuting dummy indices. @code{rename} is restricted to sums of tensor
products in which no derivatives are present. As such it is limited
and should only be used if @code{canform} is not capable of carrying out the
required simplification.

@end defun

@section Tensor symmetries

@c @node allsym
@c @unnumberedsec phone
@defvar allsym

Default: @code{false}. if @code{true} then all indexed objects
are assumed symmetric in all of their covariant and contravariant
indices. If @code{false} then no symmetries of any kind are assumed
in these indices. Derivative indices are always taken to be symmetric
unless @code{iframe_flag} is set to @code{true}.

@end defvar

@c @node decsym
@c @unnumberedsec phony
@defun decsym (tensor, m, n, [cov1,cov2,...], [contr1,contr2,...])

Declares symmetry properties for @code{tensor} of @code{m} covariant and
@code{n} contravariant indices. The @code{covi} and @code{contri} are
pseudofunctions expressing symmetry relations among the covariant and
contravariant indices respectively.  These are of the form
@code{symoper(index1, index2,...)} where @code{symoper} is one of
@code{sym}, @code{anti} or @code{cyc} and the @code{indexi} are integers
indicating the position of the index in the @code{tensor}.  This will
declare @code{tensor} to be symmetric, antisymmetric or cyclic respectively
in the @code{indexi}. @code{symoper(all)} is also an allowable form which
indicates all indices obey the symmetry condition. For example, given an
object @code{b} with 5 covariant indices,
@code{decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])} declares @code{b}
symmetric in its first and second and antisymmetric in its third and
fourth covariant indices, and cyclic in all of its contravariant indices.
Either list of symmetry declarations may be null.  The function which
performs the simplifications is @code{canform} as the example below
illustrates.

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) exp:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$

(%i3) ishow(exp)$

(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);

(%o4)                                done
(%i5) ishow(canform(exp))$

(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);

(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);

(%o7)                                done
(%i8) ishow(canform(exp))$

(%t8)                                  0
(%i9) remsym(a,3,0);

(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);

(%o10)                               done
(%i11) ishow(canform(exp))$

(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);

(%o12)                     [[cyc, [[1, 2, 3]], []]]



@end example


@end defun

@c @node remsym
@c @unnumberedsec phony
@defun remsym ()

Removes all symmetry properties from @code{tensor} which has @code{m}
covariant indices and @code{n} contravariant indices.


@end defun

@c @node canform
@c @unnumberedsec phony
@defun canform (exp)
[Tensor Package] Simplifies exp by renaming dummy
indices and reordering all indices as dictated by symmetry conditions
imposed on them. If @code{allsym} is @code{true} then all indices are assumed
symmetric, otherwise symmetry information provided by @code{decsym}
declarations will be used. The dummy indices are renamed in the same
manner as in the @code{rename} function. When @code{canform} is applied to a large
expression the calculation may take a considerable amount of time.
This time can be shortened by calling @code{rename} on the expression first.
Also see the example under @code{decsym}. Note: @code{canform} may not be able to
reduce an expression completely to its simplest form although it will
always return a mathematically correct result.
@end defun

@section Indicial tensor calculus

@c @node diff
@c @unnumberedsec phony
@defun diff (exp, v1,[n1,[v2,n2]...])

is the usual MAXIMA differentiation function which has been expanded
in its abilities for ITENSOR. It takes the derivative of @code{exp} with
respect to @code{v1} @code{n1} times, with respect to @code{v2} @code{n2}
times, etc. For the tensor package, the function has been modified so
that the @code{vi} may be integers from 1 up to the value of the variable
@code{dim}.  This will cause the differentiation to be carried out with
respect to the @code{vi}th member of the list @code{vect_coords}.  If
@code{vect_coords} is bound to an atomic variable, then that variable
subscripted by @code{vi} will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like @code{x[1]}, @code{x[2]},...  to be used.
@end defun

@c @node idiff
@c @unnumberedsec phony
@defun idiff (exp, v1,[n1,[v2,n2]...])
Indicial differentiation. Unlike @code{diff()}, which differentiates
with respect to an independent variable, @code{idiff()} can be used
to differentiate with respect to a coordinate. For an indexed object,
this amounts to appending the @code{vi} as derivative indices.
Subsequently, derivative indices will be sorted, unless @code{iframe_flag}
is set to @code{true}.

@code{idiff()} can also differentiate the determinant of th metric
tensor. Thus, if @code{imetric} has been bound to @code{G} then
@code{idiff(determinant(g),k)} will return
@code{2*determinant(g)*ichr2([%i,k],[%i])} where the dummy index @code{%i}
is chosen appropriately.


@end defun

@c @node liediff
@c @unnumberedsec phony
@defun liediff (v,ten)

Computes the Lie-derivative of the tensorial expression @code{ten} with
respect to the vector field @code{v}. @code{ten} should be any indexed
tensor expression; @code{v} should be the name (without indices) of a vector
field. For example:

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$

       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                                %1  k        %1  k      %1  k
                            + (v   b      - b   v    + v   b   ) a
                                    ,%1 l    ,l  ,%1    ,l  ,%1   i j


@end example


@end defun

@c @node rediff
@c @unnumberedsec phony
@defun rediff (ten)

Evaluates all occurrences of the @code{idiff} command in the tensorial
expression @code{ten}.

@end defun

@c @node undiff
@c @unnumberedsec phony
@defun undiff (exp)

Returns an expression equivalent to @code{exp} but with all derivatives
of indexed objects replaced by the noun form of the @code{idiff} function. Its
arguments would yield that indexed object if the differentiation were
carried out.  This is useful when it is desired to replace a
differentiated indexed object with some function definition resulting
in @code{exp} and then carry out the differentiation by saying
@code{ev(exp, idiff)}.

@end defun

@c @node evundiff
@c @unnumberedsec phony
@defun evundiff

Equivalent to the execution of @code{undiff}, followed by @code{ev} and
@code{rediff}.

@end defun

@c @node flush
@c @unnumberedsec phony
@defun flush (exp,tensor1,tensor2,...)
Tensor Package - will set to zero, in
exp, all occurrences of the @code{tensori} that have no derivative indices.

@end defun

@c @node flushd
@c @unnumberedsec phony
@defun flushd (exp,tensor1,tensor2,...)
Tensor Package - will set to zero, in
exp, all occurrences of the @code{tensori} that have derivative indices.

@end defun

@c @node flushnd
@c @unnumberedsec phony
@defun flushnd (exp,tensor,n)
Tensor Package - will set to zero, in exp, all
occurrences of the differentiated object tensor that have n or more
derivative indices as the following example demonstrates.
@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$

                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$

                                     J r
(%t3)                               a
                                     i,k r
@end example
@end defun

@c @node coord
@c @unnumberedsec phony
@defun coord (tensor1, tensor2, ...)

Gives @code{tensori} the coordinate differentiation property that the
derivative of contravariant vector whose name is one of the
@code{tensori} yields a Kronecker delta. For example, if @code{coord(x)} has
been done then @code{idiff(x([],[i]),j)} gives @code{kdelta([i],[j])}.
@code{coord} is a list of all indexed objects having this property.

@end defun
@c @node remcoord
@c @unnumberedsec phony
@defun remcoord (tensor1, tensor2, ...)

Removes the coordinate differentiation property from the @code{tensori}
that was established by the function @code{coord}.  @code{remcoord(all)}
removes this property from all indexed objects.

@end defun

@c @node makebox
@c @unnumberedsec phony
@defun makebox (exp)
will display exp in the same manner as SHOW; however,
any tensor d'Alembertian occurring in exp will be indicated using the
symbol [].  For example, @code{[]p([m],[n])} represents
@code{g([],[i,j])*p([m],[n],i,j)}.

@end defun

@c @node conmetderiv
@c @unnumberedsec phony
@defun conmetderiv (exp, tensor)

is used to simplify expressions containing ordinary derivatives of
both covariant and contravariant forms of the metric tensor (the
current restriction).  For example, CONMETDERIV can relate the
derivative of the contravariant metric tensor with the Christoffel
symbols as seen from the following:

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$

                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$

                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c

@end example

@end defun
@c @node flush1deriv
@c @unnumberedsec phony
@defun flush1deriv (exp, tensor)

Will set to zero, in @code{exp}, all occurrences of @code{tensor} that have
exactly one derivative index.

@end defun

@section Tensors in curved spaces

@c @node imetric
@c @unnumberedsec phony
@defun imetric (g)
specifies the metric by assigning the variable @code{imetric:g} in
addition, the contraction properties of the metric G are set up by
executing the commands @code{defcon(g),defcon(g,g,kdelta)}.
The variable @code{imetric}, default: [], is bound to the metric, assigned by
the @code{imetric(g)} command.

@end defun

@c @node ichr1
@c @unnumberedsec phony
@defun ichr1 ([i,j,k])
yields the Christoffel symbol of the first kind via the
definition
@example
       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
@end example
@noindent
To evaluate the Christoffel symbols for a particular metric, the
variable @code{imetric} must be assigned a name as in the example under CHR2.

@end defun

@c @node ichr2
@c @unnumberedsec phony
@defun ichr2 ([i,j],[k])
yields the Christoffel symbol of the second kind
defined by the relation
@example
                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
@end example
@end defun

@c @node icurvature
@c @unnumberedsec phony
@defun icurvature ([i,j,k],[h])
Indicial Tensor Package) yields the Riemann
curvature tensor in terms of the Christoffel symbols of the second
kind (@code{ichr2}).  The following notation is used:
@example
               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
@end example
@end defun

@c @node covdiff
@c @unnumberedsec phony
@defun covdiff (exp,v1,v2,...)
yields the covariant derivative of exp with
respect to the variables vi in terms of the Christoffel symbols of the
second kind (@code{ichr2}).  In order to evaluate these, one should use
@code{ev(exp,ichr2)}.

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$

Enter tensor name: a;

Enter a list of the covariant indices: [i,j];

Enter a list of the contravariant indices: [k];

Enter a list of the derivative indices: [];

                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$

             k         %1     k         %1     k            k     %1
(%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
             i %1      j s    %1 j      i s    i j,s        %1 s  i j

@end example

@end defun

@c @node lorentz_gauge
@c @unnumberedsec phony
@defun lorentz_gauge (exp)
imposes the Lorentz condition by substituting 0 for all
indexed objects in exp that have a derivative index identical to a
contravariant index.

@end defun

@c @node igeodesic_coords
@c @unnumberedsec phony
@defun igeodesic_coords (exp, name)

Enables the user to cause undifferentiated Christoffel symbols and
first derivatives of the metric tensor vanish in @code{exp}. The @code{name}
in the @code{igeodesic_coords} function refers to the metric @code{name}
(if it appears in @code{exp}) while the connection coefficients must be
called with the names @code{ichr1} and/or @code{ichr2}. The following example
demonstrates the verification of the cyclic identity satisfied by the Riemann
curvature tensor using the @code{igeodesic_coords} function.

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$

             u            u         %1         u            u         %1
(%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
             r t,s        %1 s      r t        r s,t        %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$

                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$

             u            u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t        r t,s

                                                                  u
                                                           + ichr2
                                                                  r s,t
(%i5) canform(%);

(%o5)                                  0

@end example

@end defun

@section Moving frames

MAXIMA now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary frame.

To use frames, you must first set @code{iframe_flag} to @code{true}. This
causes the Christoffel-symbols, @code{ichr1} and @code{ichr2}, to be replaced
by the more general frame connection coefficients @code{icc1} and @code{icc2}
in calculations. Speficially, the behavior of @code{covdiff} and
@code{icurvature} is changed.

The frame is defined by two tensors: the inverse frame field (@code{ifri}),
and the frame metric @code{ifg}. The frame metric is the identity matrix for
orthonormal frames, or the Lorentz metric for orthonormal frames in Minkowski
spacetime. The inverse frame field defines the frame base (unit vectors).
Contraction properties are defined for the frame field and the frame metric.

IMPORTANT: Setting the variable @code{iframe_flag} to @code{true} does NOT
undefine the contraction properties of a metric defined by a call to
@code{defcon()} or @code{imetric()}. If a frame field is used, it is best to
define the metric by assigning its name to the variable @code{imetric}
and NOT invoke the @code{imetric()} function.

MAXIMA uses these two tensors to define the frame coefficients (@code{ifc1}
and @code{ifc2}) which form part of the connection coefficients (@code{icc1}
and @code{icc2}), as the following example demonstrates:

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;

(%o2)                                true
(%i3) imetric(g);

(%o3)                                done
(%i4) ishow(covdiff(v([],[i]),j))$

                               i        i     %1
(%t4)                         v   + icc2     v
                               ,j       %1 j
(%i5) ishow(ev(%,icc2))$

                        %1      i           i        i
(%t5)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i6) ishow(ev(%,ifc2))$

            i %3     %2                      %2         i
           g     (ifb      g     - g      ifb    ) - ifb
       %1            %1 %3  %2 j    %1 %2    %3 j       %1 j        i        i
(%t6) v   (------------------------------------------------- + ichr2    ) + v
                                   2                                %1 j     ,j
(%i7) ishow(ifb([a,b],[c]))$

                           c           c         %4    %5
(%t7)                 (ifri      - ifri     ) ifr   ifr
                           %4,%5       %5,%4     a     b

@end example

An alternate method is used to compute the frame bracket (@code{ifb}) if
the @code{iframe_bracket_form} flag is set to @code{false}:

@example

(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b],[c])))$

                        c      %7    %6        %6      %7
(%t8)               ifri   (ifr   ifr     - ifr     ifr  )
                        %6     a     b,%7      a,%7    b

@end example


@c @node iframes
@c @unnumberedsec phony
@defun iframes ()

Since in this version of MAXIMA, contraction identities for @code{ifr} and
@code{ifri} are always defined, as is the frame bracket (@code{ifb}), this
function does nothing.

@end defun

@c @node ifb
@c @unnumberedsec phony
@defvar ifb

The frame bracket. The contribution of the frame metric to the connection
coefficients is expressed using the frame bracket:

@example

    c     cd        e     cd        e       c
ifc2   = g   g   ifb   - g   g   ifb   - ifb
    ab        be    ad        ae    db      ab

@end example

The frame bracket itself is defined in terms of the frame field and frame
metric. Two alternate methods of computation are used depending on the
value of @code{frame_bracket_form}. If true (the default):

@example

   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b

@end example

Or, if @code{false}:

@example

   c        c      e     d        d      e
ifb   = ifri   (ifr   ifr    - ifr    ifr  )
   ab       d      i     j,e      i,e    j

@end example

@end defvar


@c @node icc1
@c @unnumberedsec phony
@defvar icc1

Connection coefficients of the first kind (also known as Ricci rotation
coefficients.) In ITENSOR, defined as

@example

icc1    = ichr1    + ifc1    + ikt1    - inmc1
    abc        abc       abc       abc        abc

@end example

In this expression, if @code{itorsion_flag} is @code{false}, @code{ikt1}
will be omitted. Similarly, of @code{inonmet_flag} is @code{false},
@code{inmc1} will not be present.


@end defvar

@c @node icc2
@c @unnumberedsec phony
@defvar icc2

Connection coefficients of the first kind (also known as Ricci rotation
coefficients.) In ITENSOR, defined as

@example

    c         c        c        c         c
icc2   = ichr2   + ifc2   + ikt2   - inmc2
    ab        ab       ab       ab        ab

@end example

In this expression, if @code{itorsion_flag} is @code{false}, @code{ikt2}
will be omitted. Similarly, of @code{inonmet_flag} is @code{false},
@code{inmc2} will not be present.

@end defvar

@c @node ifc1
@c @unnumberedsec phony
@defvar ifc1

Frame coefficient of the first kind. This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind. Defined
as:

@example

                  d
ifc1    = g   ifc2
    abc    cd     ab

@end example

@end defvar

@c @node ifc2
@c @unnumberedsec phony
@defvar ifc2

Frame coefficient of the first kind. This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind. Defined
as a permutation of the frame bracket (@code{ifb}) with the appropriate
indices raised and lowered as necessary:

@example

          ce        d     ce        d       c
         g   g   ifb   - g   g   ifb   - ifb
    c         db    ae        ad    eb      ab
ifc2   = -------------------------------------
    ab                    2

@end example

@end defvar

@c @node ifr
@c @unnumberedsec phony
@defvar ifr

The frame field. Contracts with the inverse frame field (@code{ifri}) to
form the frame metric (@code{ifg}).

@end defvar

@c @node ifri
@c @unnumberedsec phony
@defvar ifri

The inverse frame field. Specifies the frame base (basis vectors). Along
with the frame metric, it forms the basis of all calculations based on
frames.

@end defvar

@c @node ifg
@c @unnumberedsec phony
@defvar ifg

The frame metric. Defaults to @code{kdelta}, but can be changed using
@code{components}.

@end defvar

@c @node ifgi
@c @unnumberedsec phony
@defvar ifgi

The inverse frame metric. Contracts with the frame metric (@code{ifg})
to @code{kdelta}.

@end defvar

@c @node iframe_bracket_form
@c @unnumberedsec phony
@defvar iframe_bracket_form

Specifies how the frame bracket (@code{ifb}) is computed. Default is
@code{true}.

@end defvar

@section Torsion

MAXIMA can now take into account torsion and nonmetricity. When the flag
@code{itorsion_flag} is set to @code{true}, the contribution of torsion
is added to the connection coefficients. Similarly, when the flag
@code{inonmet_flag} is true, nonmetricity components are included.
Note that in order for connection coefficients to be used, the flag
@code{iframe_flag} must also be set to @code{true}.


@c @node inm
@c @unnumberedsec phony
@defvar inm

The nonmetricity vector.

@end defvar


@c @node inmc1
@c @unnumberedsec phony
@defvar inmc1

Covariant permutation of the nonmetricity vector components. Defined as

@example

           g   inm  + inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

@end example

@end defvar

@c @node inmc2
@c @unnumberedsec phony
@defvar inmc2

Contravariant permutation of the nonmetricity vector components. Used
in the connection coefficients if @code{inonmet_flag} is @code{true}. Defined
as:

@example

                     c         c         cd
          inm  kdelta  - kdelta  inm  + g   inm  g
     c       a       b         a    b          d  ab
inmc2   = ------------------------------------------
     ab                       2

@end example

@end defvar

@c @node ikt1
@c @unnumberedsec phony
@defvar ikt1

Covariant permutation of the torsion tensor (also known as contorsion.)
Defined as:

@example

                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

@end example

@end defvar

@c @node ikt2
@c @unnumberedsec phony
@defvar ikt2

Contravariant permutation of the torsion tensor (also known as contorsion.)
Defined as:

@example

    c     cd
ikt2   = g   ikt1
    ab           abd

@end example

@end defvar

@c @node itr
@c @unnumberedsec phony
@defvar itr

The torsion tensor. For a metric with torsion, repeated covariant
differentiation on a scalar function will not commute, as demonstrated
by the following example:

@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;

(%o2)                                  g
(%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$

(%i4) ishow(%)$

                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);

(%o5)                                  0
(%i6) itorsion_flag:true;

(%o6)                                true
(%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$

(%i8) ishow(%)$

                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$

                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$

                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$

                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$

                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2


@end example

@end defvar

@section Interfacing with CTENSOR

The ITENSOR package has the ability to generate MAXIMA code that can
then be executed in the context of CTENSOR. The function that performs
this task is called @code{ic_convert()}.

@c @node ic_convert
@c @unnumberedsec phony
@defun ic_convert (eqn)

Converts the ITENSOR equation @code{eqn} to a CTENSOR assignment statement.
Implied sums over dummy indices are made explicit while indexed
objects are transformed into arrays (the array subscripts are in the
order of covariant followed by contravariant indices of the indexed
objects). The derivative of an indexed object will be replaced by the
noun form of @code{diff} taken with respect to @code{ct_coords} subscripted
by the derivative index. The Christoffel symbols @code{ichr1} and @code{ichr2}
will be translated to @code{lcs} and @code{mcs}, respectively and if
@code{metricconvert} is @code{true} then all occurrences of the metric
with two covariant (contravariant) indices will be renamed to @code{lg}
(@code{ug}). In addition, @code{do} loops will be introduced summing over
all free indices so that the
transformed assignment statement can be evaluated by just doing
@code{ev()}. The following examples demonstrate the features of this
function.



@example

(%i1) load(itensor);

(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$

                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);

(%o3) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);

(%o4)                                done
(%i5) metricconvert:true;

(%o5)                                true
(%i6) ic_convert(eqn);

(%o6) for i thru dim do (for j thru dim 

do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                       i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m



@end example

@end defun

@section Reserved Words

The following MAXIMA words are used by the ITENSOR package internally and
should not be redefined:

@example

  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices
  deri       Lists derivative indices
  name
  concan
  irpmon
  %c
  lc0

@end example

