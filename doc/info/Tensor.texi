@menu
* Introduction to ITENSOR::
* Definitions for ITENSOR::
@end menu

@node Introduction to Tensor, Definitions for Tensor, Tensor, Tensor
@section Introduction to Tensor

 - Indicial Tensor Manipulation package.  It may be loaded by
@code{load(itensor)}. Demos are also available: try @code{demo(itensor)}.

 - There are two tensor packages in Maxima, CTENSOR and
ITENSOR.  CTENSOR is Component Tensor Manipulation, and may be accessed
with @code{load(ctensor)}.

@c end concepts Tensor

@node Definitions for Tensor,  , Introduction to Tensor, Tensor

@section Managing Indexed Objects

@c @node entertensor
@c @unnumberedsec phony
@defun entertensor
*** TO BE WRITTEN ***
@end defun

@c @node changename
@c @unnumberedsec phony
@defun changename
*** TO BE WRITTEN ***
@end defun

@c @node listoftens
@c @unnumberedsec phony
@defun listoftens
*** TO BE WRITTEN ***
@end defun

@c @node ishow
@c @unnumberedsec phony
@defun ishow
*** TO BE WRITTEN ***
@end defun

@c @node indices
@c @unnumberedsec phony
@defun indices
*** TO BE WRITTEN ***
@end defun

@c @node rename
@c @unnumberedsec phony
@defun rename
*** TO BE WRITTEN ***
@end defun

@c @node defcon
@c @unnumberedsec phony
@defun defcon (tensor1,<tensor2,tensor3>)
gives @code{tensor1} the property that the
contraction of a product of @code{tensor1} and @code{tensor2} results in @code{tensor3}
with the appropriate indices.  If only one argument, @code{tensor1}, is
given, then the contraction of the product of tensor1 with any indexed
object having the appropriate indices (say @code{tensor}) will yield an
indexed object with that name, i.e. @code{tensor}, and with a new set of
indices reflecting the contractions performed.
    For example, if @code{imetric:g}, then @code{defcon(g)} will implement the
raising and lowering of indices through contraction with the metric
tensor.
    More than one @code{defcon} can be given for the same indexed object; the
latest one given which applies in a particular contraction will be
used.
@code{contractions} is a list of those indexed objects which have been given
contraction properties with @code{defcon}.

@end defun

@c @node remcon
@c @unnumberedsec phony
@defun remcon (tensor1,tensor2,...)
removes all the contraction properties
from the @code{tensori}.  @code{remcon(all)} removes all contraction properties from
all indexed objects.

@end defun

@c @node contract
@c @unnumberedsec phony
@defun contract (exp)
*** TO BE WRITTEN ***
@end defun

@c @node indexed_tensor
@c @unnumberedsec phony
@defun indexed_tensor
*** TO BE WRITTEN ***
@end defun

@c @node components
@c @unnumberedsec phony
@defun components
*** TO BE WRITTEN ***
@end defun

@c @node remcomps
@c @unnumberedsec phony
@defun remcomps
*** TO BE WRITTEN ***
@end defun

@c @node showcomps
@c @unnumberedsec phony
@defun showcomps
*** TO BE WRITTEN ***
@end defun

@c @node idummy
@c @unnumberedsec phony
@defun idummy ()
*** TO BE WRITTEN ***
@end defun

@c @node idummyx
@c @unnumberedsec phony
@defvar idummyx
*** TO BE WRITTEN ***
@end defvar

@c @node icounter
@c @unnumberedsec phony
@defvar icounter
 default: [1] determines the numerical suffix to be used in
generating the next dummy index in the tensor package.  The prefix is
determined by the option @node{idummy} (default: %).
@end defvar

@c @node kdelta
@c @unnumberedsec phony
@defun kdelta (l1,l2)
is the generalized Kronecker delta function defined in
the Tensor package with @code{l1} the list of covariant indices and @code{l2} the
list of contravariant indices.  @code{kdelta([i],[j])} returns the ordinary
Kronecker delta.  The command @code{ev(exp,kdelta)} causes the evaluation of
an expression containing @code{kdelta([],[])} to the dimension of the
manifold.

@end defun

@c @node kdels
@c @unnumberedsec phony
@defun kdels (l1,l2)
*** TO BE WRITTEN ***
@end defun

@c @node levi_civita
@c @unnumberedsec phony
@defun levi_civita (l)
is the permutation (or Levi-Civita) tensor which yields 1 if
the list @code{l} consists of an even permutation of integers, -1 if it
consists of an odd permutation, and 0 if some indices in @code{l} are
repeated.

@end defun

@c @node lc_l
@c @unnumberedsec phony
@defun lc_l
*** TO BE WRITTEN ***
@end defun

@c @node lc_u
@c @unnumberedsec phony
@defun lc_u
*** TO BE WRITTEN ***
@end defun

@c @node canten
@c @unnumberedsec phony
@defun canten (exp)
[Tensor Package] Simplifies exp by renaming (see @code{rename})
and permuting dummy indices. @code{rename} is restricted to sums of tensor
products in which no derivatives are present. As such it is limited
and should only be used if @code{canform} is not capable of carrying out the
required simplification.

@end defun

@section Tensor symmetries

@c @node decsym
@c @unnumberedsec phony
@defun decsym
*** TO BE WRITTEN ***
@end defun

@c @node remsym
@c @unnumberedsec phony
@defun remsym
*** TO BE WRITTEN ***
@end defun

@c @node canform
@c @unnumberedsec phony
@defun canform (exp)
[Tensor Package] Simplifies exp by renaming dummy
indices and reordering all indices as dictated by symmetry conditions
imposed on them. If @code{allsym} is @code{true} then all indices are assumed
symmetric, otherwise symmetry information provided by @code{decsym}
declarations will be used. The dummy indices are renamed in the same
manner as in the @code{rename} function. When @code{canform} is applied to a large
expression the calculation may take a considerable amount of time.
This time can be shortened by calling @code{rename} on the expression first.
Also see the example under @code{decsym}. Note: @code{canform} may not be able to
reduce an expression completely to its simplest form although it will
always return a mathematically correct result.
@end defun

@section Indicial tensor calculus


@c @node idiff
@c @unnumberedsec phony
@defun idiff
*** TO BE WRITTEN ***
@end defun

@c @node liediff
@c @unnumberedsec phony
@defun liediff
*** TO BE WRITTEN ***
@end defun

@c @node rediff
@c @unnumberedsec phony
@defun rediff
*** TO BE WRITTEN ***
@end defun

@c @node undiff
@c @unnumberedsec phony
@defun undiff
*** TO BE WRITTEN ***
@end defun

@c @node evundiff
@c @unnumberedsec phony
@defun evundiff
*** TO BE WRITTEN ***
@end defun

@c @node flush
@c @unnumberedsec phony
@defun flush (exp,tensor1,tensor2,...)
Tensor Package - will set to zero, in
exp, all occurrences of the @code{tensori} that have no derivative indices.

@end defun

@c @node flushd
@c @unnumberedsec phony
@defun flushd (exp,tensor1,tensor2,...)
Tensor Package - will set to zero, in
exp, all occurrences of the @code{tensori} that have derivative indices.

@end defun

@c @node flushnd
@c @unnumberedsec phony
@defun FLUSHND (exp,tensor,n)
Tensor Package - will set to zero, in exp, all
occurrences of the differentiated object tensor that have n or more
derivative indices as the following example demonstrates.
@example
(%i1) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s));
                               j r s      j r
(%o1)                         a        + a
                               i,k r s    I,k r
(%i2) ishow(flushnd(%o1,a,3));
                                     j r
(%o2)                               a
                                     i,k r


@end example
@end defun

@c @node coord
@c @unnumberedsec phony
@defun coord
*** TO BE WRITTEN ***
@end defun
@c @node remcoord
@c @unnumberedsec phony
@defun remcoord
*** TO BE WRITTEN ***
@end defun

@c @node makebox
@c @unnumberedsec phony
@defun makebox (exp)
will display exp in the same manner as SHOW; however,
any tensor d'Alembertian occurring in exp will be indicated using the
symbol [].  For example, @code{[]p([m],[n])} represents
@code{g([],[i,j])*p([m],[n],i,j)}.

@end defun

@c @node conmetderiv
@c @unnumberedsec phony
@defun conmetderiv
*** TO BE WRITTEN ***
@end defun
@c @node flush1deriv
@c @unnumberedsec phony
@defun flush1deriv
*** TO BE WRITTEN ***
@end defun

@section Tensors in curved spaces

@c @node imetric
@c @unnumberedsec phony
@defun imetric (g)
specifies the metric by assigning the variable @code{imetric:g} in
addition, the contraction properties of the metric G are set up by
executing the commands @code{defcon(g),defcon(g,g,kdelta)}.
The variable @code{imetric}, default: [], is bound to the metric, assigned by
the @code{imetric(g)} command.

@end defun

@c @node ichr1
@c @unnumberedsec phony
@defun ichr1 ([i,j,k])
yields the Christoffel symbol of the first kind via the
definition
@example
       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
@end example
@noindent
To evaluate the Christoffel symbols for a particular metric, the
variable @code{imetric} must be assigned a name as in the example under CHR2.

@end defun

@c @node ichr2
@c @unnumberedsec phony
@defun ichr2 ([i,j],[k])
yields the Christoffel symbol of the second kind
defined by the relation
@example
                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
@end example
@end defun

@c @node icurvature
@c @unnumberedsec phony
@defun icurvature ([i,j,k],[h])
Indicial Tensor Package) yields the Riemann
curvature tensor in terms of the Christoffel symbols of the second
kind (@code{ichr2}).  The following notation is used:
@example
               h             h            h         %1         h
     icurvature     = - ichr2      - ichr2     ichr2    + ichr2
               i j k         i k,j        %1 j      i k        i j,k
                               h          %1
                        + ichr2      ichr2
                               %1 k       i j
@end example
@end defun

@c @node covdiff
@c @unnumberedsec phony
@defun covdiff (exp,v1,v2,...)
yields the covariant derivative of exp with
respect to the variables vi in terms of the Christoffel symbols of the
second kind (@code{ichr2}).  In order to evaluate these, one should use
@code{ev(exp,ichr2)}.

@end defun

@c @node lorentz_gauge
@c @unnumberedsec phony
@defun lorentz_gauge (exp)
imposes the Lorentz condition by substituting 0 for all
indexed objects in exp that have a derivative index identical to a
contravariant index.

@end defun

@c @node igeodesic_coords
@c @unnumberedsec phony
@defun igeodesic_coords
*** TO BE WRITTEN ***
@end defun

@section Moving frames

ifb

icc1

icc2

ifc1

ifc2

ifr

ifri

@section Torsion


inmc1

inmc2

inm

ikt1

ikt2

itr


@section Interfacing with CTENsOR

ic_convert

@section Reserved Words

indices2

conti

covi

name

concan

deri

irpmon

%c

lc0

