@menu
* Introduction to Command Line::  
* Definitions for Command Line::  
@end menu

@node Introduction to Command Line, Definitions for Command Line, Command Line, Command Line
@section Introduction to Command Line

@deffn operator "'"
The @code{'} (single quote) operator has the effect of preventing evaluation.
E.g., @code{'(f(x))} means do not evaluate the expression @code{f(x)}.
@code{'f(x)} (with the single quote applied to @code{f} instead of @code{f(x)})
means return the noun form of @code{f} applied to @code{[x]}.

@end deffn

@deffn operator "'@w{}'"
The @code{'@w{}'} (double single quotes) operator causes an extra evaluation to occur.
E.g., @code{'@w{}'%i4} will re-evaluate input line @code{%i4}.
@code{'@w{}'(f(x))} means evaluate the expression @code{f(x)} an extra time.
@code{'@w{}'f(x)} (with the double single quotes applied to @code{f} instead of @code{f(x)})
means return the verb form of @code{f} applied to @code{[x]}.

@end deffn
@c end concepts Command Line
@node Definitions for Command Line,  , Introduction to Command Line, Command Line
@section Definitions for Command Line

@defun alias (newname1, oldname1, newname2, oldname2, ...)
provides an
alternate name for a (user or system) function, variable, array, etc.
Any even number of arguments may be used.

@end defun

@defvar debugmode
Default value: @code{false}

When a Maxima error occurs, Maxima will start the debugger if @code{debugmode} is @code{true}.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See @code{debugging} for a list of debugger commands.

Enabling @code{debugmode} will not catch Lisp errors.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvar

@defun ev (expr, arg_1, arg_2, arg_3, ...)
Evaluates the expression @code{expr} in the environment
specified by the arguments @code{arg_1}, @code{arg_2}, @code{arg_3}, ....
The arguments are switches (Boolean flags), assignments, equations, and functions.
@code{ev} returns the result (another expression) of the evaluation.

The evaluation is carried out in steps, as follows.

@enumerate
@item
First the environment is set up by scanning the arguments which may
be any or all of the following.

@itemize @bullet
@item
@code{simp} causes @code{expr} to be simplified regardless of the setting of the
switch @code{simp} which inhibits simplification if @code{false}.
@item
@code{noeval} supresses the evaluation phase of @code{ev} (see step (4) below).
This is useful in conjunction with the other switches and in causing
@code{expr} to be resimplified without being reevaluated.
@item
@code{expand} causes expansion.
@item
@code{expand (m, n)} causes expansion, setting the values of @code{maxposex} and
@code{maxnegex} to m and n respectively.
@item
@code{detout} causes any matrix inverses computed in @code{expr} to have their
determinant kept outside of the inverse rather than dividing through
each element.
@item
@code{diff} causes all differentiations indicated in @code{expr} to be performed.
@item
@code{derivlist (x, y, z, ...)} causes only differentiations with respect to
the indicated variables.
@item
@code{float} causes non-integral rational numbers to be converted to floating
point.
@item
@code{numer} causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point.  It causes
variables in @code{expr} which have been given numervals to be replaced by
their values.  It also sets the @code{float} switch on.
@item
@code{pred} causes predicates (expressions which evaluate to @code{true} or @code{false})
to be evaluated.
@item
@code{eval} causes an extra post-evaluation of @code{expr} to occur. (See step (5)
below.)
@item
@code{A} where @code{A} is an atom declared to be an evaluation flag (see @code{evflag})
causes @code{A} to be bound to
@code{true} during the evaluation of @code{expr}.
@item
@code{V: expression} (or alternately @code{V=expression}) causes @code{V} to be bound to the
value of @code{expression} during the evaluation of @code{expr}.  Note that if @code{V} is a
Maxima option, then @code{expression} is used for its value during the
evaluation of @code{expr}.  If more than one argument to @code{ev} is of this type
then the binding is done in parallel.  If @code{V} is a non-atomic expression
then a substitution rather than a binding is performed.
@item
@code{F} where @code{F}, a function name, has been declared to be an evaluation function (see @code{evfun})
causes @code{F}
to be applied to @code{expr}.
@item
Any other function names (e.g., @code{sum}) cause evaluation of occurrences
of those names in @code{expr} as though they were verbs.
@item
In addition a function occurring in @code{expr} (say @code{F(x)}) may be defined
locally for the purpose of this evaluation of @code{expr} by giving
@code{F(x) := expression} as an argument to @code{ev}.
@item
If an atom not mentioned above or a subscripted variable or
subscripted expression was given as an argument, it is evaluated and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to @code{ev}. This permits a list of equations to be given (e.g. @code{[X=1, Y=A**2]})
or a list of names of equations (e.g., @code{[%t1, %t2]} where @code{%t1} and
@code{%t2} are equations) such as that returned by @code{solve}.
@end itemize

The arguments of @code{ev} may be given in any order with the exception of
substitution equations which are handled in sequence, left to right,
and evaluation functions which are composed, e.g., @code{ev (expr, ratsimp, realpart)} is
handled as @code{realpart (ratsimp (expr))}.

The @code{simp}, @code{numer}, @code{float}, and @code{pred} switches may also be set locally in a
block, or globally in Maxima so that they will
remain in effect until being reset.

If @code{expr} is a canonical rational expression (CRE),
then the expression returned by @code{ev} is also a CRE,
provided the @code{numer} and @code{float} switches are not both @code{true}.

@item
During step (1), a list is made of the non-subscripted
variables appearing on the left side of equations in the arguments or in
the value of some arguments if the value is an equation.  The variables
(subscripted variables which do not have associated array
functions as well as non-subscripted variables) in the expression @code{expr} are
replaced by their global values, except for those appearing in this
list.  Usually, @code{expr} is just a label or @code{%}
(as in @code{%i2} in the example below), so this
step simply retrieves the expression named by the label, so that @code{ev}
may work on it.

@item
If any substitutions are indicated by the arguments, they are
carried out now.

@item
The resulting expression is then re-evaluated (unless one of
the arguments was @code{noeval}) and simplified according to the arguments.  Note that
any function calls in @code{expr} will be carried out after the variables in
it are evaluated and that @code{ev(F(x))} thus may behave like @code{F(ev(x))}.

@item
If one of the arguments was @code{eval}, steps (3) and (4) are repeated.
@end enumerate

                     Examples

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

An alternate top level syntax has been provided for @code{ev}, whereby one
may just type in its arguments, without the @code{ev()}.  That is, one may
write simply

@example
expr, arg_1, arg_2, arg_3, ...
@end example

This is not permitted as part of
another expression, e.g., in functions, blocks, etc.

Notice the parallel binding process in the following example.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end defun

@defvr property evflag
Some Boolean flags have the @code{evflag} property.
@code{ev} treats such flags specially.
A flag with the @code{evflag} property will be bound to @code{true}
during the execution of @code{ev} if it is
mentioned in the call to @code{ev}.
For example, @code{demoivre} and @code{ratfac} are bound to @code{true}
during the call @code{ev (%, demoivre, ratfac)}.

The flags which have the @code{evflag} property are:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, and
@code{trigexpand}.

The construct @code{:lisp (putprop '|$foo| t 'evflag)}
gives the @code{evflag} property to the variable @code{foo},
so @code{foo} is bound to @code{true} during the call @code{ev (%, foo)}.
Equivalently, @code{ev (%, foo:true)} has the same effect.

@end defvr

@defvr property evfun
Some functions have the @code{evfun} property.
@code{ev} treats such functions specially.
A function with the @code{evfun} property will be applied
during the execution of @code{ev} if it is
mentioned in the call to @code{ev}.
For example, @code{ratsimp} and @code{radcan} will be applied
during the call @code{ev (%, ratsimp, radcan)}.

The functions which have the @code{evfun} property are:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

The construct @code{:lisp (putprop '|$foo| t 'evfun)}
gives the @code{evfun} property to the function @code{foo},
so that @code{foo} is applied during the call @code{ev (%, foo)}.
Equivalently, @code{foo (ev (%))} has the same effect.

@end defvr

@defvr {special symbol} infeval
 leads to an "infinite evaluation" mode.  @code{ev} repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say @code{X}, from being evaluated away in this mode, simply
include @code{X='X} as an argument to @code{ev}.  Of course expressions such as
@code{ev (X, X=X+1, infeval)} will generate an infinite loop. @i{Caveat evaluator.}

@end defvr

@defun kill (symbol_1, symbol_2, symbol_3, ...)
@defunx kill (labels)
@defunx kill (clabels, dlabels, elabels)
@defunx kill (n)
@defunx kill ([m, n])
@defunx kill (values, functions, arrays, ...)
@defunx kill (all)
@defunx kill (allbut (symbol_1, symbol_2, symbol_3, ...))

Removes all bindings (value, function, array, or rule) from the arguments
@code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
An argument may be a single array element or subscripted function.

@code{kill} always returns @code{done}, even if an argument has no binding.

Several special arguments are recognized. 
Different kinds of arguments
may be combined, e.g., @code{kill (clabels, functions, allbut (foo, bar))}.

The special form @code{kill (labels)} unbinds
all input, output, and intermediate expression labels created so far.
@code{kill (clabels)} unbinds only input labels
which begin with the current value of @code{inchar}.
Likewise,
@code{kill (dlabels)} unbinds only output labels
which begin with the current value of @code{outchar},
and @code{kill (elabels)} unbinds only intermediate expression labels
which begin with the current value of @code{linechar}.

The special form @code{kill (n)}, where @code{n} is an integer,
unbinds the @code{n} most recent input and output labels.
The special form @code{kill ([m, n])} unbinds input and output labels @code{m} through @code{n}.

The special form @code{kill (infolist)}, where @code{infolist} is any item in @code{infolists}
(such as @code{values}, @code{functions}, or @code{arrays})
unbinds all items in @code{infolist}.
See also @code{infolists}.

The special form @code{kill (all)} unbinds all items on all infolists.

The special form @code{kill (allbut (symbol_1, symbol_2, symbol_3, ...))}
unbinds all items on all infolists except for @code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
@code{kill (allbut (infolist))} unbinds all items except for the ones on @code{infolist},
where @code{infolist} is @code{values}, @code{functions}, @code{arrays}, etc.

The memory taken up by a bound property is not released until all symbols
are unbound from it.
In particular, to release the memory taken up by the value of a symbol,
one unbinds the output label which shows the bound value, as well as unbinding the symbol itself.

@code{kill} quotes its arguments.
The double single quotes operator, @code{'@w{}'}, defeats the quotation.

@code{kill (symbol)} unbinds all properties of @code{symbol}.
In contrast, @code{remvalue}, @code{remfunction}, @code{remarray}, and @code{remrule}
unbind a specific property.
Those functions also differ in that they return a list of the symbols or @code{false}.

@end defun

@defun labels (symbol)
@defunx labels
Returns the list of input, output, or intermediate expression labels which begin with @code{symbol}.
Typically @code{symbol} is the value of @code{inchar}, @code{outchar}, or @code{linechar}.
The label character may be given with or without a percent sign,
so, for example, @code{i} and @code{%i} yield the same result.

If no labels begin with @code{symbol}, @code{labels} returns an empty list.

The function @code{labels} quotes its argument.
The double single quotes operator @code{'@w{}'} defeats the quotation.
For example,
@code{labels (''inchar)} returns the input labels which begin with the current input label character.

The variable @code{labels} is the list of input, output, and intermediate expression labels,
including all previous labels if @code{inchar}, @code{outchar}, or @code{linechar} were redefined.

By default, Maxima displays the result of each user input expression,
giving the result an output label.
The output display is suppressed by terminating the input with @code{$} (dollar sign)
instead of @code{;} (semicolon).
An output label is generated, but not displayed, 
and the label may be referenced in the same way as displayed output labels.
See also @code{%}, @code{%%}, and @code{%th}.

Intermediate expression labels can be generated by some functions.
The flag @code{programmode} controls whether @code{solve} and some other functions
generate intermediate expression labels instead of returning a list of expressions.
Some other functions, such as @code{ldisplay}, always generate intermediate expression labels.

@c NEED TO EXPLAIN THIS SHORTCUT ???
@code{first (rest (labels (''inchar)))} returns the most recent input label.

See also @code{inchar}, @code{outchar}, @code{linechar}, and @code{infolists}.

@end defun

@defvar linenum
 - the line number of the last expression.

@end defvar

@defvar myoptions
 default: [] - all options ever reset by the user (whether
or not they get reset to their default value).

@end defvar

@c THIS DESCRIPTION IS AT ODDS WITH OBSERVED BEHAVIOR: !!!
@c WHEN nolabels IS TRUE, LABELS ARE CREATED AND DISPLAYED BUT NOT PUT INTO THE labels LIST !!!
@c kill (labels) THEN KILLS THE ONES ON THE LIST BUT NOT ANY CREATED AFTER nolabels: true !!!
@defvar nolabels
 default: @code{false} - if @code{true} then no labels will be bound
except for E lines generated by the solve functions.  This is most
useful in the batch mode where it eliminates the need to do
@code{kill (labels)} in order to free up storage.
See also @code{batch}, @code{batchload}, and @code{labels}.
@c PUT A CROSS REFERENCE IN DESCRIPTION OF labels WHEN STRANGE BEHAVIOR OF nolabels IS CLEARED UP !!!

@end defvar

@defvar optionset
 default: @code{false} - if @code{true}, Maxima will print out a
message whenever a Maxima option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

@end defvar

@defun playback ()
@defunx playback (n)
@defunx playback ([m], [m, n])
@defunx playback (input)
@defunx playback (slow)
@defunx playback (time)
@defunx playback (string, grind)
Displays input, output, and intermediate expressions,
without recomputing them.
@code{playback} only displays the expressions bound to labels;
any other output (such as text printed by @code{describe}, or error messages)
is not displayed.
See also @code{labels}.

@code{playback} quotes its arguments.
The double single quotes operator, @code{'@w{}'}, defeats the quotation.
@code{playback} always returns @code{done}.

@code{playback ()} (with no arguments) displays all input, output, and intermediate expressions
generated so far.

@code{playback (n)} displays the most recent @code{n} expressions.
Each input, output, and intermediate expression counts as one.

@code{playback ([m, n])} displays input, output, and intermediate expressions
with numbers from @code{m} through @code{n}, inclusive.
@code{playback ([m])} is equivalent to @code{playback ([m, m])};
this usually prints one pair of input and output expressions.

@code{playback (input)} displays all input expressions generated so far.

@code{playback (slow)} pauses between expressions
and waits for the user to press @code{enter}.
This behavior is similar to @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} is useful in conjunction with @code{save} or @code{stringout}
when creating a secondary-storage file in order to pick out useful expressions.

@code{playback (time)} displays the computation time for each expression.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (string)} displays expressions in @code{string} mode.
@code{playback (grind)} displays expressions in @code{grind} mode.
See @code{string} and @code{grind}.

Arguments may be combined, e.g., 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@end defun

@defun printprops (a, i)
will display the property with the indicator @code{i}
associated with the atom @code{a}. @code{a} may also be a list of atoms or the atom
@code{all} in which case all of the atoms with the given property will be
used.  For example, @code{printprops ([f, g], atvalue)}.  @code{printprops} is for
properties that cannot otherwise be displayed, i.e. for
@code{atvalue}, @code{atomgrad}, @code{gradef}, and @code{matchdeclare}.

@end defun

@defvar prompt
Default value: @code{_}

@code{prompt} is the prompt symbol of the @code{demo} function,
@code{playback (slow)} mode, and the Maxima break loop (as invoked by @code{break}).

@end defvar

@defun quit ()
Terminates the Maxima session.
Note that the function must be invoked as @code{quit();} or @code{quit()$},
not @code{quit} by itself.

To stop a lengthy computation,
type @code{control-C}.
The default action is to return to the Maxima prompt.
If @code{*debugger-hook*} is @code{nil},
@code{control-C} opens the Lisp debugger.
See also @code{debugging}.

@end defun

@defun remfunction (f1, f2, f3, ...)
@defunx remfunction (all)
@c REPHRASE THIS TO SAY "UNBIND" OR SOMETHING OTHER THAN "REMOVE" (LATTER IS AMBIGUOUS) !!!
Removes the user defined functions @code{f1}, @code{f2}, @code{f3}, ... from Maxima.
@code{remfunction (all)} removes all functions.

@end defun

@defun reset ()
causes all Maxima options to be set to their default values.
(Please note that this does not include features of terminals such as
@code{linel} which can only be changed by assignment as they are not
considered to be computational features of Maxima.)

@end defun

@defvar showtime
Default value: @code{false}

@c FOLLOWING DISCUSSION OF GC TIME IS ALMOST CERTAINLY OUT OF DATE !!!
When @code{showtime} is @code{true}, the computation time will be
printed automatically with each output expression.  By setting
@code{showtime: all}, in addition to the cpu time Maxima now also prints out
(when not zero) the amount of time spent in garbage collection (gc) in
the course of a computation.  This time is of course included in the
time printed out as "time=" .  (It should be noted that since the
"time=" time only includes computation time and not any intermediate
display time or time it takes to load in out-of-core files, and since
it is difficult to ascribe "responsibility" for gc's, the gctime
printed will include all gctime incurred in the course of the
computation and hence may in rare cases even be larger than "time=").

@end defvar

@defun sstatus (feature, package)
Sets the status of @code{feature} in @code{package}.
After @code{sstatus (feature, hack_package)} is executed,
@code{status (feature, hack_package)} returns @code{true}.
This can be useful for package writers, to
keep track of what features they have loaded in.

@end defun

@defun to_lisp ()
Enters the Lisp system under Maxima.

@end defun

@defvar values
Initial value: @code{[]}

@code{values} is a list of all bound user variables (not Maxima options or switches).
The list comprises symbols bound by @code{:} , @code{::}, or @code{:=}.

@end defvar
