@menu
* Introduction to Command Line::  
* Definitions for Command Line::  
@end menu

@node Introduction to Command Line, Definitions for Command Line, Command Line, Command Line
@section Introduction to Command Line

@deffn operator "'"
  - (single quote) has the effect of preventing evaluation.  E.g.
'(F(X)) means do not evaluate the expression F(X).  'F(X) means
return the noun form of F applied to [X].

@end deffn

@deffn operator "'@w{}'"
  - (two single quotes) causes an extra evaluation to occur.  E.g.
'@w{}'%i4; will re-execute line %i4.  '@w{}'(F(X)) means evaluate the
expression F(X) an extra time.  '@w{}'F(X) means return the verb form of F
applied to [X].

@end deffn
@c end concepts Command Line
@node Definitions for Command Line,  , Introduction to Command Line, Command Line
@section Definitions for Command Line

@defun ALIAS (newname1, oldname1, newname2, oldname2, ...)
provides an
alternate name for a (user or system) function, variable, array, etc.
Any even number of arguments may be used.

@end defun

@defvar DEBUGMODE
Default value: FALSE

When a Maxima error occurs, Maxima will start the debugger if DEBUGMODE is TRUE.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See DEBUGGING for a list of debugger commands.

Enabling DEBUGMODE will not catch Lisp errors.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvar

@defun ev (expr, arg_1, arg_2, arg_3, ...)
Evaluates the expression @code{expr} in the environment
specified by the arguments @code{arg_1}, @code{arg_2}, @code{arg_3}, ....
The arguments are switches (Boolean flags), assignments, equations, and functions.
@code{ev} returns the result (another expression) of the evaluation.

The evaluation is carried out in steps, as follows.

@enumerate
@item
First the environment is set up by scanning the arguments which may
be any or all of the following.

@itemize @bullet
@item
@code{simp} causes @code{expr} to be simplified regardless of the setting of the
switch @code{simp} which inhibits simplification if @code{false}.
@item
@code{noeval} supresses the evaluation phase of @code{ev} (see step (4) below).
This is useful in conjunction with the other switches and in causing
@code{expr} to be resimplified without being reevaluated.
@item
@code{expand} causes expansion.
@item
@code{expand (m, n)} causes expansion, setting the values of @code{maxposex} and
@code{maxnegex} to m and n respectively.
@item
@code{detout} causes any matrix inverses computed in @code{expr} to have their
determinant kept outside of the inverse rather than dividing through
each element.
@item
@code{diff} causes all differentiations indicated in @code{expr} to be performed.
@item
@code{derivlist (x, y, z, ...)} causes only differentiations with respect to
the indicated variables.
@item
@code{float} causes non-integral rational numbers to be converted to floating
point.
@item
@code{numer} causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point.  It causes
variables in @code{expr} which have been given numervals to be replaced by
their values.  It also sets the @code{float} switch on.
@item
@code{pred} causes predicates (expressions which evaluate to @code{true} or @code{false})
to be evaluated.
@item
@code{eval} causes an extra post-evaluation of @code{expr} to occur. (See step (5)
below.)
@item
@code{A} where @code{A} is an atom declared to be an evaluation flag (see @code{evflag})
causes @code{A} to be bound to
@code{true} during the evaluation of @code{expr}.
@item
@code{V: expression} (or alternately @code{V=expression}) causes @code{V} to be bound to the
value of @code{expression} during the evaluation of @code{expr}.  Note that if @code{V} is a
Maxima option, then @code{expression} is used for its value during the
evaluation of @code{expr}.  If more than one argument to @code{ev} is of this type
then the binding is done in parallel.  If @code{V} is a non-atomic expression
then a substitution rather than a binding is performed.
@item
@code{F} where @code{F}, a function name, has been declared to be an evaluation function (see @code{evfun})
causes @code{F}
to be applied to @code{expr}.
@item
Any other function names (e.g., @code{sum}) cause evaluation of occurrences
of those names in @code{expr} as though they were verbs.
@item
In addition a function occurring in @code{expr} (say @code{F(x)}) may be defined
locally for the purpose of this evaluation of @code{expr} by giving
@code{F(x) := expression} as an argument to @code{ev}.
@item
If an atom not mentioned above or a subscripted variable or
subscripted expression was given as an argument, it is evaluated and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to @code{ev}. This permits a list of equations to be given (e.g. @code{[X=1, Y=A**2]})
or a list of names of equations (e.g., @code{[%t1, %t2]} where @code{%t1} and
@code{%t2} are equations) such as that returned by @code{solve}.
@end itemize

The arguments of @code{ev} may be given in any order with the exception of
substitution equations which are handled in sequence, left to right,
and evaluation functions which are composed, e.g., @code{ev (expr, ratsimp, realpart)} is
handled as @code{realpart (ratsimp (expr))}.

The @code{simp}, @code{numer}, @code{float}, and @code{pred} switches may also be set locally in a
block, or globally in Maxima so that they will
remain in effect until being reset.

If @code{expr} is a canonical rational expression (CRE),
then the expression returned by @code{ev} is also a CRE,
provided the @code{numer} and @code{float} switches are not both @code{true}.

@item
During step (1), a list is made of the non-subscripted
variables appearing on the left side of equations in the arguments or in
the value of some arguments if the value is an equation.  The variables
(subscripted variables which do not have associated array
functions as well as non-subscripted variables) in the expression @code{expr} are
replaced by their global values, except for those appearing in this
list.  Usually, @code{expr} is just a label or @code{%}
(as in @code{%i2} in the example below), so this
step simply retrieves the expression named by the label, so that @code{ev}
may work on it.

@item
If any substitutions are indicated by the arguments, they are
carried out now.

@item
The resulting expression is then re-evaluated (unless one of
the arguments was @code{noeval}) and simplified according to the arguments.  Note that
any function calls in @code{expr} will be carried out after the variables in
it are evaluated and that @code{ev(F(x))} thus may behave like @code{F(ev(x))}.

@item
If one of the arguments was @code{eval}, steps (3) and (4) are repeated.
@end enumerate

                     Examples

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

An alternate top level syntax has been provided for @code{ev}, whereby one
may just type in its arguments, without the @code{ev()}.  That is, one may
write simply

@example
expr, arg_1, arg_2, arg_3, ...
@end example

This is not permitted as part of
another expression, e.g., in functions, blocks, etc.

Notice the parallel binding process in the following example.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end defun

@defvr property evflag
Some Boolean flags have the @code{evflag} property.
@code{ev} treats such flags specially.
A flag with the @code{evflag} property will be bound to @code{true}
during the execution of @code{ev} if it is
mentioned in the call to @code{ev}.
For example, @code{demoivre} and @code{ratfac} are bound to @code{true}
during the call @code{ev (%, demoivre, ratfac)}.

The flags which have the @code{evflag} property are:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, and
@code{trigexpand}.

The construct @code{:lisp (putprop '|$foo| t 'evflag)}
gives the @code{evflag} property to the variable @code{foo},
so @code{foo} is bound to @code{true} during the call @code{ev (%, foo)}.
Equivalently, @code{ev (%, foo:true)} has the same effect.

@end defvr

@defvr property evfun
Some functions have the @code{evfun} property.
@code{ev} treats such functions specially.
A function with the @code{evfun} property will be applied
during the execution of @code{ev} if it is
mentioned in the call to @code{ev}.
For example, @code{ratsimp} and @code{radcan} will be applied
during the call @code{ev (%, ratsimp, radcan)}.

The functions which have the @code{evfun} property are:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

The construct @code{:lisp (putprop '|$foo| t 'evfun)}
gives the @code{evfun} property to the function @code{foo},
so that @code{foo} is applied during the call @code{ev (%, foo)}.
Equivalently, @code{foo (ev (%))} has the same effect.

@end defvr

@defvr {special symbol} INFEVAL
 leads to an "infinite evaluation" mode.  EV repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say X, from being evaluated away in this mode, simply
include X='X as an argument to EV.  Of course expressions such as
EV(X,X=X+1,INFEVAL); will generate an infinite loop.  CAVEAT
EVALUATOR.

@end defvr

@defun kill (symbol_1, symbol_2, symbol_3, ...)
@defunx kill (labels)
@defunx kill (clabels, dlabels, elabels)
@defunx kill (n)
@defunx kill ([m, n])
@defunx kill (values, functions, arrays, ...)
@defunx kill (all)
@defunx kill (allbut (symbol_1, symbol_2, symbol_3, ...))

Removes all bindings (value, function, array, or rule) from the arguments
@code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
An argument may be a single array element or subscripted function.

@code{kill} always returns @code{done}, even if an argument has no binding.

Several special arguments are recognized. 
Different kinds of arguments
may be combined, e.g., @code{kill (clabels, functions, allbut (foo, bar))}.

The special form @code{kill (labels)} unbinds
all input, output, and intermediate expression labels created so far.
@code{kill (clabels)} unbinds only input labels
which begin with the current value of @code{inchar}.
Likewise,
@code{kill (dlabels)} unbinds only output labels
which begin with the current value of @code{outchar},
and @code{kill (elabels)} unbinds only intermediate expression labels
which begin with the current value of @code{linechar}.

The special form @code{kill (n)}, where @code{n} is an integer,
unbinds the @code{n} most recent input and output labels.
The special form @code{kill ([m, n])} unbinds input and output labels @code{m} through @code{n}.

The special form @code{kill (infolist)}, where @code{infolist} is any item in @code{infolists}
(such as @code{values}, @code{functions}, or @code{arrays})
unbinds all items in @code{infolist}.
See also @code{infolists}.

The special form @code{kill (all)} unbinds all items on all infolists.

The special form @code{kill (allbut (symbol_1, symbol_2, symbol_3, ...))}
unbinds all items on all infolists except for @code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
@code{kill (allbut (infolist))} unbinds all items except for the ones on @code{infolist},
where @code{infolist} is @code{values}, @code{functions}, @code{arrays}, etc.

The memory taken up by a bound property is not released until all symbols
are unbound from it.
In particular, to release the memory taken up by the value of a symbol,
one unbinds the output label which shows the bound value, as well as unbinding the symbol itself.

@code{kill} quotes its arguments.
The double-quote operator, @code{'@w{}'}, defeats the quotation.

@code{kill (symbol)} unbinds all properties of @code{symbol}.
In contrast, @code{remvalue}, @code{remfunction}, @code{remarray}, and @code{remrule}
unbind a specific property.
Those functions also differ in that they return a list of the symbols or @code{false}.

@end defun

@defun labels (symbol)
@defunx labels
Returns the list of input, output, or intermediate expression labels which begin with @code{symbol}.
Typically @code{symbol} is the value of @code{inchar}, @code{outchar}, or @code{linechar}.
The label character may be given with or without a percent sign,
so, for example, @code{i} and @code{%i} yield the same result.

If no labels begin with @code{symbol}, @code{labels} returns an empty list.

The function @code{labels} quotes its argument.
The double-quote operator @code{'@w{}'} defeats the quotation.
For example,
@code{labels (''inchar)} returns the input labels which begin with the current input label character.

The variable @code{labels} is the list of input, output, and intermediate expression labels,
including all previous labels if @code{inchar}, @code{outchar}, or @code{linechar} were redefined.

Intermediate expression labels can be generated by some functions.
The flag @code{programmode} controls whether @code{solve} and some other functions
generate intermediate expression labels instead of returning a list of expressions.
Some other functions, such as @code{ldisplay}, always generate intermediate expression labels.

@c NEED TO EXPLAIN THIS SHORTCUT ???
@code{first (rest (labels (''inchar)))} returns the most recent input label.

See also @code{inchar}, @code{outchar}, @code{linechar}, and @code{infolists}.

@end defun

@defvar LINENUM
 - the line number of the last expression.

@end defvar

@defvar MYOPTIONS
 default: [] - all options ever reset by the user (whether
or not they get reset to their default value).

@end defvar

@defvar NOLABELS
 default: [FALSE] - if TRUE then no labels will be bound
except for E lines generated by the solve functions.  This is most
useful in the "BATCH" mode where it eliminates the need to do
KILL(LABELS) in order to free up storage.

@end defvar

@defvar OPTIONSET
 default: [FALSE] - if TRUE, Maxima will print out a
message whenever a Maxima option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

@end defvar

@defun PLAYBACK (arg)
"plays back" input and output lines.  If arg=n (a
number) the last n expressions (Ci, Di, and Ei count as 1 each) are
"played-back", while if arg is omitted, all lines are.  If arg=INPUT
then only input lines are played back. If arg=[m,n] then all lines
with numbers from m to n inclusive are played-back.  If m=n then [m]
is sufficient for arg.  Arg=SLOW places PLAYBACK in a slow-mode
similar to DEMO's (as opposed to the "fast" BATCH).  This is useful in
conjunction with SAVE or STRINGOUT when creating a secondary-storage
file in order to pick out useful expressions.  If arg=TIME then the
computation times are displayed as well as the expressions.  If
arg=GCTIME or TOTALTIME, then a complete breakdown of computation
times are displayed, as with SHOWTIME:ALL;.  Arg=STRING strings-out
(see STRING function) all input lines when playing back rather than
displaying them.  If ARG=GRIND "grind" mode can also be turned on (for
processing input lines) (see GRIND).  One may include any number of
options as in PLAYBACK([5,10],20,TIME,SLOW).

@end defun

@defun PRINTPROPS (a, i)
will display the property with the indicator i
associated with the atom a. a may also be a list of atoms or the atom
ALL in which case all of the atoms with the given property will be
used.  For example, PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is for
properties that cannot otherwise be displayed, i.e. for
ATVALUE, ATOMGRAD, GRADEF, and MATCHDECLARE.

@end defun

@defvar PROMPT
 default: [_] is the prompt symbol of the DEMO function,
PLAYBACK(SLOW) mode, and the Maxima break loop (as invoked by BREAK).

@end defvar

@defun QUIT ()
kills the current Maxima but doesn't affect the user's other
jobs;  equivalent to exiting to DCL and stopping the Maxima process.
One may "quit" to Maxima top-level by typing Control-C Control-G;
Control-C gets NIL's interrupt prompt, at which one types either
Control-G or just G.  Typing X at the Interrupt prompt will cause a
quit in a computation started within a Maxima break without disrupting
the suspended main computation.

@end defun

@defun REMFUNCTION (f1, f2, ...)
removes the user defined functions
f1,f2,... from Maxima.  If there is only one argument of ALL then all
functions are removed.

@end defun

@defun RESET ()
causes all Maxima options to be set to their default values.
(Please note that this does not include features of terminals such as
LINEL which can only be changed by assignment as they are not
considered to be computational features of Maxima.)

@end defun

@defvar SHOWTIME
 default: [FALSE] - if TRUE then the computation time will be
printed automatically with each output expression.  By setting
SHOWTIME:ALL, in addition to the cpu time Maxima now also prints out
(when not zero) the amount of time spent in garbage collection (gc) in
the course of a computation.  This time is of course included in the
time printed out as "time=" .  (It should be noted that since the
"time=" time only includes computation time and not any intermediate
display time or time it takes to load in out-of-core files, and since
it is difficult to ascribe "responsibility" for gc's, the gctime
printed will include all gctime incurred in the course of the
computation and hence may in rare cases even be larger than "time=").

@end defvar

@defun SSTATUS (feature,package)
- meaning SET STATUS.  It can be used to
SSTATUS( FEATURE, HACK_PACKAGE) so that STATUS( FEATURE, HACK_PACKAGE)
will then return TRUE.  This can be useful for package writers, to
keep track of what FEATURES they have loaded in.

@end defun

@defun TO_LISP ()
enters the Lisp system under Maxima.  This is useful on
those systems where control-uparrow is not available for this
function.

@end defun

@defvar VALUES
 default:[] - all bound atoms, i.e. user variables, not Maxima
Options or Switches, (set up by : , :: , or functional binding).

@end defvar
