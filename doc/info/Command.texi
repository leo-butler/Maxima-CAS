@menu
* Introduction to Command Line::  
* Definitions for Command Line::  
@end menu

@node Introduction to Command Line, Definitions for Command Line, Command Line, Command Line
@section Introduction to Command Line

@deffn operator "'"
  - (single quote) has the effect of preventing evaluation.  E.g.
'(F(X)) means do not evaluate the expression F(X).  'F(X) means
return the noun form of F applied to [X].

@end deffn

@deffn operator "'@w{}'"
  - (two single quotes) causes an extra evaluation to occur.  E.g.
'@w{}'%i4; will re-execute line %i4.  '@w{}'(F(X)) means evaluate the
expression F(X) an extra time.  '@w{}'F(X) means return the verb form of F
applied to [X].

@end deffn
@c end concepts Command Line
@node Definitions for Command Line,  , Introduction to Command Line, Command Line
@section Definitions for Command Line

@defun ALIAS (newname1, oldname1, newname2, oldname2, ...)
provides an
alternate name for a (user or system) function, variable, array, etc.
Any even number of arguments may be used.

@end defun

@defvar DEBUGMODE
Default value: FALSE

When a Maxima error occurs, Maxima will start the debugger if DEBUGMODE is TRUE.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See DEBUGGING for a list of debugger commands.

Enabling DEBUGMODE will not catch Lisp errors.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvar

@defun EV (exp, arg1, ..., argn)
is one of Maxima's most powerful and
versatile commands. It evaluates the expression exp in the environment
specified by the argi.  This is done in steps, as follows:
@itemize @bullet
@item
    (1) First the environment is set up by scanning the argi which may
be as follows:
SIMP causes exp to be simplified regardless of the setting of the
switch SIMP which inhibits simplification if FALSE.
NOEVAL supresses the evaluation phase of EV (see step (4) below).
This is useful in conjunction with the other switches and in causing
exp to be resimplified without being reevaluated.
EXPAND causes expansion.
EXPAND(m,n) causes expansion, setting the values of MAXPOSEX and
MAXNEGEX to m and n respectively.
DETOUT causes any matrix inverses computed in exp to have their
determinant kept outside of the inverse rather than dividing through
each element.
DIFF causes all differentiations indicated in exp to be performed.
DERIVLIST(var1,...,vark) causes only differentiations with respect to
the indicated variables.
FLOAT causes non-integral rational numbers to be converted to floating
point.
NUMER causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point.  It causes
variables in exp which have been given numervals to be replaced by
their values.  It also sets the FLOAT switch on.
PRED causes predicates (expressions which evaluate to TRUE or FALSE)
to be evaluated.
EVAL causes an extra post-evaluation of exp to occur. (See step (5)
below.)
E where E is an atom declared to be an EVFLAG causes E to be bound to
TRUE during the evaluation of exp.
V:expression (or alternately V=expression) causes V to be bound to the
value of expression during the evaluation of exp.  Note that if V is a
Maxima option, then expression is used for its value during the
evaluation of exp.  If more than one argument to EV is of this type
then the binding is done in parallel.  If V is a non-atomic expression
then a substitution rather than a binding is performed.
E where E, a function name, has been declared to be an EVFUN causes E
to be applied to exp.
Any other function names (e.g.  SUM) cause evaluation of occurrences
of those names in exp as though they were verbs.
In addition a function occurring in exp (say F(args)) may be defined
locally for the purpose of this evaluation of exp by giving
F(args):=body as an argument to EV.
If an atom not mentioned above or a subscripted variable or
subscripted expression was given as an argument, it is evaluated and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to EV. This permits a list of equations to be given (e.g. [X=1,
Y=A**2] ) or a list of names of equations (e.g.  [%t1,%t2] where %t1 and
E2 are equations) such as that returned by SOLVE.
The argi of EV may be given in any order with the exception of
substitution equations which are handled in sequence, left to right,
and EVFUNS which are composed, e.g. EV(exp,RATSIMP,REALPART) is
handled as REALPART(RATSIMP(exp)).
The SIMP, NUMER, FLOAT, and PRED switches may also be set locally in a
block, or globally at the "top level" in Maxima so that they will
remain in effect until being reset.
If exp is in CRE form then EV will return a result in CRE form
provided the NUMER and FLOAT switches are not both TRUE.

@item
    (2) During step (1), a list is made of the non-subscripted
variables appearing on the left side of equations in the argi or in
the value of some argi if the value is an equation.  The variables
(both subscripted variables which do not have associated array
functions, and non-subscripted variables) in the expression exp are
replaced by their global values, except for those appearing in this
list.  Usually, exp is just a label or % (as in (%i2) below), so this
step simply retrieves the expression named by the label, so that EV
may work on it.

@item
    (3) If any substitutions are indicated by the argi, they are
carried out now.

@item
    (4) The resulting expression is then re-evaluated (unless one of
the argi was NOEVAL) and simplified according the the argi.  Note that
any function calls in exp will be carried out after the variables in
it are evaluated and that EV(F(X)) thus may behave like F(EV(X)).

@item
    (5) If one of the argi was EVAL, steps (3) and (4) are repeated.
@end itemize

@example
                     Examples

(%i1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
                        d                 2
(%o1)  COS(Y) + SIN(X) + -- SIN(W) + (W + 1)
                        dW
(%i2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
                    2
(%o2)      COS(W) + W  + 2 W + COS(1) + 1.90929742
@end example

An alternate top level syntax has been provided for EV, whereby one
may just type in its arguments, without the EV().  That is, one may
write simply
@example
exp, arg1, ...,argn.
@end example

This is not permitted as part of
another expression, i.e. in functions, blocks, etc.

@example
(%i4) X+Y,X:A+Y,Y:2;
(%o4)                Y + A + 2
(Notice the parallel binding process)
(%i5) 2*X-3*Y=3$
(%i6) -3*X+2*Y=-4$
(%i7) SOLVE([%o5,%o6]);
SOLUTION
                                1
(%t7)                     Y =  - -
                                5
                          6
(%t8)                  X = -
                          5
(%o8)               [%t7, %t8]
(%i9) %o6,%o8;
(%o9)               - 4 =  - 4
(%i10) X+1/X > GAMMA(1/2);
                    1
(%o10)           X + - > SQRT(%PI)
                    X
(%i11) %,NUMER,X=1/2;
(%o11)            2.5 > 1.7724539
(%i12) %,PRED;
(%o12)                  TRUE


@end example

@end defun

@defvar EVFLAG
 default: [] - the list of things known to the EV function.  An
item will be bound to TRUE during the execution of EV if it is
mentioned in the call to EV, e.g. EV(%,numer);.  Initial evflags are


@example
FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND.
@end example

@end defvar

@defvar EVFUN
 - the list of functions known to the EV function which will get
applied if their name is mentioned.  Initial evfuns are FACTOR,
TRIGEXPAND, TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, RADCAN,
LOGCONTRACT, RECTFORM, and POLARFORM.

@end defvar

@defvr {special symbol} INFEVAL
 leads to an "infinite evaluation" mode.  EV repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say X, from being evaluated away in this mode, simply
include X='X as an argument to EV.  Of course expressions such as
EV(X,X=X+1,INFEVAL); will generate an infinite loop.  CAVEAT
EVALUATOR.

@end defvr

@defun kill (symbol_1, symbol_2, symbol_3, ...)
@defunx kill (labels)
@defunx kill (clabels, dlabels, elabels)
@defunx kill (n)
@defunx kill ([m, n])
@defunx kill (values, functions, arrays, ...)
@defunx kill (all)
@defunx kill (allbut (symbol_1, symbol_2, symbol_3, ...))

Removes all bindings (value, function, array, or rule) from the arguments
@code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
An argument may be a single array element or subscripted function.

@code{kill} always returns @code{done}, even if an argument has no binding.

Several special arguments are recognized. 
Different kinds of arguments
may be combined, e.g., @code{kill (clabels, functions, allbut (foo, bar))}.

The special form @code{kill (labels)} unbinds
all input, output, and intermediate expression labels created so far.
@code{kill (clabels)} unbinds only input labels
which begin with the current value of @code{inchar}.
Likewise,
@code{kill (dlabels)} unbinds only output labels
which begin with the current value of @code{outchar},
and @code{kill (elabels)} unbinds only intermediate expression labels
which begin with the current value of @code{linechar}.

The special form @code{kill (n)}, where @code{n} is an integer,
unbinds the @code{n} most recent input and output labels.
The special form @code{kill ([m, n])} unbinds input and output labels @code{m} through @code{n}.

The special form @code{kill (infolist)}, where @code{infolist} is any item in @code{infolists}
(such as @code{values}, @code{functions}, or @code{arrays})
unbinds all items in @code{infolist}.
See also @code{infolists}.

The special form @code{kill (all)} unbinds all items on all infolists.

The special form @code{kill (allbut (symbol_1, symbol_2, symbol_3, ...))}
unbinds all items on all infolists except for @code{symbol_1}, @code{symbol_2}, @code{symbol_3}, ....
@code{kill (allbut (infolist))} unbinds all items except for the ones on @code{infolist},
where @code{infolist} is @code{values}, @code{functions}, @code{arrays}, etc.

The memory taken up by a bound property is not released until all symbols
are unbound from it.
In particular, to release the memory taken up by the value of a symbol,
one unbinds the output label which shows the bound value, as well as unbinding the symbol itself.

@code{kill} quotes its arguments.
The double-quote operator, @code{'@w{}'}, defeats the quotation.

@code{kill (symbol)} unbinds all properties of @code{symbol}.
In contrast, @code{remvalue}, @code{remfunction}, @code{remarray}, and @code{remrule}
unbind a specific property.
Those functions also differ in that they return a list of the symbols or @code{false}.

@end defun

@defun labels (symbol)
@defunx labels
Returns the list of input, output, or intermediate expression labels which begin with @code{symbol}.
Typically @code{symbol} is the value of @code{inchar}, @code{outchar}, or @code{linechar}.
The label character may be given with or without a percent sign,
so, for example, @code{i} and @code{%i} yield the same result.

If no labels begin with @code{symbol}, @code{labels} returns an empty list.

The function @code{labels} quotes its argument.
The double-quote operator @code{'@w{}'} defeats the quotation.
For example,
@code{labels (''inchar)} returns the input labels which begin with the current input label character.

The variable @code{labels} is the list of input, output, and intermediate expression labels,
including all previous labels if @code{inchar}, @code{outchar}, or @code{linechar} were redefined.

@c NEED TO EXPLAIN THIS SHORTCUT ???
@code{first (rest (labels (''inchar)))} returns the most recent input label.

See also @code{inchar}, @code{outchar}, @code{linechar}, and @code{infolists}.

@end defun

@defvar LINENUM
 - the line number of the last expression.

@end defvar

@defvar MYOPTIONS
 default: [] - all options ever reset by the user (whether
or not they get reset to their default value).

@end defvar

@defvar NOLABELS
 default: [FALSE] - if TRUE then no labels will be bound
except for E lines generated by the solve functions.  This is most
useful in the "BATCH" mode where it eliminates the need to do
KILL(LABELS) in order to free up storage.

@end defvar

@defvar OPTIONSET
 default: [FALSE] - if TRUE, Maxima will print out a
message whenever a Maxima option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

@end defvar

@defun PLAYBACK (arg)
"plays back" input and output lines.  If arg=n (a
number) the last n expressions (Ci, Di, and Ei count as 1 each) are
"played-back", while if arg is omitted, all lines are.  If arg=INPUT
then only input lines are played back. If arg=[m,n] then all lines
with numbers from m to n inclusive are played-back.  If m=n then [m]
is sufficient for arg.  Arg=SLOW places PLAYBACK in a slow-mode
similar to DEMO's (as opposed to the "fast" BATCH).  This is useful in
conjunction with SAVE or STRINGOUT when creating a secondary-storage
file in order to pick out useful expressions.  If arg=TIME then the
computation times are displayed as well as the expressions.  If
arg=GCTIME or TOTALTIME, then a complete breakdown of computation
times are displayed, as with SHOWTIME:ALL;.  Arg=STRING strings-out
(see STRING function) all input lines when playing back rather than
displaying them.  If ARG=GRIND "grind" mode can also be turned on (for
processing input lines) (see GRIND).  One may include any number of
options as in PLAYBACK([5,10],20,TIME,SLOW).

@end defun

@defun PRINTPROPS (a, i)
will display the property with the indicator i
associated with the atom a. a may also be a list of atoms or the atom
ALL in which case all of the atoms with the given property will be
used.  For example, PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is for
properties that cannot otherwise be displayed, i.e. for
ATVALUE, ATOMGRAD, GRADEF, and MATCHDECLARE.

@end defun

@defvar PROMPT
 default: [_] is the prompt symbol of the DEMO function,
PLAYBACK(SLOW) mode, and the Maxima break loop (as invoked by BREAK).

@end defvar

@defun QUIT ()
kills the current Maxima but doesn't affect the user's other
jobs;  equivalent to exiting to DCL and stopping the Maxima process.
One may "quit" to Maxima top-level by typing Control-C Control-G;
Control-C gets NIL's interrupt prompt, at which one types either
Control-G or just G.  Typing X at the Interrupt prompt will cause a
quit in a computation started within a Maxima break without disrupting
the suspended main computation.

@end defun

@defun REMFUNCTION (f1, f2, ...)
removes the user defined functions
f1,f2,... from Maxima.  If there is only one argument of ALL then all
functions are removed.

@end defun

@defun RESET ()
causes all Maxima options to be set to their default values.
(Please note that this does not include features of terminals such as
LINEL which can only be changed by assignment as they are not
considered to be computational features of Maxima.)

@end defun

@defvar SHOWTIME
 default: [FALSE] - if TRUE then the computation time will be
printed automatically with each output expression.  By setting
SHOWTIME:ALL, in addition to the cpu time Maxima now also prints out
(when not zero) the amount of time spent in garbage collection (gc) in
the course of a computation.  This time is of course included in the
time printed out as "time=" .  (It should be noted that since the
"time=" time only includes computation time and not any intermediate
display time or time it takes to load in out-of-core files, and since
it is difficult to ascribe "responsibility" for gc's, the gctime
printed will include all gctime incurred in the course of the
computation and hence may in rare cases even be larger than "time=").

@end defvar

@defun SSTATUS (feature,package)
- meaning SET STATUS.  It can be used to
SSTATUS( FEATURE, HACK_PACKAGE) so that STATUS( FEATURE, HACK_PACKAGE)
will then return TRUE.  This can be useful for package writers, to
keep track of what FEATURES they have loaded in.

@end defun

@defun TO_LISP ()
enters the Lisp system under Maxima.  This is useful on
those systems where control-uparrow is not available for this
function.

@end defun

@defvar VALUES
 default:[] - all bound atoms, i.e. user variables, not Maxima
Options or Switches, (set up by : , :: , or functional binding).

@end defvar
