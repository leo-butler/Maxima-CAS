@c end concepts Contexts
@menu
* Definitions for Contexts::    
@end menu

@node Definitions for Contexts,  , Contexts, Contexts
@section Definitions for Contexts
@c @node ACTIVATE
@c @unnumberedsec phony
@defun ACTIVATE (cont1, cont2, ...)
causes the specified contexts conti to be
activated.  The facts in these contexts are used in making deductions
and retrieving information.  The facts in these contexts are not
listed when FACTS(); is done.  The variable ACTIVECONTEXTS is the list
of contexts which are active by way of the ACTIVATE function.

@end defun
@c @node ACTIVECONTEXTS
@c @unnumberedsec phony
@defvar ACTIVECONTEXTS
 default: [] is a list of the contexts which are active
by way of the ACTIVATE function, as opposed to being active because
they are subcontexts of the current context.

@end defvar



@c @node ASSUME
@c @unnumberedsec phony
@defun ASSUME (pred1, pred2, ...)
First checks the specified predicates for
redundancy and consistency with the current data base.  If the
predicates are consistent and non-redundant, they are added to the
data base; if inconsistent or redundant, no action is taken.  ASSUME
returns a list whose entries are the predicates added to the data base
and the atoms REDUNDANT or INCONSISTENT where applicable.

@end defun
@c @node ASSUMESCALAR
@c @unnumberedsec phony
@defvar ASSUMESCALAR
 default: [TRUE] - helps govern whether expressions @code{exp}
for which

@example
NONSCALARP(exp) is FALSE
@end example

are assumed to behave like scalars
for certain transformations as follows: Let @code{exp} represent any
non-list/non-matrix, and @code{[1,2,3]} any list or matrix.
@example
exp.[1,2,3]; ==>
 [exp,2*exp,3*exp]
@end example
if ASSUMESCALAR is TRUE or SCALARP(exp) is
TRUE or CONSTANTP(exp) is TRUE.  If ASSUMESCALAR is TRUE, such
expressions will behave like scalars only for the commutative
operators, but not for ".".  If ASSUMESCALAR is FALSE, such
expressions will behave like non-scalars.  If ASSUMESCALAR is ALL,
such expressions will behave like scalars for all the operators listed
above.
@end defvar

@c @node ASSUME_POS
@c @unnumberedsec phony
@defvar ASSUME_POS
 default:[FALSE] - When using INTEGRATE, etc. one often
introduces parameters which are real and positive or one's
calculations can often be constructed so that this is true.  There is
a switch ASSUME_POS (default FALSE) such that if set to TRUE, MACSYMA
will assume one's parameters are positive.  The intention here is to
cut down on the number of questions MACSYMA needs to ask.  Obviously,
ASSUME information or any contextual information present will take
precedence.  The user can control what is considered to be a parameter
for this purpose.  Parameters by default are those which satisfy
SYMBOLP(x) OR SUBVARP(x).  The user can change this by setting the
option ASSUME_POS_PRED [default FALSE] to the name of a predicate
function of one argument.  E.g. if you want only symbols to be
parameters, you can do ASSUME_POS:TRUE$ ASSUME_POS_PRED:'SYMBOLP$
SIGN(A); -> POS, SIGN(A[1]); -> PNZ.
@end defvar

@c @node ASSUME_POS_PRED
@c @unnumberedsec phony
@defvar ASSUME_POS_PRED
 default:[FALSE] - may be set to one argument to control
what will be considered a parameter for the "assumptions" that INTEGRATE
will make... see ASSUME and ASSUME_POS .
@end defvar

@c @node CONTEXT
@c @unnumberedsec phony
@defvar CONTEXT
 default: INITIAL. Whenever a user assumes a new fact, it is
placed in the context named as the current value of the variable
CONTEXT.  Similarly, FORGET references the current value of CONTEXT.
To change contexts, simply bind CONTEXT to the desired context.  If
the specified context does not exist it will be created by an
invisible call to NEWCONTEXT.  The context specified by the value of
CONTEXT is automatically activated.  (Do DESCRIBE(CONTEXTS); for a
general description of the CONTEXT mechanism.)

@end defvar
@c @node CONTEXTS
@c @unnumberedsec phony
@defvar CONTEXTS
 default: [INITIAL,GLOBAL] is a list of the contexts which
currently exist, including the currently active context.
The context mechanism makes it possible for a user to bind together
and name a selected portion of his data base, called a context.  Once
this is done, the user can have MACSYMA assume or forget large numbers
of facts merely by activating or deactivating their context.  Any
symbolic atom can be a context, and the facts contained in that
context will be retained in storage until the user destroys them
individually by using FORGET or destroys them as a whole by using KILL
to destroy the context to which they belong.
    Contexts exist in a formal hierarchy, with the root always being
the context GLOBAL, which contains information about MACSYMA that some
functions need.  When in a given context, all the facts in that
context are "active" (meaning that they are used in deductions and
retrievals) as are all the facts in any context which is an inferior
of that context.  When a fresh MACSYMA is started up, the user is in a
context called INITIAL, which has GLOBAL as a subcontext.
The functions which deal with contexts are: FACTS, NEWCONTEXT,
SUPCONTEXT, KILLCONTEXT, ACTIVATE, DEACTIVATE, ASSUME, and FORGET.

@end defvar
@c @node DEACTIVATE
@c @unnumberedsec phony
@defun DEACTIVATE (cont1, cont2, ...)
causes the specified contexts conti to
be deactivated.

@end defun
@c @node FACTS
@c @unnumberedsec phony
@defun FACTS (item)
If 'item' is the name of a context then FACTS returns a list
of the facts in the specified context.  If no argument is given, it
lists the current context.  If 'item' is not the name of a context
then it returns a list of the facts known about 'item' in the current
context.  Facts that are active, but in a different context, are not
listed.

@end defun
@c @node declaration
@c @unnumberedsec phony
@defvr declaration FEATURES
 - MACSYMA has built-in properties which are handled by the
data base.  These are called FEATURES.  One can do DECLARE(N,INTEGER),
etc.  One can also DECLARE one's own FEATURES by e.g.
DECLARE(INCREASING,FEATURE); which will then allow one to say
DECLARE(F,INCREASING);.  One can then check if F is INCREASING by
using the predicate FEATUREP via FEATUREP(F,INCREASING).  There is
an infolist FEATURES which is a list of known FEATURES.  At present
known FEATURES are: INTEGER, NONINTEGER, EVEN, ODD, RATIONAL,
IRRATIONAL, REAL, IMAGINARY, COMPLEX, ANALYTIC, INCREASING,
DECREASING, ODDFUN, EVENFUN, POSFUN, COMMUTATIVE, LASSOCIATIVE,
RASSOCIATIVE, SYMMETRIC, and ANTISYMMETRIC.  [Note: system "features"
may be checked with STATUS(FEATURE,...); See DESCRIBE(STATUS); or
DESCRIBE(FEATURE); for details.]

@end defvr
@c @node FORGET
@c @unnumberedsec phony
@defun FORGET (pred1, pred2, ...)
removes relations established by ASSUME.
The predicates may be expressions equivalent to (but not necessarily
identical to) those previously ASSUMEd.  FORGET(list) is also a legal
form.

@end defun
@c @node KILLCONTEXT
@c @unnumberedsec phony
@defun KILLCONTEXT (context1,context2,...,contextn)
kills the specified
contexts.  If one of them is the current context, the new current
context will become the first available subcontext of the current
context which has not been killed.  If the first available unkilled
context is GLOBAL then INITIAL is used instead.  If the INITIAL
context is killed, a new INITIAL is created, which is empty of facts.
KILLCONTEXT doesn't allow the user to kill a context which is
currently active, either because it is a subcontext of the current
context, or by use of the function ACTIVATE.

@end defun
@c @node NEWCONTEXT
@c @unnumberedsec phony
@defun NEWCONTEXT (name)
creates a new (empty) context, called name, which
has GLOBAL as its only subcontext.  The new context created will
become the currently active context.

@end defun
@c @node SUPCONTEXT
@c @unnumberedsec phony
@defun SUPCONTEXT (name,context)
will create a new context (called name)
whose subcontext is context.  If context is not specified, the current
context will be assumed.  If it is specified, context must exist.

@end defun
