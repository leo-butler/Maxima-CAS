@menu
* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::
@end menu

@node Introduction to distrib, Functions and Variables for continuous distributions, distrib, distrib
@section Introduction to distrib


Package @code{distrib} contains a set of functions for making probability computations on both discrete and continuous univariate models. 

What follows is a short reminder of basic probabilistic related definitions.

Let @math{f(x)} be the @var{density function} of an absolute continuous random variable @math{X}. The @var{distribution function} is defined as
@ifhtml
@example
                       x
                      /
                      [
               F(x) = I     f(u) du
                      ]
                      /
                       minf
@end example
@end ifhtml
@ifinfo
@example
                       x
                      /
                      [
               F(x) = I     f(u) du
                      ]
                      /
                       minf
@end example
@end ifinfo
@tex
$$F\left(x\right)=\int_{ -\infty }^{x}{f\left(u\right)\;du}$$
@end tex
which equals the probability @var{Pr(X <= x)}.

The @var{mean} value is a localization parameter and is defined as
@ifhtml
@example
                     inf
                    /
                    [
           E[X]  =  I   x f(x) dx
                    ]
                    /
                     minf
@end example
@end ifhtml
@ifinfo
@example
                     inf
                    /
                    [
           E[X]  =  I   x f(x) dx
                    ]
                    /
                     minf
@end example
@end ifinfo
@tex
$$E\left[X\right]=\int_{ -\infty }^{\infty }{x\,f\left(x\right)\;dx}$$
@end tex

The @var{variance} is a measure of variation,
@ifhtml
@example
                 inf
                /
                [                    2
         V[X] = I     f(x) (x - E[X])  dx
                ]
                /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
                [                    2
         V[X] = I     f(x) (x - E[X])  dx
                ]
                /
                 minf
@end example
@end ifinfo
@tex
$$V\left[X\right]=\int_{ -\infty }^{\infty }{f\left(x\right)\,\left(x
 -E\left[X\right]\right)^2\;dx}$$
@end tex
which is a positive real number. The square root of the variance is the @var{standard deviation}, @math{D[X]=sqrt(V[X])}, and it is another measure of variation.

The @var{skewness coefficient} is a measure of non-symmetry,
@ifhtml
@example
                 inf
                /
            1   [                    3
  SK[X] = ----- I     f(x) (x - E[X])  dx
              3 ]
          D[X]  /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
            1   [                    3
  SK[X] = ----- I     f(x) (x - E[X])  dx
              3 ]
          D[X]  /
                 minf
@end example
@end ifinfo
@tex
$$SK\left[X\right]={{\int_{ -\infty }^{\infty }{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^3\;dx}}\over{D\left[X\right]^3}}$$
@end tex

And the @var{kurtosis coefficient} measures the peakedness of the distribution,
@ifhtml
@example
                 inf
                /
            1   [                    4
  KU[X] = ----- I     f(x) (x - E[X])  dx - 3
              4 ]
          D[X]  /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
            1   [                    4
  KU[X] = ----- I     f(x) (x - E[X])  dx - 3
              4 ]
          D[X]  /
                 minf
@end example
@end ifinfo
@tex
$$KU\left[X\right]={{\int_{ -\infty }^{\infty }{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^4\;dx}}\over{D\left[X\right]^4}}-3$$
@end tex
If @math{X} is gaussian, @math{KU[X]=0}. In fact, both skewness and kurtosis are shape parameters used to measure the non--gaussianity of a distribution.

If the random variable @math{X} is discrete, the density, or @var{probability}, function @math{f(x)} takes positive values within certain countable set of numbers @math{x_i}, and zero elsewhere. In this case, the distribution function is
@ifhtml
@example
                       ====
                       \
                F(x) =  >    f(x )
                       /        i
                       ====
                      x <= x
                       i
@end example
@end ifhtml
@ifinfo
@example
                       ====
                       \
                F(x) =  >    f(x )
                       /        i
                       ====
                      x <= x
                       i
@end example
@end ifinfo
@tex
$$F\left(x\right)=\sum_{x_{i}\leq x}{f\left(x_{i}\right)}$$
@end tex

The mean, variance, standard deviation, skewness coefficient and kurtosis coefficient take the form
@ifhtml
@example
                       ====
                       \
                E[X] =  >  x  f(x ) ,
                       /    i    i
                       ====
                        x 
                         i
@end example
@end ifhtml
@ifinfo
@example
                       ====
                       \
                E[X] =  >  x  f(x ) ,
                       /    i    i
                       ====
                        x 
                         i
@end example
@end ifinfo
@tex
$$E\left[X\right]=\sum_{x_{i}}{x_{i}f\left(x_{i}\right)},$$
@end tex

@ifhtml
@example
                ====
                \                     2
        V[X] =   >    f(x ) (x - E[X])  ,
                /        i    i
                ====
                 x
                  i
@end example
@end ifhtml
@ifinfo
@example
                ====
                \                     2
        V[X] =   >    f(x ) (x - E[X])  ,
                /        i    i
                ====
                 x
                  i
@end example
@end ifinfo
@tex
$$V\left[X\right]=\sum_{x_{i}}{f\left(x_{i}\right)\left(x_{i}-E\left[X\right]\right)^2},$$
@end tex

@ifhtml
@example
               D[X] = sqrt(V[X]),
@end example
@end ifhtml
@ifinfo
@example
               D[X] = sqrt(V[X]),
@end example
@end ifinfo
@tex
$$D\left[X\right]=\sqrt{V\left[X\right]},$$
@end tex

@ifhtml
@example
                     ====
              1      \                     3
  SK[X] =  -------    >    f(x ) (x - E[X])  
           D[X]^3    /        i    i
                     ====
                      x
                       i
@end example
@end ifhtml
@ifinfo
@example
                     ====
              1      \                     3
  SK[X] =  -------    >    f(x ) (x - E[X])  
           D[X]^3    /        i    i
                     ====
                      x
                       i
@end example
@end ifinfo
@tex
$$SK\left[X\right]={{\sum_{x_{i}}{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^3\;dx}}\over{D\left[X\right]^3}}$$
@end tex
and
@ifhtml
@example
                     ====
              1      \                     4
  KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
           D[X]^4    /        i    i
                     ====
                      x
                       i
@end example
@end ifhtml
@ifinfo
@example
                     ====
              1      \                     4
  KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
           D[X]^4    /        i    i
                     ====
                      x
                       i
@end example
@end ifinfo
@tex
$$KU\left[X\right]={{\sum_{x_{i}}{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^4\;dx}}\over{D\left[X\right]^4}}-3,$$
@end tex
respectively.

Package @code{distrib} includes functions for simulating random variates. Some of these functions make use of optional variables indicating the algorithm to be used. The general inverse method (based on the fact that if @var{u} is an uniform random number in @math{(0,1)}, then @var{F^(-1)(u)} is a random variate with distribution @math{F}) is implemented in most cases; this is a suboptimal method in terms of timing, but useful for comparing with other algorithms. In this example, the perandom_formance of algorithms @code{ahrens_cheng} and @code{inverse} for simulating chi-square variates are compared by means of their histograms:

@example
(%i1) load(distrib)$
(%i2) load(descriptive)$
(%i3) showtime: true$
Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
(%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
(%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.
@end example

In order to make visual comparisons among algorithms for a discrete variate, function @code{barsplot} of the @code{descriptive} package should be used.

Note that some work remains to be done, since these simulating functions are not yet checked by more rigurous goodness of fit tests.

Please, consult an introductory manual on probability and statistics for more information about all this mathematical stuff.

There is a naming convention in package @code{distrib}. Every function name has two parts, the first one makes reference to the function or parameter we want to calculate,
@example
Functions:
   Density function            (pdf_*)
   Distribution function       (cdf_*)
   Quantile                    (quantile_*)
   Mean                        (mean_*)
   Variance                    (var_*)
   Standard deviation          (std_*)
   Skewness coefficient        (skewness_*)
   Kurtosis coefficient        (kurtosis_*)
   Random variate              (random_*)
@end example

The second part is an explicit reference to the probabilistic model,
@example
Continuous distributions:
   Normal              (*normal)
   Student             (*student_t)
   Chi^2               (*chi2)
   F                   (*f)
   Exponential         (*exp)
   Lognormal           (*lognormal)
   Gamma               (*gamma)
   Beta                (*beta)
   Continuous uniform  (*continuous_uniform)
   Logistic            (*logistic)
   Pareto              (*pareto)
   Weibull             (*weibull)
   Rayleigh            (*rayleigh)
   Laplace             (*laplace)
   Cauchy              (*cauchy)
   Gumbel              (*gumbel)

Discrete distributions:
   Binomial             (*binomial)
   Poisson              (*poisson)
   Bernoulli            (*bernoulli)
   Geometric            (*geometric)
   Discrete uniform     (*discrete_uniform)
   hypergeometric       (*hypergeometric)
   Negative binomial    (*negative_binomial)
@end example

For example, @code{pdf_student_t(x,n)} is the density function of the Student distribution with @var{n} degrees of freedom, @code{std_pareto(a,b)} is the standard deviation of the Pareto distribution with parameters @var{a} and @var{b} and @code{kurtosis_poisson(m)} is the kurtosis coefficient of the Poisson distribution with mean @var{m}.


In order to make use of package @code{distrib} you need first to load it by typing
@example
(%i1) load(distrib)$
@end example

For comments, bugs or suggestions, please contact the author at @var{'mario AT edu DOT xunta DOT es'}.






@node Functions and Variables for continuous distributions, Functions and Variables for discrete distributions, Introduction to distrib, distrib
@section Functions and Variables for continuous distributions


@deffn {Function} pdf_normal (@var{x},@var{m},@var{s})
Returns the value at @var{x} of the density function of a @math{Normal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_normal (@var{x},@var{m},@var{s})
Returns the value at @var{x} of the distribution function of a @math{Normal(m,s)} random variable, with @math{s>0}. This function is defined in terms of Maxima's built-in error function @code{erf}.

@c ===beg===
@c load (distrib)$
@c assume(s>0)$ cdf_normal(x,m,s);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(s>0)$ cdf_normal(x,m,s);
                             x - m
                       erf(---------)
                           sqrt(2) s    1
(%o3)                  -------------- + -
                             2          2
@end example

See also @code{erf}.
@end deffn


@deffn {Function} quantile_normal (@var{q},@var{m},@var{s})
Returns the @var{q}-quantile of a @math{Normal(m,s)} random variable, with @math{s>0}; in other words, this is the inverse of @code{cdf_normal}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_normal (@var{m},@var{s})
Returns the mean of a @math{Normal(m,s)} random variable, with @math{s>0}, namely @var{m}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_normal (@var{m},@var{s})
Returns the variance of a @math{Normal(m,s)} random variable, with @math{s>0}, namely @var{s^2}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_normal (@var{m},@var{s})
Returns the standard deviation of a @math{Normal(m,s)} random variable, with @math{s>0}, namely @var{s}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_normal (@var{m},@var{s})
Returns the skewness coefficient of a @math{Normal(m,s)} random variable, with @math{s>0}, which is always equal to 0. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_normal (@var{m},@var{s})
Returns the kurtosis coefficient of a @math{Normal(m,s)} random variable, with @math{s>0}, which is always equal to 0. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_normal_algorithm
Default value: @code{box_mueller}

This is the selected algorithm for simulating random normal variates. Implemented algorithms are @code{box_mueller} and @code{inverse}:
@itemize @bullet
@item
@code{box_mueller}, based on algorithm described in Knuth, D.E. (1981) @var{Seminumerical Algorithms. The Art of Computer Programming.} Addison-Wesley.

@item
@code{inverse}, based on the general inverse method.
@end itemize

See also @code{random_normal}.
@end defvr


@deffn {Function} random_normal (@var{m},@var{s})
@deffnx {Function} random_normal (@var{m},@var{s},@var{n})
Returns a @math{Normal(m,s)} random variate, with @math{s>0}. Calling @code{random_normal} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_normal_algorithm}, which defaults to @code{box_mueller}.

See also @code{random_normal_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_student_t (@var{x},@var{n})
Returns the value at @var{x} of the density function of a Student random variable @math{t(n)}, with @math{n>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_student_t (@var{x},@var{n})
Returns the value at @var{x} of the distribution function of a Student random variable @math{t(n)}, with @math{n>0}. This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_student_t(1/2, 7/3);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_student_t(1/2, 7/3);
                                     1  7
(%o2)                  cdf_student_t(-, -)
                                     2  3
(%i3) %,numer;
(%o3)                   .6698450596140417
@end example
@end deffn


@deffn {Function} quantile_student_t (@var{q},@var{n})
Returns the @var{q}-quantile of a Student random variable @math{t(n)}, with @math{n>0}; in other words, this is the inverse of @code{cdf_student_t}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_student_t (@var{n})
Returns the mean of a Student random variable @math{t(n)}, with @math{n>0}, which is always equal to 0. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_student_t (@var{n})
Returns the variance of a Student random variable @math{t(n)}, with @math{n>2}.

@c ===beg===
@c load (distrib)$
@c assume(n>2)$  var_student_t(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(n>2)$  var_student_t(n);
                                n
(%o3)                         -----
                              n - 2
@end example
@end deffn


@deffn {Function} std_student_t (@var{n})
Returns the standard deviation of a Student random variable @math{t(n)}, with @math{n>2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_student_t (@var{n})
Returns the skewness coefficient of a Student random variable @math{t(n)}, with @math{n>3}, which is always equal to 0. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_student_t (@var{n})
Returns the kurtosis coefficient of a Student random variable @math{t(n)}, with @math{n>4}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_student_t_algorithm
Default value: @code{ratio}

This is the selected algorithm for simulating random Student variates. Implemented algorithms are @code{inverse} and @code{ratio}:
@itemize @bullet
@item
@code{inverse}, based on the general inverse method.


@item
@code{ratio}, based on the fact that if @var{Z} is a normal random variable @math{N(0,1)} and @math{S^2} is chi square  random variable with @var{n} degrees of freedom, @math{Chi^2(n)}, then
@ifhtml
@example
                           Z
                 X = -------------
                     /   2  \ 1/2
                     |  S   |
                     | ---  |
                     \  n   /
@end example
@end ifhtml
@ifinfo
@example
                           Z
                 X = -------------
                     /   2  \ 1/2
                     |  S   |
                     | ---  |
                     \  n   /
@end example
@end ifinfo
@tex
$$X={{Z}\over{\sqrt{{S^2}\over{n}}}}$$
@end tex
is a Student random variable with @var{n} degrees of freedom, @math{t(n)}.
@end itemize

See also @code{random_student_t}.
@end defvr


@deffn {Function} random_student_t (@var{n})
@deffnx {Function} random_student_t (@var{n},@var{m})
Returns a Student random variate @math{t(n)}, with @math{n>0}. Calling @code{random_student_t} with a second argument @var{m}, a random sample of size @var{m} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_student_t_algorithm}, which defaults to @code{ratio}.

See also @code{random_student_t_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_chi2 (@var{x},@var{n})
Returns the value at @var{x} of the density function of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma density is returned.

@c ===beg===
@c load (distrib)$
@c pdf_chi2(x,n);
@c assume(x>0, n>0)$  pdf_chi2(x,n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_chi2(x,n);
                                    n
(%o2)                  pdf_gamma(x, -, 2)
                                    2
(%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                         n/2 - 1   - x/2
                        x        %e
(%o4)                   ----------------
                          n/2       n
                         2    gamma(-)
                                    2
@end example
@end deffn


@deffn {Function} cdf_chi2 (@var{x},@var{n})
Returns the value at @var{x} of the distribution function of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression based on the gamma distribution, since the @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}.

@c ===beg===
@c load (distrib)$
@c cdf_chi2(3,4);
@c cdf_chi2(3,4),numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_chi2(3,4);
(%o2)                  cdf_gamma(3, 2, 2)
(%i3) cdf_chi2(3,4),numer;
(%o3)                   .4421745996289249
@end example
@end deffn


@deffn {Function} quantile_chi2 (@var{q},@var{n})
Returns the @var{q}-quantile of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}; in other words, this is the inverse of @code{cdf_chi2}. Argument @var{q} must be an element of @math{[0,1]}.

This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression based on the gamma quantile function, since the @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}.

@c ===beg===
@c load (distrib)$
@c quantile_chi2(0.99,9);
@c quantile_chi2(0.99,n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_chi2(0.99,9);
(%o2)                   21.66599433346194
(%i3) quantile_chi2(0.99,n);
                                        n
(%o3)              quantile_gamma(0.99, -, 2)
                                        2
@end example
@end deffn


@deffn {Function} mean_chi2 (@var{n})
Returns the mean of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma mean is returned.

@c ===beg===
@c load (distrib)$
@c mean_chi2(n);
@c assume(n>0)$ mean_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_chi2(n);
                                   n
(%o2)                   mean_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ mean_chi2(n);
(%o4)                           n
@end example
@end deffn


@deffn {Function} var_chi2 (@var{n})
Returns the variance of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma variance is returned.

@c ===beg===
@c load (distrib)$
@c var_chi2(n);
@c assume(n>0)$ var_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_chi2(n);
                                   n
(%o2)                    var_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ var_chi2(n);
(%o4)                          2 n
@end example
@end deffn


@deffn {Function} std_chi2 (@var{n})
Returns the standard deviation of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma standard deviation is returned.

@c ===beg===
@c load (distrib)$
@c std_chi2(n);
@c assume(n>0)$ std_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_chi2(n);
                                   n
(%o2)                    std_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ std_chi2(n);
(%o4)                    sqrt(2) sqrt(n)
@end example
@end deffn


@deffn {Function} skewness_chi2 (@var{n})
Returns the skewness coefficient of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma skewness coefficient is returned.

@c ===beg===
@c load (distrib)$
@c skewness_chi2(n);
@c assume(n>0)$ skewness_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_chi2(n);
                                     n
(%o2)                 skewness_gamma(-, 2)
                                     2
(%i3) assume(n>0)$ skewness_chi2(n);
                            2 sqrt(2)
(%o4)                       ---------
                             sqrt(n)
@end example
@end deffn


@deffn {Function} kurtosis_chi2 (@var{n})
Returns the kurtosis coefficient of a Chi-square random variable @math{Chi^2(n)}, with @math{n>0}.

The @math{Chi^2(n)} random variable is equivalent to the @math{Gamma(n/2,2)}, therefore when Maxima has not enough information to get the result, a noun form based on the gamma kurtosis coefficient is returned.

@c ===beg===
@c load (distrib)$
@c kurtosis_chi2(n);
@c assume(n>0)$ kurtosis_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_chi2(n);
                                     n
(%o2)                 kurtosis_gamma(-, 2)
                                     2
(%i3) assume(n>0)$ kurtosis_chi2(n);
                               12
(%o4)                          --
                               n
@end example
@end deffn


@defvr {Option variable} random_chi2_algorithm
Default value: @code{ahrens_cheng}

This is the selected algorithm for simulating random Chi-square variates. Implemented algorithms are @code{ahrens_cheng} and @code{inverse}:
@itemize @bullet

@item
@code{ahrens_cheng}, based on the random simulation of gamma variates. See @code{random_gamma_algorithm} for details.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_chi2}.
@end defvr


@deffn {Function} random_chi2 (@var{n})
@deffnx {Function} random_chi2 (@var{n},@var{m})
Returns a Chi-square random variate @math{Chi^2(n)}, with @math{n>0}. Calling @code{random_chi2} with a second argument @var{m}, a random sample of size @var{m} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_chi2_algorithm}, which defaults to @code{ahrens_cheng}.

See also @code{random_chi2_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_f (@var{x},@var{m},@var{n})
Returns the value at @var{x} of the density function of a F random variable @math{F(m,n)}, with @math{m,n>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_f (@var{x},@var{m},@var{n})
Returns the value at @var{x} of the distribution function of a F random variable @math{F(m,n)}, with @math{m,n>0}. This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_f(2,3,9/4);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_f(2,3,9/4);
                                     9
(%o2)                    cdf_f(2, 3, -)
                                     4
(%i3) %,numer;
(%o3)                   0.66756728179008
@end example
@end deffn


@deffn {Function} quantile_f (@var{q},@var{m},@var{n})
Returns the @var{q}-quantile of a F random variable @math{F(m,n)}, with @math{m,n>0}; in other words, this is the inverse of @code{cdf_f}. Argument @var{q} must be an element of @math{[0,1]}.

This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c quantile_f(2/5,sqrt(3),5);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_f(2/5,sqrt(3),5);
                               2
(%o2)               quantile_f(-, sqrt(3), 5)
                               5
(%i3) %,numer;
(%o3)                   0.518947838573693
@end example
@end deffn


@deffn {Function} mean_f (@var{m},@var{n})
Returns the mean of a F random variable @math{F(m,n)}, with @math{m>0, n>2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_f (@var{m},@var{n})
Returns the variance of a F random variable @math{F(m,n)}, with @math{m>0, n>4}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_f (@var{m},@var{n})
Returns the standard deviation of a F random variable @math{F(m,n)}, with @math{m>0, n>4}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_f (@var{m},@var{n})
Returns the skewness coefficient of a F random variable @math{F(m,n)}, with @math{m>0, n>6}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_f (@var{m},@var{n})
Returns the kurtosis coefficient of a F random variable @math{F(m,n)}, with @math{m>0, n>8}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_f_algorithm
Default value: @code{inverse}

This is the selected algorithm for simulating random F variates. Implemented algorithms are @code{ratio} and @code{inverse}:
@itemize @bullet

@item
@code{ratio}, based on the fact that if @var{X} is a @math{Chi^2(m)} random variable and @math{Y} is a @math{Chi^2(n)} random variable, then
@ifhtml
@example
                        n X
                    F = ---
                        m Y
@end example
@end ifhtml
@ifinfo
@example
                        n X
                    F = ---
                        m Y
@end example
@end ifinfo
@tex
$$F={{n X}\over{m Y}}$$
@end tex
is a F random variable with @var{m} and @var{n} degrees of freedom, @math{F(m,n)}.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_f}.
@end defvr


@deffn {Function} random_f (@var{m},@var{n})
@deffnx {Function} random_f (@var{m},@var{n},@var{k})
Returns a F random variate @math{F(m,n)}, with @math{m,n>0}. Calling @code{random_f} with a third argument @var{k}, a random sample of size @var{k} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_f_algorithm}, which defaults to @code{inverse}.

See also @code{random_f_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_exp (@var{x},@var{m})
Returns the value at @var{x} of the density function of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull density is returned.

@c ===beg===
@c load (distrib)$
@c pdf_exp(x,m);
@c assume(x>0,m>0)$  pdf_exp(x,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_exp(x,m);
                                        1
(%o2)                 pdf_weibull(x, 1, -)
                                        m
(%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                - m x
(%o4)                       m %e
@end example
@end deffn


@deffn {Function} cdf_exp (@var{x},@var{m})
Returns the value at @var{x} of the distribution function of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull distribution is returned.

@c ===beg===
@c load (distrib)$
@c cdf_exp(x,m);
@c assume(x>0,m>0)$  cdf_exp(x,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_exp(x,m);
                                        1
(%o2)                 cdf_weibull(x, 1, -)
                                        m
(%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                 - m x
(%o4)                      1 - %e
@end example
@end deffn


@deffn {Function} quantile_exp (@var{q},@var{m})
Returns the @var{q}-quantile of an @math{Exponential(m)} random variable, with @math{m>0}; in other words, this is the inverse of @code{cdf_exp}. Argument @var{q} must be an element of @math{[0,1]}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull quantile is returned.

@c ===beg===
@c load (distrib)$
@c quantile_exp(0.56,5);
@c quantile_exp(0.56,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_exp(0.56,5);
(%o2)                   .1641961104139661
(%i3) quantile_exp(0.56,m);
                                            1
(%o3)             quantile_weibull(0.56, 1, -)
                                            m
@end example
@end deffn


@deffn {Function} mean_exp (@var{m})
Returns the mean of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull mean is returned.

@c ===beg===
@c load (distrib)$
@c mean_exp(m);
@c assume(m>0)$  mean_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_exp(m);
                                       1
(%o2)                  mean_weibull(1, -)
                                       m
(%i3) assume(m>0)$  mean_exp(m);
                                1
(%o4)                           -
                                m
@end example
@end deffn


@deffn {Function} var_exp (@var{m})
Returns the variance of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull variance is returned.

@c ===beg===
@c load (distrib)$
@c var_exp(m);
@c assume(m>0)$  var_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_exp(m);
                                       1
(%o2)                   var_weibull(1, -)
                                       m
(%i3) assume(m>0)$  var_exp(m);
                               1
(%o4)                          --
                                2
                               m
@end example
@end deffn


@deffn {Function} std_exp (@var{m})
Returns the standard deviation of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull standard deviation is returned.

@c ===beg===
@c load (distrib)$
@c std_exp(m);
@c assume(m>0)$  std_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_exp(m);
                                       1
(%o2)                   std_weibull(1, -)
                                       m
(%i3) assume(m>0)$  std_exp(m);
                                1
(%o4)                           -
                                m
@end example
@end deffn


@deffn {Function} skewness_exp (@var{m})
Returns the skewness coefficient of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull skewness coefficient is returned.

@c ===beg===
@c load (distrib)$
@c skewness_exp(m);
@c assume(m>0)$  skewness_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_exp(m);
                                         1
(%o2)                skewness_weibull(1, -)
                                         m
(%i3) assume(m>0)$  skewness_exp(m);
(%o4)                           2
@end example
@end deffn


@deffn {Function} kurtosis_exp (@var{m})
Returns the kurtosis coefficient of an @math{Exponential(m)} random variable, with @math{m>0}.

The @math{Exponential(m)} random variable is equivalent to the @math{Weibull(1,1/m)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull kurtosis coefficient is returned.

@c ===beg===
@c load (distrib)$
@c kurtosis_exp(m);
@c assume(m>0)$  kurtosis_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_exp(m);
                                         1
(%o2)                kurtosis_weibull(1, -)
                                         m
(%i3) assume(m>0)$  kurtosis_exp(m);
(%o4)                           6
@end example
@end deffn


@defvr {Option variable} random_exp_algorithm
Default value: @code{inverse}

This is the selected algorithm for simulating random exponential variates. Implemented algorithms are @code{inverse}, @code{ahrens_cheng} and @code{ahrens_dieter}
@itemize @bullet

@item
@code{inverse}, based on the general inverse method.

@item
@code{ahrens_cheng}, based on the fact that the @math{Exp(m)} random variable is equivalent to the @math{Gamma(1,1/m)}. See @code{random_gamma_algorithm} for details.

@item
@code{ahrens_dieter}, based on algorithm described in Ahrens, J.H. and Dieter, U. (1972) @var{Computer methods for sampling from the exponential and normal distributions.} Comm, ACM, 15, Oct.,  873-882.

@end itemize

See also @code{random_exp}.
@end defvr


@deffn {Function} random_exp (@var{m})
@deffnx {Function} random_exp (@var{m},@var{k})
Returns an @math{Exponential(m)} random variate, with @math{m>0}. Calling @code{random_exp} with a second argument @var{k}, a random sample of size @var{k} will be simulated.

There are three algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_exp_algorithm}, which defaults to @code{inverse}.

See also @code{random_exp_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_lognormal (@var{x},@var{m},@var{s})
Returns the value at @var{x} of the density function of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_lognormal (@var{x},@var{m},@var{s})
Returns the value at @var{x} of the distribution function of a @math{Lognormal(m,s)} random variable, with @math{s>0}. This function is defined in terms of Maxima's built-in error function @code{erf}.

@c ===beg===
@c load (distrib)$
@c assume(x>0, s>0)$  cdf_lognormal(x,m,s);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                           log(x) - m
                       erf(----------)
                           sqrt(2) s     1
(%o3)                  --------------- + -
                              2          2
@end example

See also @code{erf}.
@end deffn


@deffn {Function} quantile_lognormal (@var{q},@var{m},@var{s})
Returns the @var{q}-quantile of a @math{Lognormal(m,s)} random variable, with @math{s>0}; in other words, this is the inverse of @code{cdf_lognormal}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_lognormal (@var{m},@var{s})
Returns the mean of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_lognormal (@var{m},@var{s})
Returns the variance of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_lognormal (@var{m},@var{s})
Returns the standard deviation of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_lognormal (@var{m},@var{s})
Returns the skewness coefficient of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_lognormal (@var{m},@var{s})
Returns the kurtosis coefficient of a @math{Lognormal(m,s)} random variable, with @math{s>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_lognormal (@var{m},@var{s})
@deffnx {Function} random_lognormal (@var{m},@var{s},@var{n})
Returns a @math{Lognormal(m,s)} random variate, with @math{s>0}. Calling @code{random_lognormal} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Log-normal variates are simulated by means of random normal variates. There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_normal_algorithm}, which defaults to @code{box_mueller}.

See also @code{random_normal_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_gamma (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_gamma (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. 

This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_gamma(3,5,21);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_gamma(3,5,21);
(%o2)                  cdf_gamma(3, 5, 21)
(%i3) %,numer;
(%o3)                 4.402663157135039E-7
@end example
@end deffn


@deffn {Function} quantile_gamma (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Gamma(a,b)} random variable, with @math{a,b>0}; in other words, this is the inverse of @code{cdf_gamma}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_gamma (@var{a},@var{b})
Returns the mean of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_gamma (@var{a},@var{b})
Returns the variance of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_gamma (@var{a},@var{b})
Returns the standard deviation of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_gamma (@var{a},@var{b})
Returns the skewness coefficient of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_gamma (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Gamma(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_gamma_algorithm
Default value: @code{ahrens_cheng}

This is the selected algorithm for simulating random gamma variates. Implemented algorithms are @code{ahrens_cheng} and @code{inverse}
@itemize @bullet

@item
@code{ahrens_cheng}, this is a combinantion of two procedures, depending on the value of parameter @var{a}:

For @math{a>=1}, Cheng, R.C.H. and Feast, G.M. (1979). @var{Some simple gamma variate generators}. Appl. Stat., 28, 3, 290-295.

For @math{0<a<1}, Ahrens, J.H. and Dieter, U. (1974). @var{Computer methods for sampling from gamma, beta, poisson and binomial cdf_tributions}. Computing, 12, 223-246.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_gamma}.
@end defvr


@deffn {Function} random_gamma (@var{a},@var{b})
@deffnx {Function} random_gamma (@var{a},@var{b},@var{n})
Returns a @math{Gamma(a,b)} random variate, with @math{a,b>0}. Calling @code{random_gamma} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_gamma_algorithm}, which defaults to @code{ahrens_cheng}.

See also @code{random_gamma_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_beta (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} cdf_beta (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Beta(a,b)} random variable, with @math{a,b>0}. 

This function has no closed form and it is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_beta(1/3,15,2);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_beta(1/3,15,2);
                                 1
(%o2)                   cdf_beta(-, 15, 2)
                                 3
(%i3) %,numer;
(%o3)                 7.666089131388224E-7
@end example
@end deffn


@deffn {Function} quantile_beta (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Beta(a,b)} random variable, with @math{a,b>0}; in other words, this is the inverse of @code{cdf_beta}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_beta (@var{a},@var{b})
Returns the mean of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_beta (@var{a},@var{b})
Returns the variance of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_beta (@var{a},@var{b})
Returns the standard deviation of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_beta (@var{a},@var{b})
Returns the skewness coefficient of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_beta (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Beta(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_beta_algorithm
Default value: @code{cheng}

This is the selected algorithm for simulating random beta variates. Implemented algorithms are @code{cheng}, @code{inverse} and @code{ratio}
@itemize @bullet

@item
@code{cheng}, this is the algorithm defined in Cheng, R.C.H.  (1978). @var{Generating Beta Variates with Nonintegral Shape Parameters}. Communications of the ACM, 21:317-322

@item
@code{inverse}, based on the general inverse method.

@item
@code{ratio}, based on the fact that if @var{X} is a random variable @math{Gamma(a,1)} and @var{Y} is @math{Gamma(b,1)}, then the ratio @math{X/(X+Y)} is distributed as @math{Beta(a,b)}.

@end itemize

See also @code{random_beta}.
@end defvr


@deffn {Function} random_beta (@var{a},@var{b})
@deffnx {Function} random_beta (@var{a},@var{b},@var{n})
Returns a @math{Beta(a,b)} random variate, with @math{a,b>0}. Calling @code{random_beta} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

There are three algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_beta_algorithm}, which defaults to @code{cheng}.

See also @code{random_beta_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} pdf_continuous_uniform (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_continuous_uniform (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_continuous_uniform (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}; in other words, this is the inverse of @code{cdf_continuous_uniform}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_continuous_uniform (@var{a},@var{b})
Returns the mean of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_continuous_uniform (@var{a},@var{b})
Returns the variance of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_continuous_uniform (@var{a},@var{b})
Returns the standard deviation of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_continuous_uniform (@var{a},@var{b})
Returns the skewness coefficient of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_continuous_uniform (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Continuous Uniform(a,b)} random variable, with @math{a<b}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_continuous_uniform (@var{a},@var{b})
@deffnx {Function} random_continuous_uniform (@var{a},@var{b},@var{n})
Returns a @math{Continuous Uniform(a,b)} random variate, with @math{a<b}. Calling @code{random_continuous_uniform} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

This is a direct application of the @code{random} built-in Maxima function.

See also @code{random}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_logistic (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_logistic (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_logistic (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Logistic(a,b)} random variable , with @math{b>0}; in other words, this is the inverse of @code{cdf_logistic}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} meanlog (@var{a},@var{b})
Returns the mean of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_logistic (@var{a},@var{b})
Returns the variance of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_logistic (@var{a},@var{b})
Returns the standard deviation of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_logistic (@var{a},@var{b})
Returns the skewness coefficient of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_logistic (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Logistic(a,b)} random variable , with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_logistic (@var{a},@var{b})
@deffnx {Function} random_logistic (@var{a},@var{b},@var{n})
Returns a @math{Logistic(a,b)} random variate, with @math{b>0}. Calling @code{random_logistic} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_pareto (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Pareto(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_pareto (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Pareto(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_pareto (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Pareto(a,b)} random variable, with @math{a,b>0}; in other words, this is the inverse of @code{cdf_pareto}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_pareto (@var{a},@var{b})
Returns the mean of a @math{Pareto(a,b)} random variable, with @math{a>1,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_pareto (@var{a},@var{b})
Returns the variance of a @math{Pareto(a,b)} random variable, with @math{a>2,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_pareto (@var{a},@var{b})
Returns the standard deviation of a @math{Pareto(a,b)} random variable, with @math{a>2,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} skewness_pareto (@var{a},@var{b})
Returns the skewness coefficient of a @math{Pareto(a,b)} random variable, with @math{a>3,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_pareto (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Pareto(a,b)} random variable, with @math{a>4,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_pareto (@var{a},@var{b})
@deffnx {Function} random_pareto (@var{a},@var{b},@var{n})
Returns a @math{Pareto(a,b)} random variate, with @math{a>0,b>0}. Calling @code{random_pareto} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_weibull (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_weibull (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_weibull (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Weibull(a,b)} random variable, with @math{a,b>0}; in other words, this is the inverse of @code{cdf_weibull}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_weibull (@var{a},@var{b})
Returns the mean of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_weibull (@var{a},@var{b})
Returns the variance of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@deffn {Function} std_weibull (@var{a},@var{b})
Returns the standard deviation of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} skewness_weibull (@var{a},@var{b})
Returns the skewness coefficient of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_weibull (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Weibull(a,b)} random variable, with @math{a,b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_weibull (@var{a},@var{b})
@deffnx {Function} random_weibull (@var{a},@var{b},@var{n})
Returns a @math{Weibull(a,b)} random variate, with @math{a,b>0}. Calling @code{random_weibull} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} pdf_rayleigh (@var{x},@var{b})
Returns the value at @var{x} of the density function of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull density is returned.

@c ===beg===
@c load (distrib)$
@c pdf_rayleigh(x,b);
@c assume(x>0,b>0)$ pdf_rayleigh(x,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_rayleigh(x,b);
                                        1
(%o2)                 pdf_weibull(x, 2, -)
                                        b
(%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                    2  2
                           2     - b  x
(%o4)                   2 b  x %e
@end example
@end deffn


@deffn {Function} cdf_rayleigh (@var{x},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull distribution is returned.

@c ===beg===
@c load (distrib)$
@c cdf_rayleigh(x,b);
@c assume(x>0,b>0)$ cdf_rayleigh(x,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_rayleigh(x,b);
                                        1
(%o2)                 cdf_weibull(x, 2, -)
                                        b
(%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                   2  2
                                - b  x
(%o4)                     1 - %e
@end example
@end deffn


@deffn {Function} quantile_rayleigh (@var{q},@var{b})
Returns the @var{q}-quantile of a @math{Rayleigh(b)} random variable, with @math{b>0}; in other words, this is the inverse of @code{cdf_rayleigh}. Argument @var{q} must be an element of @math{[0,1]}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull quantile is returned.

@c ===beg===
@c load (distrib)$
@c quantile_rayleigh(0.99,b);
@c assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_rayleigh(0.99,b);
                                            1
(%o2)             quantile_weibull(0.99, 2, -)
                                            b
(%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                        2.145966026289347
(%o4)                   -----------------
                                b
@end example
@end deffn


@deffn {Function} mean_rayleigh (@var{b})
Returns the mean of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull mean is returned.

@c ===beg===
@c load (distrib)$
@c mean_rayleigh(b);
@c assume(b>0)$ mean_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_rayleigh(b);
                                       1
(%o2)                  mean_weibull(2, -)
                                       b
(%i3) assume(b>0)$ mean_rayleigh(b);
                            sqrt(%pi)
(%o4)                       ---------
                               2 b
@end example
@end deffn


@deffn {Function} var_rayleigh (@var{b})
Returns the variance of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull variance is returned.

@c ===beg===
@c load (distrib)$
@c var_rayleigh(b);
@c assume(b>0)$ var_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_rayleigh(b);
                                       1
(%o2)                   var_weibull(2, -)
                                       b
(%i3) assume(b>0)$ var_rayleigh(b);
                                 %pi
                             1 - ---
                                  4
(%o4)                        -------
                                2
                               b
@end example
@end deffn


@deffn {Function} std_rayleigh (@var{b})
Returns the standard deviation of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull standard deviation is returned.

@c ===beg===
@c load (distrib)$
@c std_rayleigh(b);
@c assume(b>0)$ std_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_rayleigh(b);
                                       1
(%o2)                   std_weibull(2, -)
                                       b
(%i3) assume(b>0)$ std_rayleigh(b);
                                   %pi
                          sqrt(1 - ---)
                                    4
(%o4)                     -------------
                                b
@end example
@end deffn


@deffn {Function} skewness_rayleigh (@var{b})
Returns the skewness coefficient of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull skewness coefficient is returned.

@c ===beg===
@c load (distrib)$
@c skewness_rayleigh(b);
@c assume(b>0)$ skewness_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_rayleigh(b);
                                         1
(%o2)                skewness_weibull(2, -)
                                         b
(%i3) assume(b>0)$ skewness_rayleigh(b);
                         3/2
                      %pi      3 sqrt(%pi)
                      ------ - -----------
                        4           4
(%o4)                 --------------------
                               %pi 3/2
                          (1 - ---)
                                4
@end example
@end deffn


@deffn {Function} kurtosis_rayleigh (@var{b})
Returns the kurtosis coefficient of a @math{Rayleigh(b)} random variable, with @math{b>0}.

The @math{Rayleigh(b)} random variable is equivalent to the @math{Weibull(2,1/b)}, therefore when Maxima has not enough information to get the result, a noun form based on the Weibull kurtosis coefficient is returned.

@c ===beg===
@c load (distrib)$
@c kurtosis_rayleigh(b);
@c assume(b>0)$ kurtosis_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_rayleigh(b);
                                         1
(%o2)                kurtosis_weibull(2, -)
                                         b
(%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                  2
                             3 %pi
                         2 - ------
                               16
(%o4)                    ---------- - 3
                              %pi 2
                         (1 - ---)
                               4
@end example
@end deffn


@deffn {Function} random_rayleigh (@var{b})
@deffnx {Function} random_rayleigh (@var{b},@var{n})
Returns a @math{Rayleigh(b)} random variate, with @math{b>0}. Calling @code{random_rayleigh} with a second argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} pdf_laplace (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_laplace (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_laplace (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Laplace(a,b)} random variable, with @math{b>0}; in other words, this is the inverse of @code{cdf_laplace}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_laplace (@var{a},@var{b})
Returns the mean of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_laplace (@var{a},@var{b})
Returns the variance of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_laplace (@var{a},@var{b})
Returns the standard deviation of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_laplace (@var{a},@var{b})
Returns the skewness coefficient of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_laplace (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Laplace(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_laplace (@var{a},@var{b})
@deffnx {Function} random_laplace (@var{a},@var{b},@var{n})
Returns a @math{Laplace(a,b)} random variate, with @math{b>0}. Calling @code{random_laplace} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} pdf_cauchy (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Cauchy(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_cauchy (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Cauchy(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_cauchy (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Cauchy(a,b)} random variable, with @math{b>0}; in other words, this is the inverse of @code{cdf_cauchy}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_cauchy (@var{a},@var{b})
@deffnx {Function} random_cauchy (@var{a},@var{b},@var{n})
Returns a @math{Cauchy(a,b)} random variate, with @math{b>0}. Calling @code{random_cauchy} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn



@deffn {Function} pdf_gumbel (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the density function of a @math{Gumbel(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_gumbel (@var{x},@var{a},@var{b})
Returns the value at @var{x} of the distribution function of a @math{Gumbel(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_gumbel (@var{q},@var{a},@var{b})
Returns the @var{q}-quantile of a @math{Gumbel(a,b)} random variable, with @math{b>0}; in other words, this is the inverse of @code{cdf_gumbel}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_gumbel (@var{a},@var{b})
Returns the mean of a @math{Gumbel(a,b)} random variable, with @math{b>0}.

@c ===beg===
@c load (distrib)$
@c assume(b>0)$  mean_gumbel(a,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(b>0)$  mean_gumbel(a,b);
(%o3)                     %gamma b + a
@end example
where symbol @code{%gamma} stands for the Euler-Mascheroni constant. See also @code{%gamma}.
@end deffn


@deffn {Function} var_gumbel (@var{a},@var{b})
Returns the variance of a @math{Gumbel(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_gumbel (@var{a},@var{b})
Returns the standard deviation of a @math{Gumbel(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_gumbel (@var{a},@var{b})
Returns the skewness coefficient of a @math{Gumbel(a,b)} random variable, with @math{b>0}.

@c ===beg===
@c load (distrib)$
@c assume(b>0)$ skewness_gumbel(a,b);
@c numer:true$ skewness_gumbel(a,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(b>0)$ skewness_gumbel(a,b);
                       12 sqrt(6) zeta(3)
(%o3)                  ------------------
                                 3
                              %pi
(%i4) numer:true$ skewness_gumbel(a,b);
(%o5)                   1.139547099404649
@end example
where @code{zeta} stands for the Riemann's zeta function.
@end deffn


@deffn {Function} kurtosis_gumbel (@var{a},@var{b})
Returns the kurtosis coefficient of a @math{Gumbel(a,b)} random variable, with @math{b>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_gumbel (@var{a},@var{b})
@deffnx {Function} random_gumbel (@var{a},@var{b},@var{n})
Returns a @math{Gumbel(a,b)} random variate, with @math{b>0}. Calling @code{random_gumbel} with a third argument @var{n}, a random sample of size @var{n} will be simulated.

Only the inverse method is implemented. To make use of this function, write first @code{load(distrib)}.
@end deffn


@node Functions and Variables for discrete distributions,  , Functions and Variables for continuous distributions, distrib
@section Functions and Variables for discrete distributions


@deffn {Function} pdf_binomial (@var{x},@var{n},@var{p})
Returns the value at @var{x} of the probability function of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_binomial (@var{x},@var{n},@var{p})
Returns the value at @var{x} of the distribution function of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer.

This function is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_binomial(5,7,1/6);
@c cdf_binomial(5,7,1/6), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_binomial(5,7,1/6);
                                         1
(%o2)                 cdf_binomial(5, 7, -)
                                         6
(%i3) cdf_binomial(5,7,1/6), numer;
(%o3)                   .9998713991769548
@end example
@end deffn


@deffn {Function} quantile_binomial (@var{q},@var{n},@var{p})
Returns the @var{q}-quantile of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer; in other words, this is the inverse of @code{cdf_binomial}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_binomial (@var{n},@var{p})
Returns the mean of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_binomial (@var{n},@var{p})
Returns the variance of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_binomial (@var{n},@var{p})
Returns the standard deviation of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_binomial (@var{n},@var{p})
Returns the skewness coefficient of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_binomial (@var{n},@var{p})
Returns the kurtosis coefficient of a @math{Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_binomial_algorithm
Default value: @code{kachit}

This is the selected algorithm for simulating random binomial variates. Implemented algorithms are @code{kachit}, @code{bernoulli} and @code{inverse}:
@itemize @bullet

@item
@code{kachit}, based on algorithm described in Kachitvichyanukul, V. and Schmeiser, B.W. (1988) @var{Binomial Random Variate Generation}. Communications of the ACM, 31, Feb., 216.

@item
@code{bernoulli}, based on simulation of Bernoulli trials.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_binomial}.
@end defvr


@deffn {Function} random_binomial (@var{n},@var{p})
@deffnx {Function} random_binomial (@var{n},@var{p},@var{m})
Returns a @math{Binomial(n,p)} random variate, with @math{0<p<1} and @math{n} a positive integer. Calling @code{random_binomial} with a third argument @var{m}, a random sample of size @var{m} will be simulated.

There are three algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_binomial_algorithm}, which defaults to @code{kachit}.

See also @code{random_binomial_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_poisson (@var{x},@var{m})
Returns the value at @var{x} of the probability function of a @math{Poisson(m)} random variable, with @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_poisson (@var{x},@var{m})
Returns the value at @var{x} of the distribution function of a @math{Poisson(m)} random variable, with @math{m>0}.

This function is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_poisson(3,5);
@c cdf_poisson(3,5), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_poisson(3,5);
(%o2)                   cdf_poisson(3, 5)
(%i3) cdf_poisson(3,5), numer;
(%o3)                   .2650259152973617
@end example
@end deffn


@deffn {Function} quantile_poisson (@var{q},@var{m})
Returns the @var{q}-quantile of a @math{Poisson(m)} random variable, with @math{m>0}; in other words, this is the inverse of @code{cdf_poisson}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_poisson (@var{m})
Returns the mean of a @math{Poisson(m)} random variable, with  @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_poisson (@var{m})
Returns the variance of a @math{Poisson(m)} random variable, with  @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_poisson (@var{m})
Returns the standard deviation of a @math{Poisson(m)} random variable, with @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_poisson (@var{m})
Returns the skewness coefficient of a @math{Poisson(m)} random variable, with @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_poisson (@var{m})
Returns the kurtosis coefficient of a Poisson random variable  @math{Poi(m)}, with @math{m>0}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_poisson_algorithm
Default value: @code{ahrens_dieter}

This is the selected algorithm for simulating random Poisson variates. Implemented algorithms are @code{ahrens_dieter} and @code{inverse}:
@itemize @bullet

@item
@code{ahrens_dieter}, based on algorithm described in Ahrens, J.H. and Dieter, U. (1982) @var{Computer Generation of Poisson Deviates From Modified Normal Distributions}. ACM Trans. Math. Software, 8, 2, June,163-179.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_poisson}.
@end defvr


@deffn {Function} random_poisson (@var{m})
@deffnx {Function} random_poisson (@var{m},@var{n})
Returns a @math{Poisson(m)} random variate, with @math{m>0}. Calling @code{random_poisson} with a second argument @var{n}, a random sample of size @var{n} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_poisson_algorithm}, which defaults to @code{ahrens_dieter}.

See also @code{random_poisson_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_bernoulli (@var{x},@var{p})
Returns the value at @var{x} of the probability function of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial probability function is returned.

@c ===beg===
@c load (distrib)$
@c pdf_bernoulli(1,p);
@c assume(0<p,p<1)$ pdf_bernoulli(1,p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_bernoulli(1,p);
(%o2)                 pdf_binomial(1, 1, p)
(%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
(%o4)                           p
@end example
@end deffn


@deffn {Function} cdf_bernoulli (@var{x},@var{p})
Returns the value at @var{x} of the distribution function of a @math{Bernoulli(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_bernoulli (@var{q},@var{p})
Returns the @var{q}-quantile of a @math{Bernoulli(p)} random variable, with @math{0<p<1}; in other words, this is the inverse of @code{cdf_bernoulli}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_bernoulli (@var{p})
Returns the mean of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial mean is returned.

@c ===beg===
@c load (distrib)$
@c mean_bernoulli(p);
@c assume(0<p,p<1)$ mean_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_bernoulli(p);
(%o2)                  mean_binomial(1, p)
(%i3) assume(0<p,p<1)$ mean_bernoulli(p);
(%o4)                           p
@end example
@end deffn


@deffn {Function} var_bernoulli (@var{p})
Returns the variance of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial variance is returned.

@c ===beg===
@c load (distrib)$
@c var_bernoulli(p);
@c assume(0<p,p<1)$ var_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_bernoulli(p);
(%o2)                  var_binomial(1, p)
(%i3) assume(0<p,p<1)$ var_bernoulli(p);
(%o4)                       (1 - p) p
@end example
@end deffn


@deffn {Function} std_bernoulli (@var{p})
Returns the standard deviation of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial standard deviation is returned.

@c ===beg===
@c load (distrib)$
@c std_bernoulli(p);
@c assume(0<p,p<1)$ std_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_bernoulli(p);
(%o2)                  std_binomial(1, p)
(%i3) assume(0<p,p<1)$ std_bernoulli(p);
(%o4)                  sqrt(1 - p) sqrt(p)
@end example
@end deffn


@deffn {Function} skewness_bernoulli (@var{p})
Returns the skewness coefficient of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial skewness coefficient is returned.

@c ===beg===
@c load (distrib)$
@c skewness_bernoulli(p);
@c assume(0<p,p<1)$ skewness_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_bernoulli(p);
(%o2)                skewness_binomial(1, p)
(%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                             1 - 2 p
(%o4)                  -------------------
                       sqrt(1 - p) sqrt(p)
@end example
@end deffn


@deffn {Function} kurtosis_bernoulli (@var{p})
Returns the kurtosis coefficient of a @math{Bernoulli(p)} random variable, with @math{0<p<1}.

The @math{Bernoulli(p)} random variable is equivalent to the @math{Binomial(1,p)}, therefore when Maxima has not enough information to get the result, a noun form based on the binomial kurtosis coefficient is returned.

@c ===beg===
@c load (distrib)$
@c kurtosis_bernoulli(p);
@c assume(0<p,p<1)$ kurtosis_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_bernoulli(p);
(%o2)                kurtosis_binomial(1, p)
(%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                         1 - 6 (1 - p) p
(%o4)                    ---------------
                            (1 - p) p
@end example
@end deffn


@deffn {Function} random_bernoulli (@var{p})
@deffnx {Function} random_bernoulli (@var{p},@var{n})
Returns a @math{Bernoulli(p)} random variate, with @math{0<p<1}. Calling @code{random_bernoulli} with a second argument @var{n}, a random sample of size @var{n} will be simulated.

This is a direct application of the @code{random} built-in Maxima function.

See also @code{random}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_geometric (@var{x},@var{p})
Returns the value at @var{x} of the probability function of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_geometric (@var{x},@var{p})
Returns the value at @var{x} of the distribution function of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_geometric (@var{q},@var{p})
Returns the @var{q}-quantile of a @math{Geometric(p)} random variable, with @math{0<p<1}; in other words, this is the inverse of @code{cdf_geometric}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_geometric (@var{p})
Returns the mean of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_geometric (@var{p})
Returns the variance of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_geometric (@var{p})
Returns the standard deviation of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_geometric (@var{p})
Returns the skewness coefficient of a @math{Geometric(p)} random variable, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_geometric (@var{p})
Returns the kurtosis coefficient of a geometric random variable  @math{Geo(p)}, with @math{0<p<1}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_geometric_algorithm
Default value: @code{bernoulli}

This is the selected algorithm for simulating random geometric variates. Implemented algorithms are @code{bernoulli}, @code{devroye} and @code{inverse}:
@itemize @bullet

@item
@code{bernoulli}, based on simulation of Bernoulli trials.

@item
@code{devroye}, based on algorithm described in Devroye, L. (1986) @var{Non-Uniform Random Variate Generation.} Springer Verlag, p. 480.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_geometric}.
@end defvr


@deffn {Function} random_geometric (@var{p})
@deffnx {Function} random_geometric (@var{p},@var{n})
Returns a @math{Geometric(p)} random variate, with @math{0<p<1}. Calling @code{random_geometric} with a second argument @var{n}, a random sample of size @var{n} will be simulated.

There are three algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_geometric_algorithm}, which defaults to @code{bernoulli}.

See also @code{random_geometric_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_discrete_uniform (@var{x},@var{n})
Returns the value at @var{x} of the probability function of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_discrete_uniform (@var{x},@var{n})
Returns the value at @var{x} of the distribution function of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_discrete_uniform (@var{q},@var{n})
Returns the @var{q}-quantile of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer; in other words, this is the inverse of @code{cdf_discrete_uniform}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_discrete_uniform (@var{n})
Returns the mean of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_discrete_uniform (@var{n})
Returns the variance of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_discrete_uniform (@var{n})
Returns the standard deviation of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_discrete_uniform (@var{n})
Returns the skewness coefficient of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_discrete_uniform (@var{n})
Returns the kurtosis coefficient of a @math{Discrete Uniform(n)} random variable, with @math{n} a strictly positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} random_discrete_uniform (@var{n})
@deffnx {Function} random_discrete_uniform (@var{n},@var{m})
Returns a @math{Discrete Uniform(n)} random variate, with @math{n} a strictly positive integer. Calling @code{random_discrete_uniform} with a second argument @var{m}, a random sample of size @var{m} will be simulated.

This is a direct application of the @code{random} built-in Maxima function.

See also @code{random}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_hypergeometric (@var{x},@var{n1},@var{n2},@var{n})
Returns the value at @var{x} of the probability function of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_hypergeometric (@var{x},@var{n1},@var{n2},@var{n})
Returns the value at @var{x} of the distribution function of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} quantile_hypergeometric (@var{q},@var{n1},@var{n2},@var{n})
Returns the @var{q}-quantile of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}; in other words, this is the inverse of @code{cdf_hypergeometric}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_hypergeometric (@var{n1},@var{n2},@var{n})
Returns the mean of a discrete uniform random variable @math{Hyp(n1,n2,n)}, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_hypergeometric (@var{n1},@var{n2},@var{n})
Returns the variance of a hypergeometric  random variable @math{Hyp(n1,n2,n)}, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_hypergeometric (@var{n1},@var{n2},@var{n})
Returns the standard deviation of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_hypergeometric (@var{n1},@var{n2},@var{n})
Returns the skewness coefficient of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_hypergeometric (@var{n1},@var{n2},@var{n})
Returns the kurtosis coefficient of a @math{Hypergeometric(n1,n2,n)} random variable, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. To make use of this function, write first @code{load(distrib)}.
@end deffn

@defvr {Option variable} random_hypergeometric_algorithm
Default value: @code{kachit}

This is the selected algorithm for simulating random hypergeometric variates. Implemented algorithms are @code{kachit} and @code{inverse}:
@itemize @bullet

@item
@code{kachit}, based on algorithm described in Kachitvichyanukul, V., Schmeiser, B.W. (1985) @var{Computer generation of hypergeometric random variates.} Journal of Statistical Computation and Simulation 22, 127-145.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_hypergeometric}.
@end defvr


@deffn {Function} random_hypergeometric (@var{n1},@var{n2},@var{n})
@deffnx {Function} random_hypergeometric (@var{n1},@var{n2},@var{n},@var{m})
Returns a @math{Hypergeometric(n1,n2,n)} random variate, with @var{n1}, @var{n2} and @var{n} non negative integers and @math{n<=n1+n2}. Calling @code{random_hypergeometric} with a fourth argument @var{m}, a random sample of size @var{m} will be simulated.

There are two algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_hypergeometric_algorithm}, which defaults to @code{kachit}.

See also @code{random_hypergeometric_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} pdf_negative_binomial (@var{x},@var{n},@var{p})
Returns the value at @var{x} of the probability function of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} cdf_negative_binomial (@var{x},@var{n},@var{p})
Returns the value at @var{x} of the distribution function of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer.

This function is numerically computed if the global variable @code{numer} equals @code{true},  otherwise it returns a nominal expression.

@c ===beg===
@c load (distrib)$
@c cdf_negative_binomial(3,4,1/8);
@c cdf_negative_binomial(3,4,1/8), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_negative_binomial(3,4,1/8);
                                             1
(%o2)            cdf_negative_binomial(3, 4, -)
                                             8
(%i3) cdf_negative_binomial(3,4,1/8), numer;
(%o3)                  .006238937377929698
@end example
@end deffn


@deffn {Function} quantile_negative_binomial (@var{q},@var{n},@var{p})
Returns the @var{q}-quantile of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer; in other words, this is the inverse of @code{cdf_negative_binomial}. Argument @var{q} must be an element of @math{[0,1]}. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} mean_negative_binomial (@var{n},@var{p})
Returns the mean of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} var_negative_binomial (@var{n},@var{p})
Returns the variance of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} std_negative_binomial (@var{n},@var{p})
Returns the standard deviation of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} skewness_negative_binomial (@var{n},@var{p})
Returns the skewness coefficient of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@deffn {Function} kurtosis_negative_binomial (@var{n},@var{p})
Returns the kurtosis coefficient of a @math{Negative Binomial(n,p)} random variable, with @math{0<p<1} and @math{n} a positive integer. To make use of this function, write first @code{load(distrib)}.
@end deffn


@defvr {Option variable} random_negative_binomial_algorithm
Default value: @code{bernoulli}

This is the selected algorithm for simulating random negative binomial variates. Implemented algorithms are @code{devroye}, @code{bernoulli} and @code{inverse}:
@itemize @bullet

@item
@code{devroye}, based on algorithm described in Devroye, L. (1986) @var{Non-Uniform Random Variate Generation}. Springer Verlag, p. 480.

@item
@code{bernoulli}, based on simulation of Bernoulli trials.

@item
@code{inverse}, based on the general inverse method.

@end itemize

See also @code{random_negative_binomial}.
@end defvr


@deffn {Function} random_negative_binomial (@var{n},@var{p})
@deffnx {Function} random_negative_binomial (@var{n},@var{p},@var{m})
Returns a @math{Negative Binomial(n,p)} random variate, with @math{0<p<1} and @math{n} a positive integer. Calling @code{random_negative_binomial} with a third argument @var{m}, a random sample of size @var{m} will be simulated.

There are three algorithms implemented for this function, the one to be used can be selected giving a certain value to the global variable @code{random_negative_binomial_algorithm}, which defaults to @code{bernoulli}.

See also @code{random_negative_binomial_algorithm}. To make use of this function, write first @code{load(distrib)}.
@end deffn
