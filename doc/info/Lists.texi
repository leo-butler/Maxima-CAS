@menu
* Introduction to Lists::       
* Definitions for Lists::       
@end menu

@node Introduction to Lists, Definitions for Lists, Lists, Lists
@section Introduction to Lists
Lists are the basic building block for Maxima and Lisp.   All data types
other than arrays, hash tables, numbers are represented as Lisp lists,
These Lisp lists have the form
@example
((MPLUS) $A 2)
@end example
@noindent
to indicate an expression @code{a+2}.   At Maxima level one would see
the infix notation @code{a+2}.   Maxima also has lists which are printed
as
@example
[1, 2, 7, x+y]
@end example
@noindent
for a list with 4 elements.   Internally this corresponds to a Lisp list
of the form
@example
((MLIST) 1  2  7  ((MPLUS)  $X $Y ))
@end example
@noindent
The flag which denotes the type field of the Maxima expression is a list
itself, since after it has been through the simplifier the list would become
@example
((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))
@end example


@c end concepts Lists

@node Definitions for Lists,  , Introduction to Lists, Lists
@section Definitions for Lists

@c @node append, assoc, Lists, Lists
@c @unnumberedsec 
@defun append (list1, list2, ...)
returns a single list of the elements of
@code{list1} followed by the elements of @code{list2},...  APPEND also works on
general expressions, e.g. @code{append(F(A,B), F(C,D,E)); -> F(A,B,C,D,E)}.
Do @code{example(append);} for an example.

@end defun
@c @node assoc, atom, append, Lists
@c @unnumberedsec 
@defun assoc (key, list, default)
This function searches for the @code{key} in the left hand side of the input @code{list}
of the form @code{[x,y,z...]} where each of the @code{list} elements is an expression of
a binary operand and 2 elements.  For example @code{x=1}, @code{2^3}, @code{[a,b]} etc.
The @code{key} is checked againts the first operand.  @code{assoc} returns the second
operand if the @code{key} is found.  If the @code{key} is not found it
either returns the @code{default} value.  @code{default} is optional
and defaults to @code{false}.

@end defun
@c @node atom, cons, append, Lists
@c @unnumberedsec 
@defun atom (exp)
is @code{true} if @code{exp} is atomic (i.e. a number, name or string) else
FALSE.  Thus @code{atom(5)} is @code{true} while @code{atom(a[1])} and @code{atom(sin(x))} are
@code{false} (asuming @code{a[1]} and @code{x} are unbound).

@end defun
@c @node cons, copylist, atom, Lists
@c @unnumberedsec 
@defun cons (exp, list)
returns a new list constructed of the element @code{exp} as
its first element, followed by the elements of @code{list}.  @code{cons} also works
on other expressions, e.g. @code{cons(x, f(a,b,c));}  ->  @code{f(x,a,b,c)}.

@end defun
@c @node copylist, delete, cons, Lists
@c @unnumberedsec 
@defun copylist (list)
creates a copy of the list @code{list}.

@end defun
@c @node delete, endcons, copylist, Lists
@c @unnumberedsec 
@defun delete (exp1, exp2)
removes all occurrences of @code{exp1} from @code{exp2}.  @code{exp1}
may be a term of @code{exp2} (if it is a sum) or a factor of @code{exp2} (if it is a
product).
@example
(%i1)  delete(sin(x),x+sin(x)+y);
(%o1)               y + x

@end example
@code{delete(exp1, exp2, n)} removes the first @code{n} occurrences of
@code{exp1} from @code{exp2}.  If there are fewer than @code{n}
occurrences of @code{exp1} in @code{exp2} then all occurrences will be deleted.
@example
(%i1)  delete(a,f(a,b,c,d,a));
(%o1)             f(b, d)
(%i2)  delete(a,f(a,b,c,d,a),2);
(%o2)           f(b, d, a)

@end example
@end defun
@c @node endcons, every, delete, Lists
@c @unnumberedsec 
@defun endcons (exp, list)
returns a new list consisting of the elements of
@code{list} followed by @code{exp}.  @code{endcons} also works on general expressions, e.g.
@code{endcons(x, f(a,b,c));}  ->  @code{f(a,b,c,x)}.

@end defun
@c @node every, first, delete, Lists
@c @unnumberedsec 
@defun every (exp)
This function takes a list, or a positive number of arguments and returns
@code{true} if all its arguments are not @code{false}.

@end defun

@c @node first, flatten, every, Lists
@c @unnumberedsec 
@defun first (exp) second (exp) .. tenth (exp)
yields the first part of exp which may result in the first
element of a list, the first row of a matrix, the first term of a sum,
etc.  Note that @code{first} and its related functions, @code{rest} and @code{last}, work
on the form of @code{exp} which is displayed not the form which is typed on
input.  If the variable @code{inflag [false]} is set to @code{true} however, these
functions will look at the internal form of @code{exp}.  Note that the
simplifier re-orders expressions.  Thus @code{first(x+y)} will be @code{x} if @code{inflag}
is @code{TRUE} and @code{Y} if @code{inflag} is @code{false} (@code{first(y+x)} gives the same
results).  The functions @code{second} .. @code{tenth} yield the second through the
tenth part of their input argument.

@end defun
@c @node flatten, get, first, Lists
@c @unnumberedsec 
@defun flatten (exp)
Takes a list of the form [[1,2],[3,4]] and returns [1,2,3,4].

@end defun
@c @node get, last, first, Lists
@c @unnumberedsec 
@defun get (a, i)
retrieves the user property indicated by @code{i} associated with
atom @code{a} or returns @code{false} if a doesn't have property @code{i}.
@example
(%i1) put (%e, 'transcendental, 'type);
(%o1)                      transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error (expr, "is not numeric.")) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)    [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)       [transcendental, [algebraic, transcendental]]
@end example

@end defun
@c @node last, length, get, Lists
@c @unnumberedsec 
@defun last (exp)
yields the last part (term, row, element, etc.) of the @code{exp}.

@end defun
@c @node length, listarith, last, Lists
@c @unnumberedsec 
@defun length (exp)
gives (by default) the number of parts in the external
(displayed) form of @code{exp}.  For lists this is the number of elements,
for matrices it is the number of rows, and for sums it is the number
of terms (see @code{dispform}).  The @code{length} command is affected by the
@code{inflag [false]} switch.  So, e.g. @code{length(a/(b*c));} gives 2 if
@code{inflag} is @code{false} (Assuming @code{exptdispflag} is @code{true}), but 3 if @code{inflag} is
@code{true} (the internal representation is essentially @code{a*b^-1*c^-1}).

@end defun
@c @node listarith, listp, length, Lists
@c @unnumberedsec 
@defvar listarith
 default: @code{[true]} - if @code{false} causes any arithmetic operations
with lists to be suppressed; when @code{true}, list-matrix operations are
contagious causing lists to be converted to matrices yielding a result
which is always a matrix.  However, list-list operations should return
lists.

@end defvar
@c @node listp, makelist, listarith, Lists
@c @unnumberedsec 
@defun listp (exp)
is @code{true} if @code{exp} is a list else @code{false}.

@end defun
@c @node makelist, member, listp, Lists
@c @unnumberedsec 
@defun makelist (exp,var,lo,hi)
returns a list as value.  @code{makelist} may be called as
@code{makelist(exp,var,lo,hi)} [@code{lo} and @code{hi} must be integers], or as
@code{makelist(exp,var,list)}.  In the first case @code{makelist} is analogous to
@code{sum}, whereas in the second case @code{makelist} is similar to @code{map}.  Examples:
@example
(%i1) makelist(concat(x,i),i,1,6);
(%o1)          [x1, x2, x3, x4, x5, x6]
(%i2) makelist(x=y,y,[a,b,c]);
(%o2)            [x = a, x = b, x = c]
@end example

@end defun
@c @node member, rest, makelist, Lists
@c @unnumberedsec 
@defun member (exp, list)
returns @code{true} if @code{exp} occurs as a member of @code{list} (not
within a member).  Otherwise @code{false} is returned.  @code{member} also works on
non-list expressions, e.g. @code{member(b,f(a,b,c));}  ->  @code{true}.

@end defun
@c @node rest, reverse, member, Lists
@c @unnumberedsec 
@defun rest (exp, n)
yields @code{exp} with its first @code{n} elements removed if @code{n} is
positive and its last @code{-n} elements removed if @code{n} is negative.  If @code{n} is 1
it may be omitted.  @code{exp} may be a list, matrix, or other expression.

@end defun
@c @node reverse,  , rest, Lists
@c @unnumberedsec  
@defun reverse (list)
reverses the order of the members of the @code{list} (not
the members themselves).  @code{reverse} also works on general expressions,
e.g.  @code{reverse(a=b);} gives @code{b=a}.
@code{reverse} default: @code{[false]} - in the Plotting functions, if @code{true} cause a
left-handed coordinate system to be assumed.

@end defun
