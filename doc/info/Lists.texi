
@menu
* Introduction to Lists::
* Definitions for Lists::
@end menu

@node Introduction to Lists, Definitions for Lists, Lists, Lists
@section Introduction to Lists

Lists are the basic building block for Maxima and Lisp.   All data types
other than arrays, hash tables, numbers are represented as Lisp lists,
These Lisp lists have the form

@example
((MPLUS) $A 2)
@end example

@noindent
to indicate an expression @code{a+2}.   At Maxima level one would see
the infix notation @code{a+2}.   Maxima also has lists which are printed
as

@example
[1, 2, 7, x+y]
@end example

@noindent
for a list with 4 elements.   Internally this corresponds to a Lisp list
of the form

@example
((MLIST) 1  2  7  ((MPLUS)  $X $Y ))
@end example

@noindent
The flag which denotes the type field of the Maxima expression is a list
itself, since after it has been through the simplifier the list would become

@example
((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))
@end example

@node Definitions for Lists,  , Introduction to Lists, Lists
@section Definitions for Lists

@defun append (list1, list2, ...)
returns a single list of the elements of @code{list1} followed
by the elements of @code{list2},...  @code{append} also works on
general expressions, e.g. @code{append(f(a,b), f(c,d,e));} ->
@code{f(a,b,c,d,e)}.

Do @code{example(append);} for an example.

@end defun

@defun assoc (key, list, default)
@defunx assoc (key, list)
This function searches for the @code{key} in the left hand side of the input @code{list}
of the form @code{[x,y,z,...]} where each of the @code{list} elements is an expression of
a binary operand and 2 elements.  For example @code{x=1}, @code{2^3}, @code{[a,b]} etc.
The @code{key} is checked againts the first operand.  @code{assoc} returns the second
operand if the @code{key} is found.  If the @code{key} is not found it
either returns the @code{default} value.  @code{default} is optional
and defaults to @code{false}.

@end defun

@defun atom (exp)
is @code{true} if @code{exp} is atomic (i.e. a number, name or string) else
@code{false}.  Thus @code{atom(5)} is @code{true} while @code{atom(a[1])} and @code{atom(sin(x))} are
@code{false} (asuming @code{a[1]} and @code{x} are unbound).

@end defun

@defun cons (exp, list)
returns a new list constructed of the element @code{exp} as
its first element, followed by the elements of @code{list}.  @code{cons} also works
on other expressions, e.g. @code{cons(x, f(a,b,c));}  ->  @code{f(x,a,b,c)}.

@end defun

@defun copylist (list)
creates a copy of the list @code{list}.

@end defun

@defun delete (exp1, exp2)
@defunx delete (exp1, exp2, n)
removes all occurrences of @code{exp1} from @code{exp2}.  @code{exp1}
may be a term of @code{exp2} (if it is a sum) or a factor of @code{exp2}
(if it is a product).

@example
(%i1)  delete(sin(x),x+sin(x)+y);
(%o1)               y + x

@end example

@code{delete(exp1, exp2, n)} removes the first @code{n} occurrences of
@code{exp1} from @code{exp2}.  If there are fewer than @code{n}
occurrences of @code{exp1} in @code{exp2} then all occurrences will be deleted.

@example
(%i1)  delete(a,f(a,b,c,d,a));
(%o1)             f(b, d)
(%i2)  delete(a,f(a,b,c,d,a),2);
(%o2)           f(b, d, a)

@end example

@end defun

@defun eigth (exp)
returns the 8'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun endcons (exp, list)
returns a new list consisting of the elements of
@code{list} followed by @code{exp}.  @code{endcons} also works on general expressions, e.g.
@code{endcons(x, f(a,b,c));}  ->  @code{f(a,b,c,x)}.

@end defun

@defun every (exp)
This function takes a list, or a positive number of arguments and returns
@code{true} if all its arguments are not @code{false}.

@end defun

@defun fifth (exp)
returns the 5'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun first (exp)
yields the first part of @code{exp} which may result in the first
element of a list, the first row of a matrix, the first term of a sum,
etc.  Note that @code{first} and its related functions, @code{rest} and @code{last}, work
on the form of @code{exp} which is displayed not the form which is typed on
input.  If the variable @code{inflag} is set to @code{true} however, these
functions will look at the internal form of @code{exp}.  Note that the
simplifier re-orders expressions.  Thus @code{first(x+y)} will be @code{x} if @code{inflag}
is @code{true} and @code{y} if @code{inflag} is @code{false} (@code{first(y+x)} gives the same
results).  The functions @code{second} .. @code{tenth} yield the second through the
tenth part of their input argument.

@end defun

@defun flatten (exp)
Takes a list of the form [[1,2],[3,4]] and returns [1,2,3,4].

@end defun

@defun fourth (exp)
returns the 4'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun get (a, i)
retrieves the user property indicated by @code{i} associated with
atom @code{a} or returns @code{false} if a doesn't have property @code{i}.

@example
(%i1) put (%e, 'transcendental, 'type);
(%o1)                      transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error (expr, "is not numeric.")) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)    [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)       [transcendental, [algebraic, transcendental]]
@end example

@end defun

@defun last (exp)
yields the last part (term, row, element, etc.) of the @code{exp}.

@end defun

@defun length (exp)
gives (by default) the number of parts in the external
(displayed) form of @code{exp}.  For lists this is the number of elements,
for matrices it is the number of rows, and for sums it is the number
of terms (see @code{dispform}).  The @code{length} command is affected by the
@code{inflag} switch.  So, e.g. @code{length(a/(b*c));} gives 2 if
@code{inflag} is @code{false} (Assuming @code{exptdispflag} is @code{true}), but 3 if @code{inflag} is
@code{true} (the internal representation is essentially @code{a*b^-1*c^-1}).

@end defun

@defvar listarith
 default value: @code{true} - if @code{false} causes any arithmetic operations
with lists to be suppressed; when @code{true}, list-matrix operations are
contagious causing lists to be converted to matrices yielding a result
which is always a matrix.  However, list-list operations should return
lists.

@end defvar

@defun listp (exp)
is @code{true} if @code{exp} is a list else @code{false}.

@end defun

@defun makelist (exp,var,lo,hi)
@defunx makelist (exp,var,list)
returns a list as value.  @code{makelist} may be called as
@code{makelist(exp,var,lo,hi)} [@code{lo} and @code{hi} must be integers], or as
@code{makelist(exp,var,list)}.  In the first case @code{makelist} is analogous to
@code{sum}, whereas in the second case @code{makelist} is similar to @code{map}.
Examples:

@example
(%i1) makelist(concat(x,i),i,1,6);
(%o1)          [x1, x2, x3, x4, x5, x6]
(%i2) makelist(x=y,y,[a,b,c]);
(%o2)            [x = a, x = b, x = c]
@end example

@end defun

@defun member (exp, list)
returns @code{true} if @code{exp} occurs as a member of @code{list} (not
within a member).  Otherwise @code{false} is returned.  @code{member} also works on
non-list expressions, e.g. @code{member(b,f(a,b,c));}  ->  @code{true}.

@end defun

@defun ninth (exp)
returns the 9'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun rest (exp, n)
@defunx rest (exp)
yields @code{exp} with its first @code{n} elements removed if @code{n} is
positive and its last @code{-n} elements removed if @code{n} is negative.  If @code{n} is 1
it may be omitted.  @code{exp} may be a list, matrix, or other expression.

@end defun

@defun reverse (list)
reverses the order of the members of the @code{list} (not
the members themselves).  @code{reverse} also works on general expressions,
e.g.  @code{reverse(a=b);} gives @code{b=a}.

@end defun

@defun second (exp)
returns the 2'nd item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun seventh (exp)
returns the 7'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun sixth (exp)
returns the 6'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun tenth (exp)
returns the 10'th item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

@defun third (exp)
returns the 3'rd item of expression or list @code{exp}.
See @code{first} for more details.

@end defun

