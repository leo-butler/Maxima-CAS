@menu
* Introduction to Input and Output::  
* FILES::                       
* Definitions for Input and Output::  
@end menu

@node Introduction to Input and Output, FILES, Input and Output, Input and Output
@section Introduction to Input and Output

@node FILES, Definitions for Input and Output, Introduction to Input and Output, Input and Output
@section FILES
A file is simply an area on a particular storage device which contains data or text.
Files on the disks are figuratively grouped into "directories".
A directory is just a list of files.
Commands which deal with files are:
@code{save},
@code{load},
@code{loadfile},
@code{stringout},
@code{batch},
@code{demo},
@code{writefile},
@code{closefile},
and
@code{appendfile}.

@c end concepts Input and Output
@node Definitions for Input and Output,  , FILES, Input and Output
@section Definitions for Input and Output

@defvar %
The output label (e.g., @code{%o1}, @code{%o2}, @code{%o3}, ...)
most recently computed by Maxima,
whether or not it was displayed.
See also @code{%%}.

@end defvar

@defvar %%
In a compound statement comprising two or more statements,
@code{%%} is the value of the previous statement.
For example,

@example
block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));
@end example

yield the same result, namely @code{21/2}.

A compound statement may comprise other compound statements.
Whether a statement be simple or compound, 
@code{%%} is the value of the previous statement.
For example,

@example
block (block (a^n, %%*42), %%/6)
@end example

yields @code{7*a^n}.

Within a compound statement, the value of @code{%%} may be inspected at a break prompt,
which is opened by executing the @code{break} function.
For example, at the break prompt opened by

@example
block (a: 42, break ())$
@end example

entering @code{%%;} yields @code{42}.

At the first statement in a compound statement,
or outside of a compound statement,
@code{%%} is undefined.

@end defvar

@defvar %edispflag
 default: @code{false} - if @code{true}, Maxima displays %E to a
negative exponent as a quotient, i.e. %E^-X as 1/%E^X.

@end defvar

@defun %th (i)
The value of the i'th previous output label. 
That is, if the next expression to be computed is the n'th output,
@code{%th (m)} is the (n-m)'th output.

@code{%th} is useful in @code{batch} files or for referring to a group of output labels.
For example,

@example
block (s: 0, for i:1 thru 10 do s: s + %th (i))$
@end example

sets @code{s} to the sum of the last ten output labels.

@end defun

@deffn {special symbol} "?"
  - As prefix to a function or variable name, signifies that the
function or variable is a Lisp token, not a Maxima token.  Two
question marks typed together, ??, will flush the current Maxima
command line.

@end deffn

@defvar absboxchar
 default: [!] is the character used to draw absolute value
signs around expressions which are more than a single line high.
@end defvar


@c end concepts Input and Output

@defun appendfile (filename)
Appends a console transcript to @code{filename}.
@code{appendfile} is the same as @code{writefile}, 
except that the transcript file, if it exists, is always appended.

@code{closefile} closes the transcript file opened by @code{appendfile} or @code{writefile}.

@end defun

@defun batch (file-specification)
reads in and evaluates Maxima command
lines from a file - A facility for executing command lines stored on a
disk file rather than in the usual on-line mode. This facility has
several uses, namely to provide a reservoir for working command lines,
for giving error-free demonstrations, or helping in organizing one's
thinking in complex problem-solving situations where modifications may
be done via a text editor.
A batch file consists of a set of Maxima command lines, each with its
terminating ; or $, which may be further separated by spaces,
carriage- returns, form-feeds, and the like.
The @code{batch} function calls for reading in the command lines from the
file one at a time, echoing them on the user console, and executing
them in turn.  Control is returned to the user console only when
serious errors occur or when the end of the file is met.  Of course,
the user may quit out of the file-processing by typing control-G at
any point.
Batch files may be created using a text editor or by use of the
@code{stringout} command.
See also @code{files}.

@end defun

@defun batchload (file-specification)
Batches in the file silently without
terminal output or labels.

@end defun

@defun closefile ()
Closes the transcript file opened by @code{writefile} or @code{appendfile}.

@end defun

@defun collapse (expression)
"collapses" its argument by causing all of its
common (i.e. equal) subexpressions to share (i.e. use the same cells),
thereby saving space.  (@code{collapse} is a subroutine used by the @code{optimize}
command.)  Thus, calling @code{collapse} may be useful
after loading in a @code{save} file.  You can collapse several expressions
together by using @code{collapse([expr1,...,exprN])}.  Similarly, you can
collapse the elements of the array @code{A} by doing
@code{collapse(listarray('A))}.

@end defun

@defun concat (arg1, arg2, ...)
evaluates its arguments and returns the
concatenation of their values resulting in a name or a quoted string
the type being given by that of the first argument.  Thus if @code{X} is
bound to 1 and @code{D} is unbound then @code{concat(X,2)} yields @code{"12"} and
@code{concat(D,X+1)} yields @code{D2}.

@end defun
@defun sconcat (arg1, arg2, ...)

evaluates its arguments and concatenates them into a string.  Unlike
@code{concat}, the arguments do @i{not} need to be atoms.    The result is a 
Lisp string.

@example
(%i5) sconcat("xx[",3,"]:",expand((x+y)^3));
(%o5) 			 xx[3]:Y^3+3*X*Y^2+3*X^2*Y+X^3
@end example

The resulting string could be used in conjunction with print.

@end defun

@defvar cursordisp
 default: @code{true} If @code{true}, causes expressions to be drawn by
the displayer in logical sequence.  This only works with a console
which can do cursor movement.  If @code{false}, expressions are simply
printed line by line.  @code{cursordisp} is @code{false} when a @code{writefile} is in
effect.

@end defvar

@defun disp (expr1,expr2, ...)
is like @code{display} but only the value of the
arguments are displayed rather than equations.  This is useful for
complicated arguments which don't have names or where only the value
of the argument is of interest and not the name.

@end defun

@c HMM, THIS NEXT ITEM IS DEFINED IN A SHARE FILE (itensor.lisp); 
@c DOES ITS DESCRIPTION WANT TO BE ELSEWHERE ???
@defun dispcon (tensor1,tensor2,...)
displays the contraction properties of
the tensori as were given to @code{defcon}.  @code{dispcon(all)} displays all the
contraction properties which were defined.

@end defun

@defun display (expr1, expr2, ...)
displays equations whose left side is
expri unevaluated, and whose right side is the value of the expression
centered on the line.  This function is useful in blocks and @code{for}
statements in order to have intermediate results displayed.  The
arguments to @code{display} are usually atoms, subscripted variables, or
function calls.  See also @code{disp}.

@example
(%i1) display(B[1,2]);
                                      2
                         B     = X - X
                          1, 2
(%o1)                            done
@end example

@end defun

@defvar display2d
 default: @code{true} - if set to @code{false} will cause the standard
display to be a string (1-dimensional) form rather than a display
(2-dimensional) form.  This may be of benefit for users on printing
consoles who would like to conserve paper.

@end defvar

@defvar display_format_internal
 default: @code{false} - if set to @code{true} will cause
expressions to be displayed without being transformed in ways that
hide the internal mathematical representation.  The display then
corresponds to what the @code{inpart} command returns rather than the @code{part}
command.  Examples:

@example
User     part       inpart
a-b;      A - B     A + (- 1) B
           A            - 1
a/b;       -         A B
           B
                       1/2
sqrt(x);   sqrt(X)    X
          4 X        4
X*4/3;    ---        - X
           3         3
@end example

@end defvar

@defun dispterms (expr)
displays its argument in parts one below the other.
That is, first the operator of 'expr' is displayed, then each term in
a sum, or factor in a product, or part of a more general expression is
displayed separately.  This is useful if expr is too large to be
otherwise displayed.  For example if P1, P2, ...  are very large
expressions then the display program may run out of storage space in
trying to display P1+P2+...  all at once.  However,
@code{dispterms(P1+P2+...)} will display @code{P1}, then below it @code{P2}, etc.  When not
using @code{dispterms}, if an exponential expression is too wide to be
displayed as @code{A**B} it will appear as @code{expt(A,B)} (or as @code{ncexpt(A,B)} in
the case of @code{A^^B}).

@end defun

@defvar error_size
 default: [20 for a display terminal, 10 for others].
controls the size of error messages.  For example, let
@code{U:(C^D^E+B+A)/(cos(X-1)+1)}.  @code{U} has an error size of 24.  So if
@code{error_size} has value < 24 then 

@example
(%i1) error("The function", foo,"doesn't like", U,"as input.");
prints as:
The function foo doesn't like errexp1 as input.
@end example
If @code{error_size}>24 then as:
@example
                                 E
                                D
                               C   + B + A
The function foo doesn't like -------------- as input.
                              cos(X - 1) + 1
@end example

Expressions larger than @code{error_size} are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
user-settable list

@example
error_syms:[errexp1,errexp2,errexp3]
@end example
The default value of this switch might change depending on user
experience.

@end defvar

@defvar error_syms
 default: [@code{errexp1}, @code{errexp2}, @code{errexp3}] - In error messages,
expressions larger than @code{error_size} are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
list @code{error_syms}, and are initially @code{errexp1}, @code{errexp2}, @code{errexp3}, etc.
After an error message is printed, e.g. "The function foo doesn't
like errexp1 as input.", the user can type @code{errexp1} to see the
expression.  @code{error_syms} may be set by the user to a different set
of symbols, if desired.

@end defvar

@defun expt (A,B)
if an exponential expression is too wide to be displayed
as @code{A^B} it will appear as @code{expt(A,B)} (or as @code{ncexpt(A,B)} in the case of
@code{A^^B}).

@end defun

@defvar exptdispflag
 default: @code{true} - if @code{true}, Maxima displays expressions
with negative exponents using quotients, e.g., @code{X**(-1)} as @code{1/X}.

@end defvar

@c THIS FUNCTION DOES EXIST BUT IT TAKES NO MORE THAN 2 ARGUMENTS !!!
@c ALSO THE DESCRIPTION SHOULD BE CLARIFIED, PERHAPS WITH EXAMPLES !!!
@defun filename_merge ("filename1","filename2",...)
; merges together
filenames.  What this means is that it returns "filename1" except
that missing components come from the corresponding components of
"filename2", and if they are missing there, then from "filename3".

@end defun

@defun file_search (filename)
@defunx file_search (filename, pathlist)

@code{file_search} searches for the file @code{filename} and returns the path to the file
(as a string) if it can be found; otherwise @code{file_search} returns @code{false}.
@code{file_search (filename)} searches in the default search directories,
which are specified by the @code{file_search_maxima}, @code{file_search_lisp}, and @code{file_search_demo} variables.

@code{file_search} first checks if the actual name passed exists,
before attempting to match it to ``wildcard'' file search patterns.
See @code{file_search_maxima} concerning file search patterns.

The argument @code{filename} can be a path and file name,
or just a file name, or, if a file search directory includes a file search pattern,
just the base of the file name (without an extension).
For example,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

will all find the same file, assuming the file exists and @code{/home/wfs/special/###.mac}
is in @code{file_search_maxima}.

@code{file_search (filename, pathlist)} searches only in the directories
specified by @code{pathlist},
which is a list of strings.
The argument @code{pathlist} supersedes the default search directories,
so if the path list is given, @code{file_search} searches only the ones specified,
and not any of the default search directories.
Even if there is only one directory in @code{pathlist}, it must still be given as a one-element list.

The user may modify the default search directories. See @code{file_search_maxima}.

@code{file_search} is invoked by @code{load} with @code{file_search_maxima} and @code{file_search_lisp}
as the search directories.

@end defun

@defvar file_search_maxima
@defvarx file_search_lisp
@defvarx file_search_demo
These variables specify lists of directories to be searched
by @code{load}, @code{demo}, and some other Maxima functions.
The default values of these variables
name various directories in the Maxima installation.

The user can modify these variables,
either to replace the default values or to append additional directories.
For example,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

replaces the default value of @code{file_search_maxima},
while

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

appends two additional directories.
It may be convenient to put such an expression in the file @code{maxima-init.mac}
so that the file search path is assigned automatically when Maxima starts.

Multiple filename extensions and multiple paths can be specified by
special ``wildcard'' constructions.
The string @code{###} expands into the sought-after name,
while a comma-separated list enclosed in curly braces @code{@{foo,bar,baz@}} expands
into multiple strings.
For example, supposing the sought-after name is @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

expands into @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, @code{/home/wfs/neumann.mac}, and @code{/home/gcj/neumann.mac}.

@end defvar

@defun file_type (filename)
Returns a guess about the content of @code{filename},
based on the filename extension.
@code{filename} need not refer to an actual file;
no attempt is made to open the file and inspect the content.

The return value is a symbol, either @code{object}, @code{lisp}, or @code{maxima}.
If the extension starts with @code{m} or @code{d}, @code{file_type} returns @code{maxima}.
If the extension starts with @code{l}, @code{file_type} returns @code{lisp}.
If none of the above, @code{file_type} returns @code{object}.

@end defun

@defun grind (arg)
prints out arg in a more readable format than the @code{string}
command.  It returns a D-line as value.
The @code{grind} switch, default: @code{false}, if @code{true} will cause the @code{string},
@code{stringout}, and @code{playback} commands to use "grind" mode instead of
"string" mode.  For @code{playback}, "grind" mode can also be turned on (for
processing input lines) by specifying @code{grind} as an option.

@end defun

@defvar ibase
Default value: 10

Integers entered into Maxima are interpreted
with respect to the base @code{ibase}.
@code{ibase} may be assigned any integer between 2 and 35 (decimal), inclusive.

See also @code{obase}.

@end defvar

@defvar inchar
Default value: @code{%i}

@code{inchar} is the prefix of the labels of expressions entered by the user.
Maxima automatically constructs a label for each input expression
by concatenating @code{inchar} and @code{linenum}.
@code{inchar} may be assigned any string or symbol, not necessarily a single character.

@example
(%i1) inchar: "input";
(%o1)                                input
(input1) expand ((a+b)^3);
                            3        2      2      3
(%o1)                      b  + 3 a b  + 3 a  b + a
(input2)
@end example

See also @code{labels}.

@end defvar

@defun ldisp (expr1,expr2,...)
is like @code{disp} but also generates intermediate
labels.

@end defun

@defun ldisplay (expr1,expr2,...)
is like @code{display} but also generates
intermediate labels.

@end defun

@defvar linechar
Default value: @code{%t}

@code{linechar} is the prefix of the labels of intermediate expressions generated by Maxima.
Maxima constructs a label for each intermediate expression (if displayed)
by concatenating @code{linechar} and @code{linenum}.
@code{linechar} may be assigned any string or symbol, not necessarily a single character.

Intermediate expressions may or may not be displayed.
See @code{programmode} and @code{labels}.

@end defvar

@defvar linel
Default value: 79

@code{linel} is the assumed width (in characters) of the console display
for the purpose of displaying expressions.
@code{linel} may be assigned any value by the user,
although very small or very large values may be impractical.
Text printed by built-in Maxima functions, such as error messages and the output of @code{describe},
is not affected by @code{linel}.

@end defvar

@defun load (filename)
Evaluates expressions in @code{filename}, 
thus bringing variables, functions, and other objects into Maxima.
The binding of any existing object is clobbered by the binding recovered from @code{filename}. 
To find the file,
@code{load} calls @code{file_search} with @code{file_search_maxima} and @code{file_search_lisp}
as the search directories.
If @code{load} succeeds, it returns the path of the file.
Otherwise @code{load} prints an error message.

@code{load} works equally well for Lisp code and Maxima code.
Files created by @code{save}, @code{translate_file}, and @code{compile_file}, which create Lisp code,
and @code{stringout}, which creates Maxima code,
can all be processed by @code{load}.
See also @code{loadfile}, @code{batch}, and @code{demo}.
@code{loadfile} processes Lisp files;
@code{batch} and @code{demo} process Maxima files.

See @code{file_search} for more detail about the file search mechanism.

@end defun

@defun loadfile (filename)
Evaluates Lisp expressions in @code{filename}.
@code{loadfile} quotes its argument, so @code{filename} must be a literal string,
not a string variable.
Also, @code{loadfile} does not invoke @code{file_search}, so @code{filename} must include
the file extension and as much of the path as needed to find the file.

@code{loadfile} can process files created by @code{save}, @code{translate_file}, and @code{compile_file}.
The user may find it more convenient to use @code{load} instead of @code{loadfile}.

@end defun

@c SEEMS TO STILL EXIST; NEEDS UPDATING !!!
@defvar loadprint
 default: @code{true} - governs the printing of messages
accompanying loading of files.  The following options are available:
@code{loadprint: true} means always print the message; @code{loadprint: 'loadfile} means print only when
the @code{loadfile} command is used; @code{loadprint: 'autoload} means print only when a file
is automatically loaded in; @code{loadprint: false}
means never print the loading message.

@end defvar

@defvar obase
Default value: 10

@code{obase} is the base for integers displayed by Maxima.
@code{obase} may be assigned any integer between 2 and 35 (decimal), inclusive.
When @code{obase} is greater than 10, the numerals comprise the decimal numerals
@code{0} through @code{9}
plus capital letters of the alphabet @code{A}, @code{B}, @code{C}, ...,
as needed.
The numerals for base 35, the largest acceptable base,
comprise @code{0} through @code{9}
and @code{A} through @code{Y}.

See also @code{ibase}.

@end defvar

@defvar outchar
Default value: @code{%o}

@code{outchar} is the prefix of the labels of expressions computed by Maxima.
Maxima automatically constructs a label for each computed expression
by concatenating @code{outchar} and @code{linenum}.
@code{outchar} may be assigned any string or symbol, not necessarily a single character.

@example
(%i1) outchar: "output";
(output1)                           output
(%i2) expand ((a+b)^3);
                            3        2      2      3
(output2)                  b  + 3 a b  + 3 a  b + a
(%i3)
@end example

See also @code{labels}.

@end defvar

@c STILL EXISTS, NEEDS CLARIFICATION !!!
@defvar packagefile
 default: @code{false} - Package designers who use @code{save}
or @code{translate} to create packages (files) for others
to use may want to set @code{packagefile: true} to prevent information
from being added to Maxima's information-lists (e.g. @code{values},
@code{functions}) except where necessary when the file is loaded in.
In this way, the contents of the package will not get in the
user's way when he adds his own data.  Note that this will not
solve the problem of possible name conflicts.  Also note that
the flag simply affects what is output to the package file.
Setting the flag to @code{true} is also useful for creating Maxima
init files.

@end defvar

@defvar pfeformat
 default: @code{false} - if @code{true} will cause rational numbers to
display in a linear form and denominators which are integers to
display as rational number multipliers.

@end defvar

@defun print (exp1, exp2, ...)
evaluates and displays its arguments one
after the other "on a line" starting at the leftmost position.  If
expi is unbound or is preceded by a single quote or is enclosed in "s
then it is printed literally.  For example, @code{print("the value of X is ",X)}.
The value returned by @code{print} is the value of its last argument.
No intermediate lines are generated.  (For "printing" files, see
the @code{printfile} function.)

@end defun

@defun tcl_output (list index &optional-skip)
prints a TCL list based on @code{list} extracting the @code{index} slot.
Here skip defaults to 2, meaning that every other element
will be printed if the argument is of the form a list of numbers,
rathter than a list of lists.
For example:

@example
tcl_output([x1,y1,x2,y2,x3,y3],1) --> @{x1 x2 x3 @}
tcl_output([x1,y1,x2,y2,x3,y3],2) --> @{y1 y2 y3 @}
tcl_output([1,2,3,4,5,6],1,3) --> @{1 4@}
tcl_output([1,2,3,4,5,6],2,3) --> @{2 5@}
@end example

@end defun

@defun read (arg_1, arg_2, arg_3, ...)
Prints its arguments, then reads one expression from the console
and returns the evaluated expression.
The expression is terminated with a @code{;} (semicolon) or @code{$} (dollar sign).

@example
(%i1) foo: 42$ 
(%i2) foo: read ("foo is", foo, " -- enter new value.")$
foo is 42  -- enter new value. 
(a+b)^3;
(%i3) foo;
                                          3
(%o3)                              (b + a)
@end example

@end defun

@defun readonly (arg_1, arg_2, arg_3, ...)
Prints its arguments, then reads one expression from the console
and returns the expression (without evaluation).
The expression is terminated with a @code{;} (semicolon) or @code{$} (dollar sign).

@example
(%i1) aa: 7$
(%i2) foo: readonly ("Enter an expression:");
Enter an expression: 
2^aa;
                                       aa
(%o2)                                 2
(%i3) foo: read ("Enter an expression:");
Enter an expression: 
2^aa;
(%o3)                                 128
@end example

See also @code{read}.

@end defun

@defun reveal (exp,depth)
will display exp to the specified integer depth
with the length of each part indicated.  Sums will be displayed as
Sum(n) and products as Product(n) where n is the number of subparts of
the sum or product.  Exponentials will be displayed as Expt.

@example
(%i1) integrate(1/(X^3+2),X)$
(%i2) reveal(%,2);
(%o2)                    Negterm + Quotient + Quotient
(%i3) reveal(%o1,3);
                                     atan         log
(%o3)                 - Quotient + ---------- + ----------
                                  Product(2)   Product(2)
@end example

@end defun

@defvar rmxchar
 default: []] - The character used to display the (right)
delimiter of a matrix (see also @code{lmxchar}).

@end defvar

@defun save (filename, name_1, name_2, name_3, ...)
@defunx save (filename, values, functions, labels, ...)
@defunx save (filename, [m, n])
@defunx save (filename, new_1=old_1, new_2=old_2, ...)
@defunx save (filename, all)
Stores the current values of @code{name_1}, @code{name_2}, @code{name_3}, ..., in @code{filename}.
The arguments must be names of variables, functions, or other objects.
@code{save} returns @code{filename}.

@code{save} stores data in the form of Lisp expressions.
The data stored by @code{save} may be recovered by @code{load (filename)}.
The effect of executing @code{save} when @code{filename} already exists
depends on the underlying Lisp implementation;
the file may be clobbered, or @code{save} may complain with an error message.

The special form @code{save (filename, values, functions, labels, ...)}
stores the items named by @code{values}, @code{functions}, @code{labels}, etc.
The names may be any specified by the variable @code{infolists}.
@code{values} comprises all user-defined variables.

The special form @code{save (filename, [m, n])} stores the values of
input and output labels @code{m} through @code{n}.
Note that @code{m} and @code{n} must be literal integers or double-quoted symbols.
Input and output labels may also be stored one by one, e.g., @code{save ("foo.1", %i42, %o42)}.
@code{save (filename, labels)} will store all input and output labels.
When the stored labels are recovered, they will clobber existing labels.

The special form @code{save (filename, name_1=expr_1, name_2=expr_2, ...)}
stores the values of @code{expr_1}, @code{expr_2}, ...,
with names @code{name_1}, @code{name_2}, ....
It is useful to apply this form to input and output labels, e.g., @code{save ("foo.1", aa=%o88)}.
The right-hand side of the equality in this form may be any expression, which is evaluated.
This form does not introduce the new names into the current Maxima environment,
but only stores them in @code{filename}.

These special forms and the general form of @code{save} may be mixed at will.
For example, @code{save (filename, aa, bb, cc=42, functions, [11, 17])}.

The special form @code{save (filename, all)} stores the current state of Maxima.
This includes all user-defined variables, functions, arrays, etc., as well
as some automatically defined items.
The saved items include system variables,
such as @code{file_search_maxima} or @code{showtime}, if assigned new values by the user.

@code{save} quotes its arguments. 
@code{filename} must be a string, not a string variable.
The first and last labels to save, if specified, must be integers.
The double quote operator will evaluate a string variable to its string value,
e.g., @code{s: "foo.1"$ save (''s, all)$},
and integer variables to their integer values, e.g., @code{m: 5$ n: 12$ save ("foo.1", [''m, ''n])$}.

@c ANY USE FOR THE FOLLOWING ???
@c The following device constructs a list of variables to save and saves them.
@c 
@c @example
@c s: "foo.1"$
@c l: ['aa, 'bb, 'cc, 'dd]$
@c apply (save, append ([s], l))$
@c @end example
@end defun

@defvar savedef
 default: @code{true} - if @code{true} will cause the Maxima version of a
user function to remain when the function is translated.  This permits
the definition to be displayed by @code{dispfun} and allows the function to
be edited.  If @code{savedef} is @code{false}, the names of translated functions are
removed from the @code{functions} list.

@end defvar

@c THIS FUNCTION IS IN THE SHARE PACKAGE itensor.lisp -- DOES THIS DESCRIPTION WANT TO BE ELSEWHERE ???
@defun show (exp)
will display exp with the indexed objects in it shown
having covariant indices as subscripts,contravariant indices as
superscripts.  The derivative indices will be displayed as subscripts,
separated from the covariant indices by a comma.

@end defun

@defun showratvars (exp)
returns a list of the canonical rational expression (CRE) variables of exp. 
See also @code{ratvars}.

@end defun

@defvar stardisp
 default: @code{false} - if @code{true} will cause multiplication to be
displayed explicitly with an * between operands.

@end defvar

@defun string (expr)
converts expr to Maxima's linear notation (similar to
Fortran) just as if it had been typed in and puts expr into the
buffer for possible editing (in which case expr is usually Ci) The
@code{string}'ed expression should not be used in a computation.

@end defun

@defun stringout (file-specification, expr1, expr2, expr3, ...)
@defunx stringout (file-specification, [m, n])
@defunx stringout (file-specification, input)
@defunx stringout (file-specification, functions)
@defunx stringout (file-specification, values)

@code{stringout} writes expressions to a file in the same form the
expressions would be typed for input. The file can then be used
as input for the @code{batch} or @code{demo} commands, and it may be edited for
any purpose. @code{stringout} can be executed while @code{writefile} is in progress.

The general form of @code{stringout} writes the values of one or more 
expressions to the output file. Note that if an expression is a
variable, only the value of the variable is written and not the name
of the variable. As a useful special case, the expressions may be
input labels (%i1, %i2, %i3, ...) or output labels (%o1, %o2, %o3, ...).

If @code{grind} is @code{true}, @code{stringout} will format the output using the @code{grind}
format. Otherwise the @code{string} format is used. See @code{grind} and @code{string}.

The special form @code{stringout (file-specification, [m, n])} writes the
values of input labels m through n, inclusive. 

The special form @code{stringout (file-specification, input)} writes all
input labels to the file.

The special form @code{stringout (file-specification, functions)} writes all
user-defined functions to the file. The functions that are written
are the same ones shown by @code{dispfun (all)}.

The special form @code{stringout (file-specification, values)} writes all
user-assigned variables to the file. Each variable is printed as an
assignment statement, with the name of the variable, a colon, and its
value. Note that the general form of @code{stringout} does not print 
variables as assignment statements.

@end defun

@defun tex (expr)
@defunx tex (expr,filename)
@defunx tex (label,filename)

In the case of a label,
a left-equation-number will be produced.
in case a file-name is supplied, the output will be appended to the
file.

@example
(%i1) integrate(1/(1+x^3),x);

					 2 x - 1
		       2	    atan(-------)
		  log(x  - x + 1)	 sqrt(3)    log(x + 1)
(%o1) 	        - --------------- + ------------- + ----------
			 6	       sqrt(3)	        3
(%i2) tex(%o1);

$$-@{@{\log \left(x^@{2@}-x+1\right)@}\over@{6@}@}
  +@{@{\arctan @{@{2\>x-1@}\over@{\sqrt@{3@}@}@}@}\over@{\sqrt@{3@}@}@}
  +@{@{\log \left(x+1\right)@}\over@{3@}@}\leqno@{\tt (%o1)@}$$
(%o2) 				     (%o1)
(%i6) tex(integrate(sin(x),x));

$$-\cos x$$
(%o6) 				     false
(%i7) tex(%o1,"/tmp/jo.tex");

(%o7) 				     (%o1)
@end example

where the last expression will be appended to the file @file{/tmp/jo.tex}

@end defun

@defun system (command)
Execute @code{command} as a subprocess.  The command will be passed to the
default shell for execution.   System is not supported by all operating
systems, but generally exists in the unix environment.
if hist is a list of frequencies which you wish to plot as a bar graph
using xgraph. 

@example
(%i1) (with_stdout("_hist.out",
           for i:1 thru length(hist) do (
             print(i,hist[i]))),
       system("xgraph -bar -brw .7 -nl < _hist.out"));
@end example

In order to make the plot be done in the background (returning control to Maxima)
and remove the temporary file after it is done do:

@example
system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")
@end example

@end defun

@defvar ttyoff
Default value: @code{false}

When @code{ttyoff} is @code{true}, output expressions are not displayed.
Output expressions are still computed and assigned labels. See @code{labels}.

Text printed by built-in Maxima functions, such as error messages and the output of @code{describe},
is not affected by @code{ttyoff}.

@end defvar

@deffn {macro} with_stdout (file,stmt1,stmt2,...)
Opens file and then evaluates stmt1, stmt2, ....  Any printing
to standard output goes to the file instead of the terminal.
It always returns @code{false}.   Note the binding of display2d to be
false, otherwise the printing will have things like "- 3" instead
of "-3".

@example
mygnuplot(f,var,range,number_ticks):=
 block([numer:true,display2d:false],
 with_stdout("/tmp/gnu",
   for x:range[1] thru range[2] step
                (range[2]-range[1])/number_ticks
      do (print(x,at(f,var=x)))),
 system("echo \"set data style lines; set title '",
        f,"' ;plot '/tmp/gnu'
;pause 10 \" | gnuplot"));

(%i8) with_stdout("/home/wfs/joe",
      n:10,
      for i:8 thru n
        do(print("factorial(",i,") gives ",i!)));
(%o8) 				     false
(%i9) system("cat /home/wfs/joe");
factorial( 8 ) gives  40320 
factorial( 9 ) gives  362880 
factorial( 10 ) gives  3628800 
(%o9) 				       0
@end example

@end deffn

@defun writefile (filename)
Begins writing a transcript of the Maxima session to @code{filename}.
All interaction between the user and Maxima is then recorded in this file,
just as it appears on the console.

The user can execute @code{playback} after
@code{writefile} to save the display of previous interactions.
As @code{playback} displays only the input and output variables (%i1, %o1, etc.),
any output generated by a print statement in a function 
(as opposed to a return value) is not displayed by @code{playback}.

As the transcript is printed in the console output format,
it cannot be reloaded into Maxima.
To make a file containing expressions which can be reloaded,
see @code{save} and @code{stringout}.
@code{save} stores expressions in Lisp form, while @code{stringout} stores expressions in Maxima form.

The effect of executing @code{writefile} when @code{filename} already exists
depends on the underlying Lisp implementation;
the transcript file may be clobbered, or the file may be appended.
@code{appendfile} always appends to the transcript file.

@code{closefile} closes the transcript file opened by @code{writefile} or @code{appendfile}.

@end defun
