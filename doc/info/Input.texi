@menu
* Introduction to Input and Output::  
* FILES::                       
* PLAYBACK::                    
* Definitions for Input and Output::  
@end menu

@node Introduction to Input and Output, FILES, Input and Output, Input and Output
@section Introduction to Input and Output

@node FILES, PLAYBACK, Introduction to Input and Output, Input and Output
@section FILES
 - A file is simply an area on a particular storage device which
contains data or text.  The only storage devices which are used on the
MC machine are disks and tapes.  Files on the disks are figuratively
grouped into "directories".  A directory is just a list of all the
files stored under a given user name.  Do DESCRIBE(FILEOP); for
details of how you may inspect your files using MACSYMA.  Other
commands which deal with files are: SAVE, FASSAVE, STORE, LOAD,
LOADFILE, RESTORE, UNSTORE, STRINGOUT, BATCH, BATCON, DEMO, WRITEFILE,
CLOSEFILE, DELFILE, REMFILE, and APPENDFILE.

@node PLAYBACK, Definitions for Input and Output, FILES, Input and Output
@section PLAYBACK
 It is possible to play back the input lines in a temporary
scroll down window, and so not lose ones current work.  This can
be done by typing Function  E.  A numeric argument tells it the line
number to start at, otherwise it will go back about 40 lines.

@c end concepts Input and Output
@node Definitions for Input and Output,  , PLAYBACK, Input and Output
@section Definitions for Input and Output
@c @node %, %%, PLAYBACK, Input and Output
@c @unnumberedsec phony
@defvar %
 The last D-line computed by MACSYMA (whether or not it was printed
out).  (See also %%.)

@end defvar
@c @node %%, %EDISPFLAG, %, Input and Output
@c @unnumberedsec phony
@defvar %%
 The value of the last computation performed while in a
(MACSYMA-BREAK).  Also may be used in compound statements in the nth
statement to refer to the value of the (n-1)th statement.  E.g.
F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%)); is in essence
equivalent to F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),
SUBST(3,X,%%)-SUBST(2,X,%%)); This will also work for communicating
between the (n-1)th and nth (non-atomic) BLOCK statements.

@end defvar
@c @node %EDISPFLAG, %TH, %%, Input and Output
@c @unnumberedsec phony
@defvar %EDISPFLAG
 default: [FALSE] - if TRUE, MACSYMA displays %E to a
negative exponent as a quotient, i.e. %E^-X as 1/%E^X.

@end defvar
@c @node %TH, {special symbol}, %EDISPFLAG, Input and Output
@c @unnumberedsec phony
@defun %TH (i)
is the ith previous computation.  That is, if the next
expression to be computed is D(j) this is D(j-i).  This is useful in
BATCH files or for referring to a group of D expressions.  For
example, if SUM is initialized to 0 then FOR I:1 THRU 10 DO
SUM:SUM+%TH(I) will set SUM to the sum of the last ten D expressions.

@end defun
@c @node "?"
@c @unnumberedsec phony
@deffn {special symbol} "?"
  - As prefix to a function or variable name, signifies that the
function or variable is a LISP token, not a MACSYMA token.  Two
question marks typed together, ??, will flush the current MACSYMA
command line.

@end deffn
@c @node ABSBOXCHAR, APPENDFILE, {special symbol}, Input and Output
@c @unnumberedsec phony
@defvar ABSBOXCHAR
 default: [!] is the character used to draw absolute value
signs around expressions which are more than a single line high.
@end defvar


@c end concepts Input and Output
@c @node APPENDFILE, BACKUP, ABSBOXCHAR, Input and Output
@c @unnumberedsec phony
@defun APPENDFILE (filename)
Appends a console transcript to @code{filename}.
APPENDFILE is the same as WRITEFILE, 
except that the transcript file, if it exists, is always appended.

CLOSEFILE closes the transcript file opened by APPENDFILE or WRITEFILE.

@end defun
@c @node BATCH, BATCHKILL, BACKUP, Input and Output
@c @unnumberedsec phony
@defun BATCH (file-specification)
reads in and evaluates MACSYMA command
lines from a file - A facility for executing command lines stored on a
disk file rather than in the usual on-line mode. This facility has
several uses, namely to provide a reservoir for working command lines,
for giving error-free demonstrations, or helping in organizing one's
thinking in complex problem-solving situations where modifications may
be done via a text editor.
A batch file consists of a set of MACSYMA command lines, each with its
terminating ; or $, which may be further separated by spaces,
carriage- returns, form-feeds, and the like.
The BATCH function calls for reading in the command lines from the
file one at a time, echoing them on the user console, and executing
them in turn.  Control is returned to the user console only when
serious errors occur or when the end of the file is met.  Of course,
the user may quit out of the file-processing by typing control-G at
any point.
BATCH files may be created using a text editor or by use of the
STRINGOUT command.  Do DESCRIBE(STRINGOUT) for details
DESCRIBE(FILE); and DESCRIBE(FILES); have additional information on
how the file argument is interpreted, and files in general.

@end defun
@c @node BATCHLOAD, BATCON, BATCHKILL, Input and Output
@c @unnumberedsec phony
@defun BATCHLOAD (file-specification)
Batches in the file silently without
terminal output or labels.

@end defun
@c @node BOTHCASES, CHANGE_FILEDEFAULTS, BATCOUNT, Input and Output
@c @unnumberedsec phony
@defvar BOTHCASES
 default: [TRUE] if TRUE will cause MAXIMA to retain lower
case text as well as upper case. Note, however, that the names of any
MAXIMA special variables or functions are in upper case.   The default
is now TRUE since it makes code more readable, allowing users to
have names like SeriesSolve.  

Because of this we make the system variables and functions all upper
case, and users may enter them however they like (in upper or lower).
But all other variables and functions are case sensitive.
When you print out your program using for example grind(fundef(f))
then you will see that the symbols like 'IF', 'SIN',... all appear
in upper case whereas non system symbols appear in the case which
you used.

This is implemented as follows: If the symbol is being encountered for
the first time, if the upper case version is in the package and has a
nontrivial function or property list, then the upper case symbol is
used, and it is recorded on the mixed case one, that the upper case
should be used in future.  If a symbol is already in the package then it
is just used.

In effect this means that most old programs should continue to work,
and that new ones may write sIn, Sin, SIN, sin etc and they will
all be interpreted as SIN.   However if they write MySin this will
be different from MYSIN, because MYSIN is not a system function or
variable.  



@example
SeriesSolve(f,x):=
   if (f = sin) ...

and this is read as

SeriesSolve(f,x):=
   IF (f = SIN) ...
@end example





@end defvar
@c @node CLOSEFILE, COLLAPSE, CHANGE_FILEDEFAULTS, Input and Output
@c @unnumberedsec phony
@defun CLOSEFILE ()
Closes the transcript file opened by WRITEFILE or APPENDFILE.

@end defun
@c @node COLLAPSE, CONCAT, CLOSEFILE, Input and Output
@c @unnumberedsec phony
@defun COLLAPSE (expression)
collapses" its argument by causing all of its
common (i.e. equal) subexpressions to share (i.e. use the same cells),
thereby saving space.  (COLLAPSE is a subroutine used by the OPTIMIZE
command.)  Thus, calling COLLAPSE may be useful before using FASSAVE
or after loading in a SAVE file.  You can collapse several expressions
together by using COLLAPSE([expr1,...,exprN])$.  Similarly, you can
collapse the elements of the array A by doing
COLLAPSE(LISTARRAY('A))$.

@end defun
@c @node CONCAT, CURSORDISP, COLLAPSE, Input and Output
@c @unnumberedsec phony
@defun CONCAT (arg1, arg2, ...)
evaluates its arguments and returns the
concatenation of their values resulting in a name or a quoted string
the type being given by that of the first argument.  Thus if X is
bound to 1 and D is unbound then CONCAT(X,2)="12" and
CONCAT(D,X+1)=D2.

@end defun
@defun SCONCAT (arg1, arg2, ...)

evaluates its arguments and concatenates them into a string.  Unlike
CONCAT, the arguments do NOT need to be atoms.    The result is a Common
Lisp String.
@example
(%i5) sconcat("xx[",3,"]:",expand((x+y)^3));
(%o5) 			 xx[3]:Y^3+3*X*Y^2+3*X^2*Y+X^3
@end example
The resulting string could be used in conjunction with print.
@end defun
@c @node CURSORDISP, DIREC, CONCAT, Input and Output
@c @unnumberedsec phony
@defvar CURSORDISP
 default: [TRUE] If TRUE, causes expressions to be drawn by
the displayer in logical sequence.  This only works with a console
which can do cursor movement.  If FALSE, expressions are simply
printed line by line.  CURSORDISP is FALSE when a WRITEFILE is in
effect.

@end defvar
@c @node DISP, DISPCON, DIREC, Input and Output
@c @unnumberedsec phony
@defun DISP (expr1,expr2, ...)
is like DISPLAY but only the value of the
arguments are displayed rather than equations.  This is useful for
complicated arguments which don't have names or where only the value
of the argument is of interest and not the name.

@end defun
@c @node DISPCON, DISPLAY, DISP, Input and Output
@c @unnumberedsec phony
@c HMM, THIS NEXT ITEM IS DEFINED IN A SHARE FILE (itensor.lisp); 
@c DOES ITS DESCRIPTION WANT TO BE ELSEWHERE ???
@defun DISPCON (tensor1,tensor2,...)
displays the contraction properties of
the tensori as were given to DEFCON.  DISPCON(ALL) displays all the
contraction properties which were defined.

@end defun
@c @node DISPLAY, DISPLAY2D, DISPCON, Input and Output
@c @unnumberedsec phony
@defun DISPLAY (expr1, expr2, ...)
displays equations whose left side is
expri unevaluated, and whose right side is the value of the expression
centered on the line.  This function is useful in blocks and FOR
statements in order to have intermediate results displayed.  The
arguments to DISPLAY are usually atoms, subscripted variables, or
function calls.  (see the DISP function)

@example
(%i1) DISPLAY(B[1,2]);
                                      2
                         B     = X - X
                          1, 2
(%o1)                            DONE


@end example
@end defun
@c @node DISPLAY2D, DISPLAY_FORMAT_INTERNAL, DISPLAY, Input and Output
@c @unnumberedsec phony
@defvar DISPLAY2D
 default: [TRUE] - if set to FALSE will cause the standard
display to be a string (1-dimensional) form rather than a display
(2-dimensional) form.  This may be of benefit for users on printing
consoles who would like to conserve paper.

@end defvar
@c @node DISPLAY_FORMAT_INTERNAL, DISPTERMS, DISPLAY2D, Input and Output
@c @unnumberedsec phony
@defvar DISPLAY_FORMAT_INTERNAL
 default: [FALSE] - if set to TRUE will cause
expressions to be displayed without being transformed in ways that
hide the internal mathematical representation.  The display then
corresponds to what the INPART command returns rather than the PART
command.  Examples:
@example
User     PART       INPART
a-b;      A - B     A + (- 1) B
           A            - 1
a/b;       -         A B
           B
                       1/2
sqrt(x);   SQRT(X)    X
          4 X        4
X*4/3;    ---        - X
           3         3

@end example
@end defvar
@c @node DISPTERMS, DSKALL, DISPLAY_FORMAT_INTERNAL, Input and Output
@c @unnumberedsec phony
@defun DISPTERMS (expr)
displays its argument in parts one below the other.
That is, first the operator of 'expr' is displayed, then each term in
a sum, or factor in a product, or part of a more general expression is
displayed separately.  This is useful if expr is too large to be
otherwise displayed.  For example if P1, P2, ...  are very large
expressions then the display program may run out of storage space in
trying to display P1+P2+...  all at once.  However,
DISPTERMS(P1+P2+...) will display P1, then below it P2, etc.  When not
using DISPTERMS, if an exponential expression is too wide to be
displayed as A**B it will appear as EXPT(A,B) (or as NCEXPT(A,B) in
the case of A^^B).

@end defun
@c @node ERROR_SIZE, ERROR_SYMS, DSKALL, Input and Output
@c @unnumberedsec phony
@defvar ERROR_SIZE
 default: [20 for a display terminal, 10 for others].
controls the size of error messages.  For example, let
U:(C^D^E+B+A)/(COS(X-1)+1); .  U has an error size of 24.  So if
ERROR_SIZE has value < 24 then 
@example
(%i1) ERROR("The function", FOO,"doesn't like", U,"as input.");
prints as:
The function FOO doesn't like ERREXP1 as input.
If ERROR_SIZE>24 then as:
                                 E
                                D
                               C   + B + A
The function FOO doesn't like -------------- as input.
                              COS(X - 1) + 1

@end example

Expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
user-settable list
@example
ERROR_SYMS:[ERREXP1,ERREXP2,ERREXP3]
@end example
.
The default value of this switch might change depending on user
experience.  If you find the defaults either too big or two small
for your tastes, send mail to MACSYMA.

@end defvar
@c @node ERROR_SYMS, EXPT, ERROR_SIZE, Input and Output
@c @unnumberedsec phony
@defvar ERROR_SYMS
 default: [ERREXP1,ERREXP2,ERREXP3] - In error messages,
expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
list ERROR_SYMS, and are initially ERREXP1, ERREXP2, ERREXP3, etc.
After an error message is printed, e.g. "The function FOO doesn't
like ERREXP1 as input.", the user can type ERREXP1; to see the
expression.  ERROR_SYMS may be set by the user to a different set
of symbols, if desired.

@end defvar
@c @node EXPT, EXPTDISPFLAG, ERROR_SYMS, Input and Output
@c @unnumberedsec phony
@defun EXPT (A,B)
if an exponential expression is too wide to be displayed
as A^B it will appear as EXPT(A,B) (or as NCEXPT(A,B) in the case of
A^^B).

@end defun
@c @node EXPTDISPFLAG, FASSAVE, EXPT, Input and Output
@c @unnumberedsec phony
@defvar EXPTDISPFLAG
 default: [TRUE] - if TRUE, MACSYMA displays expressions
with negative exponents using quotients e.g., X**(-1) as 1/X.

@end defvar
@c @node FASSAVE, FILEDEFAULTS, EXPTDISPFLAG, Input and Output
@c @unnumberedsec phony
@c IS THIS FUNCTION EXPECTED TO WORK ANYMORE ??? IF NOT I'LL CUT IT.
@defun FASSAVE (args)
is similar to SAVE but produces a FASL file in which
the sharing of subexpressions which are shared in core is preserved in
the file created.  Hence, expressions which have common subexpressions
will consume less space when loaded back from a file created by
FASSAVE rather than by SAVE.  Files created with FASSAVE are reloaded
using LOADFILE, just as files created with SAVE.  FASSAVE returns a
list of the form [<name of file>,<size of file in blocks>,...] where
...  are the things saved.  Warnings are printed out in the case of
large files.  FASSAVE may be used while a WRITEFILE is in progress.

@end defun
@c @node FILENAME_MERGE, FILENUM, FILENAME, Input and Output
@c @unnumberedsec phony
@c THIS FUNCTION DOES EXIST BUT IT TAKES NO MORE THAN 2 ARGUMENTS !!!
@c ALSO THE DESCRIPTION SHOULD BE CLARIFIED, PERHAPS WITH EXAMPLES !!!
@defun FILENAME_MERGE ("filename1","filename2",...)
; merges together
filenames.  What this means is that it returns "filename1" except
that missing components come from the corresponding components of
"filename2", and if they are missing there, then from "filename3".

@end defun
@c @node FILE_SEARCH, FILE_STRING_PRINT, FILENUM, Input and Output
@c @unnumberedsec phony
@defun FILE_SEARCH (filename)
@defunx FILE_SEARCH (filename, pathlist)

FILE_SEARCH searches for the file @code{filename} and returns the path to the file
(as a string) if it can be found; otherwise FILE_SEARCH returns FALSE.
@code{FILE_SEARCH (filename)} searches in the default search directories,
which are specified by the FILE_SEARCH_MAXIMA, FILE_SEARCH_LISP, and FILE_SEARCH_DEMO variables.

FILE_SEARCH first checks if the actual name passed exists,
before attempting to match it to ``wildcard'' file search patterns.
See FILE_SEARCH_MAXIMA concerning file search patterns.

The argument @code{filename} can be a path and file name,
or just a file name, or, if a file search directory includes a file search pattern,
just the base of the file name (without an extension).
For example,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

will all find the same file, assuming the file exists and @code{/home/wfs/special/###.mac}
is in FILE_SEARCH_MAXIMA.

@code{FILE_SEARCH (filename, pathlist)} searches only in the directories
specified by @code{pathlist},
which is a list of strings.
The argument @code{pathlist} supersedes the default search directories,
so if the path list is given, FILE_SEARCH searches only the ones specified,
and not any of the default search directories.
Even if there is only one directory in @code{pathlist}, it must still be given as a one-element list.

The user may modify the default search directories. See FILE_SEARCH_MAXIMA.

FILE_SEARCH is invoked by LOAD with FILE_SEARCH_MAXIMA and FILE_SEARCH_LISP
as the search directories.

@end defun

@defvar FILE_SEARCH_MAXIMA
@defvarx FILE_SEARCH_LISP
@defvarx FILE_SEARCH_DEMO
These variables specify lists of directories to be searched
by LOAD, DEMO, and some other Maxima functions.
The default values of these variables
name various directories in the Maxima installation.

The user can modify these variables,
either to replace the default values or to append additional directories.
For example,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

replaces the default value of FILE_SEARCH_MAXIMA,
while

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

appends two additional directories.
It may be convenient to put such an expression in the file @code{maxima-init.mac}
so that the file search path is assigned automatically when Maxima starts.

Multiple filename extensions and multiple paths can be specified by
special ``wildcard'' constructions.
The string @code{###} expands into the sought-after name,
while a comma-separated list enclosed in curly braces @code{@{foo,bar,baz@}} expands
into multiple strings.
For example, supposing the sought-after name is @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

expands into @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, @code{/home/wfs/neumann.mac}, and @code{/home/gcj/neumann.mac}.

@end defvar
@c @node FILE_TYPE, GRIND, FILE_STRING_PRINT, Input and Output
@c @unnumberedsec phony
@c THIS FUNCTION DOES EXIST BUT DESCRIPTION SHOULD BE UPDATED !!!
@defun FILE_TYPE ("filename")
; returns FASL, LISP, or MACSYMA, depending on
what kind of file it is.  FASL means a compiled Lisp file, which
normally has an extension of .VAS in NIL.

@end defun
@c @node GRIND, IBASE, FILE_TYPE, Input and Output
@c @unnumberedsec phony
@defun GRIND (arg)
prints out arg in a more readable format than the STRING
command.  It returns a D-line as value.
The GRIND switch, default: [FALSE], if TRUE will cause the STRING,
STRINGOUT, and PLAYBACK commands to use "grind" mode instead of
"string" mode.  For PLAYBACK, "grind" mode can also be turned on (for
processing input lines) by specifying GRIND as an option.

@end defun
@c @node IBASE, INCHAR, GRIND, Input and Output
@c @unnumberedsec phony
@c ALSO MENTION OBASE HERE !!!
@defvar IBASE
 default: [10] - the base for inputting numbers.

@end defvar
@c @node INCHAR, LDISP, IBASE, Input and Output
@c @unnumberedsec phony
@c UPDATE -- DEFAULT IS NOW %i !!!
@defvar INCHAR
 default: [C] - the alphabetic prefix of the names of
expressions typed by the user.

@end defvar
@c @node LDISP, LDISPLAY, INCHAR, Input and Output
@c @unnumberedsec phony
@defun LDISP (expr1,expr2,...)
is like DISP but also generates intermediate
labels.

@end defun
@c @node LDISPLAY, LINECHAR, LDISP, Input and Output
@c @unnumberedsec phony
@defun LDISPLAY (expr1,expr2,...)
is like DISPLAY but also generates
intermediate labels.

@end defun
@c @node LINECHAR, LINEDISP, LDISPLAY, Input and Output
@c @unnumberedsec phony
@c UPDATE -- DEFAULT IS NOW %t !!!
@defvar LINECHAR
 default: [E] - the alphabetic prefix of the names of
intermediate displayed expressions.

@end defvar
@c @node LINEL, LOAD, LINEDISP, Input and Output
@c @unnumberedsec phony
@c STILL EXISTS, NEEDS UPDATING !!!
@defvar LINEL
 default: [] - the number of characters which are printed on a
line. It is initially set by MACSYMA to the line length of the type of
terminal being used (as far as is known) but may be reset at any time
by the user.  The user may have to reset it in DDT with :TCTYP as
well.

@end defvar
@c @node LOAD, LOADFILE, LINEL, Input and Output
@c @unnumberedsec phony
@defun LOAD (filename)
Evaluates expressions in @code{filename}, thus bringing new variables and functions into Maxima.
To find the file,
LOAD calls FILE_SEARCH with FILE_SEARCH_MAXIMA and FILE_SEARCH_LISP
as the search directories.
If LOAD succeeds, it returns the path of the file.
Otherwise LOAD prints an error message.

LOAD works equally well for Lisp code and Maxima code.
Files created by SAVE, TRANSLATE_FILE, and COMPILE_FILE, which create Lisp code,
and STRINGOUT, which creates Maxima code,
can all be processed by LOAD.
See also LOADFILE, RESTORE, BATCH, and DEMO.
LOADFILE and RESTORE process Lisp files;
BATCH and DEMO process Maxima files.

See FILE_SEARCH for more detail about the file search mechanism.

@end defun
@c @node LOADFILE, LOADPRINT, LOAD, Input and Output
@c @unnumberedsec phony
@defun LOADFILE (filename)
Evaluates Lisp expressions in @code{filename}.
LOADFILE quotes its argument, so @code{filename} must be a literal string,
not a string variable.
Also, LOADFILE does not invoke FILE_SEARCH, so @code{filename} must include
the file extension and as much of the path as needed to find the file.

LOADFILE can process files created by SAVE, TRANSLATE_FILE, and COMPILE_FILE.
The user may find it more convenient to use LOAD instead of LOADFILE.

@end defun
@c @node LOADPRINT, NOSTRING, LOADFILE, Input and Output
@c @unnumberedsec phony
@c SEEMS TO STILL EXIST; NEEDS UPDATING !!!
@defvar LOADPRINT
 default: [TRUE] - governs the printing of messages
accompanying loading of files.  The following options are available:
TRUE means always print the message; 'LOADFILE means print only when
the LOADFILE command is used; 'AUTOLOAD means print only when a file
is automatically loaded in (e.g. the integration file SIN FASL); FALSE
means never print the loading message.

@end defvar
@c @node OBASE, OUTCHAR, NOSTRING, Input and Output
@c @unnumberedsec phony
@c ALSO MENTION IBASE HERE !!!
@defvar OBASE
 default: [10] the base for display of numbers.

@end defvar
@c @node OUTCHAR, PACKAGEFILE, OBASE, Input and Output
@c @unnumberedsec phony
@c UPDATE -- DEFAULT IS NOW %o !!!
@defvar OUTCHAR
 default: [D] - the alphabetic prefix of the names of
outputted expressions.

@end defvar
@c @node PACKAGEFILE, PARSEWINDOW, OUTCHAR, Input and Output
@c @unnumberedsec phony
@c STILL EXISTS, NEEDS CLARIFICATION !!!
@defvar PACKAGEFILE
 default:[FALSE] - Package designers who use SAVE,
FASSAVE, or TRANSLATE to create packages (files) for others
to use may want to set PACKAGEFILE:TRUE$ to prevent information
from being added to MACSYMA's information-lists (e.g. VALUES,
FUNCTIONS) except where necessary when the file is loaded in.
In this way, the contents of the package will not get in the
user's way when he adds his own data.  Note that this will not
solve the problem of possible name conflicts.  Also note that
the flag simply affects what is output to the package file.
Setting the flag to TRUE is also useful for creating MACSYMA
init files.

@end defvar
@c @node PFEFORMAT, PRINT, PARSEWINDOW, Input and Output
@c @unnumberedsec phony
@defvar PFEFORMAT
 default: [FALSE] - if TRUE will cause rational numbers to
display in a linear form and denominators which are integers to
display as rational number multipliers.

@end defvar
@c @node PRINT, READ, PFEFORMAT, Input and Output
@c @unnumberedsec phony
@defun PRINT (exp1, exp2, ...)
evaluates and displays its arguments one
after the other "on a line" starting at the leftmost position.  If
expi is unbound or is preceded by a single quote or is enclosed in "s
then it is printed literally.  For example, PRINT("THE VALUE OF X IS
",X).  The value returned by PRINT is the value of its last argument.
No intermediate lines are generated.  (For "printing" files, see
the PRINTFILE function.)

@end defun

@defun TCL_OUTPUT (LIST INDEX &optional-skip)
prints a TCL list based on LIST extracting the INDEX slot.
Here skip defaults to 2, meaning that every other element
will be printed if the argument is of the form a list of numbers,
rathter than a list of lists.
For example:
@example
TCL_OUTPUT([x1,y1,x2,y2,x3,y3],1) --> @{x1 x2 x3 @}
TCL_OUTPUT([x1,y1,x2,y2,x3,y3],2) --> @{y1 y2 y3 @}
TCL_OUTPUT([1,2,3,4,5,6],1,3) --> @{1 4@}
TCL_OUTPUT([1,2,3,4,5,6],2,3) --> @{2 5@}
@end example
@end defun

@c @node READ, READONLY, PRINT, Input and Output
@c @unnumberedsec phony
@c COULD NOTE THAT EXPRESSION IS COMMA OR DOLLAR SIGN TERMINATED !!!
@defun READ (string1, ...)
prints its arguments, then reads in and evaluates
one expression.  For example: A:READ("ENTER THE NUMBER OF VALUES").

@end defun
@c @node READONLY, REVEAL, READ, Input and Output
@c @unnumberedsec phony
@defun READONLY (string1,...)
prints its arguments, then reads in an
expression (which in contrast to READ is not evaluated).

@end defun
@c @node REVEAL, RMXCHAR, READONLY, Input and Output
@c @unnumberedsec phony
@defun REVEAL (exp,depth)
will display exp to the specified integer depth
with the length of each part indicated.  Sums will be displayed as
Sum(n) and products as Product(n) where n is the number of subparts of
the sum or product.  Exponentials will be displayed as Expt.
@example
(%i1) INTEGRATE(1/(X^3+2),X)$
(%i2) REVEAL(%,2);
(%o2)                    Negterm + Quotient + Quotient
(%i3) REVEAL(%o1,3);
                                     ATAN         LOG
(%o3)                 - Quotient + ---------- + ----------
                                  Product(2)   Product(2)


@end example
@end defun
@c @node RMXCHAR, SAVE, REVEAL, Input and Output
@c @unnumberedsec phony
@defvar RMXCHAR
 default: []] - The character used to display the (right)
delimiter of a matrix (see also LMXCHAR).

@end defvar
@c @node SAVE, SAVEDEF, RMXCHAR, Input and Output
@c @unnumberedsec phony
@c IN GREAT NEED OF UPDATING AND CLARIFICATION !!!
@defun SAVE (filename,arg1, arg2,...,argi)
saves quantities
described by its arguments on disk and keeps them in core also.
The arg's are the expressions to be SAVEd.
ALL is the simplest, but note that saving ALL will save the entire
contents of your MACSYMA, which in the case of a large computation may
result in a large file.  VALUES,
FUNCTIONS, or any other items on the INFOLISTS (do
DESCRIBE(INFOLISTS); for the list) may be SAVEd, as may functions and
variables by name.  C and D lines may also be saved, but it is better
to give them explicit names, which may be done in the command line,
e.g.  SAVE(RES1=%o15); Files saved with SAVE should be reloaded with
LOADFILE.  SAVE returns the pathname where the items were saved.


@end defun
@c @node SAVEDEF, SHOW, SAVE, Input and Output
@c @unnumberedsec phony
@defvar SAVEDEF
 default: [TRUE] - if TRUE will cause the MACSYMA version of a
user function to remain when the function is TRANSLATEd.  This permits
the definition to be displayed by DISPFUN and allows the function to
be edited.  If SAVEDEF is FALSE, the names of translated functions are
removed from the FUNCTIONS list.

@end defvar
@c @node SHOW, SHOWRATVARS, SAVEDEF, Input and Output
@c @unnumberedsec phony
@c THIS FUNCTION IS IN THE SHARE PACKAGE itensor.lisp -- DOES THIS DESCRIPTION WANT TO BE ELSEWHERE ???
@defun SHOW (exp)
will display exp with the indexed objects in it shown
having covariant indices as subscripts,contravariant indices as
superscripts.  The derivative indices will be displayed as subscripts,
separated from the covariant indices by a comma.

@end defun
@c @node SHOWRATVARS, STARDISP, SHOW, Input and Output
@c @unnumberedsec phony
@defun SHOWRATVARS (exp)
returns a list of the RATVARS (CRE variables) of
exp.

@end defun
@c @node STARDISP, STRING, SHOWRATVARS, Input and Output
@c @unnumberedsec phony
@defvar STARDISP
 default: [FALSE] - if TRUE will cause multiplication to be
displayed explicitly with an * between operands.

@end defvar
@c @node STRING, STRINGOUT, STARDISP, Input and Output
@c @unnumberedsec phony
@defun STRING (expr)
converts expr to MACSYMA's linear notation (similar to
FORTRAN's) just as if it had been typed in and puts expr into the
buffer for possible editing (in which case expr is usually Ci) The
STRING'ed expression should not be used in a computation.

@end defun
@c @node STRINGOUT, TTYOFF, STRING, Input and Output
@c @unnumberedsec phony
@defun STRINGOUT (file-specification, expr1, expr2, expr3, ...)
@defunx STRINGOUT (file-specification, [m, n])
@defunx STRINGOUT (file-specification, INPUT)
@defunx STRINGOUT (file-specification, FUNCTIONS)
@defunx STRINGOUT (file-specification, VALUES)

STRINGOUT writes expressions to a file in the same form the
expressions would be typed for input. The file can then be used
as input for the BATCH or DEMO commands, and it may be edited for
any purpose. STRINGOUT can be executed while WRITEFILE is in progress.

The general form of STRINGOUT writes the values of one or more 
expressions to the output file. Note that if an expression is a
variable, only the value of the variable is written and not the name
of the variable. As a useful special case, the expressions may be
input labels (%i1, %i2, %i3, ...) or output labels (%o1, %o2, %o3, ...).

If GRIND is TRUE, STRINGOUT will format the output using the GRIND
format. Otherwise the STRING format is used. See GRIND and STRING.

The special form STRINGOUT (file-specification, [m, n]) writes the
values of input labels m through n, inclusive. 

The special form STRINGOUT (file-specification, INPUT) writes all
input labels to the file.

The special form STRINGOUT (file-specification, FUNCTIONS) writes all
user-defined functions to the file. The functions that are written
are the same ones shown by DISPFUN (ALL).

The special form STRINGOUT (file-specification, VALUES) writes all
user-assigned variables to the file. Each variable is printed as an
assignment statement, with the name of the variable, a colon, and its
value. Note that the general form of STRINGOUT does not print 
variables as assignment statements.

@end defun

@defun TEX (expr)
@defunx TEX (expr,filename)
@defunx TEX (label,filename)

In the case of a label,
a left-equation-number will be produced.
in case a file-name is supplied, the output will be appended to the
file.

@example
(%i1) integrate(1/(1+x^3),x);

					 2 x - 1
		       2	    ATAN(-------)
		  LOG(x  - x + 1)	 SQRT(3)    LOG(x + 1)
(%o1) 	        - --------------- + ------------- + ----------
			 6	       SQRT(3)	        3
(%i2) tex(%o1);

$$-@{@{\log \left(x^@{2@}-x+1\right)@}\over@{6@}@}
  +@{@{\arctan @{@{2\>x-1@}\over@{\sqrt@{3@}@}@}@}\over@{\sqrt@{3@}@}@}
  +@{@{\log \left(x+1\right)@}\over@{3@}@}\leqno@{\tt (%o1)@}$$
(%o2) 				     (%o1)
(%i6) tex(integrate(sin(x),x));

$$-\cos x$$
(%o6) 				     FALSE
(%i7) tex(%o1,"/tmp/jo.tex");

(%o7) 				     (%o1)
@end example
where the last expression will be appended to the file @file{/tmp/jo.tex}
@end defun
@defun SYSTEM (command)
Execute COMMAND as a subprocess.  The command will be passed to the
default shell for execution.   System is not supported by all operating
systems, but generally exists in the unix environment.
if hist is a list of frequencies which you wish to plot as a bar graph
using xgraph. 
@example
(%i1) (with_stdout("_hist.out",
           for i:1 thru length(hist) do (
             print(i,hist[i]))),
       system("xgraph -bar -brw .7 -nl < _hist.out"));
@end example
In order to make the plot be done in the background (returning control to maxima)
and remove the temporary file after it is done do:
@example
system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")
@end example
@end defun

@c @node TTYOFF, WRITEFILE, STRINGOUT, Input and Output
@c @unnumberedsec phony
@c SHOULD NOTE THAT TTYOFF:TRUE DOESN'T STOP OUTPUT PRINTED BY LISP FCNS !!! (E.G. DESCRIBE)
@defvar TTYOFF
 default: [FALSE] - if TRUE stops printing output to the
console.

@end defvar

@deffn {macro} WITH_STDOUT (file,stmt1,stmt2,...)
Opens file and then evaluates stmt1, stmt2, ....  Any printing
to standard output goes to the file instead of the terminal.
It always returns FALSE.   Note the binding of display2d to be
false, otherwise the printing will have things like "- 3" instead
of "-3".
@example

mygnuplot(f,var,range,number_ticks):=
 block([numer:true,display2d:false],
 with_stdout("/tmp/gnu",
   for x:range[1] thru range[2] step
                (range[2]-range[1])/number_ticks
      do (print(x,at(f,var=x)))),
 system("echo \"set data style lines; set title '",
        f,"' ;plot '/tmp/gnu'
;pause 10 \" | gnuplot"));

(%i8) with_stdout("/home/wfs/joe",
      n:10,
      for i:8 thru n
        do(print("factorial(",i,") gives ",i!)));
(%o8) 				     FALSE
(%i9) system("cat /home/wfs/joe");
factorial( 8 ) gives  40320 
factorial( 9 ) gives  362880 
factorial( 10 ) gives  3628800 
(%o9) 				       0
@end example

@end deffn



@c @node WRITEFILE,  , TTYOFF, Input and Output
@c @unnumberedsec phony
@defun WRITEFILE (filename)
Begins writing a transcript of the Maxima session to @code{filename}.
All interaction between the user and Maxima is then recorded in this file,
just as it appears on the console.

The user can execute PLAYBACK after
WRITEFILE to save the display of previous interactions.
As PLAYBACK displays only the input and output variables (%i1, %o1, etc.),
any output generated by a print statement in a function 
(as opposed to a return value) is not displayed by PLAYBACK.

As the transcript is printed in the console output format,
it cannot be reloaded into Maxima.
To make a file containing expressions which can be reloaded,
see SAVE and STRINGOUT.
SAVE stores expressions in Lisp form, while STRINGOUT stores expressions in Maxima form.

The effect of executing WRITEFILE when @code{filename} already exists
depends on the underlying Lisp implementation;
the transcript file may be clobbered, or the file may be appended.
APPENDFILE always appends to the transcript file.

CLOSEFILE closes the transcript file opened by WRITEFILE or APPENDFILE.

@end defun
