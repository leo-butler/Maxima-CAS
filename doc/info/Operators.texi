@menu
* nary::                        
* nofix::                       
* operator::                    
* postfix::                     
* prefix::                      
* Definitions for Operators::   
@end menu


@node nary, nofix, Operators, Operators
@section nary
An @code{nary} operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the
operator, e.g. A+B or A+B+C.  The @code{nary("x")} function is a syntax
extension function to declare x to be an @code{nary} operator.
Functions may be declared to be
@code{nary}.  If @code{declare(j,nary);} is done, this tells the simplifier to
simplify, e.g. @code{j(j(a,b),j(c,d))} to @code{j(a, b, c, d)}.

See also @code{syntax}.

@node nofix, operator, nary, Operators
@section nofix
@code{nofix} operators are used to denote functions of no arguments.
The mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a Maxima break, "exit" is behaving similar to a
@code{nofix} operator.  The function @code{nofix("x")} is a syntax extension
function which declares x to be a @code{nofix} operator. 

See also @code{syntax}.

@node operator, postfix, nofix, Operators
@section operator
See @code{operators}.

@node postfix, prefix, operator, Operators
@section postfix
@code{postfix} operators like the @code{prefix} variety denote functions
of a single argument, but in this case the argument immediately
precedes an occurrence of the operator in the input string, e.g. 3! .
The @code{postfix("x")} function is a syntax extension function to declare x
to be a @code{postfix} operator.

See also @code{syntax}.

@node prefix, Definitions for Operators, postfix, Operators
@section prefix
A @code{prefix} operator is one which signifies a function of one
argument, which argument immediately follows an occurrence of the
operator.  @code{prefix("x")} is a syntax extension function to declare x to
be a @code{prefix} operator.

See also @code{syntax}.

@c end concepts Operators
@node Definitions for Operators,  , prefix, Operators
@section Definitions for Operators

@deffn operator "!"
The factorial operator.
For any complex number @code{x} (including integer, rational, and real numbers) except for
negative integers, @code{x!} is defined as @code{gamma(x+1)}.

For an integer @code{x}, @code{x!} simplifies to the product of the integers from 1 to @code{x} inclusive.
@code{0!} simplifies to 1.
For a floating point number @code{x}, @code{x!} simplifies to the value of @code{gamma (x+1)}.
For @code{x} equal to @code{n/2} where @code{n} is an odd integer,
@code{x!} simplifies to a rational factor times @code{sqrt (%pi)}
(since @code{gamma (1/2)} is equal to @code{sqrt (%pi)}).
If @code{x} is anything else,
@code{x!} is not simplified.

The variables
@code{factlim}, @code{minfactorial}, and @code{factcomb} control the simplification
of expressions containing factorials.

The functions @code{gamma}, @code{bffac}, and @code{cbffac}
are varieties of the gamma function.
@code{makegamma} substitutes @code{gamma} for factorials and related functions.

See also @code{binomial}.

@itemize @bullet
@item
The factorial of an integer, half-integer, or floating point argument is simplified
unless the operand is greater than @code{factlim}.

@example
(%i1) factlim: 10$
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          105 sqrt(%pi)
(%o2) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example

@item
The factorial of a complex number, known constant, or general expression is not simplified.
Even so it may be possible simplify the factorial after evaluating the operand.

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003, 

                                          1.227580202486819]
@end example

@item
The factorial of an unbound symbol is not simplified.

@example
(%i1) kill (foo)$
(%i2) foo!;
(%o2)                       foo!
@end example

@item
Factorials are simplified, not evaluated.
Thus @code{x!} may be replaced even in a quoted expression.

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example
@end itemize

@end deffn

@deffn operator "!!"
The double factorial operator.

For an integer, float, or rational number @code{n},
@code{n!!} evaluates to the product @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
where @code{k} is equal to @code{entier (n/2)},
that is, the largest integer less than or equal to @code{n/2}.
Note that this definition does not coincide with other published definitions
for arguments which are not integers.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

For an even (or odd) integer @code{n}, @code{n!!} evaluates to the product of
all the consecutive even (or odd) integers from 2 (or 1) through @code{n} inclusive.

For an argument @code{n} which is not an integer, float, or rational,
@code{n!!} yields a noun form @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn operator "#"
The logical operator "Not equals".

@end deffn

@deffn operator "."
The dot operator, for matrix (non-commutative) multiplication.
When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point in
a floating point number.

See also
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident},
and
@code{dotscrules}.

@end deffn

@deffn operator ":"
The assignment operator.  E.g. A:3 sets the variable A to 3.

@end deffn

@deffn operator "::"
Assignment operator.  :: assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.

@end deffn

@deffn operator "::="
The "::=" is used instead of ":=" to indicate that what
follows is a macro definition, rather than an ordinary functional
definition.  See @code{macros}.

@end deffn

@deffn operator ":="
The function definition operator.  E.g. @code{f(x):=sin(x)} defines
a function @code{f}.

@end deffn

@deffn operator "="
denotes an equation to Maxima.  To the pattern matcher in
Maxima it denotes a total relation that holds between two expressions
if and only if the expressions are syntactically identical.

@end deffn

@defun abs (@var{expr})
Returns the absolute value @var{expr}.  If @var{expr} is complex, returns the complex
modulus of @var{expr}.

@end defun
@c end concepts Operators

@defvr {special symbol} additive
If @code{declare(f,additive)} has been executed, then:

(1) If @code{f} is univariate, whenever the simplifier encounters @code{f} applied
to a sum, @code{f} will be distributed over that sum.  I.e. @code{f(y+x)} will
simplify to @code{f(y)+f(x)}.

(2) If @code{f} is a function of 2 or more arguments, additivity is defined as 
additivity in the first argument to @code{f}, as in the case of @code{sum} or 
@code{integrate}, i.e. @code{f(h(x)+g(x),x)} will simplify to @code{f(h(x),x)+f(g(x),x)}.
This simplification does not occur when @code{f} is applied to expressions of
the form @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@defvr keyword allbut
works with the @code{part} commands (i.e. @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart}, and @code{lpart}).  For example,

@example
(%i1) expr: e+d+c+b+a$
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

while

@example
(%i3) part (expr, allbut (2, 5));
(%o3)                       e + c + b
@end example

It also works with the @code{kill} command,

@example
kill (allbut (name_1, ..., name_k))
@end example

will do a @code{kill (all)} except it will not
@code{kill} the names specified.  Note: @code{name_i} means a name such as function
name such as @code{u}, @code{f}, @code{foo}, or @code{g}, not an infolist such as @code{functions}.


@end defvr

@defvr declaration antisymmetric
If @code{declare(h,antisymmetric)} is done, this tells the
simplifier that @code{h} is antisymmetric.  E.g. @code{h(x,z,y)} will simplify to
@code{- h(x, y, z)}.  That is, it will give (-1)^n times the result given by
@code{symmetric} or @code{commutative}, where n is the number of interchanges of two
arguments necessary to convert it to that form.

@end defvr

@defun cabs (@var{expr})
Returns the complex absolute value (the complex modulus) of
@var{expr}.

@end defun

@defvr declaration commutative
If @code{declare(h,commutative)} is done, this tells the
simplifier that @code{h} is a commutative function.  E.g. @code{h(x,z,y)} will
simplify to @code{h(x, y, z)}.  This is the same as @code{symmetric}.

@end defvr

@defun entier (@var{x})
Returns the largest integer less than or equal to @var{x} where @var{x} is numeric.  @code{fix} (as in
@code{fixnum}) is a synonym for this, so @code{fix(@var{x})} is precisely the same.

@end defun

@c NEEDS CLARIFICATION
@defun equal (@var{expr_1}, @var{expr_2})
Used with an @code{is}, returns @code{true} (or @code{false}) if
and only if @var{expr_1} and @var{expr_2} are equal (or not equal) for all possible
values of their variables (as determined by @code{ratsimp}).  Thus
@code{is (equal ((x + 1)^2, x^2 + 2*x + 1))} returns @code{true} whereas if @code{x} is unbound
@code{is ((x + 1)^2 = x^2 + 2*x + 1)} returns @code{false}.  Note also that @code{is(rat(0)=0)}
yields @code{false} but @code{is (equal (rat(0), 0))} yields @code{true}.

If a determination
can't be made, then @code{is (equal (a, b))} returns a simplified but equivalent expression, 
whereas @code{is (a=b)} always returns either @code{true} or @code{false}.

All variables occurring in @var{expr_1} and @var{expr_2} are presumed to be real valued.

@c COPY THIS TO DESCRIPTION OF is
@code{ev (@var{expr}, pred)} is equivalent to @code{is (@var{expr})}.

@example
(%i1) is (x^2 >= 2*x - 1);
(%o1)                         true
(%i2) assume (a > 1);
(%o2)                        [a > 1]
(%i3) is (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
(%o3)                         true
@end example

@end defun

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT eval IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON eval DOES NOT HAVE THE evflag PROPERTY
@deffn operator eval
As an argument in a call to @code{ev (@var{expr})},
@code{eval} causes an extra evaluation of @var{expr}.
See @code{ev}.

@end deffn

@defun evenp (@var{expr})
Returns @code{true} if @var{expr} is an even integer.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} is returned in all other cases.

@end defun

@defun fix (@var{x})
A synonym for @code{entier (@var{x})}.

@end defun

@defun fullmap (@var{f}, @var{expr_1}, ...)
Similar to @code{map}, but @code{fullmap} keeps mapping
down all subexpressions until the main operators are no longer the
same.

@code{fullmap} is used by the Maxima
simplifier for certain matrix manipulations; thus, Maxima sometimes generates
an error message concerning @code{fullmap} even though @code{fullmap} was not
explicitly called by the user.

@example
(%i1) a + b*c$
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end defun

@defun fullmapl (@var{f}, @var{list_1}, ...)
Similar to @code{fullmap}, but @code{fullmapl} only maps onto
lists and matrices.

@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end defun

@c NEEDS CLARIFICATION AND EXAMPLES
@defun is (@var{expr})
Attempts to determine whether @var{expr} (which must evaluate to a
predicate) is provable from the facts in the current data base.  @code{is}
returns @code{true} if the predicate is true for all values of its variables
consistent with the data base and returns @code{false} if it is false for all
such values.  Otherwise, its action depends on the setting of the
switch @code{prederror}. @code{is} errs out if the value of
@code{prederror} is @code{true} and returns @code{unknown} if @code{prederror} is @code{false}.

@end defun

@defun isqrt (@var{x})
Returns the "integer square root"
of the absolute value of @var{x},
which is an integer.

@end defun

@defun max (@var{x_1}, @var{x_2}, ...)
Returns the maximum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

@end defun

@defun min (@var{x_1}, @var{x_2}, ...)
Returns the minimum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

@end defun

@defun mod (@var{p})
@defunx mod (@var{p}, @var{m})
Converts the polynomial @var{p} to a modular representation
with respect to the current modulus which is the value of the variable
@code{modulus}.  

@code{mod (@var{p}, @var{m})} specifies a modulus @var{m} to be used 
instead of the current value of @code{modulus}.

See @code{modulus}.

@end defun

@defun oddp (@var{expr})
is @code{true} if @var{expr} is an odd integer.
@c THIS IS STRANGE -- SHOULD RETURN NOUN FORM IF INDETERMINATE
@code{false} is returned in all other cases.

@end defun

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c NOTE THAT pred IS RECOGNIZED ONLY AS AN ARGUMENT TO ev,
@c BUT FOR SOME REASON pred DOES NOT HAVE THE evflag PROPERTY
@deffn operator pred
As an argument in a call to @code{ev (@var{expr})},
@code{pred} causes predicates (expressions which evaluate to @code{true}
or @code{false}) to be evaluated.
See @code{ev}.

@end deffn

@defun make_random_state (@var{n})
@c @defunx make_random_state (@var{a})
@defunx make_random_state (@var{s})
@defunx make_random_state (true)
@defunx make_random_state (false)

A random state object represents the state of the random number generator.
The state comprises 627 32-bit words.

@code{make_random_state (@var{n})} returns a new random state object
created from an integer seed value equal to @var{n} modulo 2^32.
@var{n} may be negative.

@c OMIT THIS FOR NOW. NOT SURE HOW THIS IS SUPPOSED TO WORK.
@c @code{make_random_state (@var{a})} returns a new random state object
@c created from an array @var{a}, which must be a Lisp array of 32 unsigned bytes.

@code{make_random_state (@var{s})} returns a copy of the random state @var{s}.

@code{make_random_state (true)} returns a new random state object,
using the current computer clock time as the seed.

@code{make_random_state (false)} returns a copy of the current state
of the random number generator.

@end defun

@defun set_random_state (@var{s})
Copies @var{s} to the random number generator state.

@code{set_random_state} always returns @code{done}.

@end defun

@defun random (@var{x})
Returns a pseudorandom number. If @var{x} is an integer, @code{random (@var{x})} returns an
integer from 0 through @code{@var{x} - 1} inclusive. If @var{x} is a floating point number,
@code{random (@var{x})} returns a nonnegative floating point number less than @var{x}.
@code{random} complains with an error if @var{x} is neither an integer nor a float,
or if @var{x} is not positive.

The functions @code{make_random_state} and @code{set_random_state}
maintain the state of the random number generator.

The Maxima random number generator is an implementation of the Mersenne twister MT 19937.

Examples:
@c GENERATED FROM THE FOLLOWING
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);

@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end defun

@defun sign (@var{expr})
Attempts to determine the sign of @var{expr}
on the basis of the facts in the current data base.  It returns one of
the following answers: @code{pos} (positive), @code{neg} (negative), @code{zero}, @code{pz}
(positive or zero), @code{nz} (negative or zero), @code{pn} (positive or negative),
or @code{pnz} (positive, negative, or zero, i.e. nothing known).

@end defun

@defun signum (@var{x})
For numeric @var{x}, returns 0 if @var{x} is 0, otherwise returns -1 or +1
as @var{x} is less than or greater than 0, respectively.

If @var{x} is not numeric then a simplified but equivalent form is returned.
For example, @code{signum(-x)} gives @code{-signum(x)}.
@c UMM, THIS ISN'T THE WHOLE STORY, AS IT APPEARS signum CONSULTS THE assume DATABASE FOR SYMBOLIC ARGUMENT

@end defun

@defun sort (@var{list}, @var{p})
@defunx sort (@var{list})
Sorts @var{list} according to a predicate @code{p} of two arguments,
such as @code{"<"} or @code{orderlessp}.

@code{sort (@var{list})} sorts @var{list} according to Maxima's built-in ordering.

@var{list} may contain numeric or nonnumeric items, or both.

@c NEED EXAMPLES, ESPECIALLY SORTING NONNUMERIC ITEMS
@end defun

@defun sqrt (@var{x})
The square root of @var{x}. It is represented internally by
@code{@var{x}^(1/2)}.  See also @code{rootscontract}.

@code{radexpand} if @code{true} will cause nth roots of factors of a product
which are powers of n to be pulled outside of the radical, e.g.
@code{sqrt(16*x^2)} will become @code{4*x} only if @code{radexpand} is @code{true}.

@end defun

@defvar sqrtdispflag
Default value: @code{true}

When @code{sqrtdispflag} is @code{false},
causes @code{sqrt} to display with exponent 1/2.
@c AND OTHERWISE ... ??

@end defvar

@c NEEDS EXPANSION, CLARIFICATION, MORE EXAMPLES
@c sublis CAN ONLY SUBSTITUTE FOR ATOMS, RIGHT ?? IF SO, SAY SO
@defun sublis (@var{list}, @var{expr})
Makes multiple parallel substitutions into an expression.

The variable @code{sublis_apply_lambda} controls simplification after
@code{sublis}.

Example:

@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example

@end defun

@defun sublist (@var{list}, @var{p})
Returns the list of elements of @var{list} for which the
predicate @code{p} returns @code{true}.

Example:

@example
(%i1) L: [1, 2, 3, 4, 5, 6]$
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
@end example

@end defun

@defvar sublis_apply_lambda
default: @code{true} - controls whether @code{lambda}'s
substituted are applied in simplification after @code{sublis} is used or
whether you have to do an @code{ev} to get things to apply. @code{true} means do the
application.

@end defvar

@c NEEDS CLARIFICATION, MORE EXAMPLES
@defun subst (@var{a}, @var{b}, @var{c})
Substitutes @var{a} for @var{b} in @var{c}.  @var{b} must be an atom or a
complete subexpression of @var{c}.  For example, @code{x+y+z} is a complete
subexpression of @code{2*(x+y+z)/w} while @code{x+y} is not. When @var{b} does not have
these characteristics, one may sometimes use @code{substpart} or @code{ratsubst}
(see below).  Alternatively, if @var{b} is of the form @code{e/f} then one could
use @code{subst (a*f, e, c)} while if @var{b} is of the form @code{e^(1/f)} then one could
use @code{subst (a^f, e, c)}.  The @code{subst} command also discerns the @code{x^y} in @code{x^-y}
so that @code{subst (a, sqrt(x), 1/sqrt(x))} yields @code{1/a}.  @var{a} and @var{b} may also be
operators of an expression enclosed in double-quotes @code{"} or they may be function
names.  If one wishes to substitute for the independent variable in
derivative forms then the @code{at} function (see below) should be used.

@c UMM, REVERSE THIS AND MOVE IT TO substitute ??
@code{subst} is an alias for @code{substitute}.

@code{subst (@var{eq_1}, @var{expr})} or @code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
are other permissible
forms.  The @var{eq_i} are equations indicating substitutions to be made.
For each equation, the right side will be substituted for the left in
the expression @var{expr}.

@code{exptsubst} if @code{true} permits substitutions
like @code{y} for @code{%e^x} in @code{%e^(a*x)} to take place.

@c WHAT IS THIS ABOUT ??
When @code{opsubst} is @code{false},
@code{subst} will not attempt to substitute into the operator of an expression.
E.g. @code{(opsubst: false, subst (x^2, r, r+r[0]))} will work.

Examples:

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
For further examples, do @code{example (subst)}.

@end defun

@c NEEDS CLARIFICATION
@defun substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Similar to @code{substpart}, but @code{substinpart} works on the
internal representation of @var{expr}.

@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             D
(%o1)                    x . --- (f(x))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x+1), 0);
(%o3)                       f1(x + 1)
@end example

If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus

@example
(%i1) part (x+y+z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} holds the value of the last expression selected when using the
part functions.  It is set during the execution of the function and
thus may be referred to in the function itself as shown below.
If @code{partswitch} is set to @code{true} then @code{end} is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.

@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Also, setting the option @code{inflag} to @code{true} and calling @code{part} or @code{substpart} is 
the same as calling @code{inpart} or @code{substinpart}.

@end defun

@c NEEDS CLARIFICATION
@defun substpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Substitutes @var{x} for the subexpression
picked out by the rest of the arguments as in @code{part}.  It returns the
new value of @var{expr}.  @var{x} may be some operator to be substituted for an
operator of @var{expr}.  In some cases @var{x} needs to be enclosed in double-quotes @code{"}
(e.g.  @code{substpart ("+", a*b, 0)} yields @code{b + a}).

@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Also, setting the option @code{inflag} to @code{true} and calling @code{part} or @code{substpart} is 
the same as calling @code{inpart} or @code{substinpart}.

@end defun

@c NEEDS EXPANSION AND EXAMPLES
@defun subvarp (@var{expr})
Returns @code{true} if @var{expr} is a subscripted variable, for example
@code{a[i]}.

@end defun

@defun symbolp (@var{expr})
Returns @code{true} if @var{expr} is a symbol, else @code{false}.
In effect, @code{symbolp(x)} is equivalent to the predicate @code{atom(x) and not numberp(x)}.

@end defun

@defun unorder ()
Disables the aliasing created by the last use of the ordering
commands @code{ordergreat} and @code{orderless}. @code{ordergreat} and @code{orderless} may not
be used more than one time each without calling @code{unorder}. 
See also @code{ordergreat} and @code{orderless}.

@c HMM, IN THIS EXAMPLE, WHY ISN'T %o5 EQUAL TO ZERO ???
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1) - %th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
@end example

@end defun

@c THIS ITEM SEEMS OUT OF PLACE -- IS IT FROM A SHARE PACKAGE ??
@c NEEDS EXAMPLES
@defun vectorpotential (@var{givencurl})
Returns the vector potential of a given
curl vector, in the current coordinate system.
@code{potentialzeroloc} has a similar role as for @code{potential}, but the order of
the left-hand sides of the equations must be a cyclic permutation of
the coordinate variables.

@end defun

@defun xthru (@var{expr})
Combines all terms of @var{expr} (which should be a sum) over a
common denominator without expanding products and exponentiated sums
as @code{ratsimp} does.  @code{xthru} cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.

@c REPHRASE IN NEUTRAL TONE (GET RID OF "IT IS BETTER")
Sometimes it is better to use @code{xthru} before @code{ratsimp}ing an
expression in order to cause explicit factors of the gcd of the
numerator and denominator to be canceled thus simplifying the
expression to be @code{ratsimp}ed.

@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end example

@end defun

@c THIS FUNCTION APPEARS TO BE A HACK; SEE 4'TH ITEM BELOW
@c DUNNO WHETHER WE CAN CLEAR THIS UP
@defun zeroequiv (@var{expr}, @var{v})
Tests whether the expression @var{expr} in the variable
@var{v} is equivalent to zero, returning @code{true}, @code{false}, or
@code{dontknow}.

@code{zeroequiv} has these restrictions:
@enumerate
@item
Do not use functions that Maxima does not know how to
differentiate and evaluate.
@item
If the expression has poles on the real line, there may be errors
in the result (but this is unlikely to occur).
@item
If the expression contains functions which are not solutions to
first order differential equations (e.g.  Bessel functions) there may
be incorrect results.
@item
The algorithm uses evaluation at randomly chosen points for
carefully selected subexpressions.  This is always a somewhat
hazardous business, although the algorithm tries to minimize the
potential for error.
@end enumerate

For example @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} returns
@code{true} and @code{zeroequiv (%e^x + x, x)} returns @code{false}.
On the other hand @code{zeroequiv (log(a*b) - log(a) - log(b), a)} returns @code{dontknow} because
of the presence of an extra parameter @code{b}.

@end defun
