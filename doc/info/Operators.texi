@menu
* nary::                        
* nofix::                       
* operator::                    
* postfix::                     
* prefix::                      
* Definitions for Operators::   
@end menu


@node nary, nofix, Operators, Operators
@section nary
An @code{nary} operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the
operator, e.g. A+B or A+B+C.  The @code{nary("x")} function is a syntax
extension function to declare x to be an @code{nary} operator.
Functions may be declared to be
@code{nary}.  If @code{declare(j,nary);} is done, this tells the simplifier to
simplify, e.g. @code{j(j(a,b),j(c,d))} to @code{j(a, b, c, d)}.

See also @code{syntax}.

@node nofix, operator, nary, Operators
@section nofix
@code{nofix} operators are used to denote functions of no arguments.
The mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a Maxima break, "exit" is behaving similar to a
@code{nofix} operator.  The function @code{nofix("x")} is a syntax extension
function which declares x to be a @code{nofix} operator. 

See also @code{syntax}.

@node operator, postfix, nofix, Operators
@section operator
See @code{operators}.

@node postfix, prefix, operator, Operators
@section postfix
@code{postfix} operators like the @code{prefix} variety denote functions
of a single argument, but in this case the argument immediately
precedes an occurrence of the operator in the input string, e.g. 3! .
The @code{postfix("x")} function is a syntax extension function to declare x
to be a @code{postfix} operator.

See also @code{syntax}.

@node prefix, Definitions for Operators, postfix, Operators
@section prefix
A @code{prefix} operator is one which signifies a function of one
argument, which argument immediately follows an occurrence of the
operator.  @code{prefix("x")} is a syntax extension function to declare x to
be a @code{prefix} operator.

See also @code{syntax}.

@c end concepts Operators
@node Definitions for Operators,  , prefix, Operators
@section Definitions for Operators

@deffn operator "!"
The factorial operator.
For any complex number @code{x} (including integer, rational, and real numbers) except for
negative integers, @code{x!} is defined as @code{gamma(x+1)}.

For an integer @code{x}, @code{x!} simplifies to the product of the integers from 1 to @code{x} inclusive.
@code{0!} simplifies to 1.
For a floating point number @code{x}, @code{x!} simplifies to the value of @code{gamma (x+1)}.
For @code{x} equal to @code{n/2} where @code{n} is an odd integer,
@code{x!} simplifies to a rational factor times @code{sqrt (%pi)}
(since @code{gamma (1/2)} is equal to @code{sqrt (%pi)}).
If @code{x} is anything else,
@code{x!} is not simplified.

The variables
@code{factlim}, @code{minfactorial}, and @code{factcomb} control the simplification
of expressions containing factorials.

The functions @code{gamma}, @code{bffac}, and @code{cbffac}
are varieties of the gamma function.
@code{makegamma} substitutes @code{gamma} for factorials and related functions.

See also @code{binomial}.

@itemize @bullet
@item
The factorial of an integer, half-integer, or floating point argument is simplified
unless the operand is greater than @code{factlim}.

@example
(%i1) factlim: 10$
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          105 sqrt(%pi)
(%o2) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example

@item
The factorial of a complex number, known constant, or general expression is not simplified.
Even so it may be possible simplify the factorial after evaluating the operand.

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003, 

                                          1.227580202486819]
@end example

@item
The factorial of an unbound symbol is not simplified.

@example
(%i1) kill (foo)$
(%i2) foo!;
(%o2)                       foo!
@end example

@item
Factorials are simplified, not evaluated.
Thus @code{x!} may be replaced even in a quoted expression.

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example
@end itemize

@end deffn

@deffn operator "!!"
The double factorial operator.

For an integer, float, or rational number @code{n},
@code{n!!} evaluates to the product @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
where @code{k} is equal to @code{entier (n/2)},
that is, the largest integer less than or equal to @code{n/2}.
Note that this definition does not coincide with other published definitions
for arguments which are not integers.
@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

For an even (or odd) integer @code{n}, @code{n!!} evaluates to the product of
all the consecutive even (or odd) integers from 2 (or 1) through @code{n} inclusive.

For an argument @code{n} which is not an integer, float, or rational,
@code{n!!} yields a noun form @code{genfact (n, n/2, 2)}.
@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn operator "#"
The logical operator "Not equals".

@end deffn

@deffn operator "."
The dot operator, for matrix (non-commutative) multiplication.
When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point in
a floating point number.

See also
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident},
and
@code{dotscrules}.

@end deffn

@deffn operator ":"
The assignment operator.  E.g. A:3 sets the variable A to 3.

@end deffn

@deffn operator "::"
Assignment operator.  :: assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.

@end deffn

@deffn operator "::="
The "::=" is used instead of ":=" to indicate that what
follows is a macro definition, rather than an ordinary functional
definition.  See @code{macros}.

@end deffn

@deffn operator ":="
The function definition operator.  E.g. @code{f(x):=sin(x)} defines
a function @code{f}.

@end deffn

@deffn operator "="
denotes an equation to Maxima.  To the pattern matcher in
Maxima it denotes a total relation that holds between two expressions
if and only if the expressions are syntactically identical.

@end deffn

@defun abs (exp)
returns the absolute value exp.  If exp is complex, returns the complex
modulus of exp.

@end defun
@c end concepts Operators

@defvr {special symbol} additive
If @code{declare(f,additive)} has been executed, then:

(1) If @code{f} is univariate, whenever the simplifier encounters @code{f} applied
to a sum, @code{f} will be distributed over that sum.  I.e. @code{f(y+x)} will
simplify to @code{f(y)+f(x)}.

(2) If @code{f} is a function of 2 or more arguments, additivity is defined as 
additivity in the first argument to @code{f}, as in the case of @code{sum} or 
@code{integrate}, i.e. @code{f(h(x)+g(x),x)} will simplify to @code{f(h(x),x)+f(g(x),x)}.
This simplification does not occur when @code{f} is applied to expressions of
the form @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@defvr keyword allbut
works with the @code{part} commands (i.e. @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart}, and @code{lpart}).  For example,

@example
(%i1) expr: e+d+c+b+a$
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

while

@example
(%i3) part (expr, allbut (2, 5));
(%o3)                       e + c + b
@end example

It also works with the @code{kill} command,

@example
kill (allbut (name_1, ..., name_k))
@end example

will do a @code{kill (all)} except it will not
@code{kill} the names specified.  Note: @code{name_i} means a name such as function
name such as @code{u}, @code{f}, @code{foo}, or @code{g}, not an infolist such as @code{functions}.


@end defvr

@defvr declaration antisymmetric
If @code{declare(h,antisymmetric)} is done, this tells the
simplifier that @code{h} is antisymmetric.  E.g. @code{h(x,z,y)} will simplify to
@code{- h(x, y, z)}.  That is, it will give (-1)^n times the result given by
@code{symmetric} or @code{commutative}, where n is the number of interchanges of two
arguments necessary to convert it to that form.

@end defvr

@defun cabs (exp)
returns the complex absolute value (the complex modulus) of
exp.

@end defun

@defvr declaration commutative
If @code{declare(h,commutative)} is done, this tells the
simplifier that @code{h} is a commutative function.  E.g. @code{h(x,z,y)} will
simplify to @code{h(x, y, z)}.  This is the same as @code{symmetric}.

@end defvr

@defun entier (x)
largest integer <= X where X is numeric.  @code{fix} (as in
@code{fixnum}) is a synonym for this, so @code{fix(x)} is precisely the same.

@end defun

@defun equal (expr1,expr2)
used with an @code{is}, returns @code{true} (or @code{false}) if
and only if expr1 and expr2 are equal (or not equal) for all possible
values of their variables (as determined by @code{ratsimp}).  Thus
@code{is(equal((x+1)**2,x**2+2*x+1))} returns @code{true} whereas if X is unbound
@code{is((x+1)**2=x**2+2*x+1)} returns @code{false}.  Note also that @code{is(rat(0)=0)}
gives @code{false} but @code{is(equal(rat(0),0))} gives @code{true}.  If a determination
can't be made with @code{equal} then a simplified but equivalent form is
returned whereas = always causes either @code{true} or @code{false} to be returned.
All variables occurring in exp are presumed to be real valued.
@code{ev(exp,pred)} is equivalent to @code{is(exp)}.

@example
(%i1) is (x^2 >= 2*x - 1);
(%o1)                         true
(%i2) assume (a > 1);
(%o2)                        [a > 1]
(%i3) is (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
(%o3)                         true
@end example

@end defun

@defun eval
causes an extra post-evaluation of exp to occur.

@end defun

@defun evenp (exp)
is @code{true} if exp is an even integer.  @code{false} is returned in
all other cases.

@end defun

@defun fix (x)
a synonym for @code{entier(x)} - largest integer <= X where X is
numeric.

@end defun

@defun fullmap (fn, exp1, ...)
is similar to @code{map} but it will keep mapping
down all subexpressions until the main operators are no longer the
same.  The user should be aware that @code{fullmap} is used by the Maxima
simplifier for certain matrix manipulations; thus, the user might see
an error message concerning @code{fullmap} even though @code{fullmap} was not
explicitly called by the user.

@example
(%i1) a + b*c$
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end defun

@defun fullmapl (fn, list1, ...)
is similar to @code{fullmap} but it only maps onto
lists and matrices.

@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end defun

@defun is (exp)
attempts to determine whether exp (which must evaluate to a
predicate) is provable from the facts in the current data base.  @code{is}
returns @code{true} if the predicate is true for all values of its variables
consistent with the data base and returns @code{false} if it is false for all
such values.  Otherwise, its action depends on the setting of the
switch @code{prederror}. @code{is} errs out if the value of
@code{prederror} is @code{true} and returns @code{unknown} if @code{prederror} is @code{false}.

@end defun

@defun isqrt (x)
takes one integer argument and returns the "integer square root"
of its absolute value.

@end defun

@defun max (x1, x2, ...)
yields the maximum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

@end defun

@defun min (x1, x2, ...)
yields the minimum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

@end defun

@defun mod (poly)
converts the polynomial poly to a modular representation
with respect to the current modulus which is the value of the variable
@code{modulus}.  
@code{mod(poly,m)} specifies a @code{modulus} m to be used for converting poly, if
it is desired to override the current global value of @code{modulus}.
See @code{modulus}.

@end defun

@defun oddp (exp)
is @code{true} if exp is an odd integer.  @code{false} is returned in all
other cases.

@end defun

@deffn operator pred
Causes predicates (expressions which evaluate to @code{true}
or @code{false}) to be evaluated.

See also @code{evflag}.

@end deffn

@defun random (x)
Returns a pseudorandom number. If @code{x} is an integer, @code{random (x)} returns an
integer from 0 through @code{x-1} inclusive. If @code{x} is a floating point number,
@code{random (x)} returns a nonnegative floating point number less than @code{x}.
@code{random} complains with an error if @code{x} is neither an integer nor a float,
or if @code{x} is not positive.

Maxima @code{random} calls the Lisp function @code{RANDOM}. Different Lisp 
implementations may use different pseudorandom number generators.
The state of the generator is not directly accessible from Maxima,
although it can be accessed from the Lisp prompt using the Lisp
functions @code{MAKE-RANDOM-STATE} and @code{RANDOM}, and the global variable
@code{*RANDOM-STATE*}.

@end defun

@defun sign (exp)
Attempts to determine the sign of its specified expression
on the basis of the facts in the current data base.  It returns one of
the following answers: @code{pos} (positive), @code{neg} (negative), @code{zero}, @code{pz}
(positive or zero), @code{nz} (negative or zero), @code{pn} (positive or negative),
or @code{pnz} (positive, negative, or zero, i.e. nothing known).

@end defun

@defun signum (x)
if X<0 then -1 else if X>0 then 1 else 0.  If X is not
numeric then a simplified but equivalent form is returned. For
example, @code{signum(-x)} gives @code{-signum(x)}.

@end defun

@defun sort (list,optional-predicate)
sorts the list using a suitable
optional-predicate of two arguments (such as "<" or @code{orderlessp}).  If
the optional-predicate is not given, then Maxima's built-in ordering
predicate is used.

@end defun

@defun sqrt (x)
the square root of X. It is represented internally by
X^(1/2).  See also @code{rootscontract}.

@code{radexpand} if @code{true} will cause nth roots of factors of a product
which are powers of n to be pulled outside of the radical, e.g.
@code{sqrt(16*x^2)} will become @code{4*x} only if @code{radexpand} is @code{true}.

@end defun

@defvar sqrtdispflag
default: @code{true} - if @code{false} causes @code{sqrt} to display with
exponent 1/2.

@end defvar

@defun sublis (list,expr)
allows multiple substitutions into an expression in
parallel.  Sample syntax:

@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example

The variable @code{sublis_apply_lambda} controls simplification after
@code{sublis}.

@end defun

@defun sublist (l,f)
returns the list of elements of the list @code{l} for which the
function @code{f} returns @code{true}.  E.g., @code{sublist([1,2,3,4],evenp)} returns
@code{[2,4]}.

@end defun

@defvar sublis_apply_lambda
default: @code{true} - controls whether @code{lambda}'s
substituted are applied in simplification after @code{sublis} is used or
whether you have to do an @code{ev} to get things to apply. @code{true} means do the
application.

@end defvar

@defun subst (a, b, c)
substitutes a for b in c.  b must be an atom, or a
complete subexpression of c.  For example, X+Y+Z is a complete
subexpression of 2*(X+Y+Z)/W while X+Y is not. When b does not have
these characteristics, one may sometimes use @code{substpart} or @code{ratsubst}
(see below).  Alternatively, if b is of the form e/f then one could
use @code{subst(a*f,e,c)} while if b is of the form e**(1/f) then one could
use @code{subst(a**f,e,c)}.  The @code{subst} command also discerns the x^y in x^-y
so that @code{subst(a,sqrt(x),1/sqrt(x))} yields 1/a.  a and b may also be
operators of an expression enclosed in "s or they may be function
names.  If one wishes to substitute for the independent variable in
derivative forms then the @code{at} function (see below) should be used.

Note:  @code{subst} is an alias for @code{substitute}.
@code{subst(eq1,exp)} or @code{subst([eq1,...,eqk],exp)} are other permissible
forms.  The eqi are equations indicating substitutions to be made.
For each equation, the right side will be substituted for the left in
the expression exp.

@code{exptsubst} if @code{true} permits substitutions like Y for %E**X in
%E**(A*X) to take place.

@code{opsubst} if @code{false}, @code{subst} will not attempt to substitute into the
operator of an expression.  E.g. @code{(opsubst:false, subst(x^2,r,r+r[0]));}
will work.

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
(Note that %i2 is one way of obtaining the complex conjugate of an analytic
expression.)  For further examples, do @code{example(subst)}.

@end defun

@defun substinpart (x, exp, n1, ...)
is like @code{substpart} but works on the
internal representation of exp.

@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             D
(%o1)                    x . --- (f(x))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x+1), 0);
(%o3)                       f1(x + 1)
@end example

If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus

@example
(%i1) part (x+y+z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} holds the value of the last expression selected when using the
part functions.  It is set during the execution of the function and
thus may be referred to in the function itself as shown below.
If @code{partswitch} is set to @code{true} then @code{end} is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.

@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Also, setting the option @code{inflag} to @code{true} and calling @code{part} or @code{substpart} is 
the same as calling @code{inpart} or @code{substinpart}.

@end defun

@defun substpart (x, exp, n1, ..., nk)
Substitutes x for the subexpression
picked out by the rest of the arguments as in @code{part}.  It returns the
new value of exp.  x may be some operator to be substituted for an
operator of exp.  In some cases it needs to be enclosed in "s (e.g.
@code{substpart("+",a*b,0)} yields B + A.

@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Also, setting the option @code{inflag} to @code{true} and calling @code{part} or @code{substpart} is 
the same as calling @code{inpart} or @code{substinpart}.

@end defun

@defun subvarp (exp)
is @code{true} if exp is a subscripted variable, for example
A[I].

@end defun

@defun symbolp (exp)
returns @code{true} if "exp" is a "symbol" or "name", else
@code{false}.  I.e., in effect, @code{symbolp(x):=atom(x) and not numberp(x)}.

@end defun

@defun unorder ()
stops the aliasing created by the last use of the ordering
commands @code{ordergreat} and @code{orderless}. @code{ordergreat} and @code{orderless} may not
be used more than one time each without calling @code{unorder}. 
See also @code{ordergreat} and @code{orderless}.

@c HMM, IN THIS EXAMPLE, WHY ISN'T %o5 EQUAL TO ZERO ???
@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1) - %th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
@end example

@end defun

@defun vectorpotential (givencurl)
Returns the vector potential of a given
curl vector, in the current coordinate system.
@code{potentialzeroloc} has a similar role as for @code{potential}, but the order of
the left-hand sides of the equations must be a cyclic permutation of
the coordinate variables.

@end defun

@defun xthru (exp)
combines all terms of exp (which should be a sum) over a
common denominator without expanding products and exponentiated sums
as @code{ratsimp} does.  @code{xthru} cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.  Sometimes it is better to use @code{xthru} before @code{ratsimp}ing an
expression in order to cause explicit factors of the gcd of the
numerator and denominator to be canceled thus simplifying the
expression to be @code{ratsimp}ed.

@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end example

@end defun

@defun zeroequiv (exp,var)
tests whether the expression exp in the variable
var is equivalent to zero.  It returns either @code{true}, @code{false}, or
@code{dontknow}.  For example @code{zeroequiv(sin(2*x) - 2*sin(x)*cos(x),x)} returns
@code{true} and @code{zeroequiv(%e^x+x,x)} returns @code{false}.  On the other hand
@code{zeroequiv(log(a*b) - log(a) - log(b),a)} will return @code{dontknow} because
of the presence of an extra parameter.  The restrictions are:
(1) Do not use functions that Maxima does not know how to
differentiate and evaluate.
(2) If the expression has poles on the real line, there may be errors
in the result (but this is unlikely to occur).
(3) If the expression contains functions which are not solutions to
first order differential equations (e.g.  Bessel functions) there may
be incorrect results.
(4) The algorithm uses evaluation at randomly chosen points for
carefully selected subexpressions.  This is always a somewhat
hazardous business, although the algorithm tries to minimize the
potential for error.

@end defun
