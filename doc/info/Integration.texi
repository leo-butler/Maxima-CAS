@menu
* Introduction to Integration::  
* Definitions for Integration::  
@end menu

@node Introduction to Integration, Definitions for Integration, Integration, Integration
@section Introduction to Integration

Maxima has several routines for handling integration.
The @code{integrate} command makes use of most of them.  There is also the
@code{antid} package, which handles an unspecified function (and its
derivatives, of course).  For numerical uses, there is the @code{romberg}
function; an
adaptave integrator which uses the Newton-Cotes 8 panel quadrature
rule, called @code{quanc8}; and a set of adaptive integrators from Quadpack,
named @code{quad_qag}, @code{quad_qags}, etc.
Hypergeometric functions are being worked on,
see @code{specint} for details.
Generally speaking, Maxima only handles integrals which are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as @code{g(x)} and @code{h(x)}.

@c end concepts Integration
@node Definitions for Integration,  , Introduction to Integration, Integration
@section Definitions for Integration

@defun changevar (expr, f(x,y), y, x)
Makes the change of variable given by
@code{f(x,y) = 0} in all integrals occurring in @code{expr} with integration with
respect to @code{x}; @code{y} is the new variable.

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end example

@code{changevar} may also be used to changes in the indices of a sum or
product.  However, it must be realized that when a change is made in a
sum or product, this change must be a shift, i.e., @code{i = j+ ...}, not a
higher degree function.  E.g.,

@example
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end example

@end defun

@defun dblint ('f, 'r, 's, a, b)
A double-integral routine which was written in
top-level Maxima and then translated and compiled to machine code.
Use @code{load (dblint)} to access this package.  It uses the Simpson's rule
method in both the x and y directions to calculate

@example
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end example

The function @code{f(x,y)} must be a translated or compiled function of two
variables, and @code{r(x)} and @code{s(x)} must each be a translated or compiled
function of one variable, while @code{a} and @code{b} must be floating point
numbers. The routine has two global variables which determine the
number of divisions of the x and y intervals: @code{dblint_x} and @code{dblint_y},
both of which are initially 10, and can be changed independently to
other integer values (there are @code{2*dblint_x+1} points computed in the x
direction, and @code{2*dblint_y+1} in the y direction).
The routine subdivides the X axis and then for each value of X it
first computes @code{r(x)} and @code{s(x)}; then the Y axis between @code{r(x)} and @code{s(x)} is
subdivided and the integral along the Y axis is performed using
Simpson's rule; then the integral along the X axis is done using
Simpson's rule with the function values being the Y-integrals. This
procedure may be numerically unstable for a great variety of reasons,
but is reasonably fast: avoid using it on highly oscillatory functions
and functions with singularities (poles or branch points in the
region).  The Y integrals depend on how far apart @code{r(x)} and @code{s(x)} are,
so if the distance @code{s(x)-r(x)} varies rapidly with X, there may be
substantial errors arising from truncation with different step-sizes
in the various Y integrals. One can increase @code{dblint_x} and @code{dblint_y} in
an effort to improve the coverage of the region, at the expense of
computation time. The function values are not saved, so if the
function is very time-consuming, you will have to wait for
re-computation if you change anything (sorry).
It is required that the functions @code{f}, @code{r}, and @code{s} be either translated or
compiled prior to calling @code{dblint}. This will result in orders of
magnitude speed improvement over interpreted code in many cases!

@code{demo (dblint)} executes a demonstration of @code{dblint} applied to an example problem.
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT. !!!
@c @code{demo (dblint_1)} executes another demonstration.

@end defun

@defun defint (expr, var, low, high)
Definite integration, the same as
@code{integrate (expr,var,low,high)}.   This uses symbolic methods, if
you wish to use a numerical method try @code{romberg (expr,var,low,high)}.

@end defun

@defun erf (x)
The error function, whose derivative is:
@code{2*exp(-x^2)/sqrt(%pi)}.
@c UMM, THAT IS AN INCOMPLETE DEFINITION !!!

@end defun

@defvar erfflag
Default value: @code{true}

When @code{erfflag} is @code{false}, prevents @code{risch} from introducing the
@code{erf} function in the answer if there were none in the integrand to
begin with.

@end defvar

@defun ilt (expr, lvar, ovar)
Takes the inverse Laplace transform of @code{expr} with
respect to @code{lvar} and parameter @code{ovar}.  @code{expr} must be a ratio of
polynomials whose denominator has only linear and quadratic factors.
By using the functions @code{laplace} and @code{ilt} together with the @code{solve} or
@code{linsolve} functions the user can solve a single differential or
convolution integral equation or a set of them.

@example
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end example

@end defun

@defun integrate (expr, var)
@defunx integrate (expr, var, a, b)
Integrates @code{expr} with respect to @code{var} or returns an
integral expression (the noun form) if it cannot perform the
integration (see note 1 below).
@code{integrate (expr, var, a, b)} is a definite integral,
with limits of integration @code{a} and @code{b},
while @code{integrate (expr, var)} is an indefinite integral.

Roughly speaking three stages are used:

@itemize @bullet
@item
@code{integrate} sees if the integrand is of the form
@code{f(g(x))*diff(g(x),x)} by testing whether the derivative of some
subexpression (@code{g(x)} in the above case) divides the integrand.  If
so it looks up @code{f} in a table of integrals and substitutes @code{g(x)} for @code{x} in
the integral of @code{f}.  This may make use of gradients in taking the
derivative.  (If an unknown function appears in the integrand it must
be eliminated in this stage or else @code{integrate} will return the noun
form of the integrand.)
@item
@code{integrate} tries to match the integrand to a form for which a
specific method can be used, e.g.  trigonometric substitutions.
@item
If the first two stages fail it uses the Risch algorithm.
@end itemize

Functional relationships must be explicitly represented in order
for @code{integrate} to work properly.  @code{integrate} is not affected by
dependencies set up with the @code{depends} command.
@code{integrate (expr, var, a, b)} finds the definite integral of @code{expr} with
respect to @code{var} from @code{a} to @code{b} or returns the noun form if it cannot
perform the integration.  The limits should not contain @code{var}.  Several
methods are used, including direct substitution in the indefinite
integral and contour integration.  Improper integrals may use the
names @code{inf} for positive infinity and @code{minf} for negative infinity.  If an
integral "form" is desired for manipulation (for example, an integral
which cannot be computed until some numbers are substituted for some
parameters), the noun form @code{'integrate} may be used and this will
display with an integral sign.  (See Note 1 below.)

The function @code{ldefint} uses @code{limit} to evaluate the integral at the
lower and upper limits.

Sometimes during integration the user may be asked what the sign
of an expression is.  Suitable responses are @code{pos;}, @code{zero;}, or @code{neg;}.

Examples:

@example
(%i1) integrate (sin(x)**3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
Is  a + 1  positive, negative, or zero?

pos;
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end example

(Note 1) The fact that Maxima does not perform certain integrals does
not always imply that the integral does not exist in closed form. In
the example below the integration call returns the noun form but the
integral can be found fairly easily. For example, one can compute the
roots of @code{x^3+x+1 = 0} to rewrite the integrand in the form
@code{1/((x-a)*(x-b)*(x-c))}
where @code{a}, @code{b}, and @code{c} are the roots. Maxima will
integrate this equivalent form although the integral is quite
complicated.

@example
(%i6) integrate (1/(x^3+x+1),x);
                         /
                         [     1
(%o6)                    I ---------- dx
                         ]  3
                         / x  + x + 1
@end example

@end defun

@defvar integration_constant_counter
Default value: 0

@c WHEN DOES integrationconstant1 SHOW UP IN THE OUTPUT OF integrate ???
@c integrate (a, x) YIELDS "a x", NOT "a x + integrationconstant1" !!!
@code{integration_constant_counter} is a counter which is updated each time a
constant of integration (named by Maxima, e.g., @code{integrationconstant1})
is introduced into an expression by indefinite integration of an equation.

@end defvar

@defvar integrate_use_rootsof
Default value: @code{false}

When @code{integrate_use_rootsof} is @code{true} and the denominator of
a rational function cannot be factored, @code{integrate} returns the integral
in a form which is a sum over the roots of the denominator.

@example
(%i1) integrate_use_rootsof: false$
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end example

but now we set the flag to be true and the first part of the
integral will undergo further simplification.

@example
(%i3) integrate_use_rootsof: true$
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                      3    2
      %r4 in rootsof(x  - x  + 1)
(%o4) ----------------------------------------------------------
               7

                                                             2 x + 1
                                         2            5 atan(-------)
                                    log(x  + x + 1)          sqrt(3)
                                  - --------------- + ---------------
                                          14             7 sqrt(3)
@end example

Note that it may be that we want to approximate the roots in the
complex plane, and then provide the function factored, since we
will then be able to group the roots and their complex conjugates,
so as to give a better answer.

@end defvar

@defun ldefint (expr, var, ll, ul)
Yields the definite integral of @code{expr} by using
@code{limit} to evaluate the indefinite integral of @code{expr} with respect to @code{var}
at the upper limit @code{ul} and at the lower limit @code{ll}.

@end defun

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@defun potential (givengradient)
The calculation makes use of the global variable @code{potentialzeroloc[0]}
which must be @code{nonlist} or of the form

@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example

the
former being equivalent to the nonlist expression for all right-hand
sides in the latter.  The indicated right-hand sides are used as the
lower limit of integration.  The success of the integrations may
depend upon their values and order. @code{potentialzeroloc} is initially set
to 0.

@end defun

@defun qq
 The package @code{qq} (which may be loaded with @code{load ("qq")})
contains a function @code{quanc8} which can take either 3 or 4 arguments. The
3 arg version computes the integral of the function specified as the
first argument over the interval from lo to hi as in
@code{quanc8 ('function, lo, hi)}.
The function name should be quoted.  The 4 arg version will compute
the integral of the function or expression (first arg) with respect to
the variable (second arg) over the interval from @code{lo} to @code{hi} as in
@code{quanc8(<f(x) or expression in x>, x, lo, hi)}.
The method used is the Newton-Cotes 8th order polynomial quadrature,
and the routine is adaptive. It will thus spend time dividing the
interval only when necessary to achieve the error conditions specified
by the global variables @code{quanc8_relerr} (default value=1.0e-4) and
@code{quanc8_abserr} (default value=1.0e-8) which give the relative error
test:

@example
|integral(function) - computed value| < quanc8_relerr*|integral(function)|
@end example

and the absolute error test:

@example
|integral(function) - computed value| < quanc8_abserr
@end example

@code{printfile ("qq.usg")} yields additional information.

@end defun

@defun quanc8 ('function, lo, hi)
An adaptive integrator.
Demonstration and usage files are provided.  The method is to
use Newton-Cotes 8-panel quadrature rule, hence the function name
@code{quanc8}, available in 3 or 4 arg versions.  Absolute and relative error
checks are used.  To use it do @code{load ("qq")}.  See also @code{qq}.

@end defun

@defun residue (expr, var, val)
Computes the residue in the complex plane of
the expression @code{expr} when the variable @code{var} assumes the value @code{val}.  The
residue is the coefficient of @code{(var-val)**(-1)} in the Laurent series
for @code{expr}.

@example
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end example

@end defun

@defun risch (expr, var)
Integrates @code{expr} with respect to @code{var} using the
transcendental case of the Risch algorithm.  (The algebraic case of
the Risch algorithm has not been implemented.)  This currently
handles the cases of nested exponentials and logarithms which the main
part of @code{integrate} can't do.  @code{integrate} will automatically apply @code{risch}
if given these cases.
@code{erfflag}, if @code{false}, prevents @code{risch} from introducing the @code{erf}
function in the answer if there were none in the integrand to begin
with.

@example
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end example

@end defun

@defun romberg (expr, var, ll, ul)
@defunx romberg (expr, ll, ul)
Romberg integration.
There are two ways to use this function.  The first is an inefficient
way like the definite integral version of @code{integrate}:
@code{romberg (<integrand>, <variable of integration>, <lower limit>, <upper limit>)}.

Examples:
@example
(%i1) showtime: true$
(%i2) romberg (sin(y), y, 0, %pi);
Evaluation took 0.00 seconds (0.01 elapsed) using 25.293 KB.
(%o2)                   2.000000016288042
(%i3) 1/((x-1)^2+1/100) + 1/((x-2)^2+1/1000) + 1/((x-3)^2+1/200)$
(%i4) f(x) := ''%$
(%i5) rombergtol: 1e-6$
(%i6) rombergit: 15$
(%i7) romberg (f(x), x, -5, 5);
Evaluation took 11.97 seconds (12.21 elapsed) using 12.423 MB.
(%o7)                   173.6730736617464
@c INCLUDE THIS COMPARISON TO EXACT RESULT ??? YIELDS A LOT OF "RAT replaced" MESSAGES !!!
@c integrate (f(x), x, -5, 5) - %, numer;
@end example

The second is an efficient way that is used as follows:

@example
romberg (<function name>, <lower limit>, <upper limit>);
@end example

Continuing the above example, we have:
@example
(%i8) f(x) := (mode_declare ([function(f), x], float), ''(%th(5)))$
(%i9) translate(f);
(%o9)                          [f]
(%i10) romberg (f, -5, 5);
Evaluation took 3.51 seconds (3.86 elapsed) using 6.641 MB.
(%o10)                  173.6730736617464
@end example

The first argument must be a translated or compiled function.  (If it
is compiled it must be declared to return a @code{flonum}.)  If the first
argument is not already translated, @code{romberg} will not attempt to
translate it but will give an error.

The accuracy of the integration is governed by the global variables
@code{rombergtol} (default value 1.E-4) and @code{rombergit} (default value 11).
@code{romberg} will return a result if the relative difference in successive
approximations is less than @code{rombergtol}.  It will try halving the
stepsize @code{rombergit} times before it gives up.  The number of iterations
and function evaluations which @code{romberg} will do is governed by
@code{rombergabs} and @code{rombergmin}.

@code{romberg} may be called recursively and thus can do double and triple
integrals.

Example:
@example
(%i1) assume (x > 0)$
(%i2) integrate (integrate (x*y/(x+y), y, 0, x/2), x, 1, 3)$
(%i3) radcan (%);
                    26 log(3) - 26 log(2) - 13
(%o3)             - --------------------------
                                3
(%i4) %,numer;
(%o4)                   .8193023963959073
(%i5) define_variable (x, 0.0, float, "Global variable in function F")$
(%i6) f(y) := (mode_declare (y, float), x*y/(x+y))$
(%i7) g(x) := romberg ('f, 0, x/2)$  
(%i8) romberg (g, 1, 3);
(%o8)                   .8193022864324522
@end example

The advantage with this way is that the function @code{f} can be used for other 
purposes, like plotting. The disadvantage is that you have to think up 
a name for both the function @code{f} and its free variable @code{x}.
Or, without the global:

@example
(%i1) g_1(x) := (mode_declare (x, float), romberg (x*y/(x+y), y, 0, x/2))$
(%i2) romberg (g_1, 1, 3);
(%o2)                   .8193022864324522
@end example

The advantage here is shortness.

@example
(%i3) q (a, b) := romberg (romberg (x*y/(x+y), y, 0, x/2), x, a, b)$
(%i4) q (1, 3);
(%o4)                   .8193022864324522
@end example

It is even shorter this way, and the variables do not need to be declared 
because they are in the context of @code{romberg}.
Use of @code{romberg} for multiple integrals can have great disadvantages,
though.  The amount of extra calculation needed because of the
geometric information thrown away by expressing multiple integrals
this way can be incredible.  The user should be sure to understand and
use the @code{rombergtol} and @code{rombergit} switches.

@end defun

@defvar rombergabs
Default value: 0.0

Assuming that successive estimates
produced by @code{romberg} are @code{y[0]}, @code{y[1]}, @code{y[2]}, etc., then @code{romberg} will
return after @code{n} iterations if (roughly speaking)

@example
 (abs(y[n]-y[n-1]) <= rombergabs or
 abs(y[n]-y[n-1])/(if y[n]=0.0 then 1.0 else y[n]) <= rombergtol)
@end example

is @code{true}.  (The condition on the number of iterations given by
@code{rombergmin} must also be satisfied.)
Thus if @code{rombergabs} is 0.0 (the default) you just get the relative
error test.  The usefulness of the additional variable comes when you
want to perform an integral, where the dominant contribution comes
from a small region.  Then you can do the integral over the small
dominant region first, using the relative accuracy check, followed by
the integral over the rest of the region using the absolute accuracy
check.

Example:  Suppose you want to compute

@example
'integrate (exp(-x), x, 0, 50)
@end example

(numerically) with a relative accuracy of  1 part in 10000000.
Define the function.  @code{n} is a counter, so we can see how many
function evaluations were needed.
First of all try doing the whole integral at once.

@example
(%i1) f(x) := (mode_declare (n, integer, x, float), n:n+1, exp(-x))$
(%i2) translate(f)$
Warning-> n is an undefined global variable.
(%i3) block ([rombergtol: 1.e-6, romberabs: 0.0], n:0, romberg (f, 0, 50));
(%o3)                   1.000000000488271
(%i4) n;
(%o4)                          257
@end example

That approach required 257 function evaluations.
 Now do the integral intelligently, by first doing
     @code{'integrate (exp(-x), x, 0, 10)} and then setting @code{rombergabs} to 1.E-6 times (this
     partial integral).
This approach takes only 130 function evaluations.

@example
(%i5) block ([rombergtol: 1.e-6, rombergabs:0.0, sum:0.0],
  n: 0, sum: romberg (f, 0, 10), rombergabs: sum*rombergtol, rombergtol:0.0,
      sum + romberg (f, 10, 50));
(%o5)                   1.000000001234793
(%i6) n;
(%o6)                          130
@end example

So if @code{f(x)} were a function that took a long time to compute, the
second method would be about 2 times quicker.

@end defvar

@defvar rombergit
Default value: 11

The accuracy of the @code{romberg} integration
command is governed by the global variables @code{rombergtol} and
@code{rombergit}.  @code{romberg} will return a result if the relative
difference in successive approximations is less than @code{rombergtol}.  It
will try halving the stepsize @code{rombergit} times before it gives up.

@end defvar

@defvar rombergmin
Default value: 0

@code{rombergmin} governs the minimum number of function
evaluations that @code{romberg} will make.  @code{romberg} will evaluate its first
arg. at least @code{2^(rombergmin+2)+1} times.  This is useful for
integrating oscillatory functions, when the normal converge test might
sometimes wrongly pass.

@end defvar

@defvar rombergtol
Default value: 1e-4

The accuracy of the @code{romberg} integration
command is governed by the global variables @code{rombergtol} and
@code{rombergit}.  @code{romberg} will return a result if the relative
difference in successive approximations is less than @code{rombergtol}.  It
will try halving the stepsize @code{rombergit} times before it gives up.

@end defvar

@defun tldefint (expr, var, ll, ul)
Is just @code{ldefint} with @code{tlimswitch} set to @code{true}.

@end defun
@defun quad_qag (fun, var, a, b, key, [epsrel, [limit]])
Numerically evaluate the integral

@ifinfo
@math{integrate(f(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b {f(x) dx}$$
@end tex

using a simple adaptive integrator.

The function to be integrated is @code{fun}, with dependent
variable @code{var}, and the function is to be integrated between the
limits @code{a} and @code{b}.  @code{key} is the integrator to be used
and should be an integer between 1 and 6, inclusive.  The value of
@code{key} selects the order of the Gauss-Kronrod integration rule.

The numerical integration is done adaptively by subdividing the
integration region into sub-intervals until the desired accuracy is
achieved.

The optional arguments @code{epsrel} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.

A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
if no problems were encountered; 
@item 1
if too many sub-intervals were done;
@item 2
if excessive roundoff error is detected;
@item 3
if extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end example
@end defun

@defun quad_qags (fun, var, a, b, [epsrel, [limit]])

Numerically integrate the given function using adaptive quadrature with
extrapolation.  The function to be integrated is @code{fun}, with
dependent variable @code{var}, and the function is to be integrated
between the limits @code{a} and @code{b}.

The optional arguments @code{epsrel} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.

A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end example
We note that @code{quad_qags} is more accurate and efficient than @code{quad_qag} for this integrand.

@end defun

@defun quad_qagi (fun, var, a, inftype, [epsrel, [limit]])

Numerically evaluate one of the following integrals

@ifinfo
@math{integrate(f(x), x, a, inf)}
@end ifinfo
@tex
$$\int_a^\infty {f(x) dx}$$
@end tex

@ifinfo
@math{integrate(f(x), x, minf, a)}
@end ifinfo
@tex
$$\int_\infty^a {f(x) dx}$$
@end tex

@ifinfo
@math{integrate(f(x), x, a, minf, inf)}
@end ifinfo
@tex
$$\int_\infty^\infty {f(x) dx}$$
@end tex

using the Quadpack QAGI routine.  The function to be integrated is
@code{fun}, with dependent variable @code{var}, and the function is to
be integrated over an infinite range.

The parameter @code{inftype} determines the integration interval as
follows:
@table @code
@item inf
The interval is from @code{a} to positive infinity.
@item minf
The interval is from negative infinity to @code{a}.
@item both
The interval is the entire real line.
@end table

The optional arguments @code{epsrel} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.

A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 4
failed to converge
@item 5
integral is probably divergent or slowly convergent
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end example

@end defun

@defun quad_qawc (fun, var, c, a, b, [epsrel, [limit]])

Numerically compute the Cauchy principal value of

@ifinfo
@math{integrate(f(x)/(x - c), x, a, b)}
@end ifinfo
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

using the Quadpack QAWC routine.  The function to be integrated is
@code{fun/(x-c)}, with dependent variable @code{var}, and the function
is to be integrated over the interval @code{a} to @code{b}.

The optional arguments @code{epsrel} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.


A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

         3 alpha                       3 alpha
         -------                       -------
            2            alpha/2          2          alpha/2
      2 4        atan(4 4       )   2 4        atan(4       )   alpha
    - --------------------------- - -------------------------)/2
                alpha                        alpha
             2 4      + 2                 2 4      + 2
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end example

@end defun


@defun quad_qawf (fun, var, a, omega, trig, [epsabs, limit, maxp1, limlst])

Numerically compute the a Fourier-type integral using the Quadpack QAWF
routine.  The integral is

@ifinfo
@math{integrate(f(x)*w(x), x, a, inf)}
@end ifinfo
@tex
$$\int_a^\infty f(x) w(x) dx$$
@end tex

The weight function w(x) is selected by @code{trig}:
@table @code
@item cos
w(x) = cos(omega*x)
@item sin
w(x) = sin(omega*x)
@end table

The optional arguments are:
@table @code
@item epsabs
Desired absolute error of approximation.  Default is 1d-10.
@item limit
Size of internal work array.  (@code{limit}-@code{limlst})/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table
@code{epsabs} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.


A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end example

@end defun

@defun quad_qawo (fun, var, a, b, omega, trig, [epsabs, limit, maxp1, limlst])

Numerically compute the integral using the Quadpack QAWO
routine:

@ifinfo
@math{integrate(f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex

The weight function w(x) is selected by @code{trig}:
@table @code
@item cos
w(x) = cos(omega*x)
@item sin
w(x) = sin(omega*x)
@end table

The optional arguments are:
@table @code
@item epsabs
Desired absolute error of approximation.  Default is 1d-10.
@item limit
Size of internal work array.  (@code{limit}-@code{limlst})/2 is the
maximum number of subintervals to use.  Default is 200.
@item maxp1
Maximum number of Chebyshev moments.  Must be greater than 0.  Default
is 100.
@item limlst
Upper bound on the number of cycles.  Must be greater than or equal to
3.  Default is 10.
@end table
@code{epsabs} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.


A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end example

@end defun

@defun quad_qaws (fun, var, a, b, alfa, beta, wfun, [epsabs, limit])

Numerically compute the integral using the Quadpack QAWS
routine:

@ifinfo
@math{integrate(f(x)*w(x), x, a, b)}
@end ifinfo
@tex
$$\int_a^b f(x) w(x) dx$$
@end tex

The weight function w(x) is selected by @code{wfun}:
@table @code
@item 1
w(x) = (x-a)^alfa*(b-x)^beta
@item 2
w(x) = (x-a)^alfa*(b-x)^beta*log(x-a)
@item 3
w(x) = (x-a)^alfa*(b-x)^beta*log(b-x)
@item 2
w(x) = (x-a)^alfa*(b-x)^beta*log(x-a)*log(b-x)
@end table

The optional arguments are:
@table @code
@item epsabs
Desired absolute error of approximation.  Default is 1d-10.
@item limit
Size of internal work array.  (@code{limit}-@code{limlst})/2 is the
maximum number of subintervals to use.  Default is 200.
@end table
@code{epsabs} and @code{limit} are the desired
relative error and the maximum number of subintervals, respectively.
@code{epsrel} defaults to 1e-8 and @code{limit} is 200.


A list is returned containing the following elements:  
@itemize
@item
an approximation to the integral,
@item
the estimated absolute error of the approximation, 
@item
the number integrand evaluations,
@item
an error code.
@end itemize

The error code is 
@table @code
@item 0
no problems were encountered; 
@item 1
too many sub-intervals were done;
@item 2
excessive roundoff error is detected;
@item 3
extremely bad integrand behavior occurs;
@item 6
if the input is invalid.

@end table

Examples:
@example
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end example

@end defun

