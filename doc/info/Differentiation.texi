@c end concepts Differentiation
@menu
* Definitions for Differentiation::  
@end menu

@node Definitions for Differentiation,  , Differentiation, Differentiation
@section Definitions for Differentiation

@defun antid (@var{expr}, @var{x}, @var{u(x)}) 
Returns a two-element list,
such that an antiderivative of @var{expr} with respect to @var{x}
can be constructed from the list.
The expression @var{expr} may contain an unknown function @var{u} and its derivatives.

Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
is an antiderivative of @var{expr} with respect to @var{x}.

When @code{antid} succeeds entirely,
the second element of the return value is zero.
Otherwise, the second element is nonzero,
and the first element is nonzero or zero.
If @code{antid} cannot make any progress,
the first element is zero and the second nonzero.

@code{load ("antid")} loads this function.
The @code{antid} package also defines the functions @code{nonzeroandfreeof} and @code{linear}.

@code{antid} is related to @code{antidiff} as follows.
Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then the return value of @code{antidiff} is equal to @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
where @var{x} is the variable of integration.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THESE INPUTS
@c load ("antid")$
@c expr: exp (z(x)) * diff (z(x), x) * y(x);
@c a1: antid (expr, x, z(x));
@c a2: antidiff (expr, x, z(x));
@c a2 - (first (a1) + 'integrate (second (a1), x));
@c antid (expr, x, y(x));
@c antidiff (expr, x, y(x));
@c THERE IS A DEMO FILE share/integration/antid.dem, EXECUTED BY demo('antid)
@c BUT I THINK THE FOLLOWING ILLUSTRATES THE BASIC FUNCTIONALITY MORE CLEARLY
@c MAYBE MERGE IN THE DEMO PROBLEMS LATER

@example
(%i1) load ("antid")$
(%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                            z(x)  d
(%o2)                y(x) %e     (-- (z(x)))
                                  dx
(%i3) a1: antid (expr, x, z(x));
                       z(x)      z(x)  d
(%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                       dx
(%i4) a2: antidiff (expr, x, z(x));
                            /
                     z(x)   [   z(x)  d
(%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                            ]         dx
                            /
(%i5) a2 - (first (a1) + 'integrate (second (a1), x));
(%o5)                           0
(%i6) antid (expr, x, y(x));
                             z(x)  d
(%o6)             [0, y(x) %e     (-- (z(x)))]
                                   dx
(%i7) antidiff (expr, x, y(x));
                  /
                  [        z(x)  d
(%o7)             I y(x) %e     (-- (z(x))) dx
                  ]              dx
                  /
@end example

@end defun

@defun antidiff (@var{expr}, @var{x}, @var{u}(@var{x})})
Returns an antiderivative of @var{expr} with respect to @var{x}.
The expression @var{expr} may contain an unknown function @var{u} and its derivatives.

When @code{antidiff} succeeds entirely,
the resulting expression is free of integral signs (that is, free of the @code{integrate} noun).
Otherwise, @code{antidiff} returns an expression
which is partly or entirely within an integral sign.
If @code{antidiff} cannot make any progress,
the return value is entirely within an integral sign.

@code{load ("antid")} loads this function.
The @code{antid} package also defines the functions @code{nonzeroandfreeof} and @code{linear}.

@code{antidiff} is related to @code{antid} as follows.
Let @var{L}, a list of two elements, be the return value of @code{antid}.
Then the return value of @code{antidiff} is equal to @code{@var{L}[1] + 'integrate (@var{L}[2], @var{x})}
where @var{x} is the variable of integration.

Examples:
@c FOLLOWING EXAMPLES GENERATED FROM THESE INPUTS
@c load ("antid")$
@c expr: exp (z(x)) * diff (z(x), x) * y(x);
@c a1: antid (expr, x, z(x));
@c a2: antidiff (expr, x, z(x));
@c a2 - (first (a1) + 'integrate (second (a1), x));
@c antid (expr, x, y(x));
@c antidiff (expr, x, y(x));
@c THERE IS A DEMO FILE share/integration/antid.dem, EXECUTED BY demo('antid)
@c BUT I THINK THE FOLLOWING ILLUSTRATES THE BASIC FUNCTIONALITY MORE CLEARLY
@c MAYBE MERGE IN THE DEMO PROBLEMS LATER

@example
(%i1) load ("antid")$
(%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                            z(x)  d
(%o2)                y(x) %e     (-- (z(x)))
                                  dx
(%i3) a1: antid (expr, x, z(x));
                       z(x)      z(x)  d
(%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                       dx
(%i4) a2: antidiff (expr, x, z(x));
                            /
                     z(x)   [   z(x)  d
(%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                            ]         dx
                            /
(%i5) a2 - (first (a1) + 'integrate (second (a1), x));
(%o5)                           0
(%i6) antid (expr, x, y(x));
                             z(x)  d
(%o6)             [0, y(x) %e     (-- (z(x)))]
                                   dx
(%i7) antidiff (expr, x, y(x));
                  /
                  [        z(x)  d
(%o7)             I y(x) %e     (-- (z(x))) dx
                  ]              dx
                  /
@end example

@end defun

@c I SUSPECT THERE IS MORE TO BE SAID HERE
@defvr property atomgrad

@code{atomgrad} is the atomic gradient property of an expression.
This property is assigned by @code{gradef}.

@c NEED EXAMPLE HERE
@end defvr

@defun atvalue (@var{expr}, [@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}], @var{c})
@defunx atvalue (@var{expr}, @var{x_1} = @var{a_1}, @var{c})
Assigns the value @var{c} to @var{expr} at the point @code{@var{x} = @var{a}}.
Typically boundary values are established by this mechanism.

@var{expr} is a function evaluation,
@code{@var{f}(@var{x_1}, ..., @var{x_m})},
or a derivative,
@code{diff (@var{f}(@var{x_1}, ..., @var{x_m}), @var{x_1}, @var{n_1}, ..., @var{x_n}, @var{n_m})}
@c HMM, WHAT IS THIS NEXT PHRASE GETTING AT ??
@c DOES IT INTEND TO IMPLY THAT IMPLICIT DEPENDENCIES ARE IGNORED ??
in which the function arguments explicitly appear.
@var{n_i} is the order of differentiation with respect to @var{x_i}.

The point at which the atvalue is established is given by the list of equations
@code{[@var{x_1} = @var{a_1}, ..., @var{x_m} = @var{a_m}]}.
If there is a single variable @var{x_1},
the sole equation may be given without enclosing it in a list.

@code{printprops ([@var{f_1}, @var{f_2}, ...], atvalue)} displays the atvalues of
the functions @code{@var{f_1}, @var{f_2}, ...}
as specified by calls to @code{atvalue}.
@code{printprops (@var{f}, atvalue)} displays the atvalues of one function @var{f}.
@code{printprops (all, atvalue)} displays the atvalues of all functions for which atvalues are defined.

The symbols @code{@@1}, @code{@@2}, ... represent the 
variables @var{x_1}, @var{x_2}, ... when atvalues are displayed.

@code{atvalue} evaluates its arguments.
@code{atvalue} returns @var{c}, the atvalue.

Examples:
@c FOLLOWING ADAPTED FROM example (atvalue)
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x,y)^2 - u(x,y)^2, x);
@c at (%, [x = 0, y = 1]);

@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@end defun

@c LOOKS LIKE cartan IS THE NAME OF A PACKAGE AND NOT A FUNCTION OR VARIABLE
@c PROBABLY SHOULD SPLIT OUT cartan AND ITS CONTENTS INTO ITS OWN TEXINFO FILE
@c ext_diff AND lie_diff NOT DOCUMENTED (OTHER THAN HERE)
@defun cartan  -
The exterior calculus of differential forms is a basic tool
of differential geometry developed by Elie Cartan and has important
applications in the theory of partial differential equations.
The @code{cartan} package
implements the functions @code{ext_diff} and @code{lie_diff},
along with the operators @code{~} (wedge product) and @code{|} (contraction
of a form with a vector.)
Type @code{demo (tensor)} to see a brief
description of these commands along with examples.

@code{cartan} was implemented by F.B. Estabrook and H.D. Wahlquist.

@end defun

@defun del (@var{x})
@code{del (@var{x})} represents the differential of the variable @math{x}.

@code{diff} returns an expression containing @code{del}
if an independent variable is not specified.
In this case, the return value is the so-called "total differential".

Examples:
@c GENERATED FROM THE FOLLOWING
@c diff (log (x));
@c diff (exp (x*y));
@c diff (x*y*z);

@example
(%i1) diff (log (x));
                             del(x)
(%o1)                        ------
                               x
(%i2) diff (exp (x*y));
                     x y              x y
(%o2)            x %e    del(y) + y %e    del(x)
(%i3) diff (x*y*z);
(%o3)         x y del(z) + x z del(y) + y z del(x)
@end example

@end defun

@defun delta (@var{t})
The Dirac Delta function.

Currently only @code{laplace} knows about the @code{delta} function.

Example:

@example
(%i1) laplace (delta (t - a) * sin(b*t), t, s);
Is  a  positive, negative, or zero?

p;
                                   - a s
(%o1)                   sin(a b) %e
@end example

@end defun

@defvar dependencies
Default value: []

@code{dependencies} is the list of atoms which have functional
dependencies, assigned by @code{depends} or @code{gradef}.
The @code{dependencies} list is cumulative:
each call to @code{depends} or @code{gradef} appends additional items.

See @code{depends} and @code{gradef}.

@end defvar

@defun depends (@var{f_1}, @var{x_1}, ..., @var{f_n}, @var{x_n})
Declares functional dependencies among variables for the purpose of computing derivatives.
In the absence of declared dependence,
@code{diff (f, x)} yields zero.
If @code{depends (f, x)} is declared,
@code{diff (f, x)} yields a symbolic derivative (that is, a @code{diff} noun).

Each argument @var{f_1}, @var{x_1}, etc., can be the name of a variable or array,
or a list of names.
Every element of @var{f_i} (perhaps just a single element)
is declared to depend
on every element of @var{x_i} (perhaps just a single element).
If some @var{f_i} is the name of an array or contains the name of an array,
all elements of the array depend on @var{x_i}.

@code{diff} recognizes indirect dependencies established by @code{depends}
and applies the chain rule in these cases.

@code{remove (@var{f}, dependency)} removes all dependencies declared for @var{f}.

@code{depends} returns a list of the dependencies established.
The dependencies are appended to the global variable @code{dependencies}.
@code{depends} evaluates its arguments.

@code{diff} is the only Maxima command which recognizes dependencies established by @code{depends}.
Other functions (@code{integrate}, @code{laplace}, etc.)
only recognize dependencies explicitly represented by their arguments.
For example, @code{integrate} does not recognize the dependence of @code{f} on @code{x}
unless explicitly represented as @code{integrate (f(x), x)}.

@c GENERATED BY THE FOLLOWING
@c depends ([f, g], x);
@c depends ([r, s], [u, v, w]);
@c depends (u, t);
@c dependencies;
@c diff (r.s, u);
@example
(%i1) depends ([f, g], x);
(%o1)                     [f(x), g(x)]
(%i2) depends ([r, s], [u, v, w]);
(%o2)               [r(u, v, w), s(u, v, w)]
(%i3) depends (u, t);
(%o3)                        [u(t)]
(%i4) dependencies;
(%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
(%i5) diff (r.s, u);
                         dr           ds
(%o5)                    -- . s + r . --
                         du           du
@end example

@c GENERATED BY THE FOLLOWING
@c diff (r.s, t);
@example
(%i6) diff (r.s, t);
                      dr du           ds du
(%o6)                 -- -- . s + r . -- --
                      du dt           du dt
@end example

@c GENERATED BY THE FOLLOWING
@c remove (r, dependency);
@c diff (r.s, t);
@example
(%i7) remove (r, dependency);
(%o7)                         done
(%i8) diff (r.s, t);
                                ds du
(%o8)                       r . -- --
                                du dt
@end example

@end defun

@defvar derivabbrev
Default value: @code{false}

When @code{derivabbrev} is @code{true},
symbolic derivatives (that is, @code{diff} nouns) are displayed as subscripts.
Otherwise, derivatives are displayed in the Leibniz notation @code{dy/dx}.

@c NEED EXAMPLES HERE
@end defvar

@c SEEMS LIKE THIS STATEMENT COULD BE LESS CLUMSY
@defun derivdegree (@var{expr}, @var{y}, @var{x})
Returns the highest degree of the derivative
of the dependent variable @var{y} with respect to the independent variable
@var{x} occuring in @var{expr}.

Example:
@c GENERATED FROM THE FOLLOWING
@c 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
@c derivdegree (%, y, x);
@example
(%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                         3     2
                        d y   d y    2 dy
(%o1)                   --- + --- + x  --
                          3     2      dx
                        dz    dx
(%i2) derivdegree (%, y, x);
(%o2)                           2
@end example

@end defun

@defun derivlist (@var{var_1}, ..., @var{var_k})
causes only differentiations with respect to
the indicated variables, within the @code{ev} command.

@end defun

@defvar derivsubst
 default: @code{false} - controls non-syntactic substitutions
such as

@example
subst(x,'diff(y,t),'diff(y,t,2));
@end example

If @code{derivsubst} is set to
true, this gives @code{'diff(x,t)}.

@end defvar

@defun diff (@var{expr}, @var{v1}, @var{n1}, @var{v2}, @var{n2}, ...)
@code{diff} differentiates exp with respect to
each vi, ni times.  If just the first derivative with respect to one
variable is desired then the form @code{diff(exp,v)} may be used.  If the
noun form of the function is required (as, for example, when writing a
differential equation), @code{'diff} should be used and this will display in
a two dimensional format.

@code{derivabbrev} if @code{true} will cause derivatives to display as
subscripts.

@code{diff(exp)} gives the "total differential", that is, the sum of the
derivatives of exp with respect to each of its variables times the
function @code{del} of the variable.  No further simplification of @code{del} is
offered.

@example
(%i1) diff(exp(f(x)),x,2);
                             2
                      f(x)  d             f(x)  d         2
(%o1)                %e     (--- f(x)) + %e     (-- (f(x)))
                              2                 dx
                            dx
(%i2) derivabbrev:true$
(%i3) 'integrate(f(x,y),y,g(x),h(x));
                                h(x)
                               /
                               [
(%o3)                           i     f(x, y) dy
                               ]
                               /
                                g(x)
(%i4) diff(%,x);
            h(x)
           /
           [
(%o4)       i     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
           ]            x                     x                  x
           /
            g(x)
@end example

For the tensor package, the following modifications have been
incorporated:

1) the derivatives of any indexed objects in exp will have the
variables vi appended as additional arguments.  Then all the
derivative indices will be sorted.

2) the vi may be integers from 1 up to the value of the variable
@code{dimension} [default value: 4].  This will cause the differentiation to
be carried out wrt the vith member of the list @code{coordinates} which
should be set to a list of the names of the coordinates, e.g.,
[x,y,z,t]. If @code{coordinates} is bound to an atomic variable, then that
variable subscripted by vi will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like X[1], X[2],... to be used.  If @code{coordinates} has
not been assigned a value, then the variables will be treated as in 1)
above.

@end defun


@defvr {special symbol} diff
[flag] for ev causes all differentiations indicated in exp to be
performed.
@end defvr


@defun dscalar (@var{function})
applies the scalar d'Alembertian to the scalar
function.

@example
(%i41) dependencies(field(r));
(%o41)                           [field(r)]
(%i42) dscalar(field);
(%o43)
    -m
  %e  ((field  n - field  m + 2 field   ) r + 4 field )
             r  r       r  r         r r             r

- -----------------------------------------------------
                             2 r
@end example

@end defun

@defun express (@var{expr})
The result uses the noun form of any
derivatives arising from expansion of the vector differential
operators.  To force evaluation of these derivatives, the built-in @code{ev}
function can be used together with the @code{diff} evflag, after using the
built-in @code{depends} function to establish any new implicit dependencies.

@end defun

@defun gendiff
Sometimes @code{diff(e,x,n)} can be reduced even though N is
symbolic.

@example
batch("gendif")$
@end example

and you can try, for example,

@example
diff(%e^(a*x),x,q)
@end example

by using @code{gendiff} rather than @code{diff}.  Unevaluable
items come out quoted.  Some items are in terms of @code{genfact}, which
see.

@end defun

@defun gradef (@var{f(x1, ..., xn)}, @var{g_1}, ..., @var{g_n})
defines the derivatives of the
function f with respect to its n arguments.  That is, df/dxi = gi,
etc.  If fewer than n gradients, say i, are given, then they refer to
the first i arguments of f.  The xi are merely dummy variables as in
function definition headers and are used to indicate the ith argument
of f.  All arguments to @code{gradef} except the first are evaluated so that
if g is a defined function then it is invoked and the result is used.
It is not permissible to use @code{gradef} on subscripted functions.

Gradients are needed when, for example, a function is not known
explicitly but its first derivatives are and it is desired to obtain
higher order derivatives.

@code{gradef} may also be used to redefine the
derivatives of Maxima's predefined functions (e.g.
@code{gradef(sin(x),sqrt(1-sin(x)**2)))} .

@code{gradefs} is a list of the functions which have been given gradients by
use of the @code{gradef} command (i.e. @code{gradef(f(x1,...,xn),g1, ..., gn))} .

@code{printprops([f1,f2,...],gradef)} may be used to display the gradefs of
the functions f1,f2,..

@code{gradef(a,v,exp)} may be used to state that the derivative of the atomic
variable a with respect to v is exp.  This automatically does a
@code{depends(a,v)}.

@code{printprops([a1,a2,...],atomgrad)} may be used to display the atomic
gradient properties of a1,a2,...

@end defun

@defvar gradefs
 default: [] - a list of the functions which have been given
gradients by use of the @code{gradef} command (i.e. @code{gradef(f(x1, ..., xn), g1, ..., gn)}.)

@end defvar

@defun laplace (@var{expr}, @var{ovar}, @var{lvar})
takes the Laplace transform of exp with
respect to the variable ovar and transform parameter lvar.

@var{expr} may
only involve the functions @code{exp}, @code{log}, @code{sin}, @code{cos}, @code{sinh}, @code{cosh}, and @code{erf}.
It may also be a linear, constant coefficient differential equation in
which case @code{atvalue} of the dependent variable will be used.  These may
be supplied either before or after the transform is taken.  Since the
initial conditions must be specified at zero, if one has boundary
conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution
for them and substituting their values back. Exp may also involve
convolution integrals.  Functional relationships must be explicitly
represented in order for @code{laplace} to work properly. That is, if F
depends on X and Y it must be written as F(X,Y) wherever F occurs as
in @code{laplace('diff(f(x,y),x),x,s)}.  @code{laplace} is not affected by @code{dependencies}
set up with the @code{depends} command.

@example
(%i1) laplace(%e**(2*t+a)*sin(t)*t,t,s);
                     a
                 2 %e  (s - 2)
(%o1)            ---------------
                        2     2
                ((s - 2)  + 1)
@end example

@end defun
