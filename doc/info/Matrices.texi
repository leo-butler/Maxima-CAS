@menu
* Introduction to Matrices and Linear Algebra::  
* Definitions for Matrices and Linear Algebra::  
@end menu

@node Introduction to Matrices and Linear Algebra, Definitions for Matrices and Linear Algebra, Matrices and Linear Algebra, Matrices and Linear Algebra
@section Introduction to Matrices and Linear Algebra

@menu
* DOT::                         
* VECTORS::                     
* eigen::
@end menu

@node DOT, VECTORS, Introduction to Matrices and Linear Algebra, Introduction to Matrices and Linear Algebra
@subsection DOT
 - . The dot operator, for matrix (non-commutative)
multiplication.  When "." is used in this way, spaces should be left
on both sides of it, e.g. A . B.  This distinguishes it plainly from a
decimal point in a floating point number.  Do APROPOS(DOT); for a list
of the switches which affect the dot operator.

@node VECTORS, eigen, DOT, Introduction to Matrices and Linear Algebra
@subsection VECTORS
 - The file SHARE;VECT > contains a vector analysis package,
share/vect.dem contains a corresponding demonstration, and SHARE;VECT
ORTH contains definitions of various orthogonal curvilinear coordinate
systems.  LOAD(VECT); will load this package for you.
The vector analysis package can combine and simplify symbolic 
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under
user control, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.
There is also a capability for deriving the scalar or vector potential
of a field.
The package contains the following commands: VECTORSIMP, SCALEFACTORS,
EXPRESS, POTENTIAL, and VECTORPOTENTIAL.  Do DESCRIBE(cmd) on these
command names, or PRINTFILE(VECT,USAGE,SHARE); for details.
Warning:  The VECT package declares "." to be a commutative operator.

@node eigen, , VECTORS, Introduction to Matrices and Linear Algebra
@subsection eigen

The package @code{eigen} contains several functions devoted to the
symbolic computation of eigenvalues and eigenvectors.
Maxima loads the package automatically if one of the functions
@code{eigenvalues} or @code{eigenvectors} is invoked.
The package may be loaded explicitly as @code{load ("eigen")}.

@code{demo ("eigen")} displays a demonstration of the capabilities
of this package.
@code{batch ("eigen")} executes the same demonstration,
but without the user prompt between successive computations.

The functions in the @code{eigen} package are
@code{conjugate}, @code{innerproduct}, @code{unitvector}, @code{columnvector},
@code{gramschmidt}, @code{eigenvalues}, @code{eigenvectors}, @code{uniteigenvectors},
and @code{similaritytransform}.

@c end concepts Matrices and Linear Algebra
@node Definitions for Matrices and Linear Algebra,  , Introduction to Matrices and Linear Algebra, Matrices and Linear Algebra
@section Definitions for Matrices and Linear Algebra

@c THROUGHOUT: SHOULD WE WRITE @var{matrix} FOR MATRIX ARGUMENT OR @var{m} AND REFER TO "a matrix @var{m}" ??
@c @var{matrix} PUTS MORE INFO INTO SYNOPSIS WHICH IS THE FIRST THING MANY PEOPLE LOOK AT
@defun addcol (@var{matrix}, @var{list_1}, ..., @var{list_n})
Appends the column(s) given by the one
or more lists (or matrices) onto @var{matrix}.

@end defun

@defun addrow (@var{matrix}, @var{list_1}, ..., @var{list_n})
Appends the row(s) given by the one or
more lists (or matrices) onto @var{matrix}.

@end defun

@defun adjoint (@var{matrix})
Returns the adjoint of @var{matrix}.

@end defun

@defun augcoefmatrix ([eqn_1, ...], [var_1, ...])
Returns the augmented coefficient
matrix for the variables @var{var_1}, ... of the system of linear equations
@var{eqn_1}, ....  This is the coefficient matrix with a column adjoined for
the constant terms in each equation (i.e. those not dependent upon
@var{var_1}, ...).

@example
(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
@end example

@end defun

@defun charpoly (@var{matrix}, @var{var})
Returns the characteristic polynomial for @var{matrix}
with respect to @var{var}.  That is,
@code{determinant (@var{matrix} - diagmatrix (length (@var{matrix}), @var{var}))}.

@example
(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
@end example

@end defun

@defun coefmatrix ([@var{eqn_1}, ..., @var{eqn_m}], [@var{var_1}, ..., @var{var_n}])
Returns the coefficient matrix for the
variables @var{eqn_1}, ..., @var{eqn_m} of the system of linear equations 
@var{var_1}, ..., @var{var_n}.
@c AN EXAMPLE WOULD BE REALLY NICE HERE

@end defun

@defun col (@var{matrix}, @var{i})
Returns the @var{i}'th column of @var{matrix}.
The return value is a matrix.
@c EXAMPLE HERE

@end defun

@defun columnvector (@var{list})
@defunx covect (@var{list})
Returns a matrix of one column and @code{length (@var{list})} rows,
containing the elements of @var{list}.

@code{covect} is a synonym for @code{columnvector}.

@code{load ("eigen")} loads this function.

@c FOLLOWING COMMENT PRESERVED. WHAT DOES THIS MEAN ??
This is useful if you want to use parts of the outputs of
the functions in this package in matrix calculations.

Example:

@c HMM, SPURIOUS "redefining the Macsyma function".
@c LEAVE IT HERE SINCE THAT'S WHAT A USER ACTUALLY SEES.
@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
@end example

@end defun

@defun conjugate (@var{x})
@defunx conj (@var{x})
Substitutes @code{-%i} for @code{%i} in @var{x}.
Depending on @var{x}, the result may be the complex conjugate of @var{x}.
@c THIS DEFN IS JUST BROKEN. SEE SF BUG # 1045514.

@code{conj} is a synonym for @code{conjugate}.

@code{load ("eigen")} loads this function.

@end defun

@defun copymatrix (@var{m})
Returns a copy of the matrix @var{m}.  This is the only way
to make a copy aside from copying @var{m} element by element.

Note that an assignment of one matrix to another, as in @code{m2: m1},
does not copy @code{m1}.
An assignment @code{m2 [i,j]: x} or @code{setelmx (x, i, j, m2} also modifies @code{m1 [i,j]}.
Creating a copy with @code{copymatrix} and then using assignment creates a separate, modified copy.

@c NEED EXAMPLE HERE
@end defun

@defun determinant (@var{m})
Computes the determinant of @var{m} by a method similar to
Gaussian elimination.

@c JUST HOW DOES ratmx AFFECT THE RESULT ??
The form of the result depends upon the setting
of the switch @code{ratmx}.

@c IS A SPARSE DETERMINANT SOMETHING OTHER THAN THE DETERMINANT OF A SPARSE MATRIX ??
There is a special routine for computing
sparse determinants which is called when the switches
@code{ratmx} and @code{sparse} are both @code{true}.

@c EXAMPLES NEEDED HERE
@end defun

@defvar detout
Default value: @code{false}

When @code{detout} is @code{true}, the determinant of a
matrix whose inverse is computed is factored out of the inverse.

For this switch to have an effect DOALLMXOPS and DOSCMXOPS should be
@code{false} (see their descriptions).  Alternatively this switch can be
given to EV which causes the other two to be set correctly.

Example:

@example
(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
@end example
@c THERE'S MORE TO THIS STORY: detout: false$ invert (m); RETURNS THE SAME THING.
@c IT APPEARS THAT doallmxops IS CRUCIAL HERE.

@end defvar

@defun diagmatrix (@var{n}, @var{x})
Returns a diagonal matrix of size @var{n} by @var{n} with the
diagonal elements all equal to @var{x}.
@code{diagmatrix (@var{n}, 1)} returns an identity matrix (same as @code{ident (@var{n})}).

@var{n} must evaluate to an integer, otherwise @code{diagmatrix} complains with an error message.

@var{x} can be any kind of expression, including another matrix.
If @var{x} is a matrix, it is not copied; all diagonal elements refer to the same instance, @var{x}.

@c NEED EXAMPLE HERE
@end defun

@defvar doallmxops
Default value: @code{true}

When @code{doallmxops} is @code{true},
@c UMM, WHAT DOES THIS MEAN EXACTLY ??
all operations relating to matrices are carried out.
When it is @code{false} then the setting of the
individual @code{dot} switches govern which operations are performed.

@c NEED EXAMPLES HERE
@end defvar

@defvar domxexpt
Default value: @code{true}

When @code{domxexpt} is @code{true},
a matrix exponential, @code{exp (@var{m})} where @var{m} is a matrix,
is interpreted as a matrix with element @code{[i,j} equal to @code{exp (m[i,j])}.
Otherwise @code{exp (@var{m})} evaluates to @code{exp (@var{ev(m)}}.

@code{domxexpt}
affects all expressions of the form @code{@var{base}^@var{power}} where @var{base} is an
expression assumed scalar or constant, and @var{power} is a list or
matrix.

Example:

@example
(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
@end example

@end defvar

@defvar domxmxops
Default value: @code{true}

When @code{domxmxops} is @code{true}, all matrix-matrix or
matrix-list operations are carried out (but not scalar-matrix
operations); if this switch is @code{false} such operations are not carried out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvar

@defvar domxnctimes
Default value: @code{false}

When @code{domxnctimes} is @code{true}, non-commutative products of
matrices are carried out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvar

@defvar dontfactor
Default value: []

@code{dontfactor} may be set to a list of variables with respect
to which factoring is not to occur.  (The list is initially empty.)
Factoring also will not take place with respect to any variables which
are less important, according the variable ordering assumed for canonical rational expression (CRE) form,
than those on the @code{dontfactor} list.

@end defvar

@defvar doscmxops
Default value: @code{false}

When @code{doscmxops} is @code{true}, scalar-matrix operations are
carried out.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvar

@defvar doscmxplus
Default value: @code{false}

When @code{doscmxplus} is @code{true}, scalar-matrix operations yield
a matrix result.  This switch is not subsumed under @code{doallmxops}.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvar

@defvar dot0nscsimp
Default value: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
When @code{dot0nscsimp} is @code{true}, a non-commutative product of zero
and a nonscalar term is simplified to a commutative product.

@c NEED EXAMPLE HERE
@end defvar

@defvar dot0simp
Default value: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
When @code{dot0simp} is @code{true},
a non-commutative product of zero and
a scalar term is simplified to a commutative product.

@c NEED EXAMPLE HERE
@end defvar

@defvar dot1simp
Default value: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
When @code{dot1simp} is @code{true},
a non-commutative product of one and
another term is simplified to a commutative product.

@c NEED EXAMPLE HERE
@end defvar

@defvar dotassoc
Default value: @code{true}

When @code{dotassoc} is @code{true}, an expression @code{(A.B).C} simplifies to
@code{A.(B.C)}.
@c "." MEANS NONCOMMUTATIVE MULTIPLICATION RIGHT ??

@c NEED EXAMPLE HERE
@end defvar

@defvar dotconstrules
Default value: @code{true}

When @code{dotconstrules} is @code{true}, a non-commutative product of a
constant and another term is simplified to a commutative product.
@c TERMINOLOGY: (1) SWITCH/FLAG/SOME OTHER TERM ?? (2) ASSIGN/SET/TURN ON/SOME OTHER TERM ??
Turning on this flag effectively turns on @code{dot0simp}, @code{dot0nscsimp}, and
@code{dot1simp} as well.

@c NEED EXAMPLE HERE
@end defvar

@defvar dotdistrib
Default value: @code{false}

When @code{dotdistrib} is @code{true}, an expression @code{A.(B + C)} simplifies to @code{A.B + A.C}.

@c NEED EXAMPLE HERE
@end defvar

@defvar dotexptsimp
Default value: @code{true}

When @code{dotexptsimp} is @code{true}, an expression @code{A.A} simplifies to @code{A^^2}.

@c NEED EXAMPLE HERE
@end defvar

@defvar dotident
Default value: 1

@code{dotident} is the value returned by @code{X^^0}.
@c "RETURNED" ?? IS THIS A SIMPLIFICATION OR AN EVALUATION ??

@c NEED EXAMPLE HERE
@end defvar

@defvar dotscrules
Default value: @code{false}

When @code{dotscrules} is @code{true}, an expression @code{A.SC} or @code{SC.A} simplifies
to @code{SC*A} and @code{A.(SC*B)} simplifies to @code{SC*(A.B)}.
@c HMM, DOES "SC" MEAN "SCALAR" HERE ?? CLARIFY

@c NEED EXAMPLE HERE
@end defvar

@defun echelon (@var{m})
Returns the echelon form of the matrix @code{m}.  The echelon form is computed from @var{m}
by elementary row operations such that the first
non-zero element in each row in the resulting matrix is a one and the
column elements under the first one in each row are all zero.

@example
(%i1) m: matrix ([2, 1-a, -5*b], [a, b, c]);
                       [ 2  1 - a  - 5 b ]
(%o1)                  [                 ]
                       [ a    b      c   ]
(%i2) echelon (m);
                  [      a - 1       5 b     ]
                  [ 1  - -----     - ---     ]
                  [        2          2      ]
(%o2)/R/          [                          ]
                  [             2 c + 5 a b  ]
                  [ 0     1     ------------ ]
                  [                    2     ]
                  [             2 b + a  - a ]
@end example

@end defun

@defun eigenvalues (@var{m})
@defunx eivals (@var{m})
@c eigen.mac IS AUTOLOADED IF eigenvalues OR eigenvectors IS REFERENCED; EXTEND THAT TO ALL FUNCTIONS ??
@c EACH FUNCTION INTENDED FOR EXTERNAL USE SHOULD HAVE ITS OWN DOCUMENTATION ITEM
Returns a list of two lists containing the eigenvalues of the matrix @var{m}.
The first sublist of the return value is the list of eigenvalues of the
matrix, and the second sublist is the list of the
multiplicities of the eigenvalues in the corresponding order.

@code{eivals} is a synonym for @code{eigenvalues}.

@code{eigenvalues} calls the function @code{solve} to find the roots of the
characteristic polynomial of the matrix.
Sometimes @code{solve} may not be able to find the roots of the polynomial;
in that case some other functions in this
package (except @code{conjugate}, @code{innerproduct}, @code{unitvector}, @code{columnvector} and
@code{gramschmidt}) will not work.
@c WHICH ONES ARE THE FUNCTIONS WHICH DON'T WORK ??
@c ACTUALLY IT'S MORE IMPORTANT TO LIST THE ONES WHICH DON'T WORK HERE
@c WHAT DOES "will not work" MEAN, ANYWAY ??

In some cases the eigenvalues found by @code{solve} may be complicated expressions.
(This may happen when @code{solve} returns a not-so-obviously real expression
for an eigenvalue which is known to be real.)
It may be possible to simplify the eigenvalues using some other functions.
@c WHAT ARE THOSE OTHER FUNCTIONS ??

The package @code{eigen.mac} is loaded automatically when
@code{eigenvalues} or @code{eigenvectors} is referenced.
If @code{eigen.mac} is not already loaded,
@code{load ("eigen")} loads it.
After loading, all functions and variables in the package are available.
@c REFER TO OVERVIEW OF PACKAGE (INCLUDING LIST OF FUNCTIONS) HERE

@c NEED EXAMPLES HERE
@end defun

@defun eigenvectors (@var{m})
@defunx eivects (@var{m})
takes a matrix @var{m} as its argument and returns a list
of lists the first sublist of which is the output of @code{eigenvalues}
and the other sublists of which are the eigenvectors of the
matrix corresponding to those eigenvalues respectively.
The calculated eigenvectors and the unit eigenvectors of the matrix are the
right eigenvectors and the right unit eigenvectors respectively.

@code{eivects} is a synonym for @code{eigenvectors}.

The package @code{eigen.mac} is loaded automatically when
@code{eigenvalues} or @code{eigenvectors} is referenced.
If @code{eigen.mac} is not already loaded,
@code{load ("eigen")} loads it.
After loading, all functions and variables in the package are available.

The flags that affect this function are:

@code{nondiagonalizable} is set to @code{true} or @code{false} depending on
whether the matrix is nondiagonalizable or diagonalizable after
@code{eigenvectors} returns.

@code{hermitianmatrix} when @code{true}, causes the degenerate
eigenvectors of the Hermitian matrix to be orthogonalized using the
Gram-Schmidt algorithm.

@code{knowneigvals} when @code{true} causes the @code{eigen} package to assume the
eigenvalues of the matrix are known to the user and stored under the
global name @code{listeigvals}.  @code{listeigvals} should be set to a list similar
to the output @code{eigenvalues}.

The function @code{algsys} is used here to solve for the eigenvectors. Sometimes if the
eigenvalues are messy, @code{algsys} may not be able to find a solution.
In some cases, it may be possible to simplify the eigenvalues by
first finding them using @code{eigenvalues} command and then using other functions
to reduce them to something simpler.
Following simplification, @code{eigenvectors} can be called again
with the @code{knowneigvals} flag set to @code{true}.

@end defun

@defun ematrix (@var{m}, @var{n}, @var{x}, @var{i}, @var{j})
Returns an @var{m} by @var{n} matrix, all elements of which
are zero except for the @code{[@var{i}, @var{j}]} element which is @var{x}.
@c WOW, THAT SEEMS PRETTY SPECIALIZED ...

@end defun

@defun entermatrix (@var{m}, @var{n})
Returns an @var{m} by @var{n} matrix, reading the elements interactively.

If @var{n} is equal to @var{m},
Maxima prompts for the type of the matrix (diagonal, symmetric, antisymmetric, or general)
and for each element.
Each response is terminated by a semicolon @code{;} or dollar sign @code{$}.

If @var{n} is not equal to @var{m},
Maxima prompts for each element.

The elements may be any expressions, which are evaluated.
@code{entermatrix} evaluates its arguments.

@example
(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
@end example

@end defun

@defun genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1}, @var{j_1})
@defunx genmatrix (@var{a}, @var{i_2}, @var{j_2}, @var{i_1})
@defunx genmatrix (@var{a}, @var{i_2}, @var{j_2})
Returns a matrix generated from @var{a},
taking element @code{@var{a}[@var{i_1},@var{j_1}]}
as the upper-left element and @code{@var{a}[@var{i_2},@var{j_2}]}
as the lower-right element of the matrix.
Here @var{a} is an array (created by @code{array} but not by @code{make_array})
or an array function. 
(An array function is created like other functions with @code{:=} or @code{define},
but arguments are enclosed in square brackets instead of parentheses.)

If @var{j_1} is omitted, it is assumed equal to @var{i_1}.
If both @var{j_1} and @var{i_1} are omitted, both are assumed equal to 1.

If a selected element @code{i,j} of the array is undefined,
the matrix will contain a symbolic element @code{@var{a}[i,j]}.

@example
(%i1) h[i,j] := 1/(i+j-1)$
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2)$
(%i4) a[1,1]: %e$
(%i5) a[2,2]: %pi$
(%i6) kill (a[1,2], a[2,1])$
(%i7) genmatrix (a, 2, 2);
                        [  %e    a     ]
                        [         1, 2 ]
(%o7)                   [              ]
                        [ a       %pi  ]
                        [  2, 1        ]
@end example

@end defun

@defun gramschmidt (@var{x})
@defunx gschmit (@var{x})
Carries out the Gram-Schmidt orthogonalization algorithm on @var{x},
which is either a matrix or a list of lists.
@var{x} is not modified by @code{gramschmidt}.

If @var{x} is a matrix, the algorithm is applied to the rows of @var{x}.
If @var{x} is a list of lists, the algorithm is applied to the sublists,
which must have equal numbers of elements.
In either case,
the return value is a list of lists, the sublists of which are orthogonal
and span the same space as @var{x}.
If the dimension of the span of @var{x} is less than the number of rows or sublists,
some sublists of the return value are zero.

@code{factor} is called at each stage of the algorithm to simplify intermediate results.
As a consequence, the return value may contain factored integers.

@code{gschmit} (note spelling) is a synonym for @code{gramschmidt}.

@code{load ("eigen")} loads this function.

Example:

@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
@end example

@end defun

@defun hach (@var{a}, @var{b}, @var{m}, @var{n}, @var{l})
@code{hach} is an implementation of Hacijan's linear programming algorithm.

@code{load ("kach")} loads this function.
@code{demo ("kach")} executes a demonstration of this function.
@c ACTUALLY BOTH kach.mac AND kach.dem APPEAR TO BE BROKEN AT THE MOMENT
@c DUNNO WHAT WE SHOULD DO ABOUT THAT HERE

@end defun

@defun ident (@var{n})
Returns an @var{n} by @var{n} identity matrix.

@end defun

@defun innerproduct (@var{x}, @var{y})
@defunx inprod (@var{x}, @var{y})
Returns the inner product (also called the scalar product) of @var{x} and @var{y},
which are lists of equal length, or both 1-column or 1-row matrices of equal length.
The return value is @code{conjugate (x) . y},
where @code{.} is the noncommutative multiplication operator.

@code{load ("eigen")} loads this function.

@code{inprod} is a synonym for @code{innerproduct}.

@c NEED EXAMPLE HERE
@end defun

@c THIS DESCRIPTION NEEDS WORK
@defun invert (@var{m})
Returns the inverse of the matrix @var{m}.
The inverse is computed by the adjoint method.

This allows a user to compute the inverse of a matrix with
bfloat entries or polynomials with floating pt. coefficients without
converting to cre-form.

Cofactors are computed by the @code{determinant} function,
so if @code{ratmx} is @code{false} the inverse is computed
without changing the representation of the elements.

The current
implementation is inefficient for matrices of high order.

When @code{detout} is @code{true}, the determinant is factored out of the
inverse.

The elements of the inverse are not automatically expanded.
If @var{m} has polynomial elements, better appearing output can be
generated by @code{expand (invert (m)), detout}.
If it is desirable to then
divide through by the determinant this can be accomplished by @code{xthru (%)}
or alternatively from scratch by

@example
expand (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
@end example

See @code{^^} (noncommutative exponent) for another method of inverting a matrix.

@c NEED EXAMPLE HERE
@end defun

@defvar lmxchar
Default value: @code{[}

@code{lmxchar} is the character displayed as the left
delimiter of a matrix.
See also @code{rmxchar}.

Example:

@example
(%i1) lmxchar: "|"$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
@end example

@end defvar

@defun matrix (@var{row_1}, ..., @var{row_n})
Returns a rectangular matrix which has the rows @var{row_1}, ..., @var{row_n}.
Each row is a list of expressions.
All rows must be the same length.

The operations @code{+} (addition), @code{-} (subtraction), @code{*} (multiplication),
and @code{/} (division), are carried out element by element
when the operands are two matrices, a scalar and a matrix, or a matrix and a scalar.
The operation @code{^} (exponentiation, equivalently @code{**})
is carried out element by element 
if the operands are a scalar and a matrix or a matrix and a scalar,
but not if the operands are two matrices.
@c WHAT DOES THIS NEXT PHRASE MEAN EXACTLY ??
All operations are normally carried out in full,
including @code{.} (noncommutative multiplication).

Matrix multiplication is represented by the noncommutative multiplication operator @code{.}.
The corresponding noncommutative exponentiation operator is @code{^^}.
For a matrix @code{@var{A}}, @code{@var{A}.@var{A} = @var{A}^^2} and
@code{@var{A}^^-1} is the inverse of @var{A}, if it exists.

There are switches for controlling simplification of expressions
involving dot and matrix-list operations.
These are
@code{doallmxops}, @code{domxexpt}
@code{domxmxops}, @code{doscmxops}, and @code{doscmxplus}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

There are additional options which are related to matrices. These are:
@code{lmxchar}, @code{rmxchar}, @code{ratmx}, @code{listarith}, @code{detout},
@code{scalarmatrix},
and @code{sparse}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

There are a number of
functions which take matrices as arguments or yield matrices as return values.
See @code{eigenvalues}, @code{eigenvectors},
@code{determinant},
@code{charpoly}, @code{genmatrix}, @code{addcol}, @code{addrow}, 
@code{copymatrix}, @code{transpose}, @code{echelon},
and @code{rank}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Examples:

@itemize @bullet
@item
Construction of matrices from lists.
@end itemize
@example
(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
@end example
@itemize @bullet
@item
Addition, element by element.
@end itemize
@example
(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
@end example
@itemize @bullet
@item
Subtraction, element by element.
@end itemize
@example
(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
@end example
@itemize @bullet
@item
Multiplication, element by element.
@end itemize
@example
(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
@end example
@itemize @bullet
@item
Division, element by element.
@end itemize
@example
(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
@end example
@itemize @bullet
@item
Matrix to a scalar exponent, element by element.
@end itemize
@example
(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
@end example
@itemize @bullet
@item
Scalar base to a matrix exponent, element by element.
@end itemize
@example
(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
Matrix base to a matrix exponent. This is not carried out element by element.
@c WHAT IS THIS ??
@end itemize
@example
(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
@end example
@itemize @bullet
@item
Noncommutative matrix multiplication.
@end itemize
@example
(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
@end example
@itemize @bullet
@item
Noncommutative matrix exponentiation.
A scalar base @code{b} to a matrix power @code{m}
is carried out element by element and so @code{b^^m} is the same as @code{b^m}.
@end itemize
@example
(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
A matrix raised to a -1 exponent with noncommutative exponentiation is the matrix inverse,
if it exists.
@end itemize
@example
(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
@end example

@end defun

@defun matrixmap (fn, m)
will map the function fn onto each element of the
matrix M.

@end defun

@defun matrixp (exp)
is @code{true} if exp is a matrix else @code{false}.

@end defun

@defvar matrix_element_add
 default: [+] - May be set to "?"; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO("matrix.dem1"); and DEMO("matrix.dem2");.

@end defvar

@defvar matrix_element_mult
 default: [*] - May be set to "."; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO("matrix.dem1"); and DEMO("matrix.dem2");

@end defvar

@defvar matrix_element_transpose
 default: @code{false} - Other useful settings are
TRANSPOSE and NONSCALARS; may also be the name of a function, or a
LAMBDA expression.  In this way, a rich variety of algebraic
structures may be simulated.  For more details, do
DEMO("matrix.dem1"); and DEMO("matrix.dem2");.

@end defvar

@defun mattrace (m)
computes the trace [sum of the elements on the main diagonal] of
the square matrix M.  It is used by NCHARPOLY, an alternative to Maxima's
CHARPOLY.  It is used by doing LOADFILE("nchrpl");

@end defun

@defun minor (m, i, j)
computes the i,j minor of the matrix M.  That is, M
with row i and column j removed.

@end defun

@defun ncexpt (a,b)
if an (non-commutative) exponential expression is too
wide to be displayed as A^^B it will appear as NCEXPT(A,B).

@end defun

@defun ncharpoly (m,var)
finds the characteristic polynomial of the matrix M
with respect to var.  This is an alternative to Maxima's CHARPOLY.
NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric
functions of the roots can be calculated, which are nothing more than
the coefficients of the characteristic polynomial.  CHARPOLY works by
forming the determinant of VAR * IDENT [N] - A.  Thus NCHARPOLY wins,
for example, in the case of large dense matrices filled with integers,
since it avoids polynomial arithmetic altogether.  It may be used by
doing LOADFILE("nchrpl");

@end defun

@defun newdet (m,n)
also computes the determinant of M but uses the
Johnson-Gentleman tree minor algorithm.  M may be the name of a
matrix or array.  The argument n is the order; it is optional if M is
a matrix.

@end defun

@defvr declaration nonscalar
 - makes ai behave as does a list or matrix with respect to
the dot operator.

@end defvr

@defun nonscalarp (exp)
is @code{true} if exp is a non-scalar, i.e.  it contains
atoms declared as non-scalars, lists, or matrices.

@end defun

@defun permanent (m,n)
computes the permanent of the matrix M.  A permanent
is like a determinant but with no sign changes.

@end defun

@defun rank (m)
computes the rank of the matrix M.  That is, the order of the
largest non-singular subdeterminant of M.  Caveat: RANK may return the
wrong answer if it cannot determine that a matrix element that is
equivalent to zero is indeed so.

@end defun

@defvar ratmx
 default: @code{false} - if @code{false} will cause determinant and matrix
addition, subtraction, and multiplication to be performed in the
representation of the matrix elements and will cause the result of
matrix inversion to be left in general representation.  If it is @code{true},
the 4 operations mentioned above will be performed in CRE form and the
result of matrix inverse will be in CRE form.  Note that this may
cause the elements to be expanded (depending on the setting of RATFAC)
which might not always be desired.

@end defvar

@defun row (m, i)
gives a matrix of the ith row of matrix M.

@end defun

@defvar scalarmatrixp
 default: @code{true} - if @code{true}, then whenever a 1 x 1 matrix
is produced as a result of computing the dot product of matrices it
will be converted to a scalar, namely the only element of the matrix.
If set to ALL, then this conversion occurs whenever a 1 x 1 matrix is
simplified.  If set to @code{false}, no conversion will be done.

@end defvar

@c MOVED scalefactors HERE FROM Miscellaneous.texi, SEEMS MORE AT HOME HERE
@defun scalefactors (coordinatetransform)
Here coordinatetransform
evaluates to the form [[expression1, expression2, ...],
indeterminate1, indeterminat2, ...], where indeterminate1,
indeterminate2, etc. are the curvilinear coordinate variables and
where a set of rectangular Cartesian components is given in terms of
the curvilinear coordinates by [expression1, expression2, ...].
@code{coordinates} is set to the vector [indeterminate1, indeterminate2,...],
and @code{dimension} is set to the length of this vector.  SF[1], SF[2],
..., SF[DIMENSION] are set to the coordinate scale factors, and @code{sfprod}
is set to the product of these scale factors.  Initially, @code{coordinates}
is [X, Y, Z], @code{dimension} is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1,
corresponding to 3-dimensional rectangular Cartesian coordinates.
To expand an expression into physical components in the current
coordinate system, there is a function with usage of the form

@end defun

@defun setelmx (x, i, j, m)
changes the i,j element of M to x.  The altered
matrix is returned as the value.  The notation M[i,j]:x may also be
used, altering M in a similar manner, but returning x as the value.

@end defun

@defun similaritytransform (mat)
@defunx simtran (mat)
a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  SIMILARITYTRANSFORM takes a MATRIX as its
argument and returns a list which is the output of the
UNITEIGENVECTORS command.  In addition if the flag NONDIAGONALIZABLE
is @code{false} two global matrices LEFTMATRIX and RIGHTMATRIX will be
generated.  These matrices have the property that
LEFTMATRIX.MAT.RIGHTMATRIX is a diagonal matrix with the eigenvalues
of MAT on the diagonal.  If NONDIAGONALIZABLE is @code{true} these two
matrices will not be generated.  If the flag HERMITIANMATRIX is @code{true}
then LEFTMATRIX is the complex conjugate of the transpose of
RIGHTMATRIX.  Otherwise LEFTMATRIX is the inverse of RIGHTMATRIX.
RIGHTMATRIX is the matrix the columns of which are the unit
eigenvectors of MAT.  The other flags (see DESCRIBE(EIGENVALUES); and
DESCRIBE(EIGENVECTORS);) have the same effects since
SIMILARITYTRANSFORM calls the other functions in the package in order
to be able to form RIGHTMATRIX.

@code{simtran} is a synonym for @code{similaritytransform}.

@end defun

@defvar sparse
 default: @code{false} - if @code{true} and if RATMX:TRUE then DETERMINANT
will use special routines for computing sparse determinants.

@end defvar

@defun submatrix (m1, ..., m, n1, ...)
creates a new matrix composed of the
matrix M with rows mi deleted, and columns ni deleted.

@end defun

@defun transpose (m)
produces the transpose of the matrix M.

@end defun

@defun triangularize (m)
produces the upper triangular form of the matrix M
which needn't be square.

@end defun

@defun uniteigenvectors (mat)
@defunx ueivects (mat)
a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  UNITEIGENVECTORS takes a MATRIX as its
argument and returns a list of lists the first sublist of which is the
output of the EIGENVALUES command and the other sublists of which are
the unit eigenvectors of the matrix corresponding to those eigenvalues
respectively.  The flags mentioned in the description of the
EIGENVECTORS command have the same effects in this one as well.  In
addition there is a flag which may be useful :
KNOWNEIGVECTS - If set to @code{true} the EIGEN package will assume
that the eigenvectors of the matrix are known to the user and are
stored under the global name LISTEIGVECTS.  LISTEIGVECTS should be set
to a list similar to the output of the EIGENVECTORS command.  (If
KNOWNEIGVECTS is set to @code{true} and the list of eigenvectors is given the
setting of the flag NONDIAGONALIZABLE may not be correct.  If that is
the case please set it to the correct value.  The author assumes that
the user knows what he is doing and will not try to diagonalize a
matrix the eigenvectors of which do not span the vector space of the
appropriate dimension...)

@code{ueivects} is a synonym for @code{uniteigenvectors}.

@end defun

@defun unitvector (x)
@defunx uvect (x)
a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  UNITVECTOR takes a LIST as its argument and returns a unit
list.  (i.e. a list with unit magnitude).

@code{uvect} is a synonym for @code{unitvector}.

@end defun

@defun vectorsimp (vectorexpression)
This function employs additional
simplifications, together with various optional
expansions according to the settings of the following global flags:

@example
EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
EXPANDCURLCURL, EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS,
EXPANDLAPLACIANPROD.
@end example

All these flags have default value @code{false}. The PLUS suffix refers to
employing additivity or distributivity.  The PROD suffix refers to the
expansion for an operand that is any kind of product.
EXPANDCROSSCROSS refers to replacing p~(q~r) with (p.r)*q-(p.q)*r, and
EXPANDCURLCURL refers to replacing CURL CURL p with GRAD DIV p + DIV
GRAD p.  EXPANDCROSS:TRUE has the same effect as
EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other flags,
EXPANDPLUS and EXPANDPROD, have the same effect as setting all
similarly suffixed flags true.  When @code{true}, another flag named
EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
composition DIV GRAD.  All of these flags are initially @code{false}.  For
convenience, all of these flags have been declared EVFLAG.
For orthogonal curvilinear coordinates, the global variables
COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set
by the function invocation

@end defun

@defvar vect_cross
 default:@code{false} - If @code{true} allows DIFF(X~Y,T) to work where
~ is defined in SHARE;VECT (where VECT_CROSS is set to @code{true}, anyway.)

@end defvar

@defun zeromatrix (m,n)
takes integers m,n as arguments and returns an m by
n matrix of 0's.

@end defun

@defvr {special symbol} "["
  - [ and ] are the characters which Maxima uses to delimit a
list.
@end defvr
