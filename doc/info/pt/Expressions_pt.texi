@c /Expressions.texi/1.40/Wed Sep  7 02:58:52 2005/-ko/
@menu
* Introdu@value{cedilha}@~ao a Express@~oes::  
* Atribui@value{cedilha}@~ao::                  
* Complexo::                     
* Substantivos e Verbos::
* Identificadores::
* Desigualdade::                  
* Sintaxe::                      
* Defini@value{cedilha}@~oes para Express@~oes::  
@end menu

@node Introdu@value{cedilha}@~ao a Express@~oes, Atribui@value{cedilha}@~ao, Express@~oes, Express@~oes
@section Introdu@value{cedilha}@~ao a Express@~oes

Existem um conjunto de palavras reservadas que n@~ao podem ser usadas como
nomes de vari@'aveis.   Seu uso pode causar um poss@'ivel erro cr@'itico de sintaxe.

@example
integrate            next           from                 diff            
in                   at             limit                sum             
for                  and            elseif               then            
else                 do             or                   if              
unless               product        while                thru            
step                                                                     
@end example

Muitas coisas em Maxima s@~ao express@~oes.   Uma seq@"u@^encia de express@~oes
pode ser feita dentro de uma express@~ao maior atrav@'es da separa@,{c}@~ao dessas atrav@'es de v@'irgulas e
colocando par@^entesis em torno dela.   Isso @'e similar ao @b{C}
@i{express@~ao de v@'irgula}.

@example
(%i1) x: 3$
(%i2) (x: x+1, x: x^2);
(%o2)                          16
(%i3) (if (x > 17) then 2 else 4);
(%o3)                           4
(%i4) (if (x > 17) then x: 2 else y: 4, y+x);
(%o4)                          20
@end example

Mesmo la@,{c}os em Maxima s@~ao express@~oes, embora o valor de retorno desses
la@,{c}os n@~ao seja muito @'util (eles retornam sempre @code{done}).

@example
(%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
(%i2) y;
(%o2)                         done
@end example

contanto que o que voc@^e realmente queira @'e provavelmente incluir um terceiro
termo na @i{express@~ao de v@'irgula} que atualmente fornece de volta o valor.

@example
(%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
(%i4) y;
(%o4)                        3628800
@end example



@node Atribui@value{cedilha}@~ao, Complexo, Introdu@value{cedilha}@~ao a Express@~oes, Express@~oes
@section Atribui@value{cedilha}@~ao
Existem dois operadores de atribui@,{c}@~ao no Maxima, @code{:} and @code{::}.
E.g., @code{a: 3} escolhe a vari@'avel @code{a} para 3. @code{::} atribui o valor da
express@~ao sobre seu lado direito para o valor da quantidade sobre seu lado esquerdo,
que deve avaliar para uma vari@'avel at@^omica ou para uma vari@'avel subscrita.

@c THIS REALLY NEEDS EXPANSION
@node Complexo, Substantivos e Verbos, Atribui@value{cedilha}@~ao, Express@~oes
@section Complexo
Uma express@~ao complexa @'e especificada no Maxima atrav@'es da adi@,{c}@~ao da
parte real da express@~ao a @code{%i} vezes a parte imagin@'aria.  Dessa forma as
ra@'izes da equa@,{c}@~ao @code{x^2 - 4*x + 13 = 0} s@~ao @code{2 + 3*%i} e @code{2 - 3*%i}.  Note que
produtos de simplifica@,{c}@~ao de express@~oes complexas podem ter efeito atrav@'es da
expans@~ao do produto.  Simplifica@,{c}@~ao de quocientes, ra@'izes, e outras
fun@,{c}@~oes de express@~oes complexas podem usualmente serem realizadas atrav@'es do uso
das fun@,{c}@~oes @code{realpart}, @code{imagpart}, @code{rectform}, @code{polarform}, @code{abs}, @code{carg}.

@node Substantivos e Verbos, Identificadores, Complexo, Express@~oes
@section Substantivos e Verbos
Maxima distingue entre operadores que s@~ao "subsrtantivos" e operadores que s@~ao "verbos".
Um verbo @'e um operador que pode ser executado.
Um substantivo @'e um operador que aparece como um s@'imbolo em uma express@~ao, sem ser executado.
Por padr@~ao, nomes de fun@,{c}@~ao s@~ao verbos.
Um verbo pode ser mudado em um substantivo atrav@'es da adi@,{c}@~ao de um ap@'ostrofo no in@'icio do nome da fun@,{c}@~ao
ou aplicando a fun@,{c}@~ao @code{nounify}.
Um substantivo pode ser mudado em um verbo através da aplicação da função @code{verbify}.
O sinalizador de avaliação @code{nouns} faz com que @code{ev} avalie substantivos em uma expressão.

A forma verbal é distinguida através de
um sinal de dólar @code{$} no início do símbolo Lisp correspondente.
De forma oposta,
a forma substantiva é distinguida através de 
um sinal de @code{%} no início do símbolo Lisp correspondente.
Alguns substantivos possuem propriedades especiais de exibição, tais como @code{'integrate} e @code{'derivative}
(retornado por @code{diff}), mas muitos não.
Por padrão, as formas substantiva e verbal de uma função são idênticas quando mostradas.
O sinalizador global @code{noundisp} faz com que Maxima mostre substantivos com um apóstrofo no início @code{'}.

Veja também @code{noun}, @code{nouns}, @code{nounify}, e @code{verbify}.

Exemplos:

@c ===beg===
@c foo (x) := x^2;
@c foo (42);
@c 'foo (42);
@c 'foo (42), nouns;
@c declare (bar, noun);
@c bar (x) := x/17;
@c bar (52);
@c bar (52), nouns;
@c integrate (1/x, x, 1, 42);
@c 'integrate (1/x, x, 1, 42);
@c ev (%, nouns);
@c ===end===
@example
(%i1) foo (x) := x^2;
                                     2
(%o1)                     foo(x) := x
(%i2) foo (42);
(%o2)                         1764
(%i3) 'foo (42);
(%o3)                        foo(42)
(%i4) 'foo (42), nouns;
(%o4)                         1764
(%i5) declare (bar, noun);
(%o5)                         done
(%i6) bar (x) := x/17;
                                     x
(%o6)                    ''bar(x) := --
                                     17
(%i7) bar (52);
(%o7)                        bar(52)
(%i8) bar (52), nouns;
                               52
(%o8)                          --
                               17
(%i9) integrate (1/x, x, 1, 42);
(%o9)                        log(42)
(%i10) 'integrate (1/x, x, 1, 42);
                             42
                            /
                            [   1
(%o10)                      I   - dx
                            ]   x
                            /
                             1
(%i11) ev (%, nouns);
(%o11)                       log(42)
@end example

@node Identificadores, Desigualdade, Substantivos e Verbos, Express@~oes
@section Identificadores
Identificadores do Maxima podem compreender caracteres alfabéticos,
mais os numerais de 0 a 9,
mais qualquer caractere especial precedido por um caractere contra-barra @code{\}.

Um numeral pode ser o primeiro caractere de um identificador
se esse numeral for precedido por uma contra barra.
Numerais que forem o segundo ou o último caractere não precisam ser precedidos por uma contra barra.

Um caractere especial pode ser declarado alfabético através da função @code{declare}.
Se isso ocorrer, esse caractere não precisa ser precedido por uma contra barra em um identificador.
Os caracteres alfabéticos são inicialmente 
@code{A} a @code{Z}, @code{a} a @code{z}, @code{%}, e @code{_}.

Maxima é sensível à caixa . Os identificadores @code{algumacoisa}, @code{ALGUMACOISA}, e @code{Algumacoisa} são distintos.
Veja @ref{Lisp e Maxima} para mais sobre esse ponto.

Um identificadro Maxima é um símbolo Lisp que começa com um sianl de dólar @code{$}.
Qualquer outro símbolo Lisp é precedido por um ponto de interrogação @code{?} quando aparecer no Maxima.
Veja @ref{Lisp e Maxima} para maiores detalhes sobre esse ponto.

Exemplos:

@c ===beg===
@c %an_ordinary_identifier42;
@c embedded\ spaces\ in\ an\ identifier;
@c symbolp (%);
@c [foo+bar, foo\+bar];
@c [1729, \1729];
@c [symbolp (foo\+bar), symbolp (\1729)];
@c [is (foo\+bar = foo+bar), is (\1729 = 1729)];
@c baz\~quux;
@c declare ("~", alphabetic);
@c baz~quux;
@c [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
@c :lisp (defvar *my-lisp-variable* '$foo)
@c ?\*my\-lisp\-variable\*;
@c ===end===

@example
(%i1) %an_ordinary_identifier42;
(%o1)               %an_ordinary_identifier42
(%i2) embedded\ spaces\ in\ an\ identifier;
(%o2)           embedded spaces in an identifier
(%i3) symbolp (%);
(%o3)                         true
(%i4) [foo+bar, foo\+bar];
(%o4)                 [foo + bar, foo+bar]
(%i5) [1729, \1729];
(%o5)                     [1729, 1729]
(%i6) [symbolp (foo\+bar), symbolp (\1729)];
(%o6)                     [true, true]
(%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
(%o7)                    [false, false]
(%i8) baz\~quux;
(%o8)                       baz~quux
(%i9) declare ("~", alphabetic);
(%o9)                         done
(%i10) baz~quux;
(%o10)                      baz~quux
(%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
(%o11)                [false, false, false]
(%i12) :lisp (defvar *my-lisp-variable* '$foo)
*MY-LISP-VARIABLE*
(%i12) ?\*my\-lisp\-variable\*;
(%o12)                         foo
@end example

@node Desigualdade, Sintaxe, Identificadores, Express@~oes
@section Desigualdade
Maxima tem os operadores de desigualdade @code{<}, @code{<=}, @code{>=}, @code{>}, @code{#}, e @code{notequal}.
Veja @code{if} para uma descrição de expressões condicionais.

@node Sintaxe, Defini@value{cedilha}@~oes para Express@~oes, Desigualdade, Express@~oes
@section Sintaxe
É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes,
ou redefinir a precedência de operadores existentes.  
Um operador pode ser unário prefixado ou unário pósfixado, binario infixado, n-ário infixado, matchfix, ou nofix.
"Matchfix" significa um par de símbolos que abraçam seu argumento ou seus argumentos,
e "nofix" significa um operador que não precisa de argumentos.
Como exemplos dos diferentes tipos de operadores, existe o seguinte.

@table @asis
@item unário prefixado
negação @code{- a}
@item unário posfixado
fatorial @code{a!}
@item binário infixado
exponenciação @code{a^b}
@item n-ário infixado
addition @code{a + b}
@item matchfix
construção de lista @code{[a, b]}
@end table

(Não existe operadores internos nofix;
para um exemplo de tal um operador, veja @code{nofix}.)

O mecanismo para definir um novo operador é direto.
Somente é necessário declarar uma função como um operador;
a função operador pode ou não estar definida previamente.

Um exemplo de operadores definidos pelo usuário é o seguinte.
Note que a chamada explícita de função @code{"dd" (a)} é equivalente a @code{dd a},
da mesma forma @code{"<-" (a, b)} é equivalente a @code{a <- b}.
Note também que as funções @code{"dd"} e @code{"<-"} são indefinidas nesse exemplo.

@c ===beg===
@c prefix ("dd");
@c dd a;
@c "dd" (a);
@c infix ("<-");
@c a <- dd b;
@c "<-" (a, "dd" (b));
@c ===end===
@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

As funções máxima que definem novos operadores estão sumarizadas nessa tabela,
equilibrando expoente associado esquerdo (padrão) e o expoente associado direito ("eae" e "ead", respectivamente).
@c REWORK FOLLOWING COMMENT. IT'S NOT CLEAR ENOUGH, GIVEN THAT IT'S FAIRLY IMPORTANT
(Associação de expoentes determina a precedência do operador. todavia, uma vez que os expoentes
esquerdo e diretiro podem ser diferentes, associação de expoentes é até certo ponto mais complicado que precedência.)
Alguma das funções de definição de operações tomam argumentos adicionais;
veja as descrições de função para maiores detalhes.

@c MAKE ANCHORS FOR ALL 6 FUNCTIONS AND CHANGE @code TO @ref ACCORDINGLY
@table @code
@item prefixado
ead=180
@item posfixado
eae=180
@item infixado
eae=180, ead=180
@item nário
eae=180, ead=180
@item matchfix
(associação de expoentes não é aplicável)
@item nofix
(associação de expoentes não é aplicável)
@end table

Para comparação,
aqui está alguns operadores internos e seus expoentes associados esquerdo e direito.

@example
Operator   lbp     rbp

  :        180     20 
  ::       180     20 
  :=       180     20 
  ::=      180     20 
  !        160
  !!       160
  ^        140     139 
  .        130     129 
  *        120
  /        120     120 
  +        100     100 
  -        100     134 
  =        80      80 
  #        80      80 
  >        80      80 
  >=       80      80 
  <        80      80 
  <=       80      80 
  not              70 
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

@code{remove} e @code{kill} removem propriedades de operador de um átomo.
@code{remove ("@var{a}", op)} remove somente as propriedades de operador de @var{a}.
@code{kill ("@var{a}")} remove todas as propriedades de @var{a}, incluindo as propriedades de operador.
Note que o nome do operador dever estar abraçado por aspas duplas.

@c MAYBE COPY THIS EXAMPLE TO remove AND/OR kill
@c ===beg===
@c infix ("@");
@c "@" (a, b) := a^b;
@c 5 @ 3;
@c remove ("@", op);
@c 5 @ 3;
@c "@" (5, 3);
@c infix ("@");
@c 5 @ 3;
@c kill ("@");
@c 5 @ 3;
@c "@" (5, 3);
@c ===end===
@example
(%i1) infix ("@@");
(%o1)                           @@
(%i2) "@@" (a, b) := a^b;
                                     b
(%o2)                      a @@ b := a
(%i3) 5 @@ 3;
(%o3)                          125
(%i4) remove ("@@", op);
(%o4)                         done
(%i5) 5 @@ 3;
Incorrect syntax: @@ is not an infix operator
5 @@
 ^
(%i5) "@@" (5, 3);
(%o5)                          125
(%i6) infix ("@@");
(%o6)                           @@
(%i7) 5 @@ 3;
(%o7)                          125
(%i8) kill ("@@");
(%o8)                         done
(%i9) 5 @@ 3;
Incorrect syntax: @@ is not an infix operator
5 @@
 ^
(%i9) "@@" (5, 3);
(%o9)                        @@(5, 3)
@end example

@node Defini@value{cedilha}@~oes para Express@~oes,  , Sintaxe, Express@~oes
@section Defini@value{cedilha}@~oes para Express@~oes

@deffn {Fun@value{cedilha}@~ao} at (@var{expr}, [@var{eqn_1}, ..., @var{eqn_n}])
@deffnx {Fun@value{cedilha}@~ao} at (@var{expr}, @var{eqn})
Avalia a expressão @var{expr} com
as variáveis assumindo os valores como especificado para elas na lista de
equações @code{[@var{eqn_1}, ..., @var{eqn_n}]} ou a equação simples @var{eqn}.

Se uma subexpressão depender de qualquer das variáveis para a qual um valor foi especificado
mas não existe @code{atvalue} especificado e isso não pode ser de outra forma avaliado,
então uma forma substantiva de @code{at} é retornada que mostra em uma forma bidimensional.

@code{at} realiza múltiplas substituições em série, não em paralelo.

Veja também @code{atvalue}.
Para outras funções que realizam substituições,
veja também @code{subst} e @code{ev}.

Exemplos:
@c COPIED FROM example(at)

@c ===beg===
@c atvalue (f(x,y), [x = 0, y = 1], a^2);
@c atvalue ('diff (f(x,y), x), x = 0, 1 + y);
@c printprops (all, atvalue);
@c diff (4*f(x, y)^2 - u(x, y)^2, x);
@c at (%, [x = 0, y = 1]);
@c ===end===
@example
(%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                2
(%o1)                          a
(%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
(%o2)                        @@2 + 1
(%i3) printprops (all, atvalue);
                                !
                  d             !
                 --- (f(@@1, @@2))!       = @@2 + 1
                 d@@1            !
                                !@@1 = 0

                                     2
                          f(0, 1) = a

(%o3)                         done
(%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                  d                          d
(%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                  dx                         dx
(%i5) at (%, [x = 0, y = 1]);
                                         !
              2              d           !
(%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                             dx          !
                                         !x = 0, y = 1
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} box (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} box (@var{expr}, @var{a})
Retorna @var{expr} dentro de uma caixa.
O valor de retorno é uma expressão com @code{box} como o operador e @var{expr} como o argumento.
Uma caixa é desenhada sobre a tela quando @code{display2d} for @code{true}.

@code{box (@var{expr}, @var{a})}
Empacota @var{expr} em uma caixa rotulada pelo símbolo @var{a}.
O rótulo é truncado se for maior que a largura da caixa.

Uma expressão dentro de uma caixa não avalia para seu conteúdo,
então expressões dentro de caixas são efetivamente excluídas de cálculos.

@code{boxchar} é o caractere usado para desenhar a caixa em @code{box}
e nas funções @code{dpart} e @code{lpart}.

Exemplos:

@c ===beg===
@c box (a^2 + b^2);
@c box (a^2 + b^2, term_1);
@c 1729 - box (1729);
@c boxchar: "-";
@c box (sin(x) + cos(y));
@c ===end===
@example
@end example

@end deffn

@defvr {Variável de op@value{cedilha}@~ao} boxchar
Valor padrão: @code{"}

@code{boxchar} é o caractere usado para desenhar a caixa por @code{box}
e nas funções @code{dpart} e @code{lpart}.

Todas as caixas em uma expressão são desenhadas com o valor atual de @code{boxchar};
o caractere de desenhonão é armazenado com a expressão de caixa. Isso quer dizer que se você
desenhar uma caixa e em seguida mudar o caractere de desenho a caixa anteriormente
desenhada será redesenhada com o caractere mudado caso isso seja solicitado.

@end defvr

@deffn {Fun@value{cedilha}@~ao} carg (@var{z})
Retorna o argumento complexo de @var{z}.
O argumento complexo é um ângulo @code{theta} no intervalo de @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} onde @code{r} é o módulo de @var{z}.
@c ACTUALLY carg DOESN'T ALWAYS RETURN A VALUE IN (-%pi, %pi]; SEE SF BUG REPORT # 816166

@code{carg} é uma função computacional,
não uma função de simplificação.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

@code{carg} ignora a declaração @code{declare (@var{x}, complex)},
e trata @var{x} como uma variável real.
Isso é um erro. @c SEE SF BUG REPORT # 620246

Veja também @code{abs} (módulo de número complex), @code{polarform}, @code{rectform},
@code{realpart}, e @code{imagpart}.

Exemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c CROSS REF declare, properties, ETC
@deffn {Special operator} constant
@code{declare (@var{a}, constant)} declara @var{a} para ser uma constante.
Veja @code{declare}.
@c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@end deffn

@deffn {Fun@value{cedilha}@~ao} constantp (@var{expr})
Retorna @code{true} se @var{expr} for uma expressão constante,
de outra forma retorna @code{false}.
@c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

Uma expressão é considerada uma expressão constante se seus argumentos forem
números (incluindo números racionais rational, como mostrado com @code{/R/}),
constantes simbólicas como @code{%pi}, @code{%e}, e @code{%i},
variáveis associadas a uma constante ou constante declarada através de @code{declare},
ou funções cujos argumentos forem constante.

@code{constantp} avalia seus argumentos.

Exemplos:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===

@example
@end example

@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c THIS ITEM IS EXTREMELY IMPORTANT
@deffn {Fun@value{cedilha}@~ao} declare (@var{a_1}, @var{f_1}, @var{a_2}, @var{f_2}, ...)
Atribui ao átomo @var{a_i} o sinalizador @var{f_i}.
Os @var{a_i}'s e @var{f_i}'s podem também serem listas de átomos e sinalizadores respectivamente nesse caso
cada um dos átomos tomam todas as propriedades.

@code{declare} não avalia seus argumentos.
@code{declare} sempre retorna @code{done}.

Os possíveis sinalizadores e seus significados são:

@code{constant} torna @var{a_i} uma constate como é @code{%pi}.

@code{mainvar} torna @var{a_i} uma @code{mainvar} (variável principal).  A escala de ordenação para átomos: numeros <
constantes (e.g. @code{%e}, @code{%pi}) < escalares < outras variáveis < variáveis principais.

@code{scalar} torna @var{a_i} um escalar.

@code{nonscalar} faz @var{a_i} comportar-se como faz uma lista ou matriz com relação ao
operador ponto.

@code{noun} torna a função @var{a_i} um substantivo de forma que não possa ser avaliada
automaticamente.

@code{evfun} torna @var{a_i} conhecido para a função @code{ev} de forma que isso possa vir a ser aplicada
se seu nome for mencionado.  Veja @code{evfun}.

@code{evflag} torna @var{a_i} conhecido para a função @code{ev} de forma que isso possa vir a ser associado a
@code{true} durante a execução de @code{ev} se isso for mencionado.  Veja @code{evflag}.

@code{bindtest} faz com que @var{a_i} sinalize um erro se isso mesmo for usado em um
cálculo não associado.

Maxima atualmente reconhe os seguintes recursos de
objectos:

@c THIS LIST AND NEXT ONE COMPRISE features !!!
@c SHOULD GIVE A REFERENCE TO features INSTEAD OF LISTING !!!
@c NEED TO CHECK THIS LIST !!!
@example
even, odd, integer, rational, irrational, real, imaginary,
e complex
@end example

Que pode ser traduzido para o português como:

@example
par, ímpar, inteiro, racional, irracional, real, imaginário,
e complexo
@end example

Os recursos úteis de funções incluem:

@c NEED TO CHECK THIS LIST !! IS IT COMPREHENSIVE ??
@example
increasing,
decreasing, oddfun (odd function), evenfun (even function),
commutative (or symmetric), antisymmetric, lassociative and
rassociative
@end example

Que pode ser traduzido para o português como:
@example
incremento,
decremento, oddfun (função ímpar), evenfun (função par),
comutativa (ou simetrica), antisimetrica, lassociative (associativa à esquerda) and
rassociative (associativa à direita).
@end example


@c WHAT DOES THIS MEAN EXACTLY ??
Os @var{a_i} e @var{f_i} podem também serem listas de objetos ou recursos.

@code{featurep (@var{objeto}, @var{recurso})}
determina se @var{objeto} foi declarado para ter @var{recurso}.

Veja também @code{features}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} disolate (@var{expr}, @var{x_1}, ..., @var{x_n})
é similar a @code{isolate (@var{expr}, @var{x})}
exceto que isso habilita ao usuário isolar
mais que uma variável simultâneamente.  Isso pode ser útil, por
exemplo, se se for tentado mudar variáveis em uma integração
múltipla, e que mudança de variável envolvendo duas ou mais das
variáveis de integração.  Essa função é chamada automaticamente de
@file{simplification/disol.mac}.  Uma demostração está disponível através de
@code{demo("disol")$}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} dispform (@var{expr})
Retorna a representação externa de @var{expr} com relação a seu
principal operador.  Isso pode ser útil em conjunçào com @code{part} que
também lida com a representação externa.  Suponha @var{expr} seja -A .
Então a representação interna de @var{expr} é  "*"(-1,A), enquanto que
a representaçào externa é "-"(A). @code{dispform (@var{expr}, all)} converte a
expressão inteira (não apenas o nível mais alto) para o formato externo.  Por
exemplo, se @code{expr: sin (sqrt (x))}, tentào @code{freeof (sqrt, expr)} e
@code{freeof (sqrt, dispform (expr))} fornece @code{true}, enquanto
@code{freeof (sqrt, dispform (expr, all))} fornece @code{false}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} distrib (@var{expr})
Distribue adições sobre produtos.  Isso difere de @code{expand}
no que isso trabalha em somente no nível mais alto de uma expressão, i.e., isso não
é recursivo e isso é mais rápido que @code{expand}.  Isso difere de @code{multthru} no
que isso expande todas as adições naquele nível.

Examples:

@example
(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} dpart (@var{expr}, @var{n_1}, ..., @var{n_k})
Seleciona a mesma subexpressão que @code{part}, mas
em lugar de apenas retornar aquela subexpressão como seu valor, isso retorna
a expressão completa com a subexpressão selecionada mostrada dentro
de uma caixa.  A caixa é atualmente parte da expressão.

@example
(%i1) dpart (x+y/z^2, 1, 2, 1);
                             y
(%o1)                       ---- + x
                               2
                            """
                            "z"
                            """
@end example

@end deffn

@c PROBABLY MORE TO BE SAID HERE
@deffn {Fun@value{cedilha}@~ao} exp (@var{x})
Representa função exponencial.  
Instâncias de @code{exp (@var{x})} em uma entrada são simplificadas para @code{%e^@var{x}};
@code{exp} não aparece em expressões simplificadas.

@code{demoivre} se @code{true} faz com que @code{%e^(a + b %i)} para simplificar para
@code{%e^(a (cos(b) + %i sin(b)))} se @code{b} for livre de @code{%i}. veja @code{demoivre}.

@code{%emode}, quando @code{true}, 
faz com que @code{%e^(%pi %i x)} seja simplificado. Veja @code{%emode}.

@code{%enumer}, quando @code{true} faz com que @code{%e} seja substituído por
2.718...  quando @code{numer} for @code{true}. Veja @code{%enumer}.

@c NEED EXAMPLES HERE
@end deffn

@defvr {Variável de op@value{cedilha}@~ao} %emode
Valor padrão: @code{true}

Quando @code{%emode} for @code{true},
@code{%e^(%pi %i x)} é simplificado como
segue.

@code{%e^(%pi %i x)} simplifica para @code{cos (%pi x) + %i sin (%pi x)} se @code{x} for um inteiro ou
um multiplo de 1/2, 1/3, 1/4, ou 1/6, e então adicionalmente simplificado.

Para outro @code{x} numérico,
@code{%e^(%pi %i x)} simplifica para @code{%e^(%pi %i y)} onde @code{y} é @code{x - 2 k}
para algum inteiro @code{k} tal que @code{abs(y) < 1}.  

Quando @code{%emode} for @code{false}, nenhuma
simplificação adicional de @code{%e^(%pi %i x)} é realizada.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de op@value{cedilha}@~ao} %enumer
Valor padrão: @code{false}

Quando @code{%enumer} for @code{true},
@code{%e} é substituido por seu valor numérico
2.718...  quando @code{numer} for @code{true}. 

Quando @code{%enumer} for @code{false}, essa substituição é realizada
somente se o expoente em @code{%e^x} avaliar para um número.

Veja também @code{ev} e @code{numer}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de op@value{cedilha}@~ao} exptisolate
Valor padrão: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
@code{exptisolate}, quando @code{true}, faz com que @code{isolate (expr, var)}
examine expoentes de átomos (tais como @code{%e}) que contenham @code{var}.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Variável de op@value{cedilha}@~ao} exptsubst
Valor padrão: @code{false}

@code{exptsubst}, quando @code{true}, permite substituições tais como @code{y}
para @code{%e^x} em @code{%e^(a x)}.

@c NEED EXAMPLES HERE
@end defvr

@deffn {Fun@value{cedilha}@~ao} freeof (@var{x_1}, ..., @var{x_n}, @var{expr})
@code{freeof (@var{x_1}, @var{expr})}
Retorna @code{true}
se nenhuma subexpressão de @var{expr} for igual a @var{x_1}
ou se @var{x_1} ocorrer somente uma variável que não tenha associação fora da expressão @var{expr},
e retorna @code{false} de outra forma.

@code{freeof (@var{x_1}, ..., @var{x_n}, @var{expr})}
é equivalente a @code{freeof (@var{x_1}, @var{expr}) and ... and freeof (@var{x_n}, @var{expr})}.

Os argumentos @var{x_1}, ..., @var{x_n} 
podem ser nomes de funções e variáveis, nomes subscritos,
operadores (empacotados em aspas duplas), ou expressões gerais.
@code{freeof} avalia seus documentos.

@code{freeof} opera somente sobre @var{expr} como isso representa (após simplificação e avaliação) e
não tenta determinar se alguma expressão equivalente pode fornecer um resultado diferente.
Em particular, simplificação pode retornar uma expressão equivalente mas diferente que compreende
alguns diferentes elementos da forma original de @var{expr}.

Uma variável é uma variável dummy em uma expressão se não tiver associação fora da expressão.
Variáveis dummy recoreconhecidas através de @code{freeof} são
o índice de um somatório ou produtório, o limite da variável em @code{limit},
a variável de integração na forma de integral definida de @code{integrate},
a variável original em @code{laplace},
variáveis formais em expressoes @code{at},
e argumentos em expressões @code{lambda}.
Variáveis locais em @code{block} não são reconhecidas por @code{freeof} como variáveis dummy;
isso é um bug.

A forma indefinida de @code{integrate} é @i{not} livre de suas variáveis de integração.

@itemize @bullet
@item
Argumentos são nomes de funções, variáveis, nomes subscritos, operadores, e expressões.
@code{freeof (a, b, expr)} é equivalente a
@code{freeof (a, expr) and freeof (b, expr)}.

@example
(%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                 d + c  3
(%o1)                   cos(a ) b      z
                             1
(%i2) freeof (z, expr);
(%o2)                         false
(%i3) freeof (cos, expr);
(%o3)                         false
(%i4) freeof (a[1], expr);
(%o4)                         false
(%i5) freeof (cos (a[1]), expr);
(%o5)                         false
(%i6) freeof (b^(c+d), expr);
(%o6)                         false
(%i7) freeof ("^", expr);
(%o7)                         false
(%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
(%o8)                         true
@end example

@item
@code{freeof} avalia seus argumentos.

@example
(%i1) expr: (a+b)^5$
(%i2) c: a$
(%i3) freeof (c, expr);
(%o3)                         false
@end example

@item
@code{freeof} não considera expressões equivalentes.
Simplificação pode retornar uma expressão equivalente mas difeente.

@example
(%i1) expr: (a+b)^5$
(%i2) expand (expr);
          5        4       2  3       3  2      4      5
(%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
(%i3) freeof (a+b, %);
(%o3)                         true
(%i4) freeof (a+b, expr);
(%o4)                         false
(%i5) exp (x);
                                 x
(%o5)                          %e
(%i6) freeof (exp, exp (x));
(%o6)                         true
@end example

@item Um somatório ou uma integral definida está livre de uma variável dummy.
Uma integral indefinida não é livre de suas variáveis de integração.

@example
(%i1) freeof (i, 'sum (f(i), i, 0, n));
(%o1)                         true
(%i2) freeof (x, 'integrate (x^2, x, 0, 1));
(%o2)                         true
(%i3) freeof (x, 'integrate (x^2, x));
(%o3)                         false
@end example
@end itemize

@end deffn

@c IS THIS DEFINITION CORRECT ??
@deffn {Fun@value{cedilha}@~ao} genfact (@var{x}, @var{y}, @var{z})
Retorna o fatorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Dessa forma, para integral @var{x},
@code{genfact (x, x, 1) = x!} and @code{genfact (x, x/2, 2) = x!!}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} imagpart (@var{expr})
Retorna a parte imaginária da expressão @var{expr}.

@code{imagpart} é uma função computacional,
não uma função de simplificação.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Veja também @code{abs}, @code{carg}, @code{polarform}, @code{rectform},
e @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~ao} infix (@var{op})
@deffnx {Fun@value{cedilha}@~ao} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {Fun@value{cedilha}@~ao} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})
Declara @var{op} para ser um operador infixo.
Um operador infixo é uma função de dois argumentos,
com o nome da função escrito entre os argumentos.
Por exemplo, o operador de subtração @code{-} é um operador infixo.

@code{infix (@var{op})} declara @var{op} para ser um operador infixo
com expoentes associados padrão (esquerdo e direito ambos iguais a 180)
e podendo ser qualquer entre prefixado, infixado, posfixado, nário, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).
@c HOW IS pos DIFFERENT FROM lpos AND rpos ??

@code{infix (@var{op}, @var{lbp}, @var{rbp})} declara @var{op} para ser um operador infixo
com expoentes associados esquerdo e diretio equilibrados
e podendo ser qualquer entre prefixado, infixado, posfixado, nário, 
matchfix e nofix (esquerdo e direito ambos iguais a @code{any}).

@code{infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}
declara @var{op} para ser um operdor infixo
com expoentes associados padrão e podendo ser um entre 
prefixado, infixado, posfixado, nário, matchfix e nofix.

A precedência de @var{op} com relação a outros operadores
derivam dos espoentes associados diretiro e esquerdo dos operadores em questão.
Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que o expoente associado esquerdo e o direito de algum outro operador,
então @var{op} tem prededência sobre o outro operador.
Se os expoentes associados não forem ambos maior ou menor,
alguma relação mais complicada ocorre.

A associatividade de @var{op} depende de seus expoentes associados.
Maior expoente associado esquerdo (@var{eae}) implica uma instância de
@var{op} é avaliadas antes de outros operadores para sua esquerda em uma expressão,
enquanto maior expoente associado direito (@var{ead}) implica uma instância de
@var{op} é avaliada antes de outros operadores para sua direita em uma expressão.
Dessa forma maior @var{eae} torna @var{op} associativo à direita,
enquanto maior @var{ead} torna @var{op} associativa à esquerda.
Se @var{lbp} for igual a @var{ead}, @var{op} é associativa à esquerda.

Veja também @code{Syntax}.

Exemplos:

@itemize @bullet
@item
Se os expoentes associados esquerdo e direito de @var{op} forem ambos maiores
que os expoentes associados à direita e à esquerda de algum outro operador,
então @var{op} tem precedência sobre o outro operador.
@end itemize
@example
(%i1) "@@"(a, b) := sconcat("(", a, ",", b, ")")$
(%i2) :lisp (get '$+ 'lbp)
100
(%i2) :lisp (get '$+ 'rbp)
100
(%i2) infix ("@@", 101, 101)$
(%i3) 1 + a@@b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("@@", 99, 99)$
(%i5) 1 + a@@b + 2;
(%o5)                       (a+1,b+2)
@end example

@itemize @bullet
@item
grande @var{eae} torna @var{op} associativa à direita,
enquanto grande @var{ead} torna @var{op} associativa à esquerda.
@end itemize
@example
(%i1) "@@"(a, b) := sconcat("(", a, ",", b, ")")$
(%i2) infix ("@@", 100, 99)$
(%i3) foo @@ bar @@ baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("@@", 100, 101)$
(%i5) foo @@ bar @@ baz;
(%o5)                    ((foo,bar),baz)
@end example

@end deffn

@defvr {Variável de op@value{cedilha}@~ao} inflag
Velor padrão: @code{false}

Quando @code{inflag} for @code{true}, funções para extração de
partes inspecionam a forma interna de @code{expr}.

Note que o simplificador re-organiza expressões.
Thus @code{first (x + y)} returns @code{x} if @code{inflag}
is @code{true} and @code{y} if @code{inflag} is @code{false}.
(@code{first (y + x)} gives the same results.)

Also, setting @code{inflag} to @code{true} and calling @code{part} or @code{substpart} is
the same as calling @code{inpart} or @code{substinpart}.

Functions affected by the setting of @code{inflag} are:
@code{part}, @code{substpart}, @code{first}, @code{rest}, @code{last}, @code{length},
the @code{for} ... @code{in} construct,
@code{map}, @code{fullmap}, @code{maplist}, @code{reveal} and @code{pickapart}.

@c NEED EXAMPLES HERE
@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} inpart (@var{expr}, @var{n_1}, ..., @var{n_k})
is similar to @code{part} but works on the internal
representation of the expression rather than the displayed form and
thus may be faster since no formatting is done.  Care should be taken
with respect to the order of subexpressions in sums and products
(since the order of variables in the internal form is often different
from that in the displayed form) and in dealing with unary minus,
subtraction, and division (since these operators are removed from the
expression). @code{part (x+y, 0)} or @code{inpart (x+y, 0)} yield @code{+}, though in order to
refer to the operator it must be enclosed in "s.  For example
@code{... if inpart (%o9,0) = "+" then ...}.

Examples:

@example
(%i1) x + y + w*z;
(%o1)                      w z + y + x
(%i2) inpart (%, 3, 2);
(%o2)                           z
(%i3) part (%th (2), 1, 2);
(%o3)                           z
(%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                  g(x + 1)
(%o4)                 limit   f(x)
                      x -> 0-
(%i5) inpart (%, 1, 2);
(%o5)                       g(x + 1)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} isolate (@var{expr}, @var{x})
Returns @var{expr} with subexpressions which are sums and
which do not contain var replaced by intermediate expression labels
(these being atomic symbols like @code{%t1}, @code{%t2}, ...).  This is often useful
to avoid unnecessary expansion of subexpressions which don't contain
the variable of interest.  Since the intermediate labels are bound to
the subexpressions they can all be substituted back by evaluating the
expression in which they occur.

@code{exptisolate} (default value: @code{false}) if @code{true} will cause @code{isolate} to examine exponents of
atoms (like @code{%e}) which contain var.

@code{isolate_wrt_times} if @code{true}, then @code{isolate} will also isolate wrt
products. See @code{isolate_wrt_times}.

Do @code{example (isolate)} for examples.

@end deffn

@c NEEDS WORK
@defvr {Variável de op@value{cedilha}@~ao} isolate_wrt_times
Default value: @code{false}

When @code{isolate_wrt_times} is @code{true}, @code{isolate}
will also isolate wrt products.  E.g. compare both settings of the
switch on

@example
(%i1) isolate_wrt_times: true$
(%i2) isolate (expand ((a+b+c)^2), c);

(%t2)                          2 a


(%t3)                          2 b


                          2            2
(%t4)                    b  + 2 a b + a

                     2
(%o4)               c  + %t3 c + %t2 c + %t4
(%i4) isolate_wrt_times: false$
(%i5) isolate (expand ((a+b+c)^2), c);
                     2
(%o5)               c  + 2 b c + 2 a c + %t4
@end example

@end defvr

@c NEEDS EXAMPLES
@defvr {Variável de op@value{cedilha}@~ao} listconstvars
Default value: @code{false}

When @code{listconstvars} is @code{true}, it will cause @code{listofvars} to
include @code{%e}, @code{%pi}, @code{%i}, and any variables declared constant in the list
it returns if they appear in the expression @code{listofvars} is called on.
The default is to omit these.

@end defvr

@defvr {Variável de op@value{cedilha}@~ao} listdummyvars
Default value: @code{true}

When @code{listdummyvars} is @code{false}, "dummy variables" in the
expression will not be included in the list returned by @code{listofvars}.
(The meaning of "dummy variables" is as given in @code{freeof}.
"Dummy variables" are mathematical things like the index of a sum or
product, the limit variable, and the definite integration variable.)
Example:

@example
(%i1) listdummyvars: true$
(%i2) listofvars ('sum(f(i), i, 0, n));
(%o2)                        [i, n]
(%i3) listdummyvars: false$
(%i4) listofvars ('sum(f(i), i, 0, n));
(%o4)                          [n]
@end example

@end defvr

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} listofvars (@var{expr})
Returns a list of the variables in @var{expr}.

@code{listconstvars} if @code{true} causes @code{listofvars} to include @code{%e}, @code{%pi},
@code{%i}, and any variables declared constant in the list it returns if they
appear in @var{expr}.  The default is to omit these.

@example
(%i1) listofvars (f (x[1]+y) / g^(2+a));
(%o1)                     [g, a, x , y]
                                  1
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} lfreeof (@var{list}, @var{expr})
For each member @var{m} of list, calls @code{freeof (@var{m}, @var{expr})}.
It returns @code{false} if any call to @code{freeof} does and @code{true} otherwise.
@end deffn

@deffn {Fun@value{cedilha}@~ao} lopow (@var{expr}, @var{x})
Returns the lowest exponent of @var{x} which explicitly appears in
@var{expr}.  Thus

@example
(%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
(%o1)                       min(a, 2)
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} lpart (@var{label}, @var{expr}, @var{n_1}, ..., @var{n_k})
is similar to @code{dpart} but uses a
labelled box. A labelled box is similar to the one produced by @code{dpart}
but it has a name in the top line.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} multthru (@var{expr})
@deffnx {Fun@value{cedilha}@~ao} multthru (@var{expr_1}, @var{expr_2})
Multiplies a factor (which should be a sum) of @var{expr} by
the other factors of @var{expr}.  That is, @var{expr} is @code{@var{f_1} @var{f_2} ... @var{f_n}}
where at least
one factor, say @var{f_i}, is a sum of terms.  Each term in that sum is
multiplied by the other factors in the product.  (Namely all the
factors except @var{f_i}).  @code{multthru} does not expand exponentiated sums.
This function is the fastest way to distribute products (commutative
or noncommutative) over sums.  Since quotients are represented as
products @code{multthru} can be used to divide sums by products as well.

@code{multthru (@var{expr_1}, @var{expr_2})} multiplies each term in @var{expr_2} (which should be a
sum or an equation) by @var{expr_1}.  If @var{expr_1} is not itself a sum then this
form is equivalent to @code{multthru (@var{expr_1}*@var{expr_2})}.

@example
(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} nounify (@var{f})
Returns the noun form of the function name @var{f}.  This is
needed if one wishes to refer to the name of a verb function as if it
were a noun.  Note that some verb functions will return their noun
forms if they can't be evaluated for certain arguments.  This is also
the form returned if a function call is preceded by a quote.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} nterms (@var{expr})
Returns the number of terms that @var{expr} would have if it were
fully expanded out and no cancellations or combination of terms
occurred.
Note that expressions like @code{sin (@var{expr})}, @code{sqrt (@var{expr})}, @code{exp (@var{expr})}, etc.
count as just one term regardless of how many terms @var{expr} has (if it is a
sum).

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} op (@var{expr})
Returns the main operator of the expression @var{expr}.
@code{op (@var{expr})} is equivalent to @code{part (@var{expr}, 0)}. 

@code{op} returns a string if the main operator is
a built-in or user-defined
prefix, binary or n-ary infix, postfix, matchfix, or nofix operator.
Otherwise @code{op} returns a symbol.

@code{op} observes the value of the global flag @code{inflag}.

@code{op} evaluates it argument.

See also @code{args}.

Examples:

@c ===beg===
@c ?stringdisp: true$
@c op (a * b * c);
@c op (a * b + c);
@c op ('sin (a + b));
@c op (a!);
@c op (-a);
@c op ([a, b, c]);
@c op ('(if a > b then c else d));
@c op ('foo (a));
@c prefix (foo);
@c op (foo a);
@c ===end===

@example
(%i1) ?stringdisp: true$
(%i2) op (a * b * c);
(%o2)                          "*"
(%i3) op (a * b + c);
(%o3)                          "+"
(%i4) op ('sin (a + b));
(%o4)                          sin
(%i5) op (a!);
(%o5)                          "!"
(%i6) op (-a);
(%o6)                          "-"
(%i7) op ([a, b, c]);
(%o7)                          "["
(%i8) op ('(if a > b then c else d));
(%o8)                         "if"
(%i9) op ('foo (a));
(%o9)                          foo
(%i10) prefix (foo);
(%o10)                        "foo"
(%i11) op (foo a);
(%o11)                        "foo"
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} operatorp (@var{expr}, @var{op})
@deffnx {Fun@value{cedilha}@~ao} operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])

@code{operatorp (@var{expr}, @var{op})} returns @code{true}
if @var{op} is equal to the operator of @var{expr}.

@code{operatorp (@var{expr}, [@var{op_1}, ..., @var{op_n}])} returns @code{true}
if some element @var{op_1}, ..., @var{op_n} is equal to the operator of @var{expr}.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} optimize (@var{expr})
Returns an expression that produces the same value and
side effects as @var{expr} but does so more efficiently by avoiding the
recomputation of common subexpressions.  @code{optimize} also has the side
effect of "collapsing" its argument so that all common subexpressions
are shared.
Do @code{example (optimize)} for examples.

@end deffn

@defvr {Variável de op@value{cedilha}@~ao} optimprefix
Default value: @code{%}

@code{optimprefix} is the prefix used for generated symbols by
the @code{optimize} command.

@end defvr

@c NEEDS WORK
@c WHAT DOES ">" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} ordergreat (@var{v_1}, ..., @var{v_n})
Sets up aliases for the variables @var{v_1}, ..., @var{v_n}
such that @var{v_1} > @var{v_2} > ...  > @var{v_n},
and @var{v_n} > any other variable not mentioned as an
argument.

See also @code{orderless}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} ordergreatp (@var{expr_1}, @var{expr_2})
Returns @code{true} if @var{expr_2} precedes @var{expr_1} in the
ordering set up with the @code{ordergreat} function.

@end deffn

@c NEEDS WORK
@c WHAT DOES "<" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} orderless (@var{v_1}, ..., @var{v_n})
Sets up aliases for the variables @var{v_1}, ..., @var{v_n}
such that @var{v_1} < @var{v_2} < ...  < @var{v_n},
and @var{v_n} < any other variable not mentioned as an
argument.

@c EXPRESS THIS ORDER IN A MORE COMPREHENSIBLE FASHION
Thus the complete ordering scale is: numerical constants <
declared constants < declared scalars < first argument to @code{orderless} <
...  < last argument to @code{orderless} < variables which begin with A < ...
< variables which begin with Z < last argument to @code{ordergreat} <
 ... < first argument to @code{ordergreat} < declared @code{mainvar}s.

See also @code{ordergreat} and @code{mainvar}.

@end deffn

@c NEEDS WORK
@c WHAT DOES "PRECEDES" MEAN IN THIS CONTEXT ??
@deffn {Fun@value{cedilha}@~ao} orderlessp (@var{expr_1}, @var{expr_2})
Returns @code{true} if @var{expr_1} precedes @var{expr_2} in the
ordering set up by the @code{orderless} command.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} part (@var{expr}, @var{n_1}, ..., @var{n_k})
Returns parts of the displayed form of @code{expr}. It
obtains the part of @code{expr} as specified by the indices @var{n_1}, ..., @var{n_k}.  First
part @var{n_1} of @code{expr} is obtained, then part @var{n_2} of that, etc.  The result is
part @var{n_k} of ... part @var{n_2} of part @var{n_1} of @code{expr}.

@code{part} can be used to obtain an element of a list, a row of a matrix, etc.

@c "If the last argument to a part function" => FOLLOWING APPLIES TO OTHER FUNCTIONS ??
@c ATTEMPT TO VERIFY; IF SO, COPY THIS COMMENTARY TO DESCRIPTIONS OF OTHER FUNCTIONS
If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus @code{part (x + y + z, [1, 3])} is @code{z+x}.

@code{piece} holds the last expression selected when using the part
functions.  It is set during the execution of the function and thus
may be referred to in the function itself as shown below.

If @code{partswitch} is set to @code{true} then @code{end} is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.

@c NEED "SEE ALSO" POINTING TO ALL OTHER PART FUNCTIONS

Example: @code{part (z+2*y, 2, 1)} yields 2.

@c MERGE IN example (part) OUTPUT HERE
@code{example (part)} displays additional examples.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} partition (@var{expr}, @var{x})
Returns a list of two expressions.  They are (1)
the factors of @var{expr} (if it is a product), the terms of @var{expr} (if it is a
sum), or the list (if it is a list) which don't contain var and, (2)
the factors, terms, or list which do.

@example
(%i1) partition (2*a*x*f(x), x);
(%o1)                     [2 a, x f(x)]
(%i2) partition (a+b, x);
(%o2)                      [b + a, 0]
(%i3) partition ([a, b, f(a), c], a); 
(%o3)                  [[b, c], [a, f(a)]]
@end example

@end deffn

@c NEEDS EXAMPLE
@defvr {Variável de op@value{cedilha}@~ao} partswitch
Default value: @code{false}

When @code{partswitch} is @code{true}, @code{end} is returned
when a selected part of an expression doesn't exist, otherwise an
error message is given.

@end defvr

@deffn {Fun@value{cedilha}@~ao} pickapart (@var{expr}, @var{n})
Assigns intermediate expression labels to subexpressions of
@var{expr} at depth @var{n}, an integer.
Subexpressions at greater or lesser depths are not assigned labels.
@code{pickapart} returns an expression in terms of intermediate expressions
equivalent to the original expression @var{expr}.

See also @code{part}, @code{dpart}, @code{lpart}, @code{inpart}, and @code{reveal}.

Examples:

@example
(%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                          2
                                     sin(x )   b + a
(%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2
(%i2) pickapart (expr, 0);

                                          2
                                     sin(x )   b + a
(%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                        3        2

(%o2)                          %t2
(%i3) pickapart (expr, 1);

(%t3)                - log(sqrt(x + 1) + 1)


                                  2
                             sin(x )
(%t4)                        -------
                                3


                              b + a
(%t5)                         -----
                                2

(%o5)                    %t5 + %t4 + %t3
(%i5) pickapart (expr, 2);

(%t6)                 log(sqrt(x + 1) + 1)


                                  2
(%t7)                        sin(x )


(%t8)                         b + a

                         %t8   %t7
(%o8)                    --- + --- - %t6
                          2     3
(%i8) pickapart (expr, 3);

(%t9)                    sqrt(x + 1) + 1


                                2
(%t10)                         x

                  b + a              sin(%t10)
(%o10)            ----- - log(%t9) + ---------
                    2                    3
(%i10) pickapart (expr, 4);

(%t11)                     sqrt(x + 1)

                      2
                 sin(x )   b + a
(%o11)           ------- + ----- - log(%t11 + 1)
                    3        2
(%i11) pickapart (expr, 5);

(%t12)                        x + 1

                   2
              sin(x )   b + a
(%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                 3        2
(%i12) pickapart (expr, 6);
                  2
             sin(x )   b + a
(%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                3        2
@end example

@end deffn

@c NEEDS WORK
@defvr {System variable} piece
Holds the last expression selected when using the @code{part}
functions.
@c WHAT DOES THIS MEAN EXACTLY ??
It is set during the execution of the function and thus
may be referred to in the function itself.

@c NEED "SEE ALSO" TO POINT TO LIST OF ALL RELEVANT FUNCTIONS

@end defvr

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} polarform (@var{expr})
Returns an expression @code{r %e^(%i theta)} equivalent to @var{expr},
such that @code{r} and @code{theta} are purely real.

@end deffn

@c ISN'T THERE AN EQUIVALENT FUNCTION SOMEWHERE ??
@c NEEDS WORK (IF KEPT)
@deffn {Fun@value{cedilha}@~ao} powers (@var{expr}, @var{x})
Gives the powers of @var{x} occuring in @var{expr}.

@code{load (powers)} loads this function.
@c HMM, THERE'S A BUNCH OF MAXIMA FUNCTIONS IN src/powers.lisp ...
@c FOR SOME REASON src/powers.lisp IS NOT PART OF THE USUAL BUILD -- STRANGE

@c HERE IS THE TEXT FROM archive/share/unknown/powers.usg -- MERGE !!!
@c THIS FUNCTION IS A GENERALISATION OF "HIPOW" AND "LOPOW"
@c IN THAT IT RETURNS A LIST OF ALL THE POWERS OF VAR OCCURING
@c IN EXPR. IT IS STILL NECESSARY TO EXPAND EXPR BEFORE APPLYING
@c POWERS (ON PAIN OF GETTING THE WRONG ANSWER).
@c 
@c THIS FUNCTION HAS MANY USES, E.G. IF YOU WANT TO FIND ALL
@c THE COEFFICIENTS OF X IN A POLYNOMIAL POLY YOU CAN USE
@c MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X));
@c AND MANY OTHER SIMILAR USEFUL HACKS.

@end deffn

@c NEEDS WORK
@deffn {Fun@value{cedilha}@~ao} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Returns the product of the values of @code{expr} as
the index @var{i} varies from @var{i_0} to @var{i_1}.
@c WHAT DOES THIS MEAN EXACTLY ??
The evaluation is similar to that of @code{sum}.

If @var{i_1} is one less than @var{i_0}, the product is an "empty product" and @code{product} 
returns 1 rather than reporting an error.  See also @code{prodhack}.

Maxima does not simplify products.
@c WELL, WE SHOULD CHANGE THAT.

Example:

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
@end example

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} realpart (@var{expr})
Returns the real part of @var{expr}. @code{realpart} and @code{imagpart} will
work on expressions involving trigonometic and hyperbolic functions,
as well as square root, logarithm, and exponentiation.

@end deffn

@c NEEDS EXAMPLES
@deffn {Fun@value{cedilha}@~ao} rectform (@var{expr})
Returns an expression @code{a + b %i} equivalent to @var{expr},
such that @var{a} and @var{b} are purely real.

@end deffn

@deffn {Fun@value{cedilha}@~ao} rembox (@var{expr}, unlabelled)
@deffnx {Fun@value{cedilha}@~ao} rembox (@var{expr}, @var{label})
@deffnx {Fun@value{cedilha}@~ao} rembox (@var{expr})
Removes boxes from @var{expr}.

@code{rembox (@var{expr}, unlabelled)} removes all unlabelled boxes from @var{expr}.

@code{rembox (@var{expr}, @var{label})} removes only boxes bearing @var{label}.

@code{rembox (@var{expr})} removes all boxes, labelled and unlabelled.

Boxes are drawn by the @code{box}, @code{dpart}, and @code{lpart} functions.

Examples:

@c ===beg===
@c expr: (a*d - b*c)/h^2 + sin(%pi*x);
@c dpart (dpart (expr, 1, 1), 2, 2);
@c expr2: lpart (BAR, lpart (FOO, %, 1), 2);
@c rembox (expr2, unlabelled);
@c rembox (expr2, FOO);
@c rembox (expr2, BAR);
@c rembox (expr2);
@c ===end===
@example
(%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                  a d - b c
(%o1)                sin(%pi x) + ---------
                                      2
                                     h
(%i2) dpart (dpart (expr, 1, 1), 2, 2);
                        """""""    a d - b c
(%o2)               sin("%pi x") + ---------
                        """""""      """"
                                     " 2"
                                     "h "
                                     """"
(%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                  FOO"""""""""""   BAR""""""""
                  "    """"""" "   "a d - b c"
(%o3)             "sin("%pi x")" + "---------"
                  "    """"""" "   "  """"   "
                  """"""""""""""   "  " 2"   "
                                   "  "h "   "
                                   "  """"   "
                                   """""""""""
(%i4) rembox (expr2, unlabelled);
                                  BAR""""""""
                   FOO"""""""""   "a d - b c"
(%o4)              "sin(%pi x)" + "---------"
                   """"""""""""   "    2    "
                                  "   h     "
                                  """""""""""
(%i5) rembox (expr2, FOO);
                                  BAR""""""""
                       """""""    "a d - b c"
(%o5)              sin("%pi x") + "---------"
                       """""""    "  """"   "
                                  "  " 2"   "
                                  "  "h "   "
                                  "  """"   "
                                  """""""""""
(%i6) rembox (expr2, BAR);
                   FOO"""""""""""
                   "    """"""" "   a d - b c
(%o6)              "sin("%pi x")" + ---------
                   "    """"""" "     """"
                   """"""""""""""     " 2"
                                      "h "
                                      """"
(%i7) rembox (expr2);
                                  a d - b c
(%o7)                sin(%pi x) + ---------
                                      2
                                     h
@end example

@end deffn

@c NEEDS WORK
@c NEEDS EXAMPLES
@c VERY IMPORTANT !!
@deffn {Fun@value{cedilha}@~ao} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})
Represents a summation of the values of @var{expr} as
the index @var{i} varies from @var{i_0} to @var{i_1}.
Sums may be differentiated, added, subtracted, or multiplied with some
automatic simplification being performed.
The noun form @code{'sum} is displayed in sigma notation.

If the upper and lower limits differ by an integer,
the summand @var{expr} is evaluated for each value of the summation index @var{i},
and the results are added together.

Otherwise, if the @code{simpsum} is @code{true} the summation is simplified.
Simplification may sometimes yield a closed form.
If the evaluation flag @code{simpsum} is @code{false} or simplification fails,
the result is a noun form @code{'sum}.

@code{sum} evaluates @var{i_0} and @var{i_1} and quotes @var{i}.
@c EVALUATION OF THE SUMMAND IS A MESS !!
The summand @var{expr} is quoted under some circumstances,
or evaluated to greater or lesser degree in others.

If @var{i_1} is one less than @var{i_0}, the sum is a considered an "empty sum" and @code{sum} returns 0 
rather than reporting an error.
See also @code{sumhack}.

When the evaluation flag @code{cauchysum} is @code{true},
the product of summations is expressed as a Cauchy product,
in which the index of the inner summation is a function of the
index of the outer one, rather than varying independently.

The global variable @code{genindex} is the alphabetic prefix used to generate the next index of summation,
when an automatically generated index is needed.

@code{gensumnum} is the numeric suffix used to generate the next index of summation,
when an automatically generated index is needed.
When @code{gensumnum} is @code{false}, an automatically-generated index is only
@code{genindex} with no numeric suffix.

See also @code{sumcontract}, @code{intosum},
@code{bashindices}, @code{niceindices},
@code{nouns}, and @code{evflag}.

Examples:

@c ===beg===
@c sum (i^2, i, 1, 7);
@c sum (a[i], i, 1, 7);
@c sum (a(i), i, 1, 7);
@c sum (a(i), i, 1, n);
@c ev (sum (2^i + i^2, i, 0, n), simpsum);
@c ev (sum (1/3^i, i, 1, inf), simpsum);
@c ev (sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum);
@c ===end===

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
(%i5) ev (sum (2^i + i^2, i, 0, n), simpsum);
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o5)             2      + --------------- - 1
                                  6
(%i6) ev (sum (1/3^i, i, 1, inf), simpsum);
                                1
(%o6)                           -
                                2
(%i7) ev (sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum);
                                  2
(%o7)                        5 %pi
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} lsum (@var{expr}, @var{x}, @var{L})
Represents the sum of @var{expr} for each element @var{x} in @var{L}.

A noun form @code{'lsum} is returned
if the argument @var{L} does not evaluate to a list.

Examples:

@c ===beg===
@c lsum (x^i, i, [1, 2, 7]);
@c lsum (i^2, i, rootsof (x^3 - 1));
@c ===end===
@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} verbify (@var{f})
Returns the verb form of the function name @var{f}.

See also @code{verb}, @code{noun}, and @code{nounify}.

Examples:

@c ===beg===
@c verbify ('foo);
@c :lisp $%
@c nounify (foo);
@c :lisp $%
@c ===end===
@example
(%i1) verbify ('foo);
(%o1)                          foo
(%i2) :lisp $%
$FOO
(%i2) nounify (foo);
(%o2)                          foo
(%i3) :lisp $%
%FOO
@end example

@end deffn
