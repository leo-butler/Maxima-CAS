@c /Command.texi/1.36/Sun Dec  4 08:14:10 2005/-ko/
@menu
* Introdu@value{cedilha}@~ao a Linha de Comando::  
* Defini@value{cedilha}@~oes para Linha de Comando::  
@end menu

@node Introdu@value{cedilha}@~ao a Linha de Comando, Defini@value{cedilha}@~oes para Linha de Comando, Linha de Comando, Linha de Comando
@section Introdu@value{cedilha}@~ao a Linha de Comando

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn operador "'"
O operador ap@'ostrofo @code{'} evita avalia@,{c}@~ao.

Aplicado a um s@'imbolo,
o ap@'ostrofo evita avalia@,{c}@~ao do s@'imbolo.

Aplicado a uma chamada de fun@,{c}@~ao,
o ap@'ostrofo evita avalia@,{c}@~ao da chamada de fun@,{c}@~ao,
embora os argumentos da fun@,{c}@~ao sejam ainda avaliados (se a avalia@,{c}@~ao n@`ao for de outra forma evitada).
O resultado @'e a forma substantiva da chamada de fun@,{c}@~ao.

Aplicada a uma espress@~ao com par@^entesis,
o ap@'ostrofo evita avalia@,{c}@~ao de todos os s@'imbolos e chamadas de fun@,{c}@~ao na express@~ao.
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
E.g., @code{'(f(x))} significa n@~ao avalie a express@~ao @code{f(x)}.
@code{'f(x)} (com ap@'ostrofo aplicado a @code{f} em lugar de @code{f(x)})
retorna a forma substantiva de @code{f} aplicada a @code{[x]}.

O ap@'ostrofo nao evita simplifica@,{c}@~ao.

Quando o sinalizador global @code{noundisp} for @code{true},
substantivos s@~ao mostrados com um ap@'ostrofo.
Ess comutador @'e sempre @code{true} quando mostrando defini@,{c}@~oes de fun@,{c}@~oes.

Veja tamb@'em operador ap@'ostrofo-ap@'ostrofo @code{''} e @code{nouns}.

Exemplos:

Aplicado a um s@'imbolo,
o ap@'ostrofo evita avalia@,{c}@~ao do s@'imbolo.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Aplicado a uma chamada de fun@,{c}@~ao,
o ap@'ostrofo evita avalia@,{c}@~ao da chamada de fun@,{c}@~ao.
O resultado @'e a forma substantiva da chamada de fun@,{c}@~ao.

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Aplicado a uma express@~ao com par@^entesis,
o ap@'ostrofo evita avalia@,{c}@~ao de todos os s@'imbolos e chamadas de fun@,{c}@~ao na express@~ao.

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

O ap@'ostrof n@~ao evita simplifica@,{c}@~ao.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example


@end deffn

@deffn {Operador} "'@w{}'"
O operador @code{'@w{}'} (aspas simples) faz com que ocorra uma avalia@,{c}@~ao extra.
E.g., @code{'@w{}'%i4} ir@'a reavaliar a linha de entrada @code{%i4}.
@code{'@w{}'(f(x))} significa avalie a express@~ao @code{f(x)} novamente.
@code{'@w{}'f(x)} (com as aspas simples aplicadas a @code{f} em lugar de @code{f(x)})
significa retorne a forma verbal de @code{f} aplicada a @code{[x]}.

@end deffn

@node Defini@value{cedilha}@~oes para Linha de Comando,  , Introdu@value{cedilha}@~ao a Linha de Comando, Linha de Comando
@section Defini@value{cedilha}@~oes para Linha de Comando

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Fun@,{c}@~ao} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
prov@^e um
nome alternativo para uma fun@,{c}@~ao (de usu@'ario ou de sistema), vari@'avel, array, etc.
Qualquer n@'umero de argumentos pode ser usado.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} debugmode
Valor padr@~ao: @code{false}

Quando um erro do Maxima ocorre, Maxima iniciar@'a o depurador se @code{debugmode} @'e @code{true}.
O usu@'ario pode informar comandos para examinar o hist@'orico de chamadas, marcar pontos de parada, percorrer uma linha por vez
o c@'odigo do Maxima, e assim por diante.  Veja @code{debugging} para uma lista de op@,{c}@~oes do depurador.

Habilitando @code{debugmode} n@~ao ser@~ao capturados erros do Lisp.
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Fun@,{c}@~ao} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Avalia a express@~ao @var{expr} no ambiente
especificado pelos argumentos @var{arg_1}, ..., @var{arg_n}.
Os argumentos s@~ao comutadores (sinalizadores Booleanos), atribui@,{c}@~oes, equa@,{c}@~oes, e fun@,{c}@~oes.
@code{ev} retorna o resultado (outra express@~ao) da avalia@,{c}@~ao.

A avalia@,{c}@~ao @'e realizada em passos, como segue.

@enumerate
@item
Primeiro o ambiente @'e preparado examinando os argumentos que podem
ser quaisquer ou todos os seguintes.

@itemize @bullet
@item
@code{simp} faz com que @var{expr} seja simplificado independentemente da posi@,{c}@~ao do
comutador @code{simp} que inibe simplifica@,{c}@~ao se @code{false}.
@item
@code{noeval} suprime a fase de avalia@,{c}@~ao de @code{ev} (veja passo (4) adiante).
Isso @'e @'util juntamente com outros comutadores e faz com que
@var{expr} seja simplificado novamente sem ser reavaliado.
@item
@code{nouns} causa a avalia@,{c}@~ao de formas substantivas
(tipicamente fun@,{c}@~oes n@~ao avaliadas tais como @code{'integrate} ou @code{'diff})
em @var{expr}.
@item
@code{expand} causa expans@~ao.
@item
@code{expand (@var{m}, @var{n})} causa expans@~ao, alterando os valores de @code{maxposex} e
@code{maxnegex} para @var{m} e @var{n} respectivamente.
@item
@code{detout} faz com que qualquer matriz inversa calculada em @var{expr} tenha seu
determinante mantido fora da inversa ao inv@'es de dividindo a
cada elementos.
@item
@code{diff} faz com que todas as diferencia@,{c}@~oes indicadas em @var{expr} sejam executadas.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} causa somente diferencia@,{c}@~oes referentes @`as
vari@'aveis indicadas.
@item
@code{float} faz com que n@'umeros racionais n@~ao integrais sejam convertidos para ponto 
flutuante.
@item
@code{numer} faz com que algumas fun@,{c}@~oes matem@'aticas (incluindo a exponencia@,{c}@~ao)
com argumentos sejam valiadas em ponto flutuante.  Isso faz com que
vari@'avels em @var{expr} que tenham sido dados numervals sejam substitu@'idas por
seus valores.  Isso tamb@'em modifica o comutador @code{float} para ativado.
@item
@code{pred} faz com que predicados (express@~oes que podem ser avaliados em @code{true} ou @code{false})
sejam avaliadas.
@item
@code{eval} faz com que uma avalia@,{c}@~ao posterior de @var{expr} ocorra.  (Veja passo (5)
adiante.)
@item
@code{A} onde @code{A} @'e um @'atomo declarado seja um sinalizador de avalia@,{c}@~ao (veja @code{evflag})
faz com que @code{A} seja associado a
@code{true} durante a avalia@,{c}@~ao de @var{expr}.
@item
@code{V: expres@~ao} (ou alternativamente @code{V=express@~ao}) faz com que @code{V} seja associado ao
valor de @code{express@~ao} durante a avalia@,{c}@~ao de @var{expr}.  Note que se @code{V} @'e uma
op@,{c}@~ao do Maxima, ent@~ao @code{expression} @'e usada para seu valor durante a
avalia@,{c}@~ao de @var{expr}.  Se mais que um argumento para @code{ev} @'e desse tipo
ent@~ao a associa@~ao termina em paralelo.  Se @code{V} @'e uma express@~ao n@~ao at@^omica
ent@~ao a substitui@,{c}@~ao, ao inv@'es de uma associa@,{c}@~ao, @'e executada.
@item
@code{F} onde @code{F}, um nome de fun@,{c}@~ao, tenha sido declarado para ser uma fun@,{c}@~ao de avalia@,{c}@~ao (veja @code{evfun})
faz com que @code{F}
seja aplicado a @var{expr}.
@item
Qualquer outro nome de fun@,{c}@~ao (e.g., @code{sum}) causa a avalia@,{c}@~ao de ocorr@^encias
desses nomes em @var{expr} mesmo que eles tenham sido verbos.
@item
De forma adicional uma fun@,{c}@~ao ocorrendo em @var{expr} (digamos @code{F(x)}) pode ser definida
localmente para o prop@'osito dessa avalia@,{c}@~ao de @var{expr} dando
@code{F(x) := express@~ao} como um argumento para @code{ev}.
@item
Se um @'atomo n@~ao mensionado adiante ou uma vari@'avel subscrita ou
express@~ao subscrita for dada como um argumento, isso @'e avaliado e
se o resultado @'e uma equa@,{c}@~ao ou uma atribui@,{c}@~ao ent@~ao a associa@,{c}@~ao indicada
ou substitui@,{c}@~ao @'e executada.  Se o resultado @'e uma lista ent@~ao os
membros da lista ser@~ao tratados  como se eles fossem argumentos adicionais
dados para @code{ev}.  Isso permite uma lista de equa@,{c}@~oes seja dada (e.g. @code{[X=1, Y=A**2]})
ou uma lista de nomes de equa@,{c}@~oes (e.g., @code{[%t1, %t2]} onde @code{%t1} e
@code{%t2} s@~ao equa@,{c}@~oes) tais como aquelas retornadas por @code{solve}.
@end itemize

Os argumentos de @code{ev} podem ser dados em qualquer ordem com exce@,{c}@~ao de
substitui@,{c}@~oes de equa@,{c}@~oes que s@~ao manuseadas em seq@"u@^encia, da esquerda para a direita,
e fun@,{c}@~oes de avalia@,{c}@~ao que s@~ao compostas, e.g., @code{ev (@var{expr}, ratsimp, realpart)} @'e
manuseada como @code{realpart (ratsimp (@var{expr}))}.

Os comutadores @code{simp}, @code{numer}, @code{float}, e @code{pred} podem tamb@'em ser alterados localmente em um
bloco, ou globalmente no Maxima dessa forma eles ir@~a
permanecer em efeito at@'e serem resetados.

Se @var{expr} for uma express@~ao racional can@^onica (CRE),
ent@~ao a express@~ao retornada por @code{ev} @'e tamb@'em uma CRE,
provida a comutadores @code{numer} e @code{float} n@~ao sejam ambos @code{true}.

@item
Durante o passo (1), uma lista @'e feita de vari@'aveis n@~ao subscritas
aparecendo do lado esquerdo das equa@,{c}@~oes nos argumentos ou nos
valores de alguns argumentos se o valor @'e uma equa@,{c}@~ao.  As vari@'aveis
(vari@'aveis subscritas que n@~ao possuem fun@,{c}@~oes array
associadas bem como vari@'aveis n@~ao subscritas) na express@~ao @var{expr} s@~ao
substitu@'idas por seus valores globais, exceto para esse aparecendo nessa 
lista.  Usualmente, @var{expr} @'e apenas um r@'otulo ou @code{%}
(como em @code{%i2} no exemplo adiante), ent@~ao esse 
passo simplesmente repete a express@~ao nomeada pelo r@'otulo, de modo que @code{ev}
possa trabalhar sobre isso.

@item
Se quaisquer substitui@,{c}@~oes s@~ao indicadas pelos argumentos, elas ser@~ao
realizadas agora.

@item
A express@~ao resultante @'e ent@~ao reavaliada (a menos que um dos
argumentos seja @code{noeval}) e simplificada conforme os argumentos.  Note que
qualquer chamada de fun@,{c}@~ao em @var{expr} ser@'a completada depois das vari@'aveis
nela serem avalidas e que @code{ev(F(x))} dessa forma possa comportar-se como @code{F(ev(x))}.

@item
Se um dos argumentos for @code{eval}, passos (3) e (4) ser@~ao repetidos.
@end enumerate

                     Exemplos

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Uma sintaxe alternativa de alto n@'ivel tem sido provida por @code{ev}, por meio da qual
se pode apenas digitar seus argumentos, sem o @code{ev()}.  Isto @'e, se pode
escrever simplesmente

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Isso n@~ao @'e permitido como parte de
outra express@~ao, e.g., em fun@,{c}@~oes, blocos, etc.

Observe o processo de associa@,{c}@~ao paralela no seguinte exemplo.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn

@defvr {Propriedade} evflag
Alguns sinalizadores Booleanos possuem a propriedae @code{evflag}.
@code{ev} trata tais sinalizadores especialmente.
Um sinalizador com a propriedade @code{evflag} n@~ao ser@'a associado a @code{true}
durante a execu@,{c}@~ao de @code{ev} se isso @'e
mensionado na chamada para @code{ev}.
Por exemplo, @code{demoivre} e @code{ratfac} s@~ao associados a @code{true}
durante a chamada @code{ev (%, demoivre, ratfac)}.

Os sinalizadores qu possuem a propriedade @code{evflag} s@~ao:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, and
@code{trigexpand}.

A constru@,{c}@~ao @code{:lisp (putprop '|$foo| t 'evflag)}
fornece a propriedade @code{evflag} para a vari@'avel @code{foo},
ent@~ao @code{foo} @'associada a @code{true} durante a chamada @code{ev (%, foo)}.
Equivalentemente, @code{ev (%, foo:true)} tem o mesmo efeito.

@end defvr

@defvr {Propriedade}  evfun
Agumas fun@,{c}@~oes possuem a proriedade @code{evfun}.
@code{ev} trata cada fun@,{c}@~ao especialmente.
Uma fun@,{c}@~ao com a propriedade @code{evfun} ser@'a aplicada
durante a execu@,{c}@~ao de @code{ev} se isso for
mecionado na chamada a @code{ev}.
Por exemplo, @code{ratsimp} e @code{radcan} ser@'a aplicada
durante a chamada @code{ev (%, ratsimp, radcan)}.

As fun@,{c}@~oes que possuem a propriedade @code{evfun} s@~ao:
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

A constru@,{c}@~ao @code{:lisp (putprop '|$foo| t 'evfun)}
fornece a propriedade @code{evfun} para a fun@,{c}@~ao @code{foo},
de modo que @code{foo} @'e aplicada durante a chamada @code{ev (%, foo)}.
Equivalentemente, @code{foo (ev (%))} tem o mesmo efeito.

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de op@,{c}@~ao} infeval
Habilita o modo "avalia@,{c}@~ao infinita".  @code{ev} repetidamente avalia
uma express@~ao at@'e que ela permane@,{c}a invariante.  Para prevenir uma
vari@'avel, digamos @code{X}, seja demoradamente avaliada nesso modo, simplesmente
inclua @code{X='X} como um argumento para @code{ev}.  Certamente express@~oes tais como
@code{ev (X, X=X+1, infeval)} ir@~ao gerar um ciclo infinito.

@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Fun@,{c}@~ao} kill (@var{symbol_1}, ..., @var{symbol_n})
@deffnx {Fun@,{c}@~ao} kill (labels)
@deffnx {Fun@,{c}@~ao} kill (inlabels, outlabels, linelabels)
@deffnx {Fun@,{c}@~ao} kill (@var{n})
@deffnx {Fun@,{c}@~ao} kill ([@var{m}, @var{n}])
@deffnx {Fun@,{c}@~ao} kill (values, functions, arrays, ...)
@deffnx {Fun@,{c}@~ao} kill (all)
@deffnx {Fun@,{c}@~ao} kill (allbut (@var{symbol_1}, ..., @var{symbol_n}))

Remove todas as associa@,{c}@~oes (valor, fun@,{c}@~oes, array, ou regra) dos argumentos
@var{symbol_1}, ..., @var{symbol_n}.
Um argumento pode ser um elemento simples de um array ou uma fun@,{c}@~ao subscrita.

Muitos argumentos especiais s@~ao reconhecidos.  
Diferentes fam@'ilias de argumentos 
podem ser combinadas, e.g., @code{kill (inlabels, functions, allbut (foo, bar))}

todos os r@'otulos de entrada, de sa@'ida, e de express@~oes intermedi@'arias criados at@'e ent@~ao.
@code{kill (inlabels)} libera somente r@'otudos de entrada 
que come@,{c}am com o valor corrente de @code{inchar}.
De forma semelhante,
@code{kill (outlabels)} libera somente r@'otulos de sa@'ida
que come@,{c}am com o valor corrente de @code{outchar},
e @code{kill (linelabels)} libera somente r@'otulos de express@~oes intermedi@'arias
que come@,{c}am com o valor corrente de @code{linechar}.

@code{kill (@var{n})}, onde @var{n} @'e um inteiro,
libera os @var{n} mais recentes r@'otulos de entrada e sa@'ida.

@code{kill ([@var{m}, @var{n}])} libera r@'otulos de entrada e sa@'ida de @var{m} at@'e @var{n}.

@code{kill (@var{infolist})}, onde @var{infolist} @'e um @'item em @code{infolists}
(tais como @code{values}, @code{functions}, ou @code{arrays})
libera todos os @'itens em @var{infolist}.
Veja tamb@'em @code{infolists}.

@code{kill (all)} liberar todos os @'itens em todas as infolists.
@code{kill (all)} n@~ao retorna vari@'aveis globais para seus valores padr@~oes;
Veja @code{reset} sobre esse ponto.

@code{kill (allbut (@var{symbol_1}, ..., @var{symbol_n}))}
libera todos os @'itens em todas as infolists exceto para @var{symbol_1}, ..., @var{symbol_n}.
@code{kill (allbut (@var{infolist}))} libera todos os @'itens exceto para si pr@'oprio em @var{infolist},
onde @var{infolist} @'e @code{values}, @code{functions}, @code{arrays}, etc.

A mem@'oria usada por uma propriedade de associa@,{c}@~ao n@~ao ser@'a liberada at@'e que todos os s@'imbolos
sejam liberados disso.
Em particular, para liberar a mem@'oria usada pelo valor de um s@'imbolo,
deve-se liberar o r@'otulo de sa@'ida que mosta o valor associado, bem como liberando o pr@'oprio s@'imbolo.

@code{kill} n@~ao avalia seus argumentos.
O operador aspas simples, @code{'@w{}'}, faz com que ocorra avalia@,{c}@~ao.

@code{kill (@var{symbol})} libera todas as propriedades de @var{symbol}.
Em oposi@,{c}@~ao, @code{remvalue}, @code{remfunction}, @code{remarray}, e @code{remrule}
liberam uma propriedade espec@'ifica.

@code{kill} sempre retorna @code{done}, igualmente se um argumento n@~ao tem associa@,{c}@~oes.

@end deffn

@deffn {Fun@,{c}@~ao} labels (@var{symbol})
@deffnx {Vari@'avel de sistema} labels
Retorna a lista de r@'otulos de entradas, de sa@'ida, de express@~oes intermedi@'arias que come@,{c}am com @var{symbol}.
Tipicamente @var{symbol} @'e o valor de @code{inchar}, @code{outchar}, ou @code{linechar}.
O caracter r@'otulo pode ser dado com ou sem o sinal de porcentagem,
ent@~ao, por exemplo, @code{i} e @code{%i} retornam o mesmo resultado.

Se nenhum r@'otulo come@,{c}a com @var{symbol}, @code{labels} retorna uma lista vazia.

A fun@,{c}@~ao @code{labels} n@~ao avalia seu argumento.
O operador aspas simples @code{'@w{}'} faz com que ocorra avalia@,{c}@~ao.
Por exemplo,
@code{labels (''inchar)} retorna os r@'otulos de entrada que come@,{c}am com o caractere corrente do r@'otulo de entrada.

A vari@'avel @code{labels} @'e uma lista de r@'otulos de entrada, sa@'ida, e de express@`oes intermedi@'arias,
incluindo todos os r@'otulos anteriores se @code{inchar}, @code{outchar}, ou @code{linechar} foram redefinidos.

Por padr@~ao, Maxima mostra o resultado de cada express@~ao de entrada do usu@'ario,
dando ao resultado um r@'otulo de sa@'ida.
A exibi@,{c}@~ao da sa@'ida @'e suprimida pelo encerramento da entrada com @code{$} (sinal de dolar)
em lugar de @code{;} (ponto e v@'irgula).
Um r@'otulo de sa@'ida @'e gerado, mas n@~ao @'e mostrado, 
e o r@'otulo pode ser referenciado da mesma forma que r@'otulos de sa@'ida mostrados.
Veja tamb@'em @code{%}, @code{%%}, e @code{%th}.

R@'otulos de express@~oes intermedi@'arias podem ser gerados por algumas fun@,{c}@~oes.
O sinalizador @code{programmode} controla se @code{solve} e algumas outras fun@,{c}@~oes
geram r@'otulos de express@~oes intermedi@'arias em lugar de retornar uma lista de express@~oes.
Algumas outras fun@,{c}@~oes, tais como @code{ldisplay}, sempre gera r@'otulos de express@~oes intermedi@'arias.

@c NEED TO EXPLAIN THIS SHORTCUT ???
@code{first (rest (labels (''inchar)))} retorna o r@'otulo de entrada mais recente.

Veja tamb@'em @code{inchar}, @code{outchar}, @code{linechar}, e @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Vari@'avel de sistema} linenum
Retorna o n@'umero da linha do par corrente de express@~oes de entrada e sa@'ida.

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de sistema} myoptions
Valor padr@~ao: @code{[]}

@code{myoptions} @'e a lista de todas as op@,{c}@~oes alguma vez alteradas pelo usu@'ario,
tenha ou n@~ao ele retornado a altera@,{c}@~ao para o seu valor padr@~ao.

@end defvr

@c THIS DESCRIPTION IS AT ODDS WITH OBSERVED BEHAVIOR: !!!
@c WHEN nolabels IS TRUE, LABELS ARE CREATED AND DISPLAYED BUT NOT PUT INTO THE labels LIST !!!
@c kill (labels) THEN KILLS THE ONES ON THE LIST BUT NOT ANY CREATED AFTER nolabels: true !!!
@defvr {Vari@'avel de op@,{c}@~ao} nolabels
Valor padr@~ao: @code{false}

@c PREVIOUS DESCRIPTION OF nolabels: THIS IS OUT OF DATE
@c When @code{nolabels} is @code{true}, then no labels will be bound
@c except for intermediate express@~ao lines generated by the solve functions.  This is most
@c useful in the batch mode where it eliminates the need to do
@c @code{kill (labels)} in order to free up storage.

Quando @code{nolabels} @'e @code{true}, r@'otulos de entrada e sa@'ida s@~ao gerados
mas n@~ao adicionados ao final de @code{labels}, a lista de todos os r@'otulos de entrada e sa@'ida.
@code{kill (labels)} elimina os r@'otulos na lista @code{labels},
mas n@~ao elimina qualquer r@'otulo gerado desde @code{nolabels} foi atribu@'ido @code{true}.
Isso d@'a a entender que provavelmente esse comportamento est@'a simplesmente quebrado.

Veja tamb@'em @code{batch}, @code{batchload}, e @code{labels}.
@c PUT A CROSS REFERENCE IN DESCRIPTION OF labels WHEN STRANGE BEHAVIOR OF nolabels IS CLEARED UP !!!

@end defvr

@c NEEDS WORK
@defvr {Vari@'avel de op@,{c}@~ao} optionset
Valor padr@~ao: @code{false}

Quando @code{optionset} @'e @code{true}, Maxima mostra uma
mensagem sempre que uma op@,{c}@~ao do Maxima @'e alterada.  Isso @'e @'util se o
usu@'ario est@'a incerto sobre a ortografia de alguma op@,{c}@~ao e quer ter certeza
que a vari@'avel por ele atribu@'ido um valor foi realmente uma vari@'avel de op@,{c}@~ao.

@end defvr

@deffn {Fun@,{c}@~ao} playback ()
@deffnx {Fun@,{c}@~ao} playback (@var{n})
@deffnx {Fun@,{c}@~ao} playback ([@var{m}, @var{n}])
@deffnx {Fun@,{c}@~ao} playback ([@var{m}])
@deffnx {Fun@,{c}@~ao} playback (input)
@deffnx {Fun@,{c}@~ao} playback (slow)
@deffnx {Fun@,{c}@~ao} playback (time)
@deffnx {Fun@,{c}@~ao} playback (grind)
Mostra express@~oes de entrada, de sa@'ida, e express@~oes intermedi@'arias,
sem refazer os c@'alculos.
@code{playback} somente mostra as express@~oes associadas a r@'otulos;
qualquer outra sa@'ida (tais como textos impressos por @code{print} ou @code{describe}, ou messagens de erro)
n@~ao @'e mostrada.
Veja tamb@'em @code{labels}.

@code{playback} n@~ao avalia seus argumentos.
O operador aspas simples, @code{'@w{}'}, sobrep@~oe-se @`as aspas.
@code{playback} sempre retorna @code{done}.

@code{playback ()} (sem argumentos) mostra todas as entradas, sa@'idas e express@~oes intermedi@'arias
geradas at@'e ent@~ao.
Uma express@~ao de sa@'ida @'e mostrada mesmo se for suprimida pelo terminador @code{$}
quando ela tiver sido originalmente calculada.

@code{playback (@var{n})} mostra as mais recentes @var{n} express@~oes.
Cada entrada, sa@'ida e express@~ao intermedi@'aria
conta como um.

@code{playback ([@var{m}, @var{n}])} mostra entradas, sa@'idas e express@~oes intermedi@'arias
com os n@'umeros de @var{m} at@'e @var{n}, inclusive.

@code{playback ([@var{m}])} @'e equivalente a @code{playback ([@var{m}, @var{m}])};
isso usu@'almente imprime um par de express@~oes de entrada e sa@'ida.

@code{playback (input)} mostra todas as express@~oes de entrada geradas at@'e ent@~ao.

@code{playback (slow)} insere pausas entre express@~oes
e espera que o usu@'ario pressione @code{enter}.
Esse comportamento @'e similar a @code{demo}.
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} @'e @'util juntamente com @code{save} ou @code{stringout}
quando criamos um arquivo secund@'ario de armazenagem com a finalidade de capturar express@~oes @'uteis.

@code{playback (time)} mostra o tempo de computa@,{c}@~ao de cada express@~ao.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} e @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} mostra express@~oes de entrada
no mesmo formato da fun@,{c}@~ao @code{grind}.
Express@~oes de sa@'ida n@~ao s@~ao afetadas pela op@,{c}@~ao @code{grind}.
Veja @code{grind}.

Argumentos podem ser combinados, e.g., 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS).  CORRECT ???

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Fun@,{c}@~ao} printprops (@var{a}, @var{i})
@deffnx {Fun@,{c}@~ao} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Fun@,{c}@~ao} printprops (all, @var{i})
Mostra a propriedade como o indicador @var{i}
associada com o @'atomo @var{a}.  @var{a} pode tamb@'em ser uma lista de @'atomos ou o @'atomo
@code{all} nesse caso todos os @'atomos com a propriedade dada ser@~ao
usados.  Por exemplo, @code{printprops ([f, g], atvalue)}.  @code{printprops} @'e para
propriedades que n@~ao podem  ser mostradas de outra forma, i.e. para
@code{atvalue}, @code{atomgrad}, @code{gradef}, e @code{matchdeclare}.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} prompt
Valor padr@~ao: @code{_}

@code{prompt} @'e o s@'imbolo de linha de comando da fun@,{c}@~ao @code{demo},
modo @code{playback (slow)}, e o Maxima interrompe o ciclo (como invocado por @code{break}).

@end defvr

@deffn {Fun@,{c}@~ao} quit ()
Encerra a sess@~ao do Maxima.
Note que a fun@,{c}@~ao pode ser invocada como @code{quit();} ou @code{quit()$},
n@~ao por s@'i mesma @code{quit}.

Para parar um c@'alculo muito longo,
digite @code{control-C}.
A a@,{c}@~ao padr@~ao @'e retornar @`a linha de comando do Maxima.
Se @code{*debugger-hook*} @'e @code{nil},
@code{control-C} abre o depurador Lisp.
Veja tamb@'em @code{debugging}.

@end deffn

@deffn {Fun@,{c}@~ao} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Fun@,{c}@~ao} remfunction (all)
Desassocia as defini@,{c}@~oes de fun@,{c}@~ao dos s@'ibolos @var{f_1}, ..., @var{f_n}.
Os argumentos podem ser os nomes de fun@,{c}@~oes comuns (criadas por meio de @code{:=} ou @code{define})
ou fun@,{c}@~oes macro (criadas por meio de @code{::=}).

@code{remfunction (all)} desassocia todas as defini@,{c}@~oes de func@,{c}@~ao.

@code{remfunction} coloca um ap'ostrofo em seus argumentos (n@~ao os avalia).

@code{remfunction} retorna uma lista de s@'imbolos para a qual a defini@,{c}@~ao de fun@,{c}@~ao foi desassociada.
@code{false} @'e retornado em lugar de qualquer s@'imbolo para o qual n@~ao exista defini@,{c}@~ao de fun@,{c}@~ao.

@end deffn

@deffn {Fun@,{c}@~ao} reset ()
Retorna muitas vari@'aveis globais e op@,{c}@~oes, e algumas outras vari@'aveis, para seus valores padr@~oes.

@code{reset} processa as vari@'aveis na lista Lisp @code{*vari@'avel-initial-values*}.
A macro Lisp @code{defmvar} coloca vari@'aveis nessa lista (entre outras a@,{c}@~oes).
Muitas, mas n@~ao todas, vari@'aveis globais e op@,{c}@~oes s@~ao definidas por @code{defmvar},
 e algumas vari@'aveis definidas por @code{defmvar} n@~ao s@~ao vari@'aveis globais ou op@,{c}@~oes.

@end deffn

@defvr {Vari@'avel de op@,{c}@~ao} showtime
Valor padr@~ao: @code{false}

Quando @code{showtime} @'e @code{true}, o tempo de computa@,{c}@~ao e o tempo decorrido s@~ao
impressos na tela com cada express@~ao de sa@'ida.

O tempo de c@'algulo @'e sempre gravado,
ent@~ao @code{time} e @code{playback} podem mostrar o tempo de c@'alculo
mesmo quando @code{showtime} for @code{false}.

Veja tamb@'em @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Fun@,{c}@~ao} sstatus (@var{feature}, @var{package})
Altera o status de @var{feature} em @var{package}.
Ap@'os @code{sstatus (@var{feature}, @var{package})} @'e executado,
@code{status (@var{feature}, @var{package})} retorna @code{true}.
Isso pode ser @'util para quem escreve pacotes, para
manter um rastro de quais recursos os pacotes usam.

@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Fun@,{c}@~ao} to_lisp ()
Insere o sistema Lisp dentro do Maxima.  @code{(to-maxima)} retorna para o Maxima.

@end deffn

@defvr {Vari@'avel de sistema} values
Valor inicial: @code{[]}

@code{values} @'e uma lista de todas as var@'aveis de usu@'ario associadas (n@~ao op@,{c}@~oes Maxima ou comutadores).
A lista compreende s@'imbolos associados por @code{:} , @code{::}, ou @code{:=}.

@end defvr
