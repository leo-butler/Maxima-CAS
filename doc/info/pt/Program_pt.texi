@c /Program.texi/1.20/Fri Jun 17 00:57:34 2005/-ko/
@menu
* Introduction to Program Flow::  
* Definitions for Program Flow::  
@end menu

@node Introduction to Program Flow, Definitions for Program Flow, Program Flow, Program Flow
@c PT = Introdu@,{c}@~ao ao Fluxo do Programa
@section Introduction to Program Flow

Maxima fornece um @code{do} para ciclos iterativos, tamb@'em contru@,{c}@~oes mais
primitivas tais como @code{go}.

@c end concepts Program Flow
@node Definitions for Program Flow,  , Introduction to Program Flow, Program Flow
@c PT = Defini@,{c}@~oes para Fluxo do Programa
@section Definitions for Program Flow

@deffn {Fun@,{c}@~ao} backtrace ()
@deffnx {Fun@,{c}@~ao} backtrace (@var{n})
Imprime a pilha de chamadas, que @'e, a lista de fun@,{c}@~oes que
foram chamadas pela fun@,{c}@~ao correntemente ativa.

@code{backtrace()} imprime toda a pilha de chamadas.

@code{backtrace (@var{n})} imprime as @var{n} mais recentes chamadas a
fun@,{c}@~oes, incluindo a fun@,{c}@~ao correntemente ativa.

@c IS THIS STATMENT REALLY NEEDED ?? 
@c (WHY WOULD ANYONE BELIEVE backtrace CANNOT BE CALLED OUTSIDE A DEBUGGING CONTEXT??)
@code{backtrace} pode ser chamada por um script, uma fun@,{c}@~ao, ou a partir da linha de comando interativa
(n@~ao somente em um contexto de depura@,{c}@~ao).

Exemplos:

@itemize @bullet
@item
@code{backtrace()} imprime toda a pilha de chamadas.

@example
(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@itemize @bullet
@item
@code{backtrace (@var{n})} imprime as @var{n} mais recentes chamadas a
fun@,{c}@~oes, incluindo a fun@,{c}@~ao correntemente ativa.

@example
(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@end deffn

@deffn {Operador especial} do
A declara@,{c}@~ao @code{do} @'e usada para executar itera@,{c}@~ao.  Devido @`a sua
grande generalidade a declara@,{c}@~ao @code{do} ser@'a  descrita em duas partes.
Primeiro a forma usual ser@'a dada que @'e an@'aloga @`a forma que @'e usada em
muitas outras linguagens de programa@,{c}@~ao (Fortran, Algol, PL/I, etc.); em segundo lugar
os outros recursos ser@~ao mencionados.

Existem tr@^es variantes do operador especial @code{do} que diferem somente por suas
condi@,{c}@~oes de encerramento.  S@~ao elas:

@itemize @bullet
@item
@code{for @var{Vari@'avel}: @var{valor_inicial} step @var{incremento}
      thru @var{limite} do @var{corpo}}
@item
@code{for @var{Vari@'avel}: @var{valor_inicial} step @var{incremento}
      while @var{condition} do @var{corpo}}
@item
@code{for @var{Vari@'avel}: @var{valor_inicial} step @var{incremento}
      unless @var{condition} do @var{corpo}}
@end itemize

@c UGH.  DO WE REALLY NEED TO MENTION THIS??
(Alternativamente, o @code{step} pode ser dado ap@'os a condi@,{c}@~ao de encerramento
ou limite.)

@var{valor_inicial}, @var{incremento}, @var{limite}, e @var{corpo} podem ser quaisquer
express@~oes.  Se o incremento for 1 ent@~ao "@code{step 1}" pode ser omitido.

A execu@,{c}@~ao da declara@,{c}@~ao @code{do} processa-se primeiro atribuindo o
valor_inicial para a vari@'avel (daqui em diante chamada a
vari@'avel de controle).  Ent@~ao: (1) Se a vari@'avel de controle excede
o limite de uma especifica@,{c}@~ao @code{thru}, ou se a condi@,{c}@~ao de @code{unless} for
@code{true}, ou se a condi@,{c}@~ao de @code{while} for @code{false} ent@~ao o @code{do}
ser@'a encerrado.  (2) O corpo @'e avaliado.  (3) O incremento @'e adicionado @`a
vari@'avel de controle.  O processo de (1) a (3) @'e executado
repetidamente at@'e que a condi@,{c}@~ao de encerramento seja satisfeita.  Pode-se tamb@'em
dar muitas condi@,{c}@~oes de encerramento e nesse caso o @code{do} termina
quando qualquer delas for satisfeita.

Em geral o teste @code{thru} @'e satisfeito quando a vari@'avel de controle for
maior que o limite se o incremento for n@~ao negativo, ou quando a
vari@'avel de controle for menor que o limite se o incremento for negativo.
O incremento e o limite podem ser express@~oes n@~ao num@'ericas enquanto essa
desigualdade puder ser determinada.  Todavia, a menos que o incremento seja
sintaticamente negativo (e.g. for um n@'umero negativo) na hora em que a declara@,{c}@~ao @code{do}
for iniciada, Maxima assume que o incremento e o limite ser@~ao positivos quando o @code{do} for
executado.  Se o limite e o incremento n@~ao forem positivos, ent@~ao o @code{do} pode n@~ao terminar
propriamente.

Note que o limite, incremento, e condi@,{c}@~ao de encerramento s@~ao
avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer desses for respons@'avel por
muitos c@'alculos, e retornar um resultado que n@~ao muda durante todas
as execu@,{c}@~oes do corpo, ent@~ao @'e mais eficiente escolher uma
vari@'avel para seu valor anterior para o @code{do} e usar essa vari@'avel na
forma @code{do}.

O valor normalmente retornado por uma declara@,{c}@~ao @code{do} @'e o @'atomo @code{done}.
Todavia, a fun@,{c}@~ao
@code{return} pode ser usada dentro do corpo para sair da delcara@,{c}@~ao @code{do} prematuramente e dar
a isso qualquer valor desejado.
Note todavia que um @code{return} dentro de um @code{do} que
ocorre em um @code{block} encerrar@'a somente o @code{do} e n@~ao o @code{block}.  Note tamb@'em
que a fun@,{c}@~ao @code{go} n@~ao pode ser usada para sair de dentro de um @code{do} dentro de um
@code{block} que o envolve.

A vari@'avel de controle @'e sempre local para o @code{do} e dessa forma qualquer
vari@'avel pode ser usada sem afetar o valor de uma vari@'avel com
o mesmo nome fora da declara@,{c}@~ao @code{do}.  A vari@'avel de controle @'e liberada
ap@'os o encerramento da declara@,{c}@~ao @code{do}.

@example
(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
@end example

@example
(%i1) s: 0$
(%i2) for i: 1 while i <= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
@end example

Note que a condi@,{c}@~ao @code{while i <= 10}
@'e equivalente a @code{unless i > 10} e tamb@'em @code{thru 10}.

@example
(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p > 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
@end example

que fornece 8 termos da s@'erie de Taylor para @code{e^sin(x)}.

@example
(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) < 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
@end example

Esse exemplo calcula a ra@'iz quadrada negativa de 10 usando a
itera@,{c}@~ao de Newton- Raphson um maximum de 10 vezes.  Caso o crit@'erio de
converg@^ecia n@~ao tenha sido encontrado o valor retornado pode ser @code{done}.
Em lugar de sempre adicionar uma quantidade @`a vari@'avel de controle pode-se
algumas vezes desejar alterar isso de alguma outra forma para cada itera@,{c}@~ao.
Nesse caso pode-se usar @code{next @var{express@~ao}} em lugar de @code{step @var{incremento}}.
Isso far@'a com que a vari@'avel de controle seja escolhida para o
resultado da express@~ao de avalia@,{c}@~ao cada vez que o ciclo de repeti@,{c}@~ao for executado.

@example
(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
@end example

@c UGH.  DO WE REALLY NEED TO MENTION THIS??
Como uma alternativa para @code{for @var{Vari@'avel}: @var{valor} ...do...} a sintaxe
@code{for @var{Vari@'avel} from @var{valor} ...do...}  pode ser usada.  Isso permite o
@code{from @var{valor}} ser colocado ap@'os o @code{step} ou proximo valor ou ap@'os a
condi@,{c}@~ao de encerramento.  Se @code{from @var{valor}} for omitido ent@~ao 1 @'e usado como
o valor inicial.

Algumas vezes se pode estar interessado em executar uma itera@,{c}@~ao onde
a vari@'avel de controle nunca seja usada.  Isso @'e permiss@'ivel
para dar somente as condi@,{c}@~oes de encerramento omitindo a inicializa@,{c}@~ao
e a informa@,{c}@~ao de atualiza@,{c}@~ao como no exemplo seguinte para para calcular a
ra@'iz quadrada de 5 usando uma fraca suposi@,{c}@~ao inicial.

@example
(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
@end example

Se isso for desejado pode-se sempre omitir as condi@,{c}@~oes de encerramento
inteiramente e apenas dar o corpo @code{do @var{corpo}} que continuar@'a a ser 
avaliado indefinidamente.  Nesse caso a fun@,{c}@~ao @code{return} ser@'a usada para
encerrar a execu@,{c}@~ao da declara@,{c}@~ao @code{do}.

@example
(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) < 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
@end example

@c DUNNO IF WE NEED THIS LEVEL OF DETAIL; THIS ARTICLE IS GETTING PRETTY LONG
(Note que @code{return}, quando executado, faz com que o valor corrente de
@code{x} seja retornado como o valor da declara@,{c}@~ao @code{do}.  O @code{block} @'e encerrado e
esse valor da declara@,{c}@~ao @code{do} @'e retornado como o valor do @code{block} porque o
@code{do} @'e a @'ultima declara@,{c}@~ao do @code{block}.)

Uma outra forma de @code{do} @'e dispon@'ivel no Maxima.  A sintaxe @'e:

@example
for @var{Vari@'avel} in @var{list} @var{end_tests} do @var{corpo}
@end example

Os elementos de @var{list} s@~ao quaisquer express@~oes que ir@~ao
sucessivamente ser atribu@'idas para a vari@'avel a cada itera@,{c}@~ao do
corpo.  O teste opcional @var{end_tests} pode ser usado para encerrar a execu@,{c}@~ao da
declara@,{c}@~ao @code{do}; de outra forma o @code{do} terminar@'a quando a lista for exaurida ou quando
um @code{return} for executado no corpo.  (De fato, a lista pode ser qualquer
express@~ao n@~ao at@^omica, e partes sucessivas s@~ao usadas.)

@example
(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
@end example

@end deffn

@deffn {Fun@,{c}@~ao} errcatch (@var{expr_1}, ..., @var{expr_n})
Avalia @var{expr_1}, ..., @var{expr_n} uma por uma e
retorna @code{[@var{expr_n}]} (uma lista) se nenhum erro ocorrer.  Se um
erro ocorrer na avalia@,{c}@~ao de qualquer argumento, @code{errcatch}
evita que o erro se propague e
retorna a lista vazia @code{[]} sem avaliar quaisquer mais argumentos.

@code{errcatch}
@'e @'util em arquivos @code{batch} onde se suspeita que um erro possa estar ocorrendo o @code{errcatch}
terminar@'a o @code{batch} se o erro n@~ao for detectado.

@end deffn

@deffn {Fun@,{c}@~ao} error (@var{expr_1}, ..., @var{expr_n})
@deffnx {Vari@'avel de sistema} error
Avalia e imprime @var{expr_1}, ..., @var{expr_n},
e ent@~ao causa um retorno de erro para o n@'ivel mais alto do Maxima
ou para o mais pr@'oximo contendo @code{errcatch}.

A vari@'avel @code{error} @'e escolhida para uma lista descrevendo o erro.
O primeiro elemento de @code{error} @'e uma string de formato,
que junta todas as strings entre os argumentos @var{expr_1}, ..., @var{expr_n},
e os elementos restantes s@~ao os valores de quaisquer argumentos n@~ao string.

@code{errormsg()} formata e imprime @code{error}.
Isso efetivamente reimprime a mais recente mensagem de erro.

@end deffn

@deffn {Fun@,{c}@~ao} errormsg ()
Reimprime a mais recente mensagem de erro.
A vari@'avel @code{error} recebe a mensagem,
e @code{errormsg} formata e imprime essa mensagem.

@end deffn

@c REPHRASE
@deffn {Operador especial} for
Usado em itera@,{c}@~oes.  Veja @code{do} para uma descri@,{c}@~ao das
facilidades de itera@,{c}@~ao do Maxima.

@end deffn

@deffn {Fun@,{c}@~ao} go (@var{tag})
@'e usada dentro de um @code{block} para transferir o controle para a declara@,{c}@~ao
do bloco que for identificada com o argumento para @code{go}.  Para identificar uma
declara@,{c}@~ao, coloque antes dessa declara@,{c}@~ao um argumento at@^omico como outra declara@,{c}@~ao no
@code{block}.  Por exemplo:

@example
block ([x], x:1, loop, x+1, ..., go(loop), ...)
@end example

O argumento para @code{go} deve ser o nome de um identificardor aparecendo no mesmo
@code{block}.  N@~ao se pode usar @code{go} para transferir para um identificador em um outro @code{block} que n@~ao seja
o pr@'oprio contendo o @code{go}.

@end deffn

@c NEEDS CLARIFICATION, EXPANSION, EXAMPLES
@c THIS ITEM IS IMPORTANT
@deffn {Operador especial} if
A declara@,{c}@~ao @code{if} @'e usada para execu@,{c}@~ao condicional.  A sintaxe
@'e:

@example
if <condi@,{c}@~ao> then <expr_1> else <expr_2>
@end example

O resultado de uma declara@,{c}@~ao @code{if} ser@'a @var{expr_1} se condi@,{c}@~ao for @code{true} e
@var{expr_2} de outra forma.  @var{expr_1} e @var{expr_2} s@~ao quaisquer
express@~oes Maxima (incluindo declara@,{c}@~oes @code{if} aninhadas), e @var{condi@,{c}@~ao} @'e
uma express@~ao que avalia para @code{true} ou @code{false} e @'e composto de
operadores relacionais e l@'ogicos que s@~ao os seguintes:

@c - SEEMS LIKE THIS TABLE WANTS TO BE IN A DISCUSSION OF PREDICATE FUNCTIONS; PRESENT LOCATION IS OK I GUESS
@c - REFORMAT THIS TABLE USING TEXINFO MARKUP (MAYBE)
@example
Opera@,{c}@~ao             S@'imbolo      Tipo
 
menor que            <           infixo relacional
menor que            <=
  ou igual a                     infixo relacional
igualdade            =
  (sint@'atica)                    infixo relacional
nega@,{c}@~ao de =         #           infixo relacional
igualdade (valor)    equal       fun@,{c}@~ao relacional
nega@,{c}@~ao de           notequal
  igualdade                      fun@,{c}@~ao relacional
maior que            >=
  ou igual a                     infixo relacional
maior que            >           infixo relacional
e                    and         infixo l@'ogico
ou                   or          infixo l@'ogico
n@~ao                  not         prefixo l@'ogico
@end example

@end deffn

@c NEEDS CLARIFICATION
@c THIS ITEM IS IMPORTANT
@deffn {Fun@,{c}@~ao} map (@var{f}, @var{expr_1}, ..., @var{expr_n})
Retorna uma express@~ao cujo operador principal
@'e o mesmo que o das express@~oes
@var{expr_1}, ..., @var{expr_n} mas cujas subpartes s@~ao os resultados da
aplica@,{c}@~ao de @var{f} nas correspondentes subpartes das express@~oes.  @var{f} @'e ainda
o nome de uma fun@,{c}@~ao de @math{n} argumentos
ou @'e uma forma @code{lambda} de @math{n} argumentos.

@code{maperror} - se @code{false} far@'a com que todas as fun@,{c}@~oes mapeadas
(1) parem quando elas terminarem retornando a menor expi se n@~ao forem todas as
expi do mesmo comprimento e (2) aplique fn a [exp1, exp2,...]
se expi n@~ao forem todas do mesmo tipo de objeto.  Se @code{maperror} for @code{true}
ent@~ao uma mensagem de erro ser@'a dada nas duas inst@^ancias acima.

Um dos usos dessa fun@,{c}@~ao @'e para mapear (@code{map}) uma fun@,{c}@~ao (e.g. @code{partfrac})
sobre cada termo de uma express@~ao muito larga onde isso ordin@'ariamente n@~ao poderia
ser poss@'ivel usar a fun@,{c}@~ao sobre a express@~ao inteira devido a uma
exaust@~ao de espa@,{c}o da lista de armazenamento no decorrer da computa@,{c}@~ao.

@c IN THESE EXAMPLES, SPELL OUT WHAT IS THE MAIN OPERATOR 
@c AND SHOW HOW THE RESULT FOLLOWS FROM THE DESCRIPTION STATED IN THE FIRST PARAGRAPH
@example
(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map("=",[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


@end example
@end deffn

@deffn {Fun@,{c}@~ao} mapatom (@var{expr})
Retorna @code{true} se e somente se @var{expr} for tratada pelas rotinas de
mapeamento como um @'atomo.  "Mapatoms" s@~ao @'atomos, n@'umeros
(inclu@'indo n@'umeros racioanais), e vari@'aveis subscritas.
@c WHAT ARE "THE MAPPING ROUTINES", AND WHY DO THEY HAVE A SPECIALIZED NOTION OF ATOMS ??

@end deffn

@c NEEDS CLARIFICATION
@defvr {Vari@'avel de op@,{c}@~ao} maperror
Valor padr@~ao: @code{true}

Quando @code{maperror} @'e @code{false}, faz com que todas as fun@,{c}@~oes mapeadas, por exemplo

@example
map (f, expr_1, expr_2, ...))
@end example

(1) parem quando elas terminarem
retornando a menor expi se n@~ao forem todas as expi do mesmo
comprimento e (2) aplique @code{f} a @code{[expr_1, expr_2, ...]} se @code{expr_i} n@~ao forem todas
do mesmo tipo de objeto.

Se @code{maperror} for @code{true} ent@~ao uma ,mensagem de erro
@'e mostrada nas duas inst@^ancias acima.

@end defvr

@c NEEDS CLARIFICATION
@deffn {Fun@,{c}@~ao} maplist (@var{f}, @var{expr_1}, ..., @var{expr_n})
Retorna uma lista de aplica@,{c}@~oes de @var{f}
em todas as partes das express@~oes @var{expr_1}, ..., @var{expr_n}.
@var{f} @'e o nome de uma fun@,{c}@~ao, ou uma express@~ao lambda.

@code{maplist} difere de @code{map (@var{f}, @var{expr_1}, ..., @var{expr_n})}
que retorna uma express@~ao com o mesmo operador principal que @var{expr_i} tem
(exceto para simplifica@,{c}@~oes  e o caso onde @code{map} faz um @code{apply}).

@end deffn

@c NEEDS CLARIFICATION
@defvr {Vari@'avel de op@,{c}@~ao} prederror
Valor padr@~ao: @code{true}

Quando @code{prederror} for @code{true}, uma mensagem de erro @'e mostrada
sempre que o predicado de uma declara@,{c}@~ao @code{if} ou uma fun@,{c}@~ao @code{is} falha em
avaliar ou para @code{true} ou para  @code{false}.

Se @code{false}, @code{unknown} @'e retornado
no lugar nesse caso.  O modo @code{prederror: false} n@~ao @'e suportado no
c@'odigo traduzido;
todavia, @code{maybe} @'e suportado no c@'odigo traduzido.

Veja tamb@'em @code{is} e @code{maybe}.

@end defvr

@deffn {Fun@,{c}@~ao} return (valor)
Pode ser usada para sair explicitamente de um bloco, levando
seu argumento.  Veja @code{block} para mais informa@,{c}@~ao.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Fun@,{c}@~ao} scanmap (@var{f}, @var{expr})
@deffnx {Fun@,{c}@~ao} scanmap (@var{f}, @var{expr}, bottomup)
Recursivamente aplica @var{f} a @var{expr}, de cima
para baixo.  Isso @'e muito @'util quando uma fatora@,{c}@~ao completa @'e
desejada, por exemplo:

@example
(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
@end example

Note o caminho atrav@'es do qual @code{scanmap} aplica a dada fun@,{c}@~ao @code{factor} para as
subexpress@~oes constituintes de @var{expr}; se outra forma de @var{expr} @'e apresentada
para @code{scanmap} ent@~ao o resultado pode ser diferente.  Dessa forma, @code{%o2} n@~ao @'e
recuperada quando @code{scanmap} @'e aplicada para a forma expandida de exp:

@example
(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
@end example

Aqui est@'a um outro exemplo do caminho no qual @code{scanmap} aplica
recursivamente uma fun@,{c}@~ao dada para todas as subexpress@~oes, incluindo expoentes:

@example
(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
@end example

@code{scanmap (@var{f}, @var{expr}, bottomup)} aplica @var{f} a @var{expr} de
baixo para cima.  E.g., para @code{f} indefinida,

@example
scanmap(f,a*x+b) ->
   f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
    -> f(f(a)*f(x))+f(b) ->
     f(f(f(a)*f(x))+f(b))
@end example

Nesse caso, voc@^e pega a mesma resposta em ambos os
caminhos.

@end deffn

@deffn {Fun@,{c}@~ao} throw (@var{expr})
Avalia @var{expr} e descarta o valor retornado para o mais recente
@code{catch}.  @code{throw} @'e usada com @code{catch} como um mecanismo de retorno
n@~ao local.

@end deffn

@deffn {Fun@,{c}@~ao} outermap (@var{f}, @var{a_1}, ..., @var{a_n})
Aplica a fun@,{c}@~ao @var{f} para cada um dos elementos do produto externo
@var{a_1} vezes @var{a_2} ... vezes @var{a_n}.

@var{f} @'e para ser o nome de uma fun@,{c}@~ao de @math{n} argumentos
ou uma express@~ao lambda de @math{n} argumentos.
Os argumentos @var{a_1}, ..., @var{a_n} podem ser listas ou n@~ao listas.
Argumentos listas podem ter diferentes comprimentos.
Argumentos outros que n@~ao listas s@~ao tratados como listas de comprimento 1 para o prop@'osito de constru@,{c}@~ao do
produto externo.

O resultado da aplica@,{c}@~ao de @var{f} para o produto externo @'e organizado como uma lista aninhada.
A intensidade do aninhamento @'e igual ao n@'umero de argumentos listas
(argumentos outros que n@~ao listas n@~ao contribuem com um n@'ivel de aninhamento).
Uma lista de intensidade de aninhamento @math{k} tem o mesmo comprimento que o @math{k}'@'esimo argumento da lista.

@code{outermap} avalia seus argumentos.

Veja tamb@'em @code{map}, @code{maplist}, e @code{apply}.
@c CROSS REF OTHER FUNCTIONS HERE ??

Exemplos:
@c GENERATED FROM:
@c f (x, y) := x - y$
@c outermap (f, [2, 3, 5], [a, b, c, d]);
@c outermap (lambda ([x, y], y/x), [55, 99], [Z, W]);
@c g: lambda ([x, y, z], x + y*z)$
@c outermap (g, [a, b, c], %pi, [11, 17]);
@c flatten (%);

@example
(%i1) f (x, y) := x - y$
(%i2) outermap (f, [2, 3, 5], [a, b, c, d]);
(%o2) [[2 - a, 2 - b, 2 - c, 2 - d], 
      [3 - a, 3 - b, 3 - c, 3 - d], [5 - a, 5 - b, 5 - c, 5 - d]]
(%i3) outermap (lambda ([x, y], y/x), [55, 99], [Z, W]);
                        Z   W     Z   W
(%o3)                 [[--, --], [--, --]]
                        55  55    99  99
(%i4) g: lambda ([x, y, z], x + y*z)$
(%i5) outermap (g, [a, b, c], %pi, [11, 17]);
(%o5) [[a + 11 %pi, a + 17 %pi], [b + 11 %pi, b + 17 %pi], 
                                        [c + 11 %pi, c + 17 %pi]]
(%i6) flatten (%);
(%o6) [a + 11 %pi, a + 17 %pi, b + 11 %pi, b + 17 %pi, 
                                          c + 11 %pi, c + 17 %pi]
@end example

@end deffn
