@c /Equations.texi/1.17/Wed Apr 27 14:39:39 2005/-ko//
@c end concepts Equations
@menu
* Definitions for Equations::   
@end menu

@node Definitions for Equations,  , Equations, Equations
@section Definitions for Equations

@c NEED A DESCRIPTION OF %rnum AS WELL
@defvr {Vari@'avel} %rnum_list
Valor padr@~ao: @code{[]}

@code{%rnum_list} @'e a lista de vari@'aveis introduzidas em solu@,{c}@~oes
por @code{algsys}.
@code{%r} vari@'aveis S@~ao adicionadas a @code{%rnum_list} na ordem em que
forem criadas.
Isso @'e conveniente para fazer substitui@,{c}@~oes dentro da
solu@,{c}@~ao mais tarde.
@c WHAT DOES THIS STATEMENT MEAN ??
@'E recomendado usar essa lista em lugar de
fazer @code{concat ('%r, j)}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'avel} algexact
Valor padr@~ao: @code{false}

@code{algexact} afeta o comportamento de @code{algsys} como segue:

Se @code{algexact} @'e @code{true},
@code{algsys} sempre chama @code{solve} e ent@~ao usa @code{realroots}
sobre falhas de @code{solve}.

Se @code{algexact} @'e @code{false}, @code{solve} @'e chamada somente se
o eliminante n@~ao for de uma vari@'avel, ou se for uma quadr@'atica ou uma
biquadrada.

Dessa forma @code{algexact: true} n@~ao garante solu@,{c}@~oes
exatas, apenas que @code{algsys} tentar@'a primeiro pegar
solu@,{c}@~oes exatas, e somente retorna aproxima@,{c}@~oes quando tudo mais falha.

@c ABOVE DESCRIPTION NOT TOO CLEAR -- MAYBE EXAMPLES WILL HELP
@end defvr

@deffn {Fun@,{c}@~ao} algsys ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
@deffnx {Fun@,{c}@~ao} algsys ([@var{eqn_1}, ..., @var{eqn_m}], [@var{x_1}, ..., @var{x_n}])
Resolve polin@^omios simult@^aneos @var{expr_1}, ..., @var{expr_m}
ou equa@,{c}@~oes polin@^omiais @var{eqn_1}, ..., @var{eqn_m}
para as vari@'aveis @var{x_1}, ..., @var{x_n}.
Uma express@~ao @var{expr} @'e equivalente a uma equa@,{c}@~ao @code{@var{expr} = 0}.
Pode existir mais equa@,{c}@~oes que vari@'aveis ou vice-versa.

@code{algsys} retorna uma lista de solu@,{c}@~oes,
com cada solu@,{c}@~ao dada com uma lista de valores de estado das equa@,{c}@~oes
das vari@'aveis @var{x_1}, ..., @var{x_n} que satisfazem o sistema de equa@,{c}@~oes.
Se @code{algsys} n@~ao pode achar uma solu@,{c}@~ao, uma lista vazia @code{[]} @'e retornada.

Os s@'imbolos @code{%r1}, @code{%r2}, ...,
s@~ao introduzidos tantos quantos forem necess@'arios para representar par@^ametros arbitr@'arios na solu@,{c}@~ao;
essas vari@'aveis s@~ao tamb@'em anexadas @`a lista @code{%rnum_list}.

O m@'etodo usado @'e o seguinte:

(1) Primeiro as equa@,{c}@~oes s@~ao fatoradas e quebradas em subsistemas.

(2) Para cada subsistema @var{S_i}, uma equa@,{c}@~ao @var{E} e uma vari@'avel @var{x} s@~ao
selecionados.
A vari@'avel @'e escolhida para ter o menor grau n@~ao zero.
Ent@~ao a resultante de @var{E} e @var{E_j} em rela@,{c}@~ao a @var{x} @'e calculada para cada um das
equa@,{c}@~oes restantes @var{E_j} nos subsistemas @var{S_i}.
Isso retorna um novo subsistema @var{S_i'} em umas poucas vari@'aveis, como @var{x} tenha sido eliminada.
O processo agora retorna ao passo (1).

(3) Eventualmente, um subsistema consistindo de uma equa@,{c}@~ao simples @'e
obtido.  Se a equa@,{c}@~ao @'e de v@'arias vari@'aveis e aproxima@,{c}@~oes na
forma de n@'umeros em ponto flutuante n@~a tenham sido introduzidas, ent@~ao @code{solve} @'e
chamada para achar uma solu@,{c}@~ao exata.

Em alguns casos, @code{solve} n@~ao est@'a habilitada a achar uma solu@,{c}@~ao,
ou se isso @e'e feito a solu@,{c}@~ao pode ser uma express@~ao express@~ao muito larga.

@c REMAINDER OF (3) IS PRETTY COMPLEX.  HOW CAN IT BE CLARIFIED ??
Se a equa@,{c}@~ao @'e de uma @'unica vari@'avel e @'e ou linear, ou quadr@'atica, ou
biquadrada, ent@~ao novamente @code{solve} @'e chamada se aproxima@,{c}@~oes n@~ao tiverem
sido introduzidas.  Se aproxima@,{c}@~oes tiverem sido introduzidas ou a
equa@,{c}@~ao n@~ao @'e de uma @'unica vari@'avel e nem t@~ao pouco linear, quadratica, ou
biquadrada, ent@~ao o comutador @code{realonly} @'e @code{true}, A fun@,{c}@~ao
@code{realroots} @'e chamada para achar o valor real das solu@,{c}@~oes.  Se
@code{realonly} @'e @code{false}, ent@~ao @code{allroots} @'e chamada a qual procura por
solu@,{c}@~oes reais e complexas.

Se @code{algsys} produz uma solu@,{c}@~ao que tem
poucos digitos significativos que o requerido, o usu@'ario pode escolher o valor
de @code{algepsilon} para um valor maior.

Se @code{algexact} @'e escolhido para
@code{true}, @code{solve} ser@'a sempre chamada.
@c algepsilon IS IN Floating.texi -- MAY WANT TO BRING IT INTO THIS FILE

(4) Finalmente, as solu@,{c}@~oes obtidas no passo (3) s@~ao substitu@'idas dentro
dos n@'iveis pr@'evios e o processo de solu@,{c}@~ao retorna para (1).
@c "PREVIOUS LEVELS" -- WHAT ARE THOSE ??

Quando @code{algsys} encontrar uma equa@,{c}@~ao de v@'arias vari@'aveis que cont@'em
aproxima@,{c}@~oes em ponto flutuante (usualmente devido a suas falhas em achar
solu@,{c}@~oes exatas por um est@'agio mais f@'acil), ent@~ao n@~ao tentar@'a
aplicar m@'etodos exatos para tais equa@,{c}@~oes e em lugar disso imprime a mensagem:
"@code{algsys} cannot solve - system too complicated."

Intera@,{c}@~oes com @code{radcan} podem produzir express@~oes largas ou
complicadas.
Naquele caso, pode ser poss@'ivel isolar partes do resultado
com @code{pickapart} ou @code{reveal}.

Ocasionalmente, @code{radcan} pode introduzir uma unidade imagin@'aria
@code{%i} dentro de uma solu@,{c}@~ao que @'e atualmente avaliada como real.

Exemplos:
@c FOLLOWING EXAMPLES GENERATED FROM THIS CODE, ADAPTED FROM example(algsys)
@c e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
@c e2: a2 - a1; 
@c e3: a1*(-y - x^2 + 1); 
@c e4: a2*(y - (x - 1)^2);
@c algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
@c e1: x^2 - y^2;
@c e2: -1 - y + 2*y^2 - x + x^2;
@c algsys ([e1, e2], [x, y]);

@example
(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
@end example

@end deffn

@deffn {Fun@,{c}@~ao} allroots (@var{expr})
@deffnx {Fun@,{c}@~ao} allroots (@var{eqn})
Calcula aproxima@,{c}@~oes num@'ericas de ra@'izes reais e complexas do
polin@^omio @var{expr} ou equa@,{c}@~ao polin@^omial @var{eqn} de uma vari@'avel.

@c polyfactor IS NOT OTHERWISE DOCUMENTED
O sinalizador @code{polyfactor} quando @code{true} faz com que
@code{allroots} fatore o polin@^omio sobre os n@'umeros reais se o
polin@^omio for real, ou sobre os n@'umeros complexos, se o polin@^omio for
complexo.

@code{allroots} pode retornar resultados imprecisos no caso de multiplas ra@'izes.
Se o polin@^omio for real, @code{allroots (%i*@var{p})}) pode retornar
aproxima@,{c}@~oes mais precisas que @code{allroots (@var{p})},
como @code{allroots} invoca um algor@'itmo diferente naquele caso.

@code{allroots} rejeita n@~ao-polin@^omios.  Isso requer que o numerador
ap@'os a classifica@,{c}@~ao (@code{rat}'ing) poder@'a ser um polin@^omio, e isso requer que o
denominador seja quando muito um n@'umero complexo.  Com um resultado disso @code{allroots}
ir@'a sempre retornar uma express@~ao equivalente (mas fatorada), se
@code{polyfactor} for @code{true}.

Para polin@^omios complexos um algor@'itmo por Jenkins and Traub @'e
usado (Algorithm 419, @i{Comm.  ACM}, vol.  15, (1972), p.  97).
Para polin@^omios reais o algor@'itmo usado @'e devido a Jenkins (Algorithm 493, @i{ACM TOMS},
vol.  1, (1975), p.178).

Exemplos:
@c EXAMPLES GENERATED BY THESE INPUTS:
@c eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
@c soln: allroots (eqn);
@c for e in soln
@c         do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
@c polyfactor: true$
@c allroots (eqn);

@example
(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
@end example

@end deffn

@defvr {Vari@'avel} backsubst
Valor padr@~ao: @code{true}

@c WHAT IS THE CONTEXT HERE ?? (TO WHICH OTHER FUNCTION DOES THIS APPLY ??)
Quando @code{backsubst} @'e @code{false}, evita substitui@,{c}@~oes
em express@~oes anteriores ap@'os as equa@,{c}@~oes terem sido triangularizadas.  Isso pode
ser de grande ajuda em problemas muito grandes onde substitui@,{c}@~ao em express@~oes anteriores pode vir a causar
a gera@,{c}@~ao de express@~oes extremamente largas.

@end defvr

@defvr {Vari@'avel} breakup
Valor padr@~ao: @code{true}

Quando @code{breakup} @'e @code{true}, @code{solve} expressa solu@,{c}@~oes
de equa@,{c}@~oes c@'ubicas e qu@'articas em termos de subexpress@~oes comuns,
que s@~ao atribu@'idas a r@'otulos de express@~oes intermedi@'arias (@code{%t1}, @code{%t2}, etc.).
De outra forma, subexpress@~oes comuns n@~ao s@~ao identificadas.

@code{breakup: true} tem efeito somente quando @code{programmode} @'e @code{false}.

Exemplos:

@example
(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
@end example

@end defvr

@deffn {Fun@,{c}@~ao} dimension (@var{eqn})
@deffnx {Fun@,{c}@~ao} dimension (@var{eqn_1}, ..., @var{eqn_n})
@code{dimen} @'e um pacote de an@'alise dimensional.
@code{load ("dimen")} chama esse pacote.
@code{demo ("dimen")} mostra uma cura demostra@,{c}@~ao.
@c I GUESS THIS SHOULD BE EXPANDED TO COVER EACH FUNCTION IN THE PACKAGE

@end deffn

@defvr {Vari@'avel} dispflag
Valor padr@~ao: @code{true}

@c WHAT DOES THIS MEAN ??
Se escolhida para @code{false} dentro de um @code{block} inibir@'a
a visualiza@,{c}@~ao da sa@'ida gerada pelas fun@,{c}@~oes solve chamadas de
dentro de @code{block}.  Terminando @code{block} com um sinal de dolar, $, escolhe
@code{dispflag} para @code{false}.

@end defvr

@c THIS COULD BENEFIT FROM REPHRASING
@deffn {Fun@,{c}@~ao} funcsolve (@var{eqn}, @var{g}(@var{t}))
Retorna @code{[@var{g}(@var{t}) = ...]}  ou @code{[]}, dependendo de existir
ou n@~ao uma fun@,{c}@~ao racional @code{@var{g}(@var{t})} satisfazendo @var{eqn},
que deve ser de primeira ordem, polin@^omio linear em (para esse caso) 
@code{@var{g}(@var{t})} and @code{@var{g}(@var{t}+1)}

@example
(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Equa@,{c}@~oes dependentes eliminadas:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
@end example

Aten@,{c}@~ao: essa @'e uma implementa@,{c}@~ao muito rudimentar -- muitas verifica@,{c}@~oes de seguran@,{c}a
e obviamente generaliza@,{c}@~oes est@~ao aus@^entes.

@end deffn

@defvr {Vari@'avel} globalsolve
Valor padr@~ao: @code{false}

Quando @code{globalsolve} @'e @code{true}, a vari@'aveis resolvidas
s@~ao atribu@'idos os valores da solu@,{c}@~ao achados por @code{solve}.
@c DOES ANY OTHER FUNCTION RESPECT globalsolve ??

Exemplos:

@example
(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
@end example

@end defvr

@c THIS DESCRIPTION NEEDS WORK AND EXAMPLES
@c MERGE IN TEXT FROM share/integequations/inteqn.usg
@c AND EXAMPLES FROM .../intexs.mac
@deffn {Fun@,{c}@~ao} ieqn (@var{ie}, @var{unk}, @var{tech}, @var{n}, @var{guess})
@code{inteqn} @'e um pacote para resolver equa@,{c}@~oes integrais.
@code{load ("inteqn")} carrega esse pacote.

@var{ie} @'e a equa@,{c}@~ao integral; @var{unk} @'e a fun@,{c}@~ao desconhecida; @var{tech} @'e a
t@'ecnica a ser tentada nesses dados acima (@var{tech} = @code{first} significa: tente
a primeira t@'ecnica que achar uma solu@,{c}@~ao; @var{tech} = @code{all} significa: tente todas a
t@'ecnicas aplic@'aveis); @var{n} @'e o n@'umero m@'aximo de termos a serem usados de
@code{taylor}, @code{neumann}, @code{firstkindseries}, ou @code{fredseries} (isso @'e tamb@'em o
n@'umero m@'aximo de ciclos de recurss@~ao para o m@'etodo de diferencia@,{c}@~ao); @var{guess} @'e
o inicial suposto para @code{neumann} ou @code{firstkindseries}.

Valores padr@~ao do segundo at@'e o quinto par@^ametro s@~ao:

@var{unk}: @code{@var{p}(@var{x})}, onde @var{p} @'e a primeira fun@,{c}@~ao encontrada em um integrando
que @'e desconhecida para Maxima e @var{x} @'e a vari@'avel que ocorre como um
argumento para a primeira ocorr@^encia de @var{p} achada fora de uma integral no
caso de equa@,{c}@~oes @code{secondkind} , ou @'e somente outra vari@'avel
ao lado da vari@'avel de integra@,{c}@~ao em equa@,{c}@~oes @code{firstkind}.  Se uma
tentativa de procurar por @var{x} falha, o usu@'ario ser@'a perguntado para suprir a
vari@'avel independente.

tech: @code{first}

n: 1

guess: @code{none} o que far@'a com que @code{neumann} e @code{firstkindseries} use
@code{@var{f}(@var{x})} como uma suposi@,{c}@~ao inicial.

@end deffn

@defvr {Vari@'avel} ieqnprint
Valor padr@~ao: @code{true}

@code{ieqnprint} governa o comportamento do resultado
retornado pelo comando @code{ieqn}.  Quando @code{ieqnprint} @'e
@code{false}, as listas retornadas pela fun@,{c}@~ao @code{ieqn} s@~ao da forma

   [@var{solu@,{c}@~ao}, @var{tecnica usada}, @var{nterms}, @var{sinalizador}]

onde @var{sinalizador} @'e retirado se a solu@,{c}@~ao for exata.

De outra forma, isso @'e a
palavra @code{approximate} ou @code{incomplete} correspondendo @`a forma inexata ou
forma aberta de solu@,{c}@~ao, respectivamente.  Se um m@'etodo de s@'erie foi usado,
@var{nterms} fornece o n@'umero de termos usados (que poder@'a ser menor que os n
dados para @code{ieqn} se ocorrer um erro evita a gera@,{c}@~ao de termos adicionais).

@end defvr

@deffn {Fun@,{c}@~ao} lhs (@var{eqn})
Retorna o lado esquerdo da equa@,{c}@~ao @var{eqn}.

Se o argumento n@~ao for uma equa@,{c}@~ao, @code{lhs} retorna o argumento.

Veja tamb@'em @code{rhs}.

Exemplo:

@example
(%i1) e: x^2 + y^2 = z^2;
                           2    2    2
(%o1)                     y  + x  = z
(%i2) lhs (e);
                              2    2
(%o2)                        y  + x
(%i3) rhs (e);
                                2
(%o3)                          z
@end example

@end deffn

@c REVISIT -- THERE'S PROBABLY MORE TO SAY HERE
@deffn {Fun@,{c}@~ao} linsolve ([@var{expr_1}, ..., @var{expr_m}], [@var{x_1}, ..., @var{x_n}])
Resolve a lista de
equa@,{c}@~oes lineares simult@^aneas para a lista de vari@'aveis.  As express@~oes
devem ser cada uma polin@^omios nas vari@'aveis e podem ser equa@,{c}@~oes.

Quando @code{globalsolve} @'e @code{true} ent@~ao vari@'aveis que foram resolvidas
ser@~ao escolhidas para a solu@,{c}@~ao do conjunto de equa@,{c}@~oes simult@^aneas.

Quando @code{backsubst} @'e @code{false}, @code{linsolve}
n@~ao realiza substitui@,{c}@~ao em equa@,{c}@~oes anteriores ap@'os
as equa@,{c}@~oes terem sido triangularizadas.  Isso pode ser necess@'ario em problemas
muito grandes onde substitui@,{c}@~ao em equa@,{c}@~oes anteriores poder@'a causar a gera@,{c}@~ao de
express@~oes extremamente largas.

Quando @code{linsolve_params} @'e @code{true},
@code{linsolve} tamb@'em gera s@'imbolos @code{%r}
usados para representar par@^ametros arbitr@'arios descritos no manual sob
@code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@,{c}@~oes com algumas vari@'aveis expressas em termos de outras.

@example
(%i1) e1: x + z = y$
(%i2) e2: 2*a*x - y = 2*a^2$
(%i3) e3: y - 2*z = 2$
(%i4) linsolve ([e1, e2, e3], [x, y, z]);
(%o4)            [x = a + 1, y = 2 a, z = a - 1]
@end example

@end deffn

@c DO ANY FUNCTIONS OTHER THAN linsolve RESPECT linsolvewarn ??
@defvr {Vari@'avel} linsolvewarn
Valor padr@~ao: @code{true}

Quando @code{linsolvewarn} @'e @code{true},
@code{linsolve} imprime uma mensagem "Dependent equa@,{c}@~oes eliminated".

@end defvr

@defvr {Vari@'avel} linsolve_params
Valor padr@~ao: @code{true}

Quando @code{linsolve_params} @'e @code{true}, @code{linsolve} tamb@'em gera
os s@'imbolos @code{%r} usados para representar par@^ametros arbitr@'arios descritos no
manual sob @code{algsys}.
De outra forma, @code{linsolve} resolve um menor-determinado sistema de
equa@,{c}@~oes com algumas vari@'aveis expressas em termos e outras.

@end defvr

@defvr {Vari@'avel} multiplicities
Valor padr@~ao: @code{not_set_yet}

@code{multiplicities} @'e escolhida para uma lista de
multiplicidades das solu@,{c}@~oes individuais retornadas por @code{solve} ou
@code{realroots}.
@c NEED AN EXAMPLE HERE

@end defvr

@deffn {Fun@,{c}@~ao} nroots (@var{p}, @var{low}, @var{high})
Retorna o n@'umero de ra@'izes reais do polin@^omio 
real de uma @'unica vari@'avel @var{p} no intervalo semi-aberto
@code{(@var{low}, @var{high}]}.
Uma extremidade do intervalo podem ser @code{minf} ou @code{inf}.
infinito e mais infinito.

@code{nroots} usa o m@'etodo das sequ@"u@^encias de Sturm.

@example
(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
@end example

@end deffn

@c NEEDS WORK
@deffn {Fun@,{c}@~ao} nthroot (@var{p}, @var{n})
Onde p @'e um polin@^omio com coeficientes inteiros e
n @'e um inteiro positivo retorna q, um polin@^omio sobre os inteiros, tal
que q^n=p ou imprime uma mensagem de erro indicando que p n@~ao @'e uma pot@^encia n-@'esima
perfeita.  Essa rotina @'e mais r@'apida que @code{factor} ou mesmo @code{sqfr}.

@end deffn

@defvr {Vari@'avel} programmode
Valor padr@~ao: @code{true}

Quando @code{programmode} @'e @code{true},
@code{solve}, @code{realroots}, @code{allroots}, e @code{linsolve}
retornam solu@,{c}@~oes como elementos em uma lista.
@c WHAT DOES BACKSUBSTITUTION HAVE TO DO WITH RETURN VALUES ??
(Exceto quando @code{backsubst} @'e escolhido para @code{false}, nesse caso
@code{programmode: false} @'e assumido.)

Quando @code{programmode} @'e @code{false}, @code{solve}, etc.
cria r@'otulos de express@~oes intermedi@'arias
@code{%t1}, @code{t2}, etc., e atribui as solu@,{c}@~oes para eles.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} realonly
Valor padr@~ao: @code{false}

Quando @code{realonly} @'e @code{true}, @code{algsys} retorna somente
aquelas solu@,{c}@~oes que est@~ao livres de @code{%i}.

@end defvr

@c NEEDS WORK
@deffn {Fun@,{c}@~ao} realroots (@var{poly}, @var{bound})
Acha todas as ra@'izes reais de um polin@^omio tamb@'em real de
uma @'unica vari@'avel poly dentro de uma toler@^ancia de limite que, se menor
que 1, faz com que todas as ra@'izes da integral sejam achadas exatamente.  O par@^ametro
limite pode ser arbitrariamente pequeno com o objetivo de encontrar qualquer precis@~ao
desejada.  O primeiro argumento pode tamb@'em ser uma equa@,{c}@~ao.  @code{realroots} escolhe
@code{multiplicities}, @'util em caso de multiplas ra@'izes.  @code{realroots (@var{p})} @'e
equivalente a @code{realroots (@var{p}, rootsepsilon)}.  @code{rootsepsilon} @'e um
n@'umero real usado para estabelecer um intervalo de confid@^encia para as ra@@'izes.
Fa@,{c}a @code{example (realroots)} para um exemplo.

@end deffn

@deffn {Fun@,{c}@~ao} rhs (@var{eqn})
Retorna o lado direito da equa@,{c}@~ao @var{eqn}.

Se o argumento n@~ao @'e uma equa@,{c}@~ao, @code{rhs} retorna @code{0}.

Veja tamb@'em @code{lhs}.

Exemplo:

@example
(%i1) e: x^2 + y^2 = z^2;
                           2    2    2
(%o1)                     y  + x  = z
(%i2) lhs (e);
                              2    2
(%o2)                        y  + x
(%i3) rhs (e);
                                2
(%o3)                          z
@end example

@end deffn

@defvr {Vari@'avel} rootsconmode
Valor padr@~ao: @code{true}

@code{rootsconmode} governa o comportamento do comando
@code{rootscontract}.  Veja @code{rootscontract} para detalhes.

@end defvr

@c NEEDS WORK
@deffn {Fun@,{c}@~ao} rootscontract (@var{expr})
Converte produtos de ra@'izes em ra@'izes de produtos.
Por exemplo,
@code{rootscontract (sqrt(x)*y^(3/2))} retorna @code{sqrt(x*y^3)}.

Quando @code{radexpand} @'e @code{true} e @code{domain} @'e @code{real},
@code{rootscontract} converte @code{abs} em @code{sqrt}, e.g.,
@code{rootscontract (abs(x)*sqrt(y))} retorna @code{sqrt(x^2*y)}.

Existe uma op@,{c}@~ao @code{rootsconmode}
afetando @code{rootscontract} como segue:

@example
Problem            Value of        Result of applying
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
@end example

Quando @code{rootsconmode} @'e @code{false}, @code{rootscontract} contrai somente como rela@,{c}@~ao a expoentes
de n@'umero racional cujos denominadores s@~ao os mesmos.  A chave para os exemplos
@code{rootsconmode: true} @'e simplesmente que 2 divides 4 mas n@~ao 
divide 3.  @code{rootsconmode: all} envolve pegar o menor multiplo comum
dos denominadores dos expoentes.

@code{rootscontract} usa @code{ratsimp} em uma maneira similar a @code{logcontract}.

Exemplos:
@c FOLLOWING ADAPTED FROM example (rootscontract)
@c rootsconmode: false$
@c rootscontract (x^(1/2)*y^(3/2));
@c rootscontract (x^(1/2)*y^(1/4));
@c rootsconmode: true$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: all$
@c rootscontract (x^(1/2)*y^(1/4));
@c rootscontract (x^(1/2)*y^(1/3));
@c rootsconmode: false$
@c rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
@c                     *sqrt(sqrt(1 + x) - sqrt(x)));
@c rootsconmode: true$
@c rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));

@example
(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
@end example

@end deffn

@defvr {Vari@'avel} rootsepsilon
Valor padr@~ao: 1.0e-7

@code{rootsepsilon} @'e a toler@^ancia que estabelece o
intervalo de confic@^encia para as ra@'izes achadas pela fun@,{c}@~ao @code{realroots}.
@c IS IT GUARANTEED THAT |ACTUAL - ESTIMATE| < rootepsilon OR IS IT SOME OTHER NOTION ??
@c NEED EXAMPLE HERE

@end defvr

@c NEEDS WORK
@deffn {Fun@,{c}@~ao} solve (@var{expr}, @var{x})
@deffnx {Fun@,{c}@~ao} solve (@var{expr})
@deffnx {Fun@,{c}@~ao} solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])
Resolve a equa@,{c}@~ao alg@'ebrica @var{expr} para a vari@'avel
@var{x} e retorna uma lista de equa@,{c}@~oes solu@,{c}@~ao em @var{x}.  Se @var{expr} n@~ao @'e uma
equa@,{c}@~ao, a equa@,{c}@~ao @code{@var{expr} = 0} @'e assumida em seu lugar.
@var{x} pode ser uma fun@,{c}@~ao (e.g. @code{f(x)}), ou outra express@~ao n@~ao at@^omica
exceto uma adi@,{c}@~ao ou um produto.  @var{x} pode ser omitido se @var{expr} cont@'em somente uma
vari@'avel.  @var{expr} pode ser uma express@~ao racional, e pode conter
fun@,{c}@~oes trigonom@'etricas, exponenciais, etc.

O seguinte m@'etodo @'e usado:

Tome @var{E} sendo a express@~ao e @var{X} sendo a vari@'avel.  Se @var{E} @'e linear em @var{X}
ent@~ao isso @'e trivialmente resolvido para @var{X}.  De outra forma se @var{E} @'e da forma
@code{A*X^N + B} ent@~ao o resultado @'e @code{(-B/A)^1/N)} vezes as @code{N}'@'esimas ra@'izes da
unidade.

Se @var{E} n@~ao @'e linear em @var{X} ent@~ao o m@'aximo divisor comum (mdc) dos expoentes de @var{X} em @var{E} (digamos
@var{N}) @'e dividido dentro dos expoentes e a multiplicidade das ra@'izes @'e
multiplicada por @var{N}.  Ent@~ao @code{solve} @'e chamada novamente sobre o resultado.
Se @var{E} for dada em fatores ent@~ao @code{solve} @'e chamada sobre cada um dos fatores.  Finalmente
@code{solve} usar@'a as f@'ormulas quadr@'aticas, c@'ubicas, ou qu@'articas onde
necess@'ario.

No caso onde @var{E} for um polin@^omio em alguma fun@,{c}@~ao de vari@'avel a ser
resolvida, digamos @code{F(X)}, ent@~ao isso @'e primeiro resolvida para @code{F(X)} (chama o
resultado @var{C}), ent@~ao a equa@,{c}@~ao @code{F(X)=C} pode ser resolvida para @var{X} fornecendo o
inverso da fun@,{c}@~ao @var{F} que @'e conhecida.

@code{breakup} se @code{false} far@'a com que @code{solve} expresse as solu@,{c}@~oes de
equa@,{c}@~oes c@'ubicas ou qu@'articas como express@~oes simples ao inv@'es de como feito
em cima de v@'arias subexpress@~oes comuns que @'e o padr@~ao.

@code{multiplicities} - ser@'a escolhido para uma lista de multiplicidades de
solu@,{c}@~oes individuais retornadas por @code{solve}, @code{realroots}, ou @code{allroots}.
Tente @code{apropos (solve)} para os comutadores que afetam @code{solve}.  @code{describe} pode
ent@~ao ser usada sobre o nome do comutador individual se seu propr@'osito n@~ao @'e
claro.

@code{solve ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_n}])}
resolve um sistema de equa@,{c}@~oes polinomiais
(lineares ou n@~ao-lineares) simult@^aneas por chamada a @code{linsolve} ou
@code{algsys} e retorna uma lista de listas solu@,{c}@~ao nas vari@'aveis.  No
caso de @code{linsolve} essa lista conter@'a uma lista simples de
solu@,{c}@~oes.  Isso pega duas listas como argumentos.  A primeira lista
representa as equa@,{c}@~oes a serem resolvidas; a segunda lista @'e a
lista de desconhecidos a ser determinada.  Se o n@'umero total de
vari@'aveis nas equa@,{c}@~oes @'e igual ao n@'umero de equa@,{c}@~oes, a
segunda lista-argumento pode ser omitida.  Para sistemas lineares se as dadas
equa@,{c}@~oes n@~ao s@~ao compat@'iveis, a mensagem @code{inconsistent} ser@'a
mostrada (veja o comutador @code{solve_inconsistent_error} ); se n@~ao existe
solu@,{c}@~ao @'unica, ent@~ao @code{singular} ser@'a mostrado.

Exemplos:
@c FOLLOWING ADAPTED FROM example (solve)
@c solve (asin (cos (3*x))*(f(x) - 1), x);
@c ev (solve (5^f(x) = 125, f(x)), solveradcan);
@c [4*x^2 - y^2 = 12, x*y - x = 2];
@c solve (%, [x, y]);
@c solve (1 + a*x + x^3, x);
@c solve (x^3 - 1);
@c solve (x^6 - 1);
@c ev (x^6 - 1, %[1]);
@c expand (%);
@c x^2 - 1;
@c solve (%, x);
@c ev (%th(2), %[1]);

@example
(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE @'e using arc-trig functions to get a solu@,{c}@~ao.
Some solu@,{c}@~oes will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
@end example

@end deffn

@defvr {Vari@'avel} solvedecomposes
Valor padr@~ao: @code{true}

Quando @code{solvedecomposes} @'e @code{true}, @code{solve} chama
@code{polydecomp} se perguntado para resolver polin@^omios.
@c OTHERWISE WHAT HAPPENS -- CAN'T SOLVE POLYNOMIALS, OR SOME OTHER METHOD IS USED ??

@end defvr

@defvr {Vari@'avel} solveexplicit
Valor padr@~ao: @code{false}

Quando @code{solveexplicit} @'e @code{true}, inibe @code{solve} de
retornar solu@,{c}@~oes impl@'icitas, isto @'e, solu@,{c}@~oes da forma @code{F(x) = 0}
onde @code{F} @'e alguma fun@,{c}@~ao.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} solvefactors
Valor padr@~ao: @code{true}

@c WHAT IS THIS ABOUT EXACTLY ??
Quando @code{solvefactors} @'e @code{false}, @code{solve} n@~ao tenta
fatorar a express@~ao.  O @code{false} escolhido pode ser desejado em alguns casos
onde a fatora@,{c}@~ao n@~ao @'e necess@'aria.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} solvenullwarn
Valor padr@~ao: @code{true}

Quando @code{solvenullwarn} @'e @code{true}, 
@code{solve} imprime uma mensagem de alerta se chamada com ou uma lista equa@,{c}@~ao ou uma vari@'avel lista nula.
Por exemplo, @code{solve ([], [])} imprimir@'a duas mensagens de alerta e retorna @code{[]}.

@end defvr

@defvr {Vari@'avel} solveradcan
Valor padr@~ao: @code{false}

Quando @code{solveradcan} @'e @code{true}, @code{solve} chama @code{radcan}
que faz @code{solve} lento mas permitir@'a certamente que problemas
contendo exponeniais e logar@'itmos sejam resolvidos.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} solvetrigwarn
Valor padr@~ao: @code{true}

@c MAYBE THIS CAN BE CLARIFIED
Quando @code{solvetrigwarn} @'e @code{true},
@code{solve} pode imprimir uma mensagem dizendo que est@'a usando fun@,{c}@~oes
trigonom@'etricas inversas para resolver a equa@,{c}@~ao, e desse modo perdendo
solu@,{c}@~oes.
@c NEED AN EXAMPLE HERE

@end defvr

@defvr {Vari@'avel} solve_inconsistent_error
Valor padr@~ao: @code{true}

Quando @code{solve_inconsistent_error} @'e 
@code{true}, @code{solve} e
@code{linsolve} resultam em erro se as equa@,{c}@~oes a serem resolvidas s@~ao inconsistentes.

Se @code{false}, @code{solve} e @code{linsolve} retornam uma lista vazia @code{[]} 
se as equa@,{c}@~oes forem inconsistentes.

Exemplo:

@example
(%i1) solve_inconsistent_error: true$
(%i2) solve ([a + b = 1, a + b = 2], [a, b]);
Inconsistent equa@,{c}@~oes:  (2)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i3) solve_inconsistent_error: false$
(%i4) solve ([a + b = 1, a + b = 2], [a, b]);
(%o4)                          []
@end example

@end defvr
