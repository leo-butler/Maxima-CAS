@c version 1.26
@menu
* Introducci@'on a las Funciones Especiales::  
* specint::                     
* Definiciones para las Funciones Especiales::  
@end menu

@node Introducci@'on a las Funciones Especiales, specint, Funciones Especiales, Funciones Especiales
@section Introducci@'on a las Funciones Especiales


@node specint, Definiciones para las Funciones Especiales, Introducci@'on a las Funciones Especiales, Funciones Especiales
@section specint


El paquete @code{hypgeo} permite calcular transformadas de Laplace de funciones especiales, mientras que @code{hyp} es otro paquete destinado al c@'alculo de funciones hipergeom@'etricas generalizadas.

Por otro lado, @code{specint} tiene por objeto calcular la integral definida (en el intervalo que va desde cero hasta infinito) de expresiones que contengan funciones especiales. Cuando el integrando contenga el factor @code{exp (-s t)}, 
el resultado no es otro que la transformada de Laplace.

La sintaxis es la siguiente:

@example
specint (exp (-s*@var{t}) * @var{expr}, @var{t});
@end example

donde @var{t} es la variable de integraci@'on y @var{expr} es una expresi@'on que contiene funciones especiales.

Si @code{specint} no puede calcular la integral, la respuesta que se obtiene puede contener s@'{@dotless{i}}mbolos de Lisp, entre los que se incluyen 
@code{other-defint-to-follow-negtest},
@code{other-lt-exponential-to-follow},
@code{product-of-y-with-nofract-indices}, etc.; este es un fallo conocido del programa. 

A continuaci@'on se especifican las notaciones correspondientes a las funciones especiales:

@example
bessel_j (index, expr)    Funci@'on de Bessel de primera especie
bessel_y (index, expr)    Funci@'on de Bessel de segunda especie
bessel_i (index, expr)    Funci@'on de Bessel modificada de primera especie
bessel_k (index, expr)    Funci@'on de Bessel modificada de segunda especie
%he[n] (z)                Polinomio de Hermite (Ojo: @code{he}, no @code{h}. Ver A&S 22.5.18)
%p[u,v] (z)               Funci@'on de Legendre de primera especie
%q[u,v] (z)               Funci@'on de Legendre de segunda especie
hstruve[n] (z)            Funci@'on H de Struve
lstruve[n] (z)            Funci@'on L de Struve
%f[p,q] ([], [], expr)    Funci@'on hipergeom@'etrica generalizada
gamma()                   Funci@'on Gamma
gammagreek(a,z)           Funci@'on Gamma incompleta
gammaincomplete(a,z)      Extremo de la funci@'on Gamma incompleta
@c IS slommel THE "LOMMEL" FUNCTION ?? NOT OTHERWISE MENTIONED IN TEXINFO FILES
slommel
%m[u,k] (z)               Funci@'on de Whittaker de primera especie
%w[u,k] (z)               Funci@'on de Whittaker de segunda especie
erfc (z)                  Complemento de la funci@'on de error, erf
ei (z)                    Integral exponencial (?)
kelliptic (z)             Integral el@'{@dotless{i}}ptica completa de primera especie (K)
%d [n] (z)                Funci@'on cil@'{@dotless{i}}ndrica parab@'olica
@end example

Con la instrucci@'on @code{demo ("hypgeo")} se podr@'an ver algunos ejemplos de transformadas de Laplace calculadas por @code{specint}.

Este paquete a@'un est@'a en desarrollo, por lo que algunos nombres de funciones pueden sufrir cambios.

@node Definiciones para las Funciones Especiales,  , specint, Funciones Especiales
@section Definiciones para las Funciones Especiales

@c airy IS IN THE bessel PACKAGE. ai, bi, ETC ARE IN THE airy PACKAGE.
@deffn {Funci@'on} airy (@var{x})
Funci@'on Ai de Airy.
Si el argumento @var{x} es un n@'umero, se obtiene el valor num@'erico de @code{airy (@var{x})}.
En caso contrario, se devuelve la expresi@'on no evaluada @code{airy (@var{x})}.
@c THE RETURN VALUE IS '(($AIRY SIMP) $X) -- NOT A NOUN, RIGHT? SINCE %AIRY WOULD BE A NOUN

La ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0} tiene dos soluciones linealmente independientes, llamadas @code{ai} y @code{bi}. Esta ecuaci@'on es muy utilizada para obtener aproximaciones a problemas complejos en muchos @'ambitos de la f@'{@dotless{i}}sica matem@'atica.

La instrucci@'on @code{load ("airy")} carga las funciones @code{ai}, @code{bi}, @code{dai} y @code{dbi}.

El paquete @code{airy} contiene algoritmos para calcular @code{ai} y @code{bi}, as@'{@dotless{i}} como sus derivadas @code{dai} y @code{dbi}. El resultado es un n@'umero decimal en coma flotante si el argumento es a su vez un n@'umero, en caso contrario ser@'a una expresi@'on no evaluada.

Se producir@'a un error si el argumento es lo suficientemente grande como para que los exponenciales causen un desbordamiento (@i{overflow}), o una p@'erdida de precisi@'on en el @code{sin} o en el @code{cos}. Con esto, el rango de validez es aproximadamente entre 
-2800 y 10^38 para @code{ai} y @code{dai}, y entre -2800 y 25 para @code{bi} y @code{dbi}.

Maxima reconoce las siguientes derivadas:
@itemize @bullet
@item
@code{diff (ai(x), x)} devuelve @code{dai(x)},
@item
@code{diff (dai(x), x)} devuelve @code{x ai(x)},
@item
@code{diff (bi(x), x)} devuelve @code{dbi(x)},
@item
@code{diff (dbi(x), x)} devuelve @code{x bi(x)}.
@end itemize

Los valores de las funciones se calculan a partir del desarrollo convergente de Taylor para @code{abs(@var{x}) < 3},
y de las expansiones asint@'oticas para @code{@var{x} < -3} o @code{@var{x} > 3}, seg@'un sea necesario.
Con esto se consiguen discrepancias num@'ericas despreciables en @code{@var{x} = 3} y @code{@var{x} = -3}.
Para detalles, v@'ease Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4 y Tabla 10.11.

La llamada @code{ev (taylor (ai(x), x, 0, 9), infeval)} devuelve el desarrollo de Taylor con n@'umeros decimales de la funci@'on @code{ai}. Se puede escribir una expresi@'on similar para @code{bi}.

@end deffn

@deffn {Funci@'on} airy_ai (@var{x})
Funci@'on Ai de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4. 

La ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0} tiene dos soluciones linealmente independientes, @code{y = Ai(x)} y @code{y = Bi(x)}. La derivada @code{diff (airy_ai(x), x)} es @code{airy_dai(x)}.

Si el argumento @code{x} es un n@'umero decimal real o complejo, se devolver@'a el valor num@'erico de @code{airy_ai} siempre que sea posible.

V@'eanse @code{airy_bi}, @code{airy_dai} y @code{airy_dbi}.
@end deffn

@deffn {Funci@'on} airy_dai (@var{x})
Es la derivada de la funci@'on Ai de Airy, @code{airy_ai(x)}. 

V@'ease @code{airy_ai}.
@end deffn

@deffn {Funci@'on} airy_bi (@var{x})
Es la funci@'on Bi de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4. Se trata de la segunda soluci@'on de la ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un n@'umero decimal real o complejo, se devolver@'a el valor num@'erico de @code{airy_bi} siempre que sea posible. En los otros casos, se devuelve la expresi@'on sin evaluar.

La derivada @code{diff (airy_bi(x), x)} es @code{airy_dbi(x)}.

V@'eanse @code{airy_ai} y @code{airy_dbi}.
@end deffn

@deffn {Funci@'on} airy_dbi (@var{x})
Es la derivada de la funci@'on Bi de Airy, @code{airy_bi(x)}.

V@'eanse @code{airy_ai} y @code{airy_bi}.
@end deffn

@deffn {Funci@'on} asympa
El paquete @code{asympa} contiene funciones de simplificaci@'on para realizar an@'alisis asint@'otico, incluyendo las funciones  ``big O'' y  ``little o'', de uso frecuente en el an@'alisis complejo y num@'erico.

La instrucci@'on @code{load ("asympa")} carga este paquete.

@end deffn

@deffn {Funci@'on} bessel (@var{z}, @var{a}) 
Funci@'on de Bessel de primera especie.

Ya no se recomienda su uso.  Util@'{@dotless{i}}cese @code{bessel_j (@var{z}, @var{a})} en su lugar.

@end deffn

@deffn {Funci@'on} bessel_j (@var{v}, @var{z})
Funci@'on de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_j} calcula el arreglo @code{besselarray} tal que @code{besselarray [i] = bessel_j [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_j} se define como

@ifhtml
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifhtml
@ifinfo
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn

@deffn {Funci@'on} bessel_y (@var{v}, @var{z})
Funci@'on de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_y} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_y [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_y} se define como

@ifhtml
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifhtml
@ifinfo
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifinfo

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

si @math{v} no es un entero.  En caso de que  @math{v} sea un entero @math{n}, se calcula el l@'{@dotless{i}}mite cuando @math{v} se aproxima a @math{n}.

@end deffn

@deffn {Funci@'on} bessel_i (@var{v}, @var{z})
Funci@'on modificada de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_i} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_i [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_i} se define como

@ifhtml
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifhtml
@ifinfo
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn

@deffn {Funci@'on} bessel_k (@var{v}, @var{z})
Funci@'on modificada de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_k} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_k [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_k} se define como

@ifhtml
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifhtml
@ifinfo
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifinfo

@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex

si @math{v} no es un entero.  Si @math{v} es igual al entero @math{n}, entonces se calcula el l@'{@dotless{i}}mite cuando @math{v} tiende a @math{n}.

@end deffn

@defvr {Variable optativa} besselexpand
Valor por defecto: @code{false}

Controla la expansi@'on de las funciones de Bessel cuando el orden es la mitad de un entero impar. En tal caso, las funciones de Bessel se pueden expandir en t@'erminos de otras funciones elementales.  Si @code{besselexpand} vale @code{true}, se expande la funci@'on de Bessel.

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                          2 z   sin(z)   cos(z)
(%o4)                sqrt(---) (------ - ------)
                          %pi      2       z
                                  z
@end example
@end defvr


@deffn {Funci@'on} scaled_bessel_i (@var{v}, @var{z})

Es la funci@'on de Bessel modificada de primera especie de
orden @math{v} y argumento @math{z}, es decir
@math{scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)}.
Esta funci@'on es especialmente @'util para calcular @math{bessel_i}
cuando @math{z} es grande. Sin embargo, Maxima no sabe mucho m@'as 
sobre esta funci@'on. En c@'alculos simb@'olicos, quiz@'as sea
preferible trabajar directamente con la expresi@'on 
@code{exp(-abs(z))*bessel_i(v, z)}.

@end deffn

@deffn {Funci@'on} scaled_bessel_i0 (@var{z})

Id@'entica a @code{scaled_bessel_i(0,z)}.

@end deffn

@deffn {Funci@'on} scaled_bessel_i1 (@var{z})

Id@'entica a @code{scaled_bessel_i(1,z)}.

@end deffn


@deffn {Funci@'on} beta (@var{x}, @var{y})
Funci@'on beta, definida como @code{gamma(x) gamma(y)/gamma(x + y)}.

@end deffn

@deffn {Funci@'on} gamma (@var{x})
Funci@'on gamma.

V@'ease tambi@'en @code{makegamma}.

La variable @code{gammalim} controla la simplificaci@'on de la funci@'on gamma.

La constante de Euler-Mascheroni es @code{%gamma}.

@end deffn

@defvr {Variable optativa} gammalim
Valor por defecto: 1000000

La variable @code{gammalim} controla la simplificaci@'on de la funci@'on gamma con argumentos enteros o racionales. Si el valor absoluto del argumento no es mayor que @code{gammalim}, entonces se realizar@'a la simplificaci@'on. N@'otese que la variable @code{factlim} tambi@'en controla la simplificaci@'on del resultado de @code{gamma} con argumento entero.

@end defvr

@deffn {Funci@'on} intopois (@var{a})
Convierte @var{a} en un codificado Poisson.

@end deffn

@deffn {Funci@'on} makefact (@var{expr})
Transforma las funciones @code{binomial}, @code{gamma} y @code{beta} que aparecen en @var{expr} en su notaci@'on factorial.

V@'ease tambi@'en @code{makegamma}.

@end deffn

@deffn {Funci@'on} makegamma (@var{expr})
Transforma las funciones @code{binomial}, @code{factorial} y @code{beta} que aparecen en @var{expr} en funciones @code{gamma}.

V@'ease tambi@'en @code{makefact}.

@end deffn

@deffn {Funci@'on} numfactor (@var{expr})
Devuelve el factor num@'erico que multiplica a la expresi@'on @var{expr}, la cual debe tener un @'unico t@'ermino. 

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example

@end deffn

@deffn {Funci@'on} outofpois (@var{a})
Convierte @var{a} desde codificado de Poisson a una representaci@'on general.  Si @var{a} no est@'a en forma de Poisson, @code{outofpois} hace la conversi@'on, siendo entonces el valor retornado @code{outofpois (intopois (@var{a}))}. Esta funci@'on es un simplificador can@'onico para sumas de potencias de senos y cosenos.

@end deffn

@deffn {Funci@'on} poisdiff (@var{a}, @var{b})
Deriva @var{a} con respecto a @var{b}. El argumento @var{b} debe aparecer s@'olo en los argumentos trigonom@'etricos o s@'olo en los coeficientes.

@end deffn

@deffn {Funci@'on} poisexpt (@var{a}, @var{b})
Id@'entico a @code{intopois (@var{a}^@var{b})}. El argumento @var{b} debe ser un entero positivo.

@end deffn

@c AQUI FALTA DEFINICION DE poisint

@defvr {Variable optativa} poislim
Valor por defecto: 5

La variable @code{poislim} determina el dominio de los coeficientes en los argumentos de las funciones trigonom@'etricas.  El valor por defecto 5 corresponde al intervalo [-2^(5-1)+1,2^(5-1)], o [-15,16], pero puede reasignarse para  [-2^(n-1)+1, 2^(n-1)].

@end defvr

@c AQUI FALTA DEFINICION DE poismap 

@deffn {Funci@'on} poisplus (@var{a}, @var{b})
Id@'entico a @code{intopois (a + b)}.

@end deffn

@deffn {Funci@'on} poissimp (@var{a})
Convierte @var{a} en una serie de Poisson para @var{a} en su representaci@'on general.

@end deffn

@defvr {S@'{@dotless{i}}mbolo especial} poisson
El s@'{@dotless{i}}mbolo @code{/P/} sigue a la etiqueta de las l@'{@dotless{i}}neas que contienen expresiones que son series de Poisson.

@end defvr

@deffn {Funci@'on} poissubst (@var{a}, @var{b}, @var{c})
Sustituye @var{b} por @var{a} en @var{c}, donde  @var{c} es una serie de Poisson.

(1) Si @var{b} es una de las variables @var{u}, @var{v}, @var{w}, @var{x}, @var{y} o @var{z}, entonces @var{a} debe ser una expresi@'on lineal en esas variables (por ejemplo, @code{6*u + 4*v}).

(2) Si @var{b} no es ninguna de esas variables, entonces @var{a} no puede contener tampoco a ninguna de ellas, ni senos, ni cosenos.

@c AQUI FALTA PARRAFO

@end deffn

@deffn {Funci@'on} poistimes (@var{a}, @var{b})
Id@'entico a @code{intopois (@var{a}*@var{b})}.

@end deffn

@c AQUI FALTA DEFINICION DE poistrim

@deffn {Funci@'on} printpois (@var{a})
Presenta una serie de Poisson en un formato legible.  Conjuntamente con @code{outofpois}, si es necesario convertir@'a @var{a} primero en una codificaci@'on de Poisson.

@end deffn


@deffn {Funci@'on} psi [@var{n}](@var{x})

Es la derivada de @code{log (gamma (@var{x}))} de orden @code{@var{n}+1},
de tal manera que @code{psi[0](@var{x})} es la primera derivada, 
@code{psi[1](@var{x})} la segunda derivada y as@'{@dotless{i}} 
sucesivamente.

En general, Maxima no sabe c@'omo calcular valores num@'ericos de 
@code{psi}, pero s@'{@dotless{i}} conoce el valor exacto para
algunos argumentos racionales.
Existen algunas variables globales para controlar en qu@'e rangos
racionales debe devolver @code{psi} resultados exactos, si ello es posible.
V@'eanse las descripciones de @code{maxpsiposint}, @code{maxpsinegint},
@code{maxpsifracnum} y @code{maxpsifracnum}.
En resumen, @var{x} debe alcanzar un valor entre @code{maxpsinegint} y
@code{maxpsiposint}. Si el valor absoluto de la parte fraccional de
@var{x} es racional y tiene un numerador menor que @code{maxpsifracnum}
y un denominador menor que @code{maxpsifracdenom}, la funci@'on @code{psi}
devolver@'a un valor exacto.

La funci@'on @code{bfpsi} del paquete @code{bffac} puede calcular
valores num@'ericos.

@end deffn

@defvr {Variable opcional} maxpsiposint
Valor por defecto: 20

La variable @code{maxpsiposint} guarda el mayor valor positivo para el 
que @code{psi[n](x)} intentar@'a calcular un valor exacto.

@end defvr

@defvr {Variable opcional} maxpsinegint
Valor por defecto: -10

La variable @code{maxpsinegint} guarda el menor valor negativo para el
que @code{psi[n](x)} intentar@'a calcular un valor exacto. Si
@var{x} es menor que @code{maxnegint}, @code{psi[n](@var{x})} no devolver@'a
una respuesta simplificada, aunque supiese c@'omo hacerlo.

@end defvr

@defvr {Variable opcional} maxpsifracnum
Valor por defecto: 4

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{p} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr

@defvr {Variable opcional} maxpsifracdenom
Valor por defecto: 4

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{q} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr
