@c version 1.33
@menu
* Introducci@'on a las funciones especiales::
* Funciones y variables para las funciones especiales::
@end menu

@node Introducci@'on a las funciones especiales, Funciones y variables para las funciones especiales, Funciones Especiales, Funciones Especiales
@section Introducci@'on a las funciones especiales

A continuaci@'on se especifican las notaciones correspondientes a las funciones especiales:

@example
bessel_j (index, expr)    Funci@'on de Bessel de primera especie
bessel_y (index, expr)    Funci@'on de Bessel de segunda especie
bessel_i (index, expr)    Funci@'on de Bessel modificada de primera especie
bessel_k (index, expr)    Funci@'on de Bessel modificada de segunda especie
%he[n] (z)                Polinomio de Hermite (Ojo: @code{he}, no @code{h}.
                                  Ver A&S 22.5.18)
%p[u,v] (z)               Funci@'on de Legendre de primera especie
%q[u,v] (z)               Funci@'on de Legendre de segunda especie
hstruve[n] (z)            Funci@'on H de Struve
lstruve[n] (z)            Funci@'on L de Struve
%f[p,q] ([], [], expr)    Funci@'on hipergeom@'etrica generalizada
gamma()                   Funci@'on Gamma
gammagreek(a,z)           Funci@'on Gamma incompleta
gammaincomplete(a,z)      Extremo de la funci@'on Gamma incompleta
@c IS slommel THE "LOMMEL" FUNCTION ?? NOT OTHERWISE MENTIONED IN TEXINFO FILES
slommel
%m[u,k] (z)               Funci@'on de Whittaker de primera especie
%w[u,k] (z)               Funci@'on de Whittaker de segunda especie
erfc (z)                  Complemento de la funci@'on de error, erf
ei (z)                    Integral exponencial (?)
kelliptic (z)             Integral el@'{@dotless{i}}ptica completa
                                  de primera especie (K)
%d [n] (z)                Funci@'on cil@'{@dotless{i}}ndrica parab@'olica
@end example




@node Funciones y variables para las funciones especiales,  , Introducci@'on a las funciones especiales, Funciones Especiales
@section Funciones y variables para las funciones especiales


@deffn {Funci@'on} airy_ai (@var{x})
Funci@'on Ai de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4. 

La ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0} tiene dos soluciones linealmente independientes, @code{y = Ai(x)} y @code{y = Bi(x)}. La derivada @code{diff (airy_ai(x), x)} es @code{airy_dai(x)}.

Si el argumento @code{x} es un n@'umero decimal real o complejo, se devolver@'a el valor num@'erico de @code{airy_ai} siempre que sea posible.

V@'eanse @code{airy_bi}, @code{airy_dai} y @code{airy_dbi}.
@end deffn

@deffn {Funci@'on} airy_dai (@var{x})
Es la derivada de la funci@'on Ai de Airy, @code{airy_ai(x)}. 

V@'ease @code{airy_ai}.
@end deffn

@deffn {Funci@'on} airy_bi (@var{x})
Es la funci@'on Bi de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Secci@'on 10.4. Se trata de la segunda soluci@'on de la ecuaci@'on de Airy @code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un n@'umero decimal real o complejo, se devolver@'a el valor num@'erico de @code{airy_bi} siempre que sea posible. En los otros casos, se devuelve la expresi@'on sin evaluar.

La derivada @code{diff (airy_bi(x), x)} es @code{airy_dbi(x)}.

V@'eanse @code{airy_ai} y @code{airy_dbi}.
@end deffn

@deffn {Funci@'on} airy_dbi (@var{x})
Es la derivada de la funci@'on Bi de Airy, @code{airy_bi(x)}.

V@'eanse @code{airy_ai} y @code{airy_bi}.
@end deffn

@deffn {Funci@'on} asympa
El paquete @code{asympa} contiene funciones de simplificaci@'on para realizar an@'alisis asint@'otico, incluyendo las funciones  ``big O'' y  ``little o'', de uso frecuente en el an@'alisis complejo y num@'erico.

La instrucci@'on @code{load ("asympa")} carga este paquete.

@end deffn

@deffn {Funci@'on} bessel (@var{z}, @var{a}) 
Funci@'on de Bessel de primera especie.

Ya no se recomienda su uso.  Util@'{@dotless{i}}cese @code{bessel_j (@var{z}, @var{a})} en su lugar.

@end deffn

@deffn {Funci@'on} bessel_j (@var{v}, @var{z})
Funci@'on de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_j} calcula el arreglo @code{besselarray} tal que @code{besselarray [i] = bessel_j [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_j} se define como

@ifhtml
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifhtml
@ifinfo
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn

@deffn {Funci@'on} bessel_y (@var{v}, @var{z})
Funci@'on de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_y} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_y [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_y} se define como

@ifhtml
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifhtml
@ifinfo
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifinfo

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

si @math{v} no es un entero.  En caso de que  @math{v} sea un entero @math{n}, se calcula el l@'{@dotless{i}}mite cuando @math{v} se aproxima a @math{n}.

@end deffn

@deffn {Funci@'on} bessel_i (@var{v}, @var{z})
Funci@'on modificada de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_i} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_i [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_i} se define como

@ifhtml
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifhtml
@ifinfo
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

aunque la serie infinita no se utiliza en los c@'alculos.

@end deffn

@deffn {Funci@'on} bessel_k (@var{v}, @var{z})
Funci@'on modificada de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La funci@'on @code{bessel_k} calcula el arreglo @code{besselarray} tal que
@code{besselarray [i] = bessel_k [i + v - int(v)] (z)} para @code{i} desde cero hasta @code{int(v)}.

La funci@'on @code{bessel_k} se define como

@ifhtml
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifhtml
@ifinfo
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifinfo

@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex

si @math{v} no es un entero.  Si @math{v} es igual al entero @math{n}, entonces se calcula el l@'{@dotless{i}}mite cuando @math{v} tiende a @math{n}.

@end deffn

@defvr {Variable optativa} besselexpand
Valor por defecto: @code{false}

Controla la expansi@'on de las funciones de Bessel cuando el orden es la mitad de un entero impar. En tal caso, las funciones de Bessel se pueden expandir en t@'erminos de otras funciones elementales.  Si @code{besselexpand} vale @code{true}, se expande la funci@'on de Bessel.

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                          2 z   sin(z)   cos(z)
(%o4)                sqrt(---) (------ - ------)
                          %pi      2       z
                                  z
@end example
@end defvr


@deffn {Funci@'on} scaled_bessel_i (@var{v}, @var{z})

Es la funci@'on de Bessel modificada de primera especie de
orden @math{v} y argumento @math{z}, es decir
@math{scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)}.
Esta funci@'on es especialmente @'util para calcular @math{bessel_i}
cuando @math{z} es grande. Sin embargo, Maxima no sabe mucho m@'as 
sobre esta funci@'on. En c@'alculos simb@'olicos, quiz@'as sea
preferible trabajar directamente con la expresi@'on 
@code{exp(-abs(z))*bessel_i(v, z)}.

@end deffn

@deffn {Funci@'on} scaled_bessel_i0 (@var{z})

Id@'entica a @code{scaled_bessel_i(0,z)}.

@end deffn

@deffn {Funci@'on} scaled_bessel_i1 (@var{z})

Id@'entica a @code{scaled_bessel_i(1,z)}.

@end deffn


@deffn {Funci@'on} beta (@var{x}, @var{y})
Funci@'on beta, definida como @code{gamma(x) gamma(y)/gamma(x + y)}.

@end deffn

@deffn {Funci@'on} gamma (@var{x})
Funci@'on gamma.

V@'ease tambi@'en @code{makegamma}.

La variable @code{gammalim} controla la simplificaci@'on de la funci@'on gamma.

La constante de Euler-Mascheroni es @code{%gamma}.

@end deffn

@defvr {Variable optativa} gammalim
Valor por defecto: 1000000

La variable @code{gammalim} controla la simplificaci@'on de la funci@'on gamma con argumentos enteros o racionales. Si el valor absoluto del argumento no es mayor que @code{gammalim}, entonces se realizar@'a la simplificaci@'on. N@'otese que la variable @code{factlim} tambi@'en controla la simplificaci@'on del resultado de @code{gamma} con argumento entero.

@end defvr

@deffn {Funci@'on} intopois (@var{a})
Convierte @var{a} en un codificado Poisson.

@end deffn

@deffn {Funci@'on} makefact (@var{expr})
Transforma las funciones @code{binomial}, @code{gamma} y @code{beta} que aparecen en @var{expr} en su notaci@'on factorial.

V@'ease tambi@'en @code{makegamma}.

@end deffn

@deffn {Funci@'on} makegamma (@var{expr})
Transforma las funciones @code{binomial}, @code{factorial} y @code{beta} que aparecen en @var{expr} en funciones @code{gamma}.

V@'ease tambi@'en @code{makefact}.

@end deffn

@deffn {Funci@'on} numfactor (@var{expr})
Devuelve el factor num@'erico que multiplica a la expresi@'on @var{expr}, la cual debe tener un @'unico t@'ermino. 

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example

@end deffn

@deffn {Funci@'on} outofpois (@var{a})
Convierte @var{a} desde codificado de Poisson a una representaci@'on general.  Si @var{a} no est@'a en forma de Poisson, @code{outofpois} hace la conversi@'on, siendo entonces el valor retornado @code{outofpois (intopois (@var{a}))}. Esta funci@'on es un simplificador can@'onico para sumas de potencias de senos y cosenos.

@end deffn

@deffn {Funci@'on} poisdiff (@var{a}, @var{b})
Deriva @var{a} con respecto a @var{b}. El argumento @var{b} debe aparecer s@'olo en los argumentos trigonom@'etricos o s@'olo en los coeficientes.

@end deffn

@deffn {Funci@'on} poisexpt (@var{a}, @var{b})
Id@'entico a @code{intopois (@var{a}^@var{b})}. El argumento @var{b} debe ser un entero positivo.

@end deffn

@c AQUI FALTA DEFINICION DE poisint

@defvr {Variable optativa} poislim
Valor por defecto: 5

La variable @code{poislim} determina el dominio de los coeficientes en los argumentos de las funciones trigonom@'etricas.  El valor por defecto 5 corresponde al intervalo [-2^(5-1)+1,2^(5-1)], o [-15,16], pero puede reasignarse para  [-2^(n-1)+1, 2^(n-1)].

@end defvr

@c AQUI FALTA DEFINICION DE poismap 

@deffn {Funci@'on} poisplus (@var{a}, @var{b})
Id@'entico a @code{intopois (a + b)}.

@end deffn

@deffn {Funci@'on} poissimp (@var{a})
Convierte @var{a} en una serie de Poisson para @var{a} en su representaci@'on general.

@end deffn

@defvr {S@'{@dotless{i}}mbolo especial} poisson
El s@'{@dotless{i}}mbolo @code{/P/} sigue a la etiqueta de las l@'{@dotless{i}}neas que contienen expresiones que son series de Poisson.

@end defvr

@deffn {Funci@'on} poissubst (@var{a}, @var{b}, @var{c})
Sustituye @var{b} por @var{a} en @var{c}, donde  @var{c} es una serie de Poisson.

(1) Si @var{b} es una de las variables @var{u}, @var{v}, @var{w}, @var{x}, @var{y} o @var{z}, entonces @var{a} debe ser una expresi@'on lineal en esas variables (por ejemplo, @code{6*u + 4*v}).

(2) Si @var{b} no es ninguna de esas variables, entonces @var{a} no puede contener tampoco a ninguna de ellas, ni senos, ni cosenos.

@c AQUI FALTA PARRAFO

@end deffn

@deffn {Funci@'on} poistimes (@var{a}, @var{b})
Id@'entico a @code{intopois (@var{a}*@var{b})}.

@end deffn

@c AQUI FALTA DEFINICION DE poistrim

@deffn {Funci@'on} printpois (@var{a})
Presenta una serie de Poisson en un formato legible.  Conjuntamente con @code{outofpois}, si es necesario convertir@'a @var{a} primero en una codificaci@'on de Poisson.

@end deffn


@deffn {Funci@'on} psi [@var{n}](@var{x})

Es la derivada de @code{log (gamma (@var{x}))} de orden @code{@var{n}+1},
de tal manera que @code{psi[0](@var{x})} es la primera derivada, 
@code{psi[1](@var{x})} la segunda derivada y as@'{@dotless{i}} 
sucesivamente.

En general, Maxima no sabe c@'omo calcular valores num@'ericos de 
@code{psi}, pero s@'{@dotless{i}} conoce el valor exacto para
algunos argumentos racionales.
Existen algunas variables globales para controlar en qu@'e rangos
racionales debe devolver @code{psi} resultados exactos, si ello es posible.
V@'eanse las descripciones de @code{maxpsiposint}, @code{maxpsinegint},
@code{maxpsifracnum} y @code{maxpsifracnum}.
En resumen, @var{x} debe alcanzar un valor entre @code{maxpsinegint} y
@code{maxpsiposint}. Si el valor absoluto de la parte fraccional de
@var{x} es racional y tiene un numerador menor que @code{maxpsifracnum}
y un denominador menor que @code{maxpsifracdenom}, la funci@'on @code{psi}
devolver@'a un valor exacto.

La funci@'on @code{bfpsi} del paquete @code{bffac} puede calcular
valores num@'ericos.

@end deffn

@defvr {Variable opcional} maxpsiposint
Valor por defecto: 20

La variable @code{maxpsiposint} guarda el mayor valor positivo para el 
que @code{psi[n](x)} intentar@'a calcular un valor exacto.

@end defvr

@defvr {Variable opcional} maxpsinegint
Valor por defecto: -10

La variable @code{maxpsinegint} guarda el menor valor negativo para el
que @code{psi[n](x)} intentar@'a calcular un valor exacto. Si
@var{x} es menor que @code{maxnegint}, @code{psi[n](@var{x})} no devolver@'a
una respuesta simplificada, aunque supiese c@'omo hacerlo.

@end defvr

@defvr {Variable opcional} maxpsifracnum
Valor por defecto: 6

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{p} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr

@defvr {Variable opcional} maxpsifracdenom
Valor por defecto: 6

Sea @var{x} un n@'umero racional menor que la unidad de la forma @code{p/q}.
Si @code{q} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolver@'a una respuesta simplificada.

@end defvr


@deffn {Funci@'on} specint (exp(- s*@var{t}) * @var{expr}, @var{t})

Calcula la transformada de Laplace de @var{expr} respecto de
la variable @var{t}. El integrando @var{expr} puede contener
funciones especiales.

Si @code{specint} no puede calcular la integral, le valor devuelto
puede contener s@'{@dotless{i}}mbolos de Lisp, incluyendo
@code{other-defint-to-follow-negtest},
@code{other-lt-exponential-to-follow},
@code{product-of-y-with-nofract-indices}, etc.; se trata de un
fallo pendiente de correcci@'on.

La ejecuci@'on de @code{demo(hypgeo)} muestra algunso ejemplos de
transformadas de Laplace calculadas con @code{specint}.

Examples:
@c ===beg===
@c assume (p > 0, a > 0);
@c specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
@c specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
@c               * exp(-p*t), t);
@c ===end===

@example
(%i1) assume (p > 0, a > 0);
(%o1)                    [p > 0, a > 0]
(%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                           sqrt(%pi)
(%o2)                     ------------
                                 a 3/2
                          2 (p + -)
                                 4
(%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
              * exp(-p*t), t);
                                   - a/p
                         sqrt(a) %e
(%o3)                    ---------------
                                2
                               p
@end example

@end deffn


@deffn {Funci@'on} hgfred (@var{a}, @var{b}, @var{t})

Simplifica la funci@'on hipergeom@'etrica generalizada en t@'erminos
de otras funciones m@'as sencillas. @var{a} es una lista de par@'ametros
del numerador y @var{b} lo es de par@'ametros del denominador.

En caso de que @code{hgfred} no pueda simplificar la funci@'on hipergeom@'etrica
devolver@'a una expresi@'on de la forma @code{%f[p,q]([a], [b], x)}, siendo @var{p}
el n@'umero de elementos de @var{a} y @var{q} el de @var{b}. Esta es la 
funci@'on hipergeom@'etrica generalizada @code{pFq}.

@example
(%i1) assume(not(equal(z,0)));
(%o1)                          [notequal(z, 0)]
(%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                     v/2                               %i z
                    4    bessel_j(v, z) gamma(v + 1) %e
(%o2)               ---------------------------------------
                                       v
                                      z
(%i3) hgfred([1,1],[2],z);

                                   log(1 - z)
(%o3)                            - ----------
                                       z
(%i4) hgfred([a,a+1/2],[3/2],z^2);

                               1 - 2 a          1 - 2 a
                        (z + 1)        - (1 - z)
(%o4)                   -------------------------------
                                 2 (1 - 2 a) z

@end example

Tal como muestra el siguiente ejemplo, puede ser de utilidad cargar
tambi@'en el paquete @code{orthopoly}. N@'otese que @var{L} es el
polinomio generalizado de Laguerre.

@example
(%i5) load(orthopoly)$
(%i6) hgfred([-2],[a],z);

                                    (a - 1)
                                 2 L       (z)
                                    2
(%o6)                            -------------
                                   a (a + 1)
(%i7) ev(%);

                                  2
                                 z        2 z
(%o7)                         --------- - --- + 1
                              a (a + 1)    a

@end example

@end deffn

