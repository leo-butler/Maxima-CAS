
@menu
* Introducci@'on a los Polinomios Ortogonales::  
* Definiciones para los Polinomios Ortogonales::  
@end menu

@node Introducci@'on a los Polinomios Ortogonales, Definiciones para los Polinomios Ortogonales, , Polinomios Ortogonales
@section Introducci@'on a Polinomios Ortogonales

El paquete @code{specfun} contiene el c@'odigo de Maxima para la evaluaci@'on de todos los polinomios ortogonales listados en el Cap@'{@dotless{i}}tulo 22 de Abramowitz y Stegun. Estos incluyen los polinomios de Chebyshev, Laguerre, Hermite, Jacobi, Legendre  y ultraesf@'ericos (Gegenbauer). Adem@'as, @code{specfun} contiene el c@'odigo para las funciones esf@'ericas de Bessel, de Hankel, y arm@'onicas. El paquete @code{specfun} se carga mediante la funci@'on @code{load} o con el sistema autom@'atico @code{autoload}.

La siguiente tabla lista las funciones de @code{specfun}, su nombre en Maxima, restricciones sobre sus argumentos y una referencia al algoritmo que @code{specfun} usa para evaluarlo. Con pocas excepciones, @code{specfun} sigue las convenciones de Abramowitz y Stegun.  En todos los casos, @math{m} y @math{n} deben ser enteros.

A&S se refiere a Abramowitz y Stegun, @emph{Handbook of 
Mathematical Functions} (10th edici@'on, Diciembre 1972),
G&R para Gradshteyn y Ryzhik, 
@emph{Table of Integrals, Series, and Products}
(1980, edici@'on corregida y ampliada) y Merzbacher 
para @emph{Quantum Mechanics} (2ed, 1970).  

@c CONSIDER STRIKING OUT RESTRICTIONS COLUMN TO MAKE TABLE NARROWER
@multitable @columnfractions 0.25 0.25 0.25 0.25
@item @emph{Funci@'on} @tab  @emph{Nombre en Maxima}  @tab @emph{Restricciones} @tab @emph{Referencia(s)}
@item Chebyshev T @tab chebyshev_t(n, x) @tab @math{n > -1} @tab A&S 22.5.31 
@item Chebyshev U @tab chebyshev_u(n, x) @tab @math{n > -1} @tab A&S 22.5.32 
@item Laguerre generalizado @tab gen_laguerre(n,a,x) @tab @math{n > -1} @tab A&S p@'ag 789
@item Laguerre @tab laguerre(n,x) @tab @math{n > -1} @tab A&S 22.5.67
@item Hermite @tab hermite(n,x) @tab @math{ n > -1} @tab A&S 22.4.40, 22.5.41
@item Jacobi @tab jacobi_p(n,a,b,x) @tab @math{ n > -1, a, b > -1} @tab A&S page 789
@item Legendre P asociado @tab assoc_legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.37, 8.6.6, 8.2.5
@item Legendre Q asociado @tab assoc_legendre_q(n,m,x) @tab @math{n > -1, m > -1} @tab G & R 8.706
@item Legendre P @tab legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.35
@item Legendre Q @tab legendre_q(n,m,x) @tab @math{n > -1} @tab A&S 8.6.19
@item Hankel esf@'erica 1ra. @tab spherical_hankel1(n, x) @tab @math{n > -1} @tab A&S 10.1.36
@item Hankel esf@'erica 2da. @tab spherical_hankel2(n, x) @tab @math{n > -1} @tab A&S 10.1.17
@item Bessel esf@'erica J @tab spherical_bessel_j(n,x) @tab @math{n > -1} @tab A&S 10.1.8, 10.1.15
@item Bessel esf@'erica Y @tab spherical_bessel_y(n,x) @tab @math{n > -1} @tab A&S 10.1.9, 10.1.15
@item arm@'onica esf@'erica @tab spherical_harmonic(n,m,x,y) @tab @math{n > -1, |m| <= n} @tab Merzbacher 9.64
@item ultraesf@'erica (Gegenbauer) @tab ultraspherical(n,a,x) @tab @math{ n > -1} @tab A&S 22.5.27
@end multitable

El paquete @code{specfun} intenta en principio realizar c@'alculos simb@'olicos, pero tambi@'en se espera que aporte buenos resultados en coma flotante. Se han realizado esfuerzos para mejorar su comportamiento en contextos num@'ericos. Cuando todos los argumentos, excepto el orden, son decimales en coma flotante (pero no @code{bfloats}), muchas funciones en @code{specfun} llaman a la versi@'on en coma flotante de la funci@'on de Jacobi. Esto aumenta la velocidad de c@'alculo de polinomios ortogonales.

El paquete @code{specfun} trata la mayor@'{@dotless{i}}a de errores de dominio devolviendo una funci@'on sin evaluar.  
No se han hecho esfuerzos para definir reglas de simplifiaci@'on (basado en las relaciones de recursi@'on) para funciones sin evaluar. 

La instrucci@'on @code{load ("specfun")} carga en memoria el paquete @code{specfun}. De forma alternativa, @code{setup_autoload} permite que el paquete se cargue cuando alguna de las funciones de @code{specfun} aparezca en una expresi@'on, para lo cual es suficiente con que @code{setup_autoload} aparezaca el la l@'{@dotless{i}}nea de comandos o en el archivo @code{maxima-init.mac}. V@'ease @code{setup_autoload}.

Ejemplo de utilizaci@'on de @code{specfun}:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c [hermite (0, x), hermite (1, x), hermite (2, x)];
@c diff (hermite (n, x), x);
@example
(%i1) load ("specfun")$
(%i2) [hermite (0, x), hermite (1, x), hermite (2, x)];
                                         2
(%o2)               [1, 2 x, - 2 (1 - 2 x )]
(%i3) diff (hermite (n, x), x);
(%o3)                 2 n hermite(n - 1, x)
@end example

Algunas funciones 
@c SUM IS CONSTRUCTED BY jacobi_p FOR SYMBOLIC n. OTHER FUNCTIONS CALL jacobi_p OR EACH OTHER.
@c THERE ARE SOME FUNCTIONS WHICH IMPOSE THE REQUIREMENT THAT n BE NUMERICAL,
@c SO THEY NEVER CALL A FUNCTION ON THIS LIST WITH A SYMBOLIC n.
(en concreto @code{jacobi_p}, @code{ultraspherical}, @code{chebyshev_t},
@code{chebyshev_u} y @code{legendre_p}),
devuelven una representaci@'on en serie cuando el orden es un entero simb@'olico. La representaci@'on en serie no se utiliza en @code{specfun} para la realizaci@'on de c@'alculos, pero puede simplificarse autom@'aticamente en Maxima, e incluso puede utilizarse la serie para evaluar la funci@'on tras las correspondientes manipulaciones. Por ejemplo:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@c declare (n, integer)$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@example
(%i1) load ("specfun")$
(%i2) legendre_p (n, x);
(%o2)                   legendre_p(n, x)
(%i3) ultraspherical (n, 3/2, 2);
             genfact(3, n, - 1) jacobi_p(n, 1, 1, 2)
(%o3)        ---------------------------------------
                       genfact(2, n, - 1)
(%i4) declare (n, integer)$
(%i5) legendre_p (n, x);
       n - 1
       ====
       \                                                 n - i%
(%o5) ( >     binomial(n, i%) binomial(n, n - i%) (x - 1)
       /
       ====
       i% = 1

                                    i%          n          n   n
                             (x + 1)   + (x + 1)  + (x - 1) )/2
(%i6) ultraspherical (n, 3/2, 2);
                          n - 1
                          ====
                          \       i%
(%o6) genfact(3, n, - 1) ( >     3   binomial(n + 1, i%)
                          /
                          ====
                          i% = 1

                                    n
 binomial(n + 1, n - i%) + (n + 1) 3  + n + 1)

                      n
/(genfact(2, n, - 1) 2 )
@end example

El primer y @'ultimo t@'erminos de la suma se a@~naden fuera del sumatorio.  Eliminando estos dos t@'erminos se evitan errores en Maxima asociados con t@'erminos del tipo @math{0^0} que deber@'{@dotless{i}}an valer 1, pero que dan el valor nulo en una suma de Maxima. Puesto que el @'{@dotless{i}}ndice de la suma va de 1 hasta @math{n - 1}, el @'{@dotless{i}}ndice inferior exceder@'a al superior cuando @math{n = 0}; d@'andole a la variable @code{sumhack} el valor @code{true} se resuelve el problema. Por ejemplo:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c declare (n, integer)$
@c e: legendre_p(n,x)$
@c ev (e, sum, n = 0);
@c ev (e, sum, n = 0, sumhack = true);
@example 
(%i1) load ("specfun")$
(%i2) declare (n, integer)$
(%i3) e: legendre_p(n,x)$
(%i4) ev (e, sum, n=0);
Lower bound to sum: 1
is greater than the upper bound: - 1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ev (e, sum, n=0, sumhack=true);
(%o5)                           1
@end example

La mayor@'{@dotless{i}}a de las funciones de @code{specfun} tienen la propiedad @code{gradef}; 
las derivadas con respecto al orden o respecto de otros par@'ametros de las funciones no est@'an definidas, de modo que el intento de c@'alculo de tales derivadas devuelve mensajes de error.

El autor del paquete @code{specfun} y de su documentaci@'on es
Barton Willis de la Universidad de Nebraska en Kearney. Se distribuye bajo los t@'erminos de la General Public License (GPL). Para fallos y comentarios sobre este paquete dirigirse a willisb@@unk.edu, incluyendo la versi@'on de Maxima, tal como se obtiene de @code{build_info()} y la versi@'on de @code{specfun}, tal como se obtiene de @code{get ('specfun, 'version)}.

@node Definiciones para los Polinomios Ortogonales, , Introducci@'on a los Polinomios Ortogonales, Polinomios Ortogonales
@section Definiciones para los Polinomios Ortogonales

@deffn {Funci@'on} assoc_legendre_p (@var{n}, @var{m}, @var{x})
Calcula la funci@'on asociada de primera especie para enteros @math{ n > -1 } y 
@math{ m > -1}.  Si @math{ | m | > n } y @math{ n >= 0},
se tiene  @math{assoc_legendre_p (n, m, x) = 0}.
Referencia: A&S 22.5.37 page 779,  A&S 8.6.6 (segunda ecuaci@'on) p@'agina 334, y A&S 8.2.5 p@'agina 333.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{assoc_legendre_q}, @code{legendre_p} y @code{legendre_q}.
@end deffn

@deffn {Funci@'on} assoc_legendre_q (@var{n}, @var{m}, @var{x})
Calcula la funci@'on asociada de segunda especie para enteros @math{ n > -1 } y @math{ m > -1}. 

Referencia: Gradshteyn y Ryzhik  8.706 p@'agina 1000.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en  @code{assoc_legendre_p}, @code{legendre_p} y @code{legendre_q}.
@end deffn

@deffn {Funci@'on}   chebyshev_t (@var{n}, @var{x})
Calcula la funci@'on de Chebyshev de primera especie para los enteros @math{ n > -1}.

Referencia: A&S 22.5.31 p@'agina 778 y A&S 6.1.22 p@'agina 256.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{chebyshev_u}.

@end deffn


@deffn {Funci@'on}   chebyshev_u (@var{n}, @var{x})
Calcula la funci@'on de Chebyshev de segunda especie para los enteros @math{ n > -1}.

Referencia: A&S, 22.8.3 p@'agina 783  y A&S 6.1.22 p@'agina 256. 

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{chebyshev_t}.

@end deffn

@deffn {Funci@'on}   gen_laguerre (@var{n}, @var{a}, @var{x})
Calcula el polinomio generalizado de Laguerre para enteros @math{ n > -1}.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

Referencia: tabla de la p@'agina 789 de A&S.
@end deffn

@deffn {Funci@'on} hermite (@var{n}, @var{x})
Calcula el polinomio de Hermite polynomial para enteros @math{ n > -1}.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

Referencia:  A&S 22.5.40 y 22.5.41, p@'agina 779.

@end deffn

@deffn {Funci@'on}  jacobi_p (@var{n}, @var{a}, @var{b}, @var{x})
Calcula el polinomio de Jacobi polynomial para enteros @math{ n > -1 } y @math{ a } y @math{ b } simb@'olicos o  @math{ a > -1}  y @math{b > -1}.  
(Los polinomios de Jacobi est@'an definidos para todo @math{ a } y @math{ b }; sin embargo, @math{ (1-x)^a(1+x)^b} no es integrable para @math{ a <= -1} o @math{ b <= -1}.) 

Si @math{a, b} y @math{ x } son n@'umeros en coma flotante (pero no @code{bfloats}) @code{specfun} llama a una versi@'on especial de @math{jacobi_p}. Para valores num@'ericos, la versi@'on especial es m@'as r@'apida que la otra. Muchas funciones de @code{specfun} se calculan como casos especiales de los polinomios de Jacobi, las cuales tambi@'en se benefician de la rapidez de la versi@'on especial de @math{ jacobi}.

Si @math{ n } ha sido declarado como entero,  @math{jacobi_p (n, a, b, x)} devuelve la representaci@'on sumatoria de la funci@'on de Jacobi. Puesto que Maxima simplifica @math{0^0} y @math{ 0 } en una suma, se a@~naden dos t@'erminos de la suma fuera del sumatorio.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

Referencia: tabla de la p@'agina 789 de A&S.

@c NEEDS EXAMPLES
@end deffn

@deffn {Funci@'on}  laguerre (@var{n}, @var{x})
Calcula el polinomio de Laguerre para enteros @math{ n > -1}.  

Referencia: A&S 22.5.16, p@'agina 778 y A&S p@'agina 789.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'ease tambi@'en @code{gen_laguerre}.

@end deffn

@deffn {Funci@'on}  legendre_p (@var{n}, @var{x})
Calcula el polinomio de Legendre de primera especie para enteros @math{ n > -1}.  

Referencia: A&S 22.5.35 p@'agina 779.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'ease tambi@'en @code{legendre_q}.

@end deffn

@deffn {Funci@'on}  legendre_q (@var{n}, @var{x})
Calcula el polinomio de Legendre de segunda especie para enteros @math{ n > -1}.   

Referencia: A&S 8.6.19 p@'agina 334.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'ease tambi@'en @code{legendre_p}.

@end deffn

@deffn {Funci@'on} spherical_bessel_j (@var{n}, @var{x})
Calcula la funci@'on esf@'erica de Bessel de primera especie para enteros @math{ n > -1}.  

Referencia: A&S 10.1.8 p@'agina 437 y A&S 10.1.15 p@'agina 439.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{spherical_hankel1}, @code{spherical_hankel2} y @code{spherical_bessel_y}.

@end deffn

@deffn {Funci@'on} spherical_bessel_y (@var{n}, @var{x})
Calcula la funci@'on esf@'erica de Bessel de segunda especie para enteros @math{ n > -1}.   

Referencia: A&S 10.1.9 p@'agina 437 y 10.1.15 p@'agina 439.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{spherical_hankel1}, @code{spherical_hankel2} y @code{spherical_bessel_y}.

@end deffn

@deffn {Funci@'on} spherical_hankel1 (@var{n}, @var{x})
Calcula la funci@'on esf@'erica de Hankel de primera especie para enteros @math{ n > -1}.  

Referencia: A&S 10.1.36 p@'agina 439.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{spherical_hankel2}, @code{spherical_bessel_j} y @code{spherical_bessel_y}.

@end deffn

@deffn {Funci@'on} spherical_hankel2 (@var{n}, @var{x})
Calcula la funci@'on esf@'erica de Hankel de segunda especie para enteros @math{ n > -1}.  

Referencia:  A&S 10.1.17 p@'agina 439.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'eanse tambi@'en @code{spherical_hankel1}, @code{spherical_bessel_j} y @code{spherical_bessel_y}.

@end deffn

@deffn {Funci@'on} spherical_harmonic (@var{n}, @var{m}, @var{x}, @var{y})
Calcula la funci@'on arm@'onica esf@'erica para enteros @math{ n > -1} y @math{ | m | <= n }.

Referencia:  Merzbacher 9.64.

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'ease tambi@'en @code{assoc_legendre_p}.

@end deffn

@deffn {Funci@'on} ultraspherical (@var{n}, @var{a}, @var{x})
Calcula los polinomios ultraesf@'ericos para enteros @math{ n > -1}. Los polinomios ultraesf@'ericos se conocen tambi@'en como polinomios de Gegenbauer.

Referencia: A&S 22.5.27

La instrucci@'on @code{load ("specfun")} carga en memoria esta funci@'on.

V@'ease tambi@'en @code{jacobi_p}.

@end deffn
