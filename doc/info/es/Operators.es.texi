@c english version 1.25
@menu
* n-arios::                        
* no-fijos::                       
* operador::                    
* postfijos::                     
* prefijos::                      
* Definiciones para Operadores::   
@end menu

@node n-arios, no-fijos, Operadores, Operadores

@section n-arios

Un operador de tipo @code{nary}(@code{n}-ario, en Maxima nary) es usado para denotar una funci@'on cuyo n@'umero de argumentos es arbitrario; los argumentos se separa por el s@'{@dotless{i}}mbolo del operador, como en A+B o A+B+C. La funci@'on @code{nary("x")} es una extensi@'on de la funci@'on @code{syntax} para declarar a x como un operador @code{n}-ario. Las funciones pueden ser declaradas para ser @code{nary}. Si se hace @code{declare(J,nary);}, se esta diciendo al simplificador que haga la reducci@'on de @code{j(j(a,b),j(c,d))} a @code{j(a, b, c, d)}.

Funciones relacionadas: @code{syntax}.

@node no-fijos, operador, n-arios, Operadores

@section no-fijos

Los operadores de tipo @code{nofix} (no-fijos, en Maxima nofix) son usados para denotar funciones que no reciben argumentos. La mera presencia de tal operador en un comando causar@'a que la correspondiente funci@'on sea evaluada. Por ejemplo, cuando se escribe "exit;" para salir de una interrupci@'on de Maxima, "exit" se est@'a comportando de forma similar a un operador no-fijo (@code{nofix}). La funci@'on @code{nofix("x")} es una extensi@'on de la funci@'on syntax la cual declara a x como un operador @code{nofix}. 

Funciones relacionadas @code{syntax}.


@node operador, postfijos, no-fijos, Operadores
@section operadores
V@'ease @code{operadores}.

@node postfijos, prefijos, operador, Operadores
@section postfijos

Un operador de tipo @code{postfix} (postfijo), al contrario de los de tipo @code{prefix}, denota funciones de un solo argumento, pero en este caso el argumento precede inmediatamente la ocurrencia del operador en la cadena de entrada, como en @code{3!}. La funci@'on @code{postfix("x")} es una extensi@'on de la funci@'on syntax para declarar a x como un operador @code{postfix}. 

Funciones relacionadas: @code{syntax}.   

@node prefijos, Definiciones para Operadores, postfijos, Operadores
@section prefijos
Un operador de tipo @code{prefix} (prefijo, en Maxima prefix) indica una funci@'on de un (1) argumento, dicho argumento viene inmediatamente despu@'es de una ocurrencia del operador. La funci@'on @code{prefix("x")} es una extensi@'on de la funci@'on syntax para declarar a x como un operador de @code{prefix}. 

Funciones relacionadas: @code{syntax}.

@c end concepts Operators
@node Definiciones para Operadores,  , prefijos, Operadores
@section Definiciones para Operadores

@deffn {Operador} "!"
El operador factorial. 
Para cualquier n@'umero complejo @code{x} (incluyendo enteros, racionales  y n@'umeros reales) excepto para enteros negativos, @code{x!} se define como @code{gamma(x+1)}. 

Para un entero @code{x}, @code{x!} simplifica el producto de los enteros desde 1 hasta @code{x}.
@code{0!} simplifica a 1.
Para a un n@'umero de punto flotante @code{x}, @code{x!} calcula al valor de @code{gamma(x+1)}.
Para @code{x} igual a @code{n/2} donde @code{n} es un entero impar,
@code{x!} simplifica a un factor racional por @code{sqrt(%pi)}
(donde @code{gamma(1/2)}) es igual a @code{sqrt(%pi)}). 
Si @code{x} es cualquier otra cosa, @code{x!} no se simplifica. 

Las variables 
@code{factlim}, @code{minfactorial} y  @code{factcomb} controlan la simplificaci@'on de expresiones que contienen factoriales. 

Las funciones @code{gamma}, @code{bffac} y @code{cbffac} son variaciones 
la funci@'on gamma. 
@code{makegamma} substituye a @code{gamma} para factoriales y funciones relacionadas. 

Funciones relacionadas: @code{binomial} 

@itemize @bullet
@item
El factorial de un entero, semi-entero o de punto flotante es simplificado a menos que el operando sea mayor que @code{factlim}. 

@example
(%i1) factlim: 10$
(%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          105 sqrt(%pi)
(%o2) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example

@item
El factorial de un n@'umero complejo, constante  conocida (por ejemplo @code{%e}) o una expresi@'on general no es simplificado. 

Sin embargo puede ser posible simplificar el factorial despu@'es evaluar el operando. 

@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003, 

                                          1.227580202486819]
@end example

@item
El factorial de un s@'{@dotless{i}}mbolo no se simplifica. 

@example
(%i1) kill (foo)$
(%i2) foo!;
(%o2)                       foo!
@end example

@item
Los factoriales son simplificados no evaluados.
As@'{@dotless{i}} @code{x!} puede ser reemplazado en una expresi@'on 
antecedida por el operador comilla. 

@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931193, 40320, 20!]
               16
@end example
@end itemize

@end deffn

@deffn {Operador} "!!"
El operador doble factorial.

Para un n@'umero entero, de punto flotante o racional @code{n},
@code{n!!} se evaluar@'a como el producto de @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
donde @code{k} es igual a @code{entier(n/2)}, que es, el mayor entero
menor o igual a @code{n/2}. 
Note que esta definici@'on no coincide con otras definciones publicadas para argumentos, los cuales no son enteros. 

@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para un entero par (o impar) @code{n}, @code{n!} se evalua el producto de
todos los enteros pares (o impares) consecutivos desde 2 (o 1) por @code{n}inclusive.  

Para un argumento @code{n} el cual no es un n@'umero entero, punto flotante o racional, @code{n!!} produce una forma de nombre @code{genfact (n, n/2, 2)}. 

@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn

@deffn {Operador} "#"
Representa la negaci@'on de la igualdad sint@'actica @code{=}.

N@'otese que debido a las reglas de evaluaci@'on de expresiones de tipo predicado (en concreto debido a que @code{not @var{expr}} obliga a la evaluaci@'on previa de @var{expr}), @code{not @var{a} = @var{b}} no ser@'a equivalente a @code{@var{a} # @var{b}} en algunos casos.

Ejemplos:
@c GENERATED FROM:
@c a = b;
@c is (a = b);
@c a # b;
@c not a = b;
@c is (a # b);
@c is (not a = b);

@example
(%i1) a = b;
(%o1)                         a = b
(%i2) is (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) is (a # b);
(%o5)                         true
(%i6) is (not a = b);
(%o6)                         true
@end example

@end deffn

@deffn {Operador} "."
El operador punto, para multiplicaci@'on de matrices (no-conmutativo). 
Cuando "." se usa de esta forma, se dejar@'an espacios a
ambos lados de @'este, como en @code{A . B}. As@'{@dotless{i}} se evita que se confunda con el punto decimal de los n@'umeros. 

V@'eanse:
@code{dot},
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident}
y
@code{dotscrules}.

@end deffn

@deffn {Operador} ":"
El operador de asignaci@'on. Por ejemplo, @code{A:3} se asigna a la variable @var{A} el valor de 3.
@end deffn

@deffn {Operador} "::"
Operador de asignaci@'on. :: asigna el valor de una expresi@'on
en su derecha a el valor de la cantidad en su izquierda, la cual
debe evaluarse a una variable de tipo at@'omica o una variable subindicada.

@end deffn

@deffn {Operador} "::="
El operador de definici@'on de macros @code{::=} define una funci@'on (llamada macro por razones hist@'oricas) que no eval@'ua sus argumentos, siendo la expresi@'on que retorna (llamada "macroexpansi@'on") evaluada dentro del contexto desde el cual se ha invocado la macro. En cualquier otro sentido, una funci@'on macro es igual que una funci@'on ordinaria.

@code{macroexpand} devuelve la expresi@'on que a su vez fue devuelta por una macro (sin evaluar la expresi@'on);
@code{macroexpand (foo (x))} seguida de @code{''%} es equivalente a @code{foo (x)} si @code{foo} es una funci@'on macro.

@code{::=} coloca el nombre de la nueva funci@'on macro en la lista global @code{macros}. Por otro lado, las funciones 
@code{kill}, @code{remove} y @code{remfunction} borran las definiciones de las funciones macro y eliminan sus nombres de la lista @code{macros}.

Las funciones @code{fundef} y @code{dispfun} devuelven la definici@'on de una funci@'on macro y le asignan una etiqueta, respectivamente.

Las funciones macro normalmente contienen expresiones @code{buildq} y @code{splice} para construir una expresi@'on, que luego ser@'a evaluada.

Ejemplos:

Una funci@'on macro no eval@'ua sus argumentos, por lo que el mensaje (1) muestra @code{y - z}, no el valor de @code{y - z}.
La macroexpansi@'on (es decir, la expresi@'on no evaluada @code{'(print ("(2) x is equal to", x))}) se eval@'ua en el contexto desde el cual se produjo la llamada a la macro, imprimiendo el mensaje (2).

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
@c printq1 (y - z);
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
(%o4) printq1(x) ::= block(print("(1) x is equal to", x), 
                                '(print("(2) x is equal to", x)))
(%i5) printq1 (y - z);
(1) x is equal to y - z 
(2) x is equal to %pi 
(%o5)                          %pi
@end example

Una funci@'on ordinaria eval@'ua sus argumentos, por lo que el mensaje (1) muestra el valor de @code{y - z}.
El valor de retorno no se eval@'ua, por lo que el mensaje (2) no se imprime hasta la evaluaci@'on expl@'{@dotless{i}}cita @code{''%}.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c printe1 (x) := block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
@c printe1 (y - z);
@c ''%;
@c ===end===
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) printe1 (x) := block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
(%o4) printe1(x) := block(print("(1) x is equal to", x), 
                                '(print("(2) x is equal to", x)))
(%i5) printe1 (y - z);
(1) x is equal to 1234 - 1729 w 
(%o5)              print((2) x is equal to, x)
(%i6) ''%;
(2) x is equal to %pi 
(%o6)                          %pi
@end example

@code{macroexpand} devuelve la macroexpansi@'on;
@code{macroexpand (foo (x))} seguida de @code{''%} es equivalente a @code{foo (x)} si @code{foo} es una funci@'on macro.

@c ===beg===
@c x: %pi;
@c y: 1234;
@c z: 1729 * w;
@c g (x) ::= buildq ([x], print ("x is equal to", x));
@c macroexpand (g (y - z));
@c ''%;
@c g (y - z);
@example
(%i1) x: %pi;
(%o1)                          %pi
(%i2) y: 1234;
(%o2)                         1234
(%i3) z: 1729 * w;
(%o3)                        1729 w
(%i4) g (x) ::= buildq ([x], print ("x is equal to", x));
(%o4)    g(x) ::= buildq([x], print("x is equal to", x))
(%i5) macroexpand (g (y - z));
(%o5)              print(x is equal to, y - z)
(%i6) ''%;
x is equal to 1234 - 1729 w 
(%o6)                     1234 - 1729 w
(%i7) g (y - z);
x is equal to 1234 - 1729 w 
(%o7)                     1234 - 1729 w
@end example

@end deffn

@deffn operator ":="
El operador de definici@'on de funciones. Por ejemplo, @code{f(x):=sin(x)} define
 una funci@'on @code{f}. 

@end deffn

@deffn {Operador} "="
Denota una ecuaci@'on para Maxima. El patr@'on de emparejamiento
en Maxima denota una relaci@'on total que se sostiene entre dos
expresiones si y s@'olo si las expresiones son sint@'acticamente id@'enticas.

La negaci@'on de @code{=} se representa por @code{#}.
N@'otese que debido a las reglas de evaluaci@'on de expresiones de tipo predicado (en concreto debido a que @code{not @var{expr}} obliga a la evaluaci@'on previa de @var{expr}), @code{not @var{a} = @var{b}} no ser@'a equivalente a @code{@var{a} # @var{b}} en algunos casos.

@end deffn

@deffn {Operador} and
Operador de conjunci@'on l@'ogica. El operador @code{and} es un operador infijo @code{n}-ario;
sus operandos son expresiones booleanas y su resultado es un valor l@'ogico.

El operador @code{and} impone la evaluaci@'on (igual que @code{is}) de uno o m@'as operandos,
y puede forzar la evaluaci@'on de todos los operandos.

Los operandos se eval@'uan en el orden en el que aparecen; @code{and} s@'olo eval@'ua tantos operandos como sean necesarios para determinar el resultado. Si un operando vale @code{false}, el resultado es @code{false} y ya no se eval@'uan m@'as operandos.

La variable global @code{prederror} controla el comportamiento de @code{and} cuando la evaluaci@'on de un operando no da como resultado @code{true} o @code{false}; @code{and} imprime un mensaje de error cuando @code{prederror} vale @code{true}.
En caso contrario, @code{and} devuelve @code{unknown}.

El operador @code{and} no es conmutativo: @code{a and b} puede no ser igual a @code{b and a} debido al tratamiento de operandos indeterminados.

@end deffn

@deffn {Operador} or
Operador de disyunci@'on l@'ogica. El operador @code{or} es un operador infijo @code{n}-ario;
sus operandos son expresiones booleanas y su resultado es un valor l@'ogico.

El operador @code{or} impone la evaluaci@'on (igual que @code{is}) de uno o m@'as operandos,
y puede forzar la evaluaci@'on de todos los operandos.

Los operandos se eval@'uan en el orden en el que aparecen; @code{or} s@'olo eval@'ua tantos operandos como sean necesarios para determinar el resultado. Si un operando vale @code{true}, el resultado es @code{true} y ya no se eval@'uan m@'as operandos.

La variable global @code{prederror} controla el comportamiento de @code{or} cuando la evaluaci@'on de un operando no da como resultado @code{true} o @code{false}; @code{or} imprime un mensaje de error cuando @code{prederror} vale @code{true}.
En caso contrario, @code{and} devuelve @code{unknown}.

El operador @code{or} no es conmutativo: @code{a or b} puede no ser igual a @code{b or a} debido al tratamiento de operandos indeterminados.

@end deffn

@deffn {Operador} not
Operador de negaci@'on l@'ogica. El operador @code{not} es un operador prefijo;
su operando es una expresi@'on booleana y su resultado es un valor l@'ogico.

El operador @code{not} impone la evaluaci@'on (igual que @code{is}) de su operando.

La variable global @code{prederror} controla el comportamiento de @code{not} cuando la evaluaci@'on de su operando no da como resultado @code{true} o @code{false}; @code{not} imprime un mensaje de error cuando @code{prederror} vale @code{true}.
En caso contrario, @code{not} devuelve @code{unknown}.

@end deffn


@deffn {Funci@'on} abs (@var{expr})
Devuelve el valor absoluto de @var{expr}. Si la expresi@'on es compleja, retorna
el m@'odulo de @var{expr}.

@end deffn

@defvr {Clave} additive
Si @code{declate(f,additive)} ha sido ejecutado, entonces: 

(1) Si @code{f} es univariado, cada vez que el simplificador encuentre
@code{f} aplicada a una suma, @code{f} ser@'a distribuida bajo esta suma. Por ejemplo, @code{f(x+y)} se simplificar@'a a @code{f(x)+f(y)}. 

(2) Si @code{f} es una funci@'on de 2 o m@'as argumentos, aditivamente es definida como aditiva en el primer argumento de @code{f}, como en el caso de @code{sum} o @code{integrate}. Por ejemplo, @code{f(h(x)+g(x),x)} se simplificar@'a a @code{f(h(x),x)+f(g(x),x)}. Esta simplificaci@'on no ocurre cuando @code{f} se aplia a expresiones de la forma @code{sum(x[i],i,lower-limit,upper-limit)}.

@end defvr

@defvr {Clave} allbut
Opera con los comandos @code{part} (como @code{part}, @code{inpart}, @code{substpart},
@code{substinpart}, @code{dpart} y @code{lpart}). Por ejemplo:

@example
(%i1) expr: e+d+c+b+a$
(%i2) part (expr, [2, 5]);
(%o2)                         d + a
@end example

mientras que: 

@example
(%i3) part (expr, allbut (2, 5));
(%o3)                       e + c + b
@end example

Tambi@'en trabaja con el comando @code{kill}, 

@example
kill (allbut (name_1, ..., name_k))
@end example

lo cual har@'a un @code{kill(all)} excepto a aquellos nombres
especificados a @code{kill}, en este caso. Nota: @code{name_i} representa
un nombre de funci@'on tal como @code{u}, @code{f}, @code{foo} o @code{g}, no una lista como @code{functions}. 

@end defvr

@defvr {Declaraci@'on} antisymmetric
Si @code{declare(h,antisymmetric)} es ejecutado, esto dice al 
simplificador que @code{h} es antisim@'etrico. E.g. @code{h(x,z,y)} ser@'a simplificado a @code{-h(x,y,z)}. Que es, el producto de (-1)^n por el resultado dado por @code{symmetric} o @code{commutative}, donde n es el n@'umero de intercambios necesarios de dos argumentos para convertirle a esta forma.  

@end defvr

@deffn {Funci@'on} cabs (@var{expr})
Devuelve el valor absoluto complejo (m@'odulo complejo) de @var{expr}.

@end deffn



@deffn {Funci@'on} ceiling (@var{x})

Si @var{x} es un n@'umero real, devuelve el menor entero mayor o igual que @var{x}.  

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{ceiling} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{ceiling} al n@'umero decimal obtenido. Puesto que @code{ceiling} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{ceiling} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{ceiling} es capaz de hacer:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling(ceiling(x));
(%o1) ceiling(x)
(%i2) ceiling(floor(x));
(%o2) floor(x)
(%i3) declare(n,integer)$
(%i4) [ceiling(n), ceiling(abs(n)), ceiling(max(n,6))];
(%o4) [n, abs(n), max(n,6)]
(%i5) assume(x > 0, x < 1)$
(%i6) ceiling(x);
(%o6) 1
(%i7) tex(ceiling(a));
   $$\left \lceil a \right \rceil$$
@end example

La funci@'on @code{ceiling} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{ceiling} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare(f,integervalued)$
(%i2) floor(f(x));
(%o2) f(x)
(%i3) ceiling(f(x) -1);
(%o3) f(x)-1
@end example

@end deffn

@deffn {Funci@'on} charfun (@var{p})

Devuelve 0 cuando el predicado @var{p} toma el valor @code{false}, y devuelve
1 cuando vale @code{true}.  Si el predicado toma un valor diferente de @code{true} y @code{false} (desconocido), 
entonces devuelve una forma nominal.

Ejemplos:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun(x<1);
(%o1) charfun(x<1)
(%i2) subst(x=-1,%);
(%o2) 1
(%i3) e : charfun('"and"(-1 < x, x < 1))$
(%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
(%o4) [0,1,0]
@end example

@end deffn


@defvr {Declaraci@'on} commutative
Si @code{declare(h,commutative)} es ejecutado, le dice al simplificador
que @code{h} es una funci@'on conmutaiva. Por ejemplo, @code{h(x,z,y)} se simplificar@'a a @code{h(x,y,z)}. Esto es lo mismo que @code{symmetric}. 

@end defvr


@deffn {Funci@'on} compare (@var{x}, @var{y})

Devuelve un operador de comparaci@'on @var{op}
(@code{<}, @code{<=}, @code{>}, @code{>=}, @code{=} o @code{#}) de manera que
@code{is (@var{x} @var{op} @var{y})} tome el valor @code{true};
cuando tanto @var{x} como @var{y} dependan de @code{%i} y
@code{@var{x} # @var{y}}, devuelve @code{notcomparable};
cuando no exista tal operador o Maxima sea incapaz de determinarlo, devolver@'a @code{unknown}.

Ejemplos:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare(1,2);
(%o1) <
(%i2) compare(1,x);
(%o2) unknown
(%i3) compare(%i,%i);
(%o3) =
(%i4) compare(%i,%i+1);
(%o4) notcomparable
(%i5) compare(1/x,0);
(%o5) #
(%i6) compare(x,abs(x));
(%o6) <=
@end example

La funci@'on @code{compare} no intenta determinar si los dominios reales de sus argumentos son conjuntos no vac@'{@dotless{i}}os; as@'{@dotless{i}},

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
(%o1) <
@end example

Aqu@'{@dotless{i}}, el dominio real de @code{acos (x^2 + 1)} es el conjunto vac@'{@dotless{i}}o.

@end deffn


@deffn {Funci@'on} entier (@var{x})
Devuelve el mayor entero menor o igual a @var{x}, siendo @var{x} num@'erico. La funci@'on  @code{fix} (como en
@code{fixnum}) es un sin@'onimo, de modo que @code{fix(@var{x})} hace justamente lo mismo.

@end deffn

@deffn {Funci@'on} equal (@var{expr_1}, @var{expr_2})
Utilizado junto con @code{is}, devuelve @code{true} (o @code{false}) si
y s@'olo si @var{expr_1} y @var{expr_2} son iguales (o no) para todos
los posibles valores de sus variables (tal como los calcula @code{ratsimp}). 
As@'{@dotless{i}},  @code{is (equal ((x + 1)^2, x^2 + 2*x + 1))} devuelve @code{true}, mientras que si @code{x} no tiene valor asignado, @code{is ((x + 1)^2 = x^2 + 2*x + 1)} devuelve @code{false}. N@'otese tambi@'en que @code{is(rat(0)=0)} da @code{false} pero @code{is (equal (rat(0), 0))} da @code{true}.

Si alg@'un c@'alculo no se puede hacer, @code{is (equal (a, b))} devuelve una expresi@'on simplificada y equivalente, 
mientras que  @code{is (a=b)} siempre devuelve @code{true} o @code{false}.

Todas las variables presentes en @var{expr_1} y @var{expr_2} se suponen n@'umeros reales.

La negaci@'on de  @code{equal} es @code{notequal}.
N@'otese que debido a las reglas de evaluaci@'on de expresiones de tipo predicado (en concreto debido a que @code{not @var{expr}} obliga a la evaluaci@'on previa de @var{expr}), @code{notequal} no ser@'a equivalente a @code{not equal} en algunos casos.

@c COPY THIS TO DESCRIPTION OF is
La llamada @code{ev (@var{expr}, pred)} equivale a @code{is (@var{expr})}.

@example
(%i1) is (x^2 >= 2*x - 1);
(%o1)                         true
(%i2) assume (a > 1);
(%o2)                        [a > 1]
(%i3) is (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
(%o3)                         true
@end example


@deffn {Funci@'on} floor (@var{x})

Si @var{x} es un n@'umero real, devuelve el mayor entero menor o igual que @var{x}.

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{floor} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{floor} al n@'umero decimal obtenido. Puesto que @code{floor} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{floor} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{floor} es capaz de hacer:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a);
@c ===end===
@example
(%i1) floor(ceiling(x));
(%o1) ceiling(x)
(%i2) floor(floor(x));
(%o2) floor(x)
(%i3) declare(n,integer)$
(%i3) [floor(n), floor(abs(n)), floor(min(n,6))];
(%o4) [n,abs(n),min(n,6)]
(%i4) assume(x > 0, x < 1)$
(%i5) floor(x);
(%o5) 0
(%i6) tex(floor(a);
    $$\left \lfloor a \right \rfloor$$
@end example


La funci@'on @code{floor} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{floor} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare(f,integervalued)$
(%i2) floor(f(x));
(%o2) f(x)
(%i3) ceiling(f(x) -1);
(%o3) f(x)-1
@end example

@end deffn


@end deffn

@deffn {Funci@'on} notequal (@var{expr_1}, @var{expr_2})
Representa la negaci@'on de @code{equal (@var{expr_1}, @var{expr_2})}.

N@'otese que debido a las reglas de evaluaci@'on de expresiones de tipo predicado (en concreto debido a que @code{not @var{expr}} obliga a la evaluaci@'on previa de @var{expr}), @code{notequal} no ser@'a equivalente a @code{not equal} en algunos casos.

Ejemplos:
@c GENERATED FROM:
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c maybe (not equal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c maybe (not equal (a, b));

@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
`macsyma' was unable to evaluate the predicate:
equal(a, b)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) maybe (not equal (a, b));
(%o6)                        unknown
(%i7) assume (a > b);
(%o7)                        [a > b]
(%i8) equal (a, b);
(%o8)                      equal(a, b)
(%i9) maybe (equal (a, b));
(%o9)                         false
(%i10) notequal (a, b);
(%o10)                   notequal(a, b)
(%i11) not equal (a, b);
(%o11)                        true
(%i12) maybe (notequal (a, b));
(%o12)                        true
(%i13) maybe (not equal (a, b));
(%o13)                        true
@end example

@end deffn

@deffn {Operador} eval
El operador @code{eval} realiza una evaluaci@'on extra de una expresi@'on @var{expr}.
V@'ease @code{ev}.

@end deffn

@deffn {Funci@'on} evenp (@var{expr})
Devuelve @code{true} si @var{expr} es un entero par y @code{false} en cualquier otro caso.

@end deffn

@deffn {Funci@'on} fix (@var{x})
Es un sin@'onimo de  @code{entier (@var{x})}.

@end deffn

@deffn {Funci@'on} fullmap (@var{f}, @var{expr_1}, ...)
Similar a @code{map}, pero conservar@'a el mapeado
descendente de todas las subexpresiones hasta que los operadores
principales ya no sean los mismos.

La funci@'on @code{fullmap} es utilizada por el simplificador de Maxima
en algunas transformaciones matriciales, por lo que Maxima generar@'a en algunas ocasiones mensajes de error relacionados con @code{fullmap} aunque el usuario no haya invocado expl@'{@dotless{i}}citamente esta funci@'on.

@example
(%i1) a + b*c$
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
@end example

@end deffn

@deffn {Function} fullmapl (@var{f}, @var{list_1}, ...)
Similar a @code{fullmap}, pero @code{fullmapl} s@'olo hace mapeo
sobre listas y matrices.

@example
(%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
@end example

@end deffn

@deffn {Funci@'on} is (@var{expr})
Intenta determinar si el predicado @var{expr}  se puede deducir de los hechos almacenados en la base de datos gestionada por @code{assume}.

Si el predicado se reduce a @code{true} o @code{false},
@code{is} devuelve @code{true} o @code{false}, respectivamente.
En otro caso, el valor devuelto est@'a controlado por la variable global @code{prederror}.
Si @code{prederror} vale @code{false}, @code{is} devuelve @code{unknown} si el predicado no se puede reducir a un valor de verdad l@'ogica, retornando un mensaje de error si @code{prederror} vale @code{true}.

V@'eanse tambi@'en @code{assume}, @code{facts} y @code{maybe}.

Ejemplos:

@code{is} hace evaluaci@'on de predicados.
@c GENERATED FROM:
@c %pi > %e;
@c is (%pi > %e);

@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@code{is} eval@'ua predicados a partir de la base de datos de @code{assume}.
@c GENERATED FROM:
@c assume (a > b);
@c assume (b > c);
@c is (a < b);
@c is (a > c);
@c is (equal (a, c));

@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

Si @code{is} no puede evaluar el valor l@'ogico del predicado a partir de la base de datos gestionada por @code{assume},
la variable global  @code{prederror} controla el comportamiento de @code{is}.

@c GENERATED FROM:
@c assume (a > b);
@c prederror: true$
@c is (a > 0);
@c prederror: false$
@c is (a > 0);

@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
`macsyma' was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example

@end deffn

@deffn {Funci@'on} maybe (@var{expr})
Intenta determinar si el predicado @var{expr}  se puede deducir de los hechos almacenados en la base de datos gestionada por @code{assume}.

Si el predicado se reduce a @code{true} o @code{false},
@code{maybe} devuelve @code{true} o @code{false}, respectivamente.
En otro caso, @code{maybe} devuelve @code{unknown}.

La funci@'on @code{maybe} es funcionalmente equivalente a @code{is} con @code{prederror: false},
pero el resultado se calcula sin asignar valor alguno a @code{prederror}.

V@'eanse tambi@'en @code{assume}, @code{facts} y @code{is}.

Ejemplos:
@c GENERATED FROM:
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);

@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@end deffn

@deffn {Funci@'on} isqrt (@var{x})
Devuelve la "ra@'{@dotless{i}}z cuadrada entera"
del valor absoluto de @var{x},
el cual debe ser un entero.

@end deffn

@deffn {Funci@'on} lmax (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('max, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn

@deffn {Funci@'on} lmin (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('min, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn


@deffn {Funci@'on} max (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la mayor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{max} aplica la simplificaci@'on 
@code{max (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{max} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Funci@'on} min (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la menor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{min} aplica la simplificaci@'on 
@code{min (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{min} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Funci@'on} polymod (@var{p})
@deffnx {Funci@'on} polymod (@var{p}, @var{m})
Convierte el polinomio @var{p} a una representaci@'on modular respecto del m@'odulo actual, que es el valor almacenado en la variable @code{modulus}.  

La llamada @code{polymod (@var{p}, @var{m})} especifica un m@'odulo @var{m} para ser utilizado en lugar de valor almacenado en @code{modulus}.

V@'ease @code{modulus}.
@end deffn

@deffn {Funci@'on} mod (@var{x}, @var{y})

Si @var{x} e @var{y} son n@'umeros reales e @var{y} es distinto de cero,
devuelve @code{@var{x} - @var{y} * floor(@var{x} / @var{y})}.
Para todos los reales @var{x}, se tiene @code{mod (@var{x}, 0) = @var{x}}. Para informaci@'on sobre la definici@'on de  @code{mod (@var{x}, 0) = @var{x}}, v@'ease la secci@'on 3.4 de "Concrete Mathematics", 
by Graham, Knuth, and Patashnik. La funci@'on @code{mod (@var{x}, 1)} es de diente de sierra con periodo unidad y con @code{mod (1, 1) = 0} y @code{mod (0, 1) = 0}.

Para encontrar el argumento principal (un n@'umero del intervalo @code{(-%pi, %pi]}) de un n@'umero complejo, h@'agase uso de la funci@'on @code{@var{x} |-> %pi - mod (%pi - @var{x}, 2*%pi)}, donde @var{x} es un argumento.

Si @var{x} e @var{y} son expresiones constantes (por ejemplo, @code{10 * %pi}), @code{mod} utiliza el mismo esquema de evaluaci@'on basado en n@'umeros grandes en coma flotante (big floats) que @code{floor} y @code{ceiling}. Tambi@'en es posible, pero improbable, que @code{mod} pueda retornar un valor err@'oneo en tales casos.

Para argumentos no num@'ericos @var{x} o @var{y}, @code{mod} aplica algunas reglas de simplificaci@'on:

@c ===beg===
@c mod (x, 0);
@c mod (a*x, a*y);
@c mod (0, x);
@c ===end===
@example
(%i1) mod(x,0);
(%o1) x
(%i2) mod(a*x,a*y);
(%o2) a*mod(x,y)
(%i3) mod(0,x);
(%o3) 0
@end example
@end deffn

@deffn {Funci@'on} oddp (@var{expr})
Devuelve @code{true} si @var{expr} es un entero impar y @code{false} en caso contrario.

@end deffn

@deffn {Operador} pred
El operador @code{pred} realiza una evaluaci@'on extra de un predicado (expresi@'on cuya evaluaci@'on debe dar @code{true}
o @code{false}). V@'ease @code{ev}.

@end deffn

@deffn {Funci@'on} make_random_state (@var{n})
@deffnx {Funci@'on} make_random_state (@var{s})
@deffnx {Funci@'on} make_random_state (true)
@deffnx {Funci@'on} make_random_state (false)

Un objeto de estado aleatorio representa el estado del generador de n@'umeros aleatorios. El estado consiste en 627 cadenas binarias de 32 bits.

La llamada @code{make_random_state (@var{n})} devuelve un nuevo objeto de estado aleatorio creado a partir de una semilla entera igual a @var{n} m@'odulo 2^32. El argumento @var{n} puede ser negativo.

La llamada @code{make_random_state (@var{s})} devuelve una copia del estado aleatorio @var{s}.

La llamada @code{make_random_state (true)} devuelve un nuevo objeto de estado aleatorio, cuya semilla se genera a partir de la hora actual del reloj del sistema como semilla.

La llamada @code{make_random_state (false)} devuelve una copia del estado actual del generador de n@'umeros aleatorios.

@end deffn

@deffn {Funci@'on} set_random_state (@var{s})
Establece @var{s} como estado del generador de n@'umeros aleatorios.

La funci@'on @code{set_random_state} devuelve @code{done} en todo caso.

@end deffn

@deffn {Funci@'on} random (@var{x})
Devuelve un n@'umero seudoaleatorio. Si @var{x} es un entero, @code{random (@var{x})} devuelve un
entero entre 0 y @code{@var{x} - 1}, ambos inclusive. Si @var{x} es un decimal en punto flotante,
@code{random (@var{x})} devuelve un decimal no negativo en punto flotante menor que @var{x}.
La funci@'on @code{random} emite un mensaje de error si @var{x} no es ni entero ni de punto flotante,
o si @var{x} no es positivo.

Las funciones @code{make_random_state} y @code{set_random_state}
permiten controlar el estado del generador de n@'umeros aleatorios.

El generador de n@'umeros aleatorios de Maxima implementa el algoritmo de Mersenne twister MT 19937.

Ejemplos:
@c GENERATED FROM THE FOLLOWING
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);

@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn


@deffn {Funci@'on} rationalize (@var{expr})
Convierte todos los n@'umeros en coma flotante de doble precisi@'on y grandes (big float) presentes en una expresi@'on @var{expr} de Maxima a a sus formas racionales exactas equivalentes. Si el usuario no est@'a familiarizado con la representaci@'on binaria de n@'umeros en coma flotante, le puede extra@~nar que @code{rationalize (0.1)} no sea igual que 1/10.  Este comportamiento no es @'unico de Maxima, ya que el n@'umero 1/10 en su forma binaria es peri@'odico y no exacto.

@c ===beg===
@c rationalize (0.5);
@c rationalize (0.1);
@c fpprec : 5$
@c rationalize (0.1b0);
@c fpprec : 20$
@c rationalize (0.1b0);
@c rationalize (sin (0.1*x + 5.6));
@c ===end===
@example
(%i1) rationalize(0.5);
(%o1) 1/2
(%i2) rationalize(0.1);
(%o2) 3602879701896397/36028797018963968
(%i3) fpprec : 5$
(%i4) rationalize(0.1b0);
(%o4) 209715/2097152
(%i5) fpprec : 20$
(%i6) rationalize(0.1b0);
(%o6) 236118324143482260685/2361183241434822606848
(%i7) rationalize(sin(0.1 * x + 5.6));
(%o7) sin((3602879701896397*x)/36028797018963968+3152519739159347/562949953421312)
@end example

Ejemplo de uso:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf)); 
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
unitfrac(r) := block([uf : [], q],
   if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
   while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
   reverse(uf)); 

(%i2) unitfrac(9/10);
(%o2) [1/2,1/3,1/15]
(%i3) apply("+",%);
(%o3) 9/10
(%i4) unitfrac(-9/10);
(%o4) [-1,1/10]
(%i5) apply("+",%);
(%o5) -9/10
(%i6) unitfrac(36/37);
(%o6) [1/2,1/3,1/8,1/69,1/6808]
(%i7) apply("+",%);
(%o7) 36/37   
@end example

@end deffn


@deffn {Funci@'on} sign (@var{expr})
Intenta determinar el signo de @var{expr} en base a los hechos almacenados en la base de datos. Devuelve una de las siguientes respuestas: @code{pos} (positivo), @code{neg} (negativo), @code{zero} (cero), @code{pz}
(positivo o cero), @code{nz} (negativo o cero), @code{pn} (positivo o negativo),
o @code{pnz} (positivo, negativo o cero, lo que significa que el signo es desconocido).

@end deffn

@deffn {Funci@'on} signum (@var{x})
Para @var{x} num@'erico, devuelve 0 si @var{x} es 0, en caso contrario devuelve -1 o +1, seg@'un que @var{x} sea menor o mayor que 0, respectivamente.

Si @var{x} no es num@'erico, entonces se devuelve una forma simplificada equivalente.
Por ejemplo, @code{signum(-x)} devuelve @code{-signum(x)}.
@c UMM, THIS ISN'T THE WHOLE STORY, AS IT APPEARS signum CONSULTS THE assume DATABASE FOR SYMBOLIC ARGUMENT

@end deffn

@deffn {Funci@'on} sort (@var{list}, @var{p})
@deffnx {Funci@'on} sort (@var{list})
Ordena @var{list} de acuerdo con el predicado @code{p} de dos argumentos, como @code{"<"} o @code{orderlessp}.

La llamada @code{sort (@var{list})} ordena @var{list} de acuerdo con la ordenaci@'on preestablecida en Maxima.

El argumento @var{list} puede contener elementos num@'ericos o no num@'ericos o de de ambos tipos.

@c NEED EXAMPLES, ESPECIALLY SORTING NONNUMERIC ITEMS
@end deffn

@deffn {Funci@'on} sqrt (@var{x})
Ra@'{@dotless{i}}z cuadrada de @var{x}. Se representa internamente por @code{@var{x}^(1/2)}.  V@'ease tambi@'en @code{rootscontract}.

Si la variable @code{radexpand} vale @code{true} har@'a que las ra@'{@dotless{i}}ces @code{n}-@'esimas de los factores de un producto que sean potencias de @code{n} sean extra@'{@dotless{i}}das del radical; por ejemplo, @code{sqrt(16*x^2)} se convertir@'a en @code{4*x} s@'olo si @code{radexpand} vale @code{true}.

@end deffn

@defvr {Variable opcional} sqrtdispflag
Valor por defecto: @code{true}

Si @code{sqrtdispflag} vale @code{false}, har@'a que @code{sqrt} se muestre con el exponente 1/2.
@c AND OTHERWISE ... ??

@end defvr

@deffn {Funci@'on} sublis (@var{list}, @var{expr})
Realiza sustituciones  m@'ultiples en paralelo en una expresi@'on.

La variable @code{sublis_apply_lambda} controla la simplificaci@'on despu@'es de @code{sublis}.

Ejemplo:

@example
(%i1) sublis ([a=b, b=a], sin(a) + cos(b));
(%o1)                    sin(b) + cos(a)
@end example

@end deffn

@deffn {Funci@'on} sublist (@var{list}, @var{p})
Devuelve la lista de elementos de @var{list} para los cuales el predicado @code{p} retorna @code{true}.

Ejemplo:

@example
(%i1) L: [1, 2, 3, 4, 5, 6]$
(%i2) sublist (L, evenp);
(%o2)                       [2, 4, 6]
@end example

@end deffn

@defvr {Variable opcional} sublis_apply_lambda
Valor por defecto: @code{true}

Controla si los @code{lambda} sustituidos son aplicados en la simplificaci@'on despu@'es de invocar a @code{sublis}, o si se tiene que hacer un @code{ev} para hacerlo. Si @code{sublis_apply_lambda} vale @code{true}, significa que se ejecute la aplicaci@'on.

@end defvr

@deffn {Funci@'on} subst (@var{a}, @var{b}, @var{c})
Sustituye @var{a} por @var{b} en @var{c}. El argumento  @var{b} debe ser un @'atomo o una subexpresi@'on completa de @var{c}.  Por ejemplo, @code{x+y+z} es una subexpresi@'on completa de  @code{2*(x+y+z)/w} mientras que @code{x+y} no lo es. Cuando @var{b} no cumple esta caracter@'{@dotless{i}}stica, se puede utilizar en algunos casos @code{substpart} o @code{ratsubst}
(ver m@'as abajo).  Alternativamente, si @var{b} no es de la forma @code{e/f} entonces se puede usar @code{subst (a*f, e, c)}, pero si @var{b} es de la forma @code{e^(1/f)} se debe usar @code{subst (a^f, e, c)}.  La instrucci@'on @code{subst} tambi@'en reconoce @code{x^y} en @code{x^-y}, de manera que  @code{subst (a, sqrt(x), 1/sqrt(x))} da @code{1/a}. Los argumentos @var{a} y @var{b} tambi@'en pueden ser operadores de una expresi@'on acotados por comillas dobles @code{"} o nombres de funciones.  Si se quiere sustituir la variable independiente en expresiones con derivadas se debe utilizar la funci@'on @code{at} (ver m@'as abajo).

La funci@'on @code{subst} es sin@'onimo de @code{substitute}.

La llamada @code{subst (@var{eq_1}, @var{expr})} o @code{subst ([@var{eq_1}, ..., @var{eq_k}], @var{expr})}
est@'an permitidas.  Las @var{eq_i} son ecuaciones que indican las sustituciones a realizar.
Para cada ecuaci@'on, el miembro derecho ser@'a sustituida por la expresi@'on del miembro izquierdo en @var{expr}.

Si la variable @code{exptsubst} vale @code{true} se permiten ciertas sustituciones de exponentes; por ejemplo, sustituir @code{y} por @code{%e^x} en @code{%e^(a*x)}.

Si @code{opsubst} vale @code{false},
@code{subst} no intentar@'a sustituir un operador de una expresi@'on. Por ejemplo, 
@code{(opsubst: false, subst (x^2, r, r+r[0]))} trabajar@'a sin problemas.

Ejemplos:

@example
(%i1) subst (a, x+y, x + (x+y)^2 + y);
                                    2
(%o1)                      y + x + a
(%i2) subst (-%i, %i, a + b*%i);
(%o2)                       a - %i b
@end example

@noindent
Para m@'as ejemplos, ejec@'utese @code{example (subst)}.

@end deffn

@deffn {Funci@'on} substinpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Es similar a @code{substpart}, pero @code{substinpart} trabaja con la representaci@'on interna de @var{expr}.

@example
(%i1) x . 'diff (f(x), x, 2);
                              2
                             D
(%o1)                    x . --- (f(x))
                               2
                             dx
(%i2) substinpart (d^2, %, 2);
                                  2
(%o2)                        x . d
(%i3) substinpart (f1, f[1](x+1), 0);
(%o3)                       f1(x + 1)
@end example

Si el @'ultimo argumento de la funci@'on @code{part} es una lista de @'{@dotless{i}}ndices, entonces se toman varias subexpresiones, cada una de las cuales en correspondencia con un @'{@dotless{i}}ndice de la lista. As@'{@dotless{i}}, 

@example
(%i1) part (x+y+z, [1, 3]);
(%o1)                         z + x
@end example

@code{piece} guarda el valor de la @'ultima expresi@'on seleccionada cada vez que se utiliza la funci@'on @code{part}. Esta asignaci@'on se se hace durante la ejecuci@'on de la funci@'on, con lo que puede ser referenciada en la propia funci@'on tal como se muestra m@'as abajo. Si @code{partswitch} vale @code{true} entonces se devuelve @code{end} cuando la parte seleccionada de una expresi@'on no existe, en caso contrario se muestra un mensaje de error.

@example
(%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
              3         2       2            3
(%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
(%i2) part (expr, 2, [1, 3]);
                                  2
(%o2)                         54 y
(%i3) sqrt (piece/54);
(%o3)                        abs(y)
(%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                               3
(%o4)               (3 y + 2 x)  + y + x + 1
(%i5) expr: 1/x + y/x - 1/z;
                             1   y   1
(%o5)                      - - + - + -
                             z   x   x
(%i6) substpart (xthru (piece), expr, [2, 3]);
                            y + 1   1
(%o6)                       ----- - -
                              x     z
@end example

Adem@'as, darle a la opci@'on @code{inflag} el valor @code{true} y llamar a @code{part} o a @code{substpart} es 
lo mismo que llamar a @code{inpart} o a @code{substinpart}.

@end deffn

@deffn {Funci@'on} substpart (@var{x}, @var{expr}, @var{n_1}, ..., @var{n_k})
Sustituye @var{x} por la subexpresi@'on determinada por el resto de argumentos, seg@'un el esquema de @code{part}.  Devuelve el nuevo valor de @var{expr}. El argumento  @var{x} puede ser un operador a ser sustituido por un operador de @var{expr}. En algunos casos @var{x} necesita estar acotado por comillas dobles @code{"}, como en @code{substpart ("+", a*b, 0)} para que retorne @code{b + a}.

@example
(%i1) 1/(x^2 + 2);
                               1
(%o1)                        ------
                              2
                             x  + 2
(%i2) substpart (3/2, %, 2, 1, 2);
                               1
(%o2)                       --------
                             3/2
                            x    + 2
(%i3) a*x + f (b, y);
(%o3)                     a x + f(b, y)
(%i4) substpart ("+", %, 1, 0);
(%o4)                    x + f(b, y) + a
@end example

Adem@'as, darle a la opci@'on @code{inflag} el valor @code{true} y llamar a @code{part} o a @code{substpart} es 
lo mismo que llamar a @code{inpart} o a @code{substinpart}.

@end deffn

@deffn {Funci@'on} subvarp (@var{expr})
Devuelve @code{true} si @var{expr} es una variable subindicada, como @code{a[i]}.

@end deffn

@deffn {Funci@'on} symbolp (@var{expr})
Devuelve @code{true} si @var{expr} es un s@'{@dotless{i}}mbolo y @code{false} en caso contrario.
La llamada @code{symbolp(x)} equivale al predicado @code{atom(x) and not numberp(x)}.

V@'ease tambi@'en @code{Identifiers}.

@end deffn

@deffn {Funci@'on} unorder ()
Desactiva las asociaciones creadas por la @'ultima utilizaci@'on de los comandos de ordenaci@'on @code{ordergreat} y @code{orderless}, los cuales no pueden ser utilizados m@'as de una vez sin invocar a @code{unorder}. 
V@'ease tambi@'en @code{ordergreat} y @code{orderless}.

@example
(%i1) unorder();
(%o1)                          []
(%i2) b*x + a^2;
                                   2
(%o2)                       b x + a
(%i3) ordergreat (a);
(%o3)                         done
(%i4) b*x + a^2;
                             2
(%o4)                       a  + b x
(%i5) %th(1) - %th(3);
                              2    2
(%o5)                        a  - a
(%i6) unorder();
(%o6)                          [a]
@end example

@end deffn

@deffn {Funci@'on} vectorpotential (@var{givencurl})
Devuelve el vector potencial de un vector rotacional en el sistema
de coordenadas actual. 
@code{potentialzeroloc} tiene un rol similar al de @code{potential}, 
pero el orden del miembro izquierdo de las ecuaciones debe ser una
permutaci@'on c@'{@dotless{i}}clica de las coordenadas. 

@end deffn

@deffn {Funci@'on} xthru (@var{expr})
Combina todos los t@'erminos de @var{expr} (la cual debe ser una suma) sobre un com@'un denominador sin expandir productos ni sumas elevadas a exponentes al modo que lo hace @code{ratsimp}. La funci@'on @code{xthru} cancela factores comunes en el numerador y denominador de expresiones racionales, pero s@'olo si los factores son expl@'{@dotless{i}}citos.

En ocasiones puede ser @'util el uso de @code{xthru} antes de la llamada a @code{ratsimp} a fin de cancelar factores expl@'{@dotless{i}}citos del m@'aximo com@'un divisor del numerador y denominador y as@'{@dotless{i}} simplificar la expresi@'on a la que se va a aplicar @code{ratsimp}.

@example
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end example

@end deffn

@deffn {Funci@'on} zeroequiv (@var{expr}, @var{v})
Analiza si la expresi@'on @var{expr} de variable @var{v} equivale a cero, devolviendo @code{true}, @code{false} o
@code{dontknow}.

La funci@'on @code{zeroequiv} tiene estas restricciones:
@enumerate
@item
No utilizar funciones que Maxima no sepa derivar y evaluar.
@item
Si la expresi@'on tiene polos en la recta real, pueden aparecer errores en el resultado, aunque es poco probable.
@item
Si la expresi@'on contiene funciones que no son soluciones de ecuaciones diferenciales ordinarias de primer orden (como las funciones de Bessel) pueden presentarse resultados incorrectos.
@item
El algoritmo utiliza evaluaciones en puntos aleatoriamente seleccionados. Esto conlleva un riesgo,aunque el algoritmo intenta minimizar el error.
@end enumerate

Por ejemplo, @code{zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)} devuelve
@code{true} y @code{zeroequiv (%e^x + x, x)} devuelve @code{false}.
Por otro lado @code{zeroequiv (log(a*b) - log(a) - log(b), a)} devuelve @code{dontknow} debido a la presencia del par@'ametro @code{b}.

@end deffn
