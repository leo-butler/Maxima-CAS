@menu
* Introducci@'on a la definici@'on de funciones::  
* Funciones::                    
* Macros::                       
* Definiciones para la definici@'on de funciones::  
@end menu

@node Introducci@'on a la definici@'on de funciones, Funciones, Definici@'on de Funciones, Definici@'on de Funciones
@section Introducci@'on a la definici@'on de funciones

@node Funciones, Macros, Introducci@'on a la definici@'on de funciones, Definici@'on de Funciones

@section Funciones

Para definir una funci@'on en Maxima es necesario utilizar el operador ':='.

Por ejemplo,

@example
f(x) := sin(x)
@end example
@noindent

define una funci@'on @code{f}. Tambi@'en se pueden definir funciones an@'onimas utilizando @code{lambda}, por ejemplo,

@example
lambda ([i, j], ...)
@end example

@noindent
puede utilizarse en lugar de @code{f} donde

@example
f(i,j) := block ([], ...);
map (lambda ([i], i+1), l)
@end example

@noindent
devolver@'{@dotless{i}}a una lista con todos sus elementos aumentados en una unidad.

Tambi@'en se puede definir una funci@'on con un n@'umero variable de argumentos, sin m@'as que a@~nadir un argumento final al que se le asigna una lista con todos los argumentos adicionales.:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

El miembro derecho de una funci@'on debe ser una expresi@'on. As@'{@dotless{i}}, si se quiere una secuencia de expresiones, se debe hacer

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

siendo el valor que alcance exprn el devuelto por la funci@'on.

Si se quiere hacer un @code{return} desde alguna de las expresiones de la funci@'on, se debe utilizar la estructura  @code{block} junto con @code{return}. Por ejemplo,

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

es una expresi@'on de pleno derecho, por lo que puede ocupar el lado derecho de la definici@'on de una funci@'on. Aqu@'{@dotless{i}} puede ocurrir que el retorno se produzca antes que se alcance la @'ultima expresi@'on.

Los primeros corchetes del bloque (@code{[]}) pueden contener una lista de variables junto con posibles asignaciones, tal como @code{[a: 3, b, c: []]}, lo que provocar@'a que las tres variables @code{a},@code{b} y @code{c} se consideren locales y sean independientes de otras globales con el mismo nombre; las variables locales s@'olo estar@'an activas mientras se ejecute el c@'odigo que est@'a dentro de la estructura @code{block}, o dentro de funciones que son llamadas desde dentro de @code{block}. A esto se le llama asignaci@'on din@'amica, pues las variables sobreviven desde el inicio del bloque hasta que @'este deje de estar operando. Una vez se salga del bloque los valores originales de las variables, si es que los hab@'{@dotless{i}}a, quedan restaurados. Es recomendable proteger las variables de esta forma. Se tendr@'a en cuenta que las asignaciones a las variables del bloque se hacen en paralelo, lo que significa que si como en el ejemplo anterior se hace @code{c: a} en el momento de entrar en el bloque, el valor de @code{c} ser@'a el que ten@'{@dotless{i}}a @code{a} antes de entrar en el bloque, es decir, antes de la asignaci@'on @code{a: 3}. As@'{@dotless{i}}, haciendo lo siguiente


@example
block ([a: a], expr1, ... a: a+3, ..., exprn)
@end example

se prevendr@'{@dotless{i}}a de que el valor externo de @code{a} fuese alterado, pero permitir@'{@dotless{i}}a acceder a @'el desde dentro del bloque. La parte derecha de las asignaciones se eval@'ua dentro de su contexto antes de hacer efectiva la asignaci@'on. Utilizando @'unicamente @code{block([x],..} har@'{@dotless{i}}a que @code{x} se tuviese a s@'{@dotless{i}} misma como valor, justo como si se acabase de iniciar una nueva sesi@'on de Maxima.

Los valores de los argumentos de una func@'on se tratan exactamente de la misma forma que las variables de un bloque. As@'{@dotless{i}}, con

@example
f(x) := (expr1, ..., exprn);
@end example

y

@example
f(1);
@end example

se estar@'{@dotless{i}}a en un contexto similar para la evaluaci@'on de las expresiones como si hubiera hecho

@example
block ([x: 1], expr1, ..., exprn)
@end example

Dentro de las funciones, cuando el lado derecho de la definici@'on deba ser evaluado ser@'a @'util hacer uso de @code{define} y posiblemente de @code{buildq}. 


@node Macros, Definiciones para la definici@'on de funciones, Funciones, Definici@'on de Funciones
@section Macros

@deffn {Funci@'on} buildq (@var{variables}, @var{expr})

El argumento @var{expr} es una expresi@'on de Maxima y @var{variables} es una lista cuyos elementos son de la forma @code{<@'atomo>} o @code{<@'atomo>: <valor>}.

SEM@'ANTICA

Los elementos de la lista @var{variables} son evaluados de izquierda a derecha (la sintaxis @code{@'atomo} es equivalente a @code{@var{@'atomo}: @var{@'atomo}}). Despu@'es estos valores son sustituidos en la expresi@'on en paralelo. Si alg@'un @var{@'atomo} aparece como un argumento simple de la forma especial @code{splice} (por ejemplo,@code{splice (@var{@'atomo})}) dentro de @var{expr}, entonces el valor asociado con ese @var{@'atomo} debe ser una lista de Maxima y ser@'a asociado a @var{expr} en lugar de ser sustitu@'{@dotless{i}}do.

SIMPLIFICACI@'ON

Los argumentos de @code{buildq} deben ser protegidos para evitar su simplificaci@'on hasta que las sustituciones hayan sido llevadas a cabo. Esto se lograr@'a con el uso del ap@'ostrofo @code{'}.

La funci@'on @code{buildq} puede ser @'util para construir funciones sobre la marcha. Uno de los aspectos m@'as potentes de Maxima es que dentro de las funciones se pueden definir otras funciones. M@'as abajo se tratar@'a de la definici@'on de funciones recursivas. La t@'ecnica consistente en definir funciones dentro de funciones hace uso frecuente de @code{define}, la cual eval@'ua sus argumentos. Se presentan algunos ejemplos bajo el ep@'{@dotless{i}}grafe @code{splice}.

@end deffn

@c He recortado parte de esta definición; en el propio texto original
@c inglés se reconoce que se debe redactar con mayor claridad (Mario).
@deffn {Funci@'on} splice (@var{@'atomo})
Se utiliza junto con @code{buildq} para construir una lista. Se utiliza para construir listas de argumentos en conjunci@'on con @code{buildq}.

@example
mprint ([x]) ::= buildq ([u : x],
  if (debuglevel > 3) print (splice (u)));
@end example

Haciendo una llamada como

@example
mprint ("matrix is", mat, "with length", length(mat))
@end example

es equivalente a escribir la l@'{@dotless{i}}nea

@example
if (debuglevel > 3) print ("matrix is", mat, "with length", length(mat));
@end example

Un ejemplo menos trivial es el de retornar los valores de las variables junto con sus nombres,

@example
mshow (a, b, c) 
@end example

resultar@'{@dotless{i}}a en

@example
print ('a, "=", a, ",", 'b, "=", b, ", and", 'c, "=", c)
@end example

de modo que si esto se escribe dentro de un programa se podr@'{@dotless{i}}an imprimir valores.

@example
(%i1) foo (x,y,z) := mshow (x, y, z);
(%i2) foo (1, 2, 3);
x = 1 , y = 2 , and z = 3
@end example

La definici@'on actual de @code{mshow} es como sigue. N@'otese como @code{buildq} permite construir estructuras sin evaluar, de modo que @code{'u} permite obtener el nombre de la variable. En las macros, el resultado es una pieza de c@'odigo que luego ser@'a sustituida por la macro y evaluada.

@example
mshow ([l]) ::= block ([ans:[], n:length(l)],
    for i:1 thru n do
        (ans: append (ans, buildq ([u: l[i]], ['u, "=", u])),
        if i < n then
            ans: append (ans, if i < n-1 then [","] else [", and"])),
    buildq ([u:ans], print (splice(u))));
@end example

La funci@'on @code{splice} tambi@'en vale para colocar argumentos en operaciones algebraicas:

@example
(%i1) buildq ([a: '[b, c, d]], +splice(a));
(%o1)                       d + c + b
@end example

N@'otese c@'omo la simplificaci@'on se lleva a cabo @'unicamente @i{despu@'es} de la sustituci@'on. La operaci@'on que se aplica a @code{splice} en primer lugar es @code{+} mientras que la que se aplica en segundo lugar es @code{*}, aunque pueda parecer que @code{splice(a)+splice(a)} es reemplazable por @code{2*splice(a)}. La no simplificaci@'on se obtiene con @code{buildq}. Para comprender lo que @code{splice} hace con las expresiones algebraicas se debe saber que para Maxima una operaci@'on como @code{a+b+c} internamente es similar a @code{+(a,b,c)}, y que otro tanto ocurre con la multiplicaci@'on. As@'{@dotless{i}}, @code{*(2,b,c,d)} es @code{2*b*c*d}.

@example
(%i1) buildq ([a: '[b,c,d]], +splice(a));
(%o1)                       d + c + b
(%i2) buildq ([a: '[b,c,d]], splice(a)+splice(a));
(%o2)                    2 d + 2 c + 2 b
@end example

pero

@example
(%i3) buildq ([a: '[b,c,d]], 2*splice(a));
(%o3)                        2 b c d
@end example

Finalmente, @code{buildq} puede ser no evaluable en la definici@'on de funciones recursivas.

@end deffn

@node Definiciones para la definici@'on de funciones, , Macros, Definici@'on de Funciones
@section Definiciones para la definici@'on de funciones

@deffn {Funci@'on} apply (@var{f}, [@var{x_1}, ..., @var{x_n}])
Devuelve el resultado de aplicar la funci@'on @var{f} a la lista de argumentos  @var{x_1}, ..., @var{x_n}. El s@'{@dotless{i}}mbolo  @var{f} debe ser el nombre de una funci@'on o de una expresi@'on lambda.

Es @'util en aquellos casos en los que se desea calcular los argumentos de una funci@'on antes de aplic@'arselos a @'esta. Por ejemplo, si @code{l} es la lista @code{[1, 5, -10.2, 4, 3]}, entonces @code{apply (min, l)} devuelve -10.2. La funci@'on @code{apply} es @'util tambi@'en cuando se llama a funciones que a@'un no tienen sus argumentos evaluados y se requiere que s@'{@dotless{i}} lo est@'en. Por ejemplo, si @code{filespec} es una variable cuyo valor es la lista @code{[test, case]} entonces @code{apply (closefile, filespec)}  es equivalente a @code{closefile (test, case)}. En general, el primer argumento de @code{apply} deber@'{@dotless{i}}a ir precedido de un ap@'ostrofo (@code{'}) para que se eval@'ue a s@'{@dotless{i}} mismo. Puesto que algunas variables at@'omicas tienen el mismo nombre que que ciertas funciones, el valor de la variable seer@'{@dotless{i}}a el utilizado antes que el de la funci@'on porque  @code{apply} tiene su dos argumentos evaluados.

@end deffn


@deffn {Funci@'on} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funci@'on} block (@var{expr_1}, ..., @var{expr_n})

La funci@'on @code{block} eval@'ua @var{expr_1}, ..., @var{expr_n} secuencialmente y devuelve el valor de la @'ultima expresi@'on evaluada. La secuencia puede alterarse con las funciones @code{go}, @code{throw} y @code{return}. La @'ultima expresi@'on es @var{expr_n} a menos que @code{return} o una expresi@'on que contenga un @code{throw} sea evaluada. Las variables @var{v_1}, ..., @var{v_m} son locales en el bloque; @'estas se distiguen de las globales que tengan el mismo nombre. Si no se declaran variables locales entonces se puede omitir la lista. Dentro del bloque, cualquier otra variable distinta de @var{v_1}, ..., @var{v_m} se considera global.

La funci@'on @code{block} guarda los valores actuales de las variables @var{v_1}, ..., @var{v_m}, si los tienen, a la entrada del bloque y luego las eval@'ua a s@'{@dotless{i}} mismas, es decir les saca el valor temporalmente. A las variables locales se les puede asignar cualquier valor dentro del bloque, pero al salir de @'este, los valores inicialmente almacenados quedan restaurados, al tiempo que los asignados dentro del bloque se pierden.

Un @code{block} puede aparecer dentro de otro @code{block}. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque. Las variables locales de un bloque se consideran globales dentro de otro anidado dentro del primero. Si una variable es no local dentro de un bloque, su valor es el que le corresponde en el bloque superior. Este criterio se conoce con el nombre de "alcance din@'amico".

Si se quieren guardar y restaurar otras propiedades locales adem@'as del @code{valor} de las variables, por ejemplo @code{array} (excepto arrays completos), @code{function}, @code{dependencies}, @code{atvalue}, @code{matchdeclare}, @code{atomgrad}, @code{constant} y @code{nonscalar} entonces deber@'{@dotless{i}}a usarse la funci@'on @code{local} dentro del bloque, siendo sus argumentos los nombres de las variables.

El valor del bloque es el de la @'ultima sentencia o el argumento de la funci@'on @code{return}, que puede utilizarse para salir del bloque. La funci@'on @code{go} puede usarse para transferir el control a la sentencia del bloque que est@'e etiquetada con el argumento de @code{go}. Para etiquetar una sentencia basta que vaya precedida de un argumento at@'omico como cualquier otra sentencia dentro del bloque. Por ejemplo, @code{block ([x], x:1, tururu, x: x+1, ..., go(tururu), ...)}.  El argumento de @code{go} debe ser el nombre de una etiqueta colocada dentro del bloque. No se puede utilzar @code{go} para trasladarse a una etiqueta de un bloque que no sea el que contenga a @code{go}.

Normalmente los bloques aparecer@'an al lado derecho de las definiciones de funciones, pero tambi@'en pueden utilizarse en otros contextos.

@end deffn

@deffn {Funci@'on} break (@var{expr_1}, ..., @var{expr_n})

Calcula e imprime @var{expr_1}, ..., @var{expr_n} para luego provocar la detenci@'on de Maxima, de modo que el usuario pueda examinar y cambiar el entorno de ejecuci@'on. Pulsando posteriormente @code{exit;} el c@'alculo se reanuda.

@end deffn

@deffn {Funci@'on} catch (@var{expr_1}, ..., @var{expr_n})

Eval@'ua @var{expr_1}, ..., @var{expr_n} una a una;  si alguna de ellas conlleva la evaluaci@'on de una expresi@'on de la forma @code{throw (arg)}, entonces el valor de @code{catch} es el de @code{throw (arg)} y ya no se eval@'uan m@'as expresiones. Esta respuesta pasa todos los niveles de anidamiento hasta el @code{catch} m@'as pr@'oximo. Si no hay ning@'un @code{catch}  que contenga un @code{throw} se emite un mensaje de error.

Si la evaluaci@'on de los argumentos no conlleva la evaluaci@'on de ning@'un @code{throw}, entonces el valor de @code{catch} es el devuelto por @var{expr_n}.

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

La funci@'on @code{g} devuelve las im@'agenes por @code{f} de todos los elementos de la lista @code{l} si @'esta contiene @'unicamente n@'umeros no negativos; si no es este el caso, entonces @code{g} captura el primer negativo que encuentra y lo devuelve por medio del @code{throw}.

@end deffn

@deffn {Function} compfile (@var{nombre_fichero}, @var{f_1}, ..., @var{f_n})

Traduce las funciones de Maxima @var{f_1}, ..., @var{f_n} a c@'odigo Lisp y lo guarda en el fichero @var{nombre_fichero}.

El c@'odigo Lisp traducido no se eval@'ua, ni el fichero de salida es procesado por el compilador de Lisp.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} creates and evaluates Lisp translations.
@code{compile_file} translates Maxima into Lisp, and then executes the Lisp compiler. 

V@'eanse tambi@'en @code{translate}, @code{translate_file} y @code{compile_file}.

@end deffn

@deffn {Funci@'on} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Funci@'on} compile (functions)
@deffnx {Funci@'on} compile (all)

Traduce las funciones de Maxima @var{f_1}, ..., @var{f_n} a Lisp, evaluando el c@'odigo resultante, y llama a la funci@'on Lisp @code{COMPILE} para cada funci@'on traducida. La funci@'on @code{compile} devuelve una lista con los nombres de las funciones compiladas.

Las llamadas @code{compile (all)} o @code{compile (functions)} compilan todas las funciones definidas por el usuario.

La funci@'on @code{compile} no eval@'ua sus argumentos, pero con la colocaci@'on de dos comillas simple (@code{'@w{}'}) s@'{@dotless{i}} lo hace.

@end deffn

@deffn {Funci@'on} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})

Define una funci@'on de nombre @var{f} con argumentos @var{x_1}, ..., @var{x_n} y cuerpo @var{expr}.

@code{define} no eval@'ua su primer argumento en la mayor parte de los casos y eval@'ua su segundo argumento, a menos que vaya precedido de ap@'ostrofo (@code{'}). Sin embargo, si el primer argumento es una expresi@'on de la forma @code{ev (@var{expr})}, @code{funmake (@var{expr})}  o @code{arraymake (@var{expr})}, el primer argumento es evaluado, lo que permite calcular el nombre de la funci@'on junto con su cuerpo.

@code{define} es similar al operador de definici@'on de funciones @code{:=}, pero cuando @code{define} aparece dentro de una funci@'on, la definici@'on se crea usando el valor de @code{expr} en el momento de su ejecuci@'on, en lugar de la que ten@'{@dotless{i}}a en el momento de la definici@'on de la funci@'on que la contiene.

Ejemplos:

@example
(%i1) foo: 2^bar;
                               bar
(%o1)                         2
(%i2) g(x) := (f_1 (y) :=   foo*x*y,
               f_2 (y) := ''foo*x*y,
       define (f_3 (y),     foo*x*y),
       define (f_4 (y),   ''foo*x*y));
                                             bar
(%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y, 
                                                        bar
               define(f_3(y), foo x y), define(f_4(y), 2    x y))
(%i3) functions;
(%o3)                        [g(x)]
(%i4) g(a);
                                    bar
(%o4)                  f_4(y) := a 2    y
(%i5) functions;
(%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
(%i6) dispfun (f_1, f_2, f_3, f_4);
(%t6)                   f_1(y) := foo x y

                                  bar
(%t7)                  f_2(y) := 2    x y

                                    bar
(%t8)                  f_3(y) := a 2    y

                                    bar
(%t9)                  f_4(y) := a 2    y

(%o9)                         done
@end example
@end deffn


@c Parece ser que parte de esta definción está obsoleta; he optado por obviarla (Mario).
@deffn {Funci@'on} define_variable (@var{nombre}, @var{valor_por_defecto}, @var{modo})

Introduce una variable global en el entorno de Maxima. 

La funci@'on @code{define_variable} sigue los siguientes pasos:

@enumerate
@item
@code{mode_declare (@var{nombre}, @var{modo})} declara el modo de @var{nombre} ala traductor. V@'ease en @code{mode_declare} un listado de los posibles modos.

@item
Si la variable no tiene asignado un valor, @var{valor_por_defecto} se le asigna a @var{nombre}.

@item
@code{declare (@var{nombre}, special)} la declara como especial.

@item
Asocia @var{nombre} con una funci@'on test para asegurar que a @var{name} s@'olo se le asignan valores del modo declarado.
@end enumerate

@end deffn

@deffn {Funci@'on} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Funci@'on} dispfun (all)

Muestra la deficni@'on de las funciones de usuario @var{f_1}, ..., @var{f_n}. Cada argumento puede ser el nombre de una macro (definida mediante @code{::=}), una funci@'on ordinaria (definida mediante @code{:=} o @code{define}), una funci@'on array  (definida mediante @code{:=} o @code{define}, pero encerrando los argumentos dentro de corchetes @code{[ ]}), una funci@'on de sub@'{@dotless{i}}ndice (definida mediante @code{:=} o @code{define}, pero encerrando algunos argumentos entre corchetes y otros entre par@'entesis  @code{( )}), una funci@'on de sub@'{@dotless{i}}ndice seleccionada por un sub@'{@dotless{i}}ndice variable, o una funci@'on de sub@'{@dotless{i}}ndice definida con un sub@'{@dotless{i}}ndice constante.

La llamada @code{dispfun (all)} muestra todas las funciones de usuario tal como las dan las listas @code{functions}, @code{arrays} y @code{macros}, omitiendo las funciones con sub@'{@dotless{i}}ndices definidas con sub@'{@dotless{i}}ndices constantes.

La funci@'on @code{dispfun} crea una etiqueta (@code{%t1}, @code{%t2}, etc.) para cada funci@'on mostrada, y asigna la definici@'on de la funci@'on a la etiqueta. En contraste, @code{fundef} devuelve las definiciones de las funciones.

La funci@'on @code{dispfun} no eval@'ua sus argumentos; el operador de doble comilla simple @code{'@w{}'} permite la evaluaci@'on.

La funci@'on @code{dispfun} siempre devuelve @code{done}.

Ejemplos:

@example
(%i1) m(x, y) ::= x^(-y)$
(%i2) f(x, y) :=  x^(-y)$
(%i3) g[x, y] :=  x^(-y)$
(%i4) h[x](y) :=  x^(-y)$
(%i5) i[8](y) :=  8^(-y)$
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8])$
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8
@end example

@end deffn

@defvr {Variable del sistema} functions
Valor por defecto: @code{[]}

La variable @code{functions} es una lista que contiene las funciones definidas por el usuario en la sesi@'on actual. Una funci@'on definida por el usuario es aquella que ha sido construida mediante cualquiera de los m@'etodos @code{define} o @code{:=}. Una funci@'on puede definirse durante una sesi@'on de Maxima o en un fichero que posteriormente ser@'a cargado en memoria por @code{load} o @code{batch}. T@'engase en cuenta que las funciones Lisp no se a@~naden a la lista @code{functions}.

@end defvr

@deffn {Funci@'on} fundef (@var{f})

Devuelve la definici@'on de la funci@'on @var{f}.

Cada argumento puede ser el nombre de una macro (definida mediante @code{::=}), una funci@'on ordinaria (definida mediante @code{:=} o @code{define}), una funci@'on array  (definida mediante @code{:=} o @code{define}, pero encerrando los argumentos dentro de corchetes @code{[ ]}), una funci@'on de sub@'{@dotless{i}}ndice (definida mediante @code{:=} o @code{define}, pero encerrando algunos argumentos entre corchetes y otros entre par@'entesis  @code{( )}), una funci@'on de sub@'{@dotless{i}}ndice seleccionada por un sub@'{@dotless{i}}ndice variable, o una funci@'on de sub@'{@dotless{i}}ndice definida con un sub@'{@dotless{i}}ndice constante.

La funci@'on @code{fundef} no eval@'ua sus argumentos; el operador de doble comilla simple @code{'@w{}'} permite la evaluaci@'on.

La llamada de funci@'on @code{fundef (@var{f})} devuelve la definici@'on de @var{f}. Por el contrario, @code{dispfun (@var{f})} crea una etiqueta intermedia y le asigna la definici@'on a la etiqueta.

@end deffn

@deffn {Funci@'on} funmake (@var{nombre}, [@var{arg_1}, ..., @var{arg_n}])

Devuelve una expresi@'on @code{@var{name} (@var{arg_1}, ..., @var{arg_n})}. El valor as@'{@dotless{i}} retornado es simplificado pero no evaluado, de forma que la funci@'on no es invocada.

La funci@'on @code{funmake} eval@'ua sus argumentos.

Ejemplos:

@itemize @bullet
@item
@code{funmake} eval@'ua sus argumentos, pero no el valor retornado.
@example
(%i1) det(a,b,c) := b^2 -4*a*c$
(%i2) x: 8$
(%i3) y: 10$
(%i4) z: 12$
(%i5) f: det$
(%i6) funmake (f, [x, y, z]);
(%o6)                    det(8, 10, 12)
(%i7) ''%;
(%o7)                         - 284
@end example
@item
Maxima simplifica el valor retornado por @code{funmake}.
@example
(%i1) funmake (sin, [%pi/2]);
(%o1)                           1
@end example
@end itemize

@end deffn

@deffn {Funci@'on} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})

Define y devuelve una expresi@'on lambda (esto es, una funci@'on an@'onima) de argumentos @var{x_1}, ..., @var{x_m} y devuelve el valor de @var{expr_n}. Una expresi@'on lambda puede ser asignada a una variable y evaluada como si fuese una funci@'on ordinaria. Una expresi@'on lambda puede aparecer en contextos en los que sea necesaria la evaluaci@'on de una funci@'on, pero no necesariamente un nombre de funci@'on.

Cuando la funci@'on es evaluada, se crean las variables @var{x_1}, ..., @var{x_m} sin asignaci@'on de valores. Una funci@'on @code{lambda} puede aparecer dentro de otro de un @code{block} o de otra @code{lambda}. Las variables locales se inicializan cada vez que se entra dentro de un nuevo bloque o de otra funci@'on @code{lambda}. Las variables locales se consideran globales dentro de un bloque o funci@'on @code{lambda} anidado dentro del primero. Si una variable es no local dentro de un bloque o funci@'on @code{lambda}, su valor es el que le corresponde en el bloque o funci@'on @code{lambda} superior. Este criterio se conoce con el nombre de "alcance din@'amico".

Una vez establecidas las variables locales @var{expr_1} a @var{expr_n} son secuencialmente evaluadas. La variable especial  @code{%%}, que representa el valor de la expresi@'on inmediata anterior es reconodcida. Las sentencias @code{throw} y @code{catch} pueden aparecer tambi@'en en la lista de expresiones.

La funci@'on @code{return} no puede aparecer en una expresi@'on @code{lambda} a menos que se encuentre acotada dentro de un bloque (@code{block}), en cuyo caso @code{return} establece el valor de retorno de del bloque, pero no de la expresi@'on @code{lambda}, a menos que el bloque resulte ser precisamente @var{expr_n}. De igual manera, @code{go} no puede aparecer en una expresi@'on @code{lambda} si no es dentro de un @code{block}.

Las funciones @code{lambda} no eval@'uan sus argumentos;  el operador de doble comilla simple @code{'@w{}'} permite la evaluaci@'on.

Ejemplo:

@itemize @bullet
@item
Una funci@'on lambda puede asignarse a una variable y evaluada como si fuese una funci@'on ordinaria.
@end itemize
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Una expresi@'on lambda puede aparecer en contextos en los que se espera la evaluaci@'on de una funci@'on.
@end itemize
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Los argumentos son variables locales. Otras variables se consideran globales. Las variables globales son evaluadas en el momento que lo es la expresi@'on, a menos que la evaluaci@'on de las mismas sea forzada, como cuando se hace uso de @code{'@w{}'}.
@end itemize
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Las expresiones lambda pueden anidarse. Las variables locales de expresiones lambda exteriores se consideran globales en expresiones internas, a menos que se enmascaren con variables locales de igual nombre.
@end itemize
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Puesto que @code{lambda} no eval@'ua sus argumentos, la expresi@'on lambda @code{i} de m@'as abajo no define una funci@'on del tipo "multiplar por @code{a}". Tal tipo de funci@'on se puede definir a trav@'es de @code{buildq}, como en la expresi@'on lambda @code{i2} de m@'as abajo.
@end itemize
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@end deffn

@deffn {Funci@'on} local (@var{v_1}, ..., @var{v_n})

Declara las variables  @var{v_1}, ..., @var{v_n} locales respecto de todas las propiedades en la sentencia en la que aparece esta funci@'on.

La funci@'on @code{local} s@'olo puede usarse dentro de un @code{block}, en el cuerpo de definici@'on de funciones o de expresiones @code{lambda} o en la funci@'on @code{ev}, si@'endole permitido aparecer una s@'ola vez en cada una de ellas.

La funci@'on @code{local} es independiente de @code{context}.

@end deffn

@defvr {Variable opcional} macroexpansion
Valor por defecto: @code{false}

La variable @code{macroexpansion} controla aspectos avanzados que afecta a la eficiencia de las macros. Posibles valores:

@itemize @bullet
@item
@code{false} -- Las macros se expanden normalmente cada vez que son invocadas.
@item
@code{expand} -- La primera vez que una funci@'on es llamada, la expansi@'on se mantiene internamente en memoria, de forma que ya no tendr@'a que ser recalculada en siguientes llamadas, haciendo as@'{@dotless{i}} la ejecuci@'on m@'as r@'apida. La llamada a la macro todav@'{@dotless{i}}a sigue usando @code{grind} y @code{display} de la forma habitual. Se requiere memoria extra para recordar todas las expansiones.
@item
@code{displace} -- La primera vez que que una funci@'on es evaluada, la expansi@'on es sustituida por la llamada. Esto requiere menos memoria que cuando a @code{macroexpansion} se le asigna el valor @code{expand} y es igual de r@'apido, pero tiene la desventaja de que la llamada original a la macro ya no se tienen en memoria, por lo que la expansi@'on se ver@'a como si fuese una llamada a @code{display} o a @code{grind}.  V@'ease la documentaci@'on para @code{translate} y @code{macros} para m@'as detalles.
@end itemize

@end defvr

@defvr {Variable opcional} mode_checkp
Valor por defecto: @code{true}

@c WHAT DOES THIS MEAN ??
Cuando @code{mode_checkp} vale @code{true}, @code{mode_declare} chequea los modos de las variables con valores asignados.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variable opcional} mode_check_errorp
Valor por defecto: @code{false}

@c WHAT DOES THIS MEAN ??
Cuando @code{mode_check_errorp} vale @code{true}, @code{mode_declare} llama a error.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Variable opcional} mode_check_warnp
Valor por defecto: @code{true}

@c WHAT DOES THIS MEAN ??
Cuando @code{mode_check_warnp} vale @code{true}, se detallan los errores de modo.
@c NEED SOME EXAMPLES HERE.

@end defvr

@deffn {Funci@'on} mode_declare (@var{y_1}, @var{modo_1}, ..., @var{y_n}, @var{modo_n})

La funci@'on @code{mode_declare} se utiliza para declarar los modos de variables y funciones para la ulterior traducci@'on a Lisp o compilaci@'on de funciones. Se coloca habitualmente al comienzo de la definici@'on de una funci@'on, de un script en Maxima o se ejecuta en tiempo real.

Los argumentos de @code{mode_declare} son pares formados por una variable y un modo, el cual debe ser @code{boolean}, @code{fixnum}, @code{number}, @code{rational} o @code{float}. Cada variable puede ser sustituida por una lista de variables, en cuyo caso todas ellas tendr@'an el mismo modo.

@c aquí me salto un párrafo que no está claro en el original (Mario).

C@'odigo num@'erico que utilice arrays puede ejecutarse m@'as r@'apido declarando el tama@~no que va a ocupar el array, como en:

@example
mode_declare (array (a [10, 10]), float)
@end example

para un array de n@'umeros en coma flotante de dimensiones 10 x 10.

Se puede declarar el modo del resultado de una funci@'on poniendo @code{function (f_1, f_2, ...)} como argumento;
aqu@'{@dotless{i}} @code{f_1}, @code{f_2}, ... son los nombres de las funciones. Por ejemplo, la expresi@'on

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

declara que el valor a devolver por  @code{f_1}, @code{f_2}, ... son enteros de modo "single-word".

El nombre @code{modedeclare} es sin@'onimo de @code{mode_declare}.

@end deffn

@deffn {Funci@'on} mode_identity (@var{arg_1}, @var{arg_2})
Es una forma especial usada con @code{mode_declare} y @code{macros} para declarar, por ejemplo, una lista de listas de n@'umeros. 

@c Elimino aquí un párrafo. Comentario en la versión inglesa: WHAT IS THIS ABOUT ?? (Mario)

@end deffn

@defvr {Variable optativa} transcompile
Valor por defecto: @code{true}

Si @code{transcompile} vale @code{true}, @code{translate} y @code{translate_file} generan declaraciones para hacer el c@'odigo traducido m@'as apto para la compilaci@'on.

La funci@'on @code{compfile} hace la asignaci@'on @code{transcompile: true}.

@end defvr

@deffn {Funci@'on} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Funci@'on} translate (functions)
@deffnx {Funci@'on} translate (all)

Traduce las funciones definidas por el usuario @var{f_1}, ..., @var{f_n} del lenguaje de Maxima a Lisp y eval@'ua las traducciones Lisp. Normalmente las funciones traducidas se ejecutan m@'as rapidamente que las originales.

Las llamadas @code{translate (all)} o @code{translate (functions)} traducen todas las funciones de usuario.

Las funciones a ser traducidas deber@'{@dotless{i}}an incluir una llamada a @code{mode_declare} al comienzo siempre que sea posible, a fin de producir c@'odigo m@'as eficiente. Por ejemplo:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, modo_1, v_2, modo_2, ...), ...)
@end example

@noindent

donde @var{x_1}, @var{x_2}, ... son los par@'ametros que se pasan a la funci@'on y @var{v_1}, @var{v_2}, ... son las variables locales.

Los nombres de las funciones traducidas son eliminados de la lista @code{functions} si @code{savedef} vale @code{false} (ver m@'as abajo) y son a@~nadidos a las listas @code{props}.

Las funciones no deber@'{@dotless{i}}an ser traducidas hasta no estar completamente depuradas.

Se supone que las expresiones est@'an simplificadas; en caso de no estarlo, se generar@'a c@'odigo correcto pero ineficiente. As@'{@dotless{i}}, el usuario no deber@'{@dotless{i}}a asignar a @code{simp} el valor @code{false}, el cual inhibe la simplificaci@'on de la expresi@'on a ser traducida.

Cuando la variable @code{translate} vale @code{true}, se traducen autom@'aticamente las funciones de usuario a Lisp.

N@'otese que las funciones traducidas puede que no se ejecuten exactamente igual a como lo hac@'{@dotless{i}}an antes de la traducci@'on, debido a posibles incompatibilidades entre las versiones de Maxima y Lisp. En general, la funci@'on @code{rat} con m@'as de un argumento y la funci@'on @code{ratvars} no deber@'{@dotless{i}}an utilizarse si algunas de las variables son declaradas como expresiones racionales can@'onicas (CRE) mediante @code{mode_declare}. Adem@'as, la asignaci@'on  @code{prederror: false} no traducir@'a.

Si @code{savedef} vale @code{true}, entonces la versi@'on de Maxima de una funci@'on de usuario permanecer@'a cuando la funci@'on sea traducida por @code{translate}. Con esto se hace posible que se muestre la definici@'on llamando a @code{dispfun} y que la funci@'on sea editada.

Si @code{transrun} vale @code{false} entonces las versiones interpretadas de todas las funciones ser@'an ejecutadas en lugar de las versiones traducidas.

El resultado devuelto por @code{translate} es una lista con los nombres de las funciones traducidas.

@end deffn

@deffn {Funci@'on} translate_file (@var{nombre_fichero_maxima})
@deffnx {Funci@'on} translate_file (@var{nombre_fichero_maxima}, @var{nombre_fichero_lisp})

Traduce un fichero en c@'odigo Maxima a un fichero en c@'odigo Lisp. La funci@'on @code{translate_file} devuelve una lista con los nombres de tres ficheros: el nombre del ficheero en Maxima, el nombre del fichero en Lisp y el nombre del fichero que contiene informaci@'on adicional sobre la traducci@'on. La funci@'on @code{translate_file} eval@'ua sus argumentos.

La llamada @code{translate_file ("foo.mac"); load("foo.LISP")} es lo mismo que @code{batch ("foo.mac")}, excepto por la presencia de ciertas restricciones, como el uso de @code{'@w{}'} y @code{%}, por ejemplo.
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

La llamada @code{translate_file (@var{nombre_fichero_maxima})} traduce un fichero en Maxima, @var{nombre_fichero_maxima}, a otro en Lisp de nombre similar. Por ejemplo, @code{foo.mac} se traduce en @code{foo.LISP}. El nombre del fichero en Maxima puede incluir el nombre de un directorio, en cuyo caso el fichero de salida Lisp se guardar@'a en el mismo directorio desde el que se ley@'o la fuente Maxima.

La llamada @code{translate_file (@var{nombre_fichero_maxima}, @var{nombre_fichero_lisp})} traduce el fichero Maxima  @var{nombre_fichero_maxima} en el fichero Lisp @var{nombre_fichero_lisp}. La funci@'on @code{translate_file} ignora la extensi@'on del fichero, en caso de que exista, de @code{nombre_fichero_lisp}; la extensi@'on del fichero de salida Lisp  ser@'a invariablemente @code{LISP}. El nombre del fichero Lisp puede incluir la ruta del directorio, en cuyo caso se almacenar@'a en el directorio especificado.

La funci@'on @code{translate_file} tambi@'en escribe un fichero de mensajes de avisos del traductor con diversos niveles de gravedad. La extensi@'on de este fichero es @code{UNLISP}. Este fichero puede contener informaci@'on valiosa, aunque de dif@'{@dotless{i}}cil interpretaci@'on, para detectar fallos en el c@'odigo traducido. El fichero @code{UNLISP} se guarda siempre en el mismo directorio desde el que se ley@'o la fuente de Maxima.

La funci@'on @code{translate_file} emite c@'odigo Lisp que incluye algunas declaraciones y definiciones que entran en efecto tan pronto como el c@'odigo Lisp es compilado. V@'ease @code{compile_file} para m@'as informaci@'on sobre este particular.

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
V@'eanse tambi@'en @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared}, 
@code{tr_warn_undefined_variable},
y @code{tr_windy}.

@end deffn

@defvr {Variable optativa} transrun
Valor por defecto: @code{true}

Si @code{transrun} vale @code{false} entonces se ejecutar@'an las versiones interpretadas de todas las funciones, en lugar de las versiones traducidas.

@end defvr

@defvr {Variable optativa} tr_array_as_ref
Valor por defecto: @code{true}

Si @code{translate_fast_arrays} vale @code{false}, referencias de arrays en el c@'odigo Lisp creadas por  @code{translate_file} se ven afectadas por @code{tr_array_as_ref}.

El valor de la variable @code{tr_array_as_ref} no tiene ning@'un efecto cuando @code{translate_fast_arrays} vale @code{true}.

@end defvr

@defvr {Variable optativa} tr_bound_function_applyp
Valor por defecto: @code{true}

Si @code{tr_bound_function_applyp} vale @code{true}, Maxima env@'{@dotless{i}}a un aviso si encuentra una variable con valor asignado que est@'a siendo utilizada como una funci@'on. @code{tr_bound_function_applyp} no influye en el c@'odigo generado bajo estas circunstancias.

Por ejemplo, una expresi@'on como @code{g (f, x) := f (x+1)} provocar@'a un mensaje de esta naturaleza.

@end defvr

@defvr {Variable optativa} tr_file_tty_messagesp
Valor por defecto: @code{false}

Si @code{tr_file_tty_messagesp} vale @code{true}, los mensajes generados por @code{translate_file} durante la traducci@'on de un fichero se muestran en la consola y se insertan en el fichero UNLISP.  Si vale @code{false}, los mensajes sobre la traducci@'on del fichero s@'olo se incorporan al fichero UNLISP.

@end defvr

@defvr {Variable optativa} tr_float_can_branch_complex
Valor por defecto: @code{true}

Le dice al traductor de Maxima a Lisp que las funciones @code{acos}, @code{asin}, @code{asec} y @code{acsc} pueden devolver valores complejos.

@end defvr

@defvr {Variable optativa} tr_function_call_default
Valor por defecto: @code{general}

El valor @code{false} significa llama a @code{meval}, @code{expr} significa que Lisp asign@'o los argumentos de la funci@'on,  @code{general}, el valor por defecto, devuelve c@'odigo apropiado para @code{mexprs} y @code{mlexprs} pero no para @code{macros}. La opci@'on @code{general} asegura que las asignaciones de las variables son correctas en el c@'odigo compilado. En modo @code{general}, cuando se traduce F(X), si F es una variable con valor, entonces se entiende que se quiere calcular @code{apply (f, [x])}, y como tal se traduce, con el apropiado aviso. No es necesario desactivar esto. Con los valores por defecto la falta de mensajes de aviso implica compatibilidad completa entre el c@'odigo traducido y compilado con el interpretado por Maxima.

@end defvr

@defvr {Variable optativa} tr_numer
Valor por defecto: @code{false}

Si @code{tr_numer} vale @code{true} se utilizan las propiedades num@'ericas en aquellos @'atomos que las posean, como en  @code{%pi}.

@end defvr

@defvr {Variable optativa} tr_optimize_max_loop
Valor por defecto: 100

El valor de @code{tr_optimize_max_loop} es el n@'umero m@'aximo de veces que el traductor repetir@'a la macro-expansi@'on y la optimizaci@'on en el tratamiento de una expresi@'on.

@end defvr

@defvr {Variable optativa} tr_semicompile
Valor por defecto: @code{false}

Si @code{tr_semicompile} vale @code{true}, las salidas de @code{translate_file} y @code{compfile} ser@'an macro-expandidas pero no compiladas a c@'odigo m@'aquina por el compilador de Lisp.

@end defvr

@defvr {Variable del sistema} tr_state_vars
Valor por defecto:

@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

Es la lista de variables que afectan la forma en que se obtiene la salida del c@'odigo traducido. Esta informaci@'on es @'util para desarrolladores que pretendan corregir posibles fallos del traductor. Comparando el c@'odigo traducido con el que se deber@'{@dotless{i}}a obtener bajo unas ciertas condiciones, es posible hacer el seguimiento de los fallos.

@end defvr

@deffn {Funci@'on} tr_warnings_get ()

Devuelve una lista con los avisos dados por el traductor.

@end deffn

@defvr {Variable optativa} tr_warn_bad_function_calls
Valor por defecto: @code{true}

Devuelve un aviso cuando se hacen llamadas a funciones que quiz@'as no sean correctas debido a declaraciones inapropiadas realizadas durante la traducci@'on.

@end defvr

@defvr {Variable optativa} tr_warn_fexpr
Valor por defecto: @code{compfile}

Devuelve un aviso si se encuentra con alguna FEXPR. Las FEXPR no deber@'{@dotless{i}}an aparecer en el c@'odigo traducido.

@end defvr

@defvr {Variable optativa} tr_warn_meval
Valor por defecto: @code{compfile}

Devuelve un aviso si la funci@'on @code{meval} es llamada.  Si @code{meval} es invocada, es se@~nal de la presencia de problemas en la traducci@'on.

@end defvr

@defvr {Variable optativa} tr_warn_mode
Valor por defecto: @code{all}

Devuelve un aviso cuando a las variables se les asignan valores incompatibles con su modo.

@end defvr

@defvr {Variable optativa} tr_warn_undeclared
Valor por defecto: @code{compile}

Determina cuando enviar mensajes sobre variables no declaradas.

@end defvr

@defvr {Variable optativa} tr_warn_undefined_variable
Valor por defecto: @code{all}

Devuelve un aviso cuando se detectan variables globales no definidas.

@end defvr

@defvr {Variable optativa} tr_windy
Valor por defecto: @code{true}

Genera comentarios de ayuda y consejos sobre programaci@'on.

@end defvr

@deffn {Funci@'on} compile_file (@var{nombre_fich})
@deffnx {Funci@'on} compile_file (@var{nombre_fich}, @var{nombre_fich_compilado})
@deffnx {Funci@'on} compile_file (@var{nombre_fich}, @var{nombre_fich_compilado}, @var{nombre_fich_lisp})

Traduce el fichero Maxima @var{nombre_fich} a Lisp, ejecuta el compilador de Lisp y, en caso de ser exitosa la compilaci@'on, carga el c@'odigo compilado en Maxima.

La funci@'on @code{compile_file} devuelve una lista con los nombres de tres ficheros: el fichero original en Maxima, la traducci@'on Lisp, notas sobre la traducci@'on y el c@'odigo compilado. Si la compilaci@'on falla, el cuarto elemento es  @code{false}.

Algunas declaraciones y definiciones entran en efecto tan pronto como el c@'odigo Lisp es compilado (sin cargar el c@'odigo compilado). @'Estas incluyen funciones definidas con el operador @code{:=}, macros definidas con el operador @code{::=}, @code{alias}, @code{declare}, @code{define_variable},  @code{mode_declare} y @code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix} y @code{compfile}.

Asignaciones y llamadas a funciones no se eval@'uan hasta que el c@'odigo compilado es cargado. En particular, dentro del fichero Maxima, asignaciones a los controles ("flags") de traducci@'on (@code{tr_numer}, etc.) no tienen efecto durante la traducci@'on.

El @var{nombre_fich} no puede contener sentencias del tipo @code{:lisp}.

La funci@'on @code{compile_file} eval@'ua sus argumentos.

@end deffn


@deffn {Funci@'on} declare_translated (@var{f_1}, @var{f_2}, ...)

Cuando se traduce un fichero de c@'odigo Maxima a Lisp, es importante para el traductor saber qu@'e funciones de las que est@'an en el fichero van a ser llamadas como traducidas o compiladas, y cu@'ales son simplemente funciones Maxima o que no est@'an definidas. Se genera el c@'odigo @code{(MFUNCTION-CALL fn arg1 arg2 ...)} cuando el traductor no sabe si fn va a ser una funci@'on lisp.

@end deffn
