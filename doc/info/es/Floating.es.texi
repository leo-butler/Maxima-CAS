@menu
* Definiones para aritm@'etica de punto flotante::
@end menu

@node Definiones para aritm@'etica de punto flotante, , Aritm@'etica de punto flotante, Aritm@'etica de punto flotante

@section Definiones para aritm@'etica de punto flotante

@c FOLLOWING FUNCTIONS IN bffac.mac ARE NOT DESCRIBED IN .texi FILES: !!!
@c obfac, azetb, vonschtoonk, divrlst, obzeta, bfhzeta, bfpsi0 !!!
@c DON'T KNOW WHICH ONES ARE INTENDED FOR GENERAL USE !!!

@c FOLLOWING FUNCTIONS IN bffac.mac ARE DESCRIBED IN Number.texi: !!!
@c burn, bzeta, bfzeta !!!

@c FOLLOWING FUNCTIONS IN bffac.mac ARE DESCRIBED HERE: !!!
@c bfpsi, bffac, cbffac !!!

@defun bffac (expr, n)

La versi@'on Bigfloat de la funci@'on factorial (Gamma desplazada). El segundo argumento consiste en cu@'antos d@'{@dotless{i}}gitos conservar y retornar, es una buena idea para solicitar un par adicional. 

Esta funci@'on est@'a disponible haciendo @code{load ("bffac")}. 

@end defun


@defvar algepsilon

El valor por defecto es 10^-8. 

El valor de @code{algepsilon} es usado por @code{algsys}

@end defvar

@defun bfloat (x)

Convierte todos los n@'umeros y  funciones num@'ericas a n@'umeros de punto flotante grandes. Configurando @code{fpprec} a un valor @code{n}, configurar@'a la  precisi@'on de los n@'umeros flotantes grandes a @code{n} d@'igitos. Si @code{float2bf} es @code{false} un mensaje de advertencia ser@'a impreso cuando un n@'umero de punto flotante es convertido en un numero flotante grande (Pues a partir de esto se puede perder precisi@'on). 

@end defun

@defun bfloatp (exp)

Retorna @code{true} si exp es un n@'umero flotante grande, sino devuelve @code{false}.

@end defun

@defun bfpsi (n, z, fpprec)
@defunx bfpsi0 (z, fpprec)

@code{bfpsi} es la funci@'on poligamma de un argumento real @var{z} y un entero de orden @code{n}. 
@code{bfpsi0} es la funci@'on digamma. 
@code{bfpsi0 (z, fpprec)} es equivalente a @code{bfpsi (0, z, fpprec)}. 

Estas funciones retornan valores de punto flotante grande. 
@var{fpprec} es la presici@'on de punto flotante grande para el valor
retornado. 

@c psi0(1) = -%gamma IS AN INTERESTING PROPERTY BUT IN THE ABSENCE OF ANY OTHER
@c DISCUSSION OF THE PROPERTIES OF THIS FUNCTION, THIS STATEMENT SEEMS OUT OF PLACE.
@c Note @code{-bfpsi0 (1, fpprec)} provides @code{%gamma} (Euler's constant) as a bigfloat.

Esta funci@'on est@'a disponible haciendo @code{load ("bffac")} 

@end defun

@defvar bftorat 

Por defecto: @code{false}.

@code{bftorat} controla la conversi@'on de bfloats (es decir n@'umeros de punto flotante grandes) a n@'umeros racionales. 
Cuando @code{bftorat} es @code{false}
@code{ratepsilon} ser@'a usada para controlar las conversiones (esto resulta relativo con n@'umeros racionales peque@~nos).
Cuando @code{bftorat} es @code{true}, los n@'umeros racionales generados ser@'an representados exactamente por @code{bfloat}. 

@end defvar

@defvar BFTRUNC

Valor por defecto: @code{true} 

@code{bftrunc} causa un arrastre de ceros en n@'umeros flotantes grandes cuyos ceros no son mostrados. As@'{@dotless{i}}, si @code{vftrunc} es @code{falso}, @code{bfloat (1)} es mostrado como @code{1.000000000000000B0}. De otra manera, este es mostrado como @code{1.0B0}.

@end defvar

@defun CBFAC (z,fpprec)

Un factorial para n@'umeros complejos de punto flotante grandes. 

Esta funci@'on  puede ser usada  haciendo @code{load("bffac")}. 

@end defun

@defun float (exp)

Convierte  n@'umeros enteros, racionales y flotantes grandes (bigfloats) contenidos en @code{exp} a n@'umeros de coma flotante. Es tambi@'en un @code{evflag}, @code{float} causa n@'umeros racionales y bigfloats no integrables al ser convertidos en n@'umeros de coma flotante.  

@end defun

@defvar float2bf
 
Valor por defecto: @code{false}.

Cuando @code{float2bf} es @code{false}, un mensaje de advertencia es impreso cuando un  n@'umero de coma flotante es convertido en un n@'umero flotante grande(bigfloat)(A partir de esto puede perder precisi@'on).
@end defvar

@c Parece que es una función que fue removida. 

@c @defun FLOATDEFUNK

@c Es una utilidad para realizar funciones de puntos flotantes a partir expresiones matem@'aticas. Esto puede tomar la expresi@'on de entrada y el FLOTANTE,
@c entonces (OPTIMIZE) OPTIMIZARLO, y luego ingresar MODE_DECLAREations para todas las variables.
@c Esta es la manera para usar ROMBERG, PLOT2, INTERPOLATE, etc. e.g.
@c EXP:Alguna-expresi@'on-dif@'{@dotless{i}}cil-macsyma;

@c @example
@c FLOATDEFUNK('F,['X],EXP);
@c @end example
@c Podr@'a definir la funci@'on F(x) para usted.
@c (Realice PRINTFILE(MCOMPI,DOC,MAXDOC); para m@'as detalles.)

@c @end defun

@defun floatnump (exp)

retorna @code{true} si @code{exp} es un n@'umero de punto flotante, de otra manera retorna @code{false}.

@end defun

@defvar fpprec
Valor por defecto: [16]

@code{fpprec} es la presici@'on para n@'umeros de punto flotante en Maxima (Floating Point PRECision). @code{fpprec} puede ser programada a un entero,el cual representa la precisi@'on requerida.

@end defvar

@defvar fpprintprec
Valor por defecto: 0

@code{fpprintprec} es el n@'umero de digitos a imprimir cuando se esta imprimiendo un n@'umero de punto flotante grande (bigfloat), haciendo posible computarlo con un gran n@'umero de d@'{@dotless{i}}gitos de precisi@'on, pero la respuesta es impresa con un peque@~no n@'umero de @'{@dotless{i}}gitos.  S@'{@dotless{i}} @code{fpprintprec} es 0 (por defecto), o >= que @code{fpprec}, entonces el valor de @code{fpprec} controla el n@'umero de d@'{@dotless{i}}gitos usados para imprimir.  Sin embargo, si @code{fpprintprec} tiene un valor entre 2 y @code{fpprec-1}, entonces controlar@'a el n@'umero de digitos usado.  (El m@'{@dotless{i}}nimo n@'umero de d@'{@dotless{i}}gitos usado es 2, uno a la izquierda del punto y otro a la derecha.  El valor 1 para @code{fpprintprec} es ilegal.)
@end defvar

@deffn {Funci@'on Lisp} ?round (x)
@deffnx {Funci@'on Lisp} ?round (x, divisor)


Redondea el punto flotante @code{x} al entero m@'as cercano.  El argumento debe ser n@'umero de punto flotante regular, no un n@'umero de punto flotante grande (bigfloat).  El @code{?} al comienzo del nombre indica que esto es una funci@'on Lisp.

@example
(%i1) ?round (-2.8);
(%o1)                            - 3
@end example

@end deffn

@deffn {Lisp function} ?truncate (x)
@deffnx {Lisp function} ?truncate (x, divisor)

lleva el punto flotante @code{x} hacia 0, para ser un entero. El argumento debe ser n@'umero de punto flotante regular, no un n@'umero de punto flotante grande (bigfloat).  El @code{?} al comienzo del nombre indica que esto es una funci@'on Lisp.

@example
(%i1) ?truncate (-2.8);
(%o1)                            - 2
(%i2) ?truncate (2.4);
(%o2)                             2
(%i3) ?truncate (2.8);
(%o3)                             2
@end example

@end deffn

