@menu
* Definiciones para Afines::      
@end menu

@node Definiciones para Afines,  , Afines, Afines

@section Definiciones para Afines

@defun FAST_LINSOLVE (eqns,variables)

Soluciona los sistemas de ecuaciones lineales
EQNS para las variables VARIABLES y retorna un resultado adecuado
para SUBLIS. La funci@'on es m@'as r@'apida que linsolve para sistemas de ecuaciones 
que est@'an dispersos.

@end defun

@defun GROBNER_BASIS (eqns)

Toma como argumento un lista de ecuaciones de macsyma
y retorna una grobner basis de ellos. La funci@'on POLYSIMP puede ahora
ser usada para simplificar otras funciones relativas a las ecuaciones.

GROBNER_BASIS([3*X^2+1,Y*X])$

POLYSIMP(Y^2*X+X^3*9+2)==> -3*x+2

Polysimp(f)==> 0 si y solo si f est@'a en el ideal generado por el EQNS ie.
si y solo si f es una combinaci@'on polinomial de los elementos de EQNS.

@end defun

@defun SET_UP_DOT_SIMPLIFICATIONS (eqns,[check-thru-degree])

Las eqns son
ecuciones polinomiales en variables no conmutativas.
El valor de CURRENT_VARIABLES es la
lista de variables usado para el computo de grados. La ecuaci@'on debe ser
homog@'enea, en orden para el procedimiento para terminar.

Si usted ha revisado la simplificaci@'on superpuesta en DOT_SIMPLIFICATIONS
anteriormente los grados de f, entonces lo siguiente es verdad:
DOTSIMP(f)==> 0 si y solo si f est@'a en el ideal generado por el EQNS ie.
si y solo si f es una combinaci@'on polinomial de los elementos de EQNS.

Los grados que son retornados por NC_DEGREE. Este en ocasiones es influenciado por
el peso de las variables individuales.

@end defun

@defun DECLARE_WEIGHT (var1,wt1,var2,wt2,...)

Asigna a VAR1 el peso de WT1, VAR2 peso a wt2..
Estos son los pesos usados en el computo NC_DEGREE.

@end defun

@defun NC_DEGREE (poly)

Grados de un polinomio no conmutativo. Observe DECLARE_WEIGHTS.

@end defun

@defun DOTSIMP (f)

==> 0 si y solo si f est@'a en el ideal generado por el EQNS ie.
si y solo si f es una combinaci@'on polinomial de los elementos de EQNS.

@end defun

@defun FAST_CENTRAL_ELEMENTS (variables,degree)

si SET_UP_DOT_SIMPLIFICATIONS ha sido realizada con anterioridad, busca el polinomio central 
en las variables en el grado dado,
Por ejemplo:
@example
set_up_dot_simplifications([y.x+x.y],3);
fast_central_elements([x,y],2);
[y.y,x.x];
@end example
@end defun

@defun CHECK_OVERLAPS (degree,add-to-simps)

revisa la superposici@'on a trav@'es de grados,
asegurandose que usted tiene suficientes reglas de simplificaci@'on en cada
grqado, para que dotsimp trabaje correctamente.Este proceso puede se acelerado
si usted conoce antes de tomar cual es la dimensi@'on del espacio monomial.
Si este es de dimensiones globales finitas, entonces HILBERT podr@`a se usado. Si usted
no conoce la dimensi@`on monomial, no especifique una RANK_FUNCTIION.
Un tercer argumento opcional es RESET, falsamente dice que no se preocupe en dudar
acerca de resetear cosas.

@end defun

@defun MONO (vari,n)

VARI es una lista de variables. Retorna la lista demonomios relativos 
independientes para la actual dot_simplifications, en N grados

@end defun

@defun MONOMIAL_DIMENSIONS (n)

Computa las series de hilbert a trav@'es de n grados para el algebra actual.

@end defun

@defun EXTRACT_LINEAR_EQUATIONS (List_nc_polys,monoms)

Hace una lista de los coeficientes de los polinomios en list_nc_polys
de los monomios. MONOMS es una lista de monomios no-conmutativos. Los
coeficientes pueden ser escalares. Use LIST_NC_MONOMIALS para construir la lista de
monomios.

@end defun

@defun LIST_NC_MONOMIALS (polys_or_list)

retorna  una lista de monomios no-conmutativos ocurriendo en un polinomio
o una colecci@'on de polinomios.

@end defun

@defun PCOEFF (poly monom [variables-to-exclude-from-cof (list-variables monom)])

Este funci@'on es llamada desde el nivel lisp, y usa el formato poly interno.
@example

CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))
(#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))

CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))
(#:U 1 1)
@end example
@noindent

Regla: si una variable aparece en un monomio  esta debe ser una potencia exacta,
y si esta est@'a en variables a excluir esta no debe aparecer a menos que esta estuviera
en monomio de potencia exacta.  (pcoeff pol 1 ..) excluir@'a variables
como substituyendolas por cero.

@end defun

@defun NEW-DISREP (poly)

Desde lisp este retorna el formato general de maxima para un argumento el cual est@'a
en la forma st-rat:

@example
(displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))

       2
Y + U X  + 1

@end example
@end defun

@defun CREATE_LIST (form,var1,list1,var2,list2,...)

Crea una lista mediante la evaluaci@`on de FORM con el limite VAR1
hasta cada elemento de LIST1, y para cada ribete enlazado VAR2
para cada elemento de LIST2..
El n@'umero de elementos en el resultado ser@'a
longitud(lista1)*longitus(lista2)*...
Cada VAR debe actualemtne ser un s@'{@dotless{i}}mbolo el cual no ser@'a evaluado.
Los argumentos LIST ser@'an evaluados desde el inicio de la
iteraci@'on.

@example

(C82) create_list1(x^i,i,[1,3,7]);
(D82) [X,X^3,X^7]
@end example
@noindent

Con una iteraci@'on doble:
@example
(C79) create_list([i,j],i,[a,b],j,[e,f,h]);
(D79) [[A,E],[A,F],[A,H],[B,E],[B,F],[B,H]]
@end example

En vez de la LIST de dos argumentos puede ser suplida cada cual debe
evaluar un n@'umero. Estos ser@'an incluso los limites inferior y superior
de la iteraci@'on.

@example
(C81) create_list([i,j],i,[1,2,3],j,1,i);
(D81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]
@end example

Note que el limite o la lista de la variable j puede
depender del avalor actual de i.


@end defun

@defvar ALL_DOTSIMP_DENOMS

Si su valor es FALSO el denominador encontrado en obtenci@'on
dotsimp no ser@'an coleccionadas. Para coleccionar los denominadores
@example
ALL_DOTSIMP_DENOMS:[];
@end example
@noindent
y ellos ser@'an nconc'd sobre el final de la lista.

@end defvar



