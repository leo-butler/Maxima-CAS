@c english version 1.39
@menu
* Introducci@'on a la L@'{@dotless{i}}nea de Comandos::  
* Definiciones para  la L@'{@dotless{i}}nea de Comandos::  
@end menu

@node Introducci@'on a la L@'{@dotless{i}}nea de Comandos, Definiciones para la L@'{@dotless{i}}nea de Comandos, L@'{@dotless{i}}nea de Comandos, L@'{@dotless{i}}nea de Comandos

@section Introducci@'on a la L@'{@dotless{i}}nea de Comandos

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!

@deffn {Operador} "'"

El operador comilla sencilla @code{'} evita la evaluaci@'on. 

Aplicado a un s@'{@dotless{i}}mbolo, 
la comilla sencilla evita la evaluaci@'on del s@'{@dotless{i}}mbolo. 

Aplicado a la llamada de una funci@'on,
la comilla sencilla evita la evaluaci@'on de la funci@'on llamada,
aunque los argumentos de la funci@'on son evaluados (siempre y cuando 
la evaluaci@'on no se evite de otra manera). 
El resultado es una forma de nombre de la funci@'on llamada.  

Aplicado a una expresi@'on con par@'entesis, 
la comilla simple evita la evaluaci@'on de todos los s@'{@dotless{i}}mbolos y llamadas a funciones que hayan en la expresi@'on. 
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
E.g., @code{'(f(x))} significa que no se evalua la expresi@'on @code{f(x)}. 
@code{'f(x)} (con la comilla simple aplicada a @code{f} en cambio de a @code{f(x)})
significa el retorno de la forma de nombre de @code{f} aplicada a @code{[x]}. 

La comilla simple no evita la simplificaci@'on. 

Cuando el interruptor global @code{noundisp} es @code{true}, 
los nombres se muestran con una comilla simple. 
Este interruptor siempre tiene como valor @code{true} cuando 
se muestran definiciones de funciones. 

Ver tambi@'en los operadores comilla-comilla @code{''} y @code{nouns}. 

Ejemplos:

Aplicado a un s@'{@dotless{i}}mbolo, 
la comilla sencilla evita la evaluaci@'on del s@'{@dotless{i}}mbolo. 

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Aplicado a la llamada de una funci@'on,
la comilla sencilla evita la evaluaci@'on de la funci@'on llamada,
aunque los argumentos de la funci@'on son evaluados (siempre y cuando 
la evaluaci@'on no se evite de otra manera). 
El resultado es una forma de nombre de la funci@'on llamada.  

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Aplicado a una expresi@'on con par@'entesis, 
la comilla simple evita la evaluaci@'on de todos los s@'{@dotless{i}}mbolos y llamadas a funciones que hayan en la expresi@'on. 

@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

La comilla sencilla no evita la simplificaci@'on. 

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@end deffn

@deffn {Operador} "
El operador comilla-comilla @code{'@w{}'} (dos comillas simples) modifica la evaluaci@'on
en las expresiones de entrada.

Aplicado a cualquier expresi@'on general @var{expr}, las dos comillas simples hacen que
el valor de @var{expr} sea sustituido por @var{expr} en la expresi@'on de entrada.

Aplicado al operador de una expresi@'on, el operador comilla-comilla hace que el operador
pase de ser un nombre a ser un verbo, a menos que ya sea un verbo.

El operador comilla-comilla es aplicado por el analizador sint@'actico de entrada;
no se almacena como una parte de la expresi@'on de entrada analizada.
Este operador se aplica siempre tan pronto como es detectado y no puede ser comentado con
una comilla simple. De esta manera, el operador comilla-comilla provoca la evaluaci@'on de
una expresi@'on cuando @'esta no estaba previsto que fuese evaluada, como en la
definici@'on de funciones, expresiones lambda y expresiones comentadas con una comilla simple
@code{'}.

El operador comilla-comilla es reconocido tanto por @code{batch} como por @code{load}.

V@'eanse tambi@'en el operador comilla simple @code{'} y @code{nouns}.

Ejemplos:

Aplicado a cualquier expresi@'on general @var{expr}, las dos comillas simples hacen que
el valor de @var{expr} sea sustituido por @var{expr} en la expresi@'on de entrada.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Aplicado al operador de una expresi@'on, el operador comilla-comilla hace que el operador
pase de ser un nombre a ser un verbo, a menos que ya sea un verbo.

@c ===beg==
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

El operador comilla-comilla es aplicado por el analizador sint@'actico de entrada;
no se almacena como una parte de la expresi@'on de entrada analizada.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

El operador comilla-comilla provoca la evaluaci@'on de
una expresi@'on cuando @'esta no estaba previsto que fuese evaluada, como en la
definici@'on de funciones, expresiones lambda y expresiones comentadas con una comilla simple
@code{'}.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@end deffn

@node Definiciones para la L@'{@dotless{i}}nea de Comandos,  , Introducci@'on a la L@'{@dotless{i}}nea de Comandos, L@'{@dotless{i}}nea de Comandos

@section Definiciones para la L@'{@dotless{i}}nea de Comandos

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Funci@'on} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
provee un nombre
alternativo para una (bien sea definida por el usuario o por el sistema) funci@'on, variable, arreglo, etc. 
Cualquier n@'umero par de argumentos puede ser usado. 

@end deffn

@defvr {Variable opcional} debugmode
Valor por defecto: @code{false}

Cuando en Maxima ocurre un error, Maxima inicializar@'a el depurador si @code{debugmode} tiene el valor @code{true}. 
El usuario puede ingresar comandos para examinar la pila de llamadas, los puntos de interrupci@'on; en pocas palabras ir a trav@'es del c@'odigo de Maxima. Vea @code{debugging} para una lista de los comandos del depurador.  

Habilitando @code{debugmode} no se capturar@'an los errores tipo Lisp. 

@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!

@deffn {Funci@'on} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Evalua la expresi@'on @var{expr} en el entorno especificado
por los argumentos @var{arg_1}, ..., @var{arg_n}.
Los argumentos son interruptores (Variables Booleanas), variables de
asignaci@'on, ecuaciones y funciones. 
@code{ev} retorna el resultado (otra expresi@'on) de la evaluaci@'on. 

La evaluaci@'on se realiza por etapas, como sigue: 

@enumerate
@item
Primero se configura el entorno de acuerdo a los argumentos los
cuales pueden ser algunos o todos de la siguiente lista:  

@itemize @bullet
@item
@code{simp} causa que @var{expr} sea simplificada sin importar el valor de la variable interruptor @code{simp} la cual inhibe la simplificaci@'on cuando su valor es @code{false}. 
@item
@code{noeval} suprime la fase de evaluaci@'on de @code{ev} (Vea el paso (4) m@'as adelante). 
Esto es muy @'util en conjunci@'on con otras variables interruptor y causan en @var{expr} que sea resimplificada sin ser reevaluada. 
@item
@code{nouns} causa que la evaluaci@'on de las formas de nombre
(t@'{@dotless{i}}picamente funciones sin evaluar tales como @code{'integrate} or @code{'diff}) en @code{expr}. 
@item
@code{expand} causa expansi@'on. 
@item
@code{expand (@var{m}, @var{n})} causa expansi@'on, asignando los valores de @code{maxposex} y
@code{maxnegex} a @var{m} y @var{n}, respectivamente.
@item
@code{detout} hace que cualesquiera matrices inversas calculadas en @var{expr} conserven su determinante fuera de la inversa, en vez de que divida a cada elemento.  
@item
@code{diif} realiza todas las diferenciaciones indicadas en @var{expr}. 
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} realiza s@'olo las diferenciaciones con respecto a las variables indicadas. 
@item
@code{float} provoca la conversi@'on de los n@'umeros racionales no-enteros a n@'umeros decimales de coma flotante. 
@item
@code{numer} causa que algunas funciones matem@'aticas (incluyendo potenciaci@'on) con argumentos num@'ericos sean evaluados como punto flotante. Esto causa que las variables en @var{expr} las cuales hayan sido declaradas como variables num@'ericas sean reemplazadas por sus respectivos valores. Esto tambi@'en configura la variable interruptor @code{float} a @code{true}. 
@item
@code{pred} provoca la evaluaci@'on de los predicados (expresiones las cuales se evaluan a @code{true} o @code{false}). 
@item
@code{eval} provoca una post-evaluaci@'on extra de @var{expr} (v@'ease el paso (5) m@'as adelante), pudiendo aparecer
@code{eval} varias veces; por cada aparici@'on de @code{eval}, la expresi@'on es reevaluada.
@item
@code{A}, donde @code{A} es un @'atomo declarado como una variable de tipo interruptor, (Vea @code{evflag})
causa que @code{A} tenga como valor @code{true} durante 
la evaluaci@'on de @var{expr}.  
@item
@code{V: expresion} (o alternativamente @code{V=expresion}) causa que 
@code{V} tenga el valor de @code{expresion} durante la evaluaci@'on
de @var{expr}. Notese que si @code{V} es una opci@'on Maxima, entonces
@code{expresion} se usa como su valor durante la evaluaci@'on de
@var{expr}. Si m@'as de un argumento de @code{ev} es de este 
tipo entonces el v@'{@dotless{i}}nculo se hace en paralelo. Si @code{V} es una
expresi@'on no at@'omica entonces se hace una sustituci@'on m@'as que 
un v@'{@dotless{i}}nculo.
@item
@code{F} donde @code{F}, un nombre de funci@'on, ha sido declarado para 
ser una funci@'on de evaluaci@'on (Vea @code{evfun}) causa que
@code{F} sea aplicada a @var{expr}. 
@item
Cualquier otro nombre de funci@'on (e.g., @code{sum}) causa la evaluaci@'on de las ocurrencias de esos nombres en @code{expr} como si ellos fueran
verbos. 
@item
En adici@'on de que una funci@'on ocurra en @var{expr} (digamos @code{F(x)}) puede ser definida localmente para el prop@'osito de esta evaluaci@'on 
de @var{expr} pasando @code{F(x) := expresion} como un argumento a
@code{ev}. 
@item
Si un @'atomo no mencionado anteriormente o una variable o expresi@'on 
con sub@'{@dotless{i}}ndices fueran pasadas como un argumento, esta es evaluada y
si el resultado es una ecuaci@'on o una asignaci@'on entonces el 
v@'{@dotless{i}}nculo o sustituci@'on se llevar@'a a cabo. Si el resultado es una
lista entonces los miembros de la lista tratados como si ellos fueran
argumentos adicionales pasados a @code{ev}. Esto permite que una
lista de argumentos sea pasada (e.g., @code{[X=1, Y=A**2]}) o una lista
de nombres de ecuaciones (e.g., @code{[%t1, %t2]} donde @code{%t1} y
@code{%t2} son ecuaciones) tal como lo que es retornado por 
@code{solve}. 
@end itemize

Los argumentos de @code{ev} pueden ser pasados en cualquier orden con excepci@'on de la sustituci@'on de ecuaciones las cuales son manipuladas en 
secuencia, de izquierda a derecha y las funciones de evaluaci@'on las 
cuales son compuestas, e.g., @code{ev (@var{expr}, ratsimp, realpart)}
es manipulada como @code{realpart (ratsimp (@var{expr}))}. 

Los interruptores @code{simp}, @code{numer}, @code{float} y @code{pred} 
pueden tambi@'en ser configurados localmente en una sentencia block, o
globalmente en Maxima para que su efecto permanezca hasta que
sean reconfiguradas.   

Si @var{expr} es una Expresi@'on Racional Can@'onica (CRE, por sus siglas en ingl@'es), entonces la expresi@'on retornada por @code{ev} es tambi@'en 
de tipo CRE, siempre que los interruptores @code{numer} y @code{float} no sean @code{true}. 

@item
Durante el paso (1), se fabrica una lista de las variables que no contienen sub@'{@dotless{i}}ndices que aparecen en el lado izquierdo de las ecuaciones en los
argumentos o en el valor de algunos argumentos si el valor es una ecuaci@'on. Las variables (variables que contienen sub@'{@dotless{i}}ndices las cuales no tienen asociado un arreglo de funciones como tambi@'en las variables que no contienen sub@'{@dotless{i}}ndices) en la expresi@'on @var{expr} son reemplazadas por sus valores globales, excepto por aquellos que aparezcan en esa lista. 
Usualmente, @var{expr} es s@'olo una etiqueta o un @code{%} 
(como en @code{%i2} en el ejemplo de m@'as abajo) as@'{@dotless{i}} que 
este paso simplemente recupera la expresi@'on a la que hace referencia 
la etiqueta y as@'{@dotless{i}} @code{ev} puede trabajarla. 

@item
Si algunas sustituciones son indicadas por los argumentos, ellas
ser@'an llevadas a cabo ahora. 

@item
La expresi@'on resultante es tambi@'en reevaluada (a menos que uno de 
los argumentos fuese @code{noeval}) y simplificada de acuerdo a los 
argumentos. Notese que cualquier llamada a una funci@'on en @var{expr} 
ser@'a llevada a cabo despu@'es de que las variables sean evaluadas 
en ella y que @code{ev(F(x))} pueda comportarse como @code{F(ev(x))}. 

@item
Por cada aparici@'on de @code{eval} en los argumentos, se repetir@'an los pasos (3) y (4).
@end enumerate

Ejemplos

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Una sintaxis alternativa de alto nivel ha sido proveida para @code{ev}, 
por medio de la cual uno puede escribir solamente sus argumentos, sin 
el comando @code{ev()}. Esto es, una forma sencilla de escritura:

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Esto no es permitido como parte de otra 
expresi@'on , e.g., en funciones, sentencias block, etc. 

N@'otese el proceso de v@'{@dotless{i}}nculo en paralelo en el siguiente ejemplo:

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Soluci@'on

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn



@defvr {Propiedad} evflag
Algunos interruptores booleanos tienen la propiedad @code{evflag}. 
@code{ev} trata de forma especial tales interruptores. 
Un interruptor con la propiedad @code{evflag} ser@'a puesto a @code{true}
durante la ejecuci@'on de @code{ev} si este es mencionado en la 
llamada a @code{ev}. 
Por ejemplo, @code{demoivre} y @code{ratfac} son puestos a @code{true} durante la llamada a @code{ev (%, demoivre, ratfac)}. 

Los interruptores que tienen la propiedad @code{evflag} son: 

@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand}, y
@code{trigexpand}.

La instrucci@'on @code{:lisp (putprop '|$foo| t 'evflag)}
da la propiedad @code{evflag} a la variable @code{foo}, 
as@'{@dotless{i}} que @code{foo} es puesta a @code{true} durante la llamada a
@code{ev (%, foo)}. 
De forma equivalente, @code{ev ($, foo:true)} tiene el mismo efecto. 
@end defvr

@defvr {Propiedad} evfun
Algunas funciones tienen la propiedad @code{evfun}.
@code{ev} trata tales funciones de forma especial. 
Una funci@'on con la propiedad @code{evfun} ser@'a aplicada 
durante la ejecuci@'on de @code{ev} si @'esta es mencionada 
en la llamada a @code{ev}. 
Por ejemplo, @code{ratsimp} y @code{radcan} ser@'an aplicadas 
durante la llamada a @code{ev (%, ratsimp, radcan)}.

Las funciones que tienen la propiedad @code{evfun} son: 

@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, y
@code{trigreduce}.

La instrucci@'on @code{:lisp (putprop '|$foo| t 'evfun)}
da la propiedad @code{evfun} a la funci@'on @code{foo}, 
as@'{@dotless{i}} que @code{foo} es aplicada durante la llamada a @code{ev (%, foo)}. 
De forma equivalente, @code{foo (ev(%))} tiene el mismo efecto.  
@end defvr

@c NEEDS WORK
@defvr {Variable opcional} infeval
Habilita el modo de "evaluaci@'on infinita". @code{ev} repetidamente 
evalua una expresi@'on hasta que se interrumpa la acci@'on. Para prevenir
que una variable, digamos @code{X}, sea evaluada sin parar en este modo, 
simplemente incluya @code{X='X} como argumento de @code{ev}. 
Esta claro que expresiones como: @code{ev (X, X=X+1, infeval)} generar@'an un bucle infinito.
@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Funci@'on} kill (@var{symbol_1}, ..., @var{symbol_n})
@deffnx {Funci@'on} kill (labels)
@deffnx {Funci@'on} kill (inlabels, outlabels, linelabels)
@deffnx {Funci@'on} kill (@var{n})
@deffnx {Funci@'on} kill ([@var{m}, @var{n}])
@deffnx {Funci@'on} kill (values, functions, arrays, ...)
@deffnx {Funci@'on} kill (all)
@deffnx {Funci@'on} kill (allbut (@var{symbol_1}, ..., @var{symbol_n}))

Remueve todos los v@'{@dotless{i}}nculos (valor, funci@'on, arreglo o regla) de los
argumentos @var{symbol_1}, ..., @var{symbol_n}.
Un argumento puede ser un simple arreglo de elementos o funciones con sub@'{@dotless{i}}ndices. 

Varios argumentos especiales son reconocidos. 
Diferentes clases de argumentos pueden ser combinados, 
e.g., @code{kill (inlabels, functions, allbut (foo, bar))}.



@code{kill (labels)} elimina todas las etiquetas de entrada, salida y expresiones intermedias creadas
hasta el momento. 

@code{kill (inlabels)} elimina s@'olo las etiquetas de entrada
las cuales empiezan con el valor de @code{inchar} en ese momento. 

Igualmente, 
@code{kill (outlabels)} elimina s@'olo las etiquetas de salida
las cuales empiezan con el valor de @code{outchar} de ese momento, 
y @code{kill (linelabels)} elimina s@'olo las etiquetas de expresiones 
intermedias las cuales empiezan con el valor de @code{linchar} de ese momento. 

@code{kill (@var{n})}, donde @var{n} es un entero,
elimina las @var{n} etiquetas de entrada y salida m@'as recientes. 

@code{kill ([@var{m}, @var{n}]} elimina las etiquetas de entrada y salida @var{m} hasta @var{n}. 

@code{kill (@var{infolist})}, donde @var{infolist} es cualquier item de @code{infolists} (tales como @code{values}, @code{functions} o @code{arrays}), elimina todos los items en @var{infolist}. 
V@'ease tambi@'en @code{infolists}. 

@code{kill (all)} elimina todos los items de todas las listas de informaci@'on (infolists).
@code{kill (all)} no reconfigura las variables globales a sus valores por defecto; vea @code{reset} para m@'as informaci@'on sobre este punto. 


@code{kill (allbut (@var{symbol_1}, ..., @var{symbol_n}))}
elimina todos los items de todas las listas de informaci@'on (infolists) excepto para @var{symbol_1}, ..., @var{symbol_n}.

@code{kill (allbut (@var{infolist}))} elimina todos los items excepto para los que aparezcan en @var{infolist}, 
donde @var{infolist} es @code{values}, @code{functions}, @code{arrays}, etc. 

@c FALTA PARRAFO

@code{kill} no evalua sus argumentos. 
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.  

La funci@'on @code{kill} no eval@'ua sus argumentos. El operador de dobles comillas simples, @code{'@w{}'}, hace que los argumentos se eval@'uen.

La llamada @code{kill (@var{symbol})} elimina todas las propiedades de @var{symbol}.
En contraste, @code{remvalue}, @code{remfunction}, @code{remarray} y @code{remrule} elimina a propiedad en espec@'{@dotless{i}}fico. 

@code{kill} siempre retorna @code{done}, incluso si un argumento no fue eliminado. 

@end deffn

@deffn {Funci@'on} labels (@var{symbol})
@deffnx {Variable del sistema} labels
Retorna la lista de etiquetas de entrada, salida o de expresiones intermedias las cuales empiezan con @var{symbol}. 
T@'{@dotless{i}}picamente @var{symbol} es el valor de las variables @code{inchar}, @code{outchar} o @code{linechar}. 
El caract@'er de etiqueta puede ser pasado con o sin signo de porcentaje, 
as@'{@dotless{i}}, por ejemplo, @code{i} y @code{%i} producen el mismo resultado.  

Si ninguna etiqueta empieza con @var{symbol}, @code{labels} retorna a una
lista vac@'{@dotless{i}}a. 

La funci@'on @code{labels} no evalua su argumento.
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.
Por ejemplo, 
@code{labels (''inchar)} devuelve las etiquetas de entrada que empiezan con el caract@'er de etiqueta de entrada actual. 

La variable @code{labels} es una lista de las etiquetas de entrada, salida y expresiones intermedias, incluyendo todas las etiquetas anteriores en el caso de que @code{inchar}, @code{outchar} o @code{linechar} hayan sido redefinidas. 

Por defecto, Maxima muestra el resultado de cada expresi@'on introducida por el usuario, asignando al resultado una etiqueta de salida. 
La salida (es decir el resultado) puede ser suprimida terminando la expresi@'on de entrada con un @code{$} (signo de d@'olar) en vez de un @code{;} (punto y coma). 
En este caso, se crea la etiqueta de salida y se le asigna el resultado, aunque @'este no se muestre; a@'un as@'{@dotless{i}}, la etiqueta puede ser referenciada de la misma forma que se hace con aqu@'ellas cuyos resultados s@'{@dotless{i}} son muestrados.

V@'eanse tambi@'en: @code{%}, @code{%%} y @code{%th}. 

Las etiquetas de expresiones intermedias pueden ser generadas por algunas funciones. El interruptor @code{programmode} controla si @code{solve} y algunas otras funciones generan etiquetas de expresiones intermedias en vez de retornar una lista de expresiones. 
Algunas otras funciones, tales como @code{ldisplay}, siempre generan etiquetas de expresiones intermedias. 
 

V@'ease tambi@'en: @code{inchar}, @code{outchar}, @code{linechar} y @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Variable del sistema} linenum
El n@'umero de la l@'{@dotless{i}}nea del par de expresiones de entrada y salida actuales. 
@end defvr

@c NEEDS WORK
@defvr {Variable del sistema} myoptions
Valor por defecto: @code{[]}

@code{myoptions} es la lista de todas las opciones que nunca fueron reconfiguradas por el usuario, aunque @'estas hayan sido reconfiguradas a su valor por defecto. 

@end defvr

@defvr {Variable opcional} nolabels
Valor por defecto: @code{false}

Cuando @code{nolabels} vale @code{true},
las etiquetas de entrada y salida 
(@code{%i} y @code{%o}, respectivamente)
son mostradas, pero a @'estas no se les 
asignan los resultados; adem@'as, las etiquetas no se
incorporan a la lista @code{labels}.
Puesto que a las etiquetas no se les asignan resultados, 
el colector de basura puede recuperar la memoria ocupada
por los @'estos.

En el caso contrario, a las etiquetas de entrada y salida se les asignan los resultados correspondientes y son a@~nadidas a la lista @code{labels}.

Las etiquetas de expresiones intermedias (@code{%t}) no se ven afectadas por la variable @code{nolabels};
independientemente de que @code{nolabels} valga @code{true} o @code{false}, a las etiquetas de expresiones intermedias se les asignan siempre valores, adem@'as de ser a@~nadidas a la lista @code{labels}.

V@'eanse tambi@'en @code{batch}, @code{batchload} y @code{labels}. 

@end defvr

@defvr {Variable opcional} optionset
Valor por defecto: @code{false}

Cuando @code{optionset} tiene como valor @code{true}, Maxima imprime un
mensaje cada vez que una opci@'on de Maxima es reconfigurada. Esto es 
muy @'util si el usuario duda con frecuencia de la correctitud de alguna
opci@'on y quiere estar seguro de la variable a la que @'el asign@'o un
valor fue verdaramente una variable opci@'on (o interruptor). 

@end defvr

@deffn {Funci@'on} playback ()
@deffnx {Funci@'on} playback (@var{n})
@deffnx {Funci@'on} playback ([@var{m}, @var{n}])
@deffnx {Funci@'on} playback ([@var{m}])
@deffnx {Funci@'on} playback (input)
@deffnx {Funci@'on} playback (slow)
@deffnx {Funci@'on} playback (time)
@deffnx {Funci@'on} playback (grind)
Muestra las entradas, salidas y expresiones intermedias 
sin recalcularlas. 
@code{playback} s@'olo muestra las expresiones asociadas con etiquetas; 
cualquier otra salida (tal como texto impreso por @code{print} o @code{describe}, o mensajes de error) no es mostrada. 
V@'ease tambi@'en: @code{labels}. 

@code{playback} no evalua sus argumentos. 
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.
@code{playback} siempre devuelve @code{done}. 

@code{playback ()} (sin argumentos) muestra todas las entradas, salidas y expresiones intermedias generadas hasta el momento. 
Una expresi@'on de salida es mostrada incluso si @'esta fue suprimida por el caracter de terminaci@'on @code{$}, cuando fue originalmente calculada. 

@code{playback (@var{n})}  muestra las @var{n} expresiones m@'as recientes. Cada entrada, salida y expresi@'on intermedia cuenta como una. 

@code{playback ([@var{m}, @var{n}])} muestra entradas, salidas y expresiones intermedias con los n@'umeros desde @var{m} hasta @var{n}, ambos inclusive. 

@code{playback ([@var{m}])} es equivalente a @code{playback ([@var{m}, @var{m}])};
esto usualmente imprime un par de expresiones de entrada y salida. 

@code{playback (input)} muestra todas las expresiones de entrada generadas hasta el momento. 

@code{playback (slow)} hace pausas entre expresiones y
espera a que el usuario pulse la tecla @code{enter} para continuar. 
Esto es un comportamiento similar a @code{demo}. 

@c WHAT DOES THE FOLLOWING MEAN ???
@c HAY QUE ESPERAR PARA ACLARAR ESTA PARTE
@code{playback (slow)} es muy @'util en conjunci@'on con @code{save} o
@code{stringout} cuando se crea un archivo secundario de almacenamiento con el objetivo de elegir cuidadosamente las expresiones realmente @'utiles. 

@c @code{playback (slow)} is useful in conjunction with @code{save} or @code{stringout}
@c when creating a secondary-storage file in order to pick out useful expressions.

@code{playback (time)} muestra el tiempo de computo por cada expresi@'on. 

@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} muestra las expresiones de entrada 
en el mismo formato como la funci@'on @code{grind}. 
Las expresiones de salida no se ven afectadas por la opci@'on 
@code{grind}. 
Vea @code{grind}. 

Los argumentos pueden ser combinandos, e.g., 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@end deffn

@deffn {Funci@'on} printprops (@var{a}, @var{i})
@deffnx {Funci@'on} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Funci@'on} printprops (all, @var{i})
Muestra la propiedad con el indicador @var{i} asociado 
con el @'atomo @var{a}. @var{a} pueder ser tambi@'en una lista de
@'atomos o el @'atomo @code{all} en cuyo caso todos los @'atomos a los cuales se les haya dado esa propiedad ser@'an usados. 
Por ejemplo, @code{printprops ([f, g], atvalue)}. @code{printprops} es 
para propiedades que no pueden ser mostradas de otra manera, i.e. para
@code{atvalue}, @code{atomgrad}, @code{gradef}, y @code{matchdeclare}.

@end deffn

@defvr {Variable opcional} prompt
Valor por defecto: @code{_}

@code{prompt} es el s@'{@dotless{i}}mbolo del prompt de la funci@'on @code{demo}, 
del modo @code{playback (slow)} y del bucle de interrupci@'on de Maxima (el que se invoca con @code{break}). 

@end defvr

@deffn {Funci@'on} quit ()
Termina una sesi@'on de Maxima. 
N@'otese que la funci@'on debe ser invocada como @code{quit();} o @code{quit()$}, no como @code{quit}. 

Para parar un c@'alculo muy demorado 
pulse @code{Control-C}. 
La acci@'on por defecto es retornar a prompt de Maxima. 
Si @code{*debugger-hook*} tiene como valor @code{nil},
pulsar @code{Control-C} abrir@'a el depurador de Lisp. 
Vea tambi@'en: @code{debugging}. 

@end deffn


@deffn {Funci@'on} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Funci@'on} remfunction (all)
Desliga las definiciones de funci@'on de sus s@'{@dotless{i}}mbolos @var{f_1}, ..., @var{f_n}.
Los argumentos pueden ser nombres de funciones ordinarias (creadas con @code{:=} o @code{define}) o de funciones macro (creadas con @code{::=}).

La instrucci@'on @code{remfunction (all)} desliga todas las definiciones de funciones.

La funci@'on @code{remfunction} no eval@'ua sus argumentos.

La funci@'on @code{remfunction} devuelve una lista con los s@'{@dotless{i}}mbolos para los que la definici@'on de funci@'on fue desligada. Devuelve @code{false} en el lugar de cualquier s@'{@dotless{i}}mbolo para el que no hay funci@'on definida.

@end deffn

@deffn {Funci@'on} reset ()
Reconfigura muchas variables y opciones globales y algunas otras variables a sus valores por defecto. 

@code{reset} procesa las variables que se encuentran en la lista Lisp 
@code{*variable-initial-values*}. 
La macro Lisp @code{defmvar} pone las variables en @'esta lista (entre otras acciones). 
Muchas, pero no todas, las variables y opciones globales son definidas por @code{defmvar}, y algunas variables definidas por @code{defmvar} no son ni variables ni opciones globales. 

@end deffn

@defvr {Variable opcional} showtime
Valor por defecto: @code{false}

Cuando @code{showtime} tiene como valor @code{true}, el tiempo de c@'alculo y el tiempo de retardo se imprimen junto con la salida de cada expresi@'on. 

El tiempo de c@'alculo se almacena siempre, de manera que @code{time} y @code{playback} puedan mostrar el tiempo de c@'alculo incluso cuando @code{showtime} vale @code{false}.

V@'ease tambi@'en @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Funci@'on} sstatus (@var{feature}, @var{package})
Configura el estado de @var{feature} en @var{package}. 
Despu@'es de que @code{sstatus (@var{feature}, @var{package})} es 
ejecutado @code{status (@var{feature}, @var{package})} retorna
@code{true}. 
Esto puede ser muy @'util para escritores de paquetes, con el 
objetivo de conservar las pistas de que caracter@'{@dotless{i}}siticas han 
cargado estos. 

@end deffn

@deffn {Function} to_lisp ()
Entra en el int@'erprete Lisp bajo Maxima. @code{(to-maxima)} retorna de nuevo a Maxima. 

@end deffn

@defvr {Variable del sistema} values
Valor inicial: @code{[]}

@code{values} es una lista de todas las variables que el usuario ha creado (no constituye las opciones Maxima ni los interruptores). 
La lista comprende los s@'{@dotless{i}}mbolos @code{:} , @code{::}, o @code{:=}.

@end defvr
