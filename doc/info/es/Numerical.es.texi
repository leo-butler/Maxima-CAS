@c version 1.20
@menu
* Introducci@'on a los m@'etodos num@'ericos::   
* Series de Fourier::                     
* Definiciones para los m@'etodos num@'ericos::   
* Definiciones para las series de Fourier::
@end menu

@node Introducci@'on a los m@'etodos num@'ericos, Series de Fourier, M@'etodos num@'ericos, M@'etodos num@'ericos
@section Introducci@'on a los m@'etodos num@'ericos

@node Series de Fourier, Definiciones para los m@'etodos num@'ericos, Introducci@'on a los m@'etodos num@'ericos, M@'etodos num@'ericos
@section Series de Fourier

El paquete @code{fft} contiene funciones para el c@'alculo num@'erico (no simb@'olico) de la transformada r@'apida de Fourier. La instrucci@'on @code{load ("fft")} carga el paquete. V@'ease @code{fft}.

El paquete @code{fourie} contiene funciones para el c@'alculo simb@'olico de series de Fourier. La instrucci@'on 
@code{load ("fourie")} carga el paquete. Hay funciones en el paquete @code{fourie} para calcular los coeficientes de Fourier y para la transformaci@'on de expresiones. V@'ease @code{Definiciones para las series de Fourier}.

@c end concepts M@'etodos num@'ericos

@node Definiciones para los m@'etodos num@'ericos, Definiciones para las series de Fourier, Series de Fourier, M@'etodos num@'ericos
@section Definiciones para los m@'etodos num@'ericos
@c NOTE: Let's keep POLARTORECT, RECTTOPOLAR, and IFT before FFT
@c in this file. Otherwise DESCRIBE returns the FFT text (because
@c POLARTORECT, etc are list in the heading of FFT with @defunx).

@deffn {Funci@'on} polartorect (@var{magnitude_array}, @var{phase_array})

Transforma valores complejos de la forma @code{r %e^(%i t)} a la forma @code{a + b %i}. La instrucci@'on
@code{load ("fft")} carga esta funci@'on en Maxima. V@'ease tambi@'en @code{fft}.

El m@'odulo y la fase, @code{r} y @code{t}, se toman de @var{magnitude_array} y @var{phase_array}, respectivamente. Los valores originales de los arreglos de entrada se reemplazan por las partes real e imaginaria, @code{a} y @code{b}. Los resultados se calculan como

@example
a: r cos (t)
b: r sin (t)
@end example

Los arreglos de entrada deben ser de igual tama@~no y de dimensi@'on 1. El tama@~no del arreglo no necesita ser potencia de 2.

La funci@'on @code{polartorect} es la inversa de  @code{recttopolar}.

@end deffn

@deffn {Funci@'on} recttopolar (@var{real_array}, @var{imaginary_array})

Transforma valores complejos de la forma @code{a + b %i} a la forma @code{r %e^(%i t)}. La instrucci@'on
@code{load ("fft")} carga esta funci@'on en Maxima. V@'ease tambi@'en @code{fft}.

Las partes real e imaginaria, @code{a} y @code{b}, se toman de @var{real_array} y @var{imaginary_array}, respectivamente. Los valores originales de los arreglos de entrada se reemplazan por el m@'odulo y el argumento, @code{r} y @code{t}. Los resultados se calculan como

@example
r: sqrt (a^2 + b^2)
t: atan2 (b, a)
@end example

El @'angulo calculado est@'a en el rango entre @code{-%pi} y @code{%pi}. 

Los arreglos de entrada deben ser de igual tama@~no y de dimensi@'on 1. El tama@~no del arreglo no necesita ser potencia de 2.

La funci@'on @code{recttopolar} es la inversa de @code{polartorect}.

@end deffn

@deffn {Funci@'on} ift (@var{real_array}, @var{imaginary_array})

Tranformada discreta inversa de Fourier. La instrucci@'on @code{load ("fft")} carga esta funci@'on en Maxima.

La funci@'on @code{ift} calcula la transformada r@'apida inversa compleja  de Fourier de arreglos unidimensionales de n@'umeros decimales en coma flotante. La transformada inversa se define como

@example
x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)
@end example

V@'ease @code{fft} para m@'as detalles.

@end deffn

@deffn {Funci@'on} fft (@var{real_array}, @var{imaginary_array})
@deffnx {Funci@'on} ift (@var{real_array}, @var{imaginary_array})
@deffnx {Funci@'on} recttopolar (@var{real_array}, @var{imaginary_array})
@deffnx {Funci@'on} polartorect (@var{magnitude_array}, @var{phase_array})

Transformada r@'apida de Fourier y funciones asociadas. La instrucci@'on @code{load ("fft")} carga estas funciones en Maxima.

Las funciones @code{fft} y @code{ift} calculan la transformada r@'apida compleja de Fourier y su inversa de arreglos unidimensionales de n@'umeros decimales en coma flotante. El tama@~no de @var{imaginary_array} debe ser igual al de @var{real_array}.

Los resultados devueltos por las funciones @code{fft} y @code{ift} sustituyen al contenido original de los arreglos de entrada. La funci@'on @code{fillarray} puede hacer una copia de un array en caso de ser necesario.

La transformada discreta de Fourier y la transformada inversa se definen como sigue. Sea @code{x} el arreglo con los datos originales, con

@example
x[i]: real_array[i] + %i imaginary_array[i]
@end example
  
Sea @code{y} el arreglo con los datos transformados. Las transformadas directa e inversa son

@example
y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)
@end example

Arreglos apropiados se pueden preparar con la funci@'on @code{array}. Por ejemplo:

@example
array (my_array, float, n-1)$
@end example

declara un arreglo unidimensional con @code{n} elementos, indexado de 0 a n-1, ambos inclusive. El n@'umero de elementos, @code{n}, debe ser par.

La funci@'on @code{fft} se puede aplicar a datos reales (con partes imaginarias nulas) para obtener coeficientes seno y coseno. Despu@'es de llamar a la funci@'on @code{fft}, los coeficientes del seno y coseno, llam@'emosles @code{a} y @code{b}, se pueden calcular como

@example
a[0]: real_array[0]
b[0]: 0
@end example

y

@example
a[j]: real_array[j] + real_array[n-j]
b[j]: imaginary_array[j] - imaginary_array[n-j]
@end example

para j tomando valores de 1 a n/2-1, y

@example
a[n/2]: real_array[n/2]
b[n/2]: 0
@end example

La funci@'on @code{recttopolar} transforma valores complejos de la forma @code{a + b %i} a la forma @code{r %e^(%i t)}. V@'ease @code{recttopolar}.

La funci@'on @code{polartorect} transforma valores complejos de la forma @code{r %e^(%i t)} a la forma @code{a + b %i}. V@'ease @code{polartorect}.

La instrucci@'on @code{demo ("fft")} presenta una demostarci@'on del paquete @code{fft}.

@end deffn

@defvr {Variable opcional} fortindent
Valor por defecto: 0

La variable @code{fortindent} controla el margen izquierdo de las expresiones que escribe la instrucci@'on @code{fortran}.  El valor 0 escribe con un margen normal de 6 espacios; valores positivos har@'an que las expresiones se escriban m@'as a la derecha.

@end defvr

@deffn {Funci@'on} fortran (@var{expr})
Escribe @var{expr} en c@'odigo Fortran. La salida se escribe con m@'argenes, y si @'esta es demasiado larga @code{fortran} sigue escribiendo en l@'{@dotless{i}}neas sucesivas. La funci@'on @code{fortran} escribe el operador de exponenciaci@'on @code{^} como @code{**}, e imprime un n@'umero complejo @code{a + b %i} como @code{(a,b)}.

El argumento @var{expr} puede ser una ecuaci@'on. En tal caso, @code{fortran} escribe una sentencia de asignaci@'on, d@'andole el valor del miembro derecho de la expresi@'on al miembro izquierdo. En particular, si el miembro derecho de @var{expr} es el nombre de una matriz, entonces @code{fortran} escribe una sentencia de asignaci@'on para cada elemento de la matriz.

Si @var{expr} no es reconozida por @code{fortran}, la expresi@'on se escribe en formato @code{grind} sin avisos. La funci@'on @code{fortran} no reconoce listas, arreglos ni funciones.

La variable @code{fortindent} controla el margen izquierdo de las expresiones que escribe la instrucci@'on @code{fortran}.  El valor 0 escribe con un margen normal de 6 espacios; valores positivos har@'an que las expresiones se escriban m@'as a la derecha.

Si @code{fortspaces} vale @code{true}, @code{fortran} rellena las l@'{@dotless{i}}neas con espacios de 80 columnas.

La funci@'on @code{fortran} eval@'ua sus argumentos; un argumento precedido de ap@'ostrofo previene de la evaluaci@'on.
La funci@'on @code{fortran} siempre devuelve @code{done}.

Ejemplos:

@example
(%i1) expr: (a + b)^12$
(%i2) fortran (expr);
      (b+a)**12                                                                 
(%o2)                         done
(%i3) fortran ('x=expr);
      x = (b+a)**12                                                             
(%o3)                         done
(%i4) fortran ('x=expand (expr));
      x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792        
     1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b        
     2   **3+66*a**10*b**2+12*a**11*b+a**12                                     
(%o4)                         done
(%i5) fortran ('x=7+5*%i);
      x = (7,5)                                                                 
(%o5)                         done
(%i6) fortran ('x=[1,2,3,4]);
      x = [1,2,3,4]                                                             
(%o6)                         done
(%i7) f(x) := x^2$
(%i8) fortran (f);
      f                                                                         
(%o8)                         done
@end example

@end deffn

@defvr {Variable opcional} fortspaces
Valor por defecto: @code{false}

Si @code{fortspaces} vale @code{true}, @code{fortran} rellena las l@'{@dotless{i}}neas con espacios de 80 columnas.

@end defvr

@deffn {Funci@'on} horner (@var{expr}, @var{x})
@deffnx {Funci@'on} horner (@var{expr})
Cambia el formato de @var{expr} seg@'un la regla de Horner utilizando @var{x} como variable principal, si @'esta se especifica. El argumento @code{x} se puede omitir, en cuyo caso se considerar@'a como variable principal la de @var{expr} en su formato racional can@'onico (CRE).

La funci@'on @code{horner} puede mejorar las estabilidad si @code{expr} va a ser num@'ericamente evaluada. Tambi@'en es @'util si Maxima se utiliza para generar programas que ser@'an ejecutados en Fortran. V@'ease tambi@'en @code{stringout}.

@example
(%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                           2
(%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
(%i2) expr2: horner (%, x), keepfloat: true;
(%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
(%i3) ev (expr, x=1e155);
Maxima encountered a Lisp error:

 floating point overflow

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i4) ev (expr2, x=1e155);
(%o4)                       7.0E+154
@end example

@end deffn


@c NEEDS WORK
@deffn {Funci@'on} interpolate (@var{f}(@var{x}), @var{x}, @var{a}, @var{b})
@deffnx {Funci@'on} interpolate (@var{f}, @var{a}, @var{b})

Encuentra el cero de la funci@'on @var{f} cuando @var{x} var@'{@dotless{i}}a en el rango @code{[@var{a}, @var{b}]}.
La funci@'on debe tener signos diferentes en los extremos del intervalo. Si esta condici@'on no se cumple, la acci@'on de esta funci@'on la gobierna la variable @code{intpolerror}.  Si @code{intpolerror} vale @code{true} entonces se emite un mensaje de error, en otro caso se devuelve el valor de @code{intpolerror}.  V@'eanse @code{intpolabs}, @code{intpolerror} y @code{intpolrel} @c FALTA TERMINAR ESTE PARRAFO

El primer argumento puede ser una ecuaci@'on y el orden de los dos @'ultimos argumentos es irrelevante, as@'{@dotless{i}} 

@example
interpolate (sin(x) = x/2, x, %pi, 0.1);
@end example

equivale a

@example
interpolate (sin(x) = x/2, x, 0.1, %pi);
@end example

La funci@'on utiliza una b@'usqueda binaria en el rango especificado por los dos @'ultimos argumentos. Cuando cree que la funci@'on es casi lineal, comienza la interpolaci@'on lineal.

@c PREVIOUS EXAMPLE STUFF
@c f(x):=(mode_declare(x,float),sin(x)-x/2.0);
@c interpolate(sin(x)-x/2,x,0.1,%pi)       time= 60 msec
@c interpolate(f(x),x,0.1,%pi);            time= 68 msec
@c translate(f);
@c interpolate(f(x),x,0.1,%pi);            time= 26 msec
@c interpolate(f,0.1,%pi);                 time=  5 msec
@c
@c STUFF BELOW GENERATED FROM THE FOLLOWING
@c f(x) := sin(x) - x/2;
@c interpolate (sin(x) - x/2, x, 0.1, %pi);
@c interpolate (sin(x) = x/2, x, 0.1, %pi);
@c interpolate (f(x), x, 0.1, %pi);
@c interpolate (f, 0.1, %pi);
@example
(%i1) f(x) := sin(x) - x/2;
                                        x
(%o1)                  f(x) := sin(x) - -
                                        2
(%i2) interpolate (sin(x) - x/2, x, 0.1, %pi);
(%o2)                   1.895494267033981
(%i3) interpolate (sin(x) = x/2, x, 0.1, %pi);
(%o3)                   1.895494267033981
(%i4) interpolate (f(x), x, 0.1, %pi);
(%o4)                   1.895494267033981
(%i5) interpolate (f, 0.1, %pi);
(%o5)                   1.895494267033981
@end example


@end deffn

@defvr {Variable opcional} intpolabs
Valor por defecto: 0.0

La variable @code{intpolabs} es el error de la instrucci@'on @code{interpolate}, cuyo comportamiento lo controlan @code{intpolabs} y @code{intpolrel}, variables que deben guardar dos n@'umeros no negativos decimales en coma flotante.  La funci@'on @code{interpolate} parar@'a cuando su primer argumento tome un valor menor o igual que @code{intpolabs} o si sucesivas aproximaciones a la ra@'{@dotless{i}}z difieren entre s@'{@dotless{i}} en no m@'as de @code{intpolrel * <one of the approximants>}.
Los valores por defecto de @code{intpolabs} y @code{intpolrel} es 0.0, de manera que @code{interpolate} obtiene una respuesta tan buena como lo permita la precisi@'on aritm@'etica de que se disponga.

@end defvr

@defvr {Variable opcional} intpolerror
Valor por defecto: @code{true}

La variable @code{intpolerror} controla el comportamiento de @code{interpolate}.
Cuando se llama a la funci@'on @code{interpolate}, @'esta determina si la funci@'on a ser interpolada satisface la condici@'on de que sus valores en los extremos de los intervalos tengan signos diferentes. Si son de signo diferente, se procede a la interpolaci@'on. Si son del mismo signo, y @code{intpolerror} vale @code{true}, entonces se presenta un mensaje de error. Si son del mismo signo y @code{intpolerror} no vale @code{true}, retornar@'a el valor de @code{intpolerror}.

@end defvr

@defvr {Variable opcional} intpolrel
Valor por defecto: 0.0

La variable @code{intpolrel} es el error de la instrucci@'on @code{interpolate}, cuyo comportamiento lo controlan @code{intpolabs} y @code{intpolrel}, variables que deben guardar dos n@'umeros no negativos decimales en coma flotante.  La funci@'on @code{interpolate} parar@'a cuando su primer argumento tome un valor menor o igual que @code{intpolabs} o si sucesivas aproximaciones a la ra@'{@dotless{i}}z difieren entre s@'{@dotless{i}} en no m@'as de @code{intpolrel * <one of the approximants>}.
Los valores por defecto de @code{intpolabs} y @code{intpolrel} es 0.0, de manera que @code{interpolate} obtiene una respuesta tan buena como lo permita la precisi@'on aritm@'etica de que se disponga.

@end defvr


@node Definiciones para las series de Fourier, , Definiciones para los m@'etodos num@'ericos, M@'etodos num@'ericos
@section Definiciones para las series de Fourier

@c REPHRASE
@deffn {Funci@'on} equalp (@var{x}, @var{y})
Devuelve @code{true} si @code{equal (@var{x}, @var{y})}, en otro caso devuelve @code{false}. No devuelve el mensaje de error que se obtiene de  @code{equal (x, y)} en un caso como @'este.

@c NEEDS EXAMPLES
@end deffn

@deffn {Funci@'on} remfun (@var{f}, @var{expr})
@deffnx {Funci@'on} remfun (@var{f}, @var{expr}, @var{x})
La llamada @code{remfun (@var{f}, @var{expr})} reemplaza todas las subexpresiones @code{@var{f} (@var{arg})} por @var{arg} en @var{expr}.

La llamada @code{remfun (@var{f}, @var{expr}, @var{x})} reemplaza todas las subexpresiones @code{@var{f} (@var{arg})} por @var{arg} en @var{expr} s@'olo si @var{arg} contiene a la variable @var{x}.

@c NEEDS EXAMPLES
@end deffn

@deffn {Funci@'on} funp (@var{f}, @var{expr})
@deffnx {Funci@'on} funp (@var{f}, @var{expr}, @var{x})
La llamada @code{funp (@var{f}, @var{expr})} devuelve @code{true} si @var{expr} contiene la funci@'on @var{f}.

La llamada @code{funp (@var{f}, @var{expr}, @var{x})} devuelve @code{true} si @var{expr} contiene la funci@'on @var{f} y la variable @var{x} est@'a presente en el argumento de alguna de las presencias de @var{f}.

@c NEEDS EXAMPLES
@end deffn

@deffn {Funci@'on} absint (@var{f}, @var{x}, @var{halfplane})
@deffnx {Funci@'on} absint (@var{f}, @var{x})
@deffnx {Funci@'on} absint (@var{f}, @var{x}, @var{a}, @var{b})
La llamada @code{absint (@var{f}, @var{x}, @var{halfplane})} devuelve la integral indefinida de @var{f} con respecto a 
@var{x} en el semiplano dado (@code{pos}, @code{neg} o @code{both}). La funci@'on @var{f} puede contener expresiones de la forma @code{abs (x)}, @code{abs (sin (x))}, @code{abs (a) * exp (-abs (b) * abs (x))}.

La llamada @code{absint (@var{f}, @var{x})} equivale a @code{absint (@var{f}, @var{x}, pos)}.

La llamada @code{absint (@var{f}, @var{x}, @var{a}, @var{b})} devuelve la integral definida de @var{f} con respecto a  @var{x} de @var{a} a @var{b}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION. WHAT IS THE ARGUMENT p ??
@deffn {Funci@'on} fourier (@var{f}, @var{x}, @var{p})
Devuelve una lista con los coeficientes de Fourier de @code{@var{f}(@var{x})} definida en el intervalo @code{[-%pi, %pi]}.

@c NEEDS EXAMPLES
@end deffn

@c NEES EXPANSION. WHAT IS THE ARGUMENT l ??
@deffn {Funci@'on} foursimp (@var{l})
Simplifica @code{sin (n %pi)} a 0 si @code{sinnpiflag} vale @code{true} y
@code{cos (n %pi)} a @code{(-1)^n} si @code{cosnpiflag} vale @code{true}.

@c NEEDS EXAMPLES
@end deffn

@defvr {Variable opcional} sinnpiflag
Valor por defecto: @code{true}

V@'ease @code{foursimp}.

@end defvr

@defvr {Variable opcional} cosnpiflag
Valor por defecto: @code{true}

V@'ease @code{foursimp}.

@end defvr

@c NEEDS EXPANSION. EXPLAIN x AND p HERE (DO NOT REFER SOMEWHERE ELSE)
@deffn {Funci@'on} fourexpand (@var{l}, @var{x}, @var{p}, @var{limit})
Calcula y devuelve la serie de Fourier a partir de la lista de los coeficientes de Fourier @var{l} hasta el t@'ermino @var{limit} (@var{limit} puede ser @code{inf}). Los argumentos @var{x} y @var{p} tienen el mismo significado que en
@code{fourier}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION. WHAT IS THE ARGUMENT p ??
@deffn {Funci@'on} fourcos (@var{f}, @var{x}, @var{p})
Devuelve los coeficientes de los cosenos de Fourier de @code{@var{f}(@var{x})} definida en @code{[0, %pi]}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION. WHAT IS THE ARGUMENT p ??
@deffn {Funci@'on} foursin (@var{f}, @var{x}, @var{p})
Devuelve los coeficientes de los senos de Fourier de @code{@var{f}(@var{x})} definida en @code{[0, %pi]}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION. WHAT IS THE ARGUMENT p ??
@deffn {Funci@'on} totalfourier (@var{f}, @var{x}, @var{p})
Devuelve @code{fourexpand (foursimp (fourier (@var{f}, @var{x}, @var{p})), @var{x}, @var{p}, 'inf)}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION
@deffn {Funci@'on} fourint (@var{f}, @var{x})
Calcula y devuelve la lista de los coeficientes integrales de Fourier de @code{@var{f}(@var{x})} definida en @code{[minf, inf]}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION
@deffn {Funci@'on} fourintcos (@var{f}, @var{x})
Devuelve los coeficientes integrales de los cosenos  @code{@var{f}(@var{x})} en @code{[0, inf]}.

@c NEEDS EXAMPLES
@end deffn

@c NEEDS EXPANSION
@deffn {Funci@'on} fourintsin (@var{f}, @var{x})
Devuelve los coeficientes integrales de los senos  @code{@var{f}(@var{x})} en @code{[0, inf]}.

@c NEEDS EXAMPLES
@end deffn
