@c version 1.10
@menu
* Definiciones para Arreglos y Tablas::  
@end menu

@node Definiciones para Arreglos y Tablas,  , Arreglos y Tablas, Arreglos y Tablas
@section Definiciones para Arreglos y Tablas

@deffn {Funci@'on} array (@var{nombre}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Funci@'on} array (@var{nombre}, @var{type}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Funci@'on} array ([@var{nombre_1}, ..., @var{nombre_m}], @var{dim_1}, ..., @var{dim_n})

Crea un arreglo de dimensi@'on @math{n}, que debe ser menor o igual que 5. Los sub@'{@dotless{i}}ndices de la @math{i}-@'esima dimensi@'on son enteros que toman valores entre 0 y @var{dim_i}.  

La llamada @code{array (@var{nombre}, @var{dim_1}, ..., @var{dim_n})} crea un arreglo de tipo general.

La llamada @code{array (@var{nombre}, @var{type}, @var{dim_1}, ..., @var{dim_n})} crea un arreglo con sus elementos del tipo especificado. El tipo @var{type} puede ser @code{fixnum} para enteros de tama@~no limitado o @code{flonum} para n@'umeros decimales en coma flotante.

La llamada @code{array ([@var{nombre_1}, ..., @var{nombre_m}], @var{dim_1}, ..., @var{dim_n})}
crea @math{m} arreglos,  todos ellos de igual dimensi@'on.
@c SAME TYPE AS WELL ??

@c THIS DISCUSSION OF UNDECLARED ARRAYS REALLY WANTS TO BE SOMEWHERE ELSE
Si el usuario asigna un valor a una variable subindicada antes de declarar el arreglo correspondiente, entonces se construye un arreglo no declarado. Los arreglos no declarados, tambi@'en conocidos por el nombre de "arreglos de claves" (hashed arrays), son m@'as generales que los arreglos declarados. El usuario no necesita declarar su tama@~no m@'aximo y pueden ir creciendo de forma din@'amica. Los sub@'{@dotless{i}}ndices de los arreglos no declarados no necesitan ser necesariamente n@'umeros. Sin embargo, a menos que un arreglo tenga sus elementos dispersos, probablemente sea m@'as eficiente declararlo siempre que sea posible antes que dejarlo como no declarado. La funci@'on @code{array} puede utilizarse para transformar un arreglo no declarado a a uno declarado.
@c HOW DOES ONE CHANGE AN UNDECLARED ARRAY INTO A DECLARED ARRAY EXACTLY ??

@end deffn

@deffn {Funci@'on} arrayapply (@var{A}, [@var{i_1}, ..., @var{i_n}])
Eval@'ua @code{@var{A} [@var{i_1}, ..., @var{i_n}]}, donde @var{A} es un arreglo y @var{i_1}, ..., @var{i_n} son enteros.

Esto es como @code{apply}, excepto por el hecho de que el primer argumento es un arreglo en lugar de una funci@'on.

@end deffn

@deffn {Funci@'on} arrayinfo (@var{A})
Devuelve una lista con informaci@'on sobre el arreglo @var{A}. Para arreglos de claves (hashed arrays) devuelve una lista @code{hashed}, el n@'umero de sub@'{@dotless{i}}ndices y los sub@'{@dotless{i}}ndices de aquellos elementos que tengan valor. Para arreglos declarados devuelve una lista @code{declared}, el n@'umero de sub@'{@dotless{i}}ndices y los valores dados a la funci@'on @code{array} cuando fue invocada para crear @var{A}.  H@'agase @code{example(arrayinfo);} para ver un ejemplo.

@end deffn

@deffn {Funci@'on} arraymake (@var{name}, [@var{i_1}, ..., @var{i_n}])
Devuelve la expresi@'on @code{@var{name} [@var{i_1}, ..., @var{i_n}]}.

Esta funci@'on es similar a @code{funmake}, excepto que el valor retornado es referencia a un arreglo no evaluado, en lugar de una llamada a una funci@'on no evaluada.

@end deffn

@defvr {Variable del sistema} arrays
Valor por defecto: @code{[]}

La variable @code{arrays} es una lista con todos los arreglos que han sido alojados, hayan sido declarados o no.

V@'eanse tambi@'en
@code{array}, @code{arrayapply}, @code{arrayinfo}, @code{arraymake}, 
@code{fillarray}, @code{listarray} y @code{rearray}.
@c IS THIS AN EXHAUSTIVE LIST ??

@end defvr

@deffn {Funci@'on} bashindices (@var{expr})
Transforma la expresi@'on @var{expr} d@'andole a cada suma y producto un @'unico @'{@dotless{i}}ndice. Esto le da a @code{changevar} mayor precisi@'on cuando opera con sumas y productos. La forma del @'unico @'{@dotless{i}}ndice es @code{j@var{number}}. La cantidad @var{number} se determina en funci@'on de @code{gensumnum}, valor que puede cambiar el usuario.  Por ejemplo, haciendo @code{gensumnum:0$}.

@end deffn

@deffn {Funci@'on} fillarray (@var{A}, @var{B})
Rellena el arreglo @var{A} con los valores de @var{B}, que puede ser una lista o arreglo.

Si @var{A} es un array de n@'umeros decimales en coma flotante (enteros) entonces @var{B} debe ser o bien una lista de n@'umeros decimales en coma flotante  (enteros), o bien otro arreglo de n@'umeros en coma flotante (enteros).

Si las dimensiones de los areglos son diferentes, @var{A} se rellena seg@'un el orden de las filas. Si no hay suficientes elementos en @var{B} el @'ultimo elemento se utiliza para cubrir el resto de @var{A}. Si hay demasiados, los elementos sobrantes son ignorados.

La funci@'on @code{fillarray} devuelve su primer argumento.

@end deffn

@deffn {Funci@'on} listarray (@var{A})
Devuelve una lista con los elementos del arreglo declarado o tabla de claves @var{A}, en el orden de las filas. Los elementos que todav@'{@dotless{i}}a no han sido declarados se representan mediante @code{#####}.

@end deffn

@deffn {Funci@'on} make_array (@var{tipo}, @var{dim_1}, ..., @var{dim_n})
Construye y devuelve un arreglo de Lisp. El argumento @var{tipo} puede ser  @code{any}, @code{flonum}, @code{fixnum}, @code{hashed} o @code{functional}. Hay @math{n} @'{@dotless{i}}ndices, y el @'{@dotless{i}}ndice @math{i}-@'esimo va de  0 a @math{@var{dim_i} - 1}.

La ventaja de @code{make_array} sobre @code{array} estriba en que el valor retornado no tiene nombre, y una vez que un puntero deja de referenciarlo, el valor desaparece. Por ejemplo, si @code{y: make_array (...)} entonces @code{y} apunta a un objeto que ocupa cierto espacio en la memoria, pero despu@'es de @code{y: false}, @code{y} ya no apunta al objeto, por lo que @'este puede ser considerado basura y posteriormente eliminado.  

@c NEEDS CLARIFICATION HERE
En la instrucci@'on @code{y: make_array ('functional, 'f, 'hashed, 1)} el segundo argumento de @code{make_array}  es la funci@'on que se debe invocar para calcular los elementos del arreglo, pas@'andose recursivamente a @code{make_array} el resto de los argumentos para generar la "memoria" de la funci@'on arreglo.

@end deffn

@c DOES THIS MODIFY A OR DOES IT CREATE A NEW ARRAY ??
@deffn {Funci@'on} rearray (@var{A}, @var{dim_1}, ..., @var{dim_n})
Cambia las dimensiones de un arreglo. El nuevo arreglo ser@'a rellenado con los elementos del viejo seg@'un el orden de las filas. Si el arreglo antiguo era demasiado peque@~no, los elementos restantes se rellenan con @code{false}, @code{0.0} o @code{0}, dependiendo del tipo del arreglo. El tipo del arreglo no se puede cambiar.

@end deffn

@deffn {Funci@'on} remarray (@var{A_1}, ..., @var{A_n})
@deffnx {Funci@'on} remarray (all)
Borra los arreglos y las funciones relacionadas con ellos, liberando el espacio de memoria ocupado.

La llamada @code{remarray (all)} borra todos los elementos de la lista global @code{arrays}.

La funci@'on @code{remarray} devuelve la lista de los arreglos borrados.

@end deffn

@c THIS IS REALLY CONFUSING
@defvr {Variable optativa} use_fast_arrays
Valor por defecto: @code{false}

Si @code{use_fast_arrays} vale @code{true} entonces tan solo se reconocen dos tipos de arreglos. 

@c AQUI QUEDAN TRES PARRAFOS SIN TRADUCIR
 
@end defvr
