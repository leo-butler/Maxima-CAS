@menu
* Introducci@'on a numericalio::
* Definiciones para numericalio::
@end menu

@node Introducci@'on a numericalio, Definiciones para numericalio, numericalio, numericalio
@section Introducci@'on a numericalio

El paquete @code{numericalio} define funciones para leer y escribir ficheros de datos.
Se lee el fichero completo a fin de construir un objeto, por lo que el paquete no
soporta lecturas parciales de archivos.

Cada elemento a leer o escribir en un fichero debe ser necesariamente un @'atomo:
un n@'umero entero, decimal, decimal grande, una cadena o un s@'{@dotless{i}}mbolo;
no se admiten fracciones, n@'umeros complejos o cualquier otra expresi@'on no
at@'omica. Estas funciones pueden llegar a realizar operaciones v@'alidas con
expresiones no at@'omicas, pero estos resultados no se documentan y est@'an sujetos
a cambios ulteriores.

Los @'atomos, tanto en los ficheros de entrada como en los de salida, tienen el 
mismo formato que en los ficheros por lotes de Maxima o en la consola
interactiva. En particular, las cadenas deben encerrarse entre comillas
dobles, la barra invertida @code{\} evita cualquier interpretaci@'on
especial del car@'acter siguiente, y el s@'{@dotless{i}}mbolo de
interrogaci@'on @code{?} se reconoce como el comienzo de un 
s@'{@dotless{i}}mbolo de Lisp. No se reconoce ning@'un car@'acter de
continuaci@'on de l@'{@dotless{i}}nea interrumpida.

El argumento opcional @var{separator_flag}, com@'un a todas las funciones de
lectura y escritura, indica qu@'e car@'acter ser@'a el utilizado para
separar elementos.

Para la lectura de ficheros se reconocen los siguientes valores de la
variable @var{separator_flag}: @code{comma} para los valores separados por
comas, @code{pipe} para los valores separados por el car@'acter de la barra
vertical @code{|}, @code{semicolon} para los valores separados por punto y
coma @code{;}, y @code{space} para cuando los valores se separan por espacios
o tabulaciones. Si el nombre del fichero tiene extensi@'on @code{.csv} y no se
especifica el argumento @var{separator_flag}, se tomar@'a por defecto @code{comma}.
Si el fichero tiene cualquier otra extensi@'on diferente de @code{.csv} y no se
especifica @code{separator_flag}, se usar@'a por defecto @code{space}.

Para los ficheros de salida se utilizan los mismos formatos de separaci@'on
que para los de entrada; a los que se le a@~nade @code{tab} para separar 
valores con tabulaciones.

En la entrada, varios espacios y tabulaciones sucesivos cuentan como un
@'unico separador. Sin embargo, varias comas, barras verticales o punto y comas 
sucesivos se interpretan que tienen el s@'{@dotless{i}}mbolo @code{false} entre
ellos; por ejemplo, @code{1234,,Foo} se interpreta lo mismo que si fuese
@code{1234,false,Foo}. En la salida, los @'atomos @code{false} deben
escribirse expl@'{@dotless{i}}citamente, por lo que la lista 
@code{[1234, false, Foo]} debe escribirse @code{1234,false,Foo}.



@node Definiciones para numericalio,  , Introducci@'on a numericalio, numericalio
@section Definiciones para numericalio

@deffn {Funci@'on} read_matrix (@var{file_name})
@deffnx {Funci@'on} read_matrix (@var{file_name}, @var{separator_flag})
Lee el fichero @var{file_name} y devuelve su contenido completo en forma
de matriz. Si no se especifica @var{separator_flag}, se entiende que los 
valores est@'an separados por espacios.

La funci@'on @code{read_matrix} obtiene el tama@~no de la matriz a partir
de los datos de entrada. Cada l@'{@dotless{i}}nea del fichero forma una fila de
la matriz. Si hay filas con diferente n@'umero de elementos, @code{read_matrix}
emite un mensaje de error.

@end deffn

@deffn {Funci@'on} read_lisp_array (@var{file_name}, @var{A})
@deffnx {Funci@'on} read_lisp_array (@var{file_name}, @var{A}, @var{separator_flag})
La funci@'on @code{read_lisp_array} requiere que el arreglo sea declarado
por @code{make_array} antes de solicitar la lectura del fichero, lo cual evita la
necesidad de calcular las dimensiones del arreglo, especialmente en el caso
de arreglos multidimensionales.

La funci@'on @code{read_lisp_array} no comprueba si el fichero de
entrada es compatible con las dimensiones del arreglo; la entrada
se lee como una lista para a continuaci@'on completar el arreglo con
@code{fillarray}.

@end deffn


@deffn {Funci@'on} read_maxima_array (@var{file_name}, @var{A})
@deffnx {Funci@'on} read_maxima_array (@var{file_name}, @var{A}, @var{separator_flag})
La funci@'on @code{read_maxima_array} requiere que el arreglo sea declarado
por @code{array} antes de solicitar la lectura del fichero, lo cual evita la
necesidad de calcular las dimensiones del arreglo, especialmente en el caso
de arreglos multidimensionales.

La funci@'on @code{read_maxima_array} no comprueba si el fichero de
entrada es compatible con las dimensiones del arreglo; la entrada
se lee como una lista para a continuaci@'on completar el arreglo con
@code{fillarray}.
@end deffn


@deffn {Funci@'on} read_hashed_array (@var{file_name}, @var{A})
@deffnx {Funci@'on} read_hashed_array (@var{file_name}, @var{A}, @var{separator_flag})
La funci@'on @code{read_hashed_array} considera el primer t@'ermino
de la l@'{@dotless{i}}nea como un @'{@dotless{i}}ndice, asociando a @'este el
resto de la l@'{@dotless{i}}nea. Por ejemplo, una fila con el contenido 
@code{567 12 17 32 55} equivale a  @code{A[567]: [12, 17, 32, 55]$}.
Las filas no necesitan tener el mismo n@'umero de elementos.
@end deffn

@deffn {Funci@'on} read_nested_list (@var{file_name})
@deffnx {Funci@'on} read_nested_list (@var{file_name}, @var{separator_flag})
La funci@'on @code{read_nested_list} devuelve una lista con una sublista
por cada fila de entrada. Las filas no necesitan tener el mismo n@'umero de elementos.
Las filas vac@'{@dotless{i}}as @i{no} se ignoran, dando lugar a sublistas 
vac@'{@dotless{i}}as.
@end deffn

@deffn {Funci@'on} read_list (@var{file_name})
@deffnx {Funci@'on} read_list (@var{file_name}, @var{separator_flag})
La funci@'on @code{read_list} lee todo el fichero de entrada como
una lista simple, ignorando los caracteres de fin de l@'{@dotless{i}}nea.
@end deffn

@deffn {Funci@'on} write_data (@var{X}, @var{file_name})
@deffnx {Funci@'on} write_data (@var{object}, @var{file_name}, @var{separator_flag})
La funci@'on @code{write_data} escribe el objeto @var{X} en el fichero
@var{file_name}.

@code{write_data} escribe las matrices fila a fila.

@code{write_data} escribe arreglos de Maxima y Lisp fila
a fila, con un salto de l@'{@dotless{i}}nea al final de
cada tabla. Las tablas multidimensionales se separan con
saltos de l@'{@dotless{i}}nea adicionales.

@code{write_data} escribe arreglos codificados con un @'{@dotless{i}}ndice
seguido de una lista asociativa en cada  l@'{@dotless{i}}nea.

@code{write_data} escribe una lista anidada con una sublista por
l@'{@dotless{i}}nea.

@code{write_data} escribe una lista simple en una @'unica l@'{@dotless{i}}nea.

@code{write_data} a@~nadir@'a o inicializar@'a el fichero de salida
seg@'un le indique la variable global @code{file_output_append}.

@end deffn

