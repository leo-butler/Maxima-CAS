@menu
* Introduction to Ctensor::     
* Definitions for Ctensor::     
@end menu

@node Introduction to Ctensor, Definitions for Ctensor, Ctensor, Ctensor
@section Introduction to Ctensor

 - Component Tensor Manipulation Package.  To use the CTENSOR
package, type @code{load(ctensor)}.
To begin an interactive session with CTENSOR, type @code{csetup()}.  You are
first asked to specify the dimension of the manifold. If the dimension
is 2, 3 or 4 then the list of coordinates defaults to @code{[x,y]}, @code{[x,y,z]}
or @code{[x,y,z,t]} respectively.
These names may be changed by assigning a new list of coordinates to
the variable @code{ct_coords} (described below) and the user is queried about
this.
** Care must be taken to avoid the coordinate names conflicting
with other object definitions **.
Next, the user enters the metric either directly or from a file by
specifying its ordinal position. As an example of a file of common
metrics, see @code{share/tensor/metrics.mac}. The metric is stored in the matrix
LG. Finally, the metric inverse is computed and stored in the matrix
UG. One has the option of carrying out all calculations in a power
series.
A sample protocol is begun below for the static, spherically symmetric
metric (standard coordinates) which will be applied to the problem of
deriving Einstein's vacuum equations (which lead to the Schwarzschild
solution) as an example. Many of the functions in CTENSR will be
displayed for the standard metric as examples.
@example
(%i1) load(ctensor);

(%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
(%i2) csetup();

Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
depends([a,d],x);
Do you wish to see the metric? 
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]

(%o2)                                done
(%i3) christof(mcs);

                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a

(%o11)                               done

@end example

@c end concepts Ctensor
@node Definitions for Ctensor,  , Introduction to Ctensor, Ctensor

@section Definitions for Ctensor

@subsection Initialization and setup

@c @node csetup
@c @unnumberedsec phony
@defun csetup ()
A function in the CTENSOR (Component Tensor Manipulation) package
which initializes the package and allows the user to enter a metric
interactively. See CTENSOR for more details.
@end defun

@c @node cmetric
@c @unnumberedsec phony
@defun cmetric ([dis])
A function in the CTENSOR (Component Tensor Manipulation) package
that computes the metric inverse and sets up the package for
further calculations.
If @code{cframe_flag} is false, the function computes the inverse metric
ug from the (user-defined) matrix @code{lg}. The metric determinant is
also computed and stored in the variable @code{gdet}. Furthermore, the
package determines if the metric is diagonal and sets the value
of @code{diagmetric} accordingly. If the optional argument @code{dis}
is present and not equal to false, the user is prompted to see
the metric inverse.
If @code{cframe_flag} is true, the function expects that the values of
@code{fri} (the inverse frame matrix) and @code{lfg} (the frame metric) are
defined. From these, the frame matrix @code{fr} and the inverse frame
metric @code{ufg} are computed.

@end defun

@c @node ct_coordsys
@c @unnumberedsec phony
@defun ct_coordsys (coordinate_system,[extra_args])
Sets up a predefined coordinate system and metric. The argument
@code{coordinate_system} can be one of the following symbols:

@example

  SYMBOL               Dim Coordinates       Description/comments
  --------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Cartesian 2D coordinate system
  polar                 2  [r,phi]           Polar coordinate system
  elliptic              2  [u,v]
  confocalelliptic      2  [u,v]
  bipolar               2  [u,v]
  parabolic             2  [u,v]
  cartesian3d           3  [x,y,z]           Cartesian 3D coordinate system
  polarcylindrical      3  [r,theta,z]
  ellipticcylindrical   3  [u,v,z]           Elliptic 2D with cylindrical Z
  confocalellipsoidal   3  [u,v,w]
  bipolarcylindrical    3  [u,v,z]           Bipolar 2D with cylintrical Z
  paraboliccylindrical  3  [u,v,z]           Parabolic 2D with cylindrical Z
  paraboloidal          3  [u,v,phi]
  conical               3  [u,v,w]
  toroidal              3  [u,v,phi]
  spherical             3  [r,theta,phi]     Spherical coordinate system
  oblatespheroidal      3  [u,v,phi]
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]
  cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate system
  spherical4d           4  [r,theta,eta,phi]
  exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
  interiorschwarzschild 4  [t,r,theta,phi]   Interior (non-vacuum)
  kerr_newman           4  [t,r,theta,phi]

@end example

@code{coordinate_system} can also be a list of transformation functions,
followed by a list containing the coordinate variables. For instance,
you can specify a spherical metric as follows:

@example

(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);

(%o2)                                done
(%i3) lg:trigsimp(lg);

                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;

(%o4)                           [r, theta, phi]
(%i5) dim;

(%o5)                                  3

@end example

Transformation functions can also be used when @code{cframe_flag} is @code{true}:

@example

(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;

(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);

(%o3)                                done
(%i4) fri;

      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();

(%o5)                                false
(%i6) lg:trigsimp(lg);

                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

The optional arguments can be any one of the following:

@code{cylindrical} tells @code{ct_coordsys} to attach an additional cylindrical coordinate.

@code{minkowski} tells @code{ct_coordsys} to attach an additional coordinate with negative metric signature.

@code{all} tells @code{ct_coordsys} to call @code{cmetric} and @code{christof(false)} after setting up the metric.

if the option variable @code{verbose} is set to @code{true}, @code{ct_coordsys} displays the values of @code{dim}, @code{ct_coords}, and either @code{lg} or @code{lfg} and @code{fri}, depending on the value of @code{cframe_flag}.

@end defun

@c @node init_ctensor
@c @unnumberedsec phony
@defun init_ctensor ()
Initializes the CTENSOR package.

The @code{init_ctensor()} function reinitializes the CTENSOR package. It removes all arrays and matrices used by CTENSOR, resets all flags, resets @code{dim} to 4, and resets the frame metric to the Lorentz-frame.

@end defun


@subsection The tensors of curved space

The main purpose of the CTENSOR package is to compute the tensors
of curved space(time), most notably the tensors used in general
relativity.

When a metric base is used, CTENSOR can compute the following tensors:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

CTENSOR can also work using moving frames. When @code{cframe_flag} is
set to @code{true}, the following tensors can be calculated:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@c @node christof
@c @unnumberedsec phony
@defun christof (dis)
A function in the CTENSOR (Component Tensor
Manipulation) package.  It computes the Christoffel symbols of both
kinds.  The argument @code{dis} determines which results are to be immediately
displayed.  The Christoffel symbols of the first and second kinds are
stored in the arrays @code{lcs[i,j,k]} and @code{mcs[i,j,k]} respectively and
defined to be symmetric in the first two indices. If the argument to
@code{christof} is @code{lcs} or @code{mcs} then the unique non-zero values of @code{lcs[i,j,k]}
or @code{mcs[i,j,k]}, respectively, will be displayed. If the argument is @code{all}
then the unique non-zero values of @code{lcs[i,j,k]} and @code{mcs[i,j,k]} will be
displayed.  If the argument is @code{false} then the display of the elements
will not occur. The array elements @code{mcs[i,j,k]} are defined in such a
manner that the final index is contravariant.
@end defun

@c @node ricci
@c @unnumberedsec phony
@defun ricci (dis)
A function in the CTENSOR (Component Tensor
Manipulation) package. @code{ricci} computes the covariant (symmetric)
components @code{ric[i,j]} of the Ricci tensor.  If the argument @code{dis} is @code{true},
then the non-zero components are displayed.
@end defun

@c @node uricci
@c @unnumberedsec phony
@defun uricci (dis)
Tensor package) This function first computes the
covariant components @code{ric[i,j]} of the Ricci tensor.
Then the mixed Ricci tensor is computed using the
contravariant metric tensor.  If the value of the argument @code{dis}
is @code{true}, then these mixed components, @code{uric[i,j]} (the index i is
covariant and the index j is contravariant), will be displayed
directly.  Otherwise, @code{ricci(false)} will simply compute the entries
of the array @code{uric[i,j]} without displaying the results.

@end defun
@c @node scurvature
@c @unnumberedsec phony
@defun scurvature ()

returns the scalar curvature (obtained by contracting
the Ricci tensor) of the Riemannian manifold with the given metric.

@end defun
@c @node einstein
@c @unnumberedsec phony
@defun einstein (dis)
A function in the CTENSOR (Component Tensor
Manipulation) package.  @code{einstein} computes the mixed Einstein tensor
after the Christoffel symbols and Ricci tensor have been obtained
(with the functions @code{christof} and @code{ricci}).  If the argument @code{dis} is
@code{true}, then the non-zero values of the mixed Einstein tensor @code{ein[i,j]}
will be displayed where @code{j} is the contravariant index.
The variable @code{rateinstein} (default: @code{true} will cause the rational simplification on
these components. If @code{ratfac} (default: @code{false}) is TRUE then the components will
also be factored.

@end defun
@c @node leinstein
@c @unnumberedsec phony
@defun leinstein (dis)
Covariant Einstein-tensor. @code{leinstein()} stores the values of the covariant Einstein tensor in the array @code{lein}. The covariant Einstein-tensor is computed from the mixed Einstein tensor @code{ein} by multiplying it with the metric tensor. If the argument @code{dis} is @code{true}, then the non-zero values of the covariant Einstein tensor are displayed.

@end defun

@c @node riemann
@c @unnumberedsec phony
@defun riemann (dis)
A function in the CTENSOR (Component Tensor
Manipulation) Package.  @code{riemann} computes the Riemann curvature tensor
from the given metric and the corresponding Christoffel symbols. The following
index conventions are used:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

This notation is consistent with the notation used by the ITENSOR
package and its @code{icurvature} function.
If the optional argument @code{dis} is @code{true},
the non-zero components @code{riem[i,j,k,l]} will be displayed.
As with the Einstein tensor, various switches set by the user
control the simplification of the components of the Riemann tensor.
If @code{ratriemann} (default: @code{true}) is @code{true}, then
rational simplification will be done. If @code{ratfac} (default:
@code{false}) is @code{true} then
each of the components will also be factored.

If the variable @code{cframe_flag} is @code{false}, the Riemann tensor is
computed directly from the Christoffel-symbols. If @code{cframe_flag} is
@code{false}, the covariant Riemann-tensor is computed first from the
frame field coefficients.

@end defun

@c @node lriemann
@c @unnumberedsec phony
@defun lriemann (dis)
Covariant Riemann-tensor (@code{lriem[]}).

Computes the covariant Riemann-tensor as the array @code{lriem}. If the
argument @code{dis} is @code{true}, unique nonzero values are displayed.

If the variable @code{cframe_flag} is @code{true}, the covariant Riemann
tensor is computed directly from the frame field coefficients. Otherwise,
the (3,1) Riemann tensor is computed first.

For information on index ordering, see @code{riemann()}.

@end defun

@c @node uriemann
@c @unnumberedsec phony
@defun uriemann (dis)
Computes the contravariant components of the Riemann
curvature tensor as array elements @code{uriem[i,j,k,l]}.  These are displayed
if @code{dis} is @code{true}.

@end defun

@c @node rinvariant
@c @unnumberedsec phony
@defun rinvariant ()
Forms the Kretchmann-invariant (@code{kinvariant}) obtained by
contracting the tensors
@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example

This object is not automatically simplified since it can be very large.

@end defun

@c @node weyl
@c @unnumberedsec phony
@defun weyl ()
Computes the Weyl conformal tensor.  If the argument @code{dis} is
@code{true}, the non-zero components @code{weyl[i,j,k,l]} will be displayed to the
user.  Otherwise, these components will simply be computed and stored.
If the switch @code{ratweyl} is set to @code{true}, then the components will be
rationally simplified; if @code{ratfac} is @code{true} then the results will be
factored as well.

@end defun

@subsection Frame fields

When the variable @code{cframe_flag} is set to true, the CTENSOR package
performs its calculations using a moving frame.

@c @node frame_bracket
@c @unnumberedsec phony
@defun frame_bracket (fr,fri,diagframe)
The frame bracket (@code{fb[]}).

*** TO BE WRITTEN ***
@end defun

@subsection Algebraic classification

A new feature (as of November, 2004) of CTENSOR is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
@code{share/tensor/petrov.dem}.

@c @node nptetrad
@c @unnumberedsec phony
@defun nptetrad ()
Computes a Newman-Penrose null tetrad (@code{np}) and its inverse (@code{npi}).
See @code{petrov()} for an example.

@end defun

@c @node psi
@c @unnumberedsec phony
@defun psi (dis)
Computes the five Newman-Penrose coefficients @code{psi[0]}...@code{psi[4]}.
If @code{psi} is set to @code{true}, the coefficients are displayed.
See @code{petrov()} for an example.

@end defun

@c @node petrov
@c @unnumberedsec phony
@defun petrov ()
Computes the Petrov classification of the metric characterized by @code{psi[0]}...@code{psi[4]}.

For example, the following demonstrates how to obtain the Petrov-classification
of the Kerr metric:

@example
(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);

(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);

(%o3)                                done
(%i4) ug:invert(lg)$

(%i5) weyl(false);

(%o5)                                done
(%i6) nptetrad(true);

(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);

(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4

(%o12)                               done
(%i12) petrov();

(%o12)                             Type is D

@end example


@end defun


@subsection Torsion and nonmetricity

Ctensor has the ability to compute and include torsion and nonmetricity
coefficients in the connection coefficients.

The torsion coefficients are calculated from a user-supplied tensor
@code{tr}, which should be a rank (2,1) tensor. From this, the torsion
coefficients @code{kt} are computed according to the following formulae:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

Note that only the mixed-index tensor is calculated and stored in the
array @code{kt}.

The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector @code{nm}. From this, the nonmetricity coefficients
@code{nmc} are computed as follows:

@example

            k    k        km
       nm  D  - D  nm  + g   nm  g
   k     i  j    i   j         m  ij
nmc  = -----------------------------
   ij                2

@end example

where D stands for the Kronecker-delta.

When @code{ctorsion_flag} is set to @code{true}, the values of @code{kt}
are substracted from the mixed-indexed connection coefficients computed by
@code{christof()} and stored in @code{mcs}. Similarly, if @code{cnonmet_flag}
is set to @code{true}, the values of @code{nmc} are substracted from the
mixed-indexed connection coefficients.

If necessary, @code{christof} calls the functions @code{contortion()} and
@code{nonmetricity()} in order to compute @code{kt} and @code{nm}.

@c @node contortion
@c @unnumberedsec phony
@defun contortion (tr)

Computes the (2,1) contortion coefficients from the torsion tensor @code{tr}.

@end defun

@c @node nonmetricity
@c @unnumberedsec phony
@defun nonmetricity (nm)

Computes the (2,1) nonmetricity coefficients from the nonmetricity
vector @code{nm}.

@end defun



@subsection Miscellaneous features

@c @node ctransform
@c @unnumberedsec phony
@defun ctransform (matrix)
A function in the CTENSOR (Component Tensor
Manipulation) package which will perform a coordinate transformation
upon an arbitrary square symmetric matrix. The user must input the
functions which define the transformation.  (Formerly called TRANSFORM.)

@end defun

@c @node findde
@c @unnumberedsec phony
@defun findde (array, n)

returns a list of the unique differential equations (expressions)
corresponding to the elements of the @code{n} dimensional square
@code{array}. Presently, @code{n} may be 2 or 3. @code{deindex} is a global list
containing the indices of @code{array} corresponding to these unique
differential equations. For the Einstein tensor (@code{ein}), which
is a two dimensional array, if computed for the metric in the example
below, @code{findde} gives the following independent differential equations:


@example
(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;

(%o2)                                true
(%i3) dim:4;

(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);

                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);

(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];

(%o6)                            [x, y, z, t]
(%i7) cmetric();

(%o7)                                done
(%i8) einstein(false);

(%o8)                                done
(%i9) findde(ein,2);

                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;

(%o10)                     [[1, 1], [2, 2], [4, 4]]


@end example


@end defun
@c @node cograd
@c @unnumberedsec phony
@defun cograd ()
computes the COvariant GRADient of a scalar function allowing the
user to choose the corresponding vector name as the example under
@code{contragrad} illustrates.
@end defun
@c @node contragrad
@c @unnumberedsec phony
@defun contragrad ()

computes the CONTRAvariant GRADient of a scalar function allowing
the user to choose the corresponding vector^F2name^F* as the example
below for the Schwarzschild metric illustrates:

@example


(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;

(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);

(%o3)                                done
(%i4) depends(f,r);

(%o4)                               [f(r)]
(%i5) cograd(f,g1);

(%o5)                                done
(%i6) listarray(g1);

(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);

(%o7)                                done
(%i8) listarray(g2);

                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

@end example

@end defun
@c @node dscalar
@c @unnumberedsec phony
@defun dscalar ()
computes the tensor d'Alembertian of the scalar function once
dependencies have been declared upon the function. For example:

@example
(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;

(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);

(%o3)                                done
(%i4) depends(p,r);

(%o4)                               [p(r)]
(%i5) factor(dscalar(p));

                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end example

@end defun
@c @node checkdiv
@c @unnumberedsec phony
@defun checkdiv ()

computes the covariant divergence of the mixed second rank tensor
(whose first index must be covariant) by printing the
corresponding n components of the vector field (the divergence) where
n = @code{dim}. If the argument to the function is @code{g} then the
divergence of the Einstein tensor will be formed and must be zero.
In addition, the divergence (vector) is given the array name @code{div}.
@end defun

@c @node cgeodesic
@c @unnumberedsec phony
@defun cgeodesic (dis)
A function in the CTENSOR (Component Tensor
Manipulation) package.  @code{cgeodesic} computes the geodesic equations of
motion for a given metric.  They are stored in the array @code{geod[i]}.  If
the argument @code{dis} is @code{true} then these equations are displayed.

@end defun


@c @node bdvac
@c @unnumberedsec phony
@defun bdvac (fun)

generates the covariant components of the vacuum field equations of
the Brans- Dicke gravitational theory. The scalar field is specified
by the argument @code{fun}, which should be a (quoted) function name
with functional dependencies, e.g., @code{'p(x)}.

The components of the second rank covariant field tensor are
represented by the array @code{bd}.

@end defun
@c @node invariant1
@c @unnumberedsec phony
@defun invariant1 ()

generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of R^2. The field equations are the components of an
array named @code{inv1}.

@end defun
@c @node invariant2
@c @unnumberedsec phony
@defun invariant2 ()

*** NOT YET IMPLEMENTED ***

generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of @code{ric[i,j]*uriem[i,j]}. The field equations are the
components of an array named @code{inv2}.


@end defun
@c @node bimetric
@c @unnumberedsec phony
@defun bimetric ()

*** NOT YET IMPLEMENTED ***

generates the field equations of Rosen's bimetric theory. The field
equations are the components of an array named @code{rosen}.

@end defun

@subsection Utility functions

@c @node diagmatrixp
@c @unnumberedsec phony
@defun diagmatrixp (m)

Returns @code{true} if @code{m} is a diagonal matrix or (2D) array.

@end defun
@c @node symmetricp
@c @unnumberedsec phony
@defun symmetricp (m)

Returns @code{true} if @code{m} is a symmetric matrix or (2D) array.

@end defun
@c @node ntermst
@c @unnumberedsec phony
@defun ntermst (f)
gives the user a quick picture of the "size" of the doubly subscripted
tensor (array) @code{f}.  It prints two element lists where the second
element corresponds to NTERMS of the components specified by the first
elements.  In this way, it is possible to quickly find the non-zero
expressions and attempt simplification.

@end defun
@c @node cdisplay
@c @unnumberedsec phony
@defun cdisplay (ten)
displays all the elements of the tensor @code{ten}, as represented by
a multidimensional array. Tensors of rank 0 and 1, as well as other types
of variables, are displayed as with @code{ldisplay}. Tensors of rank 2 are
displayed as 2-dimensional matrices, while tensors of higher rank are displayed
as a list of 2-dimensional matrices. For instance, the Riemann-tensor of
the Schwarzschild metric can be viewed as:

@example
(%i1) load(ctensor);

(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;

(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);

(%o3)                                done
(%i4) riemann(false);

(%o4)                                done
(%i5) cdisplay(riem);

               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

@end example
@end defun
@c @node deleten
@c @unnumberedsec phony
@defun deleten (list,n)
returns a new list consisting of @code{list} with the @code{n}th element
deleted.
@end defun

@subsection Variables used by CTENSOR


@c @node dim
@c @unnumberedsec phony
@defvar dim
 default:[4] - An option in the CTENSOR (Component Tensor
Manipulation) package.  @code{dim} is the dimension of the manifold with the
default 4. The command @code{dim:n}; will reset the dimension to any other
value @code{n}.

@end defvar
@c @node diagmetric
@c @unnumberedsec phony
@defvar diagmetric
 default:@code{false} - An option in the CTENSOR (Component Tensor
Manipulation) package.  If @code{diagmetric} is @code{true} special routines compute
all geometrical objects (which contain the metric tensor explicitly)
by taking into consideration the diagonality of the metric. Reduced
run times will, of course, result. Note: this option is set
automatically by @code{csetup()} if a diagonal metric is specified.

@end defvar

@c @node ctrgsimp
@c @unnumberedsec phony
@defvar ctrgsimp

Causes trigonometric simplifications to be used when tensors are computed. Presently,
@code{ctrgsimp} affects only computations involving a moving frame.

@end defvar

@c @node cframe_flag
@c @unnumberedsec phony
@defvar cframe_flag

Causes computations to be performed relative to a moving frame as opposed to
a holonomic metric. The frame is defined by the inverse frame array @code{fri}
and the frame metric @code{lfg}. For computations using a Cartesian frame,
@code{lfg} should be the unit matrix of the appropriate dimension; for
computations in a Lorentz frame, @code{lfg} should have the appropriate
signature.

@end defvar

@c @node ctorsion_flag
@c @unnumberedsec phony
@defvar ctorsion_flag

Causes the contortion tensor to be included in the computation of the
connection coefficients. The contortion tensor itself is computed by
@code{contortion()} from the user-supplied tensor @code{tr}.

@end defvar

@c @node cnonmet_flag
@c @unnumberedsec phony
@defvar cnonmet_flag

Causes the nonmetricity coefficients to be included in the computation of
the connection coefficients. The nonmetricity coefficients are computed
from the user-supplied nonmetricity vector @code{nm} by the function
@code{nonmetricity()}.

@c @node ctayswitch
@c @unnumberedsec phony
@defvar ctayswitch

If set to @code{true}, causes some CTENSOR computations to be carried out using
Taylor-series expansions. Presently, @code{christof()}, @code{ricci()}, @code{uricci()},
@code{einstein()}, and @code{weyl()} take into account this setting, but only when
a holonomic metric is being used (i.e., @code{cframe_flag} is @code{false}).

@end defvar

@c @node gdet
@c @unnumberedsec phony
@defvar gdet

The determinant of the metric tensor @code{lg}. Computed by @code{cmetric()} when
@code{cframe_flag} is set to @code{false}.

@end defvar

@c @node ratchristof
@c @unnumberedsec phony
@defvar ratchristof

Causes rational simplification to be applied by @code{christof()}.

@end defvar

@c @node rateinstein
@c @unnumberedsec phony
@defvar rateinstein
 default: @code{true} - if @code{true} rational simplification will be
performed on the non-zero components of Einstein tensors; if
@code{ratfac} is @code{true} then the components will also be factored.

@end defvar
@c @node ratriemann
@c @unnumberedsec phony
@defvar ratriemann
 default: @code{true} - one of the switches which controls
simplification of Riemann tensors; if @code{true}, then rational
simplification will be done; if @code{ratfac} is @code{true} then each of the
components will also be factored.

@end defvar

@c @node ratweyl
@c @unnumberedsec phony
@defvar ratweyl
 default: @code{true} - If @code{true}, this switch causes the @code{Weyl()} function
to apply rational simplification to the values of the Weyl tensor. If
@code{ratfac} is @code{true}, then the components will also be factored.
@end defvar

@c @node lfg
@c @unnumberedsec phony
@defvar lfg
The covariant frame metric. By default, it is initialized to the 4-dimensional Lorentz frame with signature (+,+,+,-). Used when @code{cframe_flag} is @code{true}.
@end defvar

@c @node ufg
@c @unnumberedsec phony
@defvar ufg
The inverse frame metric. Computed from @code{lfg} when @code{cmetric()} is claled while @code{cframe_flag} is set to @code{true}.
@end defvar

@c @note riem
@c @unnumberedsec phony
@defvar riem
The (3,1) Riemann tensor. Computed when the function @code{riemann()} is invoked. For information about index ordering, see the description of @code{riemann()}.

if @code{cframe_flag} is @code{true}, @code{riem} is computed from the covariant Riemann-tensor @code{lriem}.

@end defvar

@c @node lriem
@c @unnumberedsec phony
@defvar lriem

The covariant Riemann tensor. Computed by @code{lriemann()}.

@end defvar

@c @node uriem
@c @unnumberedsec phony
@defvar uriem

The contravariant Riemann tensor. Computed by @code{uriemann()}.

@end defvar

@c @node ric
@c @unnumberedsec phony
@defvar ric

The mixed Ricci-tensor. Computed by @code{ricci()}.

@end defvar

@c @node uric
@c @unnumberedsec phony
@defvar uric

The contravariant Ricci-tensor. Computed by @code{uricci()}.

@end defvar

@c @node lg
@c @unnumberedsec phony
@defvar lg

The metric tensor. This tensor must be specified (as a @code{dim}x@code{dim} matrix)
before other computations can be performed.

@end defvar

@c @node ug
@c @unnumberedsec phony
@defvar ug

The inverse of the metric tensor. Computed by @code{cmetric()}.

@end defvar

@c @node weyl
@c @unnumberedsec phony
@defvar weyl

The Weyl tensor. Computed by @code{weyl()}.

@end defvar

@c @node fb
@c @unnumberedsec phony
@defvar fb

Frame bracket coefficients, as computed by @code{frame_bracket}.

@end defvar

@c @node kinvariant
@c @unnumberedsec phony
@defvar kinvariant

The Kretchmann invariant. Computed by @code{rinvariant()}.

@end defvar

@c @node np
@c @unnumberedsec phony
@defvar np

A Newman-Penrose null tetrad. Computed by @code{nptetrad()}.

@end defvar

@c @node npi
@c @unnumberedsec phony
@defvar npi

The inverse Newman-Penrose null tetrad. Computed by @code{nptetrad()}.

@end defvar

@c @node tr
@c @unnumberedsec phony
@defvar tr

User-supplied rank-3 tensor representing torsion. Used by @code{contortion()}.
@end defvar

@c @node kt
@c @unnumberedsec phony
@defvar kt

The contortion tensor, computed from @code{tr} by @code{contortion()}.
@end defvar

@c @node nm
@c @unnumberedsec phony
@defvar nm

User-supplied nonmetricity vector. Used by @code{nonmetricity()}.
@end defvar

@c @node nmc
@c @unnumberedsec phony

The nonmetricity coefficients, computed from @code{nm} by @code{nonmetricity()}.

@end defvar

@c @node tensorkill
@c @unnumberedsec phony
@defvar tensorkill

Variable indicating if the tensor package has been initialized. Set and used by
@code{csetup()}, reset by @code{init_ctensor()}.

@end defvar

@c @node ct_coords
@c @unnumberedsec phony
@defvar ct_coords
 default:[] - An option in the CTENSOR (Component Tensor
Manipulation) package.  @code{ct_coords} contains a list of coordinates.
While normally defined when the function @code{csetup} is called,
one may redefine the coordinates with the assignment
@code{ct_coords:[j1,j2,...jn]} where the j's are the new coordinate names.
See also @code{csetup}.

@end defvar

@subsection Reserved names

The following names are used internally by the CTENSOR package and
should not be redefined:

@example
  Name         Description
  ---------------------------------------
  _lg()
  _ug()
  cleanup()
  contract4()  Used by psi()
  filemet()    Used by csetup() when reading the metric from a file
  findde1()    Used by findde()
  findde2()    Used by findde()
  findde3()    Used by findde()
  kdelt()
  newmet()     Used by csetup() for setting up a metric interactively
  setflags()   Used by init_ctensor()
  readvalue()
  resimp()
  sermet()
  txyzsum()
  tmetric()    Frame metric, used by cmetric() when cframe_flag:true
  triemann()   Riemann-tensor in frame base, used when cframe_flag:true
  tricci()     Ricci-tensor in frame base, used when cframe_flag:true
  trrc()       Ricci rotation coefficients, used by christof()
  yesp()
@end example


@subsection Changes

In November, 2004, the CTENSOR package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of MACSYMA.


@example
  New Name     Old Name        Description
  --------------------------------------------------
  vect_coords  COORDINATES
  ctaylor()    DLGTAYLOR()
  lgeod[]      EM              Geodesic equations
  ein[]        G[]             Mixed Einstein-tensor
  ric[]        LR[]            Mixed Ricci-tensor
  ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
  ctaypov      MINP
  cgeodesic()  MOTION
  ct_coords    OMEGA           Metric coordinates
  ctayvar      PARAM
  lriem[]      R[]             Covariant Riemann-tensor
  uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
  ratriemann   RATRIEMAN       Rational simplification of the Riemann-tensor
  uric[]       RICCI[]         Contravariant Ricci-tensor
  uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
  cmetric()    SETMETRIC()     Set up the metric
  ctaypt       TAYPT
  ctayswitch   TAYSWITCH
  csetup()     TSETUP()        Start interactive setup session
  ctransform() TTRANSFORM()    Interactive coordinate transformation
  uriem[]      UR[]            Contravariant Riemann-tensor
  weyl[]       W[]             (3,1) Weyl-tensor

@end example

@section Developer's Notes

I added support for moving frames to CTENSOR in November, 2004. This
functionality was reconstructed on the basis of two things: code I
developed earlier for computations in a tetrad base, and the documentation
of commercial MACSYMA.

This implementation differs from commercial MACSYMA in an important
respect: when a frame base is used, the Ricci rotation coefficients are
computed directly, without referencing the frame bracket. (Hence the
lack of an implementation, at least for now, of @code{frame_bracket}.)
The algorithms have been verified through several examples, some of
which are included as demos: see @code{tetrad.dem} or @code{petrov.dem},
for instance.

Implementation of torsion and nonmetricity is a work-in-progress.
