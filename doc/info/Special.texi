@menu
* Introduction to Special Functions::  
* SPECINT::                     
* Definitions for Special Functions::  
@end menu

@node Introduction to Special Functions, SPECINT, Special Functions, Special Functions
@section Introduction to Special Functions

@c NEEDS EXPANSION OR EXPUNCTION
@deffn %K [index](expr)

Constant, in ODE2

@end deffn
@node SPECINT, Definitions for Special Functions, Introduction to Special Functions, Special Functions
@section SPECINT
 - The Hypergeometric Special Functions Package HYPGEO is
still under development.  At the moment it will find the Laplace
Transform or rather, the integral from 0 to INF of some special
functions or combinations of them.  The factor, EXP(-P*var) must be
explicitly stated.  The syntax is as follows:
SPECINT(EXP(-P*var)*expr,var);
where var is the variable of integration and expr may be
any expression containing special functions (at your own risk).
Special function notation follows:
@example
bessel_j(index, expr)         Bessel Funct 1st Kind
bessel_y(index, expr)           "     "    2nd Kind
bessel_i(index, expr)         Modified Bessel Funct 1st Kind
bessel_k(index, expr)
%HE[     ](  )                Hermite Poly (He, not H.  See A&S 22.5.18)
%P[  ]( )                     Legendre Funct
%Q[  ]( )                     Legendre of second kind
HSTRUVE[ ]( )                 Struve H Function
LSTRUVE[ ]( )                   "    L Function
%F[ ]([],[],expr)             Hypergeometric Function
GAMMA()                       Gamma function
GAMMAGREEK()                  Incomplete gamma function
GAMMAINCOMPLETE()             Tail of incomplete gamma function
SLOMMEL
%M[]()                        Whittaker Funct 1st Kind
%W[]()                           "       "    2nd  "
@end example
@noindent
For a better feeling for what it can do, do DEMO(HYPGEO,DEMO,SHARE1); .

@c end concepts Special Functions
@node Definitions for Special Functions,  , SPECINT, Special Functions
@section Definitions for Special Functions

@c airy IS IN THE bessel PACKAGE. ai, bi, ETC ARE IN THE airy PACKAGE.
@defun airy (@var{x})
returns the Airy function Ai of real argument X.

@c REMAINDER DERIVED FROM airy.usg AND SHOULD PROBABLY BE MOVED
@c TO A NODE DEVOTED TO THE airy PACKAGE.
The Airy equation @code{diff (y(x), x, 2) - x y(x) = 0} has two linearly independent
solutions, named @code{ai} and @code{bi}. This equation is very popular
as an approximation to more complicated problems in many mathematical
physics settings.

@code{load ("airy")} loads the functions @code{ai}, @code{bi}, @code{dai}, and @code{dbi}.

The @code{airy} package contains routines to compute
@code{ai} and @code{bi} and their derivatives @code{dai} and @code{dbi}. The result is
a floating point number if the argument is a number, and a
simplified form otherwise. An error occurs if the argument is large
enough to cause an overflow in the exponentials, or a loss of 
accuracy in @code{sin} or @code{cos}. This makes the range of validity
@c NEED TO UPDATE RANGES TO REFLECT DOUBLE PRECISION ARITHMETIC.
about -2800 to 10^38 for @code{ai} and @code{dai}, and -2800 to 25 for @code{bi} and @code{dbi}.
The derivative rules are known to Maxima:
@code{diff (ai(x), x)} yields @code{dai(x)},
@code{diff (dai(x), x)} yields @code{x ai(x)},
@code{diff (bi(x), x)} yields @code{dbi(x)},
and @code{diff (dbi(x), x)} yields @code{x bi(x)}.

Function values are computed from the convergent Taylor series for @code{abs(x) < 3},
and from the asymptotic expansions for @code{x < -3} or @code{x > 3} as needed.
This results in only very minor numerical discrepancies at @code{x = 3} and @code{x = -3}.
For details, see Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Section 10.4 and Table 10.11.

@code{ev (taylor (ai(x), x, 0, 9), infeval)} yields a
floating point Taylor expansions of the function @code{ai}.
A similar expression can be constructed for @code{bi}.

@end defun


@defun asympa
@code{asympa} is a package for asymptotic analysis. The package contains
simplification functions for asymptotic analysis, including the ``big O''
and ``little o'' functions that are widely used in complexity analysis and
numerical analysis.

@code{load ("asympa")} loads this package.

@end defun

@defun bessel (@var{z}, @var{a}) 
returns the value of Bessel function J for complex argument Z and real
order A > 0.0 .  Also an array BESSELARRAY is set up such that
BESSELARRAY[I] = J[I+A- ENTIER(A)](Z).

This function is deprecated.  Use BESSEL_J instead.

@end defun


@defun bessel_j (@var{v}, @var{z})
The Bessel function of the first kind of order @math{v} and argument
@math{z}.  Also, the array BESSELARRAY is computed such that
BESSELARRAY[I] = J[I + V - INT(V)](z).

It is defined by 
@ifinfo
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex
@end defun


@defun bessel_y (@var{v}, @var{z})
The Bessel function of the second kind of order @math{v} and argument
@math{z}.  Also, the array BESSELARRAY is computed such that
BESSELARRAY[I] = Y[I + V - INT(V)](z).

It is defined by
@ifinfo
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifinfo

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

when @math{v} is not an integer.  When @math{v} is an integer @math{n},
the limit as @math{v} approaches @math{n} is taken.

@end defun


@defun bessel_i (@var{v}, @var{z})
The modified Bessel function of the first kind of order @math{v} and
argument @math{z}.  Also, the array BESSELARRAY is computed such that
BESSELARRAY[I] = I[I + V - INT(V)](z).

It is defined by 
@ifinfo
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifinfo

@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

@end defun


@defun bessel_k (@var{v}, @var{z})
The modified Bessel function of the second kind of order @math{v} and
argument @math{z}.  Also, the array BESSELARRAY is computed such that
BESSELARRAY[I] = K[I + V - INT(V)](z).

It is defined by
@ifinfo
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifinfo
@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex
when @math{v} is not an integer.  If @math{v} is an integer @math{n},
then the limit as @math{v} approaches @math{n} is taken.
@end defun

@defvar besselexpand
Default value: @code{false}

Controls expansion of the Bessel functions when the order is half of
an odd integer.  In this case, the Bessel functions can be expanded
in terms of other elementary functions.  When @code{besselexpand} is @code{true},
the Bessel function is expanded.

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                          2 z   sin(z)   cos(z)
(%o4)                sqrt(---) (------ - ------)
                          %pi      2       z
                                  z
@end example
@end defvar


@defun j0 (@var{x})
The Bessel function of the first kind of order 0.

Deprecated.  Write @code{bessel_j (0, @var{x})} instead.

@end defun


@defun j1 (@var{x})
The Bessel function of the first kind of order 1.

Deprecated.  Write @code{bessel_j (1, @var{x})} instead.

@end defun


@defun jn (@var{x}, @var{n})
The Bessel function of the first kind of order N.

Deprecated.  Write @code{bessel_j (@var{n}, @var{x})} instead.

@end defun


@defun i0 (@var{x})
The modified Bessel function of the first kind of order 0.

Deprecated.  Write @code{bessel_i (0, @var{x})} instead.

@end defun


@defun i1 (@var{x})
The Bessel function of the first kind of order 1.

Deprecated.  Write @code{bessel_i (1, @code{x})} instead.

@end defun


@defun beta (@var{x}, @var{y})
Same as gamma(x)*gamma(y)/gamma(x+y).

@end defun

@defun gamma (@var{x})
The gamma function. GAMMA(I)=(I-1)!  for I a positive
integer.  For the Euler-Mascheroni constant, see %GAMMA.  See also the
MAKEGAMMA function.  The variable GAMMALIM[1000000] (which see)
controls simplification of the gamma function.

@end defun

@defvar gammalim
 default: [1000000] controls simplification of the gamma
function for integral and rational number arguments.  If the absolute
value of the argument is not greater than GAMMALIM, then
simplification will occur.  Note that the FACTLIM switch controls
simplification of the result of GAMMA of an integer argument as well.

@end defvar

@defun intopois (@var{a})
converts A into a Poisson encoding.

@end defun

@defun makefact (@var{expr})
transforms occurrences of binomial,gamma, and beta
functions in exp to factorials.

@end defun

@defun makegamma (@var{expr})
transforms occurrences of binomial,factorial, and beta
functions in exp to gamma functions.

@end defun

@defun numfactor (@var{expr})
gives the numerical factor multiplying the expression
exp which should be a single term.  If the gcd of all the terms in a
sum is desired the CONTENT function may be used.
@example
(%i1) GAMMA(7/2);
(%o1)               15 SQRT(%PI)
                   ------------
                        8
(%i2) NUMFACTOR(%);
                    15
(%o2)                --
                     8


@end example
@end defun

@defun outofpois (@var{a})
converts A from Poisson encoding to general
representation.  If A is not in Poisson form, it will make the
conversion, i.e.  it will look like the result of
OUTOFPOIS(INTOPOIS(A)).  This function is thus a canonical simplifier
for sums of powers of SIN's and COS's of a particular type.

@end defun

@defun poisdiff (@var{a}, @var{b})
differentiates A with respect to B.  B must occur only
in the trig arguments or only in the coefficients.

@end defun

@defun poisexpt (@var{a}, @var{b})
B a positive integer) is functionally identical to
INTOPOIS(A**B).

@end defun

@defun poisint (@var{a}, @var{b})
integrates in a similarly restricted sense (to
POISDIFF).  Non-periodic terms in B are dropped if B is in the trig
arguments.

@end defun

@defvar poislim
 default: [5] - determines the domain of the coefficients in
the arguments of the trig functions.  The initial value of 5
corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but it
can be set to [-2^(n-1)+1, 2^(n-1)].

@end defvar

@c UMM, WHAT IS THIS ABOUT EXACTLY ?? EXAMPLES NEEDED
@defun poismap (@var{series}, @var{sinfn}, @var{cosfn})
will map the functions sinfn on the
sine terms and cosfn on the cosine terms of the poisson series given.
sinfn and cosfn are functions of two arguments which are a coefficient
and a trigonometric part of a term in series respectively.

@end defun

@defun poisplus (@var{a}, @var{b})
is functionally identical to INTOPOIS(A+B).

@end defun

@defun poissimp (@var{a})
converts A into a Poisson series for A in general
representation.

@end defun

@defvr {special symbol} poisson
 - The Symbol /P/ follows the line label of Poisson series
expressions.

@end defvr

@defun poissubst (@var{a}, @var{b}, @var{c})
substitutes A for B in C.  C is a Poisson series.
(1) Where B is a variable U, V, W, X, Y, or Z then A must be an
expression linear in those variables (e.g. 6*U+4*V).
(2) Where B is other than those variables, then A must also be
free of those variables, and furthermore, free of sines or cosines.
POISSUBST(A, B, C, D, N) is a special type of substitution which
operates on A and B as in type (1) above, but where D is a Poisson
series, expands COS(D) and SIN(D) to order N so as to provide the
result of substituting A+D for B in C.  The idea is that D is an
expansion in terms of a small parameter.  For example,
POISSUBST(U,V,COS(V),E,3) results in COS(U)*(1-E^2/2) -
SIN(U)*(E-E^3/6).

@end defun

@defun poistimes (@var{a}, @var{b})
is functionally identical to INTOPOIS(A*B).

@end defun

@defun poistrim ()
is a reserved function name which (if the user has defined
it) gets applied during Poisson multiplication.  It is a predicate
function of 6 arguments which are the coefficients of the U, V,..., Z
in a term.  Terms for which POISTRIM is @code{true} (for the coefficients of
that term) are eliminated during multiplication.

@end defun

@defun printpois (@var{a})
prints a Poisson series in a readable format.  In common
with OUTOFPOIS, it will convert A into a Poisson encoding first, if
necessary.

@end defun

@defun psi (@var{x})
derivative of LOG(GAMMA(X)).  At this time, Maxima does not
have numerical evaluation capabilities for PSI.  For information on
the PSI[N](X) notation, see POLYGAMMA.

@end defun
