@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /stats.texi/1.3/Mon Dec 25 13:25:10 2006//
@menu
* Introdu@value{cedilha}@~ao a stats::
* Defini@value{cedilha}@~oes para inference_result::
* Defini@value{cedilha}@~oes para stats::
* Defini@value{cedilha}@~oes para distribui@value{cedilha}@~oes especiais::
@end menu

@node Introdu@value{cedilha}@~ao a stats, Defini@value{cedilha}@~oes para inference_result, Top, Top
@section Introdu@value{cedilha}@~ao a stats


O pacote @code{stats} cont@'em um conjunto de procedimentos de infer@^encia cl@'assica 
estat@'istica e procedimentos de teste.

Todas essas fun@,{c}@~oes retornam um objeto do Maxima chamado @code{inference_result} que cont@'em
os resultados necess@'arios para infer@^encias de manipula@,{c}@~ao e tomada de decis@~oes.

A vari@'avel global @code{stats_numer} controla se resultados s@~ao mostrados em 
ponto flutuante ou simb@'olico e no formato racional; seu valor padr@~ao @'e @code{true}
e os resultados s@~ao retornados no formato de ponto flutuante.

O pacote @code{descriptive} cont@'em alguns utilit@'arios para manipular estruturas de dados
(listas e matrizes); por exemplo, para extrair subamostras. O pacote @code{descriptive} tamb@'em cont@'em alguns
exemplos sobre como usar o pacote @code{numericalio} para ler dados a partir de arquivo no formato texto 
plano. Veja @code{descriptive} e @code{numericalio} para maiores detalhes.

O pacote @code{stats} precisa dos pacotes @code{descriptive}, @code{distrib} e
@code{inference_result}.

Para coment@'arios, erros ou sugest@~oes, por favor contate o autor em

@var{'mario AT edu DOT xunta DOT es'}.


@node Defini@value{cedilha}@~oes para inference_result, Defini@value{cedilha}@~oes para stats, Introdu@value{cedilha}@~ao a stats, Top
@section Defini@value{cedilha}@~oes para inference_result

@deffn {Fun@,{c}@~ao} inference_result (@var{t@'itulo}, @var{valores}, @var{n@'umeros})

Constr@'oi um objeto @code{inference_result} do tipo retornado pelas
fun@,{c}@~oes stats. O argumento @var{t@'itulo} @'e uma
seq@"u@^encia de caracteres do Maxima co o nome do procedimento; @var{valores} @'e uma lissta com
elementos da forma @code{s@'imbolo = valor} e @var{n@'umeros} @'e uma lista
com n@'umeros inteiros positivos no intervalo de um para @code{length(@var{valores})},
indicando que valores ser@~ao mostrados por padr@~ao.

Exemplo:

Este @'e um exemplo que mostras os resultados associados a um ret@'angulo. O
t@'itulo deste bojeto @'e a seq@"u@^encia de caraceteres @code{"Ret@^angulo"}, o qual
armazena cinco resultados, a saber, @code{'base}, @code{'altura}, 
@code{'diagonal}, @code{'@'area} y @code{'per@'imetro}, por@'em s@'o mostra
o primeiro, segundo, quinto e quarto resultado. O resultado @code{'diagonal} tamb@'em
@'e armazenado neste objeto, no entanto n@~ao @'e mostrado por padr@~ao; para se ter acesso
a este valor, faz-se uso da fun@,{c}@~ao @code{take_inference}.

@c ===beg===
@c load (inference_result)$
@c b: 3$ h: 2$
@c inference_result("Ret@^angulo",
@c                  ['base=b,
@c                   'altura=h,
@c                   'diagonal=sqrt(b^2+h^2),
@c                   'area=b*h,
@c                   'per@'imetro=2*(b+h)],
@c                  [1,2,5,4] );
@c take_inference('diagonal,%);
@c ===end===
@example
(%i1) load(inference_result)$
(%i2) b: 3$ h: 2$
(%i3) inference_result("Ret@^angulo",
                        ['base=b,
                         'altura=h,
                         'diagonal=sqrt(b^2+h^2),
                         '@'area=b*h,
                         'per@'imetro=2*(b+h)],
                        [1,2,5,4] );
                        |   Ret@^angulo
                        |
                        |    base = 3
                        |
(%o3)                   |   altura = 2
                        |
                        | per@'imetro = 10
                        |
                        |    area = 6
(%i4) take_inference('diagonal,%);
(%o4)                        sqrt(13)
@end example

Veja tamb@'em @code{take_inference}.
@end deffn






@deffn {Fun@,{c}@~ao} inferencep (@var{obj})

Retorna @code{true} ou @code{false}, dependendo se @var{obj} @'e
um objeto @code{inference_result} ou n@~ao.

@end deffn






@deffn {Fun@,{c}@~ao} items_inference (@var{obj})

Retorna uma lista com os nomes dos itens em @var{obj}, que devem
ser um objeto @code{inference_result}.

Exemplo:

O objeto @code{inference_result} armazena dois valores, a saber @code{'pi} e @code{'e},
mas somente o segundo @'e mostrado. A fun@,{c}@~ao @code{items_inference} retorna os nomes
de todos os itens, n@~ao importa se eles s@~ao ou n@~ao mostrados.

@c ===beg===
@c load (inference_result)$
@c inference_result("Hi", ['pi=%pi,'e=%e],[2]);
@c items_inference(%);
@c ===end===
@example
(%i1) load(inference_result)$
(%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                            |   Hi
(%o2)                       |
                            | e = %e
(%i3) items_inference(%);
(%o3)                        [pi, e]
@end example
@end deffn







@deffn {Fun@,{c}@~ao} take_inference (@var{n}, @var{obj})
@deffnx {Fun@,{c}@~ao} take_inference (@var{nome}, @var{obj})
@deffnx {Fun@,{c}@~ao} take_inference (@var{lista}, @var{obj})

Retorna o @var{n}-@'esimo valor armazenado em @var{obj} se @var{n} for um inteiro positivo,
ou o item chamado @var{nome} se esse for o nome de um item. Se o primeiro
argumento for uma lista de n@'umeros e/ou s@'imbolos, a fun@,{c}@~ao @code{take_inference} retorna
uma lista com os resultados correspondentes.

Exemplo:

Fornece um objeto @code{inference_result}, a fun@,{c}@~ao @code{take_inference} @'e
chamada com o objetivo de extrair alguma informa@,{c}@~ao armazenada nesse objeto.

@c ===beg===
@c load (inference_result)$
@c b: 3$ h: 2$
@c sol:inference_result("Ret@^angulo",
@c                      ['base=b,
@c                       'altura=h,
@c                       'diagonal=sqrt(b^2+h^2),
@c                       'area=b*h,
@c                       'per@'imetro=2*(b+h)],
@c                      [1,2,5,4] );
@c take_inference('base,sol);
@c take_inference(5,sol);
@c take_inference([1,'diagonal],sol);
@c take_inference(items_inference(sol),sol);
@c ===end===
@example
(%i1) load(inference_result)$
(%i2) b: 3$ h: 2$
(%i3) sol: inference_result("Ret@^angulo",
                            ['base=b,
                             'altura=h,
                             'diagonal=sqrt(b^2+h^2),
                             'area=b*h,
                             'per@'imetro=2*(b+h)],
                            [1,2,5,4] );
                        |   Ret@^angulo
                        |
                        |    base = 3
                        |
(%o3)                   |   altura = 2
                        |
                        | per@'imetro = 10
                        |
                        |    area = 6
(%i4) take_inference('base,sol);
(%o4)                           3
(%i5) take_inference(5,sol);
(%o5)                          10
(%i6) take_inference([1,'diagonal],sol);
(%o6)                     [3, sqrt(13)]
(%i7) take_inference(items_inference(sol),sol);
(%o7)                [3, 2, sqrt(13), 6, 10]
@end example

Veja tamb@'em @code{inference_result} e @code{take_inference}.
@end deffn









@node Defini@value{cedilha}@~oes para stats, Defini@value{cedilha}@~oes para distribui@value{cedilha}@~oes especiais, Defini@value{cedilha}@~oes para inference_result, Top
@section Defini@value{cedilha}@~oes para stats


@defvr {Vari@'avel de op@,{c}@~ao} stats_numer
Valor padr@~ao: @code{true}

Se @code{stats_numer} for @code{true}, fun@,{c}@~oes de infer@^encia estat@'istica 
retornam seus resultados em n@'umeros com ponto flutuante. Se @code{stats_numer} for @code{false},
resultados s@~ao fornecidos em formato simb@'olico e racional.

@end defvr


@deffn {Fun@,{c}@~ao} test_mean (@var{x})
@deffnx {Fun@,{c}@~ao} test_mean (@var{x}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

Esse @'e o teste-@var{t} de m@'edia. O argumento @var{x} @'e uma lista ou uma matriz coluna
contendo uma amostra unidimensional. @code{test_mean} tamb;em executa um teste assint@'otico
baseado no @i{Teorema do Limite Central} se a op@,{c}@~ao @code{'asymptotic} for
@code{true}.

Op@,{c}@~oes:

@itemize @bullet

@item
@code{'mean}, o valor padr@~ao @'e @code{0}, @'e o valor da m@'edia a ser verificado.

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, @'e a hip@'otese alternativa;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@item
@code{'dev}, o valor padr@~ao @'e @code{'unknown}, corresponde ao valor do desvio padr@~ao quando esse valor de desvio padr@~ao for
conhecido; valores v@'alidos s@~ao: @code{'unknown} ou uma express@~ao positiva.

@item
@code{'conflevel}, o valor padr@~ao @'e @code{95/100}, n@'ivel de confid@^encia para o intervalo de confid@^encia; deve
ser uma express@~ao que toma um valor em (0,1).

@item
@code{'asymptotic}, o valor padr@~ao @'e @code{false}, indica se @code{test_mean} exeecuta um teste-@var{t} exato ou
um teste assint@'otico baseando-se no @i{Teorema do Limite Central};
valores v@'alidos s@~ao @code{true} e @code{false}.

@end itemize

A sa@'ida da fun@,{c}@~ao @code{test_mean} @'e um objeto @code{inference_result} do Maxima
mostrando os seguintes resultados:

@enumerate

@item
@code{'mean_estimate}: a m@'edia da amostra.

@item
@code{'conf_level}: n@'ivel de confid@^encia selecionado pelo usu@'ario.

@item
@code{'conf_interval}: intervalo de confid@^encia para a m@'edia da popula@,{c}@~ao.

@item
@code{'method}: procedimento de infer@^encia.

@item
@code{'hypotheses}: hip@'otese do nulo e hip@'otese alternativa a ser testada.

@item
@code{'statistic}: valor da amostra estat@'istica a ser usado para testar a hip@'otese do nulo.

@item
@code{'distribution}: distribui@,{c}@~ao da amostra estat@'istica, juntamente com seus par@^ametro(s).

@item
@code{'p_value}: valores de @math{p} do teste.

@end enumerate

Exemplos:

Executa um teste-@var{t} exato com vari@^ancia desconhecida. A hip@'otese do nulo
@'e @math{H_0: mean=50} contra a alternativa unilatera @math{H_1: mean<50};
conforme os resultados, o valor de @math{p} @'e muito grande, n@~ao existem
evid@^encias paa rejeitar @math{H_0}.

@c ===beg===
@c load (stats)$
@c data: [78,64,35,45,45,75,43,74,42,42]$
@c test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
@c ===end===
@example
(%i1) load("stats")$
(%i2) data: [78,64,35,45,45,75,43,74,42,42]$
(%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
          |                 MEAN TEST
          |
          |            mean_estimate = 54.3
          |
          |              conf_level = 0.9
          |
          | conf_interval = [minf, 61.51314273502712]
          |
(%o3)     |  method = Exact t-test. Unknown variance.
          |
          | hypotheses = H0: mean = 50 , H1: mean < 50
          |
          |       statistic = .8244705235071678
          |
          |       distribution = [student_t, 9]
          |
          |        p_value = .7845100411786889
@end example

Nesta ocasi@~ao Maxima executa um testte assint@'otico, baseado no @i{Teorema do Limite Central}.
A hip@'otese do nulo @'e @math{H_0: equal(mean, 50)} contra a alternativa de duas vias @math{H_1: not equal(mean, 50)};
conforme os resultados, o valor de @math{p} @'e muito pequeno, @math{H_0} pode ser rejeitado em
favor da alternativa @math{H_1}. Note que, como indicado pela componente @code{Method},
esse procedimento pode ser aplicado a grandes amostras.

@c ===beg===
@c load (stats)$
@c test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
@c         98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
@c         45,51,123,54,151],
@c         'asymptotic=true,'mean=50);
@c ===end===
@example
(%i1) load("stats")$
(%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
              98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
              45,51,123,54,151],
              'asymptotic=true,'mean=50);
          |                       MEAN TEST
          |
          |           mean_estimate = 74.88571428571429
          |
          |                   conf_level = 0.95
          |
          | conf_interval = [57.72848600856194, 92.04294256286663]
          |
(%o2)     |    method = Large sample z-test. Unknown variance.
          |
          |       hypotheses = H0: mean = 50 , H1: mean # 50
          |
          |             statistic = 2.842831192874313
          |
          |             distribution = [normal, 0, 1]
          |
          |             p_value = .004471474652002261
@end example

@end deffn







@deffn {Fun@,{c}@~ao} test_means_difference (@var{x1}, @var{x2})
@deffnx {Fun@,{c}@~ao} test_means_difference (@var{x1}, @var{x2}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

Esse @'e o teste-@var{t} de diferen@,{c}a de m@'edias entre duas amostras.
Os argumentos @var{x1} e @var{x2} s@~ao listas ou matrizes colunas
contendo duas amostras independentes. No caso de diferentes vari@^ancias desconhecidas
(veja op@,{c}@~oes @code{'dev1}, @code{'dev2} e @code{'varequal} abaixo),
os graus de liberdade s@~ao calculados por meio da aproxima@,{c}@~ao de Welch.
@code{test_means_difference} tamb@'em executa um teste assint@'otico
baseado no @i{Teorema do Limite Central} se a op@,{c}@~ao @code{'asymptotic} for
escolhida para @code{true}.

Op@,{c}@~oes:

@itemize @bullet

@item

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, @'e a hip@'otese alternativa;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@item
@code{'dev1}, o valor padr@~ao @'e @code{'unknown}, @'e o valor do desvio padr@~ao
da amostra @var{x1} quando esse desvio for conhecido; valores v@'alidos s@~ao: @code{'unknown} ou uma express@~ao positiva.

@item
@code{'dev2}, o valor padr@~ao @'e @code{'unknown}, @'e o valor do desvio padr@~ao
da amostra @var{x2} quando esse desvio for conhecido; valores v@'alidos s@~ao: @code{'unknown} ou uma express@~ao positiva.

@item
@code{'varequal}, o valor padr@~ao @'e @code{false}, se vari@^ancias podem serem consideradas como iguais ou n@~ao;
essa op@,{c}@~ao tem efeito somente quando @code{'dev1} e/ou @code{'dev2} forem  @code{'unknown}.

@item
@code{'conflevel}, o valor padr@~ao @'e @code{95/100}, n@'ivel de confid@^encia para o intervalo de confid@^encia; deve
ser uma express@~ao que toma valores em (0,1).

@item
@code{'asymptotic}, o valor padr@~ao @'e @code{false}, indicates whether it performs an exact @var{t}-test or
an asymptotic one based on the @i{Central Limit Theorem};
valores v@'alidos s@~ao @code{true} e @code{false}.

@end itemize

The output of function @code{test_means_difference} is an @code{inference_result} Maxima object
showing the following results:

@enumerate

@item
@code{'diff_estimate}: the difference of means estimate.

@item
@code{'conf_level}: confidence level selected by the user.

@item
@code{'conf_interval}: confidence interval for the difference of means.

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameter(s).

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate

Exemplos:

The equality of means is tested with two small samples @var{x} e @var{y},
against the alternative @math{H_1: m_1>m_2}, being @math{m_1} e @math{m_2}
the populations means; variances are unknown and supposed to be different.

@c equivalent code for R:
@c x <- c(20.4,62.5,61.3,44.2,11.1,23.7)
@c y <- c(1.2,6.9,38.7,20.4,17.2)
@c t.test(x,y,alternative="greater")

@c ===beg===
@c load (stats)$
@c x: [20.4,62.5,61.3,44.2,11.1,23.7]$
@c y: [1.2,6.9,38.7,20.4,17.2]$
@c test_means_difference(x,y,'alternative='greater);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
(%i3) y: [1.2,6.9,38.7,20.4,17.2]$
(%i4) test_means_difference(x,y,'alternative='greater);
            |              DIFFERENCE OF MEANS TEST
            |
            |         diff_estimate = 20.31999999999999
            |
            |                 conf_level = 0.95
            |
            |    conf_interval = [- .04597417812882298, inf]
            |
(%o4)       |        method = Exact t-test. Welch approx.
            |
            | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
            |
            |           statistic = 1.838004300728477
            |
            |    distribution = [student_t, 8.62758740184604]
            |
            |            p_value = .05032746527991905
@end example

The same test as before, but now variances are supposed to be
equal.

@c equivalent code for R:
@c x <- c(20.4,62.5,61.3,44.2,11.1,23.7)
@c y <- c(1.2,6.9,38.7,20.4,17.2)
@c t.test(x,y,var.equal=T,alternative="greater")

@c ===beg===
@c load (stats)$
@c x: [20.4,62.5,61.3,44.2,11.1,23.7]$
@c y: [1.2,6.9,38.7,20.4,17.2]$
@c test_means_difference(x,y,'alternative='greater,'varequal=true);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
(%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
(%i4) test_means_difference(x,y,'alternative='greater,'varequal=true);
            |              DIFFERENCE OF MEANS TEST
            |
            |         diff_estimate = 20.31999999999999
            |
            |                 conf_level = 0.95
            |
            |     conf_interval = [- .7722627696897568, inf]
            |
(%o4)       |   method = Exact t-test. Unknown equal variances
            |
            | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
            |
            |           statistic = 1.765996124515009
            |
            |           distribution = [student_t, 9]
            |
            |            p_value = .05560320992529344
@end example

@end deffn







@deffn {Fun@,{c}@~ao} test_variance (@var{x})
@deffnx {Fun@,{c}@~ao} test_variance (@var{x}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

This is the variance @var{chi^2}-test. Argument @var{x} is a list or a column matrix
containing a one dimensional sample taken from a normal population.

Options:

@itemize @bullet

@item
@code{'mean}, o valor padr@~ao @'e @code{'unknown}, is the population's mean, when it is known.

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, is the alternative hypothesis;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@item
@code{'variance}, o valor padr@~ao @'e @code{1}, this is the variance value (positive) to be checked.

@item
@code{'conflevel}, o valor padr@~ao @'e @code{95/100}, confidence level for the confidence interval; it must
be an expression which takes a value in (0,1).

@end itemize

The output of function @code{test_variance} is an @code{inference_result} Maxima object
showing the following results:

@enumerate

@item
@code{'var_estimate}: the sample variance.

@item
@code{'conf_level}: confidence level selected by the user.

@item
@code{'conf_interval}: confidence interval for the population variance.

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameter.

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate

Exemplos:

It is tested whether the variance of a population with unknown mean
is equal to or greater than 200.

@c ===beg===
@c load (stats)$
@c x: [203,229,215,220,223,233,208,228,20]$
@c test_variance(x,'alternative='greater,'variance=200);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [203,229,215,220,223,233,208,228,209]$
(%i3) test_variance(x,'alternative='greater,'variance=200);
             |                  VARIANCE TEST
             |
             |              var_estimate = 110.75
             |
             |                conf_level = 0.95
             |
             |     conf_interval = [57.13433376937479, inf]
             |
(%o3)        | method = Variance Chi-square test. Unknown mean.
             |
             |    hypotheses = H0: var = 200 , H1: var > 200
             |
             |                 statistic = 4.43
             |
             |             distribution = [chi2, 8]
             |
             |           p_value = .8163948512777689
@end example

@end deffn







@deffn {Fun@,{c}@~ao} test_variance_ratio (@var{x1}, @var{x2})
@deffnx {Fun@,{c}@~ao} test_variance_ratio (@var{x1}, @var{x2}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

This is the variance ratio @var{F}-test for two normal populations.
Arguments @var{x1} e @var{x2} are lists or column matrices
containing two independent samples.

Options:

@itemize @bullet

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, is the alternative hypothesis;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@item
@code{'mean1}, o valor padr@~ao @'e @code{'unknown}, when it is known, this is the mean of
the population from which @var{x1} was taken.

@item
@code{'mean2}, o valor padr@~ao @'e @code{'unknown}, when it is known, this is the mean of
the population from which @var{x2} was taken.

@item
@code{'conflevel}, o valor padr@~ao @'e @code{95/100}, confidence level for the confidence interval of the
ratio; it must be an expression which takes a value in (0,1).

@end itemize

The output of function @code{test_variance_ratio} is an @code{inference_result} Maxima object
showing the following results:

@enumerate

@item
@code{'ratio_estimate}: the sample variance ratio.

@item
@code{'conf_level}: confidence level selected by the user.

@item
@code{'conf_interval}: confidence interval for the variance ratio.

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameters.

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate


Exemplos:

The equality of the variances of two normal populations is checked
against the alternative that the first is greater than the second.

@c equivalent code for R:
@c x <- c(20.4,62.5,61.3,44.2,11.1,23.7)
@c y <- c(1.2,6.9,38.7,20.4,17.2)
@c var.test(x,y,alternative="greater")

@c ===beg===
@c load (stats)$
@c x: [20.4,62.5,61.3,44.2,11.1,23.7]$
@c y: [1.2,6.9,38.7,20.4,17.2]$
@c test_variance_ratio(x,y,'alternative='greater);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
(%i3) y: [1.2,6.9,38.7,20.4,17.2]$
(%i4) test_variance_ratio(x,y,'alternative='greater);
              |              VARIANCE RATIO TEST
              |
              |       ratio_estimate = 2.316933391522034
              |
              |               conf_level = 0.95
              |
              |    conf_interval = [.3703504689507268, inf]
              |
(%o4)         | method = Variance ratio F-test. Unknown means.
              |
              | hypotheses = H0: var1 = var2 , H1: var1 > var2
              |
              |         statistic = 2.316933391522034
              |
              |            distribution = [f, 5, 4]
              |
              |          p_value = .2179269692254457
@end example

@end deffn






@deffn {Fun@,{c}@~ao} test_sign (@var{x})
@deffnx {Fun@,{c}@~ao} test_sign (@var{x}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

This is the non parametric sign test for the median of a continuous population.
Argument @var{x} is a list or a column matrix containing a one dimensional sample.

Options:

@itemize @bullet

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, is the alternative hypothesis;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@item
@code{'median}, o valor padr@~ao @'e @code{0}, is the median value to be checked.

@end itemize

The output of function @code{test_sign} is an @code{inference_result} Maxima object
showing the following results:

@enumerate

@item
@code{'med_estimate}: the sample median.

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameter(s).

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate

Exemplos:

Checks whether the population from which the sample was taken has median 6, 
against the alternative @math{H_1: median > 6}.

@c ===beg===
@c load (stats)$
@c x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
@c test_sign(x,'median=6,'alternative='greater);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
(%i3) test_sign(x,'median=6,'alternative='greater);
               |                  SIGN TEST
               |
               |              med_estimate = 5.1
               |
               |      method = Non parametric sign test.
               |
(%o3)          | hypotheses = H0: median = 6 , H1: median > 6
               |
               |                statistic = 7
               |
               |      distribution = [binomial, 10, 0.5]
               |
               |         p_value = .05468749999999989
@end example

@end deffn









@deffn {Fun@,{c}@~ao} test_signed_rank (@var{x})
@deffnx {Fun@,{c}@~ao} test_signed_rank (@var{x}, @var{op@,{c}@~ao_1}, @var{op@,{c}@~ao_2}, ...)

This is the Wilcoxon signed rank test to make inferences about the median of a
continuous population. Argument @var{x} is a list or a column matrix
containing a one dimensional sample. Performs normal approximation if the
sample size is greater than 20, or if there are zeroes or ties.

Veja tamb@'em @code{pdf_rank_test} e @code{cdf_rank_test}.

Options:

@itemize @bullet

@item
@code{'median}, o valor padr@~ao @'e @code{0}, is the median value to be checked.

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, is the alternative hypothesis;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@end itemize

The output of function @code{test_signed_rank} is an @code{inference_result} Maxima object
with the following results:

@enumerate

@item
@code{'med_estimate}: the sample median.

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameter(s).

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate

Exemplos:

Checks the null hypothesis @math{H_0: median = 15} against the 
alternative @math{H_1: median > 15}. This is an exact test, since
there are no ties.

@c equivalent code for R:
@c x <- c(17.1,15.9,13.7,13.4,15.5,17.6)
@c wilcox.test(x,mu=15,alternative="greater")

@c ===beg===
@c load (stats)$
@c x: [17.1,15.9,13.7,13.4,15.5,17.6]$
@c test_signed_rank(x,median=15,alternative=greater);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
(%i3) test_signed_rank(x,median=15,alternative=greater);
                 |             SIGNED RANK TEST
                 |
                 |           med_estimate = 15.7
                 |
                 |           method = Exact test
                 |
(%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                 |
                 |              statistic = 14
                 |
                 |     distribution = [signed_rank, 6]
                 |
                 |            p_value = 0.28125
@end example

Checks the null hypothesis @math{H_0: equal(median, 2.5)} against the 
alternative @math{H_1: not equal(median, 2.5)}. This is an approximated test,
since there are ties.

@c equivalent code for R:
@c y<-c(1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1)
@c wilcox.test(y,mu=2.5)

@c ===beg===
@c load (stats)$
@c y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
@c test_signed_rank(y,median=2.5);
@c ===end===
@example
(%i1) load("stats")$
(%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
(%i3) test_signed_rank(y,median=2.5);
             |                 SIGNED RANK TEST
             |
             |                med_estimate = 2.9
             |
             |          method = Asymptotic test. Ties
             |
(%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
             |
             |                 statistic = 76.5
             |
             | distribution = [normal, 60.5, 17.58195097251724]
             |
             |           p_value = .3628097734643669
@end example

@end deffn







@deffn {Fun@,{c}@~ao} test_rank_sum (@var{x1}, @var{x2})
@deffnx {Fun@,{c}@~ao} test_rank_sum (@var{x1}, @var{x2}, @var{op@,{c}@~ao_1})

This is the Wilcoxon-Mann-Whitney test for comparing the medians of two
continuous populations. The first two arguments @var{x1} e @var{x2} are lists
or column matrices with the data of two independent samples. Performs normal
approximation if any of the sample sizes is greater than 10, or if there are ties.

Option:

@itemize @bullet

@item
@code{'alternative}, o valor padr@~ao @'e @code{'twosided}, is the alternative hypothesis;
valores v@'alidos s@~ao: @code{'twosided}, @code{'greater} e @code{'less}.

@end itemize

The output of function @code{test_rank_sum} is an @code{inference_result} Maxima object
with the following results:

@enumerate

@item
@code{'method}: inference procedure.

@item
@code{'hypotheses}: null and alternative hypotheses to be tested.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameters.

@item
@code{'p_value}: @math{p}-value of the test.

@end enumerate

Exemplos:

Checks whether populations have similar medians. Samples sizes
are small and an exact test is made.

@c equivalent code for R:
@c x <- c(12,15,17,38,42,10,23,35,28)
@c y <- c(21,18,25,14,52,65,40,43)
@c wilcox.test(x,y)

@c ===beg===
@c load (stats)$
@c x:[12,15,17,38,42,10,23,35,28]$
@c y:[21,18,25,14,52,65,40,43]$
@c test_rank_sum(x,y);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x:[12,15,17,38,42,10,23,35,28]$
(%i3) y:[21,18,25,14,52,65,40,43]$
(%i4) test_rank_sum(x,y);
              |                 RANK SUM TEST
              |
              |              method = Exact test
              |
              | hypotheses = H0: med1 = med2 , H1: med1 # med2
(%o4)         |
              |                 statistic = 22
              |
              |        distribution = [rank_sum, 9, 8]
              |
              |          p_value = .1995886466474702
@end example

Now, with greater samples and ties, the procedure makes 
normal approximation. The alternative hypothesis is
@math{H_1: median1 < median2}.

@c equivalent code for R:
@c x <- c(39,42,35,13,10,23,15,20,17,27)
@c y <- c(20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15)
@c wilcox.test(x,y,alternative="less")

@c ===beg===
@c load (stats)$
@c x: [39,42,35,13,10,23,15,20,17,27]$
@c y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
@c test_rank_sum(x,y,'alternative='less);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x: [39,42,35,13,10,23,15,20,17,27]$
(%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
(%i4) test_rank_sum(x,y,'alternative='less);
             |                  RANK SUM TEST
             |
             |          method = Asymptotic test. Ties
             |
             |  hypotheses = H0: med1 = med2 , H1: med1 < med2
(%o4)        |
             |                 statistic = 48.5
             |
             | distribution = [normal, 79.5, 18.95419580097078]
             |
             |           p_value = .05096985666598441
@end example

@end deffn







@deffn {Fun@,{c}@~ao} test_normality (@var{x})

Shapiro-Wilk test for normality. Argument @var{x} is a list of numbers, and sample
size must be greater than 2 and less or equal than 5000, otherwise, function
@code{test_normality} signals an error message.

Reference:

  [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4, 547-551

The output of function @code{test_normality} is an @code{inference_result} Maxima object
with the following results:

@enumerate

@item
@code{'statistic}: value of the @var{W} statistic.

@item
@code{'p_value}: @math{p}-value under normal assumption.

@end enumerate

Exemplos:

Checks for the normality of a population, based on a sample of size 9.

@c equivalent code for R:
@c x <- c(12,15,17,38,42,10,23,35,28)
@c shapiro.test(x)

@c ===beg===
@c load (stats)$
@c x:[12,15,17,38,42,10,23,35,28]$
@c test_normality(x);
@c ===end===
@example
(%i1) load("stats")$
(%i2) x:[12,15,17,38,42,10,23,35,28]$
(%i3) test_normality(x);
                       |      SHAPIRO - WILK TEST
                       |
(%o3)                  | statistic = .9251055695162436
                       |
                       |  p_value = .4361763918860381
@end example

@end deffn









@deffn {Fun@,{c}@~ao} simple_linear_regression (@var{x})
@deffnx {Fun@,{c}@~ao} simple_linear_regression (@var{x} @var{op@,{c}@~ao_1})

Simple linear regression, @math{y_i=a+b x_i+e_i}, where @math{e_i} are @math{N(0,sigma)}
independent random variables. Argument @var{x} must be a two column matrix or a list of
pairs.

Options:

@itemize @bullet

@item
@code{'conflevel}, o valor padr@~ao @'e @code{95/100}, confidence level for the confidence interval; it must
be an expression which takes a value in (0,1).

@item
@code{'regressor}, o valor padr@~ao @'e @code{'x}, name of the independent variable.

@end itemize

The output of function @code{simple_linear_regression} is an @code{inference_result} Maxima object
with the following results:

@enumerate

@item
@code{'model}: the fitted equation. Useful to make new predictions. See examples bellow.

@item
@code{'means}: bivariate mean.

@item
@code{'variances}: variances of both variables.

@item
@code{'correlation}: correlation coefficient.

@item
@code{'adc}: adjusted determination coefficient.

@item
@code{'a_estimation}: estimation of parameter @var{b}.

@item
@code{'a_conf_int}: confidence interval of parameter @var{a}.

@item
@code{'b_estimation}: estimation of parameter @var{b}.

@item
@code{'b_conf_int}: confidence interval of parameter @var{b}.

@item
@code{'hypotheses}: null and alternative hypotheses about parameter @var{b}.

@item
@code{'statistic}: value of the sample statistic used for testing the null hypothesis.

@item
@code{'distribution}: distribution of the sample statistic, together with its parameter.

@item
@code{'p_value}: @math{p}-value of the test about @var{b}.

@item
@code{'v_estimation}: unbiased variance estimation, or residual variance.

@item
@code{'v_conf_int}: variance confidence interval.

@item
@code{'cond_mean_conf_int}: confidence interval for the conditioned mean. See examples bellow.

@item
@code{'new_pred_conf_int}: confidence interval for a new prediction. See examples bellow.

@item
@code{'residuals}: list of pairs (prediction, residual), ordered with respect to predictions.
This is useful for goodness of fit analysis. See examples bellow.

@end enumerate

Only items 1, 4, 14, 9, 10, 11, 12, and 13 above, in this order, are shown por padr@~ao. The rest remain
hidden until the user makes use of functions @code{items_inference} e @code{take_inference}.

Exemplo:

Fitting a linear model to a bivariate sample. Input @code{%i4} plots
the sample together with the regression line; input @code{%i5}
computes @code{y} given @code{x=113}; the means and the 
confidence interval for a new prediction when @code{x=113} are also calculated.

@c ===beg===
@c load (stats)$
@c s:[[125,140.7],[130,155.1],[135,160.3],[140,167.2],[145,169.8]]$
@c z:simple_linear_regression(s,conflevel=0.99);
@c plot2d([[discrete, s], take_inference(model,z)],
@c           [x,120,150],
@c           [gnuplot_curve_styles, ["with points","with lines"]] )$
@c take_inference(model,z), x=133;
@c take_inference(means,z);
@c take_inference(new_pred_conf_int,z), x=133;
@c ===end===
@example
(%i1) load("stats")$
(%i2) s:[[125,140.7],[130,155.1],[135,160.3],[140,167.2],[145,169.8]]$
(%i3) z:simple_linear_regression(s,conflevel=0.99);
           |               SIMPLE LINEAR REGRESSION
           |
           |   model = 1.405999999999985 x - 31.18999999999804
           |
           |           correlation = .9611685255255155
           |
           |           v_estimation = 13.57966666666665
           |
(%o3)      | b_conf_int = [.04469633662525263, 2.767303663374718]
           |
           |          hypotheses = H0: b = 0 ,H1: b # 0
           |
           |            statistic = 6.032686683658114
           |
           |            distribution = [student_t, 3]
           |
           |             p_value = 0.0038059549413203
(%i4) plot2d([[discrete, s], take_inference(model,z)],
              [x,120,150],
              [gnuplot_curve_styles, ["with points","with lines"]] )$
(%i5) take_inference(model,z), x=133;
(%o5)                         155.808
(%i6) take_inference(means,z);
(%o6)                     [135.0, 158.62]
(%i7) take_inference(new_pred_conf_int,z), x=133;
(%o7)              [132.0728595995113, 179.5431404004887]
@end example

@end deffn
































@node Defini@value{cedilha}@~oes para distribui@value{cedilha}@~oes especiais, , Defini@value{cedilha}@~oes para stats, Top
@section Defini@value{cedilha}@~oes para distribui@value{cedilha}@~oes especiais


@deffn {Fun@,{c}@~ao} pdf_signed_rank (@var{x}, @var{n})
Probability density function of the exact distribution of the
signed rank statistic. Argument @var{x} is a real
number and @var{n} a positive integer.

Veja tamb@'em @code{test_signed_rank}.
@end deffn

@deffn {Fun@,{c}@~ao} cdf_signed_rank (@var{x}, @var{n})
Cumulative density function of the exact distribution of the
signed rank statistic. Argument @var{x} is a real
number and @var{n} a positive integer. 

Veja tamb@'em @code{test_signed_rank}.
@end deffn

@deffn {Fun@,{c}@~ao} pdf_rank_sum (@var{x}, @var{n}, @var{m})
Probability density function of the exact distribution of the
rank sum statistic. Argument @var{x} is a real
number and @var{n} e @var{m} are both positive integers. 

Veja tamb@'em @code{test_rank_sum}.
@end deffn

@deffn {Fun@,{c}@~ao} cdf_rank_sum (@var{x}, @var{n}, @var{m})
Cumulative density function of the exact distribution of the
rank sum statistic. Argument @var{x} is a real
number and @var{n} e @var{m} are both positive integers. 

Veja tamb@'em @code{test_rank_sum}.
@end deffn

