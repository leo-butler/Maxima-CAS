
@menu
* Definitions for Logarithms::
@end menu

@node Definitions for Logarithms,  , Logarithms, Logarithms
@section Definitions for Logarithms

@defvar %e_to_numlog
when @code{true}, @code{r} some rational number, and
@code{x} some expression, @code{%e^(r*log(x))} will be simplified into @code{x^r} .  It
should be noted that the @code{radcan} command also does this transformation,
and more complicated transformations of this ilk as well.
The @code{logcontract} command "contracts" expressions containing @code{log}.

@end defvar

@defun log (x)
the natural logarithm.

@code{logexpand} - causes @code{log(a^b)} to become @code{b*log(a)}.
If it is set to @code{all}, @code{log(a*b)} will also simplify to @code{log(a)+log(b)}.
If it is set to @code{super}, then @code{log(a/b)} will also simplify to @code{log(a)-log(b)} for rational
numbers @code{a/b}, @code{a#1}.  (@code{log(1/b)}, for @code{b} integer, always simplifies.)  If
it is set to @code{false}, all of these simplifications will be turned off.

@code{logsimp} - if @code{false} then no simplification of @code{%e} to a power
containing @code{log}'s is done.

@code{lognumer} - if @code{true} then negative floating point arguments to
@code{log} will always be converted to their absolute value before the @code{log} is
taken.  If @code{numer} is also @code{true}, then negative integer arguments to @code{log}
will also be converted to their absolute value.

@code{lognegint} - if @code{true} implements the rule @code{log(-n)} ->
@code{log(n)+%i*%pi} for @code{n} a positive integer.

@code{%e_to_numlog} - when @code{true}, @code{r} some rational number, and
@code{x} some expression, @code{%e^(r*log(x))} will be simplified into
@code{x^r} .  It should be noted that the @code{radcan} command also
does this transformation, and more complicated transformations of this ilk as well.
The @code{logcontract} command "contracts" expressions containing @code{log}.

@end defun

@defvar logabs
 default value: @code{false} - when doing indefinite integration where
logs are generated, e.g. @code{integrate(1/x,x)}, the answer is given in
terms of @code{log(abs(...))} if @code{logabs} is @code{true}, but in terms of @code{log(...)} if
@code{logabs} is @code{false}.  For definite integration, the @code{logabs:true} setting is
used, because here "evaluation" of the indefinite integral at the
endpoints is often needed.

@end defvar

@defvar logarc
default value: @code{false} - if @code{true} will cause the inverse circular and
hyperbolic functions to be converted into logarithmic form.
@code{logarc(@var{exp})} will cause this conversion for a particular
expression @var{exp} without setting the switch or having to
re-evaluate the expression with @code{ev}.

@end defvar

@defvar logconcoeffp
default value: @code{false} - controls which coefficients are
contracted when using @code{logcontract}.  It may be set to the name of a
predicate function of one argument.  E.g. if you like to generate
SQRTs, you can do @code{logconcoeffp:'logconfun$
logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Then
@code{logcontract(1/2*log(x));} will give @code{log(sqrt(x))}.

@end defvar

@defun logcontract (exp)
recursively scans an @var{exp}, transforming
subexpressions of the form @code{a1*log(b1) + a2*log(b2) + c} into
@code{log(ratsimp(b1^a1 * b2^a2)) + c}

@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                     2  4
(%o3)                         a log(x  y )

@end example

If you do @code{declare(n,integer);} then @code{logcontract(2*a*n*log(x));} gives
@code{a*log(x^(2*n))}.  The coefficients that "contract" in this manner are
those such as the 2 and the @code{n} here which satisfy
@code{featurep(coeff,integer)}.  The user can control which coefficients are
contracted by setting the option @code{logconcoeffp} to the name of a
predicate function of one argument.  E.g. if you like to generate
SQRTs, you can do @code{logconcoeffp:'logconfun$
logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Then
@code{logcontract(1/2*log(x));} will give @code{log(sqrt(x))}.

@end defun

@defvar logexpand
default value: @code{true} - causes @code{log(a^b)} to become @code{b*log(a)}.  If
it is set to @code{all}, @code{log(a*b)} will also simplify to @code{log(a)+log(b)}.  If it
is set to @code{super}, then @code{log(a/b)} will also simplify to @code{log(a)-log(b)} for
rational numbers @code{a/b}, @code{a#1}.  (@code{log(1/b)}, for integer @code{b}, always
simplifies.)  If it is set to @code{false}, all of these simplifications will
be turned off.

@end defvar

@defvar lognegint
default value: @code{false} - if @code{true} implements the rule
@code{log(-n)} -> @code{log(n)+%i*%pi} for @code{n} a positive integer.

@end defvar

@defvar lognumer
default value: @code{false} - if @code{true} then negative floating point
arguments to @code{log} will always be converted to their absolute value
before the @code{log} is taken.  If @code{numer} is also @code{true}, then negative integer
arguments to @code{log} will also be converted to their absolute value.

@end defvar

@defvar logsimp
default value: @code{true} - if @code{false} then no simplification of @code{%e} to a
power containing @code{log}'s is done.

@end defvar

@defun plog (x)
the principal branch of the complex-valued natural
logarithm with @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

@end defun

@defun polarform (exp)
returns @code{r*%e^(%i*theta)} where @code{r} and @code{theta} are purely
real.

@end defun

