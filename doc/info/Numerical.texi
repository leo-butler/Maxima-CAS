@menu
* Introduction to Numerical::   
* Fourier::                     
* Definitions for Numerical::   
@end menu

@node Introduction to Numerical, Fourier, Numerical, Numerical
@section Introduction to Numerical

@node Fourier, Definitions for Numerical, Introduction to Numerical, Numerical
@section Fourier
 - There is a Fast Fourier Transform package, do DESCRIBE(FFT)
for details.  There is also a Fourier Series package.  It may be
loaded with LOAD(FOURIE).  It will also calculate Fourier integral
coefficients and has various other functions to do such things as
replace all occurrences of F(ARG) by ARG in expression (like changing
ABS(a*x+b) to a*x+b).  Do PRINTFILE(FOURIE,USAGE,DSK,SHARE1); for
a list of the functions included.

@c end concepts Numerical

@node Definitions for Numerical,  , Fourier, Numerical
@section Definitions for Numerical
@c NOTE: Let's keep POLARTORECT, RECTTOPOLAR, and IFT before FFT
@c in this file. Otherwise DESCRIBE returns the FFT text (because
@c POLARTORECT, etc are list in the heading of FFT with @defunx).

@defun POLARTORECT (magnitude_array, phase_array)

Translates complex values of the form r %e^(%i t) to the form a + b %i.
LOAD ("FFT")$ will load this function into Maxima. See also FFT.

The magnitude and phase, r and t, are taken from magnitude_array and
phase_array, respectively. The original values of the input arrays are
replaced by the real and imaginary parts, a and b, on return. The outputs are
equal to

@example
  a: r COS (t)
  b: r SIN (t)
@end example

The input arrays must be the same size and 1-dimensional.
The array size need not be a power of 2.

POLARTORECT is the inverse function of RECTTOPOLAR.

@end defun

@defun RECTTOPOLAR (real_array, imaginary_array)

Translates complex values of the form a + b %i to the form r %e^(%i t).
LOAD ("FFT")$ will load this function into Maxima. See also FFT.

The real and imaginary parts, a and b, are taken from real_array and
imaginary_array, respectively. The original values of the input arrays
are replaced by the magnitude and angle, r and t, on return. The outputs are
equal to

@example
  r: SQRT (a^2 + b^2)
  t: ATAN2 (b, a)
@end example

The computed angle is in the range -%pi to %pi. 

The input arrays must be the same size and 1-dimensional.
The array size need not be a power of 2.

RECTTOPOLAR is the inverse function of POLARTORECT.

@end defun

@defun IFT (real_array, imaginary_array)

Fast inverse discrete Fourier transform. LOAD ("FFT")$ will load this function
into Maxima.

IFT carries out the inverse complex fast Fourier transform on
1-dimensional floating point arrays. The inverse transform is defined as

@example
  X[j]: SUM (Y[j] EXP (+2 %i %pi j k / n), k, 0, n-1)
@end example

See FFT for more details.

@end defun

@defun FFT (real_array, imaginary_array)
@defunx IFT (real_array, imaginary_array)
@defunx RECTTOPOLAR (real_array, imaginary_array)
@defunx POLARTORECT (magnitude_array, phase_array)

Fast Fourier transform and related functions. LOAD ("FFT")$ will
load these functions into Maxima.

FFT and IFT carry out the complex fast Fourier transform and
inverse transform, respectively, on 1-dimensional floating
point arrays. The size of imaginary_array must equal the size of real_array.

FFT and IFT operate in-place. That is, on return from FFT or IFT,
the original content of the input arrays is replaced by the output.
The FILLARRAY function can make a copy of an array, should it
be necessary.

The discrete Fourier transform and inverse transform are defined
as follows. Let X be the original data, with

@example
  X[i]: real_array[i] + %i imaginary_array[i]
@end example
  
Let Y be the transformed data. The forward and inverse transforms are

@example
  Y[k]: (1/n) SUM (X[j] EXP (-2 %i %pi j k / n), j, 0, n-1)

  X[j]:       SUM (Y[j] EXP (+2 %i %pi j k / n), k, 0, n-1)
@end example

Suitable arrays can be allocated by the ARRAY function. For example:

@example
  ARRAY (my_array, FLOAT, n-1)$
@end example

declares a 1-dimensional array with n elements, indexed from 0 through
n-1 inclusive. The number of elements n must be equal to 2^m for some m.

FFT can be applied to real data (imaginary array all zeros) to obtain
sine and cosine coefficients. After calling FFT, the sine and cosine
coefficients, say A and B, can be calculated as

@example
  A[0]: real_array[0]
  B[0]: 0
@end example

and

@example
  A[j]: real_array[j] + real_array[n-j]
  B[j]: imaginary_array[j] - imaginary_array[n-j]
@end example

for j equal to 1 through n/2-1, and

@example
  A[n/2]: real_array[n/2]
  B[n/2]: 0
@end example

RECTTOPOLAR translates complex values of the form a + b %i to
the form r %e^(%i t). See RECTTOPOLAR.

POLARTORECT translates complex values of the form r %e^(%i t)
to the form a + b %i. See POLARTORECT.

Execute DEMO ("FFT")$ to see a demonstration of the FFT package.

@end defun

@defvar FORTINDENT
 default: [0] - controls the left margin indentation of
expressions printed out by the FORTRAN command.  0 gives normal
printout (i.e. 6 spaces), and positive values will causes the
expressions to be printed farther to the right.

@end defvar

@defun FORTMX (name,matrix)
converts a Maxima matrix into a sequence of
FORTRAN assignment statements of the form name(i,j)=<corresponding
matrix element>.  This command is now obsolete.  FORTMX(name,matrix);
may now be done as FORTRAN(name=matrix);.  (If "name" is bound,
FORTRAN('name=matrix); may be necessary.)  Please convert code that
uses the FORTMX command as it may be flushed some day.

@end defun

@defun FORTRAN (exp)
converts exp into a FORTRAN linear expression in legal
FORTRAN with 6 spaces inserted at the beginning of each line,
continuation lines, and ** rather than ^ for exponentiation.  When the
option FORTSPACES[FALSE] is TRUE, the FORTRAN command fills out to 80
columns using spaces.  If FORTRAN is called on a bound symbolic atom,
e.g. FORTRAN(X); where X:A*B$ has been done, then X=@{value of X@}, e.g.
X=A*B will be generated.  In particular, if e.g. M:MATRIX(...); has
been done, then FORTRAN(M); will generate the appropriate assignment
statements of the form name(i,j)=<corresponding matrix element>.
FORTINDENT[0] controls the left margin of expressions printed out, 0
is the normal margin (i.e. indented 6 spaces), increasing it will
cause the expression to be printed further to the right.

@end defun

@defvar FORTSPACES
 default: [FALSE] - if TRUE, the FORTRAN command fills out
to 80 columns using spaces.

@end defvar

@defun HORNER (exp, var)
will convert exp into a rearranged representation as
in Horner's rule, using var as the main variable if it is specified.
Var may also be omitted in which case the main variable of the CRE
form of exp is used.  HORNER sometimes improves stability if expr is
to be numerically evaluated.  It is also useful if Maxima is used to
generate programs to be run in FORTRAN (see DESCRIBE(STRINGOUT);)
@example
(%i1) 1.0E-20*X^2-5.5*X+5.2E20;
                                2
(%o1)                   1.0E-20 X  - 5.5 X + 5.2E+20
(%i2) HORNER(%,X),KEEPFLOAT:TRUE;
(%o2)                  X (1.0E-20 X - 5.5) + 5.2E+20
(%i3) %o1,X=1.0E20;
ARITHMETIC OVERFLOW
(%i4) %o2,X=1.0E20;
(%o4)                          6.9999999E+19


@end example
@end defun

@defun INTERPOLATE (func,x,a,b)
finds the zero of func as x varies.  The last
two args give the range to look in.  The function must have a
different sign at each endpoint.  If this condition is not met, the
action of the of the function is governed by INTPOLERROR[TRUE]).  If
INTPOLERROR is TRUE then an error occurs, otherwise the value of
INTPOLERROR is returned (thus for plotting INTPOLERROR might be set to
0.0).  Otherwise (given that Maxima can evaluate the first argument
in the specified range, and that it is continuous) INTERPOLATE is
guaranteed to come up with the zero (or one of them if there is more
than one zero).  The accuracy of INTERPOLATE is governed by
INTPOLABS[0.0] and INTPOLREL[0.0] which must be non-negative floating
point numbers.  INTERPOLATE will stop when the first arg evaluates to
something less than or equal to INTPOLABS or if successive
approximants to the root differ by no more than INTPOLREL * <one of
the approximants>.  The default values of INTPOLABS and INTPOLREL are
0.0 so INTERPOLATE gets as good an answer as is possible with the
single precision arithmetic we have.  The first arg may be an
equation.  The order of the last two args is irrelevant.  Thus

@example
INTERPOLATE(SIN(X)=X/2,X,%PI,.1);
   is equivalent to
INTERPOLATE(SIN(X)=X/2,X,.1,%PI);
@end example
The method used is a binary search in the range specified by the last
two args.  When it thinks the function is close enough to being
linear, it starts using linear interpolation.
An alternative syntax has been added to interpolate, this replaces the
first two arguments by a function name.  The function MUST be
TRANSLATEd or compiled function of one argument.  No checking of the
result is done, so make sure the function returns a floating point
number.


@example
F(X):=(MODE_DECLARE(X,FLOAT),SIN(X)-X/2.0);
INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)       time= 60 msec
INTERPOLATE(F(X),X,0.1,%PI);            time= 68 msec
TRANSLATE(F);
INTERPOLATE(F(X),X,0.1,%PI);            time= 26 msec
INTERPOLATE(F,0.1,%PI);                 time=  5 msec
@end example

There is also a Newton method interpolation routine, do DESCRIBE(NEWTON); .

@end defun

@defvar INTPOLABS
 default: [0.0] - The accuracy of the INTERPOLATE command is
governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
non-negative floating point numbers.  INTERPOLATE will stop when the
first arg evaluates to something less than or equal to INTPOLABS or if
successive approximants to the root differ by no more than INTPOLREL *
<one of the approximants>.  The default values of INTPOLABS and
INTPOLREL are 0.0 so INTERPOLATE gets as good an answer as is possible
with the single precision arithmetic we have.

@end defvar

@defvar INTPOLERROR
 default: [TRUE] - Governs the behavior of INTERPOLATE.
When INTERPOLATE is called, it determines whether or not the function
to be interpolated satisfies the condition that the values of the
function at the endpoints of the interpolation interval are opposite
in sign.  If they are of opposite sign, the interpolation proceeds.
If they are of like sign, and INTPOLERROR is TRUE, then an error is
signaled.  If they are of like sign and INTPOLERROR is not TRUE, the
value of INTPOLERROR is returned.  Thus for plotting, INTPOLERROR
might be set to 0.0.

@end defvar

@defvar INTPOLREL
 default: [0.0] - The accuracy of the INTERPOLATE command is
governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
non-negative floating point numbers.  INTERPOLATE will stop when the
first arg evaluates to something less than or equal to INTPOLABS or if
successive approximants to the root differ by no more than INTPOLREL *
<one of the approximants>.  The default values of INTPOLABS and
INTPOLREL are 0.0 so INTERPOLATE gets as good an answer as is possible
with the single precision arithmetic we have.

@end defvar

@defun NEWTON (exp,var,X0,eps)
The file NEWTON 1 on the SHARE directory
contains a function which will do interpolation using Newton's method.
It may be accessed by LOAD(NEWTON); .  The Newton method can do things
that INTERPOLATE will refuse to handle, since INTERPOLATE requires
that everything evaluate to a flonum. Thus
NEWTON(x^2-a^2,x,a/2,a^2/100);
will say that it can't tell if flonum*a^2<a^2/100. Doing ASSUME(a>0);
and then doing NEWTON again works. You get x=a+<small flonum>*a which
is symbolic all the way.  INTERPOLATE(x^2-a^2,x,a/2,2*a); complains
that .5*a is not flonum...
An adaptive integrator which uses the Newton-Cotes 8 panel quadrature
rule is available.  Do DESCRIBE(QQ) for details.

@end defun
