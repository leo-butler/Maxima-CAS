@menu
* Introduction to Series::      
* Definitions for Series::      
@end menu

@node Introduction to Series, Definitions for Series, Series, Series
@section Introduction to Series
Maxima contains functions @code{Taylor} and @code{Powerseries} for finding the 
series of differentiable functions.   It also has tools such as @code{Nusum}
capable of finding the closed form of some series.   Operations such as addition and multiplication work as usual on series. This section presents the various global various variables which control the expansion.
@c end concepts Series
@node Definitions for Series,  , Introduction to Series, Series
@section Definitions for Series

@defvar cauchysum
 default: @code{false} - When multiplying together sums with @code{inf}
as their upper limit, if @code{sumexpand} is @code{true} and @code{cauchysum} is set to
@code{true} then the Cauchy product will be used rather than the usual
product.  In the Cauchy product the index of the inner summation is a
function of the index of the outer one rather than varying
independently.  That is: @code{sum(f(i),i,0,inf)*sum(g(j),j,0,inf)} becomes
@code{sum(sum(f(i)*g(j-i),i,0,j),j,0,inf)}

@end defvar

@defun deftaylor (function, exp)
allows the user to define the Taylor series
(about 0) of an arbitrary function of one variable as exp which may be
a polynomial in that variable or which may be given implicitly as a
power series using the @code{sum} function.

    In order to display the information given to @code{deftaylor} one can use
@code{powerseries(f(x),x,0).} (see below).

@example
(%i1) deftaylor(f(x),x**2+sum(x**i/(2**i*i!**2),
        i,4,inf));
(%o1)                          [f]
(%i2) taylor(%e**sqrt(f(x)),x,0,4);
                     2         3          4
                    x    3073 x    12817 x
(%o2)/r/     1 + x + -- + ------- + -------- +  . . .
                    2     18432     307200
@end example

@end defun

@defvar maxtayorder
 default: @code{true} - if @code{true,} then during algebraic
manipulation of (truncated) Taylor series, @code{taylor} will try to retain
as many terms as are certain to be correct.

@end defvar

@defun niceindices (expr)
will take the expression and change all the
indices of sums and products to something easily understandable. It
makes each index it can "I" , unless "I" is in the internal
expression, in which case it sequentially tries
J,K,L,M,N,I0,I1,I2,I3,I4,...  until it finds a legal index.

@end defun

@defvar niceindicespref
 default: [I,J,K,L,M,N] - the list which @code{niceindices}
uses to find indices for sums and products.  This allows the user to
set the order of preference of how @code{niceindices} finds the "nice
indices".  E.g.  @code{niceindicespref:[q,r,s,t,index]$.}  Then if
@code{niceindices} finds that it cannot use any of these as indices in a
particular summation, it uses the first as a base to try and tack on
numbers.  Here, if the list is exhausted, Q0, then Q1, etc, will be
tried.

@end defvar

@defun nusum (exp,var,low,high)
performs indefinite hypergeometric summation of exp with
respect to var using a decision procedure due to R.W. Gosper.  exp and
the potential answer must be expressible as products of nth powers,
factorials, binomials, and rational functions.  The terms "definite"
and "indefinite summation" are used analogously to "definite" and
"indefinite integration".  To sum indefinitely means to give a closed
form for the sum over intervals of variable length, not just e.g. 0 to
inf.  Thus, since there is no formula for the general partial sum of
the binomial series, @code{nusum} can't do it.

@code{nusum} and @code{unsum} know a little about sums and differences of finite products.
See also @code{unsum}.

Examples:

@example
(%i1) nusum (n*n!, n, 0, n);

Dependent equations eliminated:  (1)
(%o1)                     (n + 1)! - 1
(%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o2) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i3) unsum (%, n);
                              4  n
                             n  4
(%o3)                   ----------------
                        binomial(2 n, n)
(%i4) unsum (prod (i^2, i, 1, n), n);
                    n - 1
                    /===\
                     ! !   2
(%o4)              ( ! !  i ) (n - 1) (n + 1)
                     ! !
                    i = 1
(%i5) nusum (%, n, 1, n);

Dependent equations eliminated:  (2 3)
                            n
                          /===\
                           ! !   2
(%o5)                      ! !  i  - 1
                           ! !
                          i = 1
@end example

@end defun

@defun pade (taylor-series,num-deg-bound,denom-deg-bound)
returns a list of
all rational functions which have the given taylor-series expansion
where the sum of the degrees of the numerator and the denominator is
less than or equal to the truncation level of the power series, i.e.
are "best" approximants, and which additionally satisfy the specified
degree bounds.  Its first argument must be a univariate taylor-series;
the second and third are positive integers specifying degree bounds on
the numerator and denominator.
@code{pade}'s first argument can also be a Laurent series, and the degree
bounds can be @code{inf} which causes all rational functions whose total
degree is less than or equal to the length of the power series to be
returned.  Total degree is num-degree + denom-degree.  Length of a
power series is "truncation level" + 1 - minimum(0,"order of series").

@example
(%i15) ff:taylor(1+x+x^2+x^3,x,0,3);
                                     2    3
(%o15)/t/                    1 + x + x  + x  + . . .
(%i16) pade(ff,1,1);
                                        1
(%o16)                              [- -----]
                                      x - 1
(%i1) ff:taylor(-(83787*x^10-45552*x^9-187296*x^8
                  +387072*x^7+86016*x^6-1507328*x^5
                  +1966080*x^4+4194304*x^3-25165824*x^2
                  +67108864*x-134217728)
       /134217728,x,0,10);
@c EXAMPLE FAILS HERE WITH ERROR MESSAGE: !!!
@c  CDR: 134217728 is not a LIST !!!
(%i25) pade(ff,4,4);
(%o25) []
@end example
There is no rational function of degree 4 numerator/denominator, with this
power series expansion.  You must in general have degree of the numerator and
degree of the denominator adding up to at least the degree of the power series,
in order to have enough unknown coefficients to solve.
@example
@c EXAMPLE FAILS HERE WITH ERROR MESSAGE: !!!
@c  CDR: 134217728 is not a LIST !!!
(%i26) pade(ff,5,5);
(%o26) [-(520256329*x^5-96719020632*x^4-489651410240*x^3
           -1619100813312*x^2 -2176885157888*x-2386516803584)
	/(47041365435*x^5+381702613848*x^4+1360678489152*x^3
                +2856700692480*x^2
	        +3370143559680*x+2386516803584)]
@end example

@end defun

@defvar powerdisp
 default: @code{false} - if @code{true} will cause sums to be displayed
with their terms in the reverse order.  Thus polynomials would display
as truncated power series, i.e., with the lowest power first.

@end defvar

@defun powerseries (exp, var, pt)
generates the general form of the power
series expansion for exp in the variable var about the point pt (which
may be @code{inf} for infinity).  If @code{powerseries} is unable to expand exp, the
@code{taylor} function may give the first several terms of the series.
@code{verbose} - if @code{true} will cause comments about the progress of
@code{powerseries} to be printed as the execution of it proceeds.

@example
(%i1) verbose:true$
(%i2) powerseries(log(sin(x)/x),x,0);
can't expand 
                                 log(sin(x))
so we'll try again after applying the rule:
                                        d
                                      / -- (sin(x))
                                      [ dx
                        log(sin(x)) = i ----------- dx
                                      ]   sin(x)
                                      /
in the first simplification we have returned:
                             /
                             [
                             i cot(x) dx - log(x)
                             ]
                             /
                    inf
                    ====        i1  2 i1             2 i1
                    \      (- 1)   2     bern(2 i1) x
                     >     ------------------------------
                    /                i1 (2 i1)!
                    ====
                    i1 = 1
(%o2)                -------------------------------------
                                      2
@end example

@end defun

@defvar psexpand
 default: @code{false} - if @code{true} will cause extended rational
function expressions to display fully expanded.  (@code{ratexpand} will also
cause this.)  If @code{false,} multivariate expressions will be displayed
just as in the rational function package.  If @code{psexpand:multi,} then
terms with the same total degree in the variables are grouped
together.

@end defvar

@defun revert (expression,variable)
Does reversion of Taylor Series.
"Variable" is the variable the original Taylor expansion is in.  Do
@code{load(revert)} to access this function.  Try

@example
revert2(expression,variable,hipower)
@end example

also.  @code{revert} only works on
expansions around 0.

@end defun

@defun srrat (exp)
this command has been renamed to @code{taytorat.}

@end defun

@defun taylor (exp, var, pt, pow)
expands the expression exp in a truncated
Taylor series (or Laurent series, if required) in the variable var
around the point pt.  The terms through (var-pt)**pow are generated.
If exp is of the form f(var)/g(var) and g(var) has no terms up to
degree pow then @code{taylor} will try to expand g(var) up to degree 2*pow.
If there are still no non-zero terms @code{taylor} will keep doubling the
degree of the expansion of g(var) until reaching pow*2**n where n is
the value of the variable @code{taylordepth} [3].  If @code{maxtayorder} [FALSE] is
set to @code{true,} then during algebraic manipulation of (truncated) Taylor
series, @code{taylor} will try to retain as many terms as are certain to be
correct.  Do @code{example(taylor);} for examples.

@code{taylor(exp,[var1,pt1,ord1],[var2,pt2,ord2],...)}  returns a truncated
power series in the variables vari about the points pti, truncated at
ordi.

@code{psexpand} [FALSE] if @code{true} will cause extended rational function
expressions to display fully expanded.  (@code{ratexpand} will also cause
this.) If @code{false,} multivariate expressions will be displayed just as in
the rational function package.  If @code{psexpand:multi,} then terms with the
same total degree in the variables are grouped together.

@code{taylor(exp, [var1, var2, .  . .], pt, ord)} where each of pt and ord
may be replaced by a list which will correspond to the list of
variables.  that is, the nth items on each of the lists will be
associated together.

@code{taylor(exp, [x,pt,ord,ASYMP])} will give an expansion of exp in
negative powers of (x-pt).  The highest order term will be (x-pt)^(-ord).
The @code{asymp} is a syntactic device and not to be assigned to.
See also the @code{taylor_logexpand} switch for controlling expansion.

@end defun

@defvar taylordepth
 default: [3] - If there are still no non-zero terms
@code{taylor} will keep doubling the degree of the expansion of g(var) until
reaching pow*2**n where n is the value of the variable @code{taylordepth} [3].

@end defvar

@defun taylorinfo (exp)
returns @code{false} if exp is not a Taylor series.
Otherwise, a list of lists is returned describing the particulars of
the Taylor expansion.  For example,

@example
(%i3) taylor((1-y^2)/(1-x),x,0,3,[y,a,inf]);
             2                        2
(%o3)/r/ 1 - a  - 2 a (y - a) - (y - a)
                    2                        2
            + (1 - a  - 2 a (y - a) - (y - a) ) x
         2                        2   2
 + (1 - a  - 2 a (y - a) - (y - a) ) x
                    2                        2   3
            + (1 - a  - 2 a (y - a) - (y - a) ) x
     + . . .
(%i4) taylorinfo(%o3);
(%o4)                       [[y, a, inf], [x, 0, 3]]
@end example

@end defun

@defun taylorp (exp)
a predicate function which returns @code{true} if and only if
the expression 'exp' is in Taylor series representation.

@end defun

@defvar taylor_logexpand
 default: @code{true} controls expansions of logarithms in
@code{taylor} series.  When @code{true} all log's are expanded fully so that
zero-recognition problems involving logarithmic identities do not
disturb the expansion process.  However, this scheme is not always
mathematically correct since it ignores branch information.  If
@code{taylor_logexpand} is set to @code{false,} then the only expansion of log's
that will occur is that necessary to obtain a formal power series.

@end defvar

@defvar taylor_order_coefficients
 default: @code{true} controls the ordering of
coefficients in the expression.  The default @code{true} is that
coefficients of taylor series will be ordered canonically.

@end defvar

@defun taylor_simplifier
 - A function of one argument which @code{taylor} uses to
simplify coefficients of power series.

@end defun

@defvar taylor_truncate_polynomials
 default: @code{true} When @code{false} polynomials
input to @code{taylor} are considered to have infinite precison; otherwise
(the default) they are truncated based upon the input truncation
levels.

@end defvar

@defun taytorat (exp)
converts exp from @code{taylor} form to CRE form, i.e. it is
like @code{rat(ratdisrep(exp))} although much faster.

@end defun

@defun trunc (exp)
causes exp which is in general representation to be
displayed as if its sums were truncated Taylor series.  E.g. compare
@code{exp1:x^2+x+1;} with @code{exp2:trunc(x^2+x+1);} .  Note that @code{is(exp1=exp2);}
gives @code{true.}

@end defun

@defun unsum (fun,n)
is the first backward difference fun(n) - fun(n-1).
Thus @code{unsum} in a sense is the inverse of @code{sum}.
See also @code{nusum}.

@example
(%i1) g(p):=p*4^n/binomial(2*n,n);
                                            n
                                         p 4
(%o1)                       g(p) := ----------------
                                   binomial(2 n, n)
(%i2) g(n^4);
                                     4  n
                                    n  4
(%o2)                           ----------------
                               binomial(2 n, n)
(%i3) nusum(%o2,n,0,n);
                         4        3       2              n
          2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o3)      ------------------------------------------------ - ------
                        693 binomial(2 n, n)                 3 11 7
(%i4) unsum(%,n);
                                     4  n
                                    n  4
(%o4)                           ----------------
                               binomial(2 n, n)
@end example

@end defun

@defvar verbose
 default: @code{false} - if @code{true} will cause comments about the
progress of @code{powerseries} to be printed as the execution of it proceeds.

@end defvar
