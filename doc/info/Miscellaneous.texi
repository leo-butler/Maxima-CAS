@menu
* Introduction to Miscellaneous Options::  
* SHARE::                       
* Definitions for Miscellaneous Options::  
@end menu

@node Introduction to Miscellaneous Options, SHARE, Miscellaneous Options, Miscellaneous Options
@section Introduction to Miscellaneous Options

In this section various options are discussed which have a global effect
on the operation of Maxima.   Also various lists such as the list of all
user defined functions, are discussed.

@node SHARE, Definitions for Miscellaneous Options, Introduction to Miscellaneous Options, Miscellaneous Options
@section SHARE
@c SHARE STILL EXISTS BUT THIS DESCRIPTION IS WAY WAY OUT OF DATE
 - The SHARE directory on MC or on a DEC20 version of Maxima
contains programs, information files, etc.  which are considered to be
of interest to the Maxima community.  Most files on SHARE; are not
part of the Maxima system per se and must be loaded individually by
the user, e.g.  LOADFILE("array");. Many files on SHARE;
were contributed by Maxima users.  Do PRINTFILE(SHARE,USAGE,SHARE);
for more details and the conventions for contributing to the SHARE
directory.  For an annotated "table of contents" of the directory, do:
PRINTFILE(SHARE,>,SHARE);

@c end concepts Miscellaneous Options
@node Definitions for Miscellaneous Options,  , SHARE, Miscellaneous Options
@section Definitions for Miscellaneous Options

@defvar aliases
Default value: []

@code{aliases} is the list of atoms which have a user defined alias (set up by
the @code{alias}, @code{ordergreat}, @code{orderless} functions or by declaring the atom a
@code{noun} with @code{declare}).
@end defvar


@defvr declaration alphabetic
Adds to Maxima's alphabet which initially contains
the letters A-Z, % and _.
Thus, DECLARE("~",ALPHABETIC) enables NEW~VALUE to be used as a name.

@end defvr

@defun apropos (string)
takes a character string as argument and looks at all
the Maxima names for ones with that string appearing anywhere within
them.  Thus, APROPOS(EXP); will return a long list of all the flags
and functions which have @code{exp} as part of their names, such as @code{expand},
@code{exp}, @code{exponentialize}.  Thus if you can only remember part of the name
of something you can use this command to find the rest of the name.
Similarily, you could say APROPOS(TR_); to find a list of many of the
switches relating to the @code{translator} (most of which begin with @code{tr_}).

@end defun

@defun args (exp)
returns a list of the args of exp.  I.e. it is
essentially equivalent to
@example
SUBSTPART("[",exp,0)
@end example
Both @code{args} and
@code{substpart} depend on the setting of @code{inflag}.

@end defun

@defun dummy (i1,i2,...)
will set each index i1,i2,... to name of the form !n
where n is a positive integer.  This guarantees that dummy indices
which are needed in forming expressions will not conflict with indices
already in use.  @code{counter}[default 1] determines the numerical suffix to
be used in generating the next dummy index.  The prefix is determined
by the option @code{dummyx}[!].

@end defun

@defvar genindex
Default value: @code{i}

@code{genindex} is the alphabetic prefix used to generate the
next variable of summation when necessary.

@end defvar

@defvar gensumnum
Default value: 0

@code{gensumnum} is the numeric suffix used to generate the next variable
of summation.  If it is set to @code{false} then the index will consist only
of @code{genindex} with no numeric suffix.

@end defvar

@defvar inf
Real positive infinity.

@end defvar

@defvar infinity
Complex infinity, an infinite magnitude of arbitrary phase
angle.  See also @code{inf} and @code{minf}.

@end defvar

@defvar infolists
Default value: []

@code{infolists} is a list of the names of all of the information
lists in Maxima. These are:

@code{labels} - all bound @code{%i}, @code{%o}, and @code{%t} labels.

@code{values} - all bound atoms which are user variables, not Maxima
options or switches, created by @code{:} or @code{::} or functional binding.
@c WHAT IS INTENDED BY "FUNCTIONAL BINDING" HERE ??

@code{functions} - all user-defined functions, created by @code{:=}.

@code{arrays} - declared and undeclared arrays, created by @code{:}, @code{::}, or @code{:=}.

@code{macros} - any macros defined by the user.

@code{myoptions} - all options ever reset by the user (whether or not they
are later reset to their default values).

@code{rules} - user-defined pattern matching and simplification rules, created
by @code{tellsimp}, @code{tellsimpafter}, @code{defmatch}, or @code{defrule}.

@code{aliases} - atoms which have a user-defined alias, created by the @code{alias},
@code{ordergreat}, @code{orderless} functions or by declaring the atom as a @code{noun}
with @code{declare}.

@code{dependencies} - atoms which have functional dependencies, created by the
@code{depends} or @code{gradef} functions.

@code{gradefs} - functions which have user-defined derivatives, created by the
@code{gradef} function.

@c UMM, WE REALLY NEED TO BE SPECIFIC -- WHAT DOES "ETC" CONTAIN HERE ??
@code{props} - atoms which have any property other than those mentioned
above, such as atvalues, matchdeclares, etc., as well as properties
specified in the @code{declare} function.

@code{let_rule_packages} - a list of all the user-defined let rule packages
plus the special package @code{default_let_rule_package}.
(@code{default_let_rule_package} is the name of the rule package used when
one is not explicitly set by the user.)

@end defvar

@defun integerp (@var{expr})
Returns @code{true} if @var{expr} is an integer, otherwise @code{false}.
@c ACCORDING TO WHICH CRITERIA DOES MAXIMA JUDGE INTEGERNESS ??
@c CAN YOU DECLARE A VARIABLE TO BE AN INTEGER ??

@end defun

@defvar m1pbranch
Default value: @code{false}

@code{m1pbranch} is the principal branch for @code{-1} to a power.
Quantities such as @code{(-1)^(1/3)} (that is, an "odd" rational exponent) and 
@code{(-1)^(1/4)} (that is, an "even" rational exponent) are handled as follows:

@c REDRAW THIS AS A TABLE
@example
              domain:real
                            
(-1)^(1/3):      -1         
(-1)^(1/4):   (-1)^(1/4)   

             domain:complex              
m1pbranch:false          m1pbranch:true
(-1)^(1/3)               1/2+%i*sqrt(3)/2
(-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2
@end example

@end defvar

@c DOES numberp RETURN true FOR ANY ARGUMENT OTHER THAN A LITERAL NUMBER ??
@defun numberp (@var{expr})
Returns @code{true} if @var{expr} is an integer, a rational number, a
floating point number, or a bigfloat, otherwise @code{false}.

@end defun

@defun properties (@var{a})
Returns a list of the names of all the
properties associated with the atom @var{a}.

@end defun

@c WHAT IS HIDDEN IN THE "etc" HERE ??
@defvr {special symbol} props
@code{props} are atoms which have any property other than those explicitly
mentioned in @code{infolists}, such as atvalues, matchdeclares, etc., as well
as properties specified in the @code{declare} function.

@end defvr

@defun propvars (@var{prop})
Returns a list of those atoms on the @code{props} list which
have the property indicated by @var{prop}.  Thus @code{propvars (atvalue)}
returns a list of atoms which have atvalues.

@end defun

@defun put (@var{atom}, @var{value}, @var{indicator})
Assigns @var{value} to the property (specified by @var{indicator}) of @var{atom}.
@var{indicator} may be the name of any property, not just a system-defined property.

@code{put} evaluates its arguments. 
@code{put} returns @var{value}.

Examples:

@example
(%i1) put (foo, (a+b)^5, expr);
                                   5
(%o1)                       (b + a)
(%i2) put (foo, "Hello", str);
(%o2)                         Hello
(%i3) properties (foo);
(%o3)            [[user properties, str, expr]]
(%i4) get (foo, expr);
                                   5
(%o4)                       (b + a)
(%i5) get (foo, str);
(%o5)                         Hello
@end example

@end defun

@defun qput (@var{atom}, @var{value}, @var{indicator})
Assigns @var{value} to the property (specified by @var{indicator}) of @var{atom}.
This is the same as @code{put},
except that the arguments are quoted.

Example:

@example
(%i1) foo: aa$ 
(%i2) bar: bb$
(%i3) baz: cc$
(%i4) put (foo, bar, baz);
(%o4)                          bb
(%i5) properties (aa);
(%o5)                [[user properties, cc]]
(%i6) get (aa, cc);
(%o6)                          bb
(%i7) qput (foo, bar, baz);
(%o7)                          bar
(%i8) properties (foo);
(%o8)            [value, [user properties, baz]]
(%i9) get ('foo, 'baz);
(%o9)                          bar
@end example

@end defun

@defun rem (@var{atom}, @var{indicator})
Removes the property indicated by @var{indicator} from @var{atom}.

@c NEED AN EXAMPLE HERE
@end defun

@defun remove (@var{atom_1}, @var{property_1}, ..., @var{atom_n}, @var{property_n})
@defunx remove ([@var{atom_1}, ..., @var{atom_m}], [@var{property_1}, ..., @var{property_n}], ...)
Removes properties associated with atoms.

@code{remove (@var{atom_1}, @var{property_1}, ..., @var{atom_n}, @var{property_n})}
removes @code{property_k} from @code{atom_k}.

@code{remove ([@var{atom_1}, ..., @var{atom_m}], [@var{property_1}, ..., @var{property_n}], ...)}
removes all properties @code{@var{property_1}, ..., @var{property_n}}
from all atoms @var{atom_1}, ..., @var{atom_m}.
There may be more than one pair of lists.

@c SHOULD REFER TO A LIST OF ALL SYSTEM-DEFINED PROPERTIES HERE.
The removed properties may be system-defined properties such as
@code{function} or @code{mode_declare}, or user-defined properties.

A property may be @code{transfun} to remove
the translated Lisp version of a function.
After executing this, the Maxima version of the function is executed
rather than the translated version.

A property may be @code{op} or @code{operator} to remove a syntax extension given to an atom.
If an atom is "@code{all}" then the property is removed from
all atoms which have it.

@code{remove} always returns @code{done} whether or not an atom has a specified property.
This behavior is unlike the more specific remove functions
(@code{remvalue}, @code{remarray}, @code{remfunction}, and @code{remrule}).

@c IN SERIOUS NEED OF EXAMPLES HERE
@end defun

@defun remvalue (name1, name2, ...)
Removes the values of user variables
(which can be subscripted) from the system.  If name is @code{all} then the
values of all user variables are removed.  Values are those items
given names by the user as opposed to those which are automatically
labeled by Maxima as Ci, Di, or Ei.

@end defun

@defun rncombine (@var{expr})
transforms @var{expr} by combining all terms of @var{expr} that have
identical denominators or denominators that differ from each other by
numerical factors only.  This is slightly different from the behavior
of @code{combine}, which collects terms that have identical denominators.
Setting @code{pfeformat: true} and using @code{combine} will achieve results similar
to those that can be obtained with @code{rncombine}, but @code{rncombine} takes the
additional step of cross-multiplying numerical denominator factors.
This results in neater forms, and the possiblity of recognizing some
cancellations.

@end defun

@defun scalarp (@var{expr})
is @code{true} if @var{expr} is a number, constant, or variable
declared @code{scalar} with @code{declare}, or composed entirely of numbers, constants, and such
variables, but not containing matrices or lists.

@end defun

@defun setup_autoload (@var{filename}, @var{function_1}, ..., @var{function_n})
Specifies that
if any of @var{function_1}, ..., @var{function_n} are referenced and not yet defined,
@var{filename} is loaded via @code{load}.
@var{filename} usually contains definitions for the functions specified,
although that is not enforced.

@c SEEMS POSSIBLE THIS PARENTHETICAL REMARK IS OUT OF DATE
(This is the process by which calling e.g.
@code{integrate} in a fresh Maxima causes various files to be loaded in.)

@code{setup_autoload} does not work for array functions.

@code{setup_autoload} quotes its arguments.

@c NEED A NEW EXAMPLE HERE,
@c BUT setup_autoload APPEARS TO BE BROKEN AT THE MOMENT (CASE SENSITIVITY BUG)
@c @example
@c setup_autoload ("bessel")$ j1(0.0);
@c @end example

@end defun
