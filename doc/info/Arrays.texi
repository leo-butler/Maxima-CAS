
@menu
* Definitions for Arrays and Tables::  
@end menu

@node Definitions for Arrays and Tables,  , Arrays and Tables, Arrays and Tables
@section Definitions for Arrays and Tables

@deffn {Function} array (@var{name}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Function} array (@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})
@deffnx {Function} array ([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})

Creates an @math{n}-dimensional array.  
@math{n} may be less than or equal to 5.
The subscripts for
the @math{i}'th dimension are the integers running from 0 to @var{dim_i}.  

@code{array (@var{name}, @var{dim_1}, ..., @var{dim_n})} creates a general array.

@code{array (@var{name}, @var{type}, @var{dim_1}, ..., @var{dim_n})} creates
an array, with elements of a specified type.
@var{type} can be @code{fixnum} for
integers of limited size or @code{flonum} for floating-point numbers.

@code{array ([@var{name_1}, ..., @var{name_m}], @var{dim_1}, ..., @var{dim_n})}
creates @math{m} arrays, all of the same dimensions.
@c SAME TYPE AS WELL ??

@c THIS DISCUSSION OF UNDECLARED ARRAYS REALLY WANTS TO BE SOMEWHERE ELSE
If the user assigns to a subscripted variable before declaring the
corresponding array, an undeclared array is created.
Undeclared arrays, otherwise known as hashed arrays (because hash
coding is done on the subscripts), are more general than declared
arrays.  The user does not declare their maximum size, and they grow
dynamically by hashing as more elements are assigned values.  The
subscripts of undeclared arrays need not even be numbers.  However,
unless an array is rather sparse, it is probably more efficient to
declare it when possible than to leave it undeclared.  The @code{array}
function can be used to transform an undeclared array into a declared
array.
@c HOW DOES ONE CHANGE AN UNDECLARED ARRAY INTO A DECLARED ARRAY EXACTLY ??

@end deffn

@deffn {Function} arrayapply (@var{A}, [@var{i_1}, ..., @var{i_n}])
Evaluates @code{@var{A} [@var{i_1}, ..., @var{i_n}]},
where @var{A} is an array and @var{i_1}, ..., @var{i_n} are integers.

This is reminiscent of @code{apply}, except the first argument is an array instead of a function.

@end deffn

@deffn {Function} arrayinfo (@var{A})
Returns a list of information about the array @var{A}.  For
hashed arrays it returns a list of @code{hashed}, the number of subscripts,
and the subscripts of every element which has a value.  For declared
arrays it returns a list of @code{declared}, the number of subscripts, and
the bounds that were given the the @code{array} function when it was called
on @var{A}.  Do @code{example(arrayinfo);} for an example.

@end deffn

@deffn {Function} arraymake (@var{name}, [@var{i_1}, ..., @var{i_n}])
Returns the expression @code{@var{name} [@var{i_1}, ..., @var{i_n}]}.

This is reminiscent of @code{funmake},
except the return value is an unevaluated array reference
instead of an unevaluated function call.

@end deffn

@defvr {System variable} arrays
Default value: @code{[]}

@code{arrays} is a list of all the arrays that have been allocated,
both declared and undeclared.

See also
@code{array}, @code{arrayapply}, @code{arrayinfo}, @code{arraymake}, 
@code{fillarray}, @code{listarray}, and @code{rearray}.
@c IS THIS AN EXHAUSTIVE LIST ??

@end defvr

@deffn {Function} bashindices (@var{expr})
Transforms the expression @var{expr} by giving each
summation and product a unique index. This gives @code{changevar} greater
precision when it is working with summations or products.  The form of
the unique index is @code{j@var{number}}. The quantity @var{number} is determined by
referring to @code{gensumnum}, which can be changed by the user.  For
example, @code{gensumnum:0$} resets it.

@end deffn

@deffn {Function} fillarray (@var{A}, @var{B})
Fills array @var{A} from @var{B}, which is a list or an array.

If @var{A} is a
floating-point (integer) array then @var{B} should be
either a list of floating-point (integer) numbers or another
floating-point (integer) array.

If the dimensions of the arrays are
different @var{A} is filled in row-major order.  If there are not enough
elements in @var{B} the last element is used to fill out the
rest of @var{A}.  If there are too many the remaining ones are thrown
away.

@code{fillarray} returns its first argument.

@end deffn

@c NEEDS EXAMPLES
@deffn {Function} getchar (@var{a}, @var{i})
Returns the @var{i}'th character of the quoted string or
atomic name @var{a}.  This function is useful in manipulating the 
@code{labels} list.

@end deffn

@deffn {Function} listarray (@var{A})
Returns a list of the elements of a declared or
hashed array @var{A}.  The order is row-major.  Elements which are not yet
defined are represented by @code{#####}.

@end deffn

@c NEEDS CLARIFICATION, EXAMPLES
@deffn {Function} make_array (@var{type}, @var{dim_1}, ..., @var{dim_n})
Creates and returns a Lisp array.  @var{type} may
be @code{any}, @code{flonum}, @code{fixnum}, @code{hashed} or 
@code{functional}.
There are @math{n} indices,
and the @math{i}'th index runs from 0 to @math{@var{dim_i} - 1}.

The advantage of @code{make_array} over @code{array} is that the return value doesn't have a
name, and once a pointer to it goes away, it will also go away.
For example, if @code{y: make_array (...)} then @code{y} points to an object 
which takes up space, but after @code{y: false}, @code{y} no longer
points to that object, so the object can be garbage collected.  

@c NEEDS CLARIFICATION HERE
@code{y: make_array ('functional, 'f, 'hashed, 1)} - the second argument to
@code{make_array} in this case is the function to call to calculate array
elements, and the rest of the arguments are passed recursively to
@code{make_array} to generate the "memory" for the array function object.

@end deffn

@c DOES THIS MODIFY A OR DOES IT CREATE A NEW ARRAY ??
@deffn {Function} rearray (@var{A}, @var{dim_1}, ..., @var{dim_n})
Changes the dimensions of an array.  
The new array will be filled with the elements of the old one in
row-major order.  If the old array was too small, 
the remaining elements are filled with
@code{false}, @code{0.0} or @code{0},
depending on the type of the array.  The type of the array cannot be
changed.

@end deffn

@deffn {Function} remarray (@var{A_1}, ..., @var{A_n})
@deffnx {Function} remarray (all)
Removes arrays and array associated
functions and frees the storage occupied.

@code{remarray (all)} removes all items in the global list @code{arrays}.

@c WHAT DOES THIS MEAN EXACTLY ??
It may be necessary to use this function if it is
desired to redefine the values in a hashed array.

@code{remarray} returns the list of arrays removed.

@end deffn

@c THIS IS REALLY CONFUSING
@defvr {Option variable} use_fast_arrays
- if @code{true} then only two types of arrays are recognized.  

1) The art-q array (t in Common Lisp) which may have several dimensions
indexed by integers, and may hold any Lisp or Maxima object as an
entry.  To construct such an array, enter @code{a:make_array(any,3,4);} 
then @code{a} will have as value, an array with twelve slots, and the 
indexing is zero based.

2) The Hash_table array which is the default type of array created if one
does @code{b[x+1]:y^2} (and @code{b} is not already an array, a list, or a
matrix -- if it were one of these an error would be caused since
@code{x+1} would not be a valid subscript for an art-q array, a list or
a matrix). Its indices (also known as keys) may be any object.  
It only takes one key at a time (@code{b[x+1,u]:y} would ignore the @code{u}). 
Referencing is done by @code{b[x+1] ==> y^2}.  Of course the key may be
a list, e.g. @code{b[[x+1,u]]:y} would be valid.  This is incompatible 
with the old Maxima hash arrays, but saves consing.

An advantage of storing the arrays as values of the symbol is that the
usual conventions about local variables of a function apply to arrays as
well.  The Hash_table type also uses less consing and is more efficient
than the old type of Maxima hashar.  To obtain consistent behaviour in
translated and compiled code set @code{translate_fast_arrays} to be
@code{true}.
 
@end defvr
