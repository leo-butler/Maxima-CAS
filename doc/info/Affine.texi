@c end concepts Affine
@menu
* Definitions for Affine::      
@end menu

@node Definitions for Affine,  , Affine, Affine
@section Definitions for Affine
@c @node FAST_LINSOLVE
@c @unnumberedsec phony
@defun FAST_LINSOLVE (eqns,variables)
Solves the linear system of equations
EQNS for the variables VARIABLES  and returns a result suitable to
SUBLIS.  The function is faster than linsolve for system of equations which
are sparse.

@end defun
@c @node GROBNER_BASIS
@c @unnumberedsec phony
@defun GROBNER_BASIS (eqns)
Takes as argument a list of equations
and returns a grobner basis for them.  The function POLYSIMP may now
be used to simplify other functions relative to the equations.

GROBNER_BASIS([3*X^2+1,Y*X])$

POLYSIMP(Y^2*X+X^3*9+2)==> -3*x+2

Polysimp(f)==> 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

@end defun
@c @node SET_UP_DOT_SIMPLIFICATIONS
@c @unnumberedsec phony
@defun SET_UP_DOT_SIMPLIFICATIONS (eqns,[check-thru-degree])
The eqns are
polynomial equations in non commutative variables.
The value of CURRENT_VARIABLES is the 
list of variables used for computing degrees.  The equations must be
homogeneous, in order for the procedure to terminate.  

If you have checked overlapping simplifications in DOT_SIMPLIFICATIONS
above the degree of f, then the following is true:
DOTSIMP(f)==> 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

The degree is that returned by NC_DEGREE.   This in turn is influenced by
the weights of individual variables.

@end defun
@c @node DECLARE_WEIGHT
@c @unnumberedsec phony
@defun DECLARE_WEIGHT (var1,wt1,var2,wt2,...)
Assigns VAR1 weight WT1, VAR2 weight wt2..
These are the weights used in computing NC_DEGREE.

@end defun
@c @node NC_DEGREE
@c @unnumberedsec phony
@defun NC_DEGREE (poly)
Degree of a non commutative polynomial.  See DECLARE_WEIGHTS.

@end defun
@c @node DOTSIMP
@c @unnumberedsec phony
@defun DOTSIMP (f)
==> 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

@end defun
@c @node FAST_CENTRAL_ELEMENTS
@c @unnumberedsec phony
@defun FAST_CENTRAL_ELEMENTS (variables,degree)
if SET_UP_DOT_SIMPLIFICATIONS has been previously done, finds the central polynomials
in the variables in the given degree, 
For example:
@example
set_up_dot_simplifications([y.x+x.y],3);
fast_central_elements([x,y],2);
[y.y,x.x];
@end example
@end defun
@c @node CHECK_OVERLAPS
@c @unnumberedsec phony
@defun CHECK_OVERLAPS (degree,add-to-simps)
checks the overlaps thru degree,
making sure that you have sufficient simplification rules in each
degree, for dotsimp to work correctly.  This process can be speeded
up if you know before hand what the dimension of the space of monomials is.
If it is of finite global dimension, then HILBERT should be used.  If you
don't know the monomial dimensions, do not specify a RANK_FUNCTIION.
An optional third argument RESET, false says don't bother to query
about resetting things.

@end defun
@c @node MONO
@c @unnumberedsec phony
@defun MONO (vari,n)
VARI is a list of variables.   Returns the list of independent
monomials relative to the current dot_simplifications, in degree N

@end defun
@c @node MONOMIAL_DIMENSIONS
@c @unnumberedsec phony
@defun MONOMIAL_DIMENSIONS (n)

Compute the hilbert series through degreen n for the current algebra.


@end defun
@c @node EXTRACT_LINEAR_EQUATIONS
@c @unnumberedsec phony
@defun EXTRACT_LINEAR_EQUATIONS (List_nc_polys,monoms)

Makes a list of the coefficients of the polynomials in list_nc_polys
of the monoms.  MONOMS is a list of noncommutative monomials.   The
coefficients should be scalars.   Use LIST_NC_MONOMIALS to build the list of
monoms.

@end defun
@c @node LIST_NC_MONOMIALS
@c @unnumberedsec phony
@defun LIST_NC_MONOMIALS (polys_or_list)

returns a list of the non commutative monomials occurring in a polynomial
or a collection of polynomials.

@end defun
@c @node PCOEFF
@c @unnumberedsec phony
@defun PCOEFF (poly monom [variables-to-exclude-from-cof (list-variables monom)])


This function is called from Lisp level, and uses internal poly format.
@example

CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))
(#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))

CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))
(#:U 1 1)
@end example
@noindent

Rule: if a variable appears in monom it must be to the exact power,
and if it is in variables to exclude it may not appear unless it was
in monom to the exact power.  (pcoeff pol 1 ..) will exclude variables
like substituting them to be zero.

@end defun
@c @node NEW-DISREP
@c @unnumberedsec phony
@defun NEW-DISREP (poly)

From Lisp this returns the general Maxima format for an arg which is
in st-rat form:

@example
(displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))

       2
Y + U X  + 1

@end example
@end defun
@c @node CREATE_LIST
@c @unnumberedsec phony
@defun CREATE_LIST (form,var1,list1,var2,list2,...)

Create a list by evaluating FORM with VAR1 bound to
each element of LIST1, and for each such binding bind VAR2
to each element of LIST2,...
The number of elements in the result will be
length(list1)*length(list2)*...
Each VARn must actually be a symbol--it will not be evaluated.
The LISTn args will be evaluated once at the beginning of the
iteration.  



@example

(%i82) create_list1(x^i,i,[1,3,7]);
(%o82) [X,X^3,X^7]
@end example
@noindent

With a double iteration:
@example
(%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
(%o79) [[A,E],[A,F],[A,H],[B,E],[B,F],[B,H]]
@end example

Instead of LISTn two args maybe supplied each of which should
evaluate to a number.   These will be the inclusive lower and
upper bounds for the iteration.   

@example
(%i81) create_list([i,j],i,[1,2,3],j,1,i);
(%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]
@end example


Note that the limits or list for the j variable can
depend on the current value of i.


@end defun
@c @node ALL_DOTSIMP_DENOMS
@c @unnumberedsec phony
@defvar ALL_DOTSIMP_DENOMS

if its value is FALSE the denominators encountered in getting
dotsimps will not be collected.   To collect the denoms
@example
ALL_DOTSIMP_DENOMS:[];
@end example
@noindent
and they will be nconc'd onto the end of the list.


@end defvar



