@menu
* Introduction to Program Flow::  
* Definitions for Program Flow::  
@end menu

@node Introduction to Program Flow, Definitions for Program Flow, Program Flow, Program Flow
@section Introduction to Program Flow

Maxima provides a DO loop for iteration, as well as more primitive
constructs such as GO.

@c end concepts Program Flow
@node Definitions for Program Flow,  , Introduction to Program Flow, Program Flow
@section Definitions for Program Flow
@c @node BACKTRACE, {special operator}, ITERATION, Program Flow
@c @unnumberedsec phony
@defun BACKTRACE ()
@defunx BACKTRACE (n)
Prints the call stack, that is, the list of functions which
called the currently active function. BACKTRACE() prints the
entire stack, while BACKTRACE(n) prints the n most recent 
functions, including the currently active function.
BACKTRACE can be called at any time (not only in a debugging context).

@end defun
@c @node DO
@c @unnumberedsec phony
@deffn {special operator} DO
 - The DO statement is used for performing iteration.  Due to its
great generality the DO statement will be described in two parts.
First the usual form will be given which is analogous to that used in
several other programming languages (FORTRAN, ALGOL, PL/I, etc.); then
the other features will be mentioned.
1.  There are three variants of this form that differ only in their
terminating conditions.  They are:
@itemize @bullet
@item
(a)  FOR variable : initial-value STEP increment
      THRU limit DO body
@item
(b)  FOR variable : initial-value STEP increment
      WHILE condition DO body
@item
(c)  FOR variable : initial-value STEP increment
      UNLESS condition DO body
@end itemize
(Alternatively, the STEP may be given after the termination condition
or limit.)
    The initial-value, increment, limit, and body can be any
expressions.  If the increment is 1 then "STEP 1" may be omitted.
    The execution of the DO statement proceeds by first assigning the
initial-value to the variable (henceforth called the
control-variable). Then: (1) If the control-variable has exceeded the
limit of a THRU specification, or if the condition of the UNLESS is
TRUE, or if the condition of the WHILE is FALSE then the DO
terminates. (2) The body is evaluated.  (3) The increment is added to
the control-variable.  The process from (1) to (3) is performed
repeatedly until the termination condition is satisfied.  One may also
give several termination conditions in which case the DO terminates
when any of them is satisfied.
    In general the THRU test is satisfied when the control-variable is
greater than the limit if the increment was non-negative, or when the
control-variable is less than the limit if the increment was negative.
The increment and limit may be non-numeric expressions as long as this
inequality can be determined.  However, unless the increment is
syntactically negative (e.g. is a negative number) at the time the DO
statement is input, Maxima assumes it will be positive when the DO is
executed.  If it is not positive, then the DO may not terminate
properly.
    Note that the limit, increment, and termination condition are
evaluated each time through the loop.  Thus if any of these involve
much computation, and yield a result that does not change during all
the executions of the body, then it is more efficient to set a
variable to their value prior to the DO and use this variable in the
DO form.
    The value normally returned by a DO statement is the atom DONE, as
every statement in Maxima returns a value.  However, the function
RETURN may be used inside the body to exit the DO prematurely and give
it any desired value.  Note however that a RETURN within a DO that
occurs in a BLOCK will exit only the DO and not the BLOCK.  Note also
that the GO function may not be used to exit from a DO into a
surrounding BLOCK.
    The control-variable is always local to the DO and thus any
variable may be used without affecting the value of a variable with
the same name outside of the DO.  The control-variable is unbound
after the DO terminates.
@example
(%i1)   FOR A:-3 THRU 26 STEP 7 DO LDISPLAY(A)$
(%t1)          A = -3
(%t2)          A =  4
(%t3)          A = 11
(%t4)          A = 18
(%t5)          A = 25
@end example
The function LDISPLAY generates intermediate labels; DISPLAY does not.
@example
(%i6)   S:0$
(%i7)   FOR I:1 WHILE I<=10 DO S:S+I;
(%o7)          DONE
(%i8)   S;
(%o8)          55
@end example
Note that the condition in %i7 is equivalent to UNLESS I > 10 and also
THRU 10
@example
(%i9)   SERIES:1$
(%i10)  TERM:EXP(SIN(X))$
(%i11)  FOR P:1 UNLESS P>7 DO
          (TERM:DIFF(TERM,X)/P,
          SERIES:SERIES+SUBST(X=0,TERM)*X^P)$
(%i12)   SERIES;
                7    6     5    4    2
(%o12)          X    X     X    X    X
               -- - --- - -- - -- + -- + X + 1
               96   240   15   8    2
which gives 8 terms of the Taylor series for e^sin(x).
(%i13) POLY:0$
(%i14) FOR I:1 THRU 5 DO
        FOR J:I STEP -1 THRU 1 DO
           POLY:POLY+I*X^J$
(%i15) POLY;
              5      4       3       2
(%o15)      5 X  + 9 X  + 12 X  + 14 X  + 15 X
(%i16) GUESS:-3.0$
(%i17) FOR I:1 THRU 10 DO (GUESS:SUBST(GUESS,X,.5*(X+10/X)),
         IF ABS(GUESS^2-10)<.00005 THEN RETURN(GUESS));
(%o17)                  - 3.1622807
@end example

    This example computes the negative square root of 10 using the
Newton- Raphson iteration a maximum of 10 times.  Had the convergence
criterion not been met the value returned would have been "DONE".
Additional Forms of the DO Statement
    Instead of always adding a quantity to the control-variable one
may sometimes wish to change it in some other way for each iteration.
In this case one may use "NEXT expression" instead of "STEP
increment".  This will cause the control-variable to be set to the
result of evaluating expression each time through the loop.
@example

(%i1)  FOR COUNT:2 NEXT 3*COUNT THRU 20
         DO DISPLAY(COUNT)$
                    COUNT = 2
                    COUNT = 6
                    COUNT = 18
@end example

    As an alternative to FOR variable:value ...DO... the syntax FOR
variable FROM value ...DO...  may be used.  This permits the "FROM
value" to be placed after the step or next value or after the
termination condition.  If "FROM value" is omitted then 1 is used as
the initial value.
    Sometimes one may be interested in performing an iteration where
the control-variable is never actually used.  It is thus permissible
to give only the termination conditions omitting the initialization
and updating information as in the following example to compute the
square-root of 5 using a poor initial guess.
@example
(%i1) X:1000;
(%i2)  THRU 10 WHILE X#0.0 DO X:.5*(X+5.0/X)$
(%i3) X;
(%o3)               2.236068
@end example
    If it is desired one may even omit the termination conditions
entirely and just give "DO body" which will continue to evaluate the
body indefinitely.  In this case the function RETURN should be used to
terminate execution of the DO.
@example
(%i1) NEWTON(F,GUESS):=
  BLOCK([NUMER,Y],
        LOCAL(DF),
        NUMER:TRUE,
        DEFINE(DF(X),DIFF(F(X),X)),
        DO (Y:DF(GUESS),
            IF Y=0.0 THEN ERROR("Derivative at:",GUESS," is zero."),
            GUESS:GUESS-F(GUESS)/Y,
            IF ABS(F(GUESS))<5.0E-6 THEN RETURN(GUESS)))$
(%i2) SQR(X):=X^2-5.0$
(%i3) NEWTON(SQR,1000);
(%o3)                    2.236068
@end example
    (Note that RETURN, when executed, causes the current value of
GUESS to be returned as the value of the DO.  The BLOCK is exited and
this value of the DO is returned as the value of the BLOCK because the
DO is the last statement in the block.)
    One other form of the DO is available in Maxima.  The syntax is:

@example
FOR variable IN list [end-tests] DO body
@end example
    The members of the list are any expressions which will
successively be assigned to the variable on each iteration of the
body.  The optional end-tests can be used to terminate execution of
the DO; otherwise it will terminate when the list is exhausted or when
a RETURN is executed in the body.  (In fact, list may be any
non-atomic expression, and successive parts are taken.)
@example

(%i1)  FOR F IN [LOG, RHO, ATAN] DO LDISP(F(1))$
(%t1)                                  0
(%t2)                                RHO(1)
                                     %PI
(%t3)                                 ---
                                      4
(%i4) EV(%t3,NUMER);
(%o4)                             0.78539816

@end example
@end deffn
@c @node ERRCATCH, ERREXP, {special operator}, Program Flow
@c @unnumberedsec phony
@defun ERRCATCH (exp1, exp2, ...)
evaluates its arguments one by one and
returns a list of the value of the last one if no error occurs.  If an
error occurs in the evaluation of any arguments, ERRCATCH "catches"
the error and immediately returns [] (the empty list).  This function
is useful in BATCH files where one suspects an error might occur which
would otherwise have terminated the BATCH if the error weren't caught.

@end defun
@c @node ERREXP, ERROR, ERRCATCH, Program Flow
@c @unnumberedsec phony
@defvar ERREXP
 default: [ERREXP] When an error occurs in the course of a
computation, Maxima prints out an error message and terminates the
computation.  ERREXP is set to the offending expression and the
message "ERREXP contains the offending expression" is printed.  The
user can then type ERREXP; to see this and hopefully find the problem.

@end defvar
@c @node ERROR, ERRORFUN, ERREXP, Program Flow
@c @unnumberedsec phony
@defun ERROR (arg1, arg2, ...)
will evaluate and print its arguments and
then will cause an error return to top level Maxima or to the nearest
enclosing ERRCATCH.  This is useful for breaking out of nested
functions if an error condition is detected, or wherever one can't
type control-^.
The variable ERROR is set to a list describing the error, the first of
it being a string of text, and the rest the objects in question.
ERRORMSG(); is the preferred way to see the last error message.
ERRORFUN default: [FALSE] - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in BATCH files where the user may want his
Maxima killed or his terminal logged out if an error occurs.  In
these cases ERRORFUN would be set to QUIT or LOGOUT.

@end defun
@c @node ERRORFUN, ERRORMSG, ERROR, Program Flow
@c @unnumberedsec phony
@defvar ERRORFUN
 default: [FALSE] - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in BATCH files where the user may want his
Maxima killed or his terminal logged out if an error occurs.  In
these cases ERRORFUN would be set to QUIT or LOGOUT.

@end defvar
@c @node ERRORMSG, {special operator}, ERRORFUN, Program Flow
@c @unnumberedsec phony
@defun ERRORMSG ()
reprints the last error message.  This is very helpful if
you are using a display console and the message has gone off the
screen.  The variable ERROR is set to a list describing the error,
the first of it being a string of text, and the rest the objects in
question.
TTYINTFUN:LAMBDA([],ERRORMSG(),PRINT(""))$ will set up the user-interrupt
character (^U) to reprint the message.

@end defun
@c @node FOR
@c @unnumberedsec phony
@deffn {special operator} FOR
 - Used in iterations, do DESCRIBE("DO"); for a description of
Maxima's iteration facilities.

@end deffn
@c @node GO, {special operator}, {special operator}, Program Flow
@c @unnumberedsec phony
@defun GO (tag)
is used within a BLOCK to transfer control to the statement
of the block which is tagged with the argument to GO.  To tag a
statement, precede it by an atomic argument as another statement in
the BLOCK.  For example:
@example
BLOCK([X],X:1,LOOP,X+1,...,GO(LOOP),...)
@end example
.
The argument to GO must be the name of a tag appearing in the same
BLOCK.  One cannot use GO to transfer to tag in a BLOCK other than the
one containing the GO.

@end defun
@c @node IF
@c @unnumberedsec phony
@deffn {special operator} IF
 - The IF statement is used for conditional execution.  The syntax
is:
@example
    IF condition THEN expression1 ELSE expression2.
@end example
The result of an IF statement is expression1 if condition is true and
expression2 if it is false.  expression1 and expression2 are any
Maxima expressions (including nested IF statements), and condition is
an expression which evaluates to TRUE or FALSE and is composed of
relational and logical operators which are as follows:
@example
 
Operator name       Symbol      Type
greater than        >           relational infix
equal to            = , EQUAL   "  "
not equal to        #           "  "
less than           <           "  "
greater than        >=
  or equal to                   "  "
less than           <=
  or equal to                   "  "
and                 AND         logical infix
or                  OR          "  "
not                 NOT         logical prefix

@end example
@end deffn
@c @unnumberedsec phony
@defun MAP (fn, exp1, exp2, ...)
returns an expression whose leading operator
is the same as that of the expi but whose subparts are the results of
applying fn to the corresponding subparts of the expi.  Fn is either
the name of a function of n arguments (where n is the number of expi)
or is a LAMBDA form of n arguments.
MAPERROR[TRUE] - if FALSE will cause all of the mapping functions to
(1) stop when they finish going down the shortest expi if not all of
the expi are of the same length and (2) apply fn to [exp1, exp2,...]
if the expi are not all the same type of object. If MAPERROR is TRUE
then an error message will be given in the above two instances.
One of the uses of this function is to MAP a function (e.g. PARTFRAC)
onto each term of a very large expression where it ordinarily wouldn't
be possible to use the function on the entire expression due to an
exhaustion of list storage space in the course of the computation.
@example
(%i1) MAP(F,X+A*Y+B*Z);
(%o1)                        F(B Z) + F(A Y) + F(X)
(%i2) MAP(LAMBDA([U],PARTFRAC(U,X)),X+1/(X^3+4*X^2+5*X+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + X
                         X + 2   X + 1          2
                                         (X + 1)
(%i3) MAP(RATSIMP, X/(X^2+X)+(Y^2+Y)/Y);
                                      1
(%o3)                            Y + ----- + 1
                                    X + 1
(%i4) MAP("=",[A,B],[-0.5,3]);
(%o4)                          [A = - 0.5, B = 3]


@end example
@end defun
@c @node MAPATOM, MAPERROR, MAP, Program Flow
@c @unnumberedsec phony
@defun MAPATOM (expr)
is TRUE if and only if expr is treated by the MAPping
routines as an "atom", a unit.  "Mapatoms" are atoms, numbers
(including rational numbers), and subscripted variables.

@end defun
@c @node MAPERROR, MAPLIST, MAPATOM, Program Flow
@c @unnumberedsec phony
@defvar MAPERROR
 default: [TRUE] - if FALSE will cause all of the mapping
functions, for example
@example
MAP(fn,exp1,exp2,...))
@end example
to (1) stop when they finish
going down the shortest expi if not all of the expi are of the same
length and (2) apply fn to [exp1, exp2,...] if the expi are not all
the same type of object.  If MAPERROR is TRUE then an error message
will be given in the above two instances.

@end defvar
@c @node MAPLIST, PREDERROR, MAPERROR, Program Flow
@c @unnumberedsec phony
@defun MAPLIST (fn, exp1, exp2, ...)
yields a list of the applications of fn
to the parts of the expi.  This differs from MAP(fn,exp1,exp2,...)
which returns an expression with the same main operator as expi has
(except for simplifications and the case where MAP does an APPLY).  Fn
is of the same form as in MAP.

@end defun
@c @node PREDERROR, RETURN, MAPLIST, Program Flow
@c @unnumberedsec phony
@defvar PREDERROR
 default: [TRUE] - If TRUE, an error message is signalled
whenever the predicate of an IF statement or an IS function fails to
evaluate to either TRUE or FALSE.  If FALSE, UNKNOWN is returned
instead in this case.  The PREDERROR:FALSE mode is not supported in
translated code.

@end defvar
@c @node RETURN, SCANMAP, PREDERROR, Program Flow
@c @unnumberedsec phony
@defun RETURN (value)
may be used to exit explicitly from a BLOCK, bringing
its argument.  Do DESCRIBE(BLOCK); for more information.

@end defun
@c @node SCANMAP, THROW, RETURN, Program Flow
@c @unnumberedsec phony
@defun SCANMAP (function,exp)
recursively applies function to exp, in a "top
down" manner.  This is most useful when "complete" factorization is
desired, for example:
@example
(%i1) EXP:(A^2+2*A+1)*Y + X^2$
(%i2) SCANMAP(FACTOR,EXP);
                                    2      2
(%o2)                         (A + 1)  Y + X
@end example

Note the way in which SCANMAP applies the given function FACTOR to the
constituent subexpressions of exp; if another form of exp is presented
to SCANMAP then the result may be different.  Thus, %o2 is not
recovered when SCANMAP is applied to the expanded form of exp:
@example
(%i3) SCANMAP(FACTOR,EXPAND(EXP));
                           2                  2
(%o3)                      A  Y + 2 A Y + Y + X
@end example

Here is another example of the way in which SCANMAP recursively
applies a given function to all subexpressions, including exponents:
@example
(%i4) EXPR : U*V^(A*X+B) + C$
(%i5) SCANMAP('F, EXPR);
                    F(F(F(A) F(X)) + F(B))
(%o5) F(F(F(U) F(F(V)                      )) + F(C))
@end example
SCANMAP(function,expression,BOTTOMUP) applies function to exp in a
"bottom-up" manner.  E.g., for undefined F,

@example
SCANMAP(F,A*X+B) ->
   F(A*X+B) -> F(F(A*X)+F(B)) -> F(F(F(A)*F(X))+F(B))
SCANMAP(F,A*X+B,BOTTOMUP) -> F(A)*F(X)+F(B)
    -> F(F(A)*F(X))+F(B) ->
     F(F(F(A)*F(X))+F(B))
@end example

In this case, you get the same answer both
ways.

@end defun
@c @node THROW,  , SCANMAP, Program Flow
@c @unnumberedsec phony
@defun THROW (exp)
evaluates exp and throws the value back to the most recent
CATCH.  THROW is used with CATCH as a structured nonlocal exit
mechanism.

@end defun

