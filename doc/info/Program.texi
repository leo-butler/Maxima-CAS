@menu
* Introduction to Program Flow::  
* Definitions for Program Flow::  
@end menu

@node Introduction to Program Flow, Definitions for Program Flow, Program Flow, Program Flow
@section Introduction to Program Flow

Maxima provides a @code{do} loop for iteration, as well as more primitive
constructs such as @code{go}.

@c end concepts Program Flow
@node Definitions for Program Flow,  , Introduction to Program Flow, Program Flow
@section Definitions for Program Flow

@defun backtrace ()
@defunx backtrace (n)
Prints the call stack, that is, the list of functions which
called the currently active function.

@code{backtrace()} prints the entire call stack.

@code{backtrace (@var{n})} prints the @var{n} most recent 
functions, including the currently active function.

@c IS THIS STATMENT REALLY NEEDED ?? 
@c (WHY WOULD ANYONE BELIEVE backtrace CANNOT BE CALLED OUTSIDE A DEBUGGING CONTEXT??)
@code{backtrace} can be called from a script, a function, or the interactive prompt
(not only in a debugging context).

@itemize @bullet
@item
@code{backtrace()} prints the entire call stack.

@example
(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@itemize @bullet
@item
@code{backtrace (@var{n})} prints the @var{n} most recent 
functions, including the currently active function.

@example
(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@end defun

@deffn {special operator} do
The @code{do} statement is used for performing iteration.  Due to its
great generality the @code{do} statement will be described in two parts.
First the usual form will be given which is analogous to that used in
several other programming languages (Fortran, Algol, PL/I, etc.); then
the other features will be mentioned.

There are three variants of this form that differ only in their
terminating conditions.  They are:

@itemize @bullet
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      thru @var{limit} do @var{body}}
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      while @var{condition} do @var{body}}
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      unless @var{condition} do @var{body}}
@end itemize

@c UGH. DO WE REALLY NEED TO MENTION THIS??
(Alternatively, the @code{step} may be given after the termination condition
or limit.)

@var{initial_value}, @var{increment}, @var{limit}, and @var{body} can be any
expressions.  If the increment is 1 then "@code{step 1}" may be omitted.

The execution of the @code{do} statement proceeds by first assigning the
initial_value to the variable (henceforth called the
control-variable). Then: (1) If the control-variable has exceeded the
limit of a @code{thru} specification, or if the condition of the @code{unless} is
@code{true}, or if the condition of the @code{while} is @code{false} then the @code{do}
terminates. (2) The body is evaluated.  (3) The increment is added to
the control-variable.  The process from (1) to (3) is performed
repeatedly until the termination condition is satisfied.  One may also
give several termination conditions in which case the @code{do} terminates
when any of them is satisfied.

In general the @code{thru} test is satisfied when the control-variable is
greater than the limit if the increment was non-negative, or when the
control-variable is less than the limit if the increment was negative.
The increment and limit may be non-numeric expressions as long as this
inequality can be determined.  However, unless the increment is
syntactically negative (e.g. is a negative number) at the time the @code{do}
statement is input, Maxima assumes it will be positive when the @code{do} is
executed.  If it is not positive, then the @code{do} may not terminate
properly.

Note that the limit, increment, and termination condition are
evaluated each time through the loop.  Thus if any of these involve
much computation, and yield a result that does not change during all
the executions of the body, then it is more efficient to set a
variable to their value prior to the @code{do} and use this variable in the
@code{do} form.

The value normally returned by a @code{do} statement is the atom @code{done}.
However, the function
@code{return} may be used inside the body to exit the @code{do} prematurely and give
it any desired value.
Note however that a @code{return} within a @code{do} that
occurs in a @code{block} will exit only the @code{do} and not the @code{block}.  Note also
that the @code{go} function may not be used to exit from a @code{do} into a
surrounding @code{block}.

The control-variable is always local to the @code{do} and thus any
variable may be used without affecting the value of a variable with
the same name outside of the @code{do}.  The control-variable is unbound
after the @code{do} terminates.

@example
(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
@end example

@example
(%i1) s: 0$
(%i2) for i: 1 while i <= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
@end example

Note that the condition @code{while i <= 10}
is equivalent to @code{unless i > 10} and also @code{thru 10}.

@example
(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p > 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
@end example

which gives 8 terms of the Taylor series for @code{e^sin(x)}.

@example
(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) < 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
@end example

This example computes the negative square root of 10 using the
Newton- Raphson iteration a maximum of 10 times.  Had the convergence
criterion not been met the value returned would have been @code{done}.
Additional Forms of the @code{do} Statement

Instead of always adding a quantity to the control-variable one
may sometimes wish to change it in some other way for each iteration.
In this case one may use @code{next @var{expression}} instead of @code{step @var{increment}}.
This will cause the control-variable to be set to the
result of evaluating expression each time through the loop.

@example
(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
@end example

@c UGH. DO WE REALLY NEED TO MENTION THIS??
As an alternative to @code{for @var{variable}: @var{value} ...do...} the syntax
@code{for @var{variable} from @var{value} ...do...}  may be used.  This permits the
@code{from @var{value}} to be placed after the step or next value or after the
termination condition.  If @code{from @var{value}} is omitted then 1 is used as
the initial value.

Sometimes one may be interested in performing an iteration where
the control-variable is never actually used.  It is thus permissible
to give only the termination conditions omitting the initialization
and updating information as in the following example to compute the
square-root of 5 using a poor initial guess.

@example
(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
@end example

If it is desired one may even omit the termination conditions
entirely and just give @code{do @var{body}} which will continue to evaluate the
body indefinitely.  In this case the function @code{return} should be used to
terminate execution of the @code{do}.

@example
(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) < 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
@end example

@c DUNNO IF WE NEED THIS LEVEL OF DETAIL; THIS ARTICLE IS GETTING PRETTY LONG
(Note that @code{return}, when executed, causes the current value of
@code{x} to be returned as the value of the @code{do}.  The @code{block} is exited and
this value of the @code{do} is returned as the value of the @code{block} because the
@code{do} is the last statement in the block.)

One other form of the @code{do} is available in Maxima.  The syntax is:

@example
for @var{variable} in @var{list} @var{end_tests} do @var{body}
@end example

The elements of @var{list} are any expressions which will
successively be assigned to the variable on each iteration of the
body.  The optional termination tests @var{end_tests} can be used to terminate execution of
the @code{do}; otherwise it will terminate when the list is exhausted or when
a @code{return} is executed in the body.  (In fact, list may be any
non-atomic expression, and successive parts are taken.)

@example
(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
@end example

@end deffn

@defun errcatch (expr_1, expr_2, ...)
evaluates its arguments one by one and
returns a list of the value of the last one if no error occurs.  If an
error occurs in the evaluation of any arguments, @code{errcatch} "catches"
the error and immediately returns [] (the empty list).  This function
is useful in @code{batch} files where one suspects an error might occur which
would otherwise have terminated the @code{batch} if the error weren't caught.

@end defun

@defvar errexp
 default: @code{errexp} When an error occurs in the course of a
computation, Maxima prints out an error message and terminates the
computation.  @code{errexp} is set to the offending expression and the
message "@code{errexp contains the offending expression}" is printed.  The
user can then type @code{errexp;} to see this and hopefully find the problem.

@end defvar

@defun error (arg_1, arg_2, ...)
will evaluate and print its arguments and
then will cause an error return to top level Maxima or to the nearest
enclosing @code{errcatch}.  This is useful for breaking out of nested
functions if an error condition is detected.
The variable @code{error} is set to a list describing the error, the first of
it being a string of text, and the rest the objects in question.
@code{errormsg();} is the preferred way to see the last error message.

@code{errorfun} - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in @code{batch} files where the user may want his
Maxima killed or his terminal logged out if an error occurs.  In
these cases @code{errorfun} would be set to @code{quit} or @code{logout}.

@end defun

@defvar errorfun
 default: @code{false} - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in @code{batch} files where the user may want his
Maxima killed or his terminal logged out if an error occurs.  In
these cases @code{errorfun} would be set to @code{quit} or @code{logout}.

@end defvar

@defun errormsg ()
reprints the last error message.  This is very helpful if
you are using a display console and the message has gone off the
screen.  The variable @code{error} is set to a list describing the error,
the first of it being a string of text, and the rest the objects in
question.
@code{ttyintfun:lambda([],errormsg(),print(""))$} will set up the user-interrupt
character (^U) to reprint the message.
@c ^U -- OBSOLETE

@end defun

@deffn {special operator} for
 - Used in iterations. See @code{do} for a description of
Maxima's iteration facilities.

@end deffn

@defun go (tag)
is used within a @code{block} to transfer control to the statement
of the block which is tagged with the argument to @code{go}.  To tag a
statement, precede it by an atomic argument as another statement in
the @code{block}.  For example:
@example
block([x],x:1,loop,x+1,...,go(loop),...)
@end example
.
The argument to @code{go} must be the name of a tag appearing in the same
@code{block}.  One cannot use @code{go} to transfer to tag in a @code{block} other than the
one containing the @code{go}.

@end defun

@c NEEDS CLARIFICATION, EXPANSION, EXAMPLES
@deffn {special operator} if
The @code{if} statement is used for conditional execution.  The syntax
is:

@example
if <condition> then <expr_1> else <expr_2>
@end example

The result of an @code{if} statement is @var{expr_1} if condition is @code{true} and
@var{expr_2} otherwise.  @var{expr_1} and @var{expr_2} are any
Maxima expressions (including nested @code{if} statements), and @var{condition} is
an expression which evaluates to @code{true} or @code{false} and is composed of
relational and logical operators which are as follows:

@c - SEEMS LIKE THIS TABLE REALLY WANTS TO BE IN A DISCUSSION OF PREDICATE FUNCTIONS; THIS IS OK I GUESS
@c - NEED TO FIGURE OUT WHETHER # IS "not =" OR "not equal"
@c   WHEN WE HAVE AN ANSWER, MAKE A NOTE HERE AND ALSO IN DESCRIPTIONS OF = AND equal
@c - REFORMAT THIS TABLE USING TEXINFO MARKUP
@example
Operation           Symbol      Type
 
less than           <           relational infix
less than           <=
  or equal to                   relational infix
syntactic equality  =           relational infix
equivalence         equal       relational function
not equal to        #           relational infix
greater than        >=
  or equal to                   relational infix
greater than        >           relational infix
and                 and         logical infix
or                  or          logical infix
not                 not         logical prefix
@end example

@end deffn

@defun map (f, expr_1, expr_2, ...)
returns an expression whose leading operator
is the same as that of the expi but whose subparts are the results of
applying fn to the corresponding subparts of the expi.  Fn is either
the name of a function of n arguments (where n is the number of expi)
or is a @code{lambda} form of n arguments.
@code{maperror} - if @code{false} will cause all of the mapping functions to
(1) stop when they finish going down the shortest expi if not all of
the expi are of the same length and (2) apply fn to [exp1, exp2,...]
if the expi are not all the same type of object. If @code{maperror} is @code{true}
then an error message will be given in the above two instances.
One of the uses of this function is to @code{map} a function (e.g. @code{partfrac})
onto each term of a very large expression where it ordinarily wouldn't
be possible to use the function on the entire expression due to an
exhaustion of list storage space in the course of the computation.
@example
(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map("=",[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


@end example
@end defun

@defun mapatom (expr)
is @code{true} if and only if expr is treated by the mapping
routines as an "atom", a unit.  "Mapatoms" are atoms, numbers
(including rational numbers), and subscripted variables.

@end defun

@defvar maperror
 default: @code{true} - if @code{false} will cause all of the mapping
functions, for example
@example
map(f,expr_1,expr_2,...))
@end example
to (1) stop when they finish
going down the shortest expi if not all of the expi are of the same
length and (2) apply fn to [exp1, exp2,...] if the expi are not all
the same type of object.  If @code{maperror} is @code{true} then an error message
will be given in the above two instances.

@end defvar

@defun maplist (f, expr_1, expr_2, ...)
yields a list of the applications of fn
to the parts of the expi.  This differs from @code{map(f,expr_1,expr_2,...)}
which returns an expression with the same main operator as expi has
(except for simplifications and the case where @code{map} does an @code{apply}).  Fn
is of the same form as in @code{map}.

@end defun

@defvar prederror
 default: @code{true} - If @code{true}, an error message is signalled
whenever the predicate of an @code{if} statement or an @code{is} function fails to
evaluate to either @code{true} or @code{false}.  If @code{false}, @code{unknown} is returned
instead in this case.  The @code{prederror:false} mode is not supported in
translated code.

@end defvar

@defun return (value)
may be used to exit explicitly from a block, bringing
its argument.  See @code{block} for more information.

@end defun

@defun scanmap (function,exp)
recursively applies function to exp, in a "top
down" manner.  This is most useful when "complete" factorization is
desired, for example:
@example
(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
@end example

Note the way in which @code{scanmap} applies the given function @code{factor} to the
constituent subexpressions of exp; if another form of exp is presented
to @code{scanmap} then the result may be different.  Thus, %o2 is not
recovered when @code{scanmap} is applied to the expanded form of exp:
@example
(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
@end example

Here is another example of the way in which @code{scanmap} recursively
applies a given function to all subexpressions, including exponents:
@example
(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
@end example
@code{scanmap(@var{function},@var{expression},bottomup)} applies function to exp in a
"bottom-up" manner.  E.g., for undefined @code{f},

@example
scanmap(f,a*x+b) ->
   f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
    -> f(f(a)*f(x))+f(b) ->
     f(f(f(a)*f(x))+f(b))
@end example

In this case, you get the same answer both
ways.

@end defun

@defun throw (exp)
evaluates exp and throws the value back to the most recent
@code{catch}.  @code{throw} is used with @code{catch} as a structured nonlocal exit
mechanism.

@end defun

