@c end concepts Debugging
@menu
* Introduction to Debugging::
* Definitions for Debugging::   
@end menu

@node Introduction to Debugging, , Definitions for Debugging, Debugging
@section Introduction to Debugging
The Maxima has source level capabilities.  We can set a breakpoint
at a line in a file, and then step line by line from there.  The
call stack may be examined, together with the variables bound at that
level.

The ideal way to run Maxima is using dbl mode in GNU emacs.   Then
when we break in a function, the source code auto magically appears
in the other window.  One can step line by line, seeing a little arrow
in the other window, indicating where you are.   As you go up the
call stack, the other window changes showing where you were inside
that function.   Even if you do not use the debugger, it is convenient
to be able to evaluate forms directly from your source file into the
inferior maxima.

To do all this in emacs type

@example
M-x dbl
maxima
@end example
This will give you a window, and then you invoke maxima as you usually
would.    Look at the Mode help (c-h m) in emacs to get more information.

Maxima now allows special commands beginning with a ':'.   This was
introduced because of the debugger.  


@node Definitions for Debugging, Introduction to Debugging, Debugging, Debugging
@section Definitions for Debugging
@c @node REFCHECK
@c @unnumberedsec phony
@defvar REFCHECK
 default: [FALSE] - if TRUE causes a message to be printed
each time a bound variable is used for the first time in a
computation.

@end defvar
@c @node REMTRACE
@c @unnumberedsec phony
@defun REMTRACE ()
This function is no longer used with the new TRACE
package.

@end defun
@c @node SETCHECK
@c @unnumberedsec phony
@defvar SETCHECK
 default: [FALSE] - if set to a list of variables (which can
be subscripted) will cause a printout whenever the variables, or
subscripted occurrences of them, are bound (with : or :: or function
argument binding).  The printout consists of the variable and the
value it is bound to.  SETCHECK may be set to ALL or TRUE thereby
including all variables.  Note: No printout is generated when a
SETCHECKed variable is set to itself, e.g. X:'X.

@end defvar
@c @node SETCHECKBREAK
@c @unnumberedsec phony
@defvar SETCHECKBREAK
 default: [FALSE] - if set to TRUE will cause a
(MACSYMA-BREAK) to occur whenever the variables on the SETCHECK list
are bound.  The break occurs before the binding is done.  At this
point, SETVAL holds the value to which the variable is about to be
set.  Hence, one may change this value by resetting SETVAL.

@end defvar
@c @node SETVAL
@c @unnumberedsec phony
@defvar SETVAL
 - holds the value to which a variable is about to be set when
a SETCHECKBREAK occurs.  Hence, one may change this value by resetting
SETVAL.  (See SETCHECKBREAK).

@end defvar
@c @node TIMER
@c @unnumberedsec phony
@defun TIMER (F)
will put a timer-wrapper on the function F, within the TRACE
package, i.e. it will print out the time spent in computing F.

@end defun
@c @node TIMER_DEVALUE
@c @unnumberedsec phony
@defvar TIMER_DEVALUE
 default: [FALSE] - when set to TRUE then the time
charged against a function is the time spent dynamically inside the
function devalued by the time spent inside other TIMED functions.

@end defvar
@c @node TIMER_INFO
@c @unnumberedsec phony
@defun TIMER_INFO (F)
will print the information on timing which is stored
also as GET('F,'CALLS); GET('F,'RUNTIME); and GET('F,'GCTIME); .  This
is a TRACE package function.

@end defun
@c @node TRACE
@c @unnumberedsec phony
@defun TRACE (name1, name2, ...)
gives a trace printout whenever the
functions mentioned are called.  TRACE() prints a list of the
functions currently under TRACE.  On MC see MACDOC;TRACE USAGE for
more information.  Also, DEMO("trace.dem"); .  To remove tracing,
see UNTRACE.

@end defun
@c @node TRACE_OPTIONS
@c @unnumberedsec phony
@defun TRACE_OPTIONS (F,option1,option2,...)
gives the function F the
options indicated.  An option is either a keyword or an expression.
The possible Keywords are:
 Keyword     Meaning of return value
----------------------------------------
 NOPRINT     If TRUE do no printing. 
 BREAK       If TRUE give a breakpoint.
 LISP_PRINT  If TRUE use lisp printing.
 INFO        Extra info to print.
 ERRORCATCH  If TRUE errors are caught.
A keyword means that the option is in effect.  Using a keyword as an
expression, e.g. NOPRINT(predicate_function) means to apply the
predicate_function (which is user-defined) to some arguments to
determine if the option is in effect. The argument list to this
predicate_function is always [LEVEL, DIRECTION, FUNCTION, ITEM] where
LEVEL is the recursion level for the function.  DIRECTION is either
ENTER or EXIT.  FUNCTION is the name of the function.  ITEM is either
the argument list or the return value.  On MC see
DEMO("trace.dem"); for more details.

@end defun
@c @node UNTRACE
@c @unnumberedsec phony
@defun UNTRACE (name1, ...)
removes tracing invoked by the TRACE function.
UNTRACE() removes tracing from all functions.

@end defun
