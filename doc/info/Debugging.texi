@c end concepts Debugging
@menu
* Source Level Debugging::
* Keyword Commands::
* Definitions for Debugging::   
@end menu

@node Source Level Debugging, Keyword Commands, , Debugging
@section Source Level Debugging

Maxima has source level capabilities.  A user can set a breakpoint at
a line in a file, and then step line by line from there.  The call
stack may be examined, together with the variables bound at that
level.  If the user is running the code under GNU emacs in a shell
window (dbl shell), or is running @code{xmaxima} the graphical
interface version, then if he stops at a break point, he will see his
current position in the source file which will be displayed in the
other half of the window, either highlighted in red, or with a little
arrow pointing at the right line.  He can advance single lines at a
time by typing M-n (Alt-n) or alternately by entering @code{:n}.  To
see the names of the keyword commands type :help (or :h).  In general
commands may be abbreviated if the abbreviation is unique.  If not
unique the alternatives will be listed.

Under Emacs you should run in a @code{dbl} shell, which requires the
dbl.el file in the elisp directory.
Make sure you install the elisp files or add the maxima elisp directory to
your path:
eg add the following to your @file{.emacs} file or the @code{site-init.el}

@example
(setq load-path (cons "/usr/local/maxima-5.5/elisp" load-path))
(autoload 'dbl "dbl")
@end example
then in emacs 
@example
M-x dbl
@end example
should start a shell window in which you can run programs, for example
maxima, gcl, gdb etc.   This shell window also knows about source level
debugging, and display of source code in the other window.  

@example
maxima
Maxima 5.5 Wed Apr 18 19:02:00 CDT 2001 (with enhancements by W. Schelter).
Licensed under the GNU Public License (see file COPYING)
(%i1) batchload("/tmp/joe.mac");
(%o1) 				 /tmp/joe.mac
(%i2) :br joe
Turning on debugging debugmode(true)
Bkpt 0 for joe (in /tmp/joe.mac line 8) 
(%i2) foo(2,3);
Bkpt 0:(joe.mac 8)
(dbm:1) :bt                        <-- :bt typed here gives a backtrace 
#0: joe(y=5)(joe.mac line 8)
#1: foo(x=2,y=3)(joe.mac line 5)
(joe.mac 9)                        <-- Here type M-n to advance line 
(joe.mac 10)                       <-- Here type M-n to advance line
                                   In the other buffer the source code
                                   appears with an arrow.
(dbm:1) u;                         Investigate value of 'u
28
(dbm:1) u:33;                      Alter it to be 33
(dbm:1) :r                         :r Resumes the computation
(%o3) 				     1094
@end example

The actual file /tmp/joe.mac is the following:
@example

foo(x,y):=(
  x:x+2,
  y:y+2,
  x:joe(y),
  x+y);
    
joe(y):=block([u:y^2],
  u:u+3,
  u:u^2,
   u);
     
@end example



If you are running in Gnu Emacs then if you are looking at the
file joe.mac, you may set a break point at a certain line of that
file by typing @code{C-x space}.  This figures out which function
your cursor is in, and then it sees which line of that function
you are on.   If you are on say line 2 of joe, then it will
insert in the other window @code{:br joe 2} the command to
break joe at its second line.   To have this enabled you must have
maxima-mode.el on in the window in which the file joe.mac is visiting.
There are additional commands available in that file window, such as
evaluating the function into the maxima, by typing @code{Alt-Control-x}

@node Keyword Commands, Definitions for Debugging, Source Level Debugging, Debugging
@section Keyword Commands

Break commands start with ':'.   Thus to evaluate a lisp form you
may type @code{:lisp } followed by the argument which is the form
to be evaluated.  
@example
(%i3) :lisp (+ 2 3) 
5
@end example
The number of arguments taken depends on the particular command.  Also
you need not type the whole command, just enough to be unique among
the keyword commands.   Thus @code{:br} would suffice for @code{:break}.
The current commands are:

@table @code
@item :break
Set a breakpoint in the specified FUNCTION at the
specified LINE offset from the beginning of the function.
If FUNCTION is given as a string, then it is presumed to be
a FILE and LINE is the offset from the beginning of the file.
@item :bt
Undocumented
@item :continue
Continue the computation.
@item :delete
Delete all breakpoints, or if arguments are supplied delete the specified
breakpoints
@item :disable
Disable the specified breakpoints, or all if none are specified
@item :enable
Enable the specified breakpoints, or all if none are specified
@item :frame
With an argument print the selected stack frame.
Otherwise the current frame.
@item :help
Print help on a break command or with no arguments on all break commands
@item :info
Undocumented
@item :lisp
Evaluate the lisp form following on the line
@item :lisp-quiet
Evaluate its arg as a lisp form without printing a prompt.
@item :next     Like :step, except that subroutine calls are stepped over
@item :quit
Quit this level
@item :resume
Continue the computation.
@item :step
Step program until it reaches a new source line
@item :top
Throw to top level
@end table 


@node Definitions for Debugging, , Keyword Commands, Debugging
@section Definitions for Debugging
@c @node REFCHECK
@c @unnumberedsec phony
@defvar REFCHECK
Default value: FALSE

If REFCHECK is TRUE, Maxima prints a message
each time a bound variable is used for the first time in a
computation.

@end defvar
@c @node SETCHECK
@c @unnumberedsec phony
@defvar SETCHECK
Default value: FALSE

If SETCHECK is set to a list of variables (which can
be subscripted), 
Maxima will print a message whenever the variables, or
subscripted occurrences of them, are bound with the
ordinary assignment operator @code{:}, the @code{::} assignment
operator, or function argument binding,
but not the function assignment @code{:=} nor the macro assignment
@code{::=} operators.
The message comprises the name of the variable and the
value it is bound to.

SETCHECK may be set to ALL or TRUE thereby
including all variables.

Each new assignment of SETCHECK establishes a new list of variables
to check, and any variables previously assigned to SETCHECK are forgotten.

The names assigned to SETCHECK must be quoted if they would otherwise
evaluate to something other than themselves.
For example, if X, Y, and Z are already bound, then enter

@example
SETCHECK:['X, 'Y, 'Z]$
@end example

to put them on the list of variables to check.

No printout is generated when a
variable on the SETCHECK list is set to itself, e.g., @code{X: 'X}.

@end defvar
@c @node SETCHECKBREAK
@c @unnumberedsec phony
@defvar SETCHECKBREAK
Default value: FALSE

When SETCHECKBREAK is TRUE,
Maxima will present a break prompt 
whenever a variable on the SETCHECK list is assigned a new value.
The break occurs before the assignment is carried out.
At this point, SETVAL holds the value to which the variable is 
about to be assigned.
Hence, one may assign a different value by assigning to SETVAL.

See also SETCHECK and SETVAL.

@end defvar
@c @node SETVAL
@c @unnumberedsec phony
@defvar SETVAL
Holds the value to which a variable is about to be set when
a SETCHECKBREAK occurs.
Hence, one may assign a different value by assigning to SETVAL.

See also SETCHECK and SETCHECKBREAK.

@end defvar
@c @node TIMER
@c @unnumberedsec phony
@defun TIMER (F1, F2, ...)
@defunx TIMER ()
Given functions F1, F2, F3, ...,
TIMER puts each one on the list of functions for which timing statistics are collected.
With no arguments, 
TIMER returns the list of timed functions.
@code{TIMER(F)$ TIMER(G)$} will put F and then G onto the list;
the list accumulates from one call to the next.

Maxima records how much time is spent executing each function
on the list of timed functions.
TIMER_INFO returns the timing statistics, including the
average time elapsed per function call, the number of calls, and the
total time elapsed.
UNTIMER removes functions from the list of timed functions.

TIMER quotes its arguments. 
@code{F(X) := X^2$ G:F$ TIMER(G)$} will not put F on the timer list.

If TRACE(F) is in effect, then TIMER(F) has no effect; TRACE and
TIMER can't both be in effect at the same time.

See also TIMER_DEVALUE.

@end defun
@defun UNTIMER (F1, F2, F3, ...)
@defunx UNTIMER ()
Given functions F1, F2, F3, ...,
UNTIMER removes each function from the timer list.
With no arguments, UNTIMER removes all functions currently on the timer list.

After UNTIMER (F) is executed, TIMER_INFO (F) will still return
previously collected timing statistics,
although TIMER_INFO() (with no arguments) does not
return information about any function not currently on the timer list.
TIMER (F) resets all timing statistics to zero
and puts F on the timer list again.

@end defun
@c @node TIMER_DEVALUE
@c @unnumberedsec phony
@defvar TIMER_DEVALUE
Default value: FALSE

If set to TRUE, Maxima subtracts from each timed function
the time spent in other timed functions. Otherwise, the time reported 
for each function includes the time spent in other functions.
Note that time spent in untimed functions is not subtracted from the
total time.

See also TIMER and TIMER_INFO.

@end defvar
@c @node TIMER_INFO
@c @unnumberedsec phony
@defun TIMER_INFO (F1, F2, F3, ...)
@defunx TIMER_INFO ()
Given functions F1, F2, F3, ...,
TIMER_INFO returns a matrix containing timing information for each function.
With no arguments, TIMER_INFO returns timing information for
all functions currently on the timer list.

The matrix returned by TIMER_INFO contains the function name,
time per function call, number of function calls, total time,
and "GCTIME", which meant "garbage collection time" in the original MACSYMA
but is now always zero.

The data from which TIMER_INFO constructs its return value
can also be obtained by the GET function:

@example
GET(F, 'CALLS);  GET(F, 'RUNTIME);  GET(F, 'GCTIME);
@end example

See also TIMER.

@end defun
@c @node TRACE
@c @unnumberedsec phony
@defun TRACE (F1, F2, F3, ...)
@defunx TRACE ()
Given functions F1, F2, F3, ..., 
TRACE instructs Maxima to print out
debugging information whenever those functions are called.
With no arguments,
TRACE returns a list of all the functions currently being traced.
@code{TRACE(F)$ TRACE(G)$} will put F and then G onto the list of functions
to be traced; the list accumulates from one call to the next.

The UNTRACE function disables tracing.
See also TRACE_OPTIONS. 

TRACE quotes its arguments. Thus,
@code{F(X) := X^2$ G:F$ TRACE(G)$} will not put F on the timer list.

When a function is redefined, it is removed from the timer list.
Thus after @code{TIMER(F)$ F(X) := X^2$},
function F is no longer on the timer list.

If TIMER (F) is in effect, then TRACE (F) has no effect; TRACE and
TIMER can't both be in effect for the same function.

@end defun
@c @node TRACE_OPTIONS
@c @unnumberedsec phony
@defun TRACE_OPTIONS (F, option1, option2, ...)
@defunx TRACE_OPTIONS (F)
Sets the trace options for function F.
Any previous options are superseded.
TRACE_OPTIONS (F, ...) has no effect unless
TRACE (F) is also called (either before or after TRACE_OPTIONS). 

TRACE_OPTIONS (F) resets all options to their default values.

The option keywords are:

@example
 Keyword     If specified...
----------------------------------------------------------------
 NOPRINT     Do not print a message at function entry and exit.

 BREAK       Put a breakpoint before the function is entered,
             and after the function is exited. See BREAK.

 LISP_PRINT  Display arguments and return values as Lisp objects.

 INFO        Print "-> TRUE" at function entry and exit.

 ERRORCATCH  Catch errors, giving the option to signal an error,
             retry the function call, or specify a return value.
@end example

Trace options are specified in two forms. The presence of the option 
keyword alone puts the option into effect unconditionally.
(Note that option FOO is not put into effect by specifying 
FOO:TRUE or a similar form; note also that keywords need not
be quoted.) Specifying the option keyword with a predicate
function makes the option conditional on the predicate.

The argument list to the predicate function is always 
[LEVEL, DIRECTION, FUNCTION, ITEM] where LEVEL is the recursion level
for the function,  DIRECTION is either ENTER or EXIT, FUNCTION is the
name of the function, and ITEM is the argument list (on entering)
or the return value (on exiting).

Here is an example of unconditional trace options:

@example
(%i1) ff(n) := IF EQUAL(n, 0) THEN 1 ELSE n * ff(n - 1)$

(%i2) TRACE (ff)$

(%i3) TRACE_OPTIONS (ff, LISP_PRINT, BREAK)$

(%i4) ff(3);
@end example

Here is the same function, with the BREAK option conditional
on a predicate:

@example
(%i5) TRACE_OPTIONS (ff, BREAK(pp))$

(%i6) pp (LEVEL, DIRECTION, FUNCTION, ITEM) := BLOCK (PRINT (ITEM),
    RETURN (FUNCTION = 'ff AND LEVEL = 3 AND DIRECTION = EXIT))$

(%i7) ff(6);
@end example

@end defun
@c @node UNTRACE
@c @unnumberedsec phony
@defun UNTRACE (F1, F2, F3, ...)
@defunx UNTRACE ()
Given functions F1, F2, F3, ...,
UNTRACE disables tracing enabled by the TRACE function.
With no arguments, UNTRACE disables tracing for all functions.

UNTRACE returns a list of the functions for which 
it disabled tracing.

@end defun
