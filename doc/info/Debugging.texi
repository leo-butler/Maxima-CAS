@c end concepts Debugging
@menu
* Source Level Debugging::
* Keyword Commands::
* Definitions for Debugging::   
@end menu

@node Source Level Debugging, Keyword Commands, , Debugging
@section Source Level Debugging

Maxima has source level capabilities.  A user can set a breakpoint at
a line in a file, and then step line by line from there.  The call
stack may be examined, together with the variables bound at that
level.  If the user is running the code under GNU emacs in a shell
window (dbl shell), or is running @code{xmaxima} the graphical
interface version, then if he stops at a break point, he will see his
current position in the source file which will be displayed in the
other half of the window, either highlighted in red, or with a little
arrow pointing at the right line.  He can advance single lines at a
time by typing M-n (Alt-n) or alternately by entering @code{:n}.  To
see the names of the keyword commands type :help (or :h).  In general
commands may be abbreviated if the abbreviation is unique.  If not
unique the alternatives will be listed.

Under Emacs you should run in a @code{dbl} shell, which requires the
dbl.el file in the elisp directory.
Make sure you install the elisp files or add the maxima elisp directory to
your path:
eg add the following to your @file{.emacs} file or the @code{site-init.el}

@example
(setq load-path (cons "/usr/local/maxima-5.5/elisp" load-path))
(autoload 'dbl "dbl")
@end example
then in emacs 
@example
M-x dbl
@end example
should start a shell window in which you can run programs, for example
maxima, gcl, gdb etc.   This shell window also knows about source level
debugging, and display of source code in the other window.  

@example
maxima
Maxima 5.5 Wed Apr 18 19:02:00 CDT 2001 (with enhancements by W. Schelter).
Licensed under the GNU Public License (see file COPYING)
(%i1) batchload("/tmp/joe.mac");
(%o1) 				 /tmp/joe.mac
(%i2) :br joe
Turning on debugging debugmode(true)
Bkpt 0 for joe (in /tmp/joe.mac line 8) 
(%i2) foo(2,3);
Bkpt 0:(joe.mac 8)
(dbm:1) :bt                        <-- :bt typed here gives a backtrace 
#0: joe(y=5)(joe.mac line 8)
#1: foo(x=2,y=3)(joe.mac line 5)
(joe.mac 9)                        <-- Here type M-n to advance line 
(joe.mac 10)                       <-- Here type M-n to advance line
                                   In the other buffer the source code
                                   appears with an arrow.
(dbm:1) u;                         Investigate value of 'u
28
(dbm:1) u:33;                      Alter it to be 33
(dbm:1) :r                         :r Resumes the computation
(%o3) 				     1094
@end example

The actual file /tmp/joe.mac is the following:
@example

foo(x,y):=(
  x:x+2,
  y:y+2,
  x:joe(y),
  x+y);
    
joe(y):=block([u:y^2],
  u:u+3,
  u:u^2,
   u);
     
@end example



If you are running in Gnu Emacs then if you are looking at the
file joe.mac, you may set a break point at a certain line of that
file by typing @code{C-x space}.  This figures out which function
your cursor is in, and then it sees which line of that function
you are on.   If you are on say line 2 of joe, then it will
insert in the other window @code{:br joe 2} the command to
break joe at its second line.   To have this enabled you must have
maxima-mode.el on in the window in which the file joe.mac is visiting.
There are additional commands available in that file window, such as
evaluating the function into the maxima, by typing @code{Alt-Control-x}

@node Keyword Commands, Definitions for Debugging, Source Level Debugging, Debugging
@section Keyword Commands

Break commands start with ':'.   Thus to evaluate a lisp form you
may type @code{:lisp } followed by the argument which is the form
to be evaluated.  
@example
(%i3) :lisp (+ 2 3) 
5
@end example
The number of arguments taken depends on the particular command.  Also
you need not type the whole command, just enough to be unique among
the keyword commands.   Thus @code{:br} would suffice for @code{:break}.
The current commands are:

@table @code
@item :break
Set a breakpoint in the specified FUNCTION at the
specified LINE offset from the beginning of the function.
If FUNCTION is given as a string, then it is presumed to be
a FILE and LINE is the offset from the beginning of the file.
@item :bt
Undocumented
@item :continue
Continue the computation.
@item :delete
Delete all breakpoints, or if arguments are supplied delete the specified
breakpoints
@item :disable
Disable the specified breakpoints, or all if none are specified
@item :enable
Enable the specified breakpoints, or all if none are specified
@item :frame
With an argument print the selected stack frame.
Otherwise the current frame.
@item :help
Print help on a break command or with no arguments on all break commands
@item :info
Undocumented
@item :lisp
Evaluate the lisp form following on the line
@item :lisp-quiet
Evaluate its arg as a lisp form without printing a prompt.
@item :next     Like :step, except that subroutine calls are stepped over
@item :quit
Quit this level
@item :resume
Continue the computation.
@item :step
Step program until it reaches a new source line
@item :top
Throw to top level
@end table 


@node Definitions for Debugging, , Keyword Commands, Debugging
@section Definitions for Debugging
@c @node REFCHECK
@c @unnumberedsec phony
@defvar REFCHECK
 default: [FALSE] - if TRUE causes a message to be printed
each time a bound variable is used for the first time in a
computation.

@end defvar
@c @node REMTRACE
@c @unnumberedsec phony
@defun REMTRACE ()
This function is no longer used with the new TRACE
package.

@end defun
@c @node SETCHECK
@c @unnumberedsec phony
@defvar SETCHECK
 default: [FALSE] - if set to a list of variables (which can
be subscripted) will cause a printout whenever the variables, or
subscripted occurrences of them, are bound (with : or :: or function
argument binding).  The printout consists of the variable and the
value it is bound to.  SETCHECK may be set to ALL or TRUE thereby
including all variables.  Note: No printout is generated when a
SETCHECKed variable is set to itself, e.g. X:'X.

@end defvar
@c @node SETCHECKBREAK
@c @unnumberedsec phony
@defvar SETCHECKBREAK
 default: [FALSE] - if set to TRUE will cause a
(MACSYMA-BREAK) to occur whenever the variables on the SETCHECK list
are bound.  The break occurs before the binding is done.  At this
point, SETVAL holds the value to which the variable is about to be
set.  Hence, one may change this value by resetting SETVAL.

@end defvar
@c @node SETVAL
@c @unnumberedsec phony
@defvar SETVAL
 - holds the value to which a variable is about to be set when
a SETCHECKBREAK occurs.  Hence, one may change this value by resetting
SETVAL.  (See SETCHECKBREAK).

@end defvar
@c @node TIMER
@c @unnumberedsec phony
@defun TIMER (F)
will put a timer-wrapper on the function F, within the TRACE
package, i.e. it will print out the time spent in computing F.

@end defun
@c @node TIMER_DEVALUE
@c @unnumberedsec phony
@defvar TIMER_DEVALUE
 default: [FALSE] - when set to TRUE then the time
charged against a function is the time spent dynamically inside the
function devalued by the time spent inside other TIMED functions.

@end defvar
@c @node TIMER_INFO
@c @unnumberedsec phony
@defun TIMER_INFO (F)
will print the information on timing which is stored
also as GET('F,'CALLS); GET('F,'RUNTIME); and GET('F,'GCTIME); .  This
is a TRACE package function.

@end defun
@c @node TRACE
@c @unnumberedsec phony
@defun TRACE (name1, name2, ...)
gives a trace printout whenever the
functions mentioned are called.  TRACE() prints a list of the
functions currently under TRACE.  On MC see MACDOC;TRACE USAGE for
more information.  Also, DEMO("trace.dem"); .  To remove tracing,
see UNTRACE.

@end defun
@c @node TRACE_OPTIONS
@c @unnumberedsec phony
@defun TRACE_OPTIONS (F,option1,option2,...)
gives the function F the
options indicated.  An option is either a keyword or an expression.
The possible Keywords are:
 Keyword     Meaning of return value
----------------------------------------
 NOPRINT     If TRUE do no printing. 
 BREAK       If TRUE give a breakpoint.
 LISP_PRINT  If TRUE use lisp printing.
 INFO        Extra info to print.
 ERRORCATCH  If TRUE errors are caught.
A keyword means that the option is in effect.  Using a keyword as an
expression, e.g. NOPRINT(predicate_function) means to apply the
predicate_function (which is user-defined) to some arguments to
determine if the option is in effect. The argument list to this
predicate_function is always [LEVEL, DIRECTION, FUNCTION, ITEM] where
LEVEL is the recursion level for the function.  DIRECTION is either
ENTER or EXIT.  FUNCTION is the name of the function.  ITEM is either
the argument list or the return value.  On MC see
DEMO("trace.dem"); for more details.

@end defun
@c @node UNTRACE
@c @unnumberedsec phony
@defun UNTRACE (name1, ...)
removes tracing invoked by the TRACE function.
UNTRACE() removes tracing from all functions.

@end defun
