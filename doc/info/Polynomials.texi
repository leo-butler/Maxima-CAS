@menu
* Introduction to Polynomials::  
* Definitions for Polynomials::  
@end menu

@node Introduction to Polynomials, Definitions for Polynomials, Polynomials, Polynomials
@section Introduction to Polynomials

Polynomials are stored in Maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC is set to @code{true}).  In this CRE form an
ordering of variables (from most to least main) is assumed for each
expression.  Polynomials are represented recursively by a list
consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number or
a polynomial in another variable again represented in this form.  Thus
the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that
of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main
variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.  The "variables" of a CRE expression needn't be atomic.  In fact
any subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form) in
which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
Maxima will choose an alphabetic one.  In general, CRE's represent
rational expressions, that is, ratios of polynomials, where the
numerator and denominator have no common factors, and the denominator is
positive.  The internal form is essentially a pair of polynomials (the
numerator and denominator) preceded by the variable ordering list.  If
an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form.  An
extended CRE form is used for the representation of Taylor series.  The
notion of a rational expression is extended so that the exponents of the
variables can be positive or negative rational numbers rather than just
positive integers and the coefficients can themselves be rational
expressions as described above rather than just polynomials.  These are
represented internally by a recursive polynomial form which is similar
to and is a generalization of CRE form, but carries additional
information such as the degree of truncation.  As with CRE form, the
symbol /T/ follows the line label of such expressions.

@c end concepts Polynomials
@node Definitions for Polynomials,  , Introduction to Polynomials, Polynomials
@section Definitions for Polynomials

@defvar algebraic
Default value: @code{false}

@code{algebraic} must be set to @code{true} in order for the
simplification of algebraic integers to take effect.

@end defvar

@defvar berlefact
Default value: @code{true}

When @code{berlefact} is @code{false} then the Kronecker factoring
algorithm will be used otherwise the Berlekamp algorithm, which is the
default, will be used.

@end defvar

@c WHAT IS THIS ABOUT EXACTLY ??
@defun bezout (p1, p2, var)
an alternative to the @code{resultant} command.  It
returns a matrix. @code{determinant} of this matrix is the desired resultant.

@end defun

@defun bothcoef (exp, var)
returns a list whose first member is the
coefficient of var in exp (as found by @code{ratcoef} if exp is in CRE form
otherwise by @code{coeff}) and whose second member is the remaining part of
exp.  That is, [A,B] where exp=A*var+B.

@example
(%i1) islinear(exp,var):=block([c],
        c:bothcoef(rat(exp,var),var),
        is(freeof(var,c) and c[1]#0))$
(%i2) islinear((r**2-(x-r)**2)/x,x);
(%o2)                              true
@end example

@end defun

@defun coeff (exp, v, n)
obtains the coefficient of v**n in exp.  n may be
omitted if it is 1.  v may be an atom, or complete subexpression of
exp e.g., X, SIN(X), A[I+1], X+Y, etc. (In the last case the
expression (X+Y) should occur in exp).  Sometimes it may be necessary
to expand or factor exp in order to make v^n explicit.  This is not
done automatically by @code{coeff}.

@example
(%i1) coeff(2*a*tan(x)+tan(x)+b=5*tan(x)+3,tan(x));
(%o1)                         2 a + 1 = 5
(%i2) coeff(y+x*%e**x+1,x,0);
(%o2)                            y + 1
@end example

@end defun

@defun combine (exp)
simplifies the sum exp by combining terms with the same
denominator into a single term.

@end defun

@defun content (p1, var1, ..., varn)
returns a list whose first element is
the greatest common divisor of the coefficients of the terms of the
polynomial p1 in the variable varn (this is the content) and whose
second element is the polynomial p1 divided by the content.

@example
(%i1) content(2*x*y+4*x**2*y**2,y);
(%o1)            [2*x, 2*x*y**2+y].
@end example

@end defun

@defun denom (exp)
returns the denominator of the rational expression exp.

@end defun

@defun divide (p1, p2, var1, ..., varn)
computes the quotient and remainder
of the polynomial p1 divided by the polynomial p2, in a main
polynomial variable, varn.  The other variables are as in the @code{ratvars}
function.  The result is a list whose first element is the quotient
and whose second element is the remainder.

@example
(%i1) divide(x+y,x-y,x);
(%o1)                        [1, 2 y]
(%i2) divide(x+y,x-y);
(%o2)                      [ - 1, 2 x]
@end example

@noindent
(Note that Y is the main variable in %i2)

@end defun

@defun eliminate ([eq1,eq2,...,eqn],[v1,v2,...,vk])
eliminates variables from
equations (or expressions assumed equal to zero) by taking successive
resultants. This returns a list of n-k expressions with the k
variables v1,...,vk eliminated.  First v1 is eliminated yielding n-1
expressions, then v2 is, etc.  If k=n then a single expression in a
list is returned free of the variables v1,...,vk.  In this case @code{solve}
is called to solve the last resultant for the last variable.

Example:

@example
(%i1) exp1:2*x^2+y*x+z;
                                    2
(%o1)                   z + x y + 2 x
(%i2) exp2:3*x+5*y-z-1;
(%o2)                - z + 5 y + 3 x - 1
(%i3) exp3:z^2+x-y^2+5;
                       2    2
(%o3)                  z  - y  + x + 5
(%i4) eliminate([exp3,exp2,exp1],[y,z]);
            8         7         6          5          4
(%o3) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x
                               3         2
                       - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end defun

@defun ezgcd (p1, p2, ...)
gives a list whose first element is the g.c.d of
the polynomials p1,p2,...  and whose remaining elements are the
polynomials divided by the g.c.d.  This always uses the @code{ezgcd}
algorithm.

@end defun

@defvar facexpand
Default value: @code{true}

@code{facexpand} controls whether the irreducible factors
returned by @code{factor} are in expanded (the default) or recursive (normal
CRE) form.

@end defvar

@defun factcomb (exp)
tries to combine the coefficients of factorials in exp
with the factorials themselves by converting, for example, (N+1)*N!
into (N+1)!.

@code{sumsplitfact} if set to @code{false} will cause @code{minfactorial} to be
applied after a @code{factcomb}.

@example
(%i1) (n+1)^b*n!^b;
                                      b   b
(%o1)                           (n + 1)  n!
(%i2) factcomb(%);
@end example

@end defun

@defun factor (exp)
factors the expression exp, containing any number of
variables or functions, into factors irreducible over the integers.
@code{factor (exp, p)} factors exp over the field of integers with an element
adjoined whose minimum polynomial is p.

@code{factorflag} if @code{false} suppresses the factoring of integer factors
of rational expressions.

@code{dontfactor} may be set to a list of variables with respect to which
factoring is not to occur.  (It is initially empty).  Factoring also
will not take place with respect to any variables which are less
important (using the variable ordering assumed for CRE form) than
those on the @code{dontfactor} list.

@code{savefactors} if @code{true} causes the factors of an expression which
is a product of factors to be saved by certain functions in order to
speed up later factorizations of expressions containing some of the
same factors.

@code{berlefact} if @code{false} then the Kronecker factoring algorithm will
be used otherwise the Berlekamp algorithm, which is the default, will
be used.

@code{intfaclim} is the largest divisor which will be tried when
factoring a bignum integer.  If set to @code{false} (this is the case when
the user calls @code{factor} explicitly), or if the integer is a fixnum (i.e.
fits in one machine word), complete factorization of the integer will
be attempted.  The user's setting of @code{intfaclim} is used for internal
calls to @code{factor}. Thus, @code{intfaclim} may be reset to prevent Maxima from
taking an inordinately long time factoring large integers.
@code{newfac} may be set to true to use the new factoring routines.

Examples:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end defun

@defvar factorflag
Default value: @code{false}

@code{factorflag} if @code{false} suppresses the factoring of
integer factors of rational expressions.

@end defvar

@defun factorout (exp,var1,var2,...)
rearranges the sum exp into a sum of
terms of the form f(var1,var2,...)*g where g is a product of
expressions not containing the vari's and f is factored.

@end defun

@defun factorsum (exp)
tries to group terms in factors of exp which are sums
into groups of terms such that their sum is factorable.  It can
recover the result of @code{expand ((x + y)^2 + (z + w)^2)} but it can't recover
@code{expand ((x + 1)^2 + (x + y)^2)} because the terms have variables in common.

@example
(%i1) (x+1)*((u+v)^2+a*(w+z)^2),expand;
      2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x
                     2        2    2            2
        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum(%);
                                   2          2
(%o2)                 (x + 1) (a (z + w)  + (v + u) )
@end example

@end defun

@defun fasttimes (p1, p2)
multiplies the polynomials p1 and p2 by using a
special algorithm for multiplication of polynomials.  They should be
multivariate, dense, and nearly the same size.  Classical
multiplication is of order N*M where N and M are the degrees.
@code{fasttimes} is of order MAX(N,M)**1.585.

@end defun

@defun fullratsimp (exp)
When non-rational expressions are involved, one call
to @code{ratsimp} followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.  The command
@code{fullratsimp} makes this process convenient.  @code{fullratsimp} repeatedly
applies @code{ratsimp} followed by non-rational simplification to an
expression until no further change occurs.

For the expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .
FULLRATSIMP(EXP); gives   X^A-1 .  The problem may be seen by looking at 
RAT(EXP); which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
FULLRATSIMP(exp,var1,...,varn) takes one or more arguments similar 
to RATSIMP and RAT.

@end defun

@defun fullratsubst (a,b,c)
is the same as @code{ratsubst} except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.

@code{fullratsubst} will also accept its arguments in the format of
@code{lratsubst}.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.

There is a demo available by
DEMO("lrats.dem"); .

@end defun

@c GCD IS A VARIABLE AND A FUNCTION
@defun gcd (p1, p2, var1, ...)
computes the greatest common divisor of p1 and
p2.  The flag @code{gcd} determines which algorithm is employed.
Setting @code{gcd} to @code{ez}, @code{eez}, @code{subres}, @code{red}, or @code{spmod} selects the @code{ezgcd}, New
@code{eez} @code{gcd}, subresultant @code{prs}, reduced, or modular algorithm,
respectively.  If @code{gcd} @code{false} then GCD(p1,p2,var) will always return 1
for all var.  Many functions (e.g.  @code{ratsimp}, @code{factor}, etc.) cause gcd's
to be taken implicitly.  For homogeneous polynomials it is recommended
that @code{gcd} equal to @code{subres} be used.  To take the gcd when an algebraic is
present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , @code{algebraic} must be
@code{true} and @code{gcd} must not be @code{ez}.  @code{subres} is a new algorithm, and people
who have been using the @code{red} setting should probably change it to
@code{subres}.

The @code{gcd} flag, default: @code{subres}, if @code{false} will also prevent the greatest
common divisor from being taken when expressions are converted to CRE
form.  This will sometimes speed the calculation if gcds are not
required.

@end defun

@defun gcdex (f,g)
@defunx gcdex (f,g,var)
returns a list containing [a,b,u] where u is the gcd of f and g,
and u = a*f + b*g.   The arguments f and g should b univariate polynomials,
or else polynomials in VAR a supplied @b{main} variable   
since we need to be in a principal ideal domain for this to work.   The
gcd means the gcd regarding f and g as univariate polynomials with coefficients
being rational functions in the other variables.

The
algorithm is simply the euclidean algorithm, where we have a sequence
of @code{lis[i]:[a[i],b[i],r[i]] ..} which are all perpendicular
to @code{[f,g,-1]} and the next one is built as
if @code{q = quotient(r[i]/r[i+1])} then @code{lis[i+2]:lis[i]-q*lis[i+1]}, and it
terminates at @code{lis[i+1]} when the remainder @code{r[i+2]} is zero.

@example
(%i1) gcdex(x^2+1,x^3+4);

                              2
                             x  + 4 x - 1  x + 4
(%o1)/R/                   [- ------------, -----, 1]
                                  17        17

(%i2) %o1.[x^2+1,x^3+4,-1];
(%o2)                                   0
@end example

Note that the gcd in the following is @code{1}
since we work in @code{k(y)[x]}, not the  @code{y+1} we would expect in @code{k[y,x] }

@example
(%i4) gcdex(x*(y+1),y^2-1,x);

                                      1
(%o4)                            [0, ------, 1]
                                     2
                                    y  - 1
@end example

@end defun


@defun gcfactor (n)
factors the gaussian integer n over the gaussians, i.e.
numbers of the form a + b i where a and b are rational integers (i.e.
ordinary integers).  Factors are normalized by making a and b
non-negative.

@end defun

@defun gfactor (exp)
factors the polynomial exp over the Gaussian integers
(that is, the integers with the imaginary unit @code{%i} adjoined).  This is like
FACTOR(exp,A**2+1) where A is %I.

@example
(%i1)  gfactor(x**4-1);
(%o1)        (x - 1) (x + 1) (x + %i) (x - %i)
@end example

@end defun

@defun gfactorsum (exp)
is similar to @code{factorsum} but applies @code{gfactor} instead
of @code{factor}.

@end defun

@defun hipow (exp, v)
the highest explicit exponent of v in exp.  Sometimes
it may be necessary to expand exp since this is not done automatically
by @code{hipow}.  Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.

@end defun

@defvar intfaclim
Default value: 1000

@code{intfaclim} is the largest divisor which will be tried
when factoring a bignum integer.  If set to @code{false} (this is the case
when the user calls @code{factor} explicitly), or if the integer is a fixnum
(i.e. fits in one machine word), complete factorization of the integer
will be attempted.  The user's setting of @code{intfaclim} is used for
internal calls to @code{factor}. Thus, @code{intfaclim} may be reset to prevent
Maxima from taking an inordinately long time factoring large
integers.

@end defvar

@defvar keepfloat
Default value: @code{false}

When @code{keepfloat} is @code{true}, prevents floating
point numbers from being rationalized when expressions which contain
them are converted to CRE form.

@end defvar

@defun lratsubst (list,exp)
is analogous to SUBST(list_of_equations,exp)
except that it uses @code{ratsubst} instead of @code{subst}.  The first argument of
@code{lratsubst} must be an equation or a list of equations identical in
format to that accepted by @code{subst}.  The
substitutions are made in the order given by the list of equations,
that is, from left to right.

A demo is available by doing
DEMO("lrats.dem"); .

@end defun

@defvar modulus
Default value: @code{false}

When @code{modulus} is a positive prime p, then all
arithmetic in the rational function routines will be done modulo p.
That is all integers will be reduced to less than p/2 in absolute
value (if p=2 then all integers are reduced to 1 or 0).  This is the
so called "balanced" modulus system, e.g. N MOD 5 = -2, -1, 0, 1, or
2.  Warning: If EXP is already in CRE form when you reset @code{modulus},
then you may need to re-rat EXP, e.g. EXP:RAT(RATDISREP(EXP)), in
order to get correct results. (If @code{modulus} is set to a positive
non-prime integer, this setting will be accepted, but a warning will
be given.)

@end defvar

@c STILL APPLICABLE ??
@defvar newfac
Default value: @code{false}

When @code{newfac} is @code{true}, @code{factor} will use the new factoring
routines.

@end defvar

@defun num (exp)
obtains the numerator, exp1, of the rational expression
exp = exp1/exp2.

@end defun

@defun quotient (p1, p2, var1, ...)
computes the quotient of the polynomial
p1 divided by the polynomial p2.

@end defun

@defun rat (exp, v1, ..., vn)
converts exp to CRE form by expanding and
combining all terms over a common denominator and cancelling out the
greatest common divisor of the numerator and denominator as well as
converting floating point numbers to rational numbers within a
tolerance of @code{ratepsilon}.  The variables are ordered according
to the v1,...,vn as in @code{ratvars}, if these are specified.  @code{rat} does not
generally simplify functions other than + , - , * , / , and
exponentiation to an integer power whereas @code{ratsimp} does handle these
cases.  Note that atoms (numbers and names) in CRE form are not the
same as they are in the general form.  Thus RAT(X)- X results in
RAT(0) which has a different internal representation than 0.

@code{ratfac} when @code{true} invokes a partially factored form for CRE
rational expressions.  During rational operations the expression is
maintained as fully factored as possible without an actual call to the
factor package.  This should always save space and may save some time
in some computations.  The numerator and denominator are still made
relatively prime (e.g.  RAT((X^2 -1)^4/(X+1)^2); yields
(X-1)^4*(X+1)^2), but the factors within each part may not be
relatively prime.

@code{ratprint} if @code{false} suppresses the printout of the message
informing the user of the conversion of floating point numbers to
rational numbers.

@code{keepfloat} if @code{true} prevents floating point numbers from being
converted to rational numbers.

(Also see the @code{ratexpand} and  @code{ratsimp} functions.)

@example
(%i1) ((x-2*y)**4/(x**2-4*y**2)**2+1)*(y+a)*(2*y+x)
        /(4*y**2+x**2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)          ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat(%,y,a,x);
                            2 a + 2 y
(%o2)/r/                     ---------
                             x + 2 y
@end example

@end defun

@defvar ratalgdenom
Default value: @code{true}

When @code{ratalgdenom} is @code{true}, allows rationalization of
denominators wrt.  radicals to take effect.  To do this one must use
CRE form in algebraic mode.

@end defvar

@defun ratcoef (exp, v, n)
returns the coefficient, C, of the expression v**n
in the expression exp.  n may be omitted if it is 1.  C will be free
(except possibly in a non-rational sense) of the variables in v.  If
no coefficient of this type exists, zero will be returned.  @code{ratcoef}
expands and rationally simplifies its first argument and thus it may
produce answers different from those of @code{coeff} which is purely
syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas @code{coeff}
returns 1.  RATCOEF(exp,v,0), viewing exp as a sum, gives a sum of
those terms which do not contain v.  Therefore if v occurs to any
negative powers, @code{ratcoef} should not be used.  Since exp is rationally
simplified before it is examined, coefficients may not appear quite
the way they were envisioned.

@example
(%i1) s:a*x+b*x+5$
(%i2) ratcoef(s,a+b);
(%o2)               x
@end example

@end defun

@defun ratdenom (exp)
obtains the denominator of the rational expression exp.
If exp is in general form then the @code{denom} function should be used
instead, unless one wishes to get a CRE result.

@end defun

@defvar ratdenomdivide
Default value: @code{true}

When @code{ratdenomdivide} is @code{false}, stops the splitting up
of the terms of the numerator of @code{ratexpand}'ed expressions from
occurring.

@end defvar

@defun ratdiff (exp, var)
differentiates the rational expression exp (which
must be a ratio of polynomials or a polynomial in the variable var)
with respect to var.  For rational expressions this is much faster
than @code{diff}.  The result is left in CRE form.  However, @code{ratdiff} should
not be used on factored CRE forms; use @code{diff} instead for such
expressions.

@example
(%i1) (4*x**3+10*x-11)/(x**5+5);
                                         3
                                      4 x  + 10 x - 11
(%o1)                                  ----------------
                                            5
                                           x  
(%i2) modulus:3$
(%i3) mod(%o1);
                                2
                               x  + x - 1
(%o3)                      --------------------
                           4    3    2
                          x  + x  + x  + x + 1
(%i4) ratdiff(%o1,x);
                          5    4    3
                         x  - x  - x  + x - 1
(%o4)                ------------------------------
                     8    7    5    4    3
                    x  - x  + x  - x  + x  - x + 1
@end example

@end defun

@defun ratdisrep (exp)
changes its argument from CRE form to general form.
This is sometimes convenient if one wishes to stop the "contagion", or
use rational functions in non-rational contexts.  Most CRE functions
will work on either CRE or non-CRE expressions, but the answers may
take different forms.  If @code{ratdisrep} is given a non-CRE for an
argument, it returns its argument unchanged.  See also @code{totaldisrep}.

@end defun

@defvar ratepsilon
Default value: 2.0e-8

@code{ratepsilon} is the tolerance used in the conversion
of floating point numbers to rational numbers.

@end defvar

@c ratexpand IS ALSO A VARIABLE -- MAKE SURE THAT IS CLEAR
@defun ratexpand (exp)
expands exp by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
cancelling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by
converting exp to CRE form and then back to general form.

The switch @code{ratexpand} if @code{true} will cause CRE
expressions to be fully expanded when they are converted back to
general form or displayed, while if it is @code{false} then they will be put
into a recursive form. (see @code{ratsimp})

@code{ratdenomdivide} - if @code{false} will stop the splitting up of the
terms of the numerator of @code{ratexpand}'ed expressions from occurring.

@code{keepfloat} if set to @code{true} will prevent floating point numbers
from being rationalized when expressions which contain them are
converted to CRE form.

@example
(%i1) ratexpand((2*x-3*y)**3);
                3         2       2        3
(%o1)      - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) (x-1)/(x+1)**2+1/(x-1);
                              x - 1       1
(%o2)                         -------- + -----
                                    2   x - 1
                             (x + 1)
(%i3) expand(%o2);
                         x              1           1
(%o3)                ------------ - ------------ + -----
                     2              2             x - 1
                    x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand(%o2);
                             2
                          2 x                 2
(%o4)                 --------------- + ---------------
                      3    2            3    2
                     x  + x  - x - 1   x  + x  - x - 1
@end example

@end defun

@defvar ratfac
Default value: @code{false}

When @code{ratfac} is @code{true} invokes a partially factored form
for CRE rational expressions.  During rational operations the
expression is maintained as fully factored as possible without an
actual call to the factor package.  This should always save space and
may save some time in some computations.  The numerator and
denominator are still made relatively prime, for example
RAT((X^2 -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2),
but the factors within each part may not be relatively prime.
In the @code{ctensr} (Component Tensor Manipulation) Package, if @code{ratfac} is
@code{true}, it causes the Ricci, Einstein, Riemann, and Weyl tensors and the
Scalar Curvature to be factored automatically.  @i{This should only be
set for cases where the tensorial components are known to consist of
few terms.}

Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

@end defvar

@defun ratnumer (exp)
obtains the numerator of the rational expression exp.
If exp is in general form then the @code{num} function should be used
instead, unless one wishes to get a CRE result.

@end defun

@defun ratnump (exp)
is @code{true} if exp is a rational number (includes integers)
else @code{false}.

@end defun

@defun ratp (exp)
is @code{true} if exp is in CRE or extended CRE form else @code{false}.

@end defun

@defvar ratprint
Default value: @code{true}

When @code{ratprint} is @code{false}, suppresses the printout of the
message informing the user of the conversion of floating point numbers
to rational numbers.

@end defvar

@defun ratsimp (exp)
rationally simplifies (similar to @code{ratexpand}) the
expression exp and all of its subexpressions including the arguments
to non- rational functions.  The result is returned as the quotient of
two polynomials in a recursive form, i.e.  the coefficients of the
main variable are polynomials in the other variables.  Variables may,
as in @code{ratexpand}, include non-rational functions (e.g. SIN(X**2+1) )
but with @code{ratsimp}, the arguments to non-rational functions are
rationally simplified.  Note that @code{ratsimp} is affected by some of the
variables which affect @code{ratexpand}.

RATSIMP(exp,v1,v2,...,vn) - enables rational simplification with the
specification of variable ordering as in @code{ratvars}.

@code{ratsimpexpons} - if @code{true} will cause exponents of expressions to
be @code{ratsimp}'ed automatically during simplification.

@example
(%i1) sin(x/(x^2+x))=%e^((log(x)+1)**2-log(x)**2);
                                           2          2
                    x          (log(x) + 1)  - log (x)
(%o1)          sin(------) = %e
                   2
                  x  + x
(%i2) ratsimp(%);
                                  1          2
(%o2)                        sin(-----) = %e x
                                x + 1
(%i3) ((x-1)**(3/2)-(x+1)*sqrt(x-1))/sqrt((x-1)*(x+1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)            --------------------------------
                    sqrt(x - 1) sqrt(x + 1)
(%i4) ratsimp(%);
                                 2
(%o4)                      - -----------
                            sqrt(x + 1)
(%i5)  x**(a+1/a),ratsimpexpons:true;
                    2
                   a  + 1
                   ------
                     a
(%o5)              x
@end example

@end defun

@defvar ratsimpexpons
Default value: @code{false}

When @code{ratsimpexpons} is @code{true}, causes exponents of
expressions to be @code{ratsimp}'ed automatically during simplification.

@end defvar

@defun ratsubst (a, b, c)
substitutes a for b in c.  b may be a sum, product,
power, etc.  @code{ratsubst} knows something of the meaning of expressions
whereas @code{subst} does a purely syntactic substitution.  Thus
SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas @code{ratsubst} would return Z+A.
@code{radsubstflag} if @code{true} permits @code{ratsubst} to make substitutions
like U for SQRT(X) in X.

Examples:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
@end example

@end defun

@defun ratvars (var1, var2, ..., varn)
forms its n arguments into a list in
which the rightmost variable varn will be the main variable of future
rational expressions in which it occurs, and the other variables will
follow in sequence.  If a variable is missing from the @code{ratvars} list,
it will be given lower priority than the leftmost variable var1. The
arguments to @code{ratvars} can be either variables or non-rational functions
(e.g. SIN(X)).  The variable @code{ratvars} is a list of the arguments which
have been given to this function.

@end defun

@defun ratweight (v1, w1, ..., vn, wn)
assigns a weight of wi to the variable
vi.  This causes a term to be replaced by 0 if its weight exceeds the
value of the variable @code{ratwtlvl} (default is no truncation).
The weight of a term is the sum of the products of the
weight of a variable in the term times its power.  Thus the weight of
3*v1**2*v2 is 2*w1+w2.  This truncation occurs only when multiplying
or exponentiating CRE forms of expressions.

@example
(%i5) ratweight(a,1,b,1);
(%o5)                         [[b, 1], [a, 1]]
(%i6) exp1:rat(a+b+1)$
(%i7) %**2;
                      2                  2
(%o7)/r/              b  + (2 a + 2) b + a  + 2 a + 1
(%i8) ratwtlvl:1$
(%i9) exp1**2;
(%o9)/r/                       2 b + 2 a + 1
@end example

Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

@end defun

@defvar ratweights
@c DEFAULT VALUE ??

@code{ratweights} is a list of weight assignments (set up by the @code{ratweight}
function), @code{ratweights;} or @code{ratweight();} will show you the list.

@example
kill(...,ratweights)
@end example
and
@example
save(...,ratweights);
@end example
both work.

@end defvar

@defvar ratwtlvl
Default value: @code{false}

@code{ratwtlvl} is used in combination with the @code{ratweight}
function to control the truncation of rational (CRE form) expressions
(for the default value of @code{false}, no truncation occurs).

@end defvar

@defun remainder (p1, p2, var1, ...)
computes the remainder of the polynomial
p1 divided by the polynomial p2.

@end defun

@c BOTH A VARIABLE AND A FUNCTION
@defun resultant (p1, p2, var)
computes the resultant of the two polynomials
p1 and p2, eliminating the variable var.  The resultant is a
determinant of the coefficients of var in p1 and p2 which equals zero
if and only if p1 and p2 have a non-constant factor in common.  If p1
or p2 can be factored, it may be desirable to call @code{factor} before
calling @code{resultant}.

@code{resultant} - controls which algorithm will be used to compute
the resultant.  @code{subres} for subresultant prs [the default], @code{mod} for
modular resultant algorithm, and @code{red} for reduced prs.  On most
problems @code{subres} should be best.  On some large degree univariate or
bivariate problems @code{mod} may be better.  Another alternative is the
@code{bezout} command which takes the same arguments as @code{resultant} and returns
a matrix.  @code{determinant} of this matrix is the desired resultant.

@end defun

@defvar savefactors
Default value: @code{false}

When @code{savefactors} is @code{true}, causes the factors of an
expression which is a product of factors to be saved by certain
functions in order to speed up later factorizations of expressions
containing some of the same factors.

@end defvar

@defun sqfr (exp)
is similar to @code{factor} except that the polynomial factors are
"square-free." That is, they have factors only of degree one.  This
algorithm, which is also used by the first stage of @code{factor}, utilizes
the fact that a polynomial has in common with its nth derivative all
its factors of degree > n.  Thus by taking gcds with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.

@example
(%i1) sqfr(4*x**4+4*x**3-3*x**2-4*x-1);
                             2               2
(%o1)                       (x  - 1) (2 x + 1)
@end example

@end defun

@defun tellrat (poly)
adds to the ring of algebraic integers known to
Maxima, the element which is the solution of the polynomial with
integer coefficients.  Maxima initially knows about %I and all roots
of integers. TELLRAT(X); means substitute 0 for X in rational
functions.  There is a command @code{untellrat} which takes kernels and
removes @code{tellrat} properties.  When @code{tellrat}'ing a multivariate
polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as to
whether to substitute Y^2 for X^2 or vice versa.  The system will pick
a particular ordering, but if the user wants to specify which, e.g.
TELLRAT(Y^2=X^2); provides a syntax which says replace Y^2 by X^2.
@code{tellrat} and @code{untellrat} both can take any number of arguments, and
TELLRAT(); returns a list of the current substitutions.  Note: When
you @code{tellrat} reducible polynomials, you want to be careful not to
attempt to rationalize a denominator with a zero divisor.  E.g.
TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$ RAT(1/(W^2-W)); will give "quotient by
zero".  This error can be avoided by setting @code{ratalgdenom} to @code{false}.
@code{algebraic} must be set to @code{true} in order for the simplification of
algebraic integers to take effect.

Examples:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end defun

@defun totaldisrep (exp)
converts every subexpression of exp from CRE to
general form.  If exp is itself in CRE form then this is identical to
@code{ratdisrep} but if not then @code{ratdisrep} would return exp unchanged while
@code{totaldisrep} would "totally disrep" it.  This is useful for
ratdisrepping expressions e.g., equations, lists, matrices, etc. which
have some subexpressions in CRE form.

@end defun

@defun untellrat (x)
takes kernels and removes @code{tellrat} properties.

@end defun
