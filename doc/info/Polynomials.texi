@menu
* Introduction to Polynomials::  
* Definitions for Polynomials::  
@end menu

@node Introduction to Polynomials, Definitions for Polynomials, Polynomials, Polynomials
@section Introduction to Polynomials

Polynomials are stored in Maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC is set to @code{true}).  In this CRE form an
ordering of variables (from most to least main) is assumed for each
expression.  Polynomials are represented recursively by a list
consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number or
a polynomial in another variable again represented in this form.  Thus
the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that
of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main
variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.  The "variables" of a CRE expression needn't be atomic.  In fact
any subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form) in
which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
Maxima will choose an alphabetic one.  In general, CRE's represent
rational expressions, that is, ratios of polynomials, where the
numerator and denominator have no common factors, and the denominator is
positive.  The internal form is essentially a pair of polynomials (the
numerator and denominator) preceded by the variable ordering list.  If
an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form.  An
extended CRE form is used for the representation of Taylor series.  The
notion of a rational expression is extended so that the exponents of the
variables can be positive or negative rational numbers rather than just
positive integers and the coefficients can themselves be rational
expressions as described above rather than just polynomials.  These are
represented internally by a recursive polynomial form which is similar
to and is a generalization of CRE form, but carries additional
information such as the degree of truncation.  As with CRE form, the
symbol /T/ follows the line label of such expressions.

@c end concepts Polynomials
@node Definitions for Polynomials,  , Introduction to Polynomials, Polynomials
@section Definitions for Polynomials

@defvar algebraic
Default value: @code{false}

@code{algebraic} must be set to @code{true} in order for the
simplification of algebraic integers to take effect.

@end defvar

@defvar berlefact
Default value: @code{true}

When @code{berlefact} is @code{false} then the Kronecker factoring
algorithm will be used otherwise the Berlekamp algorithm, which is the
default, will be used.

@end defvar

@c WHAT IS THIS ABOUT EXACTLY ??
@defun bezout (@var{p1}, @var{p2}, @var{x})
an alternative to the @code{resultant} command.  It
returns a matrix. @code{determinant} of this matrix is the desired resultant.

@end defun

@c REWORD THIS ITEM -- COULD BE MORE CONCISE
@defun bothcoef (@var{expr}, @var{x})
Returns a list whose first member is the
coefficient of @var{x} in @var{expr} (as found by @code{ratcoef} if @var{expr} is in CRE form
otherwise by @code{coeff}) and whose second member is the remaining part of
@var{expr}.  That is, @code{[A, B]} where @code{@var{expr} = A*@var{x} + B}.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c islinear (expr, x) := block ([c],
@c         c: bothcoef (rat (expr, x), x),
@c         is (freeof (x, c) and c[1] # 0))$
@c islinear ((r^2 - (x - r)^2)/x, x);

@example
(%i1) islinear (expr, x) := block ([c],
        c: bothcoef (rat (expr, x), x),
        is (freeof (x, c) and c[1] # 0))$
(%i2) islinear ((r^2 - (x - r)^2)/x, x);
(%o2)                         true
@end example

@end defun

@defun coeff (@var{expr}, @var{x}, @var{n})
Returns the coefficient of @code{@var{x}^@var{n}} in @var{expr}.  @var{n} may be
omitted if it is 1.  @var{x} may be an atom, or complete subexpression of
@var{expr} e.g., @code{sin(x)}, @code{a[i+1]}, @code{x + y}, etc. (In the last case the
expression @code{(x + y)} should occur in @var{expr}).  Sometimes it may be necessary
to expand or factor @var{expr} in order to make @code{@var{x}^@var{n}} explicit.  This is not
done automatically by @code{coeff}.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
@c coeff (y + x*%e^x + 1, x, 0);

@example
(%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
(%o1)                      2 a + 1 = 5
(%i2) coeff (y + x*%e^x + 1, x, 0);
(%o2)                         y + 1
@end example

@end defun

@defun combine (@var{expr})
Simplifies the sum @var{expr} by combining terms with the same
denominator into a single term.

@c NEED EXAMPLE HERE
@end defun

@defun content (@var{p_1}, @var{x_1}, ..., @var{x_n})
Returns a list whose first element is
the greatest common divisor of the coefficients of the terms of the
polynomial @var{p_1} in the variable @var{x_n} (this is the content) and whose
second element is the polynomial @var{p_1} divided by the content.
@c APPEARS TO WORK AS ADVERTISED -- ONLY x_n HAS ANY EFFECT ON THE RESULT
@c WHAT ARE THE OTHER VARIABLES x_1 THROUGH x_{n-1} FOR ??

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c content (2*x*y + 4*x^2*y^2, y);

@example
(%i1) content (2*x*y + 4*x^2*y^2, y);
                                   2
(%o1)                   [2 x, 2 x y  + y]
@end example

@end defun

@defun denom (@var{expr})
Returns the denominator of the rational expression @var{expr}.

@end defun

@defun divide (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
computes the quotient and remainder
of the polynomial @var{p_1} divided by the polynomial @var{p_2}, in a main
polynomial variable, @var{x_n}.
@c SPELL OUT THE PURPOSE OF THE OTHER VARIABLES
The other variables are as in the @code{ratvars} function.
The result is a list whose first element is the quotient
and whose second element is the remainder.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c divide (x + y, x - y, x);
@c divide (x + y, x - y);

@example
(%i1) divide (x + y, x - y, x);
(%o1)                       [1, 2 y]
(%i2) divide (x + y, x - y);
(%o2)                      [- 1, 2 x]
@end example

@noindent
Note that @code{y} is the main variable in the second example.

@end defun

@defun eliminate ([@var{eqn_1}, ..., @var{eqn_n}], [@var{x_1}, ..., @var{x_k}])
Eliminates variables from
equations (or expressions assumed equal to zero) by taking successive
resultants. This returns a list of @code{@var{n} - @var{k}} expressions with the @var{k}
variables @var{x_1}, ..., @var{x_k} eliminated.  First @var{x_1} is eliminated yielding @code{@var{n} - 1}
expressions, then @code{x_2} is eliminated, etc.  If @code{@var{k} = @var{n}} then a single expression in a
list is returned free of the variables @var{x_1}, ..., @var{x_k}.  In this case @code{solve}
is called to solve the last resultant for the last variable.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr1: 2*x^2 + y*x + z;
@c expr2: 3*x + 5*y - z - 1;
@c expr3: z^2 + x - y^2 + 5;
@c eliminate ([expr3, expr2, expr1], [y, z]);

@example
(%i1) expr1: 2*x^2 + y*x + z;
                                      2
(%o1)                    z + x y + 2 x
(%i2) expr2: 3*x + 5*y - z - 1;
(%o2)                  - z + 5 y + 3 x - 1
(%i3) expr3: z^2 + x - y^2 + 5;
                          2    2
(%o3)                    z  - y  + x + 5
(%i4) eliminate ([expr3, expr2, expr1], [y, z]);
             8         7         6          5          4
(%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                    3         2
                            - 5154 x  - 1291 x  + 7688 x + 15376]
@end example

@end defun

@defun ezgcd (@var{p_1}, @var{p_2}, @var{p_3}, ...)
Returns a list whose first element is the g.c.d of
the polynomials @var{p_1}, @var{p_2}, @var{p_3}, ...  and whose remaining elements are the
polynomials divided by the g.c.d.  This always uses the @code{ezgcd}
algorithm.

@end defun

@defvar facexpand
Default value: @code{true}

@code{facexpand} controls whether the irreducible factors
returned by @code{factor} are in expanded (the default) or recursive (normal
CRE) form.

@end defvar

@defun factcomb (@var{expr})
Tries to combine the coefficients of factorials in @var{expr}
with the factorials themselves by converting, for example, @code{(n + 1)*n!}
into @code{(n + 1)!}.

@code{sumsplitfact} if set to @code{false} will cause @code{minfactorial} to be
applied after a @code{factcomb}.

@c Example:
@c UH, THESE ARE THE EXPRESSIONS WHICH WERE GIVEN IN 
@c THE PREVIOUS REVISION OF THIS FILE, BUT IN THIS CASE
@c factcomb HAS NO EFFECT -- I GUESS A DIFFERENT EXAMPLE IS CALLED FOR
@c (n + 1)^b*n!^b;
@c factcomb (%);
@end defun

@defun factor (@var{expr})
Factors the expression @var{expr}, containing any number of
variables or functions, into factors irreducible over the integers.
@code{factor (@var{expr}, p)} factors @var{expr} over the field of integers with an element
adjoined whose minimum polynomial is p.

@code{factorflag} if @code{false} suppresses the factoring of integer factors
of rational expressions.

@code{dontfactor} may be set to a list of variables with respect to which
factoring is not to occur.  (It is initially empty).  Factoring also
will not take place with respect to any variables which are less
important (using the variable ordering assumed for CRE form) than
those on the @code{dontfactor} list.

@code{savefactors} if @code{true} causes the factors of an expression which
is a product of factors to be saved by certain functions in order to
speed up later factorizations of expressions containing some of the
same factors.

@code{berlefact} if @code{false} then the Kronecker factoring algorithm will
be used otherwise the Berlekamp algorithm, which is the default, will
be used.

@code{intfaclim} is the largest divisor which will be tried when
factoring a bignum integer.  If set to @code{false} (this is the case when
the user calls @code{factor} explicitly), or if the integer is a fixnum (i.e.
fits in one machine word), complete factorization of the integer will
be attempted.  The user's setting of @code{intfaclim} is used for internal
calls to @code{factor}. Thus, @code{intfaclim} may be reset to prevent Maxima from
taking an inordinately long time factoring large integers.
@code{newfac} may be set to true to use the new factoring routines.

Examples:
@c EXAMPLES BELOW ADAPTED FROM examples (factor)
@c factor (2^63 - 1);
@c factor (-8*y - 4*x + z^2*(2*y + x));
@c -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
@c block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
@c factor (1 + %e^(3*x));
@c factor (1 + x^4, a^2 - 2);
@c factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
@c (2 + x)/(3 + x)/(b + x)/(c + x)^2;
@c ratsimp (%);
@c partfrac (%, x);
@c map ('factor, %);
@c ratsimp ((x^5 - 1)/(x - 1));
@c subst (a, x, %);
@c factor (%th(2), %);
@c factor (1 + x^12);
@c factor (1 + x^99);

@example
(%i1) factor (2^63 - 1);
                    2
(%o1)              7  73 127 337 92737 649657
(%i2) factor (-8*y - 4*x + z^2*(2*y + x));
(%o2)               (2 y + x) (z - 2) (z + 2)
(%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                2  2        2    2    2
(%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
(%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                       2
                     (x  + 2 x + 1) (y - 1)
(%o4)                ----------------------
                           36 (y + 1)
(%i5) factor (1 + %e^(3*x));
                      x         2 x     x
(%o5)              (%e  + 1) (%e    - %e  + 1)
(%i6) factor (1 + x^4, a^2 - 2);
                    2              2
(%o6)             (x  - a x + 1) (x  + a x + 1)
(%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                       2
(%o7)              - (y  + x) (z - x) (z + x)
(%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                             x + 2
(%o8)               ------------------------
                                           2
                    (x + 3) (x + b) (x + c)
(%i9) ratsimp (%);
                4                  3
(%o9) (x + 2)/(x  + (2 c + b + 3) x

     2                       2             2                   2
 + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
(%i10) partfrac (%, x);
           2                   4                3
(%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

     2              2         2                2
 + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                 c - 2
 - ---------------------------------
     2                             2
   (c  + (- b - 3) c + 3 b) (x + c)

                         b - 2
 + -------------------------------------------------
             2             2       3      2
   ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                         1
 - ----------------------------------------------
             2
   ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
(%i11) map ('factor, %);
              2
             c  - 4 c - b + 6                 c - 2
(%o11) - ------------------------- - ------------------------
                2        2                                  2
         (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                       b - 2                        1
            + ------------------------ - ------------------------
                             2                          2
              (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
(%i12) ratsimp ((x^5 - 1)/(x - 1));
                       4    3    2
(%o12)                x  + x  + x  + x + 1
(%i13) subst (a, x, %);
                       4    3    2
(%o13)                a  + a  + a  + a + 1
(%i14) factor (%th(2), %);
                       2        3        3    2
(%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
(%i15) factor (1 + x^12);
                       4        8    4
(%o15)               (x  + 1) (x  - x  + 1)
(%i16) factor (1 + x^99);
                 2            6    3
(%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

   10    9    8    7    6    5    4    3    2
 (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

   20    19    17    16    14    13    11    10    9    7    6
 (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

    4    3            60    57    51    48    42    39    33
 - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

    30    27    21    18    12    9    3
 - x   - x   + x   + x   - x   - x  + x  + 1)
@end example

@end defun

@defvar factorflag
Default value: @code{false}

@c WHAT IS THIS ABOUT EXACTLY ??
When @code{factorflag} is @code{false}, suppresses the factoring of
integer factors of rational expressions.

@end defvar

@defun factorout (@var{expr}, @var{x_1}, @var{x_2}, ...)
Rearranges the sum @var{expr} into a sum of
terms of the form @code{f (@var{x_1}, @var{x_2}, ...)*g} where @code{g} is a product of
expressions not containing any @var{x_i} and @code{f} is factored.
@c NEED EXAMPLE HERE

@end defun

@defun factorsum (@var{expr})
Tries to group terms in factors of @var{expr} which are sums
into groups of terms such that their sum is factorable.  @code{factorsum} can
recover the result of @code{expand ((x + y)^2 + (z + w)^2)} but it can't recover
@code{expand ((x + 1)^2 + (x + y)^2)} because the terms have variables in common.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
@c factorsum (%);

@example
(%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
           2      2                            2      2
(%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                     2        2    2            2
                        + 2 u v x + u  x + a w  + v  + 2 u v + u
(%i2) factorsum (%);
                                   2          2
(%o2)            (x + 1) (a (z + w)  + (v + u) )
@end example

@end defun

@defun fasttimes (@var{p_1}, @var{p_2})
Returns the product of the polynomials @var{p_1} and @var{p_2} by using a
special algorithm for multiplication of polynomials.  @code{p_1} and @code{p_2} should be
multivariate, dense, and nearly the same size.  Classical
multiplication is of order @code{n_1 n_2} where
@code{n_1} is the degree of @code{p_1}
and @code{n_2} is the degree of @code{p_2}.
@code{fasttimes} is of order @code{max (n_1, n_2)^1.585}.

@end defun

@defun fullratsimp (@var{expr})
@code{fullratsimp} repeatedly
applies @code{ratsimp} followed by non-rational simplification to an
expression until no further change occurs,
and returns the result.

When non-rational expressions are involved, one call
to @code{ratsimp} followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.
@code{fullratsimp} makes this process convenient.

@code{fullratsimp (@var{expr}, @var{x_1}, ..., @var{x_n})} takes one or more arguments similar 
to @code{ratsimp} and @code{rat}.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
@c ratsimp (expr);
@c fullratsimp (expr);
@c rat (expr);

@example
(%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                       a/2     2   a/2     2
                     (x    - 1)  (x    + 1)
(%o1)                -----------------------
                              a
                             x  - 1
(%i2) ratsimp (expr);
                          2 a      a
                         x    - 2 x  + 1
(%o2)                    ---------------
                              a
                             x  - 1
(%i3) fullratsimp (expr);
                              a
(%o3)                        x  - 1
(%i4) rat (expr);
                       a/2 4       a/2 2
                     (x   )  - 2 (x   )  + 1
(%o4)/R/             -----------------------
                              a
                             x  - 1
@end example

@end defun

@c SPELL OUT WHAT fullratsubst DOES INSTEAD OF ALLUDING TO ratsubst AND lratsubst
@c THIS ITEM NEEDS MORE WORK
@defun fullratsubst (@var{a}, @var{b}, @var{c})
is the same as @code{ratsubst} except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.

@code{fullratsubst} will also accept its arguments in the format of
@code{lratsubst}.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.

@code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

Examples:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c CAN PROBABLY CUT OUT THE lratsubst STUFF (lratsubst HAS ITS OWN DESCRIPTION)
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);
@c ratsubst (b*a, a^2, a^3);
@c fullratsubst (b*a, a^2, a^3);
@c fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
@c fullratsubst (a^2 = b*a, a^3);
@c errcatch (fullratsubst (b*a^2, a^2, a^3));

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example
@itemize @bullet
@item
@code{fullratsubst} is equivalent to @code{ratsubst}
except that it recurses until its result stops changing.
@end itemize
@example
(%i5) ratsubst (b*a, a^2, a^3);
                               2
(%o5)                         a  b
(%i6) fullratsubst (b*a, a^2, a^3);
                                 2
(%o6)                         a b
@end example
@itemize @bullet
@item
@code{fullratsubst} also accepts a list of equations or a single
equation as first argument.
@end itemize
@example
(%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
(%o7)                           b
(%i8) fullratsubst (a^2 = b*a, a^3);
                                 2
(%o8)                         a b
@end example
@itemize @bullet
@item
@c REWORD THIS SENTENCE
@code{fullratsubst} may cause an indefinite recursion.
@end itemize
@example
(%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

*** - Lisp stack overflow. RESET
@end example

@end defun

@c GCD IS A VARIABLE AND A FUNCTION
@c THIS ITEM NEEDS A LOT OF WORK
@defun gcd (p_1, p_2, x_1, ...)
Returns the greatest common divisor of @var{p_1} and @var{p_2}.
The flag @code{gcd} determines which algorithm is employed.
Setting @code{gcd} to @code{ez}, @code{eez}, @code{subres}, @code{red}, or @code{spmod} selects the @code{ezgcd}, New
@code{eez} @code{gcd}, subresultant @code{prs}, reduced, or modular algorithm,
respectively.  If @code{gcd} @code{false} then GCD(p1,p2,var) will always return 1
for all var.  Many functions (e.g.  @code{ratsimp}, @code{factor}, etc.) cause gcd's
to be taken implicitly.  For homogeneous polynomials it is recommended
that @code{gcd} equal to @code{subres} be used.  To take the gcd when an algebraic is
present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , @code{algebraic} must be
@code{true} and @code{gcd} must not be @code{ez}.  @code{subres} is a new algorithm, and people
who have been using the @code{red} setting should probably change it to
@code{subres}.

The @code{gcd} flag, default: @code{subres}, if @code{false} will also prevent the greatest
common divisor from being taken when expressions are converted to canonical rational expression (CRE)
form.  This will sometimes speed the calculation if gcds are not
required.
@c NEEDS EXAMPLES HERE

@end defun

@c IN NEED OF SERIOUS CLARIFICATION HERE
@defun gcdex (@var{f}, @var{g})
@defunx gcdex (@var{f}, @var{g}, @var{x})
Returns a list @code{[@var{a}, @var{b}, @var{u}]}
where @var{u} is the greatest common divisor (gcd) of @var{f} and @var{g},
and @var{u} is equal to @code{@var{a} @var{f} + @var{b} @var{g}}.
The arguments @var{f} and @var{g} should be univariate polynomials,
or else polynomials in @var{x} a supplied @b{main} variable   
since we need to be in a principal ideal domain for this to work.
The gcd means the gcd regarding @var{f} and @var{g} as univariate polynomials with coefficients
being rational functions in the other variables.

@code{gcdex} implements the Euclidean algorithm,
where we have a sequence
of @code{L[i]: [a[i], b[i], r[i]]} which are all perpendicular
to @code{[f, g, -1]} and the next one is built as
if @code{q = quotient(r[i]/r[i+1])} then @code{L[i+2]: L[i] - q L[i+1]}, and it
terminates at @code{L[i+1]} when the remainder @code{r[i+2]} is zero.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x^2 + 1, x^3 + 4);
@c % . [x^2 + 1, x^3 + 4, -1];

@example
(%i1) gcdex (x^2 + 1, x^3 + 4);
                       2
                      x  + 4 x - 1  x + 4
(%o1)/R/           [- ------------, -----, 1]
                           17        17
(%i2) % . [x^2 + 1, x^3 + 4, -1];
(%o2)/R/                        0
@end example

@c SORRY FOR BEING DENSE BUT WHAT IS THIS ABOUT EXACTLY
Note that the gcd in the following is @code{1}
since we work in @code{k(y)[x]}, not the  @code{y+1} we would expect in @code{k[y, x]}.

@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gcdex (x*(y + 1), y^2 - 1, x);

@example
(%i1) gcdex (x*(y + 1), y^2 - 1, x);
                               1
(%o1)/R/                 [0, ------, 1]
                              2
                             y  - 1
@end example

@end defun


@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@defun gcfactor (@var{n})
Factors the Gaussian integer @var{n} over the Gaussian integers, i.e.,
numbers of the form @code{@var{a} + @var{b} @code{%i}} where @var{a} and @var{b} are rational integers
(i.e.,  ordinary integers).  Factors are normalized by making @var{a} and @var{b}
non-negative.
@c NEED EXAMPLES HERE

@end defun

@c CHOOSE ONE CHARACTERIZATION OF "GAUSSIAN INTEGERS" AND USE IT WHERE GAUSSIAN INTEGERS ARE REFERENCED
@defun gfactor (@var{expr})
Factors the polynomial @var{expr} over the Gaussian integers
(that is, the integers with the imaginary unit @code{%i} adjoined).
@c "This is like" -- IS IT THE SAME OR NOT ??
This is like @code{factor (@var{expr}, @var{a}^2+1)} where @var{a} is @code{%i}.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c gfactor (x^4 - 1);

@example
(%i1) gfactor (x^4 - 1);
(%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
@end example

@end defun

@c DESCRIBE THIS INDEPENDENTLY OF factorsum
@c THIS ITEM NEEDS MORE WORK
@defun gfactorsum (@var{expr})
is similar to @code{factorsum} but applies @code{gfactor} instead
of @code{factor}.

@end defun

@defun hipow (@var{expr}, @var{x})
Returns the highest explicit exponent of @var{x} in @var{expr}.
@var{x} may be a variable or a general expression.
If @var{x} does not appear in @var{expr},
@code{hipow} returns @code{0}.

@code{hipow} does not consider expressions equivalent to @code{expr}.
In particular, @code{hipow} does not expand @code{expr},
so @code{hipow (@var{expr}, @var{x})} and @code{hipow (expand (@var{expr}, @var{x}))}
may yield different results.

Examples:

@example
(%i1) hipow (y^3 * x^2 + x * y^4, x);
(%o1)                           2
(%i2) hipow ((x + y)^5, x);
(%o2)                           1
(%i3) hipow (expand ((x + y)^5), x);
(%o3)                           5
(%i4) hipow ((x + y)^5, x + y);
(%o4)                           5
(%i5) hipow (expand ((x + y)^5), x + y);
(%o5)                           0
@end example

@end defun

@defvar intfaclim
Default value: 1000

@c NEED A LINK TO DESCRIPTION OF "BIGNUM"
@code{intfaclim} is the largest divisor which will be tried
when factoring a bignum integer.

When @code{intfaclim} is @code{false} (this is the case
@c MAYBE WE WANT TO LINK TO A DESCRIPTION OF "FIXNUM" HERE
when the user calls @code{factor} explicitly), or if the integer is a fixnum
(i.e., fits in one machine word),
factors of any size are considered.
@code{intfaclim} is set to @code{false} when factors are computed in
@code{divsum}, @code{totient}, and @code{primep}.
@c ANY OTHERS ??

@c WHAT ARE THESE MYSTERIOUS INTERNAL CALLS ?? (LET'S JUST LIST THE FUNCTIONS INVOLVED)
Internal calls to @code{factor} respect the user-specified value of @code{intfaclim}.
Setting @code{intfaclim} to a smaller value may reduce the
time spent factoring large integers.
@c NEED EXAMPLES HERE

@end defvar

@defvar keepfloat
Default value: @code{false}

When @code{keepfloat} is @code{true}, prevents floating
point numbers from being rationalized when expressions which contain
them are converted to canonical rational expression (CRE) form.
@c NEED EXAMPLES HERE

@end defvar

@c DESCRIBE lratsubst INDEPENDENTLY OF subst
@c THIS ITEM NEEDS MORE WORK
@defun lratsubst (@var{L}, @var{expr})
is analogous to @code{subst (@var{L}, @var{expr})}
except that it uses @code{ratsubst} instead of @code{subst}.

The first argument of
@code{lratsubst} is an equation or a list of equations identical in
format to that accepted by @code{subst}.  The
substitutions are made in the order given by the list of equations,
that is, from left to right.

@code{load ("lrats")} loads @code{fullratsubst} and @code{lratsubst}.

Examples:
@c EXPRESSIONS ADAPTED FROM demo ("lrats")
@c THIS STUFF CAN PROBABLY STAND REVISION -- EXAMPLES DON'T SEEM VERY ENLIGHTENING
@c load ("lrats")$
@c subst ([a = b, c = d], a + c);
@c lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
@c lratsubst (a^2 = b, a^3);

@example
(%i1) load ("lrats")$
@end example
@itemize @bullet
@item
@code{subst} can carry out multiple substitutions.
@code{lratsubst} is analogous to @code{subst}.
@end itemize
@example
(%i2) subst ([a = b, c = d], a + c);
(%o2)                         d + b
(%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
(%o3)                (d + a c) e + a d + b c
@end example
@itemize @bullet
@item
If only one substitution is desired, then a single
equation may be given as first argument.
@end itemize
@example
(%i4) lratsubst (a^2 = b, a^3);
(%o4)                          a b
@end example

@end defun

@defvar modulus
Default value: @code{false}

When @code{modulus} is a positive number @var{p},
operations on rational numbers (as returned by @code{rat} and related functions)
are carried out modulo @var{p},
using the so-called "balanced" modulus system
in which @code{@var{n} modulo @var{p}} is defined as 
an integer @var{k} in @code{[-(@var{p}-1)/2, ..., 0, ..., (@var{p}-1)/2]}
when @var{p} is odd, or @code{[-(@var{p}/2 - 1), ..., 0, ...., @var{p}/2]} when @var{p} is even,
such that @code{@var{a} @var{p} + @var{k}} equals @var{n} for some integer @var{a}.
@c NEED EXAMPLES OF "BALANCED MODULUS" HERE

@c WHAT CAN THIS MEAN ?? IS THE MODULUS STORED WITH THE EXPRESSION ??
@c "... in order to get correct results" -- WHAT DO YOU GET IF YOU DON'T RE-RAT ??
If @var{expr} is already in canonical rational expression (CRE) form when @code{modulus} is reset,
then you may need to re-rat @var{expr}, e.g., @code{expr: rat (ratdisrep (expr))},
in order to get correct results.

Typically @code{modulus} is set to a prime number.
If @code{modulus} is set to a positive non-prime integer,
this setting is accepted, but a warning message is displayed.
Maxima will allow zero or a negative integer to be assigned to @code{modulus},
although it is not clear if that has any useful consequences.

@c NEED EXAMPLES HERE
@end defvar

@c APPARENTLY OBSOLETE: ONLY EFFECT OF $newfac COULD BE TO CAUSE NONEXISTENT FUNCTION NMULTFACT
@c TO BE CALLED (IN FUNCTION FACTOR72 IN src/factor.lisp CIRCA LINE 1400)
@c $newfac NOT USED IN ANY OTHER CONTEXT (ASIDE FROM DECLARATIONS)
@c COMMENT IT OUT NOW, CUT IT ON THE NEXT PASS THROUGH THIS FILE
@c @defvar newfac
@c Default value: @code{false}
@c 
@c When @code{newfac} is @code{true}, @code{factor} will use the new factoring
@c routines.
@c 
@c @end defvar

@defun num (@var{expr})
Returns the numerator of @var{expr} if it is a ratio.
If @var{expr} is not a ratio, @var{expr} is returned.

@code{num} evaluates its argument.

@c NEED SOME EXAMPLES HERE
@end defun

@defun quotient (@var{p_1}, @var{p_2})
@defunx quotient (@var{p_1}, @var{p_2}, @var{x_1}, ..., @var{x_n})
Returns the polynomial @var{p_1} divided by the polynomial @var{p_2}.
The arguments @var{x_1}, ..., @var{x_n} are interpreted as in @code{ratvars}.

@code{quotient} returns the first element of the two-element list returned by @code{divide}.

@c NEED SOME EXAMPLES HERE
@end defun

@c THIS ITEM CAN PROBABLY BE IMPROVED
@defun rat (@var{expr})
@defunx rat (@var{expr}, @var{x_1}, ..., @var{x_n})
Converts @var{expr} to canonical rational expression (CRE) form by expanding and
combining all terms over a common denominator and cancelling out the
greatest common divisor of the numerator and denominator, as well as
converting floating point numbers to rational numbers within a
tolerance of @code{ratepsilon}.
The variables are ordered according
to the @var{x_1}, ..., @var{x_n}, if specified, as in @code{ratvars}.

@code{rat} does not generally simplify functions other than
addition @code{+}, subtraction @code{-}, multiplication @code{*}, division @code{/}, and
exponentiation to an integer power,
whereas @code{ratsimp} does handle those cases.
Note that atoms (numbers and variables) in CRE form are not the
same as they are in the general form.
For example, @code{rat(x)- x} yields 
@code{rat(0)} which has a different internal representation than 0.

@c WHAT'S THIS ABOUT EXACTLY ??
When @code{ratfac} is @code{true}, @code{rat} yields a partially factored form for CRE.
During rational operations the expression is
maintained as fully factored as possible without an actual call to the
factor package.  This should always save space and may save some time
in some computations.  The numerator and denominator are still made
relatively prime
(e.g.  @code{rat ((x^2 - 1)^4/(x + 1)^2)} yields @code{(x - 1)^4 (x + 1)^2)},
but the factors within each part may not be relatively prime.

@code{ratprint} if @code{false} suppresses the printout of the message
informing the user of the conversion of floating point numbers to
rational numbers.

@code{keepfloat} if @code{true} prevents floating point numbers from being
converted to rational numbers.

See also @code{ratexpand} and  @code{ratsimp}.

Examples:
@c FOLLOW GENERATED FROM THESE EXPRESSIONS
@c ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
@c rat (%, y, a, x);

@example
(%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                           4
                                  (x - 2 y)
              (y + a) (2 y + x) (------------ + 1)
                                   2      2 2
                                 (x  - 4 y )
(%o1)         ------------------------------------
                              2    2
                           4 y  + x
(%i2) rat (%, y, a, x);
                            2 a + 2 y
(%o2)/R/                    ---------
                             x + 2 y
@end example

@end defun

@defvar ratalgdenom
Default value: @code{true}

When @code{ratalgdenom} is @code{true}, allows rationalization of
denominators with respect to radicals to take effect.
@code{ratalgdenom} has an effect only when canonical rational expressions (CRE) are used in algebraic mode.

@end defvar

@c THIS ITEM NEEDS MORE WORK
@defun ratcoef (@var{expr}, @var{x}, @var{n})
@defunx ratcoef (@var{expr}, @var{x})
Returns the coefficient of the expression @code{@var{x}^@var{n}}
in the expression @var{expr}.
If omitted, @var{n} is assumed to be 1.

The return value is free
(except possibly in a non-rational sense) of the variables in @var{x}.
If no coefficient of this type exists, 0 is returned.

@code{ratcoef}
expands and rationally simplifies its first argument and thus it may
produce answers different from those of @code{coeff} which is purely
syntactic.
@c MOVE THIS TO EXAMPLES SECTION
Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas @code{coeff} returns 1.

@code{ratcoef (@var{expr}, @var{x}, 0)}, viewing @var{expr} as a sum,
returns a sum of those terms which do not contain @var{x}.
@c "SHOULD NOT" -- WHAT DOES THIS MEAN ??
Therefore if @var{x} occurs to any negative powers, @code{ratcoef} should not be used.

@c WHAT IS THE INTENT HERE ??
Since @var{expr} is rationally
simplified before it is examined, coefficients may not appear quite
the way they were envisioned.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c s: a*x + b*x + 5$
@c ratcoef (s, a + b);

@example
(%i1) s: a*x + b*x + 5$
(%i2) ratcoef (s, a + b);
(%o2)                           x
@end example
@c NEED MORE EXAMPLES HERE

@end defun

@defun ratdenom (@var{expr})
Returns the denominator of the rational expression @var{expr}.
If @var{expr} is in general form then the @code{denom} function should be used
instead, unless one wishes to get a CRE result.

@end defun

@defvar ratdenomdivide
Default value: @code{true}

When @code{ratdenomdivide} is @code{false}, stops the splitting up
of the terms of the numerator of @code{ratexpand}'ed expressions from
occurring.

@end defvar

@defun ratdiff (@var{expr}, @var{x})
Differentiates the rational expression @var{expr} (which
must be a ratio of polynomials or a polynomial in the variable @var{x})
with respect to @var{x}.
For rational expressions this is much faster than @code{diff}.
@c IS THE RESULT EQUIVALENT TO diff ??

The result is returned in canonical rational expression (CRE) form.
@c "SHOULD NOT" -- WHAT IS THIS ABOUT ?? 
@c (GREP ALL TEXI FILES FOR "SHOULD" AT SOME POINT)
However, @code{ratdiff} should not be used on factored CRE forms;
use @code{diff} instead for such expressions.

Example:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
@c modulus: 3$
@c mod (expr);
@c ratdiff (expr, x);

@example
(%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                           3
                        4 x  + 10 x - 11
(%o1)                   ----------------
                              5
                             x  + 5
(%i2) modulus: 3$
(%i3) mod (expr);
                            2
                           x  + x - 1
(%o3)                 --------------------
                       4    3    2
                      x  + x  + x  + x + 1
(%i4) ratdiff (expr, x);
                       5    4    3
                      x  - x  - x  + x - 1
(%o4)            ------------------------------
                  8    7    5    4    3
                 x  - x  + x  - x  + x  - x + 1
@end example

@end defun

@defun ratdisrep (@var{expr})
changes its argument from CRE form to general form.
This is sometimes convenient if one wishes to stop the "contagion", or
use rational functions in non-rational contexts.  Most CRE functions
will work on either CRE or non-CRE expressions, but the answers may
take different forms.  If @code{ratdisrep} is given a non-CRE for an
argument, it returns its argument unchanged.  See also @code{totaldisrep}.

@end defun

@defvar ratepsilon
Default value: 2.0e-8

@code{ratepsilon} is the tolerance used in the conversion
of floating point numbers to rational numbers.

@end defvar

@c ratexpand IS ALSO A VARIABLE -- MAKE SURE THAT IS CLEAR
@defun ratexpand (@var{expr})
expands @var{expr} by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
cancelling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by
converting @var{expr} to CRE form and then back to general form.

The switch @code{ratexpand} if @code{true} will cause CRE
expressions to be fully expanded when they are converted back to
general form or displayed, while if it is @code{false} then they will be put
into a recursive form. (see @code{ratsimp})

@code{ratdenomdivide} - if @code{false} will stop the splitting up of the
terms of the numerator of @code{ratexpand}'ed expressions from occurring.

@code{keepfloat} if set to @code{true} will prevent floating point numbers
from being rationalized when expressions which contain them are
converted to CRE form.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratexpand ((2*x - 3*y)^3);
@c expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
@c expand (expr);
@c ratexpand (expr);

@example
(%i1) ratexpand ((2*x - 3*y)^3);
                     3         2       2        3
(%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
(%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                         x - 1       1
(%o2)                   -------- + -----
                               2   x - 1
                        (x + 1)
(%i3) expand (expr);
                    x              1           1
(%o3)          ------------ - ------------ + -----
                2              2             x - 1
               x  + 2 x + 1   x  + 2 x + 1
(%i4) ratexpand (expr);
                        2
                     2 x                 2
(%o4)           --------------- + ---------------
                 3    2            3    2
                x  + x  - x - 1   x  + x  - x - 1
@end example

@end defun

@defvar ratfac
Default value: @code{false}

When @code{ratfac} is @code{true} invokes a partially factored form
for CRE rational expressions.  During rational operations the
expression is maintained as fully factored as possible without an
actual call to the factor package.  This should always save space and
may save some time in some computations.  The numerator and
denominator are still made relatively prime, for example
RAT((X^2 -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2),
but the factors within each part may not be relatively prime.
In the @code{ctensr} (Component Tensor Manipulation) Package, if @code{ratfac} is
@code{true}, it causes the Ricci, Einstein, Riemann, and Weyl tensors and the
Scalar Curvature to be factored automatically.  @i{This should only be
set for cases where the tensorial components are known to consist of
few terms.}

Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

@end defvar

@defun ratnumer (@var{expr})
obtains the numerator of the rational expression @var{expr}.
If @var{expr} is in general form then the @code{num} function should be used
instead, unless one wishes to get a CRE result.

@end defun

@defun ratnump (@var{expr})
is @code{true} if @var{expr} is a rational number (includes integers)
else @code{false}.

@end defun

@defun ratp (@var{expr})
is @code{true} if @var{expr} is in CRE or extended CRE form else @code{false}.

@end defun

@defvar ratprint
Default value: @code{true}

When @code{ratprint} is @code{false}, suppresses the printout of the
message informing the user of the conversion of floating point numbers
to rational numbers.

@end defvar

@defun ratsimp (@var{expr})
rationally simplifies (similar to @code{ratexpand}) the
expression @var{expr} and all of its subexpressions including the arguments
to non- rational functions.  The result is returned as the quotient of
two polynomials in a recursive form, i.e.  the coefficients of the
main variable are polynomials in the other variables.  Variables may,
as in @code{ratexpand}, include non-rational functions (e.g. SIN(X**2+1) )
but with @code{ratsimp}, the arguments to non-rational functions are
rationally simplified.  Note that @code{ratsimp} is affected by some of the
variables which affect @code{ratexpand}.

RATSIMP(@var{expr},v1,v2,...,vn) - enables rational simplification with the
specification of variable ordering as in @code{ratvars}.

@code{ratsimpexpons} - if @code{true} will cause exponents of expressions to
be @code{ratsimp}'ed automatically during simplification.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
@c ratsimp (%);
@c ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
@c ratsimp (%);
@c x^(a + 1/a), ratsimpexpons: true;

@example
(%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                         2      2
                   x         (log(x) + 1)  - log (x)
(%o1)        sin(------) = %e
                  2
                 x  + x
(%i2) ratsimp (%);
                             1          2
(%o2)                  sin(-----) = %e x
                           x + 1
(%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                       3/2
                (x - 1)    - sqrt(x - 1) (x + 1)
(%o3)           --------------------------------
                     sqrt((x - 1) (x + 1))
(%i4) ratsimp (%);
                           2 sqrt(x - 1)
(%o4)                    - -------------
                                 2
                           sqrt(x  - 1)
(%i5) x^(a + 1/a), ratsimpexpons: true;
                               2
                              a  + 1
                              ------
                                a
(%o5)                        x
@end example

@end defun

@defvar ratsimpexpons
Default value: @code{false}

When @code{ratsimpexpons} is @code{true}, causes exponents of
expressions to be @code{ratsimp}'ed automatically during simplification.

@end defvar

@defun ratsubst (a, b, c)
substitutes a for b in c.  b may be a sum, product,
power, etc.  @code{ratsubst} knows something of the meaning of expressions
whereas @code{subst} does a purely syntactic substitution.  Thus
SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas @code{ratsubst} would return Z+A.
@code{radsubstflag} if @code{true} permits @code{ratsubst} to make substitutions
like U for SQRT(X) in X.

Examples:
@c EXAMPLES BELOW ADAPTED FROM examples (ratsubst)
@c ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
@c cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
@c ratsubst (1 - sin(x)^2, cos(x)^2, %);
@c ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);

@example
(%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                              3      4
(%o1)                      a x  y + a
(%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
               4         3         2
(%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
(%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
            4           2                     2
(%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
(%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                        4           2
(%o4)                cos (x) - 2 cos (x) + 1
@end example

@end defun

@defun ratvars (var1, var2, ..., varn)
forms its n arguments into a list in
which the rightmost variable varn will be the main variable of future
rational expressions in which it occurs, and the other variables will
follow in sequence.  If a variable is missing from the @code{ratvars} list,
it will be given lower priority than the leftmost variable var1. The
arguments to @code{ratvars} can be either variables or non-rational functions
(e.g. SIN(X)).  The variable @code{ratvars} is a list of the arguments which
have been given to this function.

@end defun

@defun ratweight (v1, w1, ..., vn, wn)
assigns a weight of wi to the variable
vi.  This causes a term to be replaced by 0 if its weight exceeds the
value of the variable @code{ratwtlvl} (default is no truncation).
The weight of a term is the sum of the products of the
weight of a variable in the term times its power.  Thus the weight of
3*v1**2*v2 is 2*w1+w2.  This truncation occurs only when multiplying
or exponentiating CRE forms of expressions.

Examples:
@c FOLLOWING GENERATED FROM THESE EXPRESSIONS
@c ratweight (a, 1, b, 1);
@c expr1: rat(a + b + 1)$
@c expr1^2;
@c ratwtlvl: 1$
@c expr1^2;

@example
(%i1) ratweight (a, 1, b, 1);
(%o1)                     [a, 1, b, 1]
(%i2) expr1: rat(a + b + 1)$
(%i3) expr1^2;
                  2                  2
(%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
(%i4) ratwtlvl: 1$
(%i5) expr1^2;
(%o5)/R/                  2 b + 2 a + 1
@end example

Note: The @code{ratfac} and @code{ratweight} schemes are incompatible and may not
both be used at the same time.

@end defun

@defvar ratweights
@c DEFAULT VALUE ??

@code{ratweights} is a list of weight assignments (set up by the @code{ratweight}
function), @code{ratweights;} or @code{ratweight();} will show you the list.

@c DO WE REALLY NEED TO MENTION THIS ??
@code{kill (ratweights)} and @code{save (ratweights)} both work as expected.

@end defvar

@defvar ratwtlvl
Default value: @code{false}

@code{ratwtlvl} is used in combination with the @code{ratweight}
function to control the truncation of rational (CRE form) expressions
(for the default value of @code{false}, no truncation occurs).

@end defvar

@defun remainder (p1, p2, var1, ...)
computes the remainder of the polynomial
p1 divided by the polynomial p2.

@end defun

@c BOTH A VARIABLE AND A FUNCTION
@defun resultant (p1, p2, var)
computes the resultant of the two polynomials
p1 and p2, eliminating the variable var.  The resultant is a
determinant of the coefficients of var in p1 and p2 which equals zero
if and only if p1 and p2 have a non-constant factor in common.  If p1
or p2 can be factored, it may be desirable to call @code{factor} before
calling @code{resultant}.

@code{resultant} - controls which algorithm will be used to compute
the resultant.  @code{subres} for subresultant prs [the default], @code{mod} for
modular resultant algorithm, and @code{red} for reduced prs.  On most
problems @code{subres} should be best.  On some large degree univariate or
bivariate problems @code{mod} may be better.  Another alternative is the
@code{bezout} command which takes the same arguments as @code{resultant} and returns
a matrix.  @code{determinant} of this matrix is the desired resultant.

@end defun

@defvar savefactors
Default value: @code{false}

When @code{savefactors} is @code{true}, causes the factors of an
expression which is a product of factors to be saved by certain
functions in order to speed up later factorizations of expressions
containing some of the same factors.

@end defvar

@defun sqfr (@var{expr})
is similar to @code{factor} except that the polynomial factors are
"square-free." That is, they have factors only of degree one.  This
algorithm, which is also used by the first stage of @code{factor}, utilizes
the fact that a polynomial has in common with its nth derivative all
its factors of degree > n.  Thus by taking gcds with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.

Example:
@c FOLLOWING GENERATED FROM THIS EXPRESSION
@c sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);

@example
(%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                2   2
(%o1)                  (2 x + 1)  (x  - 1)
@end example

@end defun

@defun tellrat (poly)
adds to the ring of algebraic integers known to
Maxima, the element which is the solution of the polynomial with
integer coefficients.  Maxima initially knows about %I and all roots
of integers. TELLRAT(X); means substitute 0 for X in rational
functions.  There is a command @code{untellrat} which takes kernels and
removes @code{tellrat} properties.  When @code{tellrat}'ing a multivariate
polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as to
whether to substitute Y^2 for X^2 or vice versa.  The system will pick
a particular ordering, but if the user wants to specify which, e.g.
TELLRAT(Y^2=X^2); provides a syntax which says replace Y^2 by X^2.
@code{tellrat} and @code{untellrat} both can take any number of arguments, and
TELLRAT(); returns a list of the current substitutions.  Note: When
you @code{tellrat} reducible polynomials, you want to be careful not to
attempt to rationalize a denominator with a zero divisor.  E.g.
TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$ RAT(1/(W^2-W)); will give "quotient by
zero".  This error can be avoided by setting @code{ratalgdenom} to @code{false}.
@code{algebraic} must be set to @code{true} in order for the simplification of
algebraic integers to take effect.

Examples:
@c EXAMPLE ADAPTED FROM example (tellrat)
@c 10*(%i + 1)/(%i + 3^(1/3));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (1 + a + a^2);
@c 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
@c ev (ratdisrep (rat(%)), algebraic);
@c tellrat (y^2 = x^2);

@example
(%i1) 10*(%i + 1)/(%i + 3^(1/3));
                           10 (%i + 1)
(%o1)                      -----------
                                  1/3
                            %i + 3
(%i2) ev (ratdisrep (rat(%)), algebraic);
             2/3      1/3              2/3      1/3
(%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
(%i3) tellrat (1 + a + a^2);
                            2
(%o3)                     [a  + a + 1]
(%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                      1                 a
(%o4)           ------------- + -----------------
                sqrt(2) a - 1   sqrt(3) + sqrt(2)
(%i5) ev (ratdisrep (rat(%)), algebraic);
         (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
(%o5)    ----------------------------------------------
                               7
(%i6) tellrat (y^2 = x^2);
                        2    2   2
(%o6)                 [y  - x , a  + a + 1]
@end example

@end defun

@defun totaldisrep (@var{expr})
converts every subexpression of @var{expr} from CRE to
general form.  If @var{expr} is itself in CRE form then this is identical to
@code{ratdisrep} but if not then @code{ratdisrep} would return @var{expr} unchanged while
@code{totaldisrep} would "totally disrep" it.  This is useful for
ratdisrepping expressions e.g., equations, lists, matrices, etc. which
have some subexpressions in CRE form.

@end defun

@defun untellrat (x)
takes kernels and removes @code{tellrat} properties.

@end defun
