@menu
* Introduction to Polynomials::  
* Definitions for Polynomials::  
@end menu

@node Introduction to Polynomials, Definitions for Polynomials, Polynomials, Polynomials
@section Introduction to Polynomials

   Polynomials are stored in maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

   Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC[FALSE] is set to TRUE).  In this CRE form an
ordering of variables (from most to least main) is assumed for each
expression.  Polynomials are represented recursively by a list
consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number or
a polynomial in another variable again represented in this form.  Thus
the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that
of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main
variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.  The "variables" of a CRE expression needn't be atomic.  In fact
any subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form) in
which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
MACSYMA will choose an alphabetic one.  In general, CRE's represent
rational expressions, that is, ratios of polynomials, where the
numerator and denominator have no common factors, and the denominator is
positive.  The internal form is essentially a pair of polynomials (the
numerator and denominator) preceded by the variable ordering list.  If
an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form.  An
extended CRE form is used for the representation of Taylor series.  The
notion of a rational expression is extended so that the exponents of the
variables can be positive or negative rational numbers rather than just
positive integers and the coefficients can themselves be rational
expressions as described above rather than just polynomials.  These are
represented internally by a recursive polynomial form which is similar
to and is a generalization of CRE form, but carries additional
information such as the degree of truncation.  As with CRE form, the
symbol /T/ follows the line label of such expressions.

@c end concepts Polynomials
@node Definitions for Polynomials,  , Introduction to Polynomials, Polynomials
@section Definitions for Polynomials
@c @node ALGEBRAIC, BERLEFACT, CRE, Polynomials
@c @unnumberedsec phony
@defvar ALGEBRAIC
 default: [FALSE] must be set to TRUE in order for the
simplification of algebraic integers to take effect.
@end defvar


@c @node BERLEFACT, BEZOUT, ALGEBRAIC, Polynomials
@c @unnumberedsec phony
@defvar BERLEFACT
 default: [TRUE] if FALSE then the Kronecker factoring
algorithm will be used otherwise the Berlekamp algorithm, which is the
default, will be used.

@end defvar
@c @node BEZOUT, BOTHCOEF, BERLEFACT, Polynomials
@c @unnumberedsec phony
@defun BEZOUT (p1, p2, var)
an alternative to the RESULTANT command.  It
returns a matrix. DETERMINANT of this matrix is the desired resultant.

@end defun
@c @node BOTHCOEF, COEFF, BEZOUT, Polynomials
@c @unnumberedsec phony
@defun BOTHCOEF (exp, var)
returns a list whose first member is the
coefficient of var in exp (as found by RATCOEF if exp is in CRE form
otherwise by COEFF) and whose second member is the remaining part of
exp.  That is, [A,B] where exp=A*var+B.
@example
(C1) ISLINEAR(EXP,VAR):=BLOCK([C],
        C:BOTHCOEF(RAT(EXP,VAR),VAR),
        IS(FREEOF(VAR,C) AND C[1]#0))$
(C2) ISLINEAR((R**2-(X-R)**2)/X,X);
(D2)                              TRUE


@end example
@end defun
@c @node COEFF, COMBINE, BOTHCOEF, Polynomials
@c @unnumberedsec phony
@defun COEFF (exp, v, n)
obtains the coefficient of v**n in exp.  n may be
omitted if it is 1.  v may be an atom, or complete subexpression of
exp e.g., X, SIN(X), A[I+1], X+Y, etc. (In the last case the
expression (X+Y) should occur in exp).  Sometimes it may be necessary
to expand or factor exp in order to make v^n explicit.  This is not
done automatically by COEFF.
@example
(C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));
(D1)                         2 A + 1 = 5
(C2) COEFF(Y+X*%E**X+1,X,0);
(D2)                            Y + 1


@end example
@end defun
@c @node COMBINE, CONTENT, COEFF, Polynomials
@c @unnumberedsec phony
@defun COMBINE (exp)
simplifies the sum exp by combining terms with the same
denominator into a single term.

@end defun
@c @node CONTENT, DENOM, COMBINE, Polynomials
@c @unnumberedsec phony
@defun CONTENT (p1, var1, ..., varn)
returns a list whose first element is
the greatest common divisor of the coefficients of the terms of the
polynomial p1 in the variable varn (this is the content) and whose
second element is the polynomial p1 divided by the content.
@example
(C1) CONTENT(2*X*Y+4*X**2*Y**2,Y);
(D1)            [2*X, 2*X*Y**2+Y].


@end example
@end defun
@c @node DENOM, DIVIDE, CONTENT, Polynomials
@c @unnumberedsec phony
@defun DENOM (exp)
returns the denominator of the rational expression exp.

@end defun
@c @node DIVIDE, ELIMINATE, DENOM, Polynomials
@c @unnumberedsec phony
@defun DIVIDE (p1, p2, var1, ..., varn)
computes the quotient and remainder
of the polynomial p1 divided by the polynomial p2, in a main
polynomial variable, varn.  The other variables are as in the RATVARS
function.  The result is a list whose first element is the quotient
and whose second element is the remainder.
@example
(C1) DIVIDE(X+Y,X-Y,X);
(D1)                        [1, 2 Y]
(C2) DIVIDE(X+Y,X-Y);
(D2)                      [ - 1, 2 X]

@end example
@noindent
(Note that Y is the main variable in C2)

@end defun
@c @node ELIMINATE, EZGCD, DIVIDE, Polynomials
@c @unnumberedsec phony
@defun ELIMINATE ([eq1,eq2,...,eqn],[v1,v2,...,vk])
eliminates variables from
equations (or expressions assumed equal to zero) by taking successive
resultants. This returns a list of n-k expressions with the k
variables v1,...,vk eliminated.  First v1 is eliminated yielding n-1
expressions, then v2 is, etc.  If k=n then a single expression in a
list is returned free of the variables v1,...,vk.  In this case SOLVE
is called to solve the last resultant for the last variable.
Example:
@example
(C1) EXP1:2*X^2+Y*X+Z;
                                    2
(D1)                   Z + X Y + 2 X
(C2) EXP2:3*X+5*Y-Z-1;
(D2)                - Z + 5 Y + 3 X - 1
(C3) EXP3:Z^2+X-Y^2+5;
                       2    2
(D3)                  Z  - Y  + X + 5
(C4) ELIMINATE([EXP3,EXP2,EXP1],[Y,Z]);
            8         7         6          5          4
(D3) [7425 X  - 1170 X  + 1299 X  + 12076 X  + 22887 X
                               3         2
                       - 5154 X  - 1291 X  + 7688 X + 15376]


@end example
@end defun
@c @node EZGCD, FACEXPAND, ELIMINATE, Polynomials
@c @unnumberedsec phony
@defun EZGCD (p1, p2, ...)
gives a list whose first element is the g.c.d of
the polynomials p1,p2,...  and whose remaining elements are the
polynomials divided by the g.c.d.  This always uses the EZGCD
algorithm.

@end defun
@c @node FACEXPAND, FACTCOMB, EZGCD, Polynomials
@c @unnumberedsec phony
@defvar FACEXPAND
 default: [TRUE] controls whether the irreducible factors
returned by FACTOR are in expanded (the default) or recursive (normal
CRE) form.

@end defvar
@c @node FACTCOMB, FACTOR, FACEXPAND, Polynomials
@c @unnumberedsec phony
@defun FACTCOMB (exp)
tries to combine the coefficients of factorials in exp
with the factorials themselves by converting, for example, (N+1)*N!
into (N+1)!.
SUMSPLITFACT[TRUE] if set to FALSE will cause MINFACTORIAL to be
applied after a FACTCOMB.
@example
(C1) (N+1)^B*N!^B;
                                      B   B
(D1)                           (N + 1)  N!
(C2) FACTCOMB(%);
                                         


@end example
@end defun
@c @node FACTOR, FACTORFLAG, FACTCOMB, Polynomials
@c @unnumberedsec phony
@defun FACTOR (exp)
factors the expression exp, containing any number of
variables or functions, into factors irreducible over the integers.
FACTOR(exp, p) factors exp over the field of integers with an element
adjoined whose minimum polynomial is p.
FACTORFLAG[FALSE] if FALSE suppresses the factoring of integer factors
of rational expressions.
DONTFACTOR may be set to a list of variables with respect to which
factoring is not to occur.  (It is initially empty).  Factoring also
will not take place with respect to any variables which are less
important (using the variable ordering assumed for CRE form) than
those on the DONTFACTOR list.
SAVEFACTORS[FALSE] if TRUE causes the factors of an expression which
is a product of factors to be saved by certain functions in order to
speed up later factorizations of expressions containing some of the
same factors.
BERLEFACT[TRUE] if FALSE then the Kronecker factoring algorithm will
be used otherwise the Berlekamp algorithm, which is the default, will
be used.
INTFACLIM[1000] is the largest divisor which will be tried when
factoring a bignum integer.  If set to FALSE (this is the case when
the user calls FACTOR explicitly), or if the integer is a fixnum (i.e.
fits in one machine word), complete factorization of the integer will
be attempted.  The user's setting of INTFACLIM is used for internal
calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA from
taking an inordinately long time factoring large integers.
NEWFAC[FALSE] may be set to true to use the new factoring routines.
Do EXAMPLE(FACTOR); for examples.

@end defun
@c @node FACTORFLAG, FACTOROUT, FACTOR, Polynomials
@c @unnumberedsec phony
@defvar FACTORFLAG
 default: [FALSE] if FALSE suppresses the factoring of
integer factors of rational expressions.

@end defvar
@c @node FACTOROUT, FACTORSUM, FACTORFLAG, Polynomials
@c @unnumberedsec phony
@defun FACTOROUT (exp,var1,var2,...)
rearranges the sum exp into a sum of
terms of the form f(var1,var2,...)*g where g is a product of
expressions not containing the vari's and f is factored.

@end defun
@c @node FACTORSUM, FASTTIMES, FACTOROUT, Polynomials
@c @unnumberedsec phony
@defun FACTORSUM (exp)
tries to group terms in factors of exp which are sums
into groups of terms such that their sum is factorable.  It can
recover the result of EXPAND((X+Y)^2+(Z+W)^2) but it can't recover
EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.
@example
(C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;
      2      2                            2      2
(D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X
                     2        2    2            2
        + 2 U V X + U  X + A W  + V  + 2 U V + U
(C2) FACTORSUM(%);
                                   2          2
(D2)                 (X + 1) (A (Z + W)  + (V + U) )


@end example
@end defun
@c @node FASTTIMES, FULLRATSIMP, FACTORSUM, Polynomials
@c @unnumberedsec phony
@defun FASTTIMES (p1, p2)
multiplies the polynomials p1 and p2 by using a
special algorithm for multiplication of polynomials.  They should be
multivariate, dense, and nearly the same size.  Classical
multiplication is of order N*M where N and M are the degrees.
FASTTIMES is of order MAX(N,M)**1.585.

@end defun
@c @node FULLRATSIMP, FULLRATSUBST, FASTTIMES, Polynomials
@c @unnumberedsec phony
@defun FULLRATSIMP (exp)
When non-rational expressions are involved, one call
to RATSIMP followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.  The command
FULLRATSIMP makes this process convenient.  FULLRATSIMP repeatedly
applies RATSIMP followed by non-rational simplification to an
expression until no further change occurs.  For example, consider
For the expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .
FULLRATSIMP(EXP); gives   X^A-1 .  The problem may be seen by looking at 
RAT(EXP); which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
FULLRATSIMP(exp,var1,...,varn) takes one or more arguments similar 
to RATSIMP and RAT.

@end defun
@c @node FULLRATSUBST, GCD, FULLRATSIMP, Polynomials
@c @unnumberedsec phony
@defun FULLRATSUBST (a,b,c)
is the same as RATSUBST except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.
FULLRATSUBST will also accept its arguments in the format of
LRATSUBST.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.  There is a demo available by
DEMO("lrats.dem"); .

@end defun
@c @node GCD, GCFACTOR, FULLRATSUBST, Polynomials
@c @unnumberedsec phony
@defun GCD (p1, p2, var1, ...)
computes the greatest common divisor of p1 and
p2.  The flag GCD[SPMOD] determines which algorithm is employed.
Setting GCD to EZ, EEZ, SUBRES, RED, or SPMOD selects the EZGCD, New
EEZ GCD, subresultant PRS, reduced, or modular algorithm,
respectively.  If GCD:FALSE then GCD(p1,p2,var) will always return 1
for all var.  Many functions (e.g.  RATSIMP, FACTOR, etc.) cause gcd's
to be taken implicitly.  For homogeneous polynomials it is recommended
that GCD:SUBRES be used.  To take the gcd when an algebraic is
present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , ALGEBRAIC must be
TRUE and GCD must not be EZ.  SUBRES is a new algorithm, and people
who have been using the RED setting should probably change it to
SUBRES.
The GCD flag, default: [SPMOD], if FALSE will also prevent the greatest
common divisor from being taken when expressions are converted to CRE
form.  This will sometimes speed the calculation if gcds are not
required.

@end defun

@defun GCDEX (f,g)
@defunx GCDEX (f,g,var)
returns a list containing [a,b,u] where u is the gcd of f and g,
and u = a*f + b*g.   The arguments f and g should b univariate polynomials,
or else polynomials in VAR a supplied @b{main} variable   
since we need to be in a principal ideal domain for this to work.   The
gcd means the gcd regarding f and g as univariate polynomials with coefficients
being rational functions in the other variables.

The
algorithm is simply the euclidean algorithm, where we have a sequence
of @code{lis[i]:[a[i],b[i],r[i]] ..} which are all perpendicular
to @code{[f,g,-1]} and the next one is built as
if @code{q = quotient(r[i]/r[i+1])} then @code{lis[i+2]:lis[i]-q*lis[i+1]}, and it
terminates at @code{lis[i+1]} when the remainder @code{r[i+2]} is zero.
@example
(C1) gcdex(x^2+1,x^3+4);

                              2
                             x  + 4 x - 1  x + 4
(D1)/R/                   [- ------------, -----, 1]
                                  17        17

(C2) d1.[x^2+1,x^3+4,-1];
(D2)                                   0
@end example

note that the gcd in the following is @code{1}
since we work in @code{k(y)[x]}, not the  @code{y+1} we would expect in @code{k[y,x] }

@example
(C4) gcdex(x*(y+1),y^2-1,x);

                                      1
(D4)                            [0, ------, 1]
                                     2
                                    y  - 1


@end example

@end defun

@c @node GCFACTOR, GFACTOR, GCD, Polynomials
@c @unnumberedsec phony
@defun GCFACTOR (n)
factors the gaussian integer n over the gaussians, i.e.
numbers of the form a + b i where a and b are rational integers (i.e.
ordinary integers).  Factors are normalized by making a and b
non-negative.

@end defun
@c @node GFACTOR, GFACTORSUM, GCFACTOR, Polynomials
@c @unnumberedsec phony
@defun GFACTOR (exp)
factors the polynomial exp over the Gaussian integers
(i.  e.  with SQRT(-1) = %I adjoined).  This is like
FACTOR(exp,A**2+1) where A is %I.
@example
(C1)  GFACTOR(X**4-1);
(D1)        (X - 1) (X + 1) (X + %I) (X - %I)


@end example
@end defun
@c @node GFACTORSUM, HIPOW, GFACTOR, Polynomials
@c @unnumberedsec phony
@defun GFACTORSUM (exp)
is similar to FACTORSUM but applies GFACTOR instead
of FACTOR.

@end defun
@c @node HIPOW, INTFACLIM, GFACTORSUM, Polynomials
@c @unnumberedsec phony
@defun HIPOW (exp, v)
the highest explicit exponent of v in exp.  Sometimes
it may be necessary to expand exp since this is not done automatically
by HIPOW.  Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.

@end defun
@c @node INTFACLIM, KEEPFLOAT, HIPOW, Polynomials
@c @unnumberedsec phony
@defvar INTFACLIM
 default: [1000] is the largest divisor which will be tried
when factoring a bignum integer.  If set to FALSE (this is the case
when the user calls FACTOR explicitly), or if the integer is a fixnum
(i.e. fits in one machine word), complete factorization of the integer
will be attempted.  The user's setting of INTFACLIM is used for
internal calls to FACTOR. Thus, INTFACLIM may be reset to prevent
MACSYMA from taking an inordinately long time factoring large
integers.

@end defvar
@c @node KEEPFLOAT, LRATSUBST, INTFACLIM, Polynomials
@c @unnumberedsec phony
@defvar KEEPFLOAT
 default: [FALSE] - if set to TRUE will prevent floating
point numbers from being rationalized when expressions which contain
them are converted to CRE form.

@end defvar
@c @node LRATSUBST, MODULUS, KEEPFLOAT, Polynomials
@c @unnumberedsec phony
@defun LRATSUBST (list,exp)
is analogous to SUBST(list_of_equations,exp)
except that it uses RATSUBST instead of SUBST.  The first argument of
LRATSUBST must be an equation or a list of equations identical in
format to that accepted by SUBST (see DESCRIBE(SUBST);).  The
substitutions are made in the order given by the list of equations,
that is, from left to right.  A demo is available by doing
DEMO("lrats.dem"); .

@end defun
@c @node MODULUS, NEWFAC, LRATSUBST, Polynomials
@c @unnumberedsec phony
@defvar MODULUS
 default: [FALSE] - if set to a positive prime p, then all
arithmetic in the rational function routines will be done modulo p.
That is all integers will be reduced to less than p/2 in absolute
value (if p=2 then all integers are reduced to 1 or 0).  This is the
so called "balanced" modulus system, e.g. N MOD 5 = -2, -1, 0, 1, or
2.  Warning: If EXP is already in CRE form when you reset MODULUS,
then you may need to re-rat EXP, e.g. EXP:RAT(RATDISREP(EXP)), in
order to get correct results. (If MODULUS is set to a positive
non-prime integer, this setting will be accepted, but a warning will
be given.)

@end defvar
@c @node NEWFAC, NUM, MODULUS, Polynomials
@c @unnumberedsec phony
@defvar NEWFAC
 default: [FALSE], if TRUE then FACTOR will use the new factoring
routines.

@end defvar
@c @node NUM, QUOTIENT, NEWFAC, Polynomials
@c @unnumberedsec phony
@defun NUM (exp)
obtains the numerator, exp1, of the rational expression
exp = exp1/exp2.

@end defun
@c @node QUOTIENT, RAT, NUM, Polynomials
@c @unnumberedsec phony
@defun QUOTIENT (p1, p2, var1, ...)
computes the quotient of the polynomial
p1 divided by the polynomial p2.

@end defun
@c @node RAT, RATALGDENOM, QUOTIENT, Polynomials
@c @unnumberedsec phony
@defun RAT (exp, v1, ..., vn)
converts exp to CRE form by expanding and
combining all terms over a common denominator and cancelling out the
greatest common divisor of the numerator and denominator as well as
converting floating point numbers to rational numbers within a
tolerance of RATEPSILON[2.0E-8].  The variables are ordered according
to the v1,...,vn as in RATVARS, if these are specified.  RAT does not
generally simplify functions other than + , - , * , / , and
exponentiation to an integer power whereas RATSIMP does handle these
cases.  Note that atoms (numbers and names) in CRE form are not the
same as they are in the general form.  Thus RAT(X)- X results in
RAT(0) which has a different internal representation than 0.
RATFAC[FALSE] when TRUE invokes a partially factored form for CRE
rational expressions.  During rational operations the expression is
maintained as fully factored as possible without an actual call to the
factor package.  This should always save space and may save some time
in some computations.  The numerator and denominator are still made
relatively prime (e.g.  RAT((X^2 -1)^4/(X+1)^2); yields
(X-1)^4*(X+1)^2), but the factors within each part may not be
relatively prime.
RATPRINT[TRUE] if FALSE suppresses the printout of the message
informing the user of the conversion of floating point numbers to
rational numbers.
KEEPFLOAT[FALSE] if TRUE prevents floating point numbers from being
converted to rational numbers.
(Also see the RATEXPAND and  RATSIMP functions.)
@example
(C1) ((X-2*Y)**4/(X**2-4*Y**2)**2+1)*(Y+A)*(2*Y+X)
        /(4*Y**2+X**2);
                                           4
                                  (X - 2 Y)
              (Y + A) (2 Y + X) (------------ + 1)
                                   2      2 2
                                 (X  - 4 Y )
(D1)          ------------------------------------
                              2    2
                           4 Y  + X
(C2) RAT(%,Y,A,X);
                            2 A + 2 Y
(D2)/R/                     ---------
                             X + 2 Y


@end example
@end defun
@c @node RATALGDENOM, RATCOEF, RAT, Polynomials
@c @unnumberedsec phony
@defvar RATALGDENOM
 default: [TRUE] - if TRUE allows rationalization of
denominators wrt.  radicals to take effect.  To do this one must use
CRE form in algebraic mode.

@end defvar
@c @node RATCOEF, RATDENOM, RATALGDENOM, Polynomials
@c @unnumberedsec phony
@defun RATCOEF (exp, v, n)
returns the coefficient, C, of the expression v**n
in the expression exp.  n may be omitted if it is 1.  C will be free
(except possibly in a non-rational sense) of the variables in v.  If
no coefficient of this type exists, zero will be returned.  RATCOEF
expands and rationally simplifies its first argument and thus it may
produce answers different from those of COEFF which is purely
syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas COEFF
returns 1.  RATCOEF(exp,v,0), viewing exp as a sum, gives a sum of
those terms which do not contain v.  Therefore if v occurs to any
negative powers, RATCOEF should not be used.  Since exp is rationally
simplified before it is examined, coefficients may not appear quite
the way they were envisioned.
@example
(C1) S:A*X+B*X+5$
(C2) RATCOEF(S,A+B);
(D2)               X


@end example
@end defun
@c @node RATDENOM, RATDENOMDIVIDE, RATCOEF, Polynomials
@c @unnumberedsec phony
@defun RATDENOM (exp)
obtains the denominator of the rational expression exp.
If exp is in general form then the DENOM function should be used
instead, unless one wishes to get a CRE result.

@end defun
@c @node RATDENOMDIVIDE, RATDIFF, RATDENOM, Polynomials
@c @unnumberedsec phony
@defvar RATDENOMDIVIDE
 default: [TRUE] - if FALSE will stop the splitting up
of the terms of the numerator of RATEXPANDed expressions from
occurring.

@end defvar
@c @node RATDIFF, RATDISREP, RATDENOMDIVIDE, Polynomials
@c @unnumberedsec phony
@defun RATDIFF (exp, var)
differentiates the rational expression exp (which
must be a ratio of polynomials or a polynomial in the variable var)
with respect to var.  For rational expressions this is much faster
than DIFF.  The result is left in CRE form.  However, RATDIFF should
not be used on factored CRE forms; use DIFF instead for such
expressions.
@example
(C1) (4*X**3+10*X-11)/(X**5+5);
                                         3
                                      4 X  + 10 X - 11
(D1)                                  ----------------
                                            5
                                           X  
(C2) MODULUS:3$
(C3) MOD(D1);
                                2
                               X  + X - 1
(D3)                      --------------------
                           4    3    2
                          X  + X  + X  + X + 1
(C4) RATDIFF(D1,X);
                          5    4    3
                         X  - X  - X  + X - 1
(D4)                ------------------------------
                     8    7    5    4    3
                    X  - X  + X  - X  + X  - X + 1


@end example
@end defun
@c @node RATDISREP, RATEPSILON, RATDIFF, Polynomials
@c @unnumberedsec phony
@defun RATDISREP (exp)
changes its argument from CRE form to general form.
This is sometimes convenient if one wishes to stop the "contagion", or
use rational functions in non-rational contexts.  Most CRE functions
will work on either CRE or non-CRE expressions, but the answers may
take different forms.  If RATDISREP is given a non-CRE for an
argument, it returns its argument unchanged.  See also TOTALDISREP.

@end defun
@c @node RATEPSILON, RATEXPAND, RATDISREP, Polynomials
@c @unnumberedsec phony
@defvar RATEPSILON
 default: [2.0E-8] - the tolerance used in the conversion
of floating point numbers to rational numbers.

@end defvar
@c @node RATEXPAND, RATFAC, RATEPSILON, Polynomials
@c @unnumberedsec phony
@defun RATEXPAND (exp)
expands exp by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
cancelling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by
converting exp to CRE form and then back to general form.
The switch RATEXPAND, default: [FALSE], if TRUE will cause CRE
expressions to be fully expanded when they are converted back to
general form or displayed, while if it is FALSE then they will be put
into a recursive form. (see RATSIMP)
RATDENOMDIVIDE[TRUE] - if FALSE will stop the splitting up of the
terms of the numerator of RATEXPANDed expressions from occurring.
KEEPFLOAT[FALSE] if set to TRUE will prevent floating point numbers
from being rationalized when expressions which contain them are
converted to CRE form.
@example
(C1) RATEXPAND((2*X-3*Y)**3);
                3         2       2        3
(D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X
(C2) (X-1)/(X+1)**2+1/(X-1);
                              X - 1       1
(D2)                         -------- + -----
                                    2   X - 1
                             (X + 1)
(C3) EXPAND(D2);
                         X              1           1
(D3)                ------------ - ------------ + -----
                     2              2             X - 1
                    X  + 2 X + 1   X  + 2 X + 1
(C4) RATEXPAND(D2);
                             2
                          2 X                 2
(D4)                 --------------- + ---------------
                      3    2            3    2
                     X  + X  - X - 1   X  + X  - X - 1


@end example
@end defun
@c @node RATFAC, RATNUMER, RATEXPAND, Polynomials
@c @unnumberedsec phony
@defvar RATFAC
 default: [FALSE] - when TRUE invokes a partially factored form
for CRE rational expressions.  During rational operations the
expression is maintained as fully factored as possible without an
actual call to the factor package.  This should always save space and
may save some time in some computations.  The numerator and
denominator are still made relatively prime, for example
RAT((X^2 -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2),
but the factors within each part may not be relatively prime.
In the CTENSR (Component Tensor Manipulation) Package, if RATFAC is
TRUE, it causes the Ricci, Einstein, Riemann, and Weyl tensors and the
Scalar Curvature to be factored automatically.  ** This should only be
set for cases where the tensorial components are known to consist of
few terms **.
Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
both be used at the same time.

@end defvar
@c @node RATNUMER, RATNUMP, RATFAC, Polynomials
@c @unnumberedsec phony
@defun RATNUMER (exp)
obtains the numerator of the rational expression exp.
If exp is in general form then the NUM function should be used
instead, unless one wishes to get a CRE result.

@end defun
@c @node RATNUMP, RATP, RATNUMER, Polynomials
@c @unnumberedsec phony
@defun RATNUMP (exp)
is TRUE if exp is a rational number (includes integers)
else FALSE.

@end defun
@c @node RATP, RATPRINT, RATNUMP, Polynomials
@c @unnumberedsec phony
@defun RATP (exp)
is TRUE if exp is in CRE or extended CRE form else FALSE.

@end defun
@c @node RATPRINT, RATSIMP, RATP, Polynomials
@c @unnumberedsec phony
@defvar RATPRINT
 default: [TRUE] - if FALSE suppresses the printout of the
message informing the user of the conversion of floating point numbers
to rational numbers.

@end defvar
@c @node RATSIMP, RATSIMPEXPONS, RATPRINT, Polynomials
@c @unnumberedsec phony
@defun RATSIMP (exp)
rationally" simplifies (similar to RATEXPAND) the
expression exp and all of its subexpressions including the arguments
to non- rational functions.  The result is returned as the quotient of
two polynomials in a recursive form, i.e.  the coefficients of the
main variable are polynomials in the other variables.  Variables may,
as in RATEXPAND, include non-rational functions (e.g. SIN(X**2+1) )
but with RATSIMP, the arguments to non-rational functions are
rationally simplified.  Note that RATSIMP is affected by some of the
variables which affect RATEXPAND.
RATSIMP(exp,v1,v2,...,vn) - enables rational simplification with the
specification of variable ordering as in RATVARS.
RATSIMPEXPONS[FALSE] - if TRUE will cause exponents of expressions to
be RATSIMPed automatically during simplification.
@example
(C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);
                                           2          2
                    X          (LOG(X) + 1)  - LOG (X)
(D1)          SIN(------) = %E
                   2
                  X  + X
(C2) RATSIMP(%);
                                  1          2
(D2)                        SIN(-----) = %E X
                                X + 1
(C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));
                       3/2
                (X - 1)    - SQRT(X - 1) (X + 1)
(D3)            --------------------------------
                    SQRT(X - 1) SQRT(X + 1)
(C4) RATSIMP(%);
                                 2
(D4)                      - -----------
                            SQRT(X + 1)
(C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;
                    2
                   A  + 1
                   ------
                     A
(D5)              X


@end example
@end defun
@c @node RATSIMPEXPONS, RATSUBST, RATSIMP, Polynomials
@c @unnumberedsec phony
@defvar RATSIMPEXPONS
 default: [FALSE] - if TRUE will cause exponents of
expressions to be RATSIMPed automatically during simplification.

@end defvar
@c @node RATSUBST, RATVARS, RATSIMPEXPONS, Polynomials
@c @unnumberedsec phony
@defun RATSUBST (a, b, c)
substitutes a for b in c.  b may be a sum, product,
power, etc.  RATSUBST knows something of the meaning of expressions
whereas SUBST does a purely syntactic substitution.  Thus
SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas RATSUBST would return Z+A.
RADSUBSTFLAG[FALSE] if TRUE permits RATSUBST to make substitutions
like U for SQRT(X) in X.
Do EXAMPLE(RATSUBST); for examples.

@end defun
@c @node RATVARS, RATWEIGHT, RATSUBST, Polynomials
@c @unnumberedsec phony
@defun RATVARS (var1, var2, ..., varn)
forms its n arguments into a list in
which the rightmost variable varn will be the main variable of future
rational expressions in which it occurs, and the other variables will
follow in sequence.  If a variable is missing from the RATVARS list,
it will be given lower priority than the leftmost variable var1. The
arguments to RATVARS can be either variables or non-rational functions
(e.g. SIN(X)).  The variable RATVARS is a list of the arguments which
have been given to this function.

@end defun
@c @node RATWEIGHT, RATWEIGHTS, RATVARS, Polynomials
@c @unnumberedsec phony
@defun RATWEIGHT (v1, w1, ..., vn, wn)
assigns a weight of wi to the variable
vi.  This causes a term to be replaced by 0 if its weight exceeds the
value of the variable RATWTLVL [default is FALSE which means no
truncation].  The weight of a term is the sum of the products of the
weight of a variable in the term times its power.  Thus the weight of
3*v1**2*v2 is 2*w1+w2.  This truncation occurs only when multiplying
or exponentiating CRE forms of expressions.
@example
(C5) RATWEIGHT(A,1,B,1);
(D5)                         [[B, 1], [A, 1]]
(C6) EXP1:RAT(A+B+1)$
(C7) %**2;
                      2                  2
(D7)/R/              B  + (2 A + 2) B + A  + 2 A + 1
(C8) RATWTLVL:1$
(C9) EXP1**2;
(D9)/R/                       2 B + 2 A + 1

@end example
Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
both be used at the same time.

@end defun
@c @node RATWEIGHTS, RATWEYL, RATWEIGHT, Polynomials
@c @unnumberedsec phony
@defvar RATWEIGHTS
 - a list of weight assignments (set up by the RATWEIGHT
function), RATWEIGHTS; or RATWEIGHT(); will show you the list.

@example
KILL(...,RATWEIGHTS)
@end example
and
@example
SAVE(...,RATWEIGHTS);
@end example
both work.

@end defvar
@c @node RATWEYL, RATWTLVL, RATWEIGHTS, Polynomials
@c @unnumberedsec phony
@defvar RATWEYL
 default: [] - one of the switches controlling the
simplification of components of the Weyl conformal tensor; if TRUE,
then the components will be rationally simplified; if FACRAT is TRUE
then the results will be factored as well.

@end defvar
@c @node RATWTLVL, REMAINDER, RATWEYL, Polynomials
@c @unnumberedsec phony
@defvar RATWTLVL
 default: [FALSE] - used in combination with the RATWEIGHT
function to control the truncation of rational (CRE form) expressions
(for the default value of FALSE, no truncation occurs).

@end defvar
@c @node REMAINDER, RESULTANT, RATWTLVL, Polynomials
@c @unnumberedsec phony
@defun REMAINDER (p1, p2, var1, ...)
computes the remainder of the polynomial
p1 divided by the polynomial p2.

@end defun
@c @node RESULTANT, SAVEFACTORS, REMAINDER, Polynomials
@c @unnumberedsec phony
@defun RESULTANT (p1, p2, var)
computes the resultant of the two polynomials
p1 and p2, eliminating the variable var.  The resultant is a
determinant of the coefficients of var in p1 and p2 which equals zero
if and only if p1 and p2 have a non-constant factor in common.  If p1
or p2 can be factored, it may be desirable to call FACTOR before
calling RESULTANT.
RESULTANT[SUBRES] - controls which algorithm will be used to compute
the resultant.  SUBRES for subresultant prs [the default], MOD for
modular resultant algorithm, and RED for reduced prs.  On most
problems SUBRES should be best.  On some large degree univariate or
bivariate problems MOD may be better.  Another alternative is the
BEZOUT command which takes the same arguments as RESULTANT and returns
a matrix.  DETERMINANT of this matrix is the desired resultant.

@end defun
@c @node SAVEFACTORS, SQFR, RESULTANT, Polynomials
@c @unnumberedsec phony
@defvar SAVEFACTORS
 default: [FALSE] - if TRUE causes the factors of an
expression which is a product of factors to be saved by certain
functions in order to speed up later factorizations of expressions
containing some of the same factors.

@end defvar
@c @node SQFR, TELLRAT, SAVEFACTORS, Polynomials
@c @unnumberedsec phony
@defun SQFR (exp)
is similar to FACTOR except that the polynomial factors are
"square-free." That is, they have factors only of degree one.  This
algorithm, which is also used by the first stage of FACTOR, utilizes
the fact that a polynomial has in common with its nth derivative all
its factors of degree > n.  Thus by taking gcds with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.
@example
(C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);
                             2               2
(D1)                       (X  - 1) (2 X + 1)


@end example
@end defun
@c @node TELLRAT, TOTALDISREP, SQFR, Polynomials
@c @unnumberedsec phony
@defun TELLRAT (poly)
adds to the ring of algebraic integers known to
MACSYMA, the element which is the solution of the polynomial with
integer coefficients.  MACSYMA initially knows about %I and all roots
of integers. TELLRAT(X); means substitute 0 for X in rational
functions.  There is a command UNTELLRAT which takes kernels and
removes TELLRAT properties.  When TELLRATing a multivariate
polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as to
whether to substitute Y^2 for X^2 or vice versa.  The system will pick
a particular ordering, but if the user wants to specify which, e.g.
TELLRAT(Y^2=X^2); provides a syntax which says replace Y^2 by X^2.
TELLRAT and UNTELLRAT both can take any number of arguments, and
TELLRAT(); returns a list of the current substitutions.  Note: When
you TELLRAT reducible polynomials, you want to be careful not to
attempt to rationalize a denominator with a zero divisor.  E.g.
TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$ RAT(1/(W^2-W)); will give "quotient by
zero".  This error can be avoided by setting RATALGDENOM:FALSE$.
ALGEBRAIC[FALSE] must be set to TRUE in order for the simplification of
algebraic integers to take effect.
Do EXAMPLE(TELLRAT); for examples.

@end defun
@c @node TOTALDISREP, UNTELLRAT, TELLRAT, Polynomials
@c @unnumberedsec phony
@defun TOTALDISREP (exp)
converts every subexpression of exp from CRE to
general form.  If exp is itself in CRE form then this is identical to
RATDISREP but if not then RATDISREP would return exp unchanged while
TOTALDISREP would "totally disrep" it.  This is useful for
ratdisrepping expressions e.g., equations, lists, matrices, etc. which
have some subexpressions in CRE form.

@end defun
@c @node UNTELLRAT,  , TOTALDISREP, Polynomials
@c @unnumberedsec phony
@defun UNTELLRAT (x)
takes kernels and removes TELLRAT properties.

@end defun
