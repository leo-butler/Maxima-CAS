Listing of compilation of file /cygdrive/e/temp/maxima/src/defint.lisp
on 2002-12-17 13:34:54 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/defint.lisp ...

Disassembly of function #:|(IN-PACKAGE "MAXIMA")-1|
(CONST 0) = "MAXIMA"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "MAXIMA"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(MACSYMA-MODULE DEFINT)-2|
(CONST 0) = DEFINT
(CONST 1) = MACSYMA-MODULE
(CONST 2) = (RUNTIME)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEFINT
1     (CONST&PUSH 1)                      ; MACSYMA-MODULE
2     (CONST&PUSH 2)                      ; (RUNTIME)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(LOAD-MACSYMA-MACROS RZMAC)-3|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (*LEXPR $DIFF $LIMIT ...) (*EXPR SUBFUNMAKE $COEFF ...) ...)-4|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (SPECIAL INFINITIES REAL-INFINITIES ...))-5|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(COND (# # # ...))-6|
(CONST 0) = INFINITIES
(CONST 1) = ($INF $MINF $INFINITY)
(CONST 2) = ($INF $MINF)
(CONST 3) = REAL-INFINITIES
(CONST 4) = ($ZEROA $ZEROB)
(CONST 5) = INFINITESIMALS
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variables : (INFINITESIMALS REAL-INFINITIES INFINITIES)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFINITIES
1     (CALLS1 79)                         ; BOUNDP
3     (NOT)
4     (JMPIFNOT1 L17)
6     (CONST 1)                           ; ($INF $MINF $INFINITY)
7     (SETVALUE 0)                        ; INFINITIES
9     (CONST 2)                           ; ($INF $MINF)
10    (SETVALUE 3)                        ; REAL-INFINITIES
12    (CONST 4)                           ; ($ZEROA $ZEROB)
13    (SETVALUE 5)                        ; INFINITESIMALS
15    (SKIP&RET 1)
17    L17
17    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR DEFINTDEBUG NIL ...)-7-1|
(CONST 0) = DEFINTDEBUG
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEFINTDEBUG
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; DEFINTDEBUG
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR DEFINTDEBUG NIL ...)-7-2|
(CONST 0) = (SPECIAL DEFINTDEBUG)
(CONST 1) = DEFINTDEBUG
(CONST 2) = VARIABLE
(CONST 3) = "If true Defint prints out debugging information"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL DEFINTDEBUG)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; DEFINTDEBUG
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; DEFINTDEBUG
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; DEFINTDEBUG
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "If true Defint prints out debugging information"
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; DEFINTDEBUG
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INTEGERL NIL ...)-8-1|
(CONST 0) = INTEGERL
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTEGERL
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; INTEGERL
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INTEGERL NIL ...)-8-2|
(CONST 0) = (SPECIAL INTEGERL)
(CONST 1) = INTEGERL
(CONST 2) = VARIABLE
(CONST 3) = "An integer-list for non-atoms found out to be INTEGERs"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL INTEGERL)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; INTEGERL
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; INTEGERL
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; INTEGERL
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "An integer-list for non-atoms found out to be INTEGERs"
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; INTEGERL
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR NONINTEGERL NIL ...)-9-1|
(CONST 0) = NONINTEGERL
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; NONINTEGERL
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; NONINTEGERL
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR NONINTEGERL NIL ...)-9-2|
(CONST 0) = (SPECIAL NONINTEGERL)
(CONST 1) = NONINTEGERL
(CONST 2) = VARIABLE
(CONST 3) = "A non-integer-list for non-atoms found out to be NONINTEGERs"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL NONINTEGERL)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; NONINTEGERL
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; NONINTEGERL
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; NONINTEGERL
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "A non-integer-list for non-atoms found out to be NONINTEGERs"
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; NONINTEGERL
18    (SKIP&RET 1)


Disassembly of function #:|(DEFUN $DEFINT (EXP VAR LL ...) ...)-10|
(CONST 0) = $DEFINT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $DEFINT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $DEFINT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $DEFINT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $DEFINT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $DEFINT
8     (SKIP&RET 1)


Disassembly of function $DEFINT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = GLOBAL-DEFINT-ASSUMPTIONS
(CONST 5) = INTEGER-INFO
(CONST 6) = INTEGERL
(CONST 7) = NONINTEGERL
(CONST 8) = CONTEXT
(CONST 9) = DEFINT-ASSUMPTIONS
(CONST 10) = *DEF2*
(CONST 11) = RAD-POLY-RECUR
(CONST 12) = SIN-COS-RECUR
(CONST 13) = DINTEXP-RECUR
(CONST 14) = 0
(CONST 15) = DINTLOG-RECUR
(CONST 16) = ANS
(CONST 17) = PCPRNTD
(CONST 18) = *NODIVERG
(CONST 19) = $LOGABS
(CONST 20) = LIMITP
(CONST 21) = RP-POLYLOGP
(CONST 22) = $REAL
(CONST 23) = $DOMAIN
(CONST 24) = $M1PBRANCH
(CONST 25) = MAKE-GLOBAL-ASSUMPTIONS
(CONST 26) = RATDISREP
(CONST 27) = $CONSTANTP
(CONST 28) = "Variable of integration not a variable: ~M"
(CONST 29) = MERROR
(CONST 30) = $SUBVARP
(CONST 31) = STRIPDOLLAR
(CONST 32) = $SUBSTITUTE
(CONST 33) = "Improper variable of integration: ~M"
(CONST 34) = AMONG
(CONST 35) = $IMAGPART
(CONST 36) = $RATSIMP
(CONST 37) = "Defint: Lower limit of integration must be real."
(CONST 38) = "Defint: Upper limit of integration must be real."
(CONST 39) = DEFINT
(CONST 40) = %LIMIT
(CONST 41) = FREE
(CONST 42) = %INTEGRATE
(CONST 43) = $INF
(CONST 44) = $MINF
(CONST 45) = $INFINITY
(CONST 46) = DIVERG
(CONST 47) = $UND
(CONST 48) = (%INTEGRATE)
(CONST 49) = (%INTEGRATE)
(CONST 50) = FORGET-GLOBAL-ASSUMPTIONS
(CONST 51) = CONTEXT-UNWINDER
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS UL LL VAR EXP CONTEXT NONINTEGERL INTEGERL)
writes special variables : (ANS UL LL VAR EXP)
191 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (NIL)
13    (BIND 4)                            ; GLOBAL-DEFINT-ASSUMPTIONS
15    (NIL)
16    (BIND 5)                            ; INTEGER-INFO
18    (GETVALUE 6)                        ; INTEGERL
20    (BIND 6)                            ; INTEGERL
22    (GETVALUE 7)                        ; NONINTEGERL
24    (BIND 7)                            ; NONINTEGERL
26    (GETVALUE&PUSH 8)                   ; CONTEXT
28    (CALL1 8)                           ; CONTEXT
30    (BIND 8)                            ; CONTEXT
32    (UNWIND-PROTECT-OPEN L235)
35    (NIL)
36    (BIND 9)                            ; DEFINT-ASSUMPTIONS
38    (NIL)
39    (BIND 10)                           ; *DEF2*
41    (NIL)
42    (BIND 11)                           ; RAD-POLY-RECUR
44    (NIL)
45    (BIND 12)                           ; SIN-COS-RECUR
47    (NIL)
48    (BIND 13)                           ; DINTEXP-RECUR
50    (CONST 14)                          ; 0
51    (BIND 15)                           ; DINTLOG-RECUR
53    (NIL)
54    (BIND 16)                           ; ANS
56    (GETVALUE&PUSH 0)                   ; EXP
58    (GETVALUE&PUSH 1)                   ; VAR
60    (GETVALUE&PUSH 2)                   ; LL
62    (GETVALUE&PUSH 3)                   ; UL
64    (NIL)
65    (BIND 17)                           ; PCPRNTD
67    (NIL)
68    (BIND 18)                           ; *NODIVERG
70    (T)
71    (BIND 19)                           ; $LOGABS
73    (T)
74    (BIND 20)                           ; LIMITP
76    (NIL)
77    (BIND 21)                           ; RP-POLYLOGP
79    (CONST 22)                          ; $REAL
81    (BIND 23)                           ; $DOMAIN
83    (NIL)
84    (BIND 24)                           ; $M1PBRANCH
86    (CALL0 25)                          ; MAKE-GLOBAL-ASSUMPTIONS
88    (GETVALUE&PUSH 0)                   ; EXP
90    (CALL1 26)                          ; RATDISREP
92    (SETVALUE 0)                        ; EXP
94    (GETVALUE&PUSH 1)                   ; VAR
96    (CALL1 26)                          ; RATDISREP
98    (SETVALUE 1)                        ; VAR
100   (GETVALUE&PUSH 2)                   ; LL
102   (CALL1 26)                          ; RATDISREP
104   (SETVALUE 2)                        ; LL
106   (GETVALUE&PUSH 3)                   ; UL
108   (CALL1 26)                          ; RATDISREP
110   (SETVALUE 3)                        ; UL
112   (GETVALUE&PUSH 1)                   ; VAR
114   (CALL1&JMPIF 27 L246)               ; $CONSTANTP
118   (GETVALUE&PUSH 1)                   ; VAR
120   (CALL1&JMPIFNOT 30 L140)            ; $SUBVARP
123   (GETVALUE 1)                        ; VAR
125   (CAR)
126   (CAR&PUSH)
127   (CALL1 31)                          ; STRIPDOLLAR
129   (SETVALUE 1)                        ; VAR
131   (PUSH)
132   (LOAD&PUSH 24)
133   (GETVALUE&PUSH 0)                   ; EXP
135   (CALL 3 32)                         ; $SUBSTITUTE
138   (SETVALUE 0)                        ; EXP
140   L140
140   (GETVALUE 1)                        ; VAR
142   (JMPIFCONSP L254)
145   (GETVALUE&PUSH 1)                   ; VAR
147   (GETVALUE&PUSH 3)                   ; UL
149   (CALL2&JMPIF 34 L159)               ; AMONG
152   (GETVALUE&PUSH 1)                   ; VAR
154   (GETVALUE&PUSH 2)                   ; LL
156   (CALL2&JMPIFNOT 34 L174)            ; AMONG
159   L159
159   (GETVALUE&PUSH 1)                   ; VAR
161   (CALL1 31)                          ; STRIPDOLLAR
163   (SETVALUE 1)                        ; VAR
165   (PUSH)
166   (LOAD&PUSH 24)
167   (GETVALUE&PUSH 0)                   ; EXP
169   (CALL 3 32)                         ; $SUBSTITUTE
172   (SETVALUE 0)                        ; EXP
174   L174
174   (GETVALUE&PUSH 2)                   ; LL
176   (CALL1&PUSH 35)                     ; $IMAGPART
178   (CALL1&PUSH 36)                     ; $RATSIMP
180   (JMPIFNOTEQTO 14 L263)              ; 0
184   (GETVALUE&PUSH 3)                   ; UL
186   (CALL1&PUSH 35)                     ; $IMAGPART
188   (CALL1&PUSH 36)                     ; $RATSIMP
190   (JMPIFEQTO 14 L198)                 ; 0
193   (CONST 38)                          ; "Defint: Upper limit of integration must be real."
195   L195
195   (PUSH)
196   (CALL1 29)                          ; MERROR
198   L198
198   (GETVALUE&PUSH 0)                   ; EXP
200   (GETVALUE&PUSH 1)                   ; VAR
202   (GETVALUE&PUSH 2)                   ; LL
204   (GETVALUE&PUSH 3)                   ; UL
206   (CALL 4 39)                         ; DEFINT
209   (SETVALUE 16)                       ; ANS
211   (JMPIF L280)
214   (CONST 49)                          ; (%INTEGRATE)
216   L216
216   (PUSH)
217   (LOAD&PUSH 25)
219   (LOAD&PUSH 25)
221   (LOAD&PUSH 25)
223   (LOAD&PUSH 25)
225   (LIST 5)
227   L227
227   (UNBIND 7)
229   (SKIP 4)
231   (UNBIND 7)
233   (VALUES1)
234   (UNWIND-PROTECT-NORMAL-EXIT)
235   L235
235   (CALL0 50)                          ; FORGET-GLOBAL-ASSUMPTIONS
237   (UNWIND-PROTECT-CLOSE)
238   (PUSH)
239   (CALL0 51)                          ; CONTEXT-UNWINDER
241   (POP)
242   (UNBIND 9)
244   (SKIP&RET 5)
246   L246
246   (CONST&PUSH 28)                     ; "Variable of integration not a variable: ~M"
247   (GETVALUE&PUSH 1)                   ; VAR
249   (CALL2 29)                          ; MERROR
251   (JMP L140)
254   L254
254   (CONST&PUSH 33)                     ; "Improper variable of integration: ~M"
256   (GETVALUE&PUSH 1)                   ; VAR
258   (CALL2 29)                          ; MERROR
260   (JMP L174)
263   L263
263   (CONST 37)                          ; "Defint: Lower limit of integration must be real."
265   (JMP L195)
268   L268
268   (GETVALUE 16)                       ; ANS
270   (JMP L227)
272   L272
272   (CALL0 46)                          ; DIVERG
274   (JMP L227)
276   L276
276   (CONST 48)                          ; (%INTEGRATE)
278   (JMP L216)
280   L280
280   (LOAD&PUSH 23)
281   (GETVALUE&PUSH 1)                   ; VAR
283   (GETVALUE&PUSH 16)                  ; ANS
285   (PUSH-UNBOUND 3)
287   (CALLS1 172)                        ; SUBST
289   (SETVALUE 16)                       ; ANS
291   (JMPIFATOM L268)
293   (GETVALUE&PUSH 16)                  ; ANS
295   (CONST&PUSH 40)                     ; %LIMIT
297   (CALL2&JMPIFNOT 41 L328)            ; FREE
300   (GETVALUE&PUSH 16)                  ; ANS
302   (CONST&PUSH 42)                     ; %INTEGRATE
304   (CALL2&JMPIFNOT 41 L328)            ; FREE
307   (GETVALUE&PUSH 16)                  ; ANS
309   (CONST&PUSH 43)                     ; $INF
311   (CALL2&JMPIFNOT 41 L272)            ; FREE
314   (GETVALUE&PUSH 16)                  ; ANS
316   (CONST&PUSH 44)                     ; $MINF
318   (CALL2&JMPIFNOT 41 L272)            ; FREE
321   (GETVALUE&PUSH 16)                  ; ANS
323   (CONST&PUSH 45)                     ; $INFINITY
325   (CALL2&JMPIFNOT 41 L272)            ; FREE
328   L328
328   (GETVALUE&PUSH 16)                  ; ANS
330   (CONST&PUSH 47)                     ; $UND
332   (CALL2&JMPIFNOT 41 L276)            ; FREE
335   (GETVALUE 16)                       ; ANS
337   (JMP L227)


Disassembly of function #:|(DEFUN EEZZ (EXP LL UL) ...)-11|
(CONST 0) = EEZZ
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EEZZ>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EEZZ
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EEZZ
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EEZZ>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EEZZ
8     (SKIP&RET 1)


Disassembly of function EEZZ
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = VAR
(CONST 4) = POLYINX
(CONST 5) = PIN%EX
(CONST 6) = ANTIDERIV
(CONST 7) = INTSUBS
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR EXP)
writes special variable : (EXP)
37 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (GETVALUE&PUSH 0)                   ; EXP
11    (GETVALUE&PUSH 3)                   ; VAR
13    (NIL&PUSH)
14    (CALL 3 4)                          ; POLYINX
17    (JMPIF L29)
19    (CONST 5)                           ; PIN%EX
20    (CATCH-OPEN L51)
22    (GETVALUE&PUSH 0)                   ; EXP
24    (CALL1 5)                           ; PIN%EX
26    (CATCH-CLOSE)
27    (JMPIFNOT L53)
29    L29
29    (GETVALUE&PUSH 0)                   ; EXP
31    (CALL1 6)                           ; ANTIDERIV
33    (SETVALUE 0)                        ; EXP
35    (JMPIFNOT L48)
37    (GETVALUE&PUSH 0)                   ; EXP
39    (GETVALUE&PUSH 1)                   ; LL
41    (GETVALUE&PUSH 2)                   ; UL
43    (CALL 3 7)                          ; INTSUBS
46    (JMP L54)
48    L48
48    (NIL)
49    (JMP L54)
51    L51
51    (JMPIF L29)
53    L53
53    (NIL)
54    L54
54    (UNBIND 3)
56    (SKIP&RET 4)


Disassembly of function #:|(DEFUN SININTP (EXPR VAR) ...)-12|
(CONST 0) = SININTP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SININTP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SININTP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SININTP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SININTP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SININTP
8     (SKIP&RET 1)


Disassembly of function SININTP
(CONST 0) = VAR
(CONST 1) = FACTOR
(CONST 2) = $NUM
(CONST 3) = $DENOM
(CONST 4) = POLYINX
(CONST 5) = 2
(CONST 6) = DEG-LESSP
(CONST 7) = %EINVOLVE
(CONST 8) = FREE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
58 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR
3     (LOAD&PUSH 5)
4     (CALL1&PUSH 1)                      ; FACTOR
6     (PUSH-NIL 2)
8     (LOAD&PUSH 2)
9     (CALL1 2)                           ; $NUM
11    (STORE 1)
12    (LOAD&PUSH 2)
13    (CALL1 3)                           ; $DENOM
15    (STORE 0)
16    (LOAD&PUSH 1)
17    (GETVALUE&PUSH 0)                   ; VAR
19    (NIL&PUSH)
20    (CALL 3 4)                          ; POLYINX
23    (JMPIF L52)
25    (LOAD&PUSH 1)
26    (CALL1&PUSH 7)                      ; %EINVOLVE
28    (LOAD&PUSH 0)
29    (GETVALUE&PUSH 0)                   ; VAR
31    (NIL&PUSH)
32    (CALL 3 4)                          ; POLYINX
35    (JMPIF L72)
37    (SKIP 1)
39    (JMPIFNOT L83)
41    L41
41    (LOAD&PUSH 0)
42    (GETVALUE&PUSH 0)                   ; VAR
44    (CALL2&JMPIFNOT 8 L83)              ; FREE
47    L47
47    (T)
48    (SKIP 3)
50    (JMP L86)
52    L52
52    (LOAD&PUSH 0)
53    (GETVALUE&PUSH 0)                   ; VAR
55    (NIL&PUSH)
56    (CALL 3 4)                          ; POLYINX
59    (JMPIFNOT L83)
61    (LOAD&PUSH 0)
62    (GETVALUE&PUSH 0)                   ; VAR
64    (CONST&PUSH 5)                      ; 2
65    (CALL 3 6)                          ; DEG-LESSP
68    (JMPIFNOT L83)
70    (JMP L47)
72    L72
72    (LOAD&PUSH 0)
73    (GETVALUE&PUSH 0)                   ; VAR
75    (CONST&PUSH 5)                      ; 2
76    (CALL 3 6)                          ; DEG-LESSP
79    (SKIP 1)
81    (JMPIF L41)
83    L83
83    (NIL)
84    (SKIP 3)
86    L86
86    (UNBIND1)
87    (SKIP&RET 3)


Disassembly of function #:|(DEFUN DEG-LESSP (EXPR VAR POWER) ...)-13|
(CONST 0) = DEG-LESSP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEG-LESSP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEG-LESSP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEG-LESSP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEG-LESSP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DEG-LESSP
8     (SKIP&RET 1)


Disassembly of function DEG-LESSP
(CONST 0) = VAR
(CONST 1) = MNUMP
(CONST 2) = MTIMESP
(CONST 3) = MPLUSP
(CONST 4) = MEXPTP
(CONST 5) = ALIKE1
(CONST 6) = -1
(CONST 7) = MUL*
(CONST 8) = ADD*
(CONST 9) = ASKSIGN
(CONST 10) = $NEGATIVE
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
72 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 6)
4     (JMPIFATOM L26)
6     (LOAD&PUSH 6)
7     (CALL1&JMPIF 1 L26)                 ; MNUMP
10    (LOAD&PUSH 6)
11    (CALL1&JMPIF 2 L34)                 ; MTIMESP
14    (LOAD&PUSH 6)
15    (CALL1&JMPIF 3 L34)                 ; MPLUSP
18    (LOAD&PUSH 6)
19    (CALL1&JMPIF 4 L58)                 ; MEXPTP
22    (NIL)
23    L23
23    (UNBIND1)
24    (SKIP&RET 4)
26    L26
26    (T)
27    (JMP L23)
29    L29
29    (NIL)
30    (SKIP 1)
32    (JMP L23)
34    L34
34    (LOAD&CDR&PUSH 6)
36    (LOAD&JMPIFNOT 0 L53)
39    L39
39    (LOAD&CAR&PUSH 0)
41    (GETVALUE&PUSH 0)                   ; VAR
43    (LOAD&PUSH 7)
44    (JSR L0)
46    (JMPIFNOT L29)
48    (LOAD&CDR&STORE 0)
50    (LOAD&JMPIF 0 L39)
53    L53
53    (T)
54    (SKIP 1)
56    (JMP L23)
58    L58
58    (LOAD 6)
59    (CDR)
60    (CAR&PUSH)
61    (GETVALUE&PUSH 0)                   ; VAR
63    (CALL2&JMPIFNOT 5 L92)              ; ALIKE1
66    (LOAD 6)
67    (CDR)
68    (CDR)
69    (CAR&PUSH)
70    (CALLS2 8)                          ; NUMBERP
72    (JMPIFNOT1 L23)
74    (LOAD&PUSH 4)
75    (CONST&PUSH 6)                      ; -1
76    (LOAD 8)
77    (CDR)
78    (CDR)
79    (CAR&PUSH)
80    (CALL2&PUSH 7)                      ; MUL*
82    (CALL2&PUSH 8)                      ; ADD*
84    (CALL1&PUSH 9)                      ; ASKSIGN
86    (CONST 10)                          ; $NEGATIVE
87    (EQ)
88    (NOT)
89    (JMPIFNOT1 L23)
92    L92
92    (LOAD 6)
93    (CDR)
94    (CAR&PUSH)
95    (GETVALUE&PUSH 0)                   ; VAR
97    (LOAD&PUSH 6)
98    (JSR L0)
101   (JMP L23)


Disassembly of function #:|(DEFUN ANTIDERIV (A) ...)-14|
(CONST 0) = ANTIDERIV
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ANTIDERIV>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ANTIDERIV
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ANTIDERIV
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ANTIDERIV>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ANTIDERIV
8     (SKIP&RET 1)


Disassembly of function ANTIDERIV
(CONST 0) = A
(CONST 1) = LIMITP
(CONST 2) = ANS
(CONST 3) = GENERATE-ATAN2
(CONST 4) = VAR
(CONST 5) = SININT
(CONST 6) = %INTEGRATE
(CONST 7) = AMONG
(CONST 8) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR A)
writes special variable : (ANS)
23 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (NIL)
4     (BIND 1)                            ; LIMITP
6     (NIL)
7     (BIND 2)                            ; ANS
9     (NIL)
10    (BIND 3)                            ; GENERATE-ATAN2
12    (GETVALUE&PUSH 0)                   ; A
14    (GETVALUE&PUSH 4)                   ; VAR
16    (CALL2 5)                           ; SININT
18    (SETVALUE 2)                        ; ANS
20    (CONST&PUSH 6)                      ; %INTEGRATE
21    (GETVALUE&PUSH 2)                   ; ANS
23    (CALL2&JMPIF 7 L34)                 ; AMONG
26    (GETVALUE&PUSH 2)                   ; ANS
28    (CALL1 8)                           ; SIMPLIFY
30    L30
30    (UNBIND 4)
32    (SKIP&RET 2)
34    L34
34    (NIL)
35    (JMP L30)


Disassembly of function #:|(DEFMFUN GET-LIMIT NARGS ...)-15|
(CONST 0) = GET-LIMIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GET-LIMIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GET-LIMIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GET-LIMIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GET-LIMIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GET-LIMIT
8     (SKIP&RET 1)


Disassembly of function GET-LIMIT
(CONST 0) = LIMIT-NO-ERR
(CONST 1) = LISTIFY1
(CONST 2) = ANS
(CONST 3) = VAR
(CONST 4) = EXP
(CONST 5) = %LIMIT
(CONST 6) = AMONG
(CONST 7) = 3
(CONST 8) = 4
(CONST 9) = NARG1
(CONST 10) = ($INF $MINF)
(CONST 11) = MEMQ
(CONST 12) = 2
(CONST 13) = -1
(CONST 14) = POWER
(CONST 15) = 1
(CONST 16) = MAXIMA-SUBSTITUTE
(CONST 17) = $INF
(CONST 18) = $PLUS
(CONST 19) = $MINUS
(CONST 20) = 0
0 required arguments
0 optional arguments
Rest parameter
No keyword parameters
reads special variables: (EXP VAR ANS)
writes special variables : (ANS EXP VAR)
80 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; LIMIT-NO-ERR
4     (LOAD&PUSH 1)
5     (LOAD&PUSH 4)
6     (CALL2 1)                           ; LISTIFY1
8     (APPLY 0)
10    (BIND 2)                            ; ANS
12    (NIL&PUSH)
13    (NIL)
14    (BIND 3)                            ; VAR
16    (NIL)
17    (BIND 4)                            ; EXP
19    (NIL&PUSH)
20    (GETVALUE 2)                        ; ANS
22    (JMPIFNOT L30)
24    (CONST&PUSH 5)                      ; %LIMIT
25    (GETVALUE&PUSH 2)                   ; ANS
27    (CALL2&JMPIFNOT 6 L58)              ; AMONG
30    L30
30    (LOAD&PUSH 11)
31    (JMPIFEQTO 7 L38)                   ; 3
34    (LOAD&PUSH 11)
35    (JMPIFNOTEQTO 8 L48)                ; 4
38    L38
38    (CONST&PUSH 7)                      ; 3
39    (LOAD&PUSH 14)
40    (CALL2 9)                           ; NARG1
42    (STORE 7)
43    (PUSH)
44    (CONST&PUSH 10)                     ; ($INF $MINF)
45    (CALL2&JMPIF 11 L70)                ; MEMQ
48    L48
48    (NIL)
49    L49
49    (SKIP 1)
51    (UNBIND 2)
53    (SKIP 1)
55    (UNBIND1)
56    (SKIP&RET 3)
58    L58
58    (GETVALUE 2)                        ; ANS
60    (JMP L49)
62    L62
62    (CONST 18)                          ; $PLUS
63    (STORE 0)
64    (JMP L97)
66    L66
66    (GETVALUE 2)                        ; ANS
68    (JMP L49)
70    L70
70    (CONST&PUSH 12)                     ; 2
71    (LOAD&PUSH 14)
72    (CALL2 9)                           ; NARG1
74    (SETVALUE 3)                        ; VAR
76    (PUSH)
77    (CONST&PUSH 13)                     ; -1
78    (CALL2&PUSH 14)                     ; POWER
80    (GETVALUE&PUSH 3)                   ; VAR
82    (CONST&PUSH 15)                     ; 1
83    (LOAD&PUSH 16)
84    (CALL2&PUSH 9)                      ; NARG1
86    (CALL 3 16)                         ; MAXIMA-SUBSTITUTE
89    (SETVALUE 4)                        ; EXP
91    (LOAD&PUSH 7)
92    (JMPIFEQTO 17 L62)                  ; $INF
95    (CONST 19)                          ; $MINUS
96    (STORE 0)
97    L97
97    (GETVALUE&PUSH 4)                   ; EXP
99    (GETVALUE&PUSH 3)                   ; VAR
101   (CONST&PUSH 20)                     ; 0
102   (LOAD&PUSH 3)
103   (CALL 4 0)                          ; LIMIT-NO-ERR
106   (SETVALUE 2)                        ; ANS
108   (CONST&PUSH 5)                      ; %LIMIT
109   (GETVALUE&PUSH 2)                   ; ANS
111   (CALL2&JMPIFNOT 6 L66)              ; AMONG
114   (NIL)
115   (JMP L49)


Disassembly of function #:|(DEFUN LIMIT-NO-ERR (&REST ARGVEC) ...)-16|
(CONST 0) = LIMIT-NO-ERR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-NO-ERR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-NO-ERR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-NO-ERR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-NO-ERR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT-NO-ERR
8     (SKIP&RET 1)


Disassembly of function LIMIT-NO-ERR
(CONST 0) = ERRORSW
(CONST 1) = ANS
(CONST 2) = $LIMIT
0 required arguments
0 optional arguments
Rest parameter
No keyword parameters
reads special variable: (ANS)
writes special variable : (ANS)
22 byte-code instructions:
0     (T)
1     (BIND 0)                            ; ERRORSW
3     (NIL)
4     (BIND 1)                            ; ANS
6     (CONST 0)                           ; ERRORSW
7     (CATCH-OPEN L14)
9     (CONST&PUSH 2)                      ; $LIMIT
10    (LOAD 11)
11    (APPLY 0)
13    (CATCH-CLOSE)
14    L14
14    (SETVALUE 1)                        ; ANS
16    (PUSH)
17    (T)
18    (JMPIFEQ L26)
20    (GETVALUE 1)                        ; ANS
22    L22
22    (UNBIND 2)
24    (SKIP&RET 2)
26    L26
26    (NIL)
27    (JMP L22)


Disassembly of function #:|(DEFUN INTCV (NV IND FLAG) ...)-17|
(CONST 0) = INTCV
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTCV>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTCV
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTCV
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTCV>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTCV
8     (SKIP&RET 1)


Disassembly of function INTCV
(CONST 0) = IND
(CONST 1) = FLAG
(CONST 2) = BX**N+A
(CONST 3) = D
(CONST 4) = *ROOTS
(CONST 5) = *FAILURES
(CONST 6) = $BREAKUP
(CONST 7) = UL
(CONST 8) = $INF
(CONST 9) = LL
(CONST 10) = 0
(CONST 11) = 1
(CONST 12) = YX
(CONST 13) = -1
(CONST 14) = MUL
(CONST 15) = ADD
(CONST 16) = VAR
(CONST 17) = SOLVE
(CONST 18) = INTCV2
(CONST 19) = INTCV1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FLAG IND *ROOTS VAR D LL UL)
writes special variable : (D)
63 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; IND
3     (LOAD 4)
4     (BIND 1)                            ; FLAG
6     (LOAD&PUSH 9)
7     (CALL1 2)                           ; BX**N+A
9     (BIND 3)                            ; D
11    (NIL)
12    (BIND 4)                            ; *ROOTS
14    (NIL)
15    (BIND 5)                            ; *FAILURES
17    (NIL)
18    (BIND 6)                            ; $BREAKUP
20    (GETVALUE&PUSH 7)                   ; UL
22    (JMPIFNOTEQTO 8 L37)                ; $INF
25    (GETVALUE&PUSH 9)                   ; LL
27    (JMPIFNOTEQTO 10 L37)               ; 0
30    (GETVALUE 3)                        ; D
32    (CDR)
33    (CAR&PUSH)
34    (JMPIFEQTO 11 L59)                  ; 1
37    L37
37    (CONST&PUSH 12)                     ; YX
38    (CONST&PUSH 13)                     ; -1
39    (LOAD&PUSH 23)
40    (CALL2&PUSH 14)                     ; MUL
42    (CALL2&PUSH 15)                     ; ADD
44    (GETVALUE&PUSH 16)                  ; VAR
46    (CONST&PUSH 11)                     ; 1
47    (CALL 3 17)                         ; SOLVE
50    (GETVALUE 4)                        ; *ROOTS
52    (JMPIF L72)
54    (NIL)
55    L55
55    (UNBIND 6)
57    (SKIP&RET 4)
59    L59
59    (NIL)
60    (JMP L55)
62    L62
62    (GETVALUE&PUSH 3)                   ; D
64    (GETVALUE&PUSH 0)                   ; IND
66    (LOAD&PUSH 23)
67    (CALL 3 18)                         ; INTCV2
70    (JMP L55)
72    L72
72    (GETVALUE&PUSH 16)                  ; VAR
74    (CONST&PUSH 12)                     ; YX
75    (GETVALUE 4)                        ; *ROOTS
77    (CAR)
78    (CDR)
79    (CDR)
80    (CAR&PUSH)
81    (PUSH-UNBOUND 3)
83    (CALLS1 172)                        ; SUBST
85    (SETVALUE 3)                        ; D
87    (GETVALUE 1)                        ; FLAG
89    (JMPIF L62)
91    (GETVALUE&PUSH 3)                   ; D
93    (GETVALUE&PUSH 0)                   ; IND
95    (LOAD&PUSH 23)
96    (CALL 3 19)                         ; INTCV1
99    (JMP L55)


Disassembly of function #:|(DEFUN INTCV1 (D IND NV) ...)-18|
(CONST 0) = INTCV1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTCV1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTCV1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTCV1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTCV1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTCV1
8     (SKIP&RET 1)


Disassembly of function INTCV1
(CONST 0) = D
(CONST 1) = IND
(CONST 2) = INTCV2
(CONST 3) = LL1
(CONST 4) = UL1
(CONST 5) = ALIKE1
(CONST 6) = *DEF2*
(CONST 7) = EXP1
(CONST 8) = VAR
(CONST 9) = DEFINT
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP1 UL1 LL1 IND D)
27 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; D
3     (LOAD 5)
4     (BIND 1)                            ; IND
6     (GETVALUE&PUSH 0)                   ; D
8     (GETVALUE&PUSH 1)                   ; IND
10    (LOAD&PUSH 9)
11    (CALL 3 2)                          ; INTCV2
14    (JMPIFNOT L23)
16    (GETVALUE&PUSH 3)                   ; LL1
18    (GETVALUE&PUSH 4)                   ; UL1
20    (CALL2&JMPIFNOT 5 L28)              ; ALIKE1
23    L23
23    (NIL)
24    L24
24    (UNBIND 2)
26    (SKIP&RET 4)
28    L28
28    (T)
29    (BIND 6)                            ; *DEF2*
31    (GETVALUE&PUSH 7)                   ; EXP1
33    (GETVALUE&PUSH 8)                   ; VAR
35    (GETVALUE&PUSH 3)                   ; LL1
37    (GETVALUE&PUSH 4)                   ; UL1
39    (CALL 4 9)                          ; DEFINT
42    (UNBIND1)
43    (JMP L24)


Disassembly of function #:|(DEFUN INTCV2 (D IND NV) ...)-19|
(CONST 0) = INTCV2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTCV2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTCV2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTCV2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTCV2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTCV2
8     (SKIP&RET 1)


Disassembly of function INTCV2
(CONST 0) = D
(CONST 1) = IND
(CONST 2) = INTCV3
(CONST 3) = LL
(CONST 4) = UL
(CONST 5) = ADD*
(CONST 6) = ZEROP1
(CONST 7) = VAR
(CONST 8) = EVENFN
(CONST 9) = 2
(CONST 10) = EXP1
(CONST 11) = MUL*
(CONST 12) = 0
(CONST 13) = $PLUS
(CONST 14) = LIMCP
(CONST 15) = LL1
(CONST 16) = $MINUS
(CONST 17) = UL1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP1 VAR UL LL IND D)
writes special variables : (EXP1 UL1 LL1)
44 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; D
3     (LOAD 5)
4     (BIND 1)                            ; IND
6     (GETVALUE&PUSH 0)                   ; D
8     (GETVALUE&PUSH 1)                   ; IND
10    (LOAD&PUSH 9)
11    (CALL 3 2)                          ; INTCV3
14    (GETVALUE&PUSH 3)                   ; LL
16    (GETVALUE&PUSH 4)                   ; UL
18    (CALL2&PUSH 5)                      ; ADD*
20    (CALL1&JMPIFNOT 6 L29)              ; ZEROP1
23    (LOAD&PUSH 7)
24    (GETVALUE&PUSH 7)                   ; VAR
26    (CALL2&JMPIF 8 L58)                 ; EVENFN
29    L29
29    (LOAD&PUSH 7)
30    (GETVALUE&PUSH 7)                   ; VAR
32    (GETVALUE&PUSH 3)                   ; LL
34    (CONST 13)                          ; $PLUS
35    L35
35    (PUSH)
36    (CALL 4 14)                         ; LIMCP
39    (SETVALUE 15)                       ; LL1
41    (JMPIFNOT1 L54)
43    (LOAD&PUSH 7)
44    (GETVALUE&PUSH 7)                   ; VAR
46    (GETVALUE&PUSH 4)                   ; UL
48    (CONST&PUSH 16)                     ; $MINUS
49    (CALL 4 14)                         ; LIMCP
52    (SETVALUE 17)                       ; UL1
54    L54
54    (UNBIND 2)
56    (SKIP&RET 4)
58    L58
58    (CONST&PUSH 9)                      ; 2
59    (GETVALUE&PUSH 10)                  ; EXP1
61    (CALL2 11)                          ; MUL*
63    (SETVALUE 10)                       ; EXP1
65    (LOAD&PUSH 7)
66    (GETVALUE&PUSH 7)                   ; VAR
68    (CONST&PUSH 12)                     ; 0
69    (CONST 13)                          ; $PLUS
70    (JMP L35)


Disassembly of function #:|(DEFUN LIMCP (A B C ...) ...)-20|
(CONST 0) = LIMCP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMCP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMCP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMCP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMCP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMCP
8     (SKIP&RET 1)


Disassembly of function LIMCP
(CONST 0) = A
(CONST 1) = B
(CONST 2) = C
(CONST 3) = D
(CONST 4) = $LIMIT
(CONST 5) = ANS
(CONST 6) = %LIMIT
(CONST 7) = AMONG
(CONST 8) = $IND
(CONST 9) = $UND
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS D C B A)
35 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; A
3     (LOAD 6)
4     (BIND 1)                            ; B
6     (LOAD 8)
7     (BIND 2)                            ; C
9     (LOAD 10)
10    (BIND 3)                            ; D
12    (GETVALUE&PUSH 0)                   ; A
14    (GETVALUE&PUSH 1)                   ; B
16    (GETVALUE&PUSH 2)                   ; C
18    (GETVALUE&PUSH 3)                   ; D
20    (CALL 4 4)                          ; $LIMIT
23    (BIND 5)                            ; ANS
25    (GETVALUE 5)                        ; ANS
27    (JMPIFNOT L47)
29    (CONST&PUSH 6)                      ; %LIMIT
30    (GETVALUE&PUSH 5)                   ; ANS
32    (CALL2&JMPIF 7 L47)                 ; AMONG
35    (CONST&PUSH 8)                      ; $IND
36    (GETVALUE&PUSH 5)                   ; ANS
38    (CALL2&JMPIF 7 L47)                 ; AMONG
41    (CONST&PUSH 9)                      ; $UND
42    (GETVALUE&PUSH 5)                   ; ANS
44    (CALL2&JMPIFNOT 7 L53)              ; AMONG
47    L47
47    (NIL)
48    (UNBIND1)
49    L49
49    (UNBIND 4)
51    (SKIP&RET 5)
53    L53
53    (GETVALUE 5)                        ; ANS
55    (UNBIND1)
56    (JMP L49)


Disassembly of function #:|(DEFUN INTCV3 (D IND NV) ...)-21|
(CONST 0) = INTCV3
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTCV3>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTCV3
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTCV3
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTCV3>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTCV3
8     (SKIP&RET 1)


Disassembly of function INTCV3
(CONST 0) = D
(CONST 1) = IND
(CONST 2) = VAR
(CONST 3) = SDIFF
(CONST 4) = $RATSIMP
(CONST 5) = NN*
(CONST 6) = YX
(CONST 7) = EXP
(CONST 8) = EXP1
(CONST 9) = MUL*
(CONST 10) = SRATSIMP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP1 IND NN* EXP VAR D)
writes special variables : (EXP1 NN*)
39 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; D
3     (LOAD 5)
4     (BIND 1)                            ; IND
6     (GETVALUE&PUSH 0)                   ; D
8     (GETVALUE&PUSH 2)                   ; VAR
10    (CALL2&PUSH 3)                      ; SDIFF
12    (CALL1 4)                           ; $RATSIMP
14    (SETVALUE 5)                        ; NN*
16    (CONST&PUSH 6)                      ; YX
17    (LOAD&PUSH 8)
18    (GETVALUE&PUSH 7)                   ; EXP
20    (PUSH-UNBOUND 3)
22    (CALLS1 172)                        ; SUBST
24    (SETVALUE 8)                        ; EXP1
26    (GETVALUE&PUSH 5)                   ; NN*
28    (GETVALUE 1)                        ; IND
30    (JMPIF L64)
32    (GETVALUE&PUSH 0)                   ; D
34    (GETVALUE&PUSH 2)                   ; VAR
36    (GETVALUE&PUSH 8)                   ; EXP1
38    (PUSH-UNBOUND 3)
40    (CALLS1 172)                        ; SUBST
42    L42
42    (PUSH)
43    (CALL2 9)                           ; MUL*
45    (SETVALUE 8)                        ; EXP1
47    (GETVALUE&PUSH 2)                   ; VAR
49    (CONST&PUSH 6)                      ; YX
50    (GETVALUE&PUSH 8)                   ; EXP1
52    (PUSH-UNBOUND 3)
54    (CALLS1&PUSH 172)                   ; SUBST
56    (CALL1 10)                          ; SRATSIMP
58    (SETVALUE 8)                        ; EXP1
60    (UNBIND 2)
62    (SKIP&RET 4)
64    L64
64    (GETVALUE 7)                        ; EXP
66    (JMP L42)


Disassembly of function #:|(DEFUN DEFINT (EXP VAR LL ...) ...)-22|
(CONST 0) = DEFINT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEFINT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEFINT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEFINT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEFINT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DEFINT
8     (SKIP&RET 1)


Disassembly of function DEFINT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = DEFINT-ASSUMPTIONS
(CONST 5) = CURRENT-ASSUMPTIONS
(CONST 6) = NOASK
(CONST 7) = MAKE-DEFINT-ASSUMPTIONS
(CONST 8) = RESIMPLIFY
(CONST 9) = $EXPTSUBST
(CONST 10) = 0
(CONST 11) = LOOPSTOP*
(CONST 12) = ANS
(CONST 13) = NN*
(CONST 14) = DN*
(CONST 15) = ND*
(CONST 16) = $NOPRINCIPAL
(CONST 17) = DEFINT-LIST
(CONST 18) = ZEROP1
(CONST 19) = ALIKE1
(CONST 20) = AMONG
(CONST 21) = ($INF $MINF)
(CONST 22) = MEMQ
(CONST 23) = ($INF $MINF)
(CONST 24) = DIVERG
(CONST 25) = -1
(CONST 26) = MUL*
(CONST 27) = ADD*
(CONST 28) = RMCONST1
(CONST 29) = C
(CONST 30) = %I-OUT-OF-DENOM
(CONST 31) = $NOINTEGRATE
(CONST 32) = MQAPPLY
(CONST 33) = 
(MEXPT MPLUS MTIMES %SIN %COS %TAN %SINH %COSH %TANH %LOG %ASIN %ACOS %ATAN
 %COT %ACOT %SEC %ASEC %CSC %ACSC %DERIVATIVE)
(CONST 34) = ANTIDERIV
(CONST 35) = INTSUBS
(CONST 36) = TANSC
(CONST 37) = INITIAL-ANALYSIS
(CONST 38) = RESTORE-DEFINT-ASSUMPTIONS
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (CURRENT-ASSUMPTIONS ANS C $NOINTEGRATE UL LL VAR EXP DEFINT-ASSUMPTIONS)
writes special variables : (EXP ANS CURRENT-ASSUMPTIONS)
140 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE&PUSH 4)                   ; DEFINT-ASSUMPTIONS
14    (NIL)
15    (BIND 5)                            ; CURRENT-ASSUMPTIONS
17    (UNWIND-PROTECT-OPEN L233)
20    (CONST&PUSH 6)                      ; NOASK
21    (CALL1 7)                           ; MAKE-DEFINT-ASSUMPTIONS
23    (SETVALUE 5)                        ; CURRENT-ASSUMPTIONS
25    (GETVALUE&PUSH 0)                   ; EXP
27    (CALL1&PUSH 8)                      ; RESIMPLIFY
29    (GETVALUE&PUSH 1)                   ; VAR
31    (CALL1 8)                           ; RESIMPLIFY
33    (BIND 1)                            ; VAR
35    (T)
36    (BIND 9)                            ; $EXPTSUBST
38    (CONST 10)                          ; 0
39    (BIND 11)                           ; LOOPSTOP*
41    (NIL)
42    (BIND 12)                           ; ANS
44    (NIL)
45    (BIND 13)                           ; NN*
47    (NIL)
48    (BIND 14)                           ; DN*
50    (NIL)
51    (BIND 15)                           ; ND*
53    (NIL)
54    (BIND 16)                           ; $NOPRINCIPAL
56    (LOAD 24)
58    (BIND 0)                            ; EXP
60    (GETVALUE&PUSH 0)                   ; EXP
62    (GETVALUE&PUSH 1)                   ; VAR
64    (GETVALUE&PUSH 2)                   ; LL
66    (GETVALUE&PUSH 3)                   ; UL
68    (CALL 4 17)                         ; DEFINT-LIST
71    (SETVALUE 12)                       ; ANS
73    (JMPIF L228)
76    (GETVALUE&PUSH 0)                   ; EXP
78    (CALL1&JMPIF 18 L182)               ; ZEROP1
82    (GETVALUE&PUSH 3)                   ; UL
84    (GETVALUE&PUSH 2)                   ; LL
86    (CALL2&JMPIF 19 L182)               ; ALIKE1
90    (GETVALUE&PUSH 1)                   ; VAR
92    (GETVALUE&PUSH 0)                   ; EXP
94    (CALL2&JMPIF 20 L112)               ; AMONG
97    (GETVALUE&PUSH 3)                   ; UL
99    (CONST&PUSH 21)                     ; ($INF $MINF)
100   (CALL2&JMPIF 22 L110)               ; MEMQ
103   (GETVALUE&PUSH 2)                   ; LL
105   (CONST&PUSH 23)                     ; ($INF $MINF)
106   (CALL2&JMPIFNOT 22 L185)            ; MEMQ
110   L110
110   (CALL0 24)                          ; DIVERG
112   L112
112   (GETVALUE&PUSH 0)                   ; EXP
114   (CALL1 28)                          ; RMCONST1
116   (BIND 0)                            ; EXP
118   (GETVALUE 0)                        ; EXP
120   (CAR)
121   (BIND 29)                           ; C
123   (GETVALUE 0)                        ; EXP
125   (CDR&PUSH)
126   (CALL1 30)                          ; %I-OUT-OF-DENOM
128   (BIND 0)                            ; EXP
130   (GETVALUE 31)                       ; $NOINTEGRATE
132   (JMPIF L205)
135   (GETVALUE 0)                        ; EXP
137   (JMPIFATOM L205)
140   (CONST&PUSH 32)                     ; MQAPPLY
142   (GETVALUE&PUSH 0)                   ; EXP
144   (CALL2&JMPIF 20 L156)               ; AMONG
147   (GETVALUE 0)                        ; EXP
149   (CAR)
150   (CAR&PUSH)
151   (CONST&PUSH 33)                     ; (MEXPT MPLUS MTIMES %SIN %COS ...)
153   (CALL2&JMPIF 22 L205)               ; MEMQ
156   L156
156   (GETVALUE&PUSH 0)                   ; EXP
158   (CALL1 34)                          ; ANTIDERIV
160   (SETVALUE 12)                       ; ANS
162   (JMPIFNOT L202)
164   (PUSH)
165   (GETVALUE&PUSH 2)                   ; LL
167   (GETVALUE&PUSH 3)                   ; UL
169   (CALL 3 35)                         ; INTSUBS
172   (SETVALUE 12)                       ; ANS
174   L174
174   (GETVALUE&PUSH 29)                  ; C
176   (GETVALUE&PUSH 12)                  ; ANS
178   (CALL2 26)                          ; MUL*
180   (JMP L226)
182   L182
182   (CONST 10)                          ; 0
183   (JMP L228)
185   L185
185   (GETVALUE&PUSH 0)                   ; EXP
187   (GETVALUE&PUSH 3)                   ; UL
189   (CONST&PUSH 25)                     ; -1
190   (GETVALUE&PUSH 2)                   ; LL
192   (CALL2&PUSH 26)                     ; MUL*
194   (CALL2&PUSH 27)                     ; ADD*
196   (CALL2 26)                          ; MUL*
198   (SETVALUE 12)                       ; ANS
200   (JMP L228)
202   L202
202   (NIL)
203   (JMP L226)
205   L205
205   (GETVALUE&PUSH 0)                   ; EXP
207   (CALL1 36)                          ; TANSC
209   (SETVALUE 0)                        ; EXP
211   (PUSH)
212   (GETVALUE&PUSH 1)                   ; VAR
214   (GETVALUE&PUSH 2)                   ; LL
216   (GETVALUE&PUSH 3)                   ; UL
218   (CALL 4 37)                         ; INITIAL-ANALYSIS
221   (SETVALUE 12)                       ; ANS
223   (JMPIF L174)
225   (NIL)
226   L226
226   (UNBIND 3)
228   L228
228   (UNBIND 9)
230   (SKIP 1)
232   (UNWIND-PROTECT-NORMAL-EXIT)
233   L233
233   (LOADI&PUSH 0 0 3)
237   (GETVALUE&PUSH 5)                   ; CURRENT-ASSUMPTIONS
239   (CALL2 38)                          ; RESTORE-DEFINT-ASSUMPTIONS
241   (UNWIND-PROTECT-CLOSE)
242   (UNBIND1)
243   (SKIP 1)
245   (UNBIND 4)
247   (SKIP&RET 5)


Disassembly of function #:|(DEFUN DEFINT-LIST (EXP VAR LL ...) ...)-23|
(CONST 0) = DEFINT-LIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEFINT-LIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEFINT-LIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEFINT-LIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEFINT-LIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DEFINT-LIST
8     (SKIP&RET 1)


Disassembly of function DEFINT-LIST
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = (MEQUAL MLIST $MATRIX)
(CONST 5) = MEMQ
(CONST 6) = DEFINT
(CONST 7) = ANS
(CONST 8) = SIMPLIFY
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS UL LL VAR EXP)
56 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE 0)                        ; EXP
14    (JMPIFATOM L24)
16    (GETVALUE 0)                        ; EXP
18    (CAR)
19    (CAR&PUSH)
20    (CONST&PUSH 4)                      ; (MEQUAL MLIST $MATRIX)
21    (CALL2&JMPIF 5 L29)                 ; MEMQ
24    L24
24    (NIL)
25    L25
25    (UNBIND 4)
27    (SKIP&RET 5)
29    L29
29    (GETVALUE 0)                        ; EXP
31    (CAR&PUSH)
32    (NIL&PUSH)
33    (GETVALUE 0)                        ; EXP
35    (CDR&PUSH)
36    (JMP L62)
38    L38
38    (PUSH)
39    (CALL1 8)                           ; SIMPLIFY
41    (UNBIND1)
42    (JMP L25)
44    L44
44    (LOAD&CAR&PUSH 0)
46    (LOAD&PUSH 0)
47    (GETVALUE&PUSH 1)                   ; VAR
49    (GETVALUE&PUSH 2)                   ; LL
51    (GETVALUE&PUSH 3)                   ; UL
53    (CALL&PUSH 4 6)                     ; DEFINT
56    (LOAD&CONS&STORE 2)
58    (SKIP 1)
60    (LOAD&CDR&STORE 0)
62    L62
62    (LOAD&PUSH 0)
63    (CALLS1&JMPIFNOT 146 L44)           ; ENDP
66    (SKIP 1)
68    (LOAD&PUSH 0)
69    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
71    (SKIP 1)
73    (CONS)
74    (BIND 7)                            ; ANS
76    (GETVALUE 7)                        ; ANS
78    (JMPIF L38)
80    (NIL)
81    (UNBIND1)
82    (JMP L25)


Disassembly of function #:|(DEFUN INITIAL-ANALYSIS (EXP VAR LL ...) ...)-24|
(CONST 0) = INITIAL-ANALYSIS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INITIAL-ANALYSIS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIAL-ANALYSIS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INITIAL-ANALYSIS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INITIAL-ANALYSIS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INITIAL-ANALYSIS
8     (SKIP&RET 1)


Disassembly of function INITIAL-ANALYSIS
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = $INTANALYSIS
(CONST 5) = $NO
(CONST 6) = POLES-IN-INTERVAL
(CONST 7) = ODDFN
(CONST 8) = $MINF
(CONST 9) = $INF
(CONST 10) = ADD*
(CONST 11) = $SIGN
(CONST 12) = $ZERO
(CONST 13) = 0
(CONST 14) = PARSE-INTEGRAND
(CONST 15) = $UNKNOWN
(CONST 16) = PRINCIPAL-VALUE-INTEGRAL
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR EXP $INTANALYSIS)
64 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE 4)                        ; $INTANALYSIS
14    (JMPIFNOT L55)
16    (GETVALUE&PUSH 0)                   ; EXP
18    (GETVALUE&PUSH 1)                   ; VAR
20    (GETVALUE&PUSH 2)                   ; LL
22    (GETVALUE&PUSH 3)                   ; UL
24    (CALL 4 6)                          ; POLES-IN-INTERVAL
27    L27
27    (PUSH)
28    (LOAD&PUSH 0)
29    (JMPIFEQTO 5 L63)                   ; $NO
32    (LOAD&PUSH 0)
33    (JMPIFEQTO 15 L106)                 ; $UNKNOWN
37    (GETVALUE&PUSH 0)                   ; EXP
39    (GETVALUE&PUSH 1)                   ; VAR
41    (GETVALUE&PUSH 2)                   ; LL
43    (GETVALUE&PUSH 3)                   ; UL
45    (LOAD&PUSH 4)
46    (CALL 5 16)                         ; PRINCIPAL-VALUE-INTEGRAL
49    (SKIP 1)
51    L51
51    (UNBIND 4)
53    (SKIP&RET 5)
55    L55
55    (CONST 5)                           ; $NO
56    (JMP L27)
58    L58
58    (CONST 13)                          ; 0
59    (SKIP 1)
61    (JMP L51)
63    L63
63    (GETVALUE&PUSH 0)                   ; EXP
65    (GETVALUE&PUSH 1)                   ; VAR
67    (CALL2&JMPIFNOT 7 L91)              ; ODDFN
70    (GETVALUE&PUSH 2)                   ; LL
72    (JMPIFNOTEQTO 8 L80)                ; $MINF
75    (GETVALUE&PUSH 3)                   ; UL
77    (JMPIFEQTO 9 L58)                   ; $INF
80    L80
80    (GETVALUE&PUSH 2)                   ; LL
82    (GETVALUE&PUSH 3)                   ; UL
84    (CALL2&PUSH 10)                     ; ADD*
86    (CALL1&PUSH 11)                     ; $SIGN
88    (JMPIFEQTO 12 L58)                  ; $ZERO
91    L91
91    (GETVALUE&PUSH 0)                   ; EXP
93    (GETVALUE&PUSH 1)                   ; VAR
95    (GETVALUE&PUSH 2)                   ; LL
97    (GETVALUE&PUSH 3)                   ; UL
99    (CALL 4 14)                         ; PARSE-INTEGRAND
102   (SKIP 1)
104   (JMP L51)
106   L106
106   (NIL)
107   (SKIP 1)
109   (JMP L51)


Disassembly of function #:|(DEFUN PARSE-INTEGRAND (EXP VAR LL ...) ...)-25|
(CONST 0) = PARSE-INTEGRAND
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-INTEGRAND>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-INTEGRAND
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-INTEGRAND
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-INTEGRAND>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-INTEGRAND
8     (SKIP&RET 1)


Disassembly of function PARSE-INTEGRAND
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = ANS
(CONST 5) = EEZZ
(CONST 6) = RATP
(CONST 7) = METHOD-BY-LIMITS
(CONST 8) = MPLUSP
(CONST 9) = INTBYTERM
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR UL LL EXP)
writes special variable : (ANS)
55 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (NIL)
13    (BIND 4)                            ; ANS
15    (GETVALUE&PUSH 0)                   ; EXP
17    (GETVALUE&PUSH 2)                   ; LL
19    (GETVALUE&PUSH 3)                   ; UL
21    (CALL 3 5)                          ; EEZZ
24    (SETVALUE 4)                        ; ANS
26    (JMPIF L88)
28    (GETVALUE&PUSH 0)                   ; EXP
30    (GETVALUE&PUSH 1)                   ; VAR
32    (CALL2&JMPIFNOT 6 L50)              ; RATP
35    (GETVALUE&PUSH 0)                   ; EXP
37    (GETVALUE&PUSH 1)                   ; VAR
39    (GETVALUE&PUSH 2)                   ; LL
41    (GETVALUE&PUSH 3)                   ; UL
43    (CALL 4 7)                          ; METHOD-BY-LIMITS
46    (SETVALUE 4)                        ; ANS
48    (JMPIF L64)
50    L50
50    (GETVALUE&PUSH 0)                   ; EXP
52    (CALL1&JMPIFNOT 8 L73)              ; MPLUSP
55    (GETVALUE&PUSH 0)                   ; EXP
57    (T&PUSH)
58    (CALL2 9)                           ; INTBYTERM
60    (SETVALUE 4)                        ; ANS
62    (JMPIFNOT L73)
64    L64
64    (GETVALUE 4)                        ; ANS
66    (UNBIND1)
67    (JMP L89)
69    L69
69    (NIL)
70    (UNBIND1)
71    (JMP L89)
73    L73
73    (GETVALUE&PUSH 0)                   ; EXP
75    (GETVALUE&PUSH 1)                   ; VAR
77    (GETVALUE&PUSH 2)                   ; LL
79    (GETVALUE&PUSH 3)                   ; UL
81    (CALL 4 7)                          ; METHOD-BY-LIMITS
84    (SETVALUE 4)                        ; ANS
86    (JMPIFNOT L69)
88    L88
88    (UNBIND1)
89    L89
89    (UNBIND 4)
91    (SKIP&RET 5)


Disassembly of function #:|(DEFUN RMCONST1 (E) ...)-26|
(CONST 0) = RMCONST1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RMCONST1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RMCONST1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RMCONST1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RMCONST1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RMCONST1
8     (SKIP&RET 1)


Disassembly of function RMCONST1
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = 1
(CONST 4) = PARTITION
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAR
5     (GETVALUE&PUSH 0)                   ; E
7     (CALL2&JMPIF 2 L17)                 ; AMONG
10    (GETVALUE&PUSH 0)                   ; E
12    (CONST 3)                           ; 1
13    (CONS)
14    L14
14    (UNBIND1)
15    (SKIP&RET 2)
17    L17
17    (GETVALUE&PUSH 0)                   ; E
19    (GETVALUE&PUSH 1)                   ; VAR
21    (CONST&PUSH 3)                      ; 1
22    (CALL 3 4)                          ; PARTITION
25    (JMP L14)


Disassembly of function #:|(DEFUN METHOD-BY-LIMITS (EXP VAR LL ...) ...)-27|
(CONST 0) = METHOD-BY-LIMITS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE METHOD-BY-LIMITS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; METHOD-BY-LIMITS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; METHOD-BY-LIMITS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE METHOD-BY-LIMITS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; METHOD-BY-LIMITS
8     (SKIP&RET 1)


Disassembly of function METHOD-BY-LIMITS
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = DEFINT-ASSUMPTIONS
(CONST 5) = NOASK
(CONST 6) = MAKE-DEFINT-ASSUMPTIONS
(CONST 7) = CURRENT-ASSUMPTIONS
(CONST 8) = $INF
(CONST 9) = $MINF
(CONST 10) = MTOINF
(CONST 11) = 0
(CONST 12) = ZTOINF
(CONST 13) = FREEOF
(CONST 14) = $ASKSIGN
(CONST 15) = $POS
(CONST 16) = ZTO1
(CONST 17) = DINTEGRATE
(CONST 18) = RESTORE-DEFINT-ASSUMPTIONS
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP LL UL DEFINT-ASSUMPTIONS)
writes special variable : (CURRENT-ASSUMPTIONS)
60 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE&PUSH 4)                   ; DEFINT-ASSUMPTIONS
14    (CONST&PUSH 5)                      ; NOASK
15    (CALL1 6)                           ; MAKE-DEFINT-ASSUMPTIONS
17    (SETVALUE 7)                        ; CURRENT-ASSUMPTIONS
19    (UNWIND-PROTECT-OPEN L98)
22    (GETVALUE&PUSH 3)                   ; UL
24    (JMPIFNOTEQTO 8 L40)                ; $INF
27    (GETVALUE&PUSH 2)                   ; LL
29    (JMPIFNOTEQTO 9 L40)                ; $MINF
32    (GETVALUE&PUSH 0)                   ; EXP
34    (GETVALUE&PUSH 1)                   ; VAR
36    (CALL2 10)                          ; MTOINF
38    (JMPIF1 L97)
40    L40
40    (GETVALUE&PUSH 3)                   ; UL
42    (JMPIFNOTEQTO 8 L58)                ; $INF
45    (GETVALUE&PUSH 2)                   ; LL
47    (JMPIFNOTEQTO 11 L58)               ; 0
50    (GETVALUE&PUSH 0)                   ; EXP
52    (GETVALUE&PUSH 1)                   ; VAR
54    (CALL2 12)                          ; ZTOINF
56    (JMPIF1 L97)
58    L58
58    (GETVALUE&PUSH 2)                   ; LL
60    (JMPIFNOTEQTO 11 L83)               ; 0
63    (GETVALUE&PUSH 1)                   ; VAR
65    (GETVALUE&PUSH 3)                   ; UL
67    (CALL2&JMPIFNOT 13 L83)             ; FREEOF
70    (GETVALUE&PUSH 3)                   ; UL
72    (CALL1&PUSH 14)                     ; $ASKSIGN
74    (JMPIFNOTEQTO 15 L83)               ; $POS
77    (GETVALUE&PUSH 0)                   ; EXP
79    (CALL1 16)                          ; ZTO1
81    (JMPIF1 L97)
83    L83
83    (GETVALUE&PUSH 0)                   ; EXP
85    (GETVALUE&PUSH 1)                   ; VAR
87    (GETVALUE&PUSH 2)                   ; LL
89    (GETVALUE&PUSH 3)                   ; UL
91    (CALL 4 17)                         ; DINTEGRATE
94    (UNWIND-PROTECT-NORMAL-EXIT)
95    (JMP L98)
97    L97
97    (UNWIND-PROTECT-NORMAL-EXIT)
98    L98
98    (LOADI&PUSH 0 0 0)
102   (GETVALUE&PUSH 4)                   ; DEFINT-ASSUMPTIONS
104   (CALL2 18)                          ; RESTORE-DEFINT-ASSUMPTIONS
106   (UNWIND-PROTECT-CLOSE)
107   (SKIP 1)
109   (UNBIND 4)
111   (SKIP&RET 5)


Disassembly of function #:|(DEFUN DINTEGRATE (EXP VAR LL ...) ...)-28|
(CONST 0) = DINTEGRATE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DINTEGRATE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DINTEGRATE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DINTEGRATE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DINTEGRATE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DINTEGRATE
8     (SKIP&RET 1)


Disassembly of function DINTEGRATE
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = ANS
(CONST 5) = ARG
(CONST 6) = SCFLAG
(CONST 7) = *DFLAG
(CONST 8) = $%EMODE
(CONST 9) = SIN-COS-RECUR
(CONST 10) = OSCIP
(CONST 11) = INTSC1
(CONST 12) = RAD-POLY-RECUR
(CONST 13) = (%LOG)
(CONST 14) = NOTINVOLVE
(CONST 15) = %EINVOLVE
(CONST 16) = METHOD-RADICAL-POLY
(CONST 17) = DINTLOG-RECUR
(CONST 18) = 2
(CONST 19) = (%LOG)
(CONST 20) = INVOLVE
(CONST 21) = DINTLOG
(CONST 22) = DINTEXP-RECUR
(CONST 23) = DINTEXP
(CONST 24) = RATP
(CONST 25) = $EXPAND
(CONST 26) = ALIKE1
(CONST 27) = INTBYTERM
(CONST 28) = ANTIDERIV
(CONST 29) = INTSUBS
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(ANS DINTEXP-RECUR ARG DINTLOG-RECUR VAR RAD-POLY-RECUR UL LL EXP
 SIN-COS-RECUR)
writes special variables : (ANS ARG SCFLAG)
96 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (NIL)
13    (BIND 4)                            ; ANS
15    (NIL)
16    (BIND 5)                            ; ARG
18    (NIL)
19    (BIND 6)                            ; SCFLAG
21    (NIL)
22    (BIND 7)                            ; *DFLAG
24    (T)
25    (BIND 8)                            ; $%EMODE
27    (GETVALUE 9)                        ; SIN-COS-RECUR
29    (JMPIF L51)
31    (GETVALUE&PUSH 0)                   ; EXP
33    (CALL1&JMPIFNOT 10 L51)             ; OSCIP
36    (T)
37    (SETVALUE 6)                        ; SCFLAG
39    (GETVALUE&PUSH 2)                   ; LL
41    (GETVALUE&PUSH 3)                   ; UL
43    (GETVALUE&PUSH 0)                   ; EXP
45    (CALL 3 11)                         ; INTSC1
48    (JMPIF1 L159)
51    L51
51    (GETVALUE 12)                       ; RAD-POLY-RECUR
53    (JMPIF L80)
55    (GETVALUE&PUSH 0)                   ; EXP
57    (CONST&PUSH 13)                     ; (%LOG)
58    (CALL2&JMPIFNOT 14 L80)             ; NOTINVOLVE
61    (GETVALUE&PUSH 0)                   ; EXP
63    (CALL1&JMPIF 15 L80)                ; %EINVOLVE
66    (GETVALUE&PUSH 0)                   ; EXP
68    (GETVALUE&PUSH 1)                   ; VAR
70    (GETVALUE&PUSH 2)                   ; LL
72    (GETVALUE&PUSH 3)                   ; UL
74    (CALL 4 16)                         ; METHOD-RADICAL-POLY
77    (JMPIF1 L159)
80    L80
80    (GETVALUE&PUSH 17)                  ; DINTLOG-RECUR
82    (JMPIFEQTO 18 L102)                 ; 2
85    (GETVALUE&PUSH 0)                   ; EXP
87    (CONST&PUSH 19)                     ; (%LOG)
88    (CALL2 20)                          ; INVOLVE
90    (SETVALUE 5)                        ; ARG
92    (JMPIFNOT L102)
94    (GETVALUE&PUSH 0)                   ; EXP
96    (GETVALUE&PUSH 5)                   ; ARG
98    (CALL2 21)                          ; DINTLOG
100   (JMPIF1 L159)
102   L102
102   (GETVALUE 22)                       ; DINTEXP-RECUR
104   (JMPIF L122)
106   (GETVALUE&PUSH 0)                   ; EXP
108   (CALL1 15)                          ; %EINVOLVE
110   (SETVALUE 5)                        ; ARG
112   (JMPIFNOT L122)
114   (GETVALUE&PUSH 0)                   ; EXP
116   (GETVALUE&PUSH 1)                   ; VAR
118   (CALL2 23)                          ; DINTEXP
120   (JMPIF1 L159)
122   L122
122   (GETVALUE&PUSH 0)                   ; EXP
124   (GETVALUE&PUSH 1)                   ; VAR
126   (CALL2&JMPIF 24 L150)               ; RATP
129   (GETVALUE&PUSH 0)                   ; EXP
131   (CALL1 25)                          ; $EXPAND
133   (SETVALUE 4)                        ; ANS
135   (JMPIFNOT L150)
137   (PUSH)
138   (GETVALUE&PUSH 0)                   ; EXP
140   (CALL2&JMPIF 26 L150)               ; ALIKE1
143   (GETVALUE&PUSH 4)                   ; ANS
145   (T&PUSH)
146   (CALL2 27)                          ; INTBYTERM
148   (JMPIF1 L159)
150   L150
150   (GETVALUE&PUSH 0)                   ; EXP
152   (CALL1 28)                          ; ANTIDERIV
154   (SETVALUE 4)                        ; ANS
156   (JMPIF L163)
158   (NIL)
159   L159
159   (UNBIND 9)
161   (SKIP&RET 5)
163   L163
163   (PUSH)
164   (GETVALUE&PUSH 2)                   ; LL
166   (GETVALUE&PUSH 3)                   ; UL
168   (CALL 3 29)                         ; INTSUBS
171   (JMP L159)


Disassembly of function #:|(DEFUN METHOD-RADICAL-POLY (EXP VAR LL ...) ...)-29|
(CONST 0) = METHOD-RADICAL-POLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE METHOD-RADICAL-POLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; METHOD-RADICAL-POLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; METHOD-RADICAL-POLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE METHOD-RADICAL-POLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; METHOD-RADICAL-POLY
8     (SKIP&RET 1)


Disassembly of function METHOD-RADICAL-POLY
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = RAD-POLY-RECUR
(CONST 5) = SININTP
(CONST 6) = ANTIDERIV
(CONST 7) = INTSUBS
(CONST 8) = RATP
(CONST 9) = RATFNT
(CONST 10) = SCFLAG
(CONST 11) = $INF
(CONST 12) = RADIC
(CONST 13) = KINDP34
(CONST 14) = CV
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SCFLAG UL LL VAR EXP)
61 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (T)
13    (BIND 4)                            ; RAD-POLY-RECUR
15    (NIL&PUSH)
16    (GETVALUE&PUSH 0)                   ; EXP
18    (GETVALUE&PUSH 1)                   ; VAR
20    (CALL2&JMPIFNOT 5 L40)              ; SININTP
23    (GETVALUE&PUSH 0)                   ; EXP
25    (CALL1 6)                           ; ANTIDERIV
27    (STORE 0)
28    (JMPIFNOT L40)
30    (PUSH)
31    (GETVALUE&PUSH 2)                   ; LL
33    (GETVALUE&PUSH 3)                   ; UL
35    (CALL 3 7)                          ; INTSUBS
38    (JMPIF1 L99)
40    L40
40    (GETVALUE&PUSH 0)                   ; EXP
42    (GETVALUE&PUSH 1)                   ; VAR
44    (CALL2&JMPIFNOT 8 L54)              ; RATP
47    (GETVALUE&PUSH 0)                   ; EXP
49    (CALL1 9)                           ; RATFNT
51    (STORE 0)
52    (JMPIF1 L99)
54    L54
54    (GETVALUE&PUSH 0)                   ; EXP
56    (CALL1 6)                           ; ANTIDERIV
58    (STORE 0)
59    (JMPIFNOT L71)
61    (PUSH)
62    (GETVALUE&PUSH 2)                   ; LL
64    (GETVALUE&PUSH 3)                   ; UL
66    (CALL 3 7)                          ; INTSUBS
69    (JMPIF1 L99)
71    L71
71    (GETVALUE 10)                       ; SCFLAG
73    (JMPIF L98)
75    (GETVALUE&PUSH 3)                   ; UL
77    (JMPIFEQTO 11 L98)                  ; $INF
80    (GETVALUE&PUSH 0)                   ; EXP
82    (GETVALUE&PUSH 1)                   ; VAR
84    (CALL2&JMPIFNOT 12 L98)             ; RADIC
87    (CALL0 13)                          ; KINDP34
89    (JMPIFNOT L98)
91    (GETVALUE&PUSH 0)                   ; EXP
93    (CALL1 14)                          ; CV
95    (STORE 0)
96    (JMPIF1 L99)
98    L98
98    (NIL)
99    L99
99    (SKIP 1)
101   (UNBIND 5)
103   (SKIP&RET 5)


Disassembly of function #:|(DEFUN PRINCIPAL-VALUE-INTEGRAL (EXP VAR LL ...) ...)-30|
(CONST 0) = PRINCIPAL-VALUE-INTEGRAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PRINCIPAL-VALUE-INTEGRAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRINCIPAL-VALUE-INTEGRAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PRINCIPAL-VALUE-INTEGRAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PRINCIPAL-VALUE-INTEGRAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PRINCIPAL-VALUE-INTEGRAL
8     (SKIP&RET 1)


Disassembly of function PRINCIPAL-VALUE-INTEGRAL
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = $LOGABS
(CONST 5) = ANTIDERIV
(CONST 6) = ASK
(CONST 7) = ORDER-LIMITS
(CONST 8) = TAKE-PRINCIPAL
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL EXP)
35 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; EXP
3     (LOAD 7)
4     (BIND 1)                            ; VAR
6     (LOAD 9)
7     (BIND 2)                            ; LL
9     (LOAD 11)
10    (BIND 3)                            ; UL
12    (NIL)
13    (BIND 4)                            ; $LOGABS
15    (NIL&PUSH)
16    (GETVALUE&PUSH 0)                   ; EXP
18    (CALL1 5)                           ; ANTIDERIV
20    (STORE 0)
21    (JMPIF L47)
23    (NIL)
24    L24
24    (SKIP 1)
26    (UNBIND 5)
28    (SKIP&RET 6)
30    L30
30    (CONST&PUSH 6)                      ; ASK
31    (CALL1 7)                           ; ORDER-LIMITS
33    (LOAD&PUSH 0)
34    (GETVALUE&PUSH 2)                   ; LL
36    (GETVALUE&PUSH 3)                   ; UL
38    (LOAD&PUSH 20)
39    (CALL 4 8)                          ; TAKE-PRINCIPAL
42    (JMPIF1 L24)
44    (NIL)
45    (JMP L24)
47    L47
47    (LOAD&JMPIF 17 L30)
50    (NIL)
51    (JMP L24)


Disassembly of function #:|(DEFUN TAKE-PRINCIPAL (ANTI-DERIV LL UL ...) ...)-31|
(CONST 0) = TAKE-PRINCIPAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TAKE-PRINCIPAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TAKE-PRINCIPAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TAKE-PRINCIPAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TAKE-PRINCIPAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TAKE-PRINCIPAL
8     (SKIP&RET 1)


Disassembly of function TAKE-PRINCIPAL
(CONST 0) = LL
(CONST 1) = UL
(CONST 2) = ANS
(CONST 3) = (%LOG)
(CONST 4) = INVOLVE
(CONST 5) = $LOGCONTRACT
(CONST 6) = 0
(CONST 7) = INTERVAL-LIST
(CONST 8) = EPSILON
(CONST 9) = ADD*
(CONST 10) = -1
(CONST 11) = MUL*
(CONST 12) = INTSUBS
(CONST 13) = %LOG
(CONST 14) = FREEOF
(CONST 15) = $PLUS
(CONST 16) = GET-LIMIT
(CONST 17) = PRIN-INF
(CONST 18) = $INF
(CONST 19) = $INFINITY
(CONST 20) = FREE
(CONST 21) = $IND
(CONST 22) = $MINF
(CONST 23) = AMONG
(CONST 24) = $UND
(CONST 25) = DIVERG
(CONST 26) = PRINCIPAL
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS UL LL)
writes special variable : (ANS)
95 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; LL
3     (LOAD 5)
4     (BIND 1)                            ; UL
6     (NIL)
7     (BIND 2)                            ; ANS
9     (NIL&PUSH)
10    (LOAD&PUSH 14)
11    (CONST&PUSH 3)                      ; (%LOG)
12    (CALL2&JMPIF 4 L141)                ; INVOLVE
16    (LOAD 14)
17    L17
17    (STORE 14)
19    (CONST 6)                           ; 0
20    (SETVALUE 2)                        ; ANS
22    (LOAD&PUSH 11)
23    (GETVALUE&PUSH 0)                   ; LL
25    (GETVALUE&PUSH 1)                   ; UL
27    (CALL 3 7)                          ; INTERVAL-LIST
30    (STORE 0)
31    (CDR&PUSH)
32    (LOAD&PUSH 1)
33    (LOAD&JMPIFNOT 1 L70)
36    L36
36    (GETVALUE&PUSH 2)                   ; ANS
38    (LOAD&PUSH 17)
39    (LOAD 2)
40    (CAR)
41    (CAR&PUSH)
42    (CONST&PUSH 8)                      ; EPSILON
43    (CALL2&PUSH 9)                      ; ADD*
45    (LOAD 4)
46    (CAR)
47    (CAR&PUSH)
48    (CONST&PUSH 10)                     ; -1
49    (CONST&PUSH 8)                      ; EPSILON
50    (CALL2&PUSH 11)                     ; MUL*
52    (CALL2&PUSH 9)                      ; ADD*
54    (CALL&PUSH 3 12)                    ; INTSUBS
57    (CALL2 9)                           ; ADD*
59    (SETVALUE 2)                        ; ANS
61    (LOAD&CDR&PUSH 1)
63    (LOAD&CDR&STORE 1)
65    (POP&STORE 1)
67    (LOAD&JMPIF 1 L36)
70    L70
70    (SKIP 2)
72    (CONST&PUSH 13)                     ; %LOG
73    (GETVALUE&PUSH 2)                   ; ANS
75    (CALL2&JMPIF 14 L84)                ; FREEOF
78    (GETVALUE&PUSH 2)                   ; ANS
80    (CALL1 5)                           ; $LOGCONTRACT
82    (SETVALUE 2)                        ; ANS
84    L84
84    (GETVALUE&PUSH 2)                   ; ANS
86    (CONST&PUSH 8)                      ; EPSILON
87    (CONST&PUSH 6)                      ; 0
88    (CONST&PUSH 15)                     ; $PLUS
89    (CALL&PUSH 4 16)                    ; GET-LIMIT
92    (CONST&PUSH 17)                     ; PRIN-INF
93    (CONST&PUSH 18)                     ; $INF
94    (CALL 3 16)                         ; GET-LIMIT
97    (SETVALUE 2)                        ; ANS
99    (JMPIFNOT L147)
101   (GETVALUE&PUSH 2)                   ; ANS
103   (CONST&PUSH 19)                     ; $INFINITY
104   (CALL2&JMPIFNOT 20 L147)            ; FREE
107   (GETVALUE&PUSH 2)                   ; ANS
109   (CONST&PUSH 21)                     ; $IND
110   (CALL2&JMPIFNOT 20 L147)            ; FREE
113   (CONST&PUSH 22)                     ; $MINF
114   (GETVALUE&PUSH 2)                   ; ANS
116   (CALL2&JMPIF 23 L150)               ; AMONG
119   (CONST&PUSH 18)                     ; $INF
120   (GETVALUE&PUSH 2)                   ; ANS
122   (CALL2&JMPIF 23 L150)               ; AMONG
125   (CONST&PUSH 24)                     ; $UND
126   (GETVALUE&PUSH 2)                   ; ANS
128   (CALL2&JMPIF 23 L150)               ; AMONG
131   (CALL0 26)                          ; PRINCIPAL
133   (GETVALUE 2)                        ; ANS
135   L135
135   (SKIP 1)
137   (UNBIND 3)
139   (SKIP&RET 5)
141   L141
141   (LOAD&PUSH 14)
142   (CALL1 5)                           ; $LOGCONTRACT
144   (JMP L17)
147   L147
147   (NIL)
148   (JMP L135)
150   L150
150   (CALL0 25)                          ; DIVERG
152   (JMP L135)


Disassembly of function #:|(DEFUN INTERVAL-LIST (POLE-LIST LL UL) ...)-32|
(CONST 0) = INTERVAL-LIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTERVAL-LIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTERVAL-LIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTERVAL-LIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTERVAL-LIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTERVAL-LIST
8     (SKIP&RET 1)


Disassembly of function INTERVAL-LIST
(CONST 0) = LL
(CONST 1) = UL
(CONST 2) = $INF
(CONST 3) = PRIN-INF
(CONST 4) = IGNORED
(CONST 5) = $MINF
(CONST 6) = -1
(CONST 7) = MUL*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LL UL)
writes special variables : (LL UL)
68 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; LL
3     (LOAD 4)
4     (BIND 1)                            ; UL
6     (LOAD 9)
7     (CAR)
8     (CAR&PUSH)
9     (LOAD&PUSH 10)
10    (PUSH-UNBOUND 1)
12    (CALLS1 156)                        ; LAST
14    (CAR)
15    (CAR&PUSH)
16    (GETVALUE&PUSH 1)                   ; UL
18    (LOAD 1)
19    (JMPIFEQ L74)
21    (GETVALUE&PUSH 1)                   ; UL
23    (JMPIFNOTEQTO 2 L29)                ; $INF
26    (CONST 3)                           ; PRIN-INF
27    (SETVALUE 1)                        ; UL
29    L29
29    (LOAD&PUSH 11)
30    (GETVALUE&PUSH 1)                   ; UL
32    (CONST 4)                           ; IGNORED
33    (CONS&PUSH)
34    (LIST&PUSH 1)
36    (CALLSR&STORE 2 34 11)              ; APPEND
40    L40
40    (GETVALUE&PUSH 0)                   ; LL
42    (LOAD 2)
43    (JMPIFEQ L89)
45    (GETVALUE&PUSH 0)                   ; LL
47    (JMPIFNOTEQTO 5 L56)                ; $MINF
50    (CONST&PUSH 6)                      ; -1
51    (CONST&PUSH 3)                      ; PRIN-INF
52    (CALL2 7)                           ; MUL*
54    (SETVALUE 0)                        ; LL
56    L56
56    (GETVALUE&PUSH 0)                   ; LL
58    (CONST 4)                           ; IGNORED
59    (CONS&PUSH)
60    (LIST&PUSH 1)
62    (LOAD&PUSH 12)
63    (CALLSR&STORE 2 34 11)              ; APPEND
67    L67
67    (SKIP 2)
69    (LOAD 9)
70    (UNBIND 2)
72    (SKIP&RET 4)
74    L74
74    (GETVALUE&PUSH 1)                   ; UL
76    (JMPIFNOTEQTO 2 L40)                ; $INF
79    (CONST&PUSH 3)                      ; PRIN-INF
80    (CONST&PUSH 2)                      ; $INF
81    (LOAD&PUSH 13)
82    (PUSH-UNBOUND 3)
84    (CALLS1&STORE 172 11)               ; SUBST
87    (JMP L40)
89    L89
89    (GETVALUE&PUSH 0)                   ; LL
91    (JMPIFNOTEQTO 5 L67)                ; $MINF
94    (CONST&PUSH 6)                      ; -1
95    (CONST&PUSH 3)                      ; PRIN-INF
96    (CALL2&PUSH 7)                      ; MUL*
98    (CONST&PUSH 5)                      ; $MINF
99    (LOAD&PUSH 13)
100   (PUSH-UNBOUND 3)
102   (CALLS1&STORE 172 11)               ; SUBST
105   (JMP L67)


Disassembly of function #:|(DEFUN CV (EXP) ...)-33|
(CONST 0) = CV
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CV>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CV
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CV
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CV>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CV
8     (SKIP&RET 1)


Disassembly of function CV
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = REAL-INFINITIES
(CONST 3) = MEMQ
(CONST 4) = UL
(CONST 5) = VAR
(CONST 6) = MUL
(CONST 7) = ADD
(CONST 8) = 1
(CONST 9) = DIV*
(CONST 10) = YX
(CONST 11) = INTCV3
(CONST 12) = 0
(CONST 13) = $INF
(CONST 14) = METHOD-BY-LIMITS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR UL REAL-INFINITIES LL)
34 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 1)                   ; LL
5     (GETVALUE&PUSH 2)                   ; REAL-INFINITIES
7     (CALL2&JMPIFNOT 3 L45)              ; MEMQ
10    (NOT)
11    (JMPIFNOT1 L42)
13    L13
13    (GETVALUE&PUSH 1)                   ; LL
15    (GETVALUE&PUSH 4)                   ; UL
17    (GETVALUE&PUSH 5)                   ; VAR
19    (CALL2&PUSH 6)                      ; MUL
21    (CALL2&PUSH 7)                      ; ADD
23    (CONST&PUSH 8)                      ; 1
24    (GETVALUE&PUSH 5)                   ; VAR
26    (CALL2&PUSH 7)                      ; ADD
28    (CALL2&PUSH 9)                      ; DIV*
30    (NIL&PUSH)
31    (CONST&PUSH 10)                     ; YX
32    (CALL&PUSH 3 11)                    ; INTCV3
35    (GETVALUE&PUSH 5)                   ; VAR
37    (CONST&PUSH 12)                     ; 0
38    (CONST&PUSH 13)                     ; $INF
39    (CALL 4 14)                         ; METHOD-BY-LIMITS
42    L42
42    (UNBIND1)
43    (SKIP&RET 2)
45    L45
45    (GETVALUE&PUSH 4)                   ; UL
47    (GETVALUE&PUSH 2)                   ; REAL-INFINITIES
49    (CALL2 3)                           ; MEMQ
51    (NOT)
52    (JMPIFNOT1 L42)
54    (JMP L13)


Disassembly of function #:|(DEFUN RATFNT (EXP) ...)-34|
(CONST 0) = RATFNT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATFNT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATFNT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATFNT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATFNT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATFNT
8     (SKIP&RET 1)


Disassembly of function RATFNT
(CONST 0) = EXP
(CONST 1) = PQR
(CONST 2) = E
(CONST 3) = 0
(CONST 4) = CV
(CONST 5) = LL
(CONST 6) = UL
(CONST 7) = EEZZ
(CONST 8) = DN*
(CONST 9) = DIV*
(CONST 10) = ADD
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DN* UL LL E EXP)
39 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1 1)                           ; PQR
7     (BIND 2)                            ; E
9     (GETVALUE 2)                        ; E
11    (CAR&PUSH)
12    (JMPIFEQTO 3 L46)                   ; 0
15    (GETVALUE 2)                        ; E
17    (CDR&PUSH)
18    (JMPIFEQTO 3 L53)                   ; 0
21    (GETVALUE 2)                        ; E
23    (CAR&PUSH)
24    (GETVALUE&PUSH 5)                   ; LL
26    (GETVALUE&PUSH 6)                   ; UL
28    (CALL&PUSH 3 7)                     ; EEZZ
31    (GETVALUE 2)                        ; E
33    (CDR&PUSH)
34    (GETVALUE&PUSH 8)                   ; DN*
36    (CALL2&PUSH 9)                      ; DIV*
38    (CALL1&PUSH 4)                      ; CV
40    (CALL2 10)                          ; ADD
42    (UNBIND1)
43    L43
43    (UNBIND1)
44    (SKIP&RET 2)
46    L46
46    (GETVALUE&PUSH 0)                   ; EXP
48    (CALL1 4)                           ; CV
50    (UNBIND1)
51    (JMP L43)
53    L53
53    (GETVALUE 2)                        ; E
55    (CAR&PUSH)
56    (GETVALUE&PUSH 5)                   ; LL
58    (GETVALUE&PUSH 6)                   ; UL
60    (CALL 3 7)                          ; EEZZ
63    (UNBIND1)
64    (JMP L43)


Disassembly of function #:|(DEFUN PQR (E) ...)-35|
(CONST 0) = PQR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PQR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PQR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PQR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PQR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PQR
8     (SKIP&RET 1)


Disassembly of function PQR
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = VARLIST
(CONST 3) = NEWVAR
(CONST 4) = RATREP*
(CONST 5) = RATDENOMINATOR
(CONST 6) = PDIS
(CONST 7) = DN*
(CONST 8) = RATNUMERATOR
(CONST 9) = PDIVIDE
(CONST 10) = RDIS
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR)
writes special variables : (DN* E)
32 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAR
5     (LIST 1)
7     (BIND 2)                            ; VARLIST
9     (GETVALUE&PUSH 0)                   ; E
11    (CALL1 3)                           ; NEWVAR
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1 4)                           ; RATREP*
17    (CDR)
18    (SETVALUE 0)                        ; E
20    (PUSH)
21    (CALL1&PUSH 5)                      ; RATDENOMINATOR
23    (CALL1 6)                           ; PDIS
25    (SETVALUE 7)                        ; DN*
27    (GETVALUE&PUSH 0)                   ; E
29    (CALL1&PUSH 8)                      ; RATNUMERATOR
31    (GETVALUE&PUSH 0)                   ; E
33    (CALL1&PUSH 5)                      ; RATDENOMINATOR
35    (CALL2 9)                           ; PDIVIDE
37    (SETVALUE 0)                        ; E
39    (CAR&PUSH)
40    (CALL1&PUSH 10)                     ; RDIS
42    (CALL1&PUSH 11)                     ; SIMPLIFY
44    (GETVALUE 0)                        ; E
46    (CDR)
47    (CAR&PUSH)
48    (CALL1&PUSH 10)                     ; RDIS
50    (CALL1 11)                          ; SIMPLIFY
52    (CONS)
53    (UNBIND 2)
55    (SKIP&RET 2)


Disassembly of function #:|(DEFUN INTBYTERM (EXP *NODIVERG) ...)-36|
(CONST 0) = INTBYTERM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTBYTERM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTBYTERM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTBYTERM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTBYTERM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTBYTERM
8     (SKIP&RET 1)


Disassembly of function INTBYTERM
(CONST 0) = EXP
(CONST 1) = *NODIVERG
(CONST 2) = MPLUSP
(CONST 3) = DIVERGENT
(CONST 4) = #<COMPILED-CLOSURE INTBYTERM-1>
(CONST 5) = ANDMAPCAR
(CONST 6) = ANS
(CONST 7) = ANTIDERIV
(CONST 8) = LL
(CONST 9) = UL
(CONST 10) = INTSUBS
(CONST 11) = ADDN
(CONST 12) = SRATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL ANS EXP)
writes special variable : (ANS)
54 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; *NODIVERG
6     (GETVALUE&PUSH 0)                   ; EXP
8     (GETVALUE&PUSH 0)                   ; EXP
10    (CALL1&JMPIFNOT 2 L74)              ; MPLUSP
13    (CONST 3)                           ; DIVERGENT
14    (CATCH-OPEN L23)
16    (CONST&PUSH 4)                      ; #<COMPILED-CLOSURE INTBYTERM-1>
17    (GETVALUE 0)                        ; EXP
19    (CDR&PUSH)
20    (CALL2 5)                           ; ANDMAPCAR
22    (CATCH-CLOSE)
23    L23
23    (BIND 6)                            ; ANS
25    (GETVALUE 6)                        ; ANS
27    (JMPIFNOT L46)
29    (GETVALUE&PUSH 6)                   ; ANS
31    (JMPIFEQTO 3 L60)                   ; DIVERGENT
34    (GETVALUE&PUSH 6)                   ; ANS
36    (NIL&PUSH)
37    (CALL2&PUSH 11)                     ; ADDN
39    (CALL1 12)                          ; SRATSIMP
41    L41
41    (UNBIND1)
42    (SKIP 1)
44    (JMP L77)
46    L46
46    (NIL)
47    (JMP L41)
49    L49
49    (PUSH)
50    (GETVALUE&PUSH 8)                   ; LL
52    (GETVALUE&PUSH 9)                   ; UL
54    (CALL 3 10)                         ; INTSUBS
57    (UNBIND1)
58    (JMP L41)
60    L60
60    (NIL)
61    (BIND 1)                            ; *NODIVERG
63    (LOAD&PUSH 6)
64    (CALL1 7)                           ; ANTIDERIV
66    (SETVALUE 6)                        ; ANS
68    (JMPIF L49)
70    (NIL)
71    (UNBIND1)
72    (JMP L41)
74    L74
74    (NIL)
75    (SKIP 1)
77    L77
77    (UNBIND 2)
79    (SKIP&RET 3)


Disassembly of function INTBYTERM-1
(CONST 0) = *DEF2*
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = DEFINT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR)
9 byte-code instructions:
0     (T)
1     (BIND 0)                            ; *DEF2*
3     (LOAD&PUSH 4)
4     (GETVALUE&PUSH 1)                   ; VAR
6     (GETVALUE&PUSH 2)                   ; LL
8     (GETVALUE&PUSH 3)                   ; UL
10    (CALL 4 4)                          ; DEFINT
13    (UNBIND1)
14    (SKIP&RET 2)


Disassembly of function #:|(DEFUN KINDP34 NIL ...)-37|
(CONST 0) = KINDP34
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE KINDP34>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; KINDP34
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; KINDP34
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE KINDP34>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; KINDP34
8     (SKIP&RET 1)


Disassembly of function KINDP34
(CONST 0) = EXP
(CONST 1) = NUMDEN
(CONST 2) = DN*
(CONST 3) = D
(CONST 4) = VAR
(CONST 5) = LL
(CONST 6) = $PLUS
(CONST 7) = $LIMIT
(CONST 8) = ZEROP1
(CONST 9) = -1
(CONST 10) = MUL*
(CONST 11) = ADD*
(CONST 12) = LIMIT-POLE
(CONST 13) = $YES
(CONST 14) = A
(CONST 15) = UL
(CONST 16) = $MINUS
(CONST 17) = B
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B A UL LL VAR D DN* EXP)
60 byte-code instructions:
0     (GETVALUE&PUSH 0)                   ; EXP
2     (CALL1 1)                           ; NUMDEN
4     (GETVALUE 2)                        ; DN*
6     (BIND 3)                            ; D
8     (GETVALUE&PUSH 3)                   ; D
10    (GETVALUE&PUSH 4)                   ; VAR
12    (GETVALUE&PUSH 5)                   ; LL
14    (CONST&PUSH 6)                      ; $PLUS
15    (CALL&PUSH 4 7)                     ; $LIMIT
18    (CALL1&JMPIFNOT 8 L45)              ; ZEROP1
21    (GETVALUE&PUSH 0)                   ; EXP
23    (CONST&PUSH 9)                      ; -1
24    (GETVALUE&PUSH 5)                   ; LL
26    (CALL2&PUSH 10)                     ; MUL*
28    (GETVALUE&PUSH 4)                   ; VAR
30    (CALL2&PUSH 11)                     ; ADD*
32    (CALL2&PUSH 11)                     ; ADD*
34    (GETVALUE&PUSH 4)                   ; VAR
36    (GETVALUE&PUSH 5)                   ; LL
38    (CONST&PUSH 6)                      ; $PLUS
39    (CALL&PUSH 4 12)                    ; LIMIT-POLE
42    (JMPIFEQTO 13 L98)                  ; $YES
45    L45
45    (NIL)
46    L46
46    (BIND 14)                           ; A
48    (GETVALUE&PUSH 3)                   ; D
50    (GETVALUE&PUSH 4)                   ; VAR
52    (GETVALUE&PUSH 15)                  ; UL
54    (CONST&PUSH 16)                     ; $MINUS
55    (CALL&PUSH 4 7)                     ; $LIMIT
58    (CALL1&JMPIFNOT 8 L85)              ; ZEROP1
61    (GETVALUE&PUSH 0)                   ; EXP
63    (GETVALUE&PUSH 15)                  ; UL
65    (CONST&PUSH 9)                      ; -1
66    (GETVALUE&PUSH 4)                   ; VAR
68    (CALL2&PUSH 10)                     ; MUL*
70    (CALL2&PUSH 11)                     ; ADD*
72    (CALL2&PUSH 11)                     ; ADD*
74    (GETVALUE&PUSH 4)                   ; VAR
76    (GETVALUE&PUSH 15)                  ; UL
78    (CONST&PUSH 16)                     ; $MINUS
79    (CALL&PUSH 4 12)                    ; LIMIT-POLE
82    (JMPIFEQTO 13 L101)                 ; $YES
85    L85
85    (NIL)
86    L86
86    (BIND 17)                           ; B
88    (GETVALUE 14)                       ; A
90    (JMPIF1 L94)
92    (GETVALUE 17)                       ; B
94    L94
94    (UNBIND 3)
96    (SKIP&RET 1)
98    L98
98    (T)
99    (JMP L46)
101   L101
101   (T)
102   (JMP L86)


Disassembly of function #:|(DEFUN DIVERG NIL ...)-38|
(CONST 0) = DIVERG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DIVERG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DIVERG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DIVERG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DIVERG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DIVERG
8     (SKIP&RET 1)


Disassembly of function DIVERG
(CONST 0) = *NODIVERG
(CONST 1) = DIVERGENT
(CONST 2) = "Integral is divergent"
(CONST 3) = MERROR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*NODIVERG)
9 byte-code instructions:
0     (GETVALUE 0)                        ; *NODIVERG
2     (JMPIF L9)
4     (CONST&PUSH 2)                      ; "Integral is divergent"
5     (CALL1 3)                           ; MERROR
7     (SKIP&RET 1)
9     L9
9     (CONST&PUSH 1)                      ; DIVERGENT
10    (CONST 1)                           ; DIVERGENT
11    (THROW)


Disassembly of function #:|(DEFUN MAKE-DEFINT-ASSUMPTIONS (ASK-OR-NOT) ...)-39|
(CONST 0) = MAKE-DEFINT-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKE-DEFINT-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKE-DEFINT-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKE-DEFINT-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKE-DEFINT-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKE-DEFINT-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function MAKE-DEFINT-ASSUMPTIONS
(CONST 0) = ORDER-LIMITS
(CONST 1) = FORGET
(CONST 2) = DEFINT-ASSUMPTIONS
(CONST 3) = LL
(CONST 4) = $INF
(CONST 5) = $POS
(CONST 6) = $MINF
(CONST 7) = $NEG
(CONST 8) = $LIMIT
(CONST 9) = $SIGN
(CONST 10) = UL
(CONST 11) = -1
(CONST 12) = MUL*
(CONST 13) = ADD*
(CONST 14) = (MGREATERP)
(CONST 15) = VAR
(CONST 16) = ASSUME
(CONST 17) = (MGREATERP)
(CONST 18) = (MGREATERP)
(CONST 19) = (MGREATERP)
(CONST 20) = (MGREATERP)
(CONST 21) = (0)
(CONST 22) = (MGREATERP)
(CONST 23) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR UL LL DEFINT-ASSUMPTIONS)
writes special variable : (DEFINT-ASSUMPTIONS)
122 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&JMPIFNOT 0 L155)             ; ORDER-LIMITS
5     (CONST&PUSH 1)                      ; FORGET
6     (GETVALUE&PUSH 2)                   ; DEFINT-ASSUMPTIONS
8     (CALLSR 0 24)                       ; MAPC
11    (NIL)
12    (SETVALUE 2)                        ; DEFINT-ASSUMPTIONS
14    (GETVALUE&PUSH 3)                   ; LL
16    (JMPIFEQTO 4 L158)                  ; $INF
20    (GETVALUE&PUSH 3)                   ; LL
22    (JMPIFEQTO 6 L162)                  ; $MINF
26    (GETVALUE&PUSH 3)                   ; LL
28    (CALL1&PUSH 8)                      ; $LIMIT
30    (CALL1 9)                           ; $SIGN
32    L32
32    (PUSH)
33    (GETVALUE&PUSH 10)                  ; UL
35    (JMPIFEQTO 4 L166)                  ; $INF
39    (GETVALUE&PUSH 10)                  ; UL
41    (JMPIFEQTO 6 L170)                  ; $MINF
45    (GETVALUE&PUSH 10)                  ; UL
47    (CALL1&PUSH 8)                      ; $LIMIT
49    (CALL1 9)                           ; $SIGN
51    L51
51    (PUSH)
52    (GETVALUE&PUSH 10)                  ; UL
54    (JMPIFNOTEQTO 4 L63)                ; $INF
57    (GETVALUE&PUSH 3)                   ; LL
59    (JMPIFNOTEQTO 4 L174)               ; $INF
63    L63
63    (GETVALUE&PUSH 10)                  ; UL
65    (JMPIFNOTEQTO 6 L74)                ; $MINF
68    (GETVALUE&PUSH 3)                   ; LL
70    (JMPIFNOTEQTO 6 L178)               ; $MINF
74    L74
74    (GETVALUE&PUSH 10)                  ; UL
76    (CONST&PUSH 11)                     ; -1
77    (GETVALUE&PUSH 3)                   ; LL
79    (CALL2&PUSH 12)                     ; MUL*
81    (CALL2&PUSH 13)                     ; ADD*
83    (CALL1&PUSH 8)                      ; $LIMIT
85    (CALL1 9)                           ; $SIGN
87    L87
87    (PUSH)
88    (LOAD&PUSH 0)
89    (JMPIFEQTO 5 L182)                  ; $POS
93    (LOAD&PUSH 0)
94    (JMPIFNOTEQTO 7 L120)               ; $NEG
97    (CONST&PUSH 18)                     ; (MGREATERP)
98    (GETVALUE&PUSH 15)                  ; VAR
100   (GETVALUE&PUSH 10)                  ; UL
102   (LIST&PUSH 3)
104   (CALL1&PUSH 16)                     ; ASSUME
106   (CONST&PUSH 19)                     ; (MGREATERP)
107   (GETVALUE 3)                        ; LL
109   L109
109   (PUSH)
110   (GETVALUE&PUSH 15)                  ; VAR
112   (LIST&PUSH 3)
114   (CALL1&PUSH 16)                     ; ASSUME
116   (LIST 2)
118   (SETVALUE 2)                        ; DEFINT-ASSUMPTIONS
120   L120
120   (LOAD&PUSH 2)
121   (JMPIFNOTEQTO 5 L129)               ; $POS
124   (LOAD&PUSH 1)
125   (JMPIFEQTO 5 L197)                  ; $POS
129   L129
129   (LOAD&PUSH 2)
130   (JMPIFNOTEQTO 7 L206)               ; $NEG
134   (LOAD&PUSH 1)
135   (JMPIFNOTEQTO 7 L206)               ; $NEG
139   (CONST&PUSH 22)                     ; (MGREATERP)
140   (CONST&PUSH 23)                     ; 0
141   (GETVALUE&PUSH 15)                  ; VAR
143   (LIST 3)
145   L145
145   (PUSH)
146   (CALL1&PUSH 16)                     ; ASSUME
148   (GETVALUE 2)                        ; DEFINT-ASSUMPTIONS
150   (CONS)
151   (SETVALUE 2)                        ; DEFINT-ASSUMPTIONS
153   (SKIP&RET 5)
155   L155
155   (NIL)
156   (SKIP&RET 2)
158   L158
158   (CONST 5)                           ; $POS
159   (JMP L32)
162   L162
162   (CONST 7)                           ; $NEG
163   (JMP L32)
166   L166
166   (CONST 5)                           ; $POS
167   (JMP L51)
170   L170
170   (CONST 7)                           ; $NEG
171   (JMP L51)
174   L174
174   (CONST 5)                           ; $POS
175   (JMP L87)
178   L178
178   (CONST 7)                           ; $NEG
179   (JMP L87)
182   L182
182   (CONST&PUSH 14)                     ; (MGREATERP)
183   (GETVALUE&PUSH 15)                  ; VAR
185   (GETVALUE&PUSH 3)                   ; LL
187   (LIST&PUSH 3)
189   (CALL1&PUSH 16)                     ; ASSUME
191   (CONST&PUSH 17)                     ; (MGREATERP)
192   (GETVALUE 10)                       ; UL
194   (JMP L109)
197   L197
197   (CONST&PUSH 20)                     ; (MGREATERP)
198   (GETVALUE&PUSH 15)                  ; VAR
200   (CONST 21)                          ; (0)
202   (LIST* 2)
204   (JMP L145)
206   L206
206   (GETVALUE 2)                        ; DEFINT-ASSUMPTIONS
208   (SKIP&RET 5)


Disassembly of function #:|(DEFUN RESTORE-DEFINT-ASSUMPTIONS (OLD-ASSUMPTIONS ASSUMPTIONS) ...)-40|
(CONST 0) = RESTORE-DEFINT-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RESTORE-DEFINT-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RESTORE-DEFINT-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RESTORE-DEFINT-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RESTORE-DEFINT-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RESTORE-DEFINT-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function RESTORE-DEFINT-ASSUMPTIONS
(CONST 0) = FORGET
(CONST 1) = ASSUME
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
19 byte-code instructions:
0     (LOAD&PUSH 1)
1     (LOAD&JMPIFNOT 0 L13)
4     L4
4     (LOAD&CAR&PUSH 0)
6     (CALL1 0)                           ; FORGET
8     (LOAD&CDR&STORE 0)
10    (LOAD&JMPIF 0 L4)
13    L13
13    (SKIP 1)
15    (LOAD&PUSH 2)
16    (LOAD&JMPIFNOT 0 L28)
19    L19
19    (LOAD&CAR&PUSH 0)
21    (CALL1 1)                           ; ASSUME
23    (LOAD&CDR&STORE 0)
25    (LOAD&JMPIF 0 L19)
28    L28
28    (T)
29    (SKIP&RET 4)


Disassembly of function #:|(DEFUN MAKE-GLOBAL-ASSUMPTIONS NIL ...)-41|
(CONST 0) = MAKE-GLOBAL-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKE-GLOBAL-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKE-GLOBAL-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKE-GLOBAL-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKE-GLOBAL-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKE-GLOBAL-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function MAKE-GLOBAL-ASSUMPTIONS
(CONST 0) = ((MGREATERP) *Z* 0)
(CONST 1) = ASSUME
(CONST 2) = GLOBAL-DEFINT-ASSUMPTIONS
(CONST 3) = ((MGREATERP) EPSILON 0)
(CONST 4) = ((MLESSP) EPSILON 1.0E-8)
(CONST 5) = ((MGREATERP) PRIN-INF 1.0E8)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (GLOBAL-DEFINT-ASSUMPTIONS)
writes special variable : (GLOBAL-DEFINT-ASSUMPTIONS)
21 byte-code instructions:
0     (CONST&PUSH 0)                      ; ((MGREATERP) *Z* 0)
1     (CALL1&PUSH 1)                      ; ASSUME
3     (GETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
5     (CONS)
6     (SETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
8     (CONST&PUSH 3)                      ; ((MGREATERP) EPSILON 0)
9     (CALL1&PUSH 1)                      ; ASSUME
11    (GETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
13    (CONS)
14    (SETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
16    (CONST&PUSH 4)                      ; ((MLESSP) EPSILON 1.0E-8)
17    (CALL1&PUSH 1)                      ; ASSUME
19    (GETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
21    (CONS)
22    (SETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
24    (CONST&PUSH 5)                      ; ((MGREATERP) PRIN-INF 1.0E8)
25    (CALL1&PUSH 1)                      ; ASSUME
27    (GETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
29    (CONS)
30    (SETVALUE 2)                        ; GLOBAL-DEFINT-ASSUMPTIONS
32    (SKIP&RET 1)


Disassembly of function #:|(DEFUN FORGET-GLOBAL-ASSUMPTIONS NIL ...)-42|
(CONST 0) = FORGET-GLOBAL-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FORGET-GLOBAL-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FORGET-GLOBAL-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FORGET-GLOBAL-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FORGET-GLOBAL-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FORGET-GLOBAL-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function FORGET-GLOBAL-ASSUMPTIONS
(CONST 0) = GLOBAL-DEFINT-ASSUMPTIONS
(CONST 1) = FORGET
(CONST 2) = INTEGER-INFO
(CONST 3) = I-$REMOVE
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INTEGER-INFO GLOBAL-DEFINT-ASSUMPTIONS)
33 byte-code instructions:
0     (GETVALUE&PUSH 0)                   ; GLOBAL-DEFINT-ASSUMPTIONS
2     (LOAD&JMPIFNOT 0 L14)
5     L5
5     (LOAD&CAR&PUSH 0)
7     (CALL1 1)                           ; FORGET
9     (LOAD&CDR&STORE 0)
11    (LOAD&JMPIF 0 L5)
14    L14
14    (SKIP 1)
16    (GETVALUE 2)                        ; INTEGER-INFO
18    (JMPIF L23)
20    (NIL)
21    (SKIP&RET 1)
23    L23
23    (GETVALUE&PUSH 2)                   ; INTEGER-INFO
25    (LOAD&JMPIFNOT 0 L46)
28    L28
28    (LOAD 0)
29    (CAR)
30    (CDR)
31    (CAR&PUSH)
32    (LOAD 1)
33    (CAR)
34    (CDR)
35    (CDR)
36    (CAR&PUSH)
37    (LIST&PUSH 2)
39    (CALL1 3)                           ; I-$REMOVE
41    (LOAD&CDR&STORE 0)
43    (LOAD&JMPIF 0 L28)
46    L46
46    (T)
47    (SKIP&RET 2)


Disassembly of function #:|(DEFUN ORDER-LIMITS (ASK-OR-NOT) ...)-43|
(CONST 0) = ORDER-LIMITS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ORDER-LIMITS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ORDER-LIMITS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ORDER-LIMITS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ORDER-LIMITS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ORDER-LIMITS
8     (SKIP&RET 1)


Disassembly of function ORDER-LIMITS
(CONST 0) = LL
(CONST 1) = $IMAGPART
(CONST 2) = 0
(CONST 3) = UL
(CONST 4) = -1
(CONST 5) = $INF
(CONST 6) = MUL
(CONST 7) = ALIKE1
(CONST 8) = $MINF
(CONST 9) = VAR
(CONST 10) = MUL*
(CONST 11) = EXP
(CONST 12) = SUBIN
(CONST 13) = COMPLM
(CONST 14) = D
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR D EXP UL LL)
writes special variables : (D EXP UL LL)
91 byte-code instructions:
0     (GETVALUE&PUSH 0)                   ; LL
2     (CALL1&PUSH 1)                      ; $IMAGPART
4     (JMPIFNOTEQTO 2 L107)               ; 0
8     (GETVALUE&PUSH 3)                   ; UL
10    (CALL1&PUSH 1)                      ; $IMAGPART
12    (JMPIFNOTEQTO 2 L107)               ; 0
16    (GETVALUE&PUSH 0)                   ; LL
18    (CONST&PUSH 4)                      ; -1
19    (CONST&PUSH 5)                      ; $INF
20    (CALL2&PUSH 6)                      ; MUL
22    (CALL2&JMPIFNOT 7 L28)              ; ALIKE1
25    (CONST 8)                           ; $MINF
26    (SETVALUE 0)                        ; LL
28    L28
28    (GETVALUE&PUSH 3)                   ; UL
30    (CONST&PUSH 4)                      ; -1
31    (CONST&PUSH 5)                      ; $INF
32    (CALL2&PUSH 6)                      ; MUL
34    (CALL2&JMPIFNOT 7 L40)              ; ALIKE1
37    (CONST 8)                           ; $MINF
38    (SETVALUE 3)                        ; UL
40    L40
40    (GETVALUE&PUSH 0)                   ; LL
42    (CONST&PUSH 4)                      ; -1
43    (CONST&PUSH 8)                      ; $MINF
44    (CALL2&PUSH 6)                      ; MUL
46    (CALL2&JMPIFNOT 7 L52)              ; ALIKE1
49    (CONST 5)                           ; $INF
50    (SETVALUE 0)                        ; LL
52    L52
52    (GETVALUE&PUSH 3)                   ; UL
54    (CONST&PUSH 4)                      ; -1
55    (CONST&PUSH 8)                      ; $MINF
56    (CALL2&PUSH 6)                      ; MUL
58    (CALL2&JMPIFNOT 7 L64)              ; ALIKE1
61    (CONST 5)                           ; $INF
62    (SETVALUE 3)                        ; UL
64    L64
64    (GETVALUE&PUSH 3)                   ; UL
66    (JMPIFEQTO 5 L93)                   ; $INF
69    (GETVALUE&PUSH 0)                   ; LL
71    (JMPIFEQTO 8 L110)                  ; $MINF
74    (GETVALUE&PUSH 0)                   ; LL
76    (JMPIFNOTEQTO 5 L93)                ; $INF
79    (GETVALUE 3)                        ; UL
81    (SETVALUE 0)                        ; LL
83    (CONST 5)                           ; $INF
84    (SETVALUE 3)                        ; UL
86    (CONST&PUSH 4)                      ; -1
87    (GETVALUE&PUSH 11)                  ; EXP
89    (CALL2 10)                          ; MUL*
91    (SETVALUE 11)                       ; EXP
93    L93
93    (LOAD&PUSH 1)
94    (CALL1 13)                          ; COMPLM
96    (BIND 14)                           ; D
98    (GETVALUE&PUSH 14)                  ; D
100   (JMPIFEQTO 4 L133)                  ; -1
103   (T)
104   L104
104   (UNBIND1)
105   (SKIP&RET 2)
107   L107
107   (NIL)
108   (SKIP&RET 2)
110   L110
110   (CONST&PUSH 4)                      ; -1
111   (GETVALUE&PUSH 9)                   ; VAR
113   (CALL2&PUSH 10)                     ; MUL*
115   (GETVALUE&PUSH 11)                  ; EXP
117   (CALL2 12)                          ; SUBIN
119   (SETVALUE 11)                       ; EXP
121   (CONST&PUSH 4)                      ; -1
122   (GETVALUE&PUSH 3)                   ; UL
124   (CALL2 10)                          ; MUL*
126   (SETVALUE 0)                        ; LL
128   (CONST 5)                           ; $INF
129   (SETVALUE 3)                        ; UL
131   (JMP L93)
133   L133
133   (CONST&PUSH 4)                      ; -1
134   (GETVALUE&PUSH 11)                  ; EXP
136   (CALL2 10)                          ; MUL*
138   (SETVALUE 11)                       ; EXP
140   (GETVALUE 0)                        ; LL
142   (SETVALUE 14)                       ; D
144   (GETVALUE 3)                        ; UL
146   (SETVALUE 0)                        ; LL
148   (GETVALUE 14)                       ; D
150   (SETVALUE 3)                        ; UL
152   (JMP L104)


Disassembly of function #:|(DEFUN COMPLM (ASK-OR-NOT) ...)-44|
(CONST 0) = COMPLM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COMPLM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COMPLM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COMPLM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COMPLM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COMPLM
8     (SKIP&RET 1)


Disassembly of function COMPLM
(CONST 0) = ASK
(CONST 1) = A
(CONST 2) = UL
(CONST 3) = LL
(CONST 4) = ALIKE1
(CONST 5) = 0
(CONST 6) = -1
(CONST 7) = MUL*
(CONST 8) = ADD
(CONST 9) = $LIMIT
(CONST 10) = $ASKSIGN
(CONST 11) = $SIGN
(CONST 12) = $POS
(CONST 13) = 1
(CONST 14) = $NEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A LL UL)
writes special variable : (A)
49 byte-code instructions:
0     (LOAD&PUSH 1)
1     (JMPIFEQTO 0 L47)                   ; ASK
4     (NIL)
5     L5
5     (PUSH)
6     (NIL)
7     (BIND 1)                            ; A
9     (GETVALUE&PUSH 2)                   ; UL
11    (GETVALUE&PUSH 3)                   ; LL
13    (CALL2&JMPIF 4 L50)                 ; ALIKE1
16    (LOAD&JMPIF 3 L53)
19    (GETVALUE&PUSH 2)                   ; UL
21    (CONST&PUSH 6)                      ; -1
22    (GETVALUE&PUSH 3)                   ; LL
24    (CALL2&PUSH 7)                      ; MUL*
26    (CALL2&PUSH 8)                      ; ADD
28    (CALL1&PUSH 9)                      ; $LIMIT
30    (CALL1 11)                          ; $SIGN
32    L32
32    (SETVALUE 1)                        ; A
34    (PUSH)
35    (JMPIFEQTO 12 L68)                  ; $POS
38    (GETVALUE&PUSH 1)                   ; A
40    (JMPIFEQTO 14 L71)                  ; $NEG
43    (CONST 13)                          ; 1
44    L44
44    (UNBIND1)
45    (SKIP&RET 3)
47    L47
47    (T)
48    (JMP L5)
50    L50
50    (CONST 5)                           ; 0
51    (JMP L44)
53    L53
53    (GETVALUE&PUSH 2)                   ; UL
55    (CONST&PUSH 6)                      ; -1
56    (GETVALUE&PUSH 3)                   ; LL
58    (CALL2&PUSH 7)                      ; MUL*
60    (CALL2&PUSH 8)                      ; ADD
62    (CALL1&PUSH 9)                      ; $LIMIT
64    (CALL1 10)                          ; $ASKSIGN
66    (JMP L32)
68    L68
68    (CONST 13)                          ; 1
69    (JMP L44)
71    L71
71    (CONST 6)                           ; -1
72    (JMP L44)


Disassembly of function #:|(DEFUN INTSUBS (E A B) ...)-45|
(CONST 0) = INTSUBS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTSUBS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTSUBS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTSUBS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTSUBS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTSUBS
8     (SKIP&RET 1)


Disassembly of function INTSUBS
(CONST 0) = E
(CONST 1) = A
(CONST 2) = B
(CONST 3) = EASY-SUBS
(CONST 4) = ASK
(CONST 5) = MAKE-DEFINT-ASSUMPTIONS
(CONST 6) = CURRENT-ASSUMPTIONS
(CONST 7) = GENERATE-ATAN2
(CONST 8) = $ALGEBRAIC
(CONST 9) = $%I
(CONST 10) = FREE
(CONST 11) = TRISPLIT
(CONST 12) = 0
(CONST 13) = SRATSIMP
(CONST 14) = LIMIT-SUBS
(CONST 15) = (%LIMIT)
(CONST 16) = VAR
(CONST 17) = ($MINUS)
(CONST 18) = (%LIMIT)
(CONST 19) = ($PLUS)
(CONST 20) = SUB*
(CONST 21) = (%LIMIT)
(CONST 22) = ($MINUS)
(CONST 23) = (%LIMIT)
(CONST 24) = ($PLUS)
(CONST 25) = MUL*
(CONST 26) = ADD*
(CONST 27) = SAME-SHEET-SUBS
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR B A E)
writes special variable : (CURRENT-ASSUMPTIONS)
103 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; E
3     (LOAD 5)
4     (BIND 1)                            ; A
6     (LOAD 7)
7     (BIND 2)                            ; B
9     (GETVALUE&PUSH 0)                   ; E
11    (GETVALUE&PUSH 1)                   ; A
13    (GETVALUE&PUSH 2)                   ; B
15    (CALL 3 3)                          ; EASY-SUBS
18    (JMPIF1 L80)
20    (CONST&PUSH 4)                      ; ASK
21    (CALL1 5)                           ; MAKE-DEFINT-ASSUMPTIONS
23    (SETVALUE 6)                        ; CURRENT-ASSUMPTIONS
25    (NIL)
26    (BIND 7)                            ; GENERATE-ATAN2
28    (T)
29    (BIND 8)                            ; $ALGEBRAIC
31    (PUSH-NIL 2)
33    (GETVALUE&PUSH 0)                   ; E
35    (CONST&PUSH 9)                      ; $%I
36    (CALL2&JMPIFNOT 10 L84)             ; FREE
39    (GETVALUE&PUSH 0)                   ; E
41    (CONST 12)                          ; 0
42    (CONS)
43    L43
43    (STORE 0)
44    (CAR)
45    (STORE 1)
46    (LOAD&CDR&STORE 0)
48    (PUSH)
49    (CALL1&PUSH 13)                     ; SRATSIMP
51    (JMPIFNOTEQTO 12 L90)               ; 0
54    (LOAD&PUSH 1)
55    (CALL1 13)                          ; SRATSIMP
57    (STORE 1)
58    (PUSH)
59    (GETVALUE&PUSH 1)                   ; A
61    (GETVALUE&PUSH 2)                   ; B
63    (CALL 3 14)                         ; LIMIT-SUBS
66    (JMPIF1 L76)
68    (LOAD&PUSH 1)
69    (GETVALUE&PUSH 1)                   ; A
71    (GETVALUE&PUSH 2)                   ; B
73    (CALL 3 27)                         ; SAME-SHEET-SUBS
76    L76
76    (SKIP 2)
78    (UNBIND 2)
80    L80
80    (UNBIND 3)
82    (SKIP&RET 4)
84    L84
84    (GETVALUE&PUSH 0)                   ; E
86    (CALL1 11)                          ; TRISPLIT
88    (JMP L43)
90    L90
90    (LOAD&PUSH 1)
91    (GETVALUE&PUSH 1)                   ; A
93    (GETVALUE&PUSH 2)                   ; B
95    (CALL 3 14)                         ; LIMIT-SUBS
98    (JMPIF L120)
100   (CONST&PUSH 15)                     ; (%LIMIT)
101   (LOAD&PUSH 2)
102   (GETVALUE&PUSH 16)                  ; VAR
104   (GETVALUE&PUSH 2)                   ; B
106   (CONST 17)                          ; ($MINUS)
107   (LIST*&PUSH 4)
109   (CONST&PUSH 18)                     ; (%LIMIT)
110   (LOAD&PUSH 3)
111   (GETVALUE&PUSH 16)                  ; VAR
113   (GETVALUE&PUSH 1)                   ; A
115   (CONST 19)                          ; ($PLUS)
116   (LIST*&PUSH 4)
118   (CALL2 20)                          ; SUB*
120   L120
120   (PUSH)
121   (LOAD&PUSH 1)
122   (GETVALUE&PUSH 1)                   ; A
124   (GETVALUE&PUSH 2)                   ; B
126   (CALL 3 14)                         ; LIMIT-SUBS
129   (JMPIF L153)
131   (CONST&PUSH 21)                     ; (%LIMIT)
132   (LOAD&PUSH 2)
133   (GETVALUE&PUSH 16)                  ; VAR
135   (GETVALUE&PUSH 2)                   ; B
137   (CONST 22)                          ; ($MINUS)
139   (LIST*&PUSH 4)
141   (CONST&PUSH 23)                     ; (%LIMIT)
142   (LOAD&PUSH 3)
143   (GETVALUE&PUSH 16)                  ; VAR
145   (GETVALUE&PUSH 1)                   ; A
147   (CONST 24)                          ; ($PLUS)
149   (LIST*&PUSH 4)
151   (CALL2 20)                          ; SUB*
153   L153
153   (PUSH)
154   (LOAD&PUSH 1)
155   (CONST&PUSH 9)                      ; $%I
156   (LOAD&PUSH 2)
157   (CALL2&PUSH 25)                     ; MUL*
159   (CALL2 26)                          ; ADD*
161   (SKIP 2)
163   (JMP L76)


Disassembly of function #:|(DEFUN EASY-SUBS (E LL UL) ...)-46|
(CONST 0) = EASY-SUBS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EASY-SUBS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EASY-SUBS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EASY-SUBS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EASY-SUBS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EASY-SUBS
8     (SKIP&RET 1)


Disassembly of function EASY-SUBS
(CONST 0) = E
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = INFINITIES
(CONST 4) = MEMQ
(CONST 5) = VAR
(CONST 6) = POLYINX
(CONST 7) = NO-ERR-SUB
(CONST 8) = SUB*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E UL INFINITIES LL)
43 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; E
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (GETVALUE&PUSH 1)                   ; LL
11    (GETVALUE&PUSH 3)                   ; INFINITIES
13    (CALL2&JMPIF 4 L38)                 ; MEMQ
16    (GETVALUE&PUSH 2)                   ; UL
18    (GETVALUE&PUSH 3)                   ; INFINITIES
20    (CALL2&JMPIF 4 L38)                 ; MEMQ
23    (GETVALUE&PUSH 0)                   ; E
25    (GETVALUE&PUSH 5)                   ; VAR
27    (NIL&PUSH)
28    (CALL 3 6)                          ; POLYINX
31    (JMPIF L49)
33    (NIL)
34    L34
34    (UNBIND 3)
36    (SKIP&RET 4)
38    L38
38    (NIL)
39    (JMP L34)
41    L41
41    (LOAD&PUSH 0)
42    (LOAD&PUSH 2)
43    (CALL2 8)                           ; SUB*
45    (SKIP 2)
47    (JMP L34)
49    L49
49    (GETVALUE&PUSH 1)                   ; LL
51    (GETVALUE&PUSH 0)                   ; E
53    (CALL2&PUSH 7)                      ; NO-ERR-SUB
55    (GETVALUE&PUSH 2)                   ; UL
57    (GETVALUE&PUSH 0)                   ; E
59    (CALL2&PUSH 7)                      ; NO-ERR-SUB
61    (LOAD&JMPIFNOT 1 L67)
64    (LOAD&JMPIF 0 L41)
67    L67
67    (NIL)
68    (SKIP 2)
70    (JMP L34)


Disassembly of function #:|(DEFUN LIMIT-SUBS (E LL UL) ...)-47|
(CONST 0) = LIMIT-SUBS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-SUBS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-SUBS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-SUBS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-SUBS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT-SUBS
8     (SKIP&RET 1)


Disassembly of function LIMIT-SUBS
(CONST 0) = E
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = %ATAN
(CONST 4) = FREE
(CONST 5) = $MULTTHRU
(CONST 6) = VAR
(CONST 7) = $PLUS
(CONST 8) = $LIMIT
(CONST 9) = $MINUS
(CONST 10) = ($INF $MINF $INFINITY)
(CONST 11) = MEMQ
(CONST 12) = ($INF $MINF $INFINITY)
(CONST 13) = DIVERG
(CONST 14) = ($INF $MINF $INFINITY)
(CONST 15) = ($UND $IND)
(CONST 16) = ($UND $IND)
(CONST 17) = SUB*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR E)
writes special variable : (E)
62 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; E
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (GETVALUE&PUSH 0)                   ; E
11    (CONST&PUSH 3)                      ; %ATAN
12    (CALL2&JMPIFNOT 4 L56)              ; FREE
15    (GETVALUE&PUSH 0)                   ; E
17    (CALL1 5)                           ; $MULTTHRU
19    (SETVALUE 0)                        ; E
21    (PUSH)
22    (GETVALUE&PUSH 6)                   ; VAR
24    (GETVALUE&PUSH 1)                   ; LL
26    (CONST&PUSH 7)                      ; $PLUS
27    (CALL&PUSH 4 8)                     ; $LIMIT
30    (GETVALUE&PUSH 0)                   ; E
32    (GETVALUE&PUSH 6)                   ; VAR
34    (GETVALUE&PUSH 2)                   ; UL
36    (CONST&PUSH 9)                      ; $MINUS
37    (CALL&PUSH 4 8)                     ; $LIMIT
40    (LOAD&PUSH 1)
41    (CONST&PUSH 10)                     ; ($INF $MINF $INFINITY)
42    (CALL2&JMPIF 11 L59)                ; MEMQ
45    (LOAD&PUSH 0)
46    (CONST&PUSH 14)                     ; ($INF $MINF $INFINITY)
47    (CALL2&JMPIFNOT 11 L70)             ; MEMQ
50    L50
50    (CALL0 13)                          ; DIVERG
52    (SKIP 2)
54    (JMP L91)
56    L56
56    (NIL)
57    (JMP L91)
59    L59
59    (LOAD&PUSH 0)
60    (CONST&PUSH 12)                     ; ($INF $MINF $INFINITY)
61    (CALL2&JMPIFNOT 11 L50)             ; MEMQ
64    (LOAD&PUSH 0)
65    (LOAD 2)
66    (JMPIFNOTEQ L80)
68    (JMP L50)
70    L70
70    (LOAD&PUSH 1)
71    (CONST&PUSH 15)                     ; ($UND $IND)
72    (CALL2&JMPIF 11 L80)                ; MEMQ
75    (LOAD&PUSH 0)
76    (CONST&PUSH 16)                     ; ($UND $IND)
77    (CALL2&JMPIFNOT 11 L85)             ; MEMQ
80    L80
80    (NIL)
81    (SKIP 2)
83    (JMP L91)
85    L85
85    (LOAD&PUSH 0)
86    (LOAD&PUSH 2)
87    (CALL2 17)                          ; SUB*
89    (SKIP 2)
91    L91
91    (UNBIND 3)
93    (SKIP&RET 4)


Disassembly of function #:|(DEFUN SAME-SHEET-SUBS (EXP LL UL ...) ...)-48|
(CONST 0) = SAME-SHEET-SUBS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SAME-SHEET-SUBS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SAME-SHEET-SUBS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SAME-SHEET-SUBS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SAME-SHEET-SUBS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SAME-SHEET-SUBS
8     (SKIP&RET 1)


Disassembly of function SAME-SHEET-SUBS
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = ANS
(CONST 4) = ATAN-POLES
(CONST 5) = VAR
(CONST 6) = $PLUS
(CONST 7) = $LIMIT
(CONST 8) = $SUBSTITUTE
(CONST 9) = SRATSIMP
(CONST 10) = $MINUS
(CONST 11) = SUB*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR UL LL EXP)
writes special variables : (EXP ANS)
33 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (NIL)
10    (BIND 3)                            ; ANS
12    (GETVALUE&PUSH 0)                   ; EXP
14    (GETVALUE&PUSH 1)                   ; LL
16    (GETVALUE&PUSH 2)                   ; UL
18    (CALL&PUSH 3 4)                     ; ATAN-POLES
21    (GETVALUE&PUSH 0)                   ; EXP
23    (GETVALUE&PUSH 5)                   ; VAR
25    (GETVALUE&PUSH 1)                   ; LL
27    (CONST&PUSH 6)                      ; $PLUS
28    (CALL 4 7)                          ; $LIMIT
31    (SETVALUE 3)                        ; ANS
33    (LOAD&PUSH 0)
34    (GETVALUE&PUSH 0)                   ; EXP
36    (CALL2&PUSH 8)                      ; $SUBSTITUTE
38    (CALL1 9)                           ; SRATSIMP
40    (SETVALUE 0)                        ; EXP
42    (PUSH)
43    (GETVALUE&PUSH 5)                   ; VAR
45    (GETVALUE&PUSH 2)                   ; UL
47    (CONST&PUSH 10)                     ; $MINUS
48    (CALL&PUSH 4 7)                     ; $LIMIT
51    (GETVALUE&PUSH 3)                   ; ANS
53    (CALL2 11)                          ; SUB*
55    (SKIP 1)
57    (UNBIND 4)
59    (SKIP&RET 4)


Disassembly of function #:|(DEFUN ATAN-POLES (EXP LL UL) ...)-49|
(CONST 0) = ATAN-POLES
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ATAN-POLES>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ATAN-POLES
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ATAN-POLES
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ATAN-POLES>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ATAN-POLES
8     (SKIP&RET 1)


Disassembly of function ATAN-POLES
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = (MLIST)
(CONST 4) = ATAN-POLE1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL EXP)
14 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (CONST&PUSH 3)                      ; (MLIST)
10    (GETVALUE&PUSH 0)                   ; EXP
12    (GETVALUE&PUSH 1)                   ; LL
14    (GETVALUE&PUSH 2)                   ; UL
16    (CALL 3 4)                          ; ATAN-POLE1
19    (CONS)
20    (UNBIND 3)
22    (SKIP&RET 4)


Disassembly of function #:|(DEFUN ATAN-POLE1 (EXP LL UL ...) ...)-50|
(CONST 0) = ATAN-POLE1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ATAN-POLE1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ATAN-POLE1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ATAN-POLE1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ATAN-POLE1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ATAN-POLE1
8     (SKIP&RET 1)


Disassembly of function ATAN-POLE1
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = MAPATOM
(CONST 4) = %ATAN
(CONST 5) = TRISPLIT
(CONST 6) = SRATSIMP
(CONST 7) = 0
(CONST 8) = $ALGEBRAIC
(CONST 9) = VAR
(CONST 10) = POLES-IN-INTERVAL
(CONST 11) = $UNKNOWN
(CONST 12) = $NO
(CONST 13) = L
(CONST 14) = $MINUS
(CONST 15) = $LIMIT
(CONST 16) = $PLUS
(CONST 17) = REAL-INFINITIES
(CONST 18) = MEMQ
(CONST 19) = $MINF
(CONST 20) = -1
(CONST 21) = $%PI
(CONST 22) = MUL*
(CONST 23) = (MEQUAL SIMP)
(CONST 24) = ADD*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (REAL-INFINITIES VAR UL LL L EXP)
writes special variables : (EXP L)
159 byte-code instructions:
0     L0
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (NIL&PUSH)
10    (GETVALUE&PUSH 0)                   ; EXP
12    (CALL1&JMPIF 3 L68)                 ; MAPATOM
15    (GETVALUE&PUSH 0)                   ; EXP
17    (LOAD&PUSH 0)
18    (CALLS2&JMPIF 4 L184)               ; CONSP
22    (SKIP 1)
24    (JMPIF L194)
27    L27
27    (GETVALUE 0)                        ; EXP
29    (CDR)
30    (BIND 13)                           ; L
32    (NIL&PUSH)
33    (GETVALUE 13)                       ; L
35    (JMPIFNOT L60)
37    L37
37    (LOAD&PUSH 0)
38    (GETVALUE 13)                       ; L
40    (CAR&PUSH)
41    (GETVALUE&PUSH 1)                   ; LL
43    (GETVALUE&PUSH 2)                   ; UL
45    (JSR&PUSH L0)
47    (CALLSR&STORE 2 34 0)               ; APPEND
51    (GETVALUE 13)                       ; L
53    (CDR)
54    (SETVALUE 13)                       ; L
56    (GETVALUE 13)                       ; L
58    (JMPIF L37)
60    L60
60    (POP)
61    (UNBIND1)
62    L62
62    (SKIP 1)
64    (UNBIND 3)
66    (SKIP&RET 4)
68    L68
68    (NIL)
69    (JMP L62)
71    L71
71    (NIL)
72    (JMP L62)
74    L74
74    (CONST&PUSH 20)                     ; -1
75    (CONST&PUSH 21)                     ; $%PI
76    (CALL2 22)                          ; MUL*
78    (JMP L86)
80    L80
80    (LOAD&PUSH 1)
81    (JMPIFEQTO 19 L74)                  ; $MINF
84    (CONST 21)                          ; $%PI
86    L86
86    (PUSH)
87    (CONST&PUSH 23)                     ; (MEQUAL SIMP)
88    (GETVALUE&PUSH 0)                   ; EXP
90    (GETVALUE&PUSH 0)                   ; EXP
92    (LOAD&PUSH 3)
93    (CALL2&PUSH 24)                     ; ADD*
95    (LIST&PUSH 3)
97    (LOAD&CONS&STORE 3)
99    (SKIP 3)
101   (JMP L168)
104   L104
104   (LOAD 0)
105   (BIND 13)                           ; L
107   (NIL&PUSH)
108   (GETVALUE 13)                       ; L
110   (JMPIFNOT L177)
113   L113
113   (GETVALUE 13)                       ; L
115   (CAR)
116   (CAR&PUSH)
117   (GETVALUE 1)                        ; LL
119   (JMPIFEQ L168)
121   (GETVALUE 0)                        ; EXP
123   (CDR)
124   (CAR&PUSH)
125   (GETVALUE&PUSH 9)                   ; VAR
127   (GETVALUE 13)                       ; L
129   (CAR)
130   (CAR&PUSH)
131   (CONST&PUSH 14)                     ; $MINUS
132   (CALL&PUSH 4 15)                    ; $LIMIT
135   (GETVALUE 0)                        ; EXP
137   (CDR)
138   (CAR&PUSH)
139   (GETVALUE&PUSH 9)                   ; VAR
141   (GETVALUE 13)                       ; L
143   (CAR)
144   (CAR&PUSH)
145   (CONST&PUSH 16)                     ; $PLUS
146   (CALL&PUSH 4 15)                    ; $LIMIT
149   (LOAD&PUSH 1)
150   (LOAD 1)
151   (JMPIFEQ L166)
153   (LOAD&PUSH 1)
154   (GETVALUE&PUSH 17)                  ; REAL-INFINITIES
156   (CALL2&JMPIFNOT 18 L166)            ; MEMQ
159   (LOAD&PUSH 0)
160   (GETVALUE&PUSH 17)                  ; REAL-INFINITIES
162   (CALL2&JMPIF 18 L80)                ; MEMQ
166   L166
166   (SKIP 2)
168   L168
168   (GETVALUE 13)                       ; L
170   (CDR)
171   (SETVALUE 13)                       ; L
173   (GETVALUE 13)                       ; L
175   (JMPIF L113)
177   L177
177   (POP)
178   (UNBIND1)
179   (SKIP 1)
181   (JMP L62)
184   L184
184   (LOAD 0)
185   (CAR)
186   (CAR&PUSH)
187   (CONST 4)                           ; %ATAN
188   (EQ)
189   (SKIP 1)
191   (JMPIFNOT L27)
194   L194
194   (GETVALUE&PUSH 0)                   ; EXP
196   (CALL1 5)                           ; TRISPLIT
198   (STORE 0)
199   (CAR)
200   (SETVALUE 0)                        ; EXP
202   (LOAD&CDR&STORE 0)
204   (PUSH)
205   (CALL1&PUSH 6)                      ; SRATSIMP
207   (JMPIFNOTEQTO 7 L71)                ; 0
211   (T)
212   (BIND 8)                            ; $ALGEBRAIC
214   (GETVALUE 0)                        ; EXP
216   (CDR)
217   (CAR&PUSH)
218   (CALL1 6)                           ; SRATSIMP
220   (UNBIND1)
221   (PUSH)
222   (GETVALUE&PUSH 9)                   ; VAR
224   (GETVALUE&PUSH 1)                   ; LL
226   (GETVALUE&PUSH 2)                   ; UL
228   (CALL&PUSH 4 10)                    ; POLES-IN-INTERVAL
231   (LOAD&JMPIFNOT 0 L243)
234   (PUSH)
235   (JMPIFEQTO 11 L243)                 ; $UNKNOWN
238   (LOAD&PUSH 0)
239   (JMPIFNOTEQTO 12 L104)              ; $NO
243   L243
243   (NIL)
244   (SKIP 1)
246   (JMP L62)


Disassembly of function #:|(DEFUN DIFAPPLY (N D S ...) ...)-51|
(CONST 0) = DIFAPPLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DIFAPPLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DIFAPPLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DIFAPPLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DIFAPPLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DIFAPPLY
8     (SKIP&RET 1)


Disassembly of function DIFAPPLY
(CONST 0) = N
(CONST 1) = D
(CONST 2) = S
(CONST 3) = K
(CONST 4) = M
(CONST 5) = R
(CONST 6) = $NOPRINCIPAL
(CONST 7) = DEG
(CONST 8) = -1
(CONST 9) = MUL*
(CONST 10) = 2
(CONST 11) = ADD*
(CONST 12) = $ASKSIGN
(CONST 13) = $NEG
(CONST 14) = MEXPTP
(CONST 15) = 1
(CONST 16) = MTORAT
(CONST 17) = 0
(CONST 18) = DIV*
(CONST 19) = $ANY
(CONST 20) = ASK-INTEGER
(CONST 21) = $YES
(CONST 22) = $SIGN
(CONST 23) = $POS
(CONST 24) = DIFFHK
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (R K M N S D)
writes special variables : (K M D R $NOPRINCIPAL)
102 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; N
3     (LOAD 6)
4     (BIND 1)                            ; D
6     (LOAD 8)
7     (BIND 2)                            ; S
9     (NIL)
10    (BIND 3)                            ; K
12    (NIL)
13    (BIND 4)                            ; M
15    (NIL)
16    (BIND 5)                            ; R
18    (NIL)
19    (BIND 6)                            ; $NOPRINCIPAL
21    (GETVALUE&PUSH 1)                   ; D
23    (CALL1&PUSH 7)                      ; DEG
25    (CONST&PUSH 8)                      ; -1
26    (GETVALUE&PUSH 2)                   ; S
28    (CALL2&PUSH 9)                      ; MUL*
30    (CONST&PUSH 8)                      ; -1
31    (CONST&PUSH 10)                     ; 2
32    (CALL2&PUSH 9)                      ; MUL*
34    (CALL&PUSH 3 11)                    ; ADD*
37    (CALL1&PUSH 12)                     ; $ASKSIGN
39    (JMPIFEQTO 13 L141)                 ; $NEG
43    (T)
44    (SETVALUE 6)                        ; $NOPRINCIPAL
46    (GETVALUE&PUSH 1)                   ; D
48    (CALL1&JMPIFNOT 14 L141)            ; MEXPTP
52    (GETVALUE 1)                        ; D
54    (CDR)
55    (CDR)
56    (CAR)
57    (SETVALUE 5)                        ; R
59    (PUSH)
60    (CALLS2&JMPIFNOT 8 L141)            ; NUMBERP
64    (GETVALUE&PUSH 0)                   ; N
66    (JMPIFNOTEQTO 15 L83)               ; 1
69    (LOAD&PUSH 22)
70    (JMPIFNOTEQTO 16 L83)               ; MTORAT
73    (GETVALUE 1)                        ; D
75    (CDR)
76    (CAR&PUSH)
77    (CALL1&PUSH 7)                      ; DEG
79    (JMPIFEQTO 15 L148)                 ; 1
83    L83
83    (GETVALUE 1)                        ; D
85    (CDR)
86    (CAR)
87    (SETVALUE 1)                        ; D
89    (PUSH)
90    (CALL1 7)                           ; DEG
92    (SETVALUE 4)                        ; M
94    (GETVALUE&PUSH 2)                   ; S
96    (CONST&PUSH 10)                     ; 2
97    (CALL2&PUSH 11)                     ; ADD*
99    (GETVALUE&PUSH 4)                   ; M
101   (CALL2 18)                          ; DIV*
103   (SETVALUE 3)                        ; K
105   (GETVALUE&PUSH 2)                   ; S
107   (CONST&PUSH 10)                     ; 2
108   (CALL2&PUSH 11)                     ; ADD*
110   (GETVALUE&PUSH 4)                   ; M
112   (CALL2&PUSH 18)                     ; DIV*
114   (CONST&PUSH 19)                     ; $ANY
115   (CALL2&PUSH 20)                     ; ASK-INTEGER
117   (JMPIFEQTO 21 L127)                 ; $YES
120   (CONST&PUSH 15)                     ; 1
121   (GETVALUE&PUSH 3)                   ; K
123   (CALL2 11)                          ; ADD*
125   (SETVALUE 3)                        ; K
127   L127
127   (GETVALUE&PUSH 5)                   ; R
129   (CONST&PUSH 8)                      ; -1
130   (GETVALUE&PUSH 3)                   ; K
132   (CALL2&PUSH 9)                      ; MUL*
134   (CALL2&PUSH 11)                     ; ADD*
136   (CALL1&PUSH 22)                     ; $SIGN
138   (JMPIFEQTO 23 L153)                 ; $POS
141   L141
141   (NIL)
142   (UNBIND 4)
144   L144
144   (UNBIND 3)
146   (SKIP&RET 5)
148   L148
148   (CONST 17)                          ; 0
149   (UNBIND 4)
151   (JMP L144)
153   L153
153   (LOAD&PUSH 22)
154   (GETVALUE&PUSH 0)                   ; N
156   (GETVALUE&PUSH 1)                   ; D
158   (GETVALUE&PUSH 3)                   ; K
160   (GETVALUE&PUSH 5)                   ; R
162   (CONST&PUSH 8)                      ; -1
163   (GETVALUE&PUSH 3)                   ; K
165   (CALL2&PUSH 9)                      ; MUL*
167   (CALL2&PUSH 11)                     ; ADD*
169   (CALL 5 24)                         ; DIFFHK
172   (UNBIND 4)
174   (JMP L144)


Disassembly of function #:|(DEFUN DIFFHK (FN1 N D ...) ...)-52|
(CONST 0) = DIFFHK
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DIFFHK>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DIFFHK
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DIFFHK
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DIFFHK>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DIFFHK
8     (SKIP&RET 1)


Disassembly of function DIFFHK
(CONST 0) = N
(CONST 1) = D
(CONST 2) = R
(CONST 3) = M
(CONST 4) = *DFLAG
(CONST 5) = *Z*
(CONST 6) = ADD
(CONST 7) = POWER*
(CONST 8) = DEG
(CONST 9) = MUL*
(CONST 10) = 0
(CONST 11) = DIFAP1
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M R D N)
writes special variable : (*DFLAG)
43 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; N
3     (LOAD 6)
4     (BIND 1)                            ; D
6     (LOAD 8)
7     (BIND 2)                            ; R
9     (LOAD 10)
10    (BIND 3)                            ; M
12    (NIL&PUSH)
13    (NIL)
14    (BIND 4)                            ; *DFLAG
16    (T)
17    (SETVALUE 4)                        ; *DFLAG
19    (LOAD&PUSH 21)
20    (GETVALUE&PUSH 0)                   ; N
22    (CONST&PUSH 5)                      ; *Z*
23    (GETVALUE&PUSH 1)                   ; D
25    (CALL2&PUSH 6)                      ; ADD
27    (GETVALUE&PUSH 2)                   ; R
29    (CALL2&PUSH 7)                      ; POWER*
31    (GETVALUE&PUSH 2)                   ; R
33    (GETVALUE&PUSH 1)                   ; D
35    (CALL1&PUSH 8)                      ; DEG
37    (CALL2&PUSH 9)                      ; MUL*
39    (FUNCALL 3)
41    (STORE 3)
42    (JMPIF L52)
44    (NIL)
45    (UNBIND1)
46    (SKIP 1)
48    L48
48    (UNBIND 4)
50    (SKIP&RET 6)
52    L52
52    (PUSH)
53    (GETVALUE&PUSH 2)                   ; R
55    (CONST&PUSH 5)                      ; *Z*
56    (GETVALUE&PUSH 3)                   ; M
58    (CONST&PUSH 10)                     ; 0
59    (CALL 5 11)                         ; DIFAP1
62    (UNBIND1)
63    (SKIP 1)
65    (JMP L48)


Disassembly of function #:|(DEFUN PRINCIPAL NIL ...)-53|
(CONST 0) = PRINCIPAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PRINCIPAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRINCIPAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PRINCIPAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PRINCIPAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PRINCIPAL
8     (SKIP&RET 1)


Disassembly of function PRINCIPAL
(CONST 0) = $NOPRINCIPAL
(CONST 1) = DIVERG
(CONST 2) = PCPRNTD
(CONST 3) = "Principal Value"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (PCPRNTD $NOPRINCIPAL)
writes special variable : (PCPRNTD)
16 byte-code instructions:
0     (GETVALUE 0)                        ; $NOPRINCIPAL
2     (JMPIF L11)
4     (GETVALUE 2)                        ; PCPRNTD
6     (JMPIFNOT L15)
8     (NIL)
9     (SKIP&RET 1)
11    L11
11    (CALL0 1)                           ; DIVERG
13    (SKIP&RET 1)
15    L15
15    (CONST&PUSH 3)                      ; "Principal Value"
16    (PUSH-UNBOUND 1)
18    (CALLS1 132)                        ; PRINC
20    (T)
21    (SETVALUE 2)                        ; PCPRNTD
23    (SKIP&RET 1)


Disassembly of function #:|(DEFUN RIB (E S) ...)-54|
(CONST 0) = RIB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RIB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RIB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RIB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RIB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RIB
8     (SKIP&RET 1)


Disassembly of function RIB
(CONST 0) = E
(CONST 1) = S
(CONST 2) = *UPDN
(CONST 3) = C
(CONST 4) = MNUMP
(CONST 5) = CONSTANT
(CONST 6) = BPTU
(CONST 7) = RMCONST1
(CONST 8) = NN*
(CONST 9) = ND*
(CONST 10) = PTIMES%E
(CONST 11) = MUL*
(CONST 12) = BPTD
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (BPTD BPTU *UPDN C ND* NN* S E)
writes special variables : (BPTD BPTU ND* NN* C E)
57 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; S
6     (NIL)
7     (BIND 2)                            ; *UPDN
9     (NIL)
10    (BIND 3)                            ; C
12    (GETVALUE&PUSH 0)                   ; E
14    (CALL1&JMPIF 4 L73)                 ; MNUMP
17    (GETVALUE&PUSH 0)                   ; E
19    (CALL1&JMPIF 5 L73)                 ; CONSTANT
22    (GETVALUE&PUSH 0)                   ; E
24    (CALL1 7)                           ; RMCONST1
26    (SETVALUE 0)                        ; E
28    (CAR)
29    (SETVALUE 3)                        ; C
31    (GETVALUE 0)                        ; E
33    (CDR)
34    (SETVALUE 8)                        ; NN*
36    (GETVALUE 1)                        ; S
38    (SETVALUE 9)                        ; ND*
40    (CONST 10)                          ; PTIMES%E
41    (CATCH-OPEN L57)
43    (GETVALUE&PUSH 8)                   ; NN*
45    (GETVALUE&PUSH 9)                   ; ND*
47    (CALL2 10)                          ; PTIMES%E
49    (CATCH-CLOSE)
50    (SETVALUE 0)                        ; E
52    (JMPIF L61)
54    L54
54    (NIL)
55    (JMP L89)
57    L57
57    (SETVALUE 0)                        ; E
59    (JMPIFNOT L54)
61    L61
61    (GETVALUE&PUSH 3)                   ; C
63    (GETVALUE&PUSH 0)                   ; E
65    (CALL2 11)                          ; MUL*
67    (SETVALUE 0)                        ; E
69    (GETVALUE 2)                        ; *UPDN
71    (JMPIFNOT L82)
73    L73
73    (GETVALUE&PUSH 0)                   ; E
75    (GETVALUE 6)                        ; BPTU
77    (CONS)
78    (SETVALUE 6)                        ; BPTU
80    (JMP L89)
82    L82
82    (GETVALUE&PUSH 0)                   ; E
84    (GETVALUE 12)                       ; BPTD
86    (CONS)
87    (SETVALUE 12)                       ; BPTD
89    L89
89    (UNBIND 4)
91    (SKIP&RET 3)


Disassembly of function #:|(DEFUN PTIMES%E (TERM N) ...)-55|
(CONST 0) = PTIMES%E
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PTIMES%E>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PTIMES%E
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PTIMES%E
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PTIMES%E>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PTIMES%E
8     (SKIP&RET 1)


Disassembly of function PTIMES%E
(CONST 0) = N
(CONST 1) = VAR
(CONST 2) = POLYINX
(CONST 3) = MEXPTP
(CONST 4) = $%E
(CONST 5) = $REALPART
(CONST 6) = DEG
(CONST 7) = -1
(CONST 8) = ADD*
(CONST 9) = $SIGN
(CONST 10) = $NEG
(CONST 11) = $IMAGPART
(CONST 12) = NN*
(CONST 13) = -2
(CONST 14) = RATCOEF
(CONST 15) = $ASKSIGN
(CONST 16) = $POS
(CONST 17) = *UPDN
(CONST 18) = MTIMESP
(CONST 19) = POLFACTORS
(CONST 20) = MUL*
(CONST 21) = PTIMES%E
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N NN* VAR)
writes special variables : (*UPDN NN*)
93 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; N
3     (LOAD&PUSH 5)
4     (GETVALUE&PUSH 1)                   ; VAR
6     (NIL&PUSH)
7     (CALL 3 2)                          ; POLYINX
10    (JMPIF L90)
13    (LOAD&PUSH 5)
14    (CALL1&JMPIFNOT 3 L96)              ; MEXPTP
18    (LOAD 5)
19    (CDR)
20    (CAR&PUSH)
21    (JMPIFNOTEQTO 4 L96)                ; $%E
25    (LOAD 5)
26    (CDR)
27    (CDR)
28    (CAR&PUSH)
29    (GETVALUE&PUSH 1)                   ; VAR
31    (NIL&PUSH)
32    (CALL 3 2)                          ; POLYINX
35    (JMPIFNOT L96)
37    (LOAD 5)
38    (CDR)
39    (CDR)
40    (CAR&PUSH)
41    (CALL1&PUSH 5)                      ; $REALPART
43    (CALL1&PUSH 6)                      ; DEG
45    (CONST&PUSH 7)                      ; -1
46    (CALL2&PUSH 8)                      ; ADD*
48    (CALL1&PUSH 9)                      ; $SIGN
50    (JMPIFNOTEQTO 10 L96)               ; $NEG
53    (LOAD 5)
54    (CDR)
55    (CDR)
56    (CAR&PUSH)
57    (CALL1 11)                          ; $IMAGPART
59    (SETVALUE 12)                       ; NN*
61    (PUSH)
62    (CALL1&PUSH 6)                      ; DEG
64    (CONST&PUSH 13)                     ; -2
65    (CALL2&PUSH 8)                      ; ADD*
67    (CALL1&PUSH 9)                      ; $SIGN
69    (JMPIFNOTEQTO 10 L96)               ; $NEG
72    (GETVALUE&PUSH 12)                  ; NN*
74    (GETVALUE&PUSH 1)                   ; VAR
76    (CALL2&PUSH 14)                     ; RATCOEF
78    (CALL1&PUSH 15)                     ; $ASKSIGN
80    (JMPIFEQTO 16 L93)                  ; $POS
83    (NIL)
84    L84
84    (SETVALUE 17)                       ; *UPDN
86    (LOAD 5)
87    L87
87    (UNBIND1)
88    (SKIP&RET 3)
90    L90
90    (LOAD 5)
91    (JMP L87)
93    L93
93    (T)
94    (JMP L84)
96    L96
96    (LOAD&PUSH 5)
97    (CALL1&JMPIFNOT 18 L141)            ; MTIMESP
100   (LOAD&PUSH 5)
101   (CALL1 19)                          ; POLFACTORS
103   (SETVALUE 12)                       ; NN*
105   (JMPIFNOT L141)
107   (CAR)
108   (JMPIFNOT L127)
110   (GETVALUE&PUSH 0)                   ; N
112   (CONST&PUSH 7)                      ; -1
113   (GETVALUE 12)                       ; NN*
115   (CAR&PUSH)
116   (CALL1&PUSH 6)                      ; DEG
118   (CALL2&PUSH 20)                     ; MUL*
120   (CALL2&PUSH 8)                      ; ADD*
122   (CALL1&PUSH 9)                      ; $SIGN
124   (JMPIFNOTEQTO 16 L141)              ; $POS
127   L127
127   (GETVALUE 12)                       ; NN*
129   (CDR)
130   (CAR&PUSH)
131   (GETVALUE&PUSH 0)                   ; N
133   (JSR L0)
136   (JMPIFNOT L141)
138   (LOAD 5)
139   (JMPIF1 L87)
141   L141
141   (CONST&PUSH 21)                     ; PTIMES%E
142   (NIL)
143   (THROW)


Disassembly of function #:|(DEFUN CSEMIDOWN (N D VAR) ...)-56|
(CONST 0) = CSEMIDOWN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CSEMIDOWN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CSEMIDOWN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CSEMIDOWN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CSEMIDOWN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CSEMIDOWN
8     (SKIP&RET 1)


Disassembly of function CSEMIDOWN
(CONST 0) = N
(CONST 1) = D
(CONST 2) = VAR
(CONST 3) = PCPRNTD
(CONST 4) = LOWERHALF
(CONST 5) = #<COMPILED-CLOSURE CSEMIDOWN-1>
(CONST 6) = RES
(CONST 7) = PRINCIP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D N)
16 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (T)
10    (BIND 3)                            ; PCPRNTD
12    (GETVALUE&PUSH 0)                   ; N
14    (GETVALUE&PUSH 1)                   ; D
16    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; LOWERHALF
18    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE CSEMIDOWN-1>
19    (CALL&PUSH 4 6)                     ; RES
22    (CALL1 7)                           ; PRINCIP
24    (UNBIND 4)
26    (SKIP&RET 4)


Disassembly of function CSEMIDOWN-1
(CONST 0) = X
(CONST 1) = $IMAGPART
(CONST 2) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CALL1&PUSH 1)                      ; $IMAGPART
7     (JMPIFEQTO 2 L14)                   ; 0
10    (NIL)
11    L11
11    (UNBIND1)
12    (SKIP&RET 2)
14    L14
14    (T)
15    (JMP L11)


Disassembly of function #:|(DEFUN LOWERHALF (J) ...)-57|
(CONST 0) = LOWERHALF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOWERHALF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOWERHALF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOWERHALF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOWERHALF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOWERHALF
8     (SKIP&RET 1)


Disassembly of function LOWERHALF
(CONST 0) = $IMAGPART
(CONST 1) = $ASKSIGN
(CONST 2) = $NEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $IMAGPART
3     (CALL1&PUSH 1)                      ; $ASKSIGN
5     (CONST 2)                           ; $NEG
6     (EQ)
7     (SKIP&RET 2)


Disassembly of function #:|(DEFUN UPPERHALF (J) ...)-58|
(CONST 0) = UPPERHALF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE UPPERHALF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; UPPERHALF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; UPPERHALF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE UPPERHALF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; UPPERHALF
8     (SKIP&RET 1)


Disassembly of function UPPERHALF
(CONST 0) = $IMAGPART
(CONST 1) = $ASKSIGN
(CONST 2) = $POS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $IMAGPART
3     (CALL1&PUSH 1)                      ; $ASKSIGN
5     (CONST 2)                           ; $POS
6     (EQ)
7     (SKIP&RET 2)


Disassembly of function #:|(DEFUN CSEMIUP (N D VAR) ...)-59|
(CONST 0) = CSEMIUP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CSEMIUP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CSEMIUP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CSEMIUP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CSEMIUP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CSEMIUP
8     (SKIP&RET 1)


Disassembly of function CSEMIUP
(CONST 0) = N
(CONST 1) = D
(CONST 2) = VAR
(CONST 3) = PCPRNTD
(CONST 4) = UPPERHALF
(CONST 5) = #<COMPILED-CLOSURE CSEMIUP-1>
(CONST 6) = RES
(CONST 7) = PRINCIP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D N)
16 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (T)
10    (BIND 3)                            ; PCPRNTD
12    (GETVALUE&PUSH 0)                   ; N
14    (GETVALUE&PUSH 1)                   ; D
16    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; UPPERHALF
18    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE CSEMIUP-1>
19    (CALL&PUSH 4 6)                     ; RES
22    (CALL1 7)                           ; PRINCIP
24    (UNBIND 4)
26    (SKIP&RET 4)


Disassembly of function CSEMIUP-1
(CONST 0) = X
(CONST 1) = $IMAGPART
(CONST 2) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CALL1&PUSH 1)                      ; $IMAGPART
7     (JMPIFEQTO 2 L14)                   ; 0
10    (NIL)
11    L11
11    (UNBIND1)
12    (SKIP&RET 2)
14    L14
14    (T)
15    (JMP L11)


Disassembly of function #:|(DEFUN PRINCIP (N) ...)-60|
(CONST 0) = PRINCIP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PRINCIP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRINCIP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PRINCIP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PRINCIP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PRINCIP
8     (SKIP&RET 1)


Disassembly of function PRINCIP
(CONST 0) = N
(CONST 1) = $%I
(CONST 2) = 2
(CONST 3) = MUL
(CONST 4) = 0
(CONST 5) = PRINCIPAL
(CONST 6) = ADD*
(CONST 7) = $RECTFORM
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (N)
39 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; N
3     (GETVALUE 0)                        ; N
5     (JMPIFNOT L32)
7     (CONST&PUSH 1)                      ; $%I
8     (GETVALUE 0)                        ; N
10    (CAR)
11    (JMPIF L35)
13    (CONST 4)                           ; 0
14    L14
14    (PUSH)
15    (GETVALUE 0)                        ; N
17    (CDR)
18    (CAR)
19    (JMPIF L43)
21    (CONST 4)                           ; 0
22    L22
22    (PUSH)
23    (CALL2&PUSH 6)                      ; ADD*
25    (CALL1&PUSH 7)                      ; $RECTFORM
27    (CALL2 3)                           ; MUL
29    L29
29    (UNBIND1)
30    (SKIP&RET 2)
32    L32
32    (NIL)
33    (JMP L29)
35    L35
35    (CONST&PUSH 2)                      ; 2
36    (GETVALUE 0)                        ; N
38    (CAR&PUSH)
39    (CALL2 3)                           ; MUL
41    (JMP L14)
43    L43
43    (CALL0 5)                           ; PRINCIPAL
45    (GETVALUE 0)                        ; N
47    (CDR)
48    (CAR)
49    (JMP L22)


Disassembly of function #:|(DEFUN SCONVERT (E) ...)-61|
(CONST 0) = SCONVERT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SCONVERT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SCONVERT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SCONVERT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SCONVERT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SCONVERT
8     (SKIP&RET 1)


Disassembly of function SCONVERT
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = POLYINX
(CONST 3) = %SIN
(CONST 4) = ((RAT) -1 2)
(CONST 5) = $%I
(CONST 6) = $%E
(CONST 7) = MUL
(CONST 8) = POWER
(CONST 9) = -1
(CONST 10) = MUL*
(CONST 11) = ADD
(CONST 12) = %COS
(CONST 13) = ((RAT) 1 2)
(CONST 14) = SCONVERT
(CONST 15) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
81 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L51)
7     (GETVALUE&PUSH 0)                   ; E
9     (GETVALUE&PUSH 1)                   ; VAR
11    (NIL&PUSH)
12    (CALL 3 2)                          ; POLYINX
15    (JMPIF L55)
17    (GETVALUE 0)                        ; E
19    (CAR)
20    (CAR&PUSH)
21    (JMPIFEQTO 3 L59)                   ; %SIN
24    (GETVALUE 0)                        ; E
26    (CAR)
27    (CAR&PUSH)
28    (JMPIFEQTO 12 L94)                  ; %COS
31    (GETVALUE 0)                        ; E
33    (CAR)
34    (CAR&PUSH)
35    (LIST&PUSH 1)
37    (CONST&SYMBOL-FUNCTION&PUSH 14)     ; SCONVERT
39    (GETVALUE 0)                        ; E
41    (CDR&PUSH)
42    (CALLSR 0 22)                       ; MAPCAR
45    (CONS&PUSH)
46    (CALL1 15)                          ; SIMPLIFY
48    L48
48    (UNBIND1)
49    (SKIP&RET 2)
51    L51
51    (GETVALUE 0)                        ; E
53    (JMP L48)
55    L55
55    (GETVALUE 0)                        ; E
57    (JMP L48)
59    L59
59    (CONST&PUSH 4)                      ; ((RAT) -1 2)
60    (CONST&PUSH 5)                      ; $%I
61    (CONST&PUSH 6)                      ; $%E
62    (CONST&PUSH 5)                      ; $%I
63    (GETVALUE 0)                        ; E
65    (CDR)
66    (CAR&PUSH)
67    (CALL2&PUSH 7)                      ; MUL
69    (CALL2&PUSH 8)                      ; POWER
71    (CONST&PUSH 9)                      ; -1
72    (CONST&PUSH 6)                      ; $%E
73    (CONST&PUSH 9)                      ; -1
74    (CONST&PUSH 5)                      ; $%I
75    (CALL2&PUSH 10)                     ; MUL*
77    (GETVALUE 0)                        ; E
79    (CDR)
80    (CAR&PUSH)
81    (CALL2&PUSH 7)                      ; MUL
83    (CALL2&PUSH 8)                      ; POWER
85    (CALL2&PUSH 10)                     ; MUL*
87    (CALL2&PUSH 11)                     ; ADD
89    (CALL 3 10)                         ; MUL*
92    (JMP L48)
94    L94
94    (CONST&PUSH 13)                     ; ((RAT) 1 2)
95    (CONST&PUSH 6)                      ; $%E
96    (CONST&PUSH 5)                      ; $%I
97    (GETVALUE 0)                        ; E
99    (CDR)
100   (CAR&PUSH)
101   (CALL2&PUSH 7)                      ; MUL
103   (CALL2&PUSH 8)                      ; POWER
105   (CONST&PUSH 6)                      ; $%E
106   (CONST&PUSH 9)                      ; -1
107   (CONST&PUSH 5)                      ; $%I
108   (CALL2&PUSH 10)                     ; MUL*
110   (GETVALUE 0)                        ; E
112   (CDR)
113   (CAR&PUSH)
114   (CALL2&PUSH 7)                      ; MUL
116   (CALL2&PUSH 8)                      ; POWER
118   (CALL2&PUSH 11)                     ; ADD
120   (CALL2 10)                          ; MUL*
122   (JMP L48)


Disassembly of function #:|(DEFUN POLFACTORS (EXP) ...)-62|
(CONST 0) = POLFACTORS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POLFACTORS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POLFACTORS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POLFACTORS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POLFACTORS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POLFACTORS
8     (SKIP&RET 1)


Disassembly of function POLFACTORS
(CONST 0) = EXP
(CONST 1) = MPLUSP
(CONST 2) = MTIMESP
(CONST 3) = VAR
(CONST 4) = POLYINX
(CONST 5) = MULN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
56 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (PUSH-NIL 2)
5     (GETVALUE&PUSH 0)                   ; EXP
7     (CALL1&JMPIF 1 L26)                 ; MPLUSP
10    (GETVALUE&PUSH 0)                   ; EXP
12    (CALL1&JMPIF 2 L31)                 ; MTIMESP
15    (GETVALUE&PUSH 0)                   ; EXP
17    (LIST 1)
19    (SETVALUE 0)                        ; EXP
21    L21
21    (GETVALUE&PUSH 0)                   ; EXP
23    (LOAD&PUSH 0)
24    (JMP L65)
26    L26
26    (NIL)
27    (SKIP 2)
29    (JMP L83)
31    L31
31    (GETVALUE 0)                        ; EXP
33    (CDR&PUSH)
34    (CALLS2 72)                         ; REVERSE
36    (SETVALUE 0)                        ; EXP
38    (JMP L21)
40    L40
40    (LOAD&PUSH 0)
41    (LOAD&CONS&STORE 4)
43    (SKIP 1)
45    (JMP L63)
47    L47
47    (LOAD&CAR&PUSH 0)
49    (LOAD&PUSH 0)
50    (GETVALUE&PUSH 3)                   ; VAR
52    (NIL&PUSH)
53    (CALL 3 4)                          ; POLYINX
56    (JMPIF L40)
58    (LOAD&PUSH 0)
59    (LOAD&CONS&STORE 3)
61    (SKIP 1)
63    L63
63    (LOAD&CDR&STORE 0)
65    L65
65    (LOAD&PUSH 0)
66    (CALLS1&JMPIFNOT 146 L47)           ; ENDP
69    (SKIP 2)
71    (LOAD&PUSH 1)
72    (NIL&PUSH)
73    (CALL2&PUSH 5)                      ; MULN
75    (LOAD&PUSH 1)
76    (NIL&PUSH)
77    (CALL2&PUSH 5)                      ; MULN
79    (LIST 2)
81    (SKIP 2)
83    L83
83    (UNBIND1)
84    (SKIP&RET 2)


Disassembly of function #:|(DEFUN ESAP (E) ...)-63|
(CONST 0) = ESAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ESAP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ESAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ESAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ESAP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ESAP
8     (SKIP&RET 1)


Disassembly of function ESAP
(CONST 0) = E
(CONST 1) = D
(CONST 2) = $%E
(CONST 3) = AMONG
(CONST 4) = MEXPTP
(CONST 5) = $IMAGPART
(CONST 6) = $REALPART
(CONST 7) = POWER
(CONST 8) = (%COS)
(CONST 9) = $%I
(CONST 10) = (%SIN)
(CONST 11) = MUL
(CONST 12) = ADD*
(CONST 13) = MUL*
(CONST 14) = ESAP
(CONST 15) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D E)
writes special variable : (D)
61 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; D
6     (GETVALUE 0)                        ; E
8     (JMPIFATOM L16)
10    (CONST&PUSH 2)                      ; $%E
11    (GETVALUE&PUSH 0)                   ; E
13    (CALL2&JMPIF 3 L61)                 ; AMONG
16    L16
16    (GETVALUE 0)                        ; E
18    (UNBIND1)
19    (JMP L91)
22    L22
22    (GETVALUE 0)                        ; E
24    (CDR)
25    (CDR)
26    (CAR&PUSH)
27    (CALL1 5)                           ; $IMAGPART
29    (SETVALUE 1)                        ; D
31    (CONST&PUSH 2)                      ; $%E
32    (GETVALUE 0)                        ; E
34    (CDR)
35    (CDR)
36    (CAR&PUSH)
37    (CALL1&PUSH 6)                      ; $REALPART
39    (CALL2&PUSH 7)                      ; POWER
41    (CONST&PUSH 8)                      ; (%COS)
42    (GETVALUE&PUSH 1)                   ; D
44    (LIST&PUSH 2)
46    (CONST&PUSH 9)                      ; $%I
47    (CONST&PUSH 10)                     ; (%SIN)
48    (GETVALUE&PUSH 1)                   ; D
50    (LIST&PUSH 2)
52    (CALL2&PUSH 11)                     ; MUL
54    (CALL2&PUSH 12)                     ; ADD*
56    (CALL2 13)                          ; MUL*
58    (UNBIND1)
59    (JMP L91)
61    L61
61    (GETVALUE&PUSH 0)                   ; E
63    (CALL1&JMPIFNOT 4 L73)              ; MEXPTP
66    (GETVALUE 0)                        ; E
68    (CDR)
69    (CAR&PUSH)
70    (JMPIFEQTO 2 L22)                   ; $%E
73    L73
73    (GETVALUE 0)                        ; E
75    (CAR)
76    (CAR&PUSH)
77    (LIST&PUSH 1)
79    (CONST&SYMBOL-FUNCTION&PUSH 14)     ; ESAP
81    (GETVALUE 0)                        ; E
83    (CDR&PUSH)
84    (CALLSR 0 22)                       ; MAPCAR
87    (CONS&PUSH)
88    (CALL1 15)                          ; SIMPLIFY
90    (UNBIND1)
91    L91
91    (UNBIND1)
92    (SKIP&RET 2)


Disassembly of function #:|(DEFUN MTOSC (GRAND) ...)-64|
(CONST 0) = MTOSC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MTOSC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MTOSC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MTOSC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MTOSC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MTOSC
8     (SKIP&RET 1)


Disassembly of function MTOSC
(CONST 0) = NUMDEN
(CONST 1) = NN*
(CONST 2) = N
(CONST 3) = DN*
(CONST 4) = D
(CONST 5) = BPTU
(CONST 6) = BPTD
(CONST 7) = S
(CONST 8) = VAR
(CONST 9) = POLYINX
(CONST 10) = %EINVOLVE
(CONST 11) = $%I
(CONST 12) = AMONG
(CONST 13) = $%E
(CONST 14) = POWER
(CONST 15) = DIV*
(CONST 16) = $RATSIMP
(CONST 17) = DEG
(CONST 18) = 0
(CONST 19) = POLFACTORS
(CONST 20) = X*
(CONST 21) = SCONVERT
(CONST 22) = MUL
(CONST 23) = $EXPAND
(CONST 24) = MPLUSP
(CONST 25) = RIB
(CONST 26) = ADDN
(CONST 27) = CSEMIUP
(CONST 28) = CSEMIDOWN
(CONST 29) = $%PI
(CONST 30) = -1
(CONST 31) = MUL*
(CONST 32) = ADD*
(CONST 33) = SRATSIMP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (BPTD BPTU S N VAR D DN* NN*)
writes special variables : (BPTD BPTU S N D)
170 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1 0)                           ; NUMDEN
3     (GETVALUE 1)                        ; NN*
5     (BIND 2)                            ; N
7     (GETVALUE 3)                        ; DN*
9     (BIND 4)                            ; D
11    (NIL&PUSH)
12    (NIL)
13    (BIND 5)                            ; BPTU
15    (NIL)
16    (BIND 6)                            ; BPTD
18    (NIL)
19    (BIND 7)                            ; S
21    (PUSH-NIL 2)
23    (GETVALUE&PUSH 4)                   ; D
25    (GETVALUE&PUSH 8)                   ; VAR
27    (NIL&PUSH)
28    (CALL 3 9)                          ; POLYINX
31    (JMPIF L83)
33    (GETVALUE&PUSH 4)                   ; D
35    (CALL1 10)                          ; %EINVOLVE
37    (STORE 19)
39    (JMPIFNOT L203)
42    (CONST&PUSH 11)                     ; $%I
43    (LOAD&PUSH 20)
44    (CALL2&JMPIFNOT 12 L203)            ; AMONG
48    (GETVALUE&PUSH 4)                   ; D
50    (CONST&PUSH 13)                     ; $%E
51    (LOAD&PUSH 21)
52    (CALL2&PUSH 14)                     ; POWER
54    (CALL2&PUSH 15)                     ; DIV*
56    (CALL1 16)                          ; $RATSIMP
58    (SETVALUE 4)                        ; D
60    (PUSH)
61    (GETVALUE&PUSH 8)                   ; VAR
63    (NIL&PUSH)
64    (CALL 3 9)                          ; POLYINX
67    (JMPIFNOT L203)
70    (GETVALUE&PUSH 2)                   ; N
72    (CONST&PUSH 13)                     ; $%E
73    (LOAD&PUSH 21)
74    (CALL2&PUSH 14)                     ; POWER
76    (CALL2 15)                          ; DIV*
78    (SETVALUE 2)                        ; N
80    (JMPIFNOT L203)
83    L83
83    (GETVALUE&PUSH 4)                   ; D
85    (CALL1 17)                          ; DEG
87    (SETVALUE 7)                        ; S
89    (PUSH)
90    (JMPIFEQTO 18 L206)                 ; 0
94    (GETVALUE&PUSH 2)                   ; N
96    (CALL1 19)                          ; POLFACTORS
98    (STORE 11)
100   (LOAD 11)
101   (CAR)
102   (JMPIF L209)
105   (GETVALUE&PUSH 2)                   ; N
107   (CALL1 21)                          ; SCONVERT
109   L109
109   (PUSH)
110   (CALL1 23)                          ; $EXPAND
112   (SETVALUE 2)                        ; N
114   (JMPIFNOT L192)
117   (PUSH)
118   (CALL1&JMPIF 24 L220)               ; MPLUSP
122   (GETVALUE&PUSH 2)                   ; N
124   (LIST 1)
126   (SETVALUE 2)                        ; N
128   L128
128   (GETVALUE&PUSH 2)                   ; N
130   (LOAD&JMPIFNOT 0 L146)
133   L133
133   (LOAD&CAR&PUSH 0)
135   (GETVALUE&PUSH 7)                   ; S
137   (CALL2&JMPIFNOT 25 L230)            ; RIB
141   (LOAD&CDR&STORE 0)
143   (LOAD&JMPIF 0 L133)
146   L146
146   (SKIP 1)
148   (LOAD 11)
149   (CAR)
150   (JMPIF L235)
153   (GETVALUE 5)                        ; BPTU
155   (JMPIFNOT L262)
158   L158
158   (PUSH)
159   (NIL&PUSH)
160   (CALL2&PUSH 26)                     ; ADDN
162   (GETVALUE&PUSH 4)                   ; D
164   (GETVALUE&PUSH 8)                   ; VAR
166   (CALL 3 27)                         ; CSEMIUP
169   (STORE 1)
170   (JMPIFNOT L192)
172   (GETVALUE 6)                        ; BPTD
174   (JMPIFNOT L269)
177   L177
177   (PUSH)
178   (NIL&PUSH)
179   (CALL2&PUSH 26)                     ; ADDN
181   (GETVALUE&PUSH 4)                   ; D
183   (GETVALUE&PUSH 8)                   ; VAR
185   (CALL 3 28)                         ; CSEMIDOWN
188   (STORE 0)
189   (JMPIF L271)
192   L192
192   (NIL)
193   L193
193   (SKIP 2)
195   (UNBIND 3)
197   (SKIP 1)
199   (UNBIND 2)
201   (SKIP&RET 2)
203   L203
203   (NIL)
204   (JMP L193)
206   L206
206   (NIL)
207   (JMP L193)
209   L209
209   (CONST&PUSH 20)                     ; X*
210   (LOAD 12)
211   (CDR)
212   (CAR&PUSH)
213   (CALL1&PUSH 21)                     ; SCONVERT
215   (CALL2 22)                          ; MUL
217   (JMP L109)
220   L220
220   (GETVALUE 2)                        ; N
222   (CDR)
223   (SETVALUE 2)                        ; N
225   (JMPIFNOT L192)
227   (JMP L128)
230   L230
230   (SKIP 1)
232   (NIL)
233   (JMP L193)
235   L235
235   (LOAD&CAR&PUSH 11)
237   (CONST&PUSH 20)                     ; X*
238   (GETVALUE&PUSH 5)                   ; BPTU
240   (PUSH-UNBOUND 3)
242   (CALLS1 172)                        ; SUBST
244   (SETVALUE 5)                        ; BPTU
246   (LOAD&CAR&PUSH 11)
248   (CONST&PUSH 20)                     ; X*
249   (GETVALUE&PUSH 6)                   ; BPTD
251   (PUSH-UNBOUND 3)
253   (CALLS1 172)                        ; SUBST
255   (SETVALUE 6)                        ; BPTD
257   (GETVALUE 5)                        ; BPTU
259   (JMPIF L158)
262   L262
262   (CONST 18)                          ; 0
263   (STORE 1)
264   (GETVALUE 6)                        ; BPTD
266   (JMPIF L177)
269   L269
269   (CONST 18)                          ; 0
270   (STORE 0)
271   L271
271   (CONST&PUSH 29)                     ; $%PI
272   (LOAD&PUSH 2)
273   (CONST&PUSH 30)                     ; -1
275   (LOAD&PUSH 3)
276   (CALL2&PUSH 31)                     ; MUL*
278   (CALL2&PUSH 32)                     ; ADD*
280   (CALL2&PUSH 31)                     ; MUL*
282   (CALL1 33)                          ; SRATSIMP
284   (JMP L193)


Disassembly of function #:|(DEFUN EVENFN (E VAR) ...)-65|
(CONST 0) = EVENFN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EVENFN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EVENFN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EVENFN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EVENFN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EVENFN
8     (SKIP&RET 1)


Disassembly of function EVENFN
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = -1
(CONST 3) = MUL*
(CONST 4) = $SUBSTITUTE
(CONST 5) = $RATSUBST
(CONST 6) = ADD*
(CONST 7) = TEMP
(CONST 8) = ZEROP1
(CONST 9) = $RATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (TEMP VAR E)
42 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (CONST&PUSH 2)                      ; -1
7     (GETVALUE&PUSH 0)                   ; E
9     (CALL2&PUSH 3)                      ; MUL*
11    (GETVALUE 1)                        ; VAR
13    (JMPIFATOM L48)
15    (CONST&PUSH 2)                      ; -1
16    (GETVALUE&PUSH 1)                   ; VAR
18    (CALL2&PUSH 3)                      ; MUL*
20    (GETVALUE&PUSH 1)                   ; VAR
22    (GETVALUE&PUSH 0)                   ; E
24    (CALL 3 5)                          ; $RATSUBST
27    L27
27    (PUSH)
28    (CALL2 6)                           ; ADD*
30    (BIND 7)                            ; TEMP
32    (GETVALUE&PUSH 7)                   ; TEMP
34    (CALL1&JMPIF 8 L44)                 ; ZEROP1
37    (GETVALUE&PUSH 7)                   ; TEMP
39    (CALL1&PUSH 9)                      ; $RATSIMP
41    (CALL1&JMPIFNOT 8 L62)              ; ZEROP1
44    L44
44    (T)
45    (UNBIND1)
46    (JMP L64)
48    L48
48    (CONST&PUSH 2)                      ; -1
49    (GETVALUE&PUSH 1)                   ; VAR
51    (CALL2&PUSH 3)                      ; MUL*
53    (GETVALUE&PUSH 1)                   ; VAR
55    (GETVALUE&PUSH 0)                   ; E
57    (CALL 3 4)                          ; $SUBSTITUTE
60    (JMP L27)
62    L62
62    (NIL)
63    (UNBIND1)
64    L64
64    (UNBIND 2)
66    (SKIP&RET 3)


Disassembly of function #:|(DEFUN ODDFN (E VAR) ...)-66|
(CONST 0) = ODDFN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ODDFN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ODDFN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ODDFN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ODDFN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ODDFN
8     (SKIP&RET 1)


Disassembly of function ODDFN
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = -1
(CONST 3) = MUL*
(CONST 4) = $SUBSTITUTE
(CONST 5) = $RATSUBST
(CONST 6) = ADD*
(CONST 7) = TEMP
(CONST 8) = ZEROP1
(CONST 9) = $RATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (TEMP VAR E)
40 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; E
8     (GETVALUE 1)                        ; VAR
10    (JMPIFATOM L45)
12    (CONST&PUSH 2)                      ; -1
13    (GETVALUE&PUSH 1)                   ; VAR
15    (CALL2&PUSH 3)                      ; MUL*
17    (GETVALUE&PUSH 1)                   ; VAR
19    (GETVALUE&PUSH 0)                   ; E
21    (CALL 3 5)                          ; $RATSUBST
24    L24
24    (PUSH)
25    (CALL2 6)                           ; ADD*
27    (BIND 7)                            ; TEMP
29    (GETVALUE&PUSH 7)                   ; TEMP
31    (CALL1&JMPIF 8 L41)                 ; ZEROP1
34    (GETVALUE&PUSH 7)                   ; TEMP
36    (CALL1&PUSH 9)                      ; $RATSIMP
38    (CALL1&JMPIFNOT 8 L59)              ; ZEROP1
41    L41
41    (T)
42    (UNBIND1)
43    (JMP L61)
45    L45
45    (CONST&PUSH 2)                      ; -1
46    (GETVALUE&PUSH 1)                   ; VAR
48    (CALL2&PUSH 3)                      ; MUL*
50    (GETVALUE&PUSH 1)                   ; VAR
52    (GETVALUE&PUSH 0)                   ; E
54    (CALL 3 4)                          ; $SUBSTITUTE
57    (JMP L24)
59    L59
59    (NIL)
60    (UNBIND1)
61    L61
61    (UNBIND 2)
63    (SKIP&RET 3)


Disassembly of function #:|(DEFUN ZTOINF (GRAND VAR) ...)-67|
(CONST 0) = ZTOINF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZTOINF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZTOINF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZTOINF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZTOINF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZTOINF
8     (SKIP&RET 1)


Disassembly of function ZTOINF
(CONST 0) = VAR
(CONST 1) = N
(CONST 2) = D
(CONST 3) = SN*
(CONST 4) = SD*
(CONST 5) = VARLIST
(CONST 6) = S
(CONST 7) = ANS
(CONST 8) = R
(CONST 9) = $SAVEFACTORS
(CONST 10) = CHECKFACTORS
(CONST 11) = TEMP
(CONST 12) = 1
(CONST 13) = LOOPSTOP*
(CONST 14) = -1
(CONST 15) = ADD*
(CONST 16) = $SIGN
(CONST 17) = $POS
(CONST 18) = SCAXN
(CONST 19) = SSP
(CONST 20) = (%SIN %COS %TAN)
(CONST 21) = INVOLVE
(CONST 22) = SCONVERT
(CONST 23) = POLYINX
(CONST 24) = DIVERG
(CONST 25) = RATP
(CONST 26) = MTIMESP
(CONST 27) = SNUMDEN
(CONST 28) = ANDMAPCAR
(CONST 29) = MULN
(CONST 30) = NN*
(CONST 31) = DN*
(CONST 32) = NUMDEN
(CONST 33) = RMCONST1
(CONST 34) = DEG
(CONST 35) = FINDP
(CONST 36) = $INTEGER
(CONST 37) = ASK-INTEGER
(CONST 38) = $YES
(CONST 39) = BXM
(CONST 40) = FAN
(CONST 41) = DIV*
(CONST 42) = $RATSIMP
(CONST 43) = MUL*
(CONST 44) = $SQFR
(CONST 45) = ZTORAT
(CONST 46) = ZMTORAT
(CONST 47) = EVENFN
(CONST 48) = P*LOGNXP
(CONST 49) = LOG*RAT
(CONST 50) = (%LOG)
(CONST 51) = LOGQUAD0
(CONST 52) = BATAPP
(CONST 53) = MTOINF*
(CONST 54) = GGR
(CONST 55) = MPLUSP
(CONST 56) = *NODIVERG
(CONST 57) = DIVERGENT
(CONST 58) = #<COMPILED-CLOSURE ZTOINF-1>
(CONST 59) = ADDN
(CONST 60) = SRATSIMP
(CONST 61) = $MINF
(CONST 62) = $INF
(CONST 63) = METHOD-BY-LIMITS
(CONST 64) = ((RAT) 1 2)
(CONST 65) = MUL
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (TEMP R S N DN* NN* D SD* SN* VAR ANS LOOPSTOP*)
writes special variables : (R S D N DN* NN* LOOPSTOP* ANS TEMP SN* SD* $SAVEFACTORS)
274 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR
3     (NIL)
4     (BIND 1)                            ; N
6     (NIL)
7     (BIND 2)                            ; D
9     (NIL)
10    (BIND 3)                            ; SN*
12    (NIL)
13    (BIND 4)                            ; SD*
15    (NIL)
16    (BIND 5)                            ; VARLIST
18    (NIL)
19    (BIND 6)                            ; S
21    (PUSH-NIL 2)
23    (NIL)
24    (BIND 7)                            ; ANS
26    (NIL)
27    (BIND 8)                            ; R
29    (NIL)
30    (BIND 9)                            ; $SAVEFACTORS
32    (NIL)
33    (BIND 10)                           ; CHECKFACTORS
35    (NIL)
36    (BIND 11)                           ; TEMP
38    (NIL&PUSH)
39    (T)
40    (SETVALUE 9)                        ; $SAVEFACTORS
42    (CONST&PUSH 12)                     ; 1
43    (LIST 1)
45    (SETVALUE 4)                        ; SD*
47    (SETVALUE 3)                        ; SN*
49    (GETVALUE&PUSH 13)                  ; LOOPSTOP*
51    (CONST&PUSH 14)                     ; -1
52    (CALL2&PUSH 15)                     ; ADD*
54    (CALL1&PUSH 16)                     ; $SIGN
56    (JMPIFEQTO 17 L160)                 ; $POS
60    (LOAD&PUSH 41)
62    (CALL1&JMPIFNOT 18 L172)            ; SCAXN
66    (SETVALUE 11)                       ; TEMP
68    (JMPIF L474)
71    L71
71    (LOAD&PUSH 41)
73    (CONST&PUSH 20)                     ; (%SIN %COS %TAN)
74    (CALL2&JMPIFNOT 21 L239)            ; INVOLVE
78    (LOAD&PUSH 41)
80    (CALL1 22)                          ; SCONVERT
82    (STORE 41)
84    L84
84    (NIL)
85    (BIND 53)                           ; MTOINF*
87    (LOAD&PUSH 44)
89    (T&PUSH)
90    (CALL2 54)                          ; GGR
92    (SETVALUE 11)                       ; TEMP
94    (UNBIND1)
95    (JMPIF L455)
98    (LOAD&PUSH 41)
100   (CALL1&JMPIFNOT 55 L128)            ; MPLUSP
103   (T)
104   (BIND 56)                           ; *NODIVERG
106   (CONST 57)                          ; DIVERGENT
108   (CATCH-OPEN L117)
110   (CONST&PUSH 58)                     ; #<COMPILED-CLOSURE ZTOINF-1>
112   (LOAD&CDR&PUSH 48)
114   (CALL2 28)                          ; ANDMAPCAR
116   (CATCH-CLOSE)
117   L117
117   (SETVALUE 7)                        ; ANS
119   (UNBIND1)
120   (JMPIFNOT L128)
122   (GETVALUE&PUSH 7)                   ; ANS
124   (JMPIFNOTEQTO 57 L459)              ; DIVERGENT
128   L128
128   (LOAD&PUSH 41)
130   (GETVALUE&PUSH 0)                   ; VAR
132   (CALL2&JMPIFNOT 47 L160)            ; EVENFN
135   (CONST&PUSH 12)                     ; 1
136   (GETVALUE&PUSH 13)                  ; LOOPSTOP*
138   (CALL2 15)                          ; ADD*
140   (SETVALUE 13)                       ; LOOPSTOP*
142   (JMPIFNOT L160)
144   (LOAD&PUSH 41)
146   (GETVALUE&PUSH 0)                   ; VAR
148   (CONST&PUSH 61)                     ; $MINF
150   (CONST&PUSH 62)                     ; $INF
152   (CALL 4 63)                         ; METHOD-BY-LIMITS
155   (SETVALUE 7)                        ; ANS
157   (JMPIF L468)
160   L160
160   (NIL)
161   (SKIP 1)
163   (UNBIND 5)
165   (SKIP 2)
167   (UNBIND 6)
169   L169
169   (UNBIND1)
170   (SKIP&RET 3)
172   L172
172   (LOAD&PUSH 41)
174   (CALL1 19)                          ; SSP
176   (SETVALUE 11)                       ; TEMP
178   (JMPIFNOT L71)
181   (JMP L474)
184   L184
184   (CALL0 24)                          ; DIVERG
186   (JMP L274)
189   L189
189   (GETVALUE&PUSH 3)                   ; SN*
191   (NIL&PUSH)
192   (CALL2 29)                          ; MULN
194   (SETVALUE 30)                       ; NN*
196   (NIL)
197   (SETVALUE 3)                        ; SN*
199   (GETVALUE&PUSH 4)                   ; SD*
201   (NIL&PUSH)
202   (CALL2 29)                          ; MULN
204   (SETVALUE 31)                       ; DN*
206   (NIL)
207   (SETVALUE 4)                        ; SD*
209   (JMP L274)
211   L211
211   (LOAD&PUSH 17)
212   (LOAD&PUSH 17)
213   (CALL2&PUSH 41)                     ; DIV*
215   (GETVALUE&PUSH 7)                   ; ANS
217   (CALL1 42)                          ; $RATSIMP
219   (JMP L431)
222   L222
222   (GETVALUE 2)                        ; D
224   (JMP L382)
227   L227
227   (LOAD&PUSH 41)
229   (CALL1 51)                          ; LOGQUAD0
231   (SETVALUE 7)                        ; ANS
233   (JMPIFNOT L160)
236   (JMP L425)
239   L239
239   (LOAD&PUSH 41)
241   (GETVALUE&PUSH 0)                   ; VAR
243   (NIL&PUSH)
244   (CALL 3 23)                         ; POLYINX
247   (JMPIF L184)
250   (LOAD&PUSH 41)
252   (GETVALUE&PUSH 0)                   ; VAR
254   (CALL2&JMPIFNOT 25 L270)            ; RATP
257   (LOAD&PUSH 41)
259   (CALL1&JMPIFNOT 26 L270)            ; MTIMESP
262   (CONST&SYMBOL-FUNCTION&PUSH 27)     ; SNUMDEN
264   (LOAD&CDR&PUSH 42)
266   (CALL2&JMPIF 28 L189)               ; ANDMAPCAR
270   L270
270   (LOAD&PUSH 41)
272   (CALL1 32)                          ; NUMDEN
274   L274
274   (GETVALUE&PUSH 30)                  ; NN*
276   (CALL1 33)                          ; RMCONST1
278   (SETVALUE 1)                        ; N
280   (GETVALUE&PUSH 31)                  ; DN*
282   (CALL1 33)                          ; RMCONST1
284   (SETVALUE 2)                        ; D
286   (GETVALUE 1)                        ; N
288   (CAR)
289   (STORE 17)
291   (GETVALUE 1)                        ; N
293   (CDR)
294   (SETVALUE 1)                        ; N
296   (GETVALUE 2)                        ; D
298   (CAR)
299   (STORE 16)
301   (GETVALUE 2)                        ; D
303   (CDR)
304   (SETVALUE 2)                        ; D
306   (PUSH)
307   (GETVALUE&PUSH 0)                   ; VAR
309   (NIL&PUSH)
310   (CALL 3 23)                         ; POLYINX
313   (JMPIFNOT L444)
316   (GETVALUE&PUSH 2)                   ; D
318   (CALL1 34)                          ; DEG
320   (SETVALUE 6)                        ; S
322   (GETVALUE&PUSH 1)                   ; N
324   (CALL1 35)                          ; FINDP
326   (SETVALUE 8)                        ; R
328   (JMPIFNOT L363)
330   (PUSH)
331   (CONST&PUSH 36)                     ; $INTEGER
333   (CALL2&PUSH 37)                     ; ASK-INTEGER
335   (JMPIFNOTEQTO 38 L363)              ; $YES
338   (GETVALUE&PUSH 2)                   ; D
340   (GETVALUE&PUSH 6)                   ; S
342   (CALL2 39)                          ; BXM
344   (STORE 0)
345   (JMPIFNOT L363)
347   (CONST&PUSH 40)                     ; FAN
349   (CONST&PUSH 12)                     ; 1
350   (GETVALUE&PUSH 8)                   ; R
352   (CALL2&PUSH 15)                     ; ADD*
354   (LOAD 2)
355   (CONS)
356   (APPLY 0)
358   (SETVALUE 7)                        ; ANS
360   (JMPIF L211)
363   L363
363   (LOAD&PUSH 41)
365   (GETVALUE&PUSH 0)                   ; VAR
367   (CALL2&JMPIFNOT 25 L394)            ; RATP
370   (GETVALUE&PUSH 1)                   ; N
372   (GETVALUE&PUSH 2)                   ; D
374   (CALL1&JMPIF 26 L222)               ; MTIMESP
378   (GETVALUE&PUSH 2)                   ; D
380   (CALL1 44)                          ; $SQFR
382   L382
382   (PUSH)
383   (GETVALUE&PUSH 6)                   ; S
385   (CONST&SYMBOL-FUNCTION&PUSH 45)     ; ZTORAT
387   (CALL 4 46)                         ; ZMTORAT
390   (SETVALUE 7)                        ; ANS
392   (JMPIF L425)
394   L394
394   (GETVALUE&PUSH 2)                   ; D
396   (GETVALUE&PUSH 0)                   ; VAR
398   (CALL2&JMPIFNOT 47 L436)            ; EVENFN
401   (GETVALUE&PUSH 1)                   ; N
403   (GETVALUE&PUSH 6)                   ; S
405   (CALL2 48)                          ; P*LOGNXP
407   (SETVALUE 30)                       ; NN*
409   (JMPIFNOT L436)
411   (GETVALUE 30)                       ; NN*
413   (CAR&PUSH)
414   (GETVALUE&PUSH 2)                   ; D
416   (GETVALUE 30)                       ; NN*
418   (CDR)
419   (CAR&PUSH)
420   (CALL 3 49)                         ; LOG*RAT
423   (SETVALUE 7)                        ; ANS
425   L425
425   (LOAD&PUSH 17)
426   (LOAD&PUSH 17)
427   (CALL2&PUSH 41)                     ; DIV*
429   (GETVALUE 7)                        ; ANS
431   L431
431   (PUSH)
432   (CALL2 43)                          ; MUL*
434   (JMP L474)
436   L436
436   (LOAD&PUSH 41)
438   (CONST&PUSH 50)                     ; (%LOG)
440   (CALL2&JMPIF 21 L227)               ; INVOLVE
444   L444
444   (LOAD&PUSH 41)
446   (CALL1 52)                          ; BATAPP
448   (SETVALUE 11)                       ; TEMP
450   (JMPIFNOT L84)
453   (JMP L474)
455   L455
455   (GETVALUE 11)                       ; TEMP
457   (JMP L474)
459   L459
459   (GETVALUE&PUSH 7)                   ; ANS
461   (NIL&PUSH)
462   (CALL2&PUSH 59)                     ; ADDN
464   (CALL1 60)                          ; SRATSIMP
466   (JMP L474)
468   L468
468   (CONST&PUSH 64)                     ; ((RAT) 1 2)
470   (GETVALUE&PUSH 7)                   ; ANS
472   (CALL2 65)                          ; MUL
474   L474
474   (SKIP 1)
476   (UNBIND 5)
478   (SKIP 2)
480   (UNBIND 6)
482   (JMP L169)


Disassembly of function ZTOINF-1
(CONST 0) = VAR
(CONST 1) = ZTOINF
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
4 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; VAR
3     (CALL2 1)                           ; ZTOINF
5     (SKIP&RET 2)


Disassembly of function #:|(DEFUN ZTORAT (N D S) ...)-68|
(CONST 0) = ZTORAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZTORAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZTORAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZTORAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZTORAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZTORAT
8     (SKIP&RET 1)


Disassembly of function ZTORAT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = S
(CONST 3) = *DFLAG
(CONST 4) = NN*
(CONST 5) = ZTORAT
(CONST 6) = DIFAPPLY
(CONST 7) = PLOGABS
(CONST 8) = (%PLOG)
(CONST 9) = -1
(CONST 10) = VAR
(CONST 11) = MUL*
(CONST 12) = KEYHOLE
(CONST 13) = "Keyhole failed"
(CONST 14) = MERROR
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (S VAR NN* D N *DFLAG)
writes special variables : (N S)
44 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; S
9     (GETVALUE 3)                        ; *DFLAG
11    (JMPIF L28)
13    (GETVALUE&PUSH 0)                   ; N
15    (GETVALUE&PUSH 1)                   ; D
17    (GETVALUE&PUSH 4)                   ; NN*
19    (CONST&SYMBOL-FUNCTION&PUSH 5)      ; ZTORAT
21    (CALL 4 6)                          ; DIFAPPLY
24    (SETVALUE 2)                        ; S
26    (JMPIF L62)
28    L28
28    (NIL)
29    (BIND 7)                            ; PLOGABS
31    (CONST&PUSH 8)                      ; (%PLOG)
32    (CONST&PUSH 9)                      ; -1
33    (GETVALUE&PUSH 10)                  ; VAR
35    (CALL2&PUSH 11)                     ; MUL*
37    (LIST&PUSH 2)
39    (GETVALUE&PUSH 0)                   ; N
41    (CALL2&PUSH 11)                     ; MUL*
43    (GETVALUE&PUSH 1)                   ; D
45    (GETVALUE&PUSH 10)                  ; VAR
47    (CALL 3 12)                         ; KEYHOLE
50    (UNBIND1)
51    (SETVALUE 0)                        ; N
53    (JMPIF L66)
55    (CONST&PUSH 13)                     ; "Keyhole failed"
56    (CALL1 14)                          ; MERROR
58    L58
58    (UNBIND 3)
60    (SKIP&RET 4)
62    L62
62    (GETVALUE 2)                        ; S
64    (JMP L58)
66    L66
66    (CONST&PUSH 9)                      ; -1
67    (GETVALUE&PUSH 0)                   ; N
69    (CALL2 11)                          ; MUL*
71    (JMP L58)


Disassembly of function #:|(SETQ *DFLAG NIL)-69|
(CONST 0) = *DFLAG
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*DFLAG)
3 byte-code instructions:
0     (NIL)
1     (SETVALUE 0)                        ; *DFLAG
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN LOGQUAD0 (EXP) ...)-70|
(CONST 0) = LOGQUAD0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGQUAD0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGQUAD0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGQUAD0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGQUAD0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGQUAD0
8     (SKIP&RET 1)


Disassembly of function LOGQUAD0
(CONST 0) = EXP
(CONST 1) = A
(CONST 2) = B
(CONST 3) = C
(CONST 4) = LOGQUAD
(CONST 5) = $ASKSIGN
(CONST 6) = $POS
(CONST 7) = DIV*
(CONST 8) = ((RAT) 1 2)
(CONST 9) = POWER*
(CONST 10) = (%ACOS)
(CONST 11) = EPSILON
(CONST 12) = 2
(CONST 13) = MUL*
(CONST 14) = ADD*
(CONST 15) = SIMPLIFY
(CONST 16) = (%LOG)
(CONST 17) = (%SIN)
(CONST 18) = 0
(CONST 19) = $PLUS
(CONST 20) = GET-LIMIT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B A C EXP)
writes special variables : (A B C EXP)
74 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL)
4     (BIND 1)                            ; A
6     (NIL)
7     (BIND 2)                            ; B
9     (NIL)
10    (BIND 3)                            ; C
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CALL1 4)                           ; LOGQUAD
16    (SETVALUE 0)                        ; EXP
18    (JMPIF L95)
21    (NIL)
22    L22
22    (UNBIND 4)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE&PUSH 3)                   ; C
28    (GETVALUE&PUSH 1)                   ; A
30    (CALL2&PUSH 7)                      ; DIV*
32    (CONST&PUSH 8)                      ; ((RAT) 1 2)
33    (CALL2 9)                           ; POWER*
35    (SETVALUE 3)                        ; C
37    (CONST&PUSH 10)                     ; (%ACOS)
38    (CONST&PUSH 11)                     ; EPSILON
39    (GETVALUE&PUSH 2)                   ; B
41    (CONST&PUSH 12)                     ; 2
42    (GETVALUE&PUSH 1)                   ; A
44    (GETVALUE&PUSH 3)                   ; C
46    (CALL&PUSH 3 13)                    ; MUL*
49    (CALL2&PUSH 7)                      ; DIV*
51    (CALL2&PUSH 14)                     ; ADD*
53    (LIST&PUSH 2)
55    (CALL1 15)                          ; SIMPLIFY
57    (SETVALUE 2)                        ; B
59    (PUSH)
60    (CONST&PUSH 16)                     ; (%LOG)
61    (GETVALUE&PUSH 3)                   ; C
63    (LIST&PUSH 2)
65    (CALL2&PUSH 13)                     ; MUL*
67    (GETVALUE&PUSH 1)                   ; A
69    (CONST&PUSH 17)                     ; (%SIN)
70    (GETVALUE&PUSH 2)                   ; B
72    (LIST&PUSH 2)
74    (CALL1&PUSH 15)                     ; SIMPLIFY
76    (GETVALUE&PUSH 3)                   ; C
78    (CALL&PUSH 3 13)                    ; MUL*
81    (CALL2 7)                           ; DIV*
83    (SETVALUE 1)                        ; A
85    (PUSH)
86    (CONST&PUSH 11)                     ; EPSILON
87    (CONST&PUSH 18)                     ; 0
88    (CONST&PUSH 19)                     ; $PLUS
89    (CALL 4 20)                         ; GET-LIMIT
92    (JMP L22)
95    L95
95    (CAR)
96    (SETVALUE 1)                        ; A
98    (GETVALUE 0)                        ; EXP
100   (CDR)
101   (CAR)
102   (SETVALUE 2)                        ; B
104   (GETVALUE 0)                        ; EXP
106   (CDR)
107   (CDR)
108   (CAR)
109   (SETVALUE 3)                        ; C
111   (GETVALUE&PUSH 2)                   ; B
113   (CALL1 5)                           ; $ASKSIGN
115   (GETVALUE&PUSH 3)                   ; C
117   (CALL1&PUSH 5)                      ; $ASKSIGN
119   (JMPIFEQTO 6 L26)                   ; $POS
123   (NIL)
124   (JMP L22)


Disassembly of function #:|(DEFUN LOGQUAD (EXP) ...)-71|
(CONST 0) = LOGQUAD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGQUAD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGQUAD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGQUAD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGQUAD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGQUAD
8     (SKIP&RET 1)


Disassembly of function LOGQUAD
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VARLIST
(CONST 3) = NEWVAR
(CONST 4) = RATREP*
(CONST 5) = PDIS
(CONST 6) = (%LOG)
(CONST 7) = ALIKE1
(CONST 8) = 2
(CONST 9) = 0
(CONST 10) = PTERM
(CONST 11) = ODDELM
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP VAR)
writes special variable : (EXP)
47 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 1)                   ; VAR
5     (LIST 1)
7     (BIND 2)                            ; VARLIST
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CALL1 3)                           ; NEWVAR
13    (GETVALUE&PUSH 0)                   ; EXP
15    (CALL1 4)                           ; RATREP*
17    (CDR)
18    (SETVALUE 0)                        ; EXP
20    (CAR&PUSH)
21    (CALL1&PUSH 5)                      ; PDIS
23    (CONST&PUSH 6)                      ; (%LOG)
24    (GETVALUE&PUSH 1)                   ; VAR
26    (LIST&PUSH 2)
28    (CALL2&JMPIFNOT 7 L54)              ; ALIKE1
31    (GETVALUE 0)                        ; EXP
33    (CDR)
34    (JMPIFATOM L54)
36    (GETVALUE 0)                        ; EXP
38    (CDR)
39    (CDR)
40    (CAR&PUSH)
41    (JMPIFNOTEQTO 8 L54)                ; 2
44    (GETVALUE 0)                        ; EXP
46    (CDR)
47    (CDR&PUSH)
48    (CONST&PUSH 9)                      ; 0
49    (CALL2&PUSH 10)                     ; PTERM
51    (JMPIFNOTEQTO 9 L59)                ; 0
54    L54
54    (NIL)
55    (UNBIND1)
56    L56
56    (UNBIND1)
57    (SKIP&RET 2)
59    L59
59    (CONST&PUSH 5)                      ; PDIS
60    (GETVALUE 0)                        ; EXP
62    (CDR&PUSH)
63    (CALL1 11)                          ; ODDELM
65    (CDR&PUSH)
66    (CALLSR 0 22)                       ; MAPCAR
69    (SETVALUE 0)                        ; EXP
71    (UNBIND1)
72    (JMP L56)


Disassembly of function #:|(DEFUN MTOINF (GRAND VAR) ...)-72|
(CONST 0) = MTOINF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MTOINF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MTOINF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MTOINF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MTOINF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MTOINF
8     (SKIP&RET 1)


Disassembly of function MTOINF
(CONST 0) = VAR
(CONST 1) = ANS
(CONST 2) = SD*
(CONST 3) = SN*
(CONST 4) = P*
(CONST 5) = PE*
(CONST 6) = N
(CONST 7) = D
(CONST 8) = S
(CONST 9) = $SAVEFACTORS
(CONST 10) = CHECKFACTORS
(CONST 11) = TEMP
(CONST 12) = 1
(CONST 13) = LOOPSTOP*
(CONST 14) = -1
(CONST 15) = ADD*
(CONST 16) = $SIGN
(CONST 17) = $POS
(CONST 18) = (%SIN %COS)
(CONST 19) = INVOLVE
(CONST 20) = EVENFN
(CONST 21) = SCAXN
(CONST 22) = SSP
(CONST 23) = 2
(CONST 24) = MUL
(CONST 25) = MTOSC
(CONST 26) = $%I
(CONST 27) = %EINVOLVE
(CONST 28) = AMONG
(CONST 29) = POLYINX
(CONST 30) = DIVERG
(CONST 31) = RATP
(CONST 32) = MTIMESP
(CONST 33) = SNUMDEN
(CONST 34) = ANDMAPCAR
(CONST 35) = MULN
(CONST 36) = NN*
(CONST 37) = DN*
(CONST 38) = NUMDEN
(CONST 39) = RMCONST1
(CONST 40) = DEG
(CONST 41) = EXP
(CONST 42) = (%SINH %COSH %TANH)
(CONST 43) = NOTINVOLVE
(CONST 44) = FINDP
(CONST 45) = $INTEGER
(CONST 46) = ASK-INTEGER
(CONST 47) = $YES
(CONST 48) = BXM
(CONST 49) = $EVEN
(CONST 50) = FAN
(CONST 51) = DIV*
(CONST 52) = MUL*
(CONST 53) = POWER*
(CONST 54) = $%PI
(CONST 55) = $SQFR
(CONST 56) = MTORAT
(CONST 57) = ZMTORAT
(CONST 58) = (%SINH %COSH %TANH)
(CONST 59) = P*PIN%EX
(CONST 60) = PIN%EX
(CONST 61) = DINTEXP
(CONST 62) = $INF
(CONST 63) = GET-LIMIT
(CONST 64) = ZEROP1
(CONST 65) = $MINF
(CONST 66) = RECTZTO%PI2
(CONST 67) = GGRM
(CONST 68) = 0
(CONST 69) = METHOD-BY-LIMITS
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (S EXP DN* N D NN* ANS PE* P* SD* SN* TEMP VAR LOOPSTOP*)
writes special variables : (LOOPSTOP* PE* P* S D N ANS DN* NN* TEMP SN* SD* $SAVEFACTORS)
332 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR
3     (NIL)
4     (BIND 1)                            ; ANS
6     (NIL)
7     (BIND 2)                            ; SD*
9     (NIL)
10    (BIND 3)                            ; SN*
12    (NIL)
13    (BIND 4)                            ; P*
15    (NIL)
16    (BIND 5)                            ; PE*
18    (NIL)
19    (BIND 6)                            ; N
21    (NIL)
22    (BIND 7)                            ; D
24    (NIL)
25    (BIND 8)                            ; S
27    (PUSH-NIL 2)
29    (NIL)
30    (BIND 9)                            ; $SAVEFACTORS
32    (NIL)
33    (BIND 10)                           ; CHECKFACTORS
35    (NIL)
36    (BIND 11)                           ; TEMP
38    (T)
39    (SETVALUE 9)                        ; $SAVEFACTORS
41    (CONST&PUSH 12)                     ; 1
42    (LIST 1)
44    (SETVALUE 2)                        ; SD*
46    (SETVALUE 3)                        ; SN*
48    (GETVALUE&PUSH 13)                  ; LOOPSTOP*
50    (CONST&PUSH 14)                     ; -1
51    (CALL2&PUSH 15)                     ; ADD*
53    (CALL1&PUSH 16)                     ; $SIGN
55    (JMPIFEQTO 17 L594)                 ; $POS
59    (LOAD&PUSH 40)
61    (CONST&PUSH 18)                     ; (%SIN %COS)
62    (CALL2&JMPIF 19 L86)                ; INVOLVE
65    (CONST&PUSH 26)                     ; $%I
66    (LOAD&PUSH 41)
68    (CALL1&PUSH 27)                     ; %EINVOLVE
70    (CALL2&JMPIFNOT 28 L235)            ; AMONG
74    L74
74    (LOAD&PUSH 40)
76    (CALL1 25)                          ; MTOSC
78    (SETVALUE 11)                       ; TEMP
80    (JMPIFNOT L553)
83    (JMP L489)
86    L86
86    (LOAD&PUSH 40)
88    (GETVALUE&PUSH 0)                   ; VAR
90    (CALL2&JMPIFNOT 20 L74)             ; EVENFN
93    (LOAD&PUSH 40)
95    (CALL1 21)                          ; SCAXN
97    (SETVALUE 11)                       ; TEMP
99    (JMPIF L109)
101   (LOAD&PUSH 40)
103   (CALL1 22)                          ; SSP
105   (SETVALUE 11)                       ; TEMP
107   (JMPIFNOT L74)
109   L109
109   (CONST&PUSH 23)                     ; 2
110   (GETVALUE 11)                       ; TEMP
112   (JMP L486)
115   L115
115   (CALL0 30)                          ; DIVERG
117   (JMP L270)
120   L120
120   (GETVALUE&PUSH 3)                   ; SN*
122   (NIL&PUSH)
123   (CALL2 35)                          ; MULN
125   (SETVALUE 36)                       ; NN*
127   (NIL)
128   (SETVALUE 3)                        ; SN*
130   (GETVALUE&PUSH 2)                   ; SD*
132   (NIL&PUSH)
133   (CALL2 35)                          ; MULN
135   (SETVALUE 37)                       ; DN*
137   (NIL)
138   (SETVALUE 2)                        ; SD*
140   (JMP L270)
143   L143
143   (CONST&PUSH 50)                     ; FAN
145   (CONST&PUSH 12)                     ; 1
146   (GETVALUE&PUSH 4)                   ; P*
148   (CALL2&PUSH 15)                     ; ADD*
150   (GETVALUE 5)                        ; PE*
152   (CONS)
153   (APPLY 0)
155   (SETVALUE 1)                        ; ANS
157   (JMPIFNOT L438)
160   (CONST&PUSH 23)                     ; 2
161   (GETVALUE 1)                        ; ANS
163   (JMP L468)
166   L166
166   (GETVALUE&PUSH 1)                   ; ANS
168   (CONST&PUSH 14)                     ; -1
169   (GETVALUE&PUSH 4)                   ; P*
171   (CALL2&PUSH 53)                     ; POWER*
173   (GETVALUE&PUSH 36)                  ; NN*
175   (CALL2&PUSH 24)                     ; MUL
177   (CALL2 15)                          ; ADD*
179   (SETVALUE 1)                        ; ANS
181   (JMP L473)
184   L184
184   (GETVALUE 7)                        ; D
186   (JMP L460)
189   L189
189   (LOAD&PUSH 40)
191   (CALL1&JMPIF 27 L202)               ; %EINVOLVE
194   (LOAD&PUSH 40)
196   (CONST&PUSH 58)                     ; (%SINH %COSH %TANH)
198   (CALL2&JMPIFNOT 19 L553)            ; INVOLVE
202   L202
202   (GETVALUE&PUSH 6)                   ; N
204   (CALL1&JMPIFNOT 59 L553)            ; P*PIN%EX
208   (CONST 60)                          ; PIN%EX
210   (CATCH-OPEN L498)
213   (GETVALUE&PUSH 7)                   ; D
215   (CALL1 60)                          ; PIN%EX
217   (CATCH-CLOSE)
218   (SETVALUE 1)                        ; ANS
220   (JMPIFNOT L553)
223   (JMP L502)
226   L226
226   (LOAD&PUSH 40)
228   (GETVALUE&PUSH 0)                   ; VAR
230   (CALL2 61)                          ; DINTEXP
232   (JMP L489)
235   L235
235   (LOAD&PUSH 40)
237   (GETVALUE&PUSH 0)                   ; VAR
239   (NIL&PUSH)
240   (CALL 3 29)                         ; POLYINX
243   (JMPIF L115)
246   (LOAD&PUSH 40)
248   (GETVALUE&PUSH 0)                   ; VAR
250   (CALL2&JMPIFNOT 31 L266)            ; RATP
253   (LOAD&PUSH 40)
255   (CALL1&JMPIFNOT 32 L266)            ; MTIMESP
258   (CONST&SYMBOL-FUNCTION&PUSH 33)     ; SNUMDEN
260   (LOAD&CDR&PUSH 41)
262   (CALL2&JMPIF 34 L120)               ; ANDMAPCAR
266   L266
266   (LOAD&PUSH 40)
268   (CALL1 38)                          ; NUMDEN
270   L270
270   (GETVALUE&PUSH 36)                  ; NN*
272   (CALL1 39)                          ; RMCONST1
274   (SETVALUE 6)                        ; N
276   (GETVALUE&PUSH 37)                  ; DN*
278   (CALL1 39)                          ; RMCONST1
280   (SETVALUE 7)                        ; D
282   (GETVALUE 6)                        ; N
284   (CAR)
285   (STORE 10)
287   (GETVALUE 6)                        ; N
289   (CDR)
290   (SETVALUE 6)                        ; N
292   (GETVALUE 7)                        ; D
294   (CAR)
295   (STORE 9)
297   (GETVALUE 7)                        ; D
299   (CDR)
300   (SETVALUE 7)                        ; D
302   (PUSH)
303   (GETVALUE&PUSH 0)                   ; VAR
305   (NIL&PUSH)
306   (CALL 3 29)                         ; POLYINX
309   (JMPIFNOT L317)
311   (GETVALUE&PUSH 7)                   ; D
313   (CALL1 40)                          ; DEG
315   (SETVALUE 8)                        ; S
317   L317
317   (LOAD&PUSH 40)
319   (CALL1&JMPIF 27 L438)               ; %EINVOLVE
323   (GETVALUE&PUSH 41)                  ; EXP
325   (CONST&PUSH 42)                     ; (%SINH %COSH %TANH)
327   (CALL2&JMPIFNOT 43 L438)            ; NOTINVOLVE
331   (GETVALUE&PUSH 6)                   ; N
333   (CALL1 44)                          ; FINDP
335   (SETVALUE 4)                        ; P*
337   (JMPIFNOT L438)
340   (PUSH)
341   (CONST&PUSH 45)                     ; $INTEGER
343   (CALL2&PUSH 46)                     ; ASK-INTEGER
345   (JMPIFNOTEQTO 47 L438)              ; $YES
349   (GETVALUE&PUSH 7)                   ; D
351   (GETVALUE&PUSH 8)                   ; S
353   (CALL2 48)                          ; BXM
355   (SETVALUE 5)                        ; PE*
357   (JMPIFNOT L438)
360   (GETVALUE 5)                        ; PE*
362   (CDR)
363   (CDR)
364   (CAR&PUSH)
365   (CONST&PUSH 49)                     ; $EVEN
367   (CALL2&PUSH 46)                     ; ASK-INTEGER
369   (JMPIFNOTEQTO 47 L382)              ; $YES
372   (GETVALUE&PUSH 4)                   ; P*
374   (CONST&PUSH 49)                     ; $EVEN
376   (CALL2&PUSH 46)                     ; ASK-INTEGER
378   (JMPIFEQTO 47 L143)                 ; $YES
382   L382
382   (GETVALUE 5)                        ; PE*
384   (CAR&PUSH)
385   (JMPIFNOTEQTO 12 L438)              ; 1
388   (CONST&PUSH 50)                     ; FAN
390   (CONST&PUSH 12)                     ; 1
391   (GETVALUE&PUSH 4)                   ; P*
393   (CALL2&PUSH 15)                     ; ADD*
395   (GETVALUE 5)                        ; PE*
397   (CONS)
398   (APPLY 0)
400   (SETVALUE 1)                        ; ANS
402   (JMPIFNOT L438)
404   (CONST&PUSH 12)                     ; 1
405   (GETVALUE&PUSH 4)                   ; P*
407   (CALL2&PUSH 15)                     ; ADD*
409   (GETVALUE 5)                        ; PE*
411   (CAR&PUSH)
412   (CONST&PUSH 14)                     ; -1
413   (GETVALUE 5)                        ; PE*
415   (CDR)
416   (CAR&PUSH)
417   (CALL2&PUSH 52)                     ; MUL*
419   (GETVALUE 5)                        ; PE*
421   (CDR)
422   (CDR)
423   (CAR&PUSH)
424   (GETVALUE 5)                        ; PE*
426   (CDR)
427   (CDR)
428   (CDR)
429   (CAR&PUSH)
430   (CALL 5 50)                         ; FAN
433   (SETVALUE 36)                       ; NN*
435   (JMPIF L166)
438   L438
438   (LOAD&PUSH 40)
440   (GETVALUE&PUSH 0)                   ; VAR
442   (CALL2&JMPIFNOT 31 L189)            ; RATP
446   (CONST&PUSH 54)                     ; $%PI
448   (GETVALUE&PUSH 6)                   ; N
450   (GETVALUE&PUSH 7)                   ; D
452   (CALL1&JMPIF 32 L184)               ; MTIMESP
456   (GETVALUE&PUSH 7)                   ; D
458   (CALL1 55)                          ; $SQFR
460   L460
460   (PUSH)
461   (GETVALUE&PUSH 8)                   ; S
463   (CONST&SYMBOL-FUNCTION&PUSH 56)     ; MTORAT
465   (CALL 4 57)                         ; ZMTORAT
468   L468
468   (PUSH)
469   (CALL2 24)                          ; MUL
471   (SETVALUE 1)                        ; ANS
473   L473
473   (LOAD&PUSH 10)
474   (LOAD&PUSH 10)
475   (CALL2&PUSH 51)                     ; DIV*
477   (GETVALUE&PUSH 1)                   ; ANS
479   (CALL2 52)                          ; MUL*
481   (JMP L489)
483   L483
483   (CONST&PUSH 23)                     ; 2
484   (GETVALUE 1)                        ; ANS
486   L486
486   (PUSH)
487   (CALL2 24)                          ; MUL
489   L489
489   (UNBIND 3)
491   (SKIP 2)
493   (UNBIND 8)
495   (JMP L601)
498   L498
498   (SETVALUE 1)                        ; ANS
500   (JMPIFNOT L553)
502   L502
502   (GETVALUE 4)                        ; P*
504   (JMPIFNOT L226)
507   (LOAD&PUSH 40)
509   (GETVALUE&PUSH 0)                   ; VAR
511   (CONST&PUSH 62)                     ; $INF
513   (CALL&PUSH 3 63)                    ; GET-LIMIT
516   (CALL1&JMPIFNOT 64 L551)            ; ZEROP1
519   (LOAD&PUSH 40)
521   (GETVALUE&PUSH 0)                   ; VAR
523   (CONST&PUSH 65)                     ; $MINF
525   (CALL&PUSH 3 63)                    ; GET-LIMIT
528   (CALL1&JMPIFNOT 64 L551)            ; ZEROP1
531   (GETVALUE&PUSH 4)                   ; P*
533   (NIL&PUSH)
534   (CALL2&PUSH 35)                     ; MULN
536   (GETVALUE&PUSH 5)                   ; PE*
538   (NIL&PUSH)
539   (CALL2&PUSH 35)                     ; MULN
541   (GETVALUE&PUSH 7)                   ; D
543   (CALL 3 66)                         ; RECTZTO%PI2
546   (SETVALUE 1)                        ; ANS
548   (JMPIF L473)
551   L551
551   (CALL0 30)                          ; DIVERG
553   L553
553   (LOAD&PUSH 40)
555   (CALL1 67)                          ; GGRM
557   (SETVALUE 1)                        ; ANS
559   (JMPIF L489)
562   (LOAD&PUSH 40)
564   (GETVALUE&PUSH 0)                   ; VAR
566   (CALL2&JMPIFNOT 20 L594)            ; EVENFN
569   (CONST&PUSH 12)                     ; 1
570   (GETVALUE&PUSH 13)                  ; LOOPSTOP*
572   (CALL2 15)                          ; ADD*
574   (SETVALUE 13)                       ; LOOPSTOP*
576   (JMPIFNOT L594)
578   (LOAD&PUSH 40)
580   (GETVALUE&PUSH 0)                   ; VAR
582   (CONST&PUSH 68)                     ; 0
584   (CONST&PUSH 62)                     ; $INF
586   (CALL 4 69)                         ; METHOD-BY-LIMITS
589   (SETVALUE 1)                        ; ANS
591   (JMPIF L483)
594   L594
594   (NIL)
595   (UNBIND 3)
597   (SKIP 2)
599   (UNBIND 8)
601   L601
601   (UNBIND1)
602   (SKIP&RET 3)


Disassembly of function #:|(DEFUN LINPOWER0 (EXP VAR) ...)-73|
(CONST 0) = LINPOWER0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LINPOWER0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LINPOWER0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LINPOWER0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LINPOWER0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LINPOWER0
8     (SKIP&RET 1)


Disassembly of function LINPOWER0
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LINPOWER
(CONST 3) = $EVEN
(CONST 4) = ASK-INTEGER
(CONST 5) = $YES
(CONST 6) = 0
(CONST 7) = RATGREATERP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
27 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; EXP
8     (GETVALUE&PUSH 1)                   ; VAR
10    (CALL2 2)                           ; LINPOWER
12    (SETVALUE 0)                        ; EXP
14    (JMPIFNOT L32)
16    (CDR)
17    (CDR)
18    (CAR&PUSH)
19    (CONST&PUSH 3)                      ; $EVEN
20    (CALL2&PUSH 4)                      ; ASK-INTEGER
22    (JMPIFNOTEQTO 5 L32)                ; $YES
25    (CONST&PUSH 6)                      ; 0
26    (GETVALUE 0)                        ; EXP
28    (CAR&PUSH)
29    (CALL2&JMPIF 7 L37)                 ; RATGREATERP
32    L32
32    (NIL)
33    L33
33    (UNBIND 2)
35    (SKIP&RET 3)
37    L37
37    (GETVALUE 0)                        ; EXP
39    (JMP L33)


Disassembly of function #:|(DEFUN LINPOWER (EXP VAR) ...)-74|
(CONST 0) = LINPOWER
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LINPOWER>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LINPOWER
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LINPOWER
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LINPOWER>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LINPOWER
8     (SKIP&RET 1)


Disassembly of function LINPOWER
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = C
(CONST 3) = VARLIST
(CONST 4) = POLYP
(CONST 5) = NEWVAR
(CONST 6) = RATREP*
(CONST 7) = -1
(CONST 8) = ADD*
(CONST 9) = $DIFF
(CONST 10) = SDIFF
(CONST 11) = DIV*
(CONST 12) = $RATSIMP
(CONST 13) = (MFACTORIAL)
(CONST 14) = MUL*
(CONST 15) = POWER*
(CONST 16) = AMONG
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C VAR EXP)
writes special variable : (C)
82 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (PUSH-NIL 3)
8     (NIL)
9     (BIND 2)                            ; C
11    (NIL)
12    (BIND 3)                            ; VARLIST
14    (GETVALUE&PUSH 0)                   ; EXP
16    (CALL1&JMPIFNOT 4 L119)             ; POLYP
20    (GETVALUE&PUSH 1)                   ; VAR
22    (LIST 1)
24    (BIND 3)                            ; VARLIST
26    (GETVALUE&PUSH 0)                   ; EXP
28    (CALL1 5)                           ; NEWVAR
30    (GETVALUE&PUSH 0)                   ; EXP
32    (CALL1 6)                           ; RATREP*
34    (CDR)
35    (CAR)
36    (STORE 11)
38    (JMPIFATOM L102)
40    (LOAD 11)
41    (CDR)
42    (CAR)
43    (STORE 10)
45    (GETVALUE&PUSH 0)                   ; EXP
47    (GETVALUE&PUSH 1)                   ; VAR
49    (LOAD&PUSH 12)
50    (CONST&PUSH 7)                      ; -1
51    (CALL2&PUSH 8)                      ; ADD*
53    (CALL 3 9)                          ; $DIFF
56    (STORE 11)
58    (PUSH)
59    (GETVALUE&PUSH 1)                   ; VAR
61    (CALL2 10)                          ; SDIFF
63    (STORE 9)
65    (LOAD&PUSH 11)
66    (LOAD&PUSH 10)
67    (CALL2&PUSH 11)                     ; DIV*
69    (CALL1 12)                          ; $RATSIMP
71    (STORE 11)
73    (LOAD&PUSH 9)
74    (CONST&PUSH 13)                     ; (MFACTORIAL)
75    (LOAD&PUSH 12)
76    (LIST&PUSH 2)
78    (CALL2&PUSH 11)                     ; DIV*
80    (CALL1 12)                          ; $RATSIMP
82    (STORE 9)
84    (GETVALUE&PUSH 0)                   ; EXP
86    (CONST&PUSH 7)                      ; -1
87    (LOAD&PUSH 11)
88    (CALL2&PUSH 14)                     ; MUL*
90    (LOAD&PUSH 13)
91    (LOAD&PUSH 13)
92    (CALL2&PUSH 15)                     ; POWER*
94    (CALL2&PUSH 14)                     ; MUL*
96    (CALL2&PUSH 8)                      ; ADD*
98    (CALL1 12)                          ; $RATSIMP
100   (SETVALUE 2)                        ; C
102   L102
102   (GETVALUE&PUSH 1)                   ; VAR
104   (GETVALUE&PUSH 2)                   ; C
106   (CALL2&JMPIFNOT 16 L122)            ; AMONG
109   (NIL)
110   (UNBIND1)
111   L111
111   (UNBIND 2)
113   (SKIP 3)
115   (UNBIND 2)
117   (SKIP&RET 3)
119   L119
119   (NIL)
120   (JMP L111)
122   L122
122   (LOAD&PUSH 9)
123   (LOAD&PUSH 12)
124   (LOAD&PUSH 12)
125   (GETVALUE&PUSH 2)                   ; C
127   (LIST 4)
129   (UNBIND1)
130   (JMP L111)


Disassembly of function #:|(DEFUN MTORAT (N D S) ...)-75|
(CONST 0) = MTORAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MTORAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MTORAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MTORAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MTORAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MTORAT
8     (SKIP&RET 1)


Disassembly of function MTORAT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = S
(CONST 3) = SEMIRAT*
(CONST 4) = *DFLAG
(CONST 5) = MTORAT
(CONST 6) = DIFAPPLY
(CONST 7) = VAR
(CONST 8) = CSEMIUP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR S D N *DFLAG)
writes special variable : (S)
30 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; S
9     (T)
10    (BIND 3)                            ; SEMIRAT*
12    (GETVALUE 4)                        ; *DFLAG
14    (JMPIF L31)
16    (GETVALUE&PUSH 0)                   ; N
18    (GETVALUE&PUSH 1)                   ; D
20    (GETVALUE&PUSH 2)                   ; S
22    (CONST&SYMBOL-FUNCTION&PUSH 5)      ; MTORAT
24    (CALL 4 6)                          ; DIFAPPLY
27    (SETVALUE 2)                        ; S
29    (JMPIF L45)
31    L31
31    (GETVALUE&PUSH 0)                   ; N
33    (GETVALUE&PUSH 1)                   ; D
35    (GETVALUE&PUSH 7)                   ; VAR
37    (CALL 3 8)                          ; CSEMIUP
40    (UNBIND1)
41    L41
41    (UNBIND 3)
43    (SKIP&RET 4)
45    L45
45    (GETVALUE 2)                        ; S
47    (UNBIND1)
48    (JMP L41)


Disassembly of function #:|(DEFUN ZMTORAT (N D S ...) ...)-76|
(CONST 0) = ZMTORAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZMTORAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZMTORAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZMTORAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZMTORAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZMTORAT
8     (SKIP&RET 1)


Disassembly of function ZMTORAT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = S
(CONST 3) = C
(CONST 4) = 1
(CONST 5) = DEG
(CONST 6) = NN*
(CONST 7) = ADD*
(CONST 8) = $SIGN
(CONST 9) = $NEG
(CONST 10) = DIVERG
(CONST 11) = -4
(CONST 12) = $FACTOR
(CONST 13) = RMCONST1
(CONST 14) = MTIMESP
(CONST 15) = PARTNUM
(CONST 16) = RSN*
(CONST 17) = A
(CONST 18) = B
(CONST 19) = DIV*
(CONST 20) = ADDN
(CONST 21) = $XTHRU
(CONST 22) = SRATSIMP
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B A C D N S)
writes special variables : (N C D NN*)
128 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; N
3     (LOAD 6)
4     (BIND 1)                            ; D
6     (LOAD 8)
7     (BIND 2)                            ; S
9     (NIL)
10    (BIND 3)                            ; C
12    (GETVALUE&PUSH 2)                   ; S
14    (CONST&PUSH 4)                      ; 1
15    (GETVALUE&PUSH 0)                   ; N
17    (CALL1 5)                           ; DEG
19    (SETVALUE 6)                        ; NN*
21    (PUSH)
22    (CALL2&PUSH 7)                      ; ADD*
24    (CALL2&PUSH 7)                      ; ADD*
26    (CALL1&PUSH 8)                      ; $SIGN
28    (JMPIFNOTEQTO 9 L83)                ; $NEG
31    (CALL0 10)                          ; DIVERG
33    L33
33    (GETVALUE&PUSH 1)                   ; D
35    (CALL1 12)                          ; $FACTOR
37    (SETVALUE 1)                        ; D
39    (PUSH)
40    (CALL1 13)                          ; RMCONST1
42    (SETVALUE 3)                        ; C
44    (CDR)
45    (SETVALUE 1)                        ; D
47    (GETVALUE 3)                        ; C
49    (CAR)
50    (SETVALUE 3)                        ; C
52    (GETVALUE&PUSH 1)                   ; D
54    (CALL1&JMPIF 14 L95)                ; MTIMESP
57    L57
57    (LOAD&PUSH 13)
58    (GETVALUE&PUSH 0)                   ; N
60    (GETVALUE&PUSH 1)                   ; D
62    (GETVALUE&PUSH 2)                   ; S
64    (FUNCALL 3)
66    (SETVALUE 0)                        ; N
68    (GETVALUE 3)                        ; C
70    (JMPIF L204)
73    (GETVALUE 0)                        ; N
75    L75
75    (PUSH)
76    (CALL1 22)                          ; SRATSIMP
78    (UNBIND1)
79    L79
79    (UNBIND 3)
81    (SKIP&RET 5)
83    L83
83    (GETVALUE&PUSH 2)                   ; S
85    (CONST&PUSH 11)                     ; -4
86    (CALL2&PUSH 7)                      ; ADD*
88    (CALL1&PUSH 8)                      ; $SIGN
90    (JMPIFNOTEQTO 9 L33)                ; $NEG
93    (JMP L57)
95    L95
95    (GETVALUE 1)                        ; D
97    (CDR)
98    (SETVALUE 1)                        ; D
100   (GETVALUE&PUSH 0)                   ; N
102   (GETVALUE&PUSH 1)                   ; D
104   (CALL2 15)                          ; PARTNUM
106   (SETVALUE 0)                        ; N
108   (T)
109   (BIND 16)                           ; RSN*
111   (NIL&PUSH)
112   (GETVALUE&PUSH 0)                   ; N
114   (GETVALUE&PUSH 1)                   ; D
116   (JMP L169)
118   L118
118   (SKIP 2)
120   (JMP L181)
122   L122
122   (GETVALUE&PUSH 0)                   ; N
124   (GETVALUE&PUSH 3)                   ; C
126   (CALL2 19)                          ; DIV*
128   (UNBIND1)
129   (JMP L79)
131   L131
131   (LOAD&CAR&PUSH 1)
133   (LOAD 1)
134   (BIND 17)                           ; A
136   (LOAD 3)
137   (BIND 18)                           ; B
139   (LOAD&PUSH 27)
141   (GETVALUE 17)                       ; A
143   (CAR&PUSH)
144   (GETVALUE&PUSH 18)                  ; B
146   (GETVALUE&PUSH 18)                  ; B
148   (CALL1&PUSH 5)                      ; DEG
150   (FUNCALL&PUSH 3)
152   (GETVALUE 17)                       ; A
154   (CDR)
155   (CAR&PUSH)
156   (CALL2 19)                          ; DIV*
158   (UNBIND 2)
160   (PUSH)
161   (LOAD&CONS&STORE 4)
163   (SKIP 2)
165   (LOAD&CDR&STORE 1)
167   (LOAD&CDR&STORE 0)
169   L169
169   (LOAD&PUSH 1)
170   (CALLS1&JMPIF 146 L118)             ; ENDP
173   (LOAD&CAR&PUSH 1)
175   (LOAD&PUSH 1)
176   (CALLS1&JMPIFNOT 146 L131)          ; ENDP
179   (SKIP 3)
181   L181
181   (LOAD&PUSH 0)
182   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
185   (NIL&PUSH)
186   (CALL2&PUSH 20)                     ; ADDN
188   (CALL1 21)                          ; $XTHRU
190   (SETVALUE 0)                        ; N
192   (UNBIND1)
193   (GETVALUE 3)                        ; C
195   (JMPIF L122)
198   (GETVALUE 0)                        ; N
200   (UNBIND1)
201   (JMP L79)
204   L204
204   (GETVALUE&PUSH 0)                   ; N
206   (GETVALUE&PUSH 3)                   ; C
208   (CALL2 19)                          ; DIV*
210   (JMP L75)


Disassembly of function #:|(DEFUN PFRNUM (F G N ...) ...)-77|
(CONST 0) = PFRNUM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PFRNUM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PFRNUM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PFRNUM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PFRNUM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PFRNUM
8     (SKIP&RET 1)


Disassembly of function PFRNUM
(CONST 0) = F
(CONST 1) = N
(CONST 2) = VAR
(CONST 3) = VARLIST
(CONST 4) = GENVAR
(CONST 5) = POLYFORM
(CONST 6) = RATREP*
(CONST 7) = RESPROG0
(CONST 8) = PDIS
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N F VAR)
writes special variables : (VAR N F)
55 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; F
3     (LOAD 6)
4     (BIND 1)                            ; N
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (GETVALUE&PUSH 2)                   ; VAR
11    (LIST 1)
13    (BIND 3)                            ; VARLIST
15    (NIL)
16    (BIND 4)                            ; GENVAR
18    (GETVALUE&PUSH 0)                   ; F
20    (CALL1 5)                           ; POLYFORM
22    (SETVALUE 0)                        ; F
24    (LOAD&PUSH 19)
25    (CALL1 5)                           ; POLYFORM
27    (STORE 19)
29    (GETVALUE&PUSH 1)                   ; N
31    (CALL1 5)                           ; POLYFORM
33    (SETVALUE 1)                        ; N
35    (LOAD&PUSH 17)
36    (CALL1 5)                           ; POLYFORM
38    (STORE 17)
40    (GETVALUE&PUSH 2)                   ; VAR
42    (CALL1 6)                           ; RATREP*
44    (CDR)
45    (CAR)
46    (CAR)
47    (SETVALUE 2)                        ; VAR
49    (GETVALUE&PUSH 0)                   ; F
51    (LOAD&PUSH 20)
52    (GETVALUE&PUSH 1)                   ; N
54    (LOAD&PUSH 20)
55    (CALL 4 7)                          ; RESPROG0
58    (SETVALUE 0)                        ; F
60    (CDR)
61    (CAR&PUSH)
62    (CALL1&PUSH 8)                      ; PDIS
64    (GETVALUE 0)                        ; F
66    (CDR)
67    (CDR&PUSH)
68    (CALL1&PUSH 8)                      ; PDIS
70    (LIST&PUSH 2)
72    (GETVALUE 0)                        ; F
74    (CAR)
75    (CAR&PUSH)
76    (CALL1&PUSH 8)                      ; PDIS
78    (GETVALUE 0)                        ; F
80    (CAR)
81    (CDR&PUSH)
82    (CALL1&PUSH 8)                      ; PDIS
84    (LIST&PUSH 2)
86    (LIST 2)
88    (UNBIND 5)
90    (SKIP&RET 6)


Disassembly of function #:|(DEFUN POLYFORM (E) ...)-78|
(CONST 0) = POLYFORM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POLYFORM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POLYFORM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POLYFORM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POLYFORM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POLYFORM
8     (SKIP&RET 1)


Disassembly of function POLYFORM
(CONST 0) = E
(CONST 1) = F
(CONST 2) = D
(CONST 3) = NEWVAR
(CONST 4) = RATREP*
(CONST 5) = 1
(CONST 6) = 3
(CONST 7) = AMONG
(CONST 8) = -1
(CONST 9) = PTIMES
(CONST 10) = "Bug from PFRNUM in RESIDU"
(CONST 11) = MERROR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D F E)
writes special variables : (D F)
60 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; F
6     (NIL)
7     (BIND 2)                            ; D
9     (GETVALUE&PUSH 0)                   ; E
11    (CALL1 3)                           ; NEWVAR
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1 4)                           ; RATREP*
17    (SETVALUE 1)                        ; F
19    (CDR)
20    (CDR&PUSH)
21    (JMPIFEQTO 5 L55)                   ; 1
24    (GETVALUE 1)                        ; F
26    (CDR)
27    (CDR)
28    (SETVALUE 2)                        ; D
30    (PUSH)
31    (CALLS2&PUSH 71)                    ; LENGTH
33    (JMPIFNOTEQTO 6 L46)                ; 3
36    (GETVALUE 2)                        ; D
38    (CAR&PUSH)
39    (GETVALUE 1)                        ; F
41    (CDR)
42    (CAR&PUSH)
43    (CALL2&JMPIFNOT 7 L63)              ; AMONG
46    L46
46    (CONST&PUSH 10)                     ; "Bug from PFRNUM in RESIDU"
47    (CALL1 11)                          ; MERROR
49    (NIL)
50    (UNBIND 2)
52    L52
52    (UNBIND1)
53    (SKIP&RET 2)
55    L55
55    (GETVALUE 1)                        ; F
57    (CDR)
58    (CAR)
59    (UNBIND 2)
61    (JMP L52)
63    L63
63    (GETVALUE 2)                        ; D
65    (CAR&PUSH)
66    (CONST&PUSH 8)                      ; -1
67    (GETVALUE 2)                        ; D
69    (CDR)
70    (CAR&PUSH)
71    (CALLSR&PUSH 2 55)                  ; *
74    (GETVALUE 1)                        ; F
76    (CDR)
77    (CAR&PUSH)
78    (GETVALUE 2)                        ; D
80    (CDR)
81    (CDR)
82    (CAR&PUSH)
83    (CALL2&PUSH 9)                      ; PTIMES
85    (LIST 3)
87    (UNBIND 2)
89    (JMP L52)


Disassembly of function #:|(DEFUN PARTNUM (N DL) ...)-79|
(CONST 0) = PARTNUM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARTNUM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARTNUM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARTNUM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARTNUM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARTNUM
8     (SKIP&RET 1)


Disassembly of function PARTNUM
(CONST 0) = N
(CONST 1) = 1
(CONST 2) = ANS
(CONST 3) = MULN
(CONST 4) = VAR
(CONST 5) = PFRNUM
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR N)
writes special variables : (N ANS)
53 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (CONST&PUSH 1)                      ; 1
4     (NIL)
5     (BIND 2)                            ; ANS
7     (NIL&PUSH)
8     (LOAD&PUSH 9)
9     (JMP L54)
11    L11
11    (LOAD&CAR&PUSH 0)
13    (LOAD&CDR&PUSH 1)
15    (NIL&PUSH)
16    (CALL2&PUSH 3)                      ; MULN
18    (GETVALUE&PUSH 0)                   ; N
20    (LOAD&PUSH 8)
21    (GETVALUE&PUSH 4)                   ; VAR
23    (CALL 5 5)                          ; PFRNUM
26    (STORE 1)
27    (GETVALUE&PUSH 2)                   ; ANS
29    (LOAD&CAR&PUSH 2)
31    (NIL)
32    (CONS&PUSH)
33    (CALLSR 2 35)                       ; NCONC
36    (SETVALUE 2)                        ; ANS
38    (LOAD 1)
39    (CDR)
40    (CAR)
41    (CDR)
42    (CAR)
43    (STORE 5)
44    (LOAD 1)
45    (CDR)
46    (CAR)
47    (CAR)
48    (SETVALUE 0)                        ; N
50    (NIL&STORE 1)
52    (LOAD&CDR&STORE 0)
54    L54
54    (LOAD 0)
55    (CDR)
56    (JMPIF L11)
58    (GETVALUE&PUSH 2)                   ; ANS
60    (GETVALUE&PUSH 0)                   ; N
62    (LOAD&PUSH 7)
63    (LIST&PUSH 2)
65    (NIL)
66    (CONS&PUSH)
67    (CALLSR 2 35)                       ; NCONC
70    (SKIP 2)
72    (UNBIND1)
73    (SKIP 1)
75    (UNBIND1)
76    (SKIP&RET 3)


Disassembly of function #:|(DEFUN GGRM (E) ...)-80|
(CONST 0) = GGRM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GGRM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GGRM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GGRM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GGRM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GGRM
8     (SKIP&RET 1)


Disassembly of function GGRM
(CONST 0) = E
(CONST 1) = MTOINF*
(CONST 2) = VARLIST
(CONST 3) = GENVAR
(CONST 4) = L
(CONST 5) = C
(CONST 6) = VAR
(CONST 7) = %EINVOLVE
(CONST 8) = $%E
(CONST 9) = POWER
(CONST 10) = DIV*
(CONST 11) = $RATSIMP
(CONST 12) = POLYP
(CONST 13) = GGRM
(CONST 14) = GGR
(CONST 15) = -1
(CONST 16) = 0
(CONST 17) = SUBIN
(CONST 18) = MUL*
(CONST 19) = ADD
(CONST 20) = MUL
(CONST 21) = ADD*
(CONST 22) = NEWVAR
(CONST 23) = RATREP*
(CONST 24) = PDIS
(CONST 25) = POWER*
(CONST 26) = B
(CONST 27) = A
(CONST 28) = GGRM1
(CONST 29) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C B A L E VAR)
writes special variables : (E C L MTOINF* VARLIST)
178 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (PUSH-NIL 2)
5     (NIL)
6     (BIND 1)                            ; MTOINF*
8     (NIL&PUSH)
9     (NIL)
10    (BIND 2)                            ; VARLIST
12    (NIL)
13    (BIND 3)                            ; GENVAR
15    (NIL)
16    (BIND 4)                            ; L
18    (NIL)
19    (BIND 5)                            ; C
21    (NIL&PUSH)
22    (GETVALUE&PUSH 6)                   ; VAR
24    (LIST 1)
26    (SETVALUE 2)                        ; VARLIST
28    (T)
29    (SETVALUE 1)                        ; MTOINF*
31    (GETVALUE&PUSH 0)                   ; E
33    (CALL1 7)                           ; %EINVOLVE
35    (STORE 17)
37    (JMPIFNOT L70)
39    (GETVALUE&PUSH 0)                   ; E
41    (CONST&PUSH 8)                      ; $%E
42    (LOAD&PUSH 19)
43    (CALL2&PUSH 9)                      ; POWER
45    (CALL2&PUSH 10)                     ; DIV*
47    (CALL1 11)                          ; $RATSIMP
49    (STORE 18)
51    (PUSH)
52    (CALL1&JMPIFNOT 12 L70)             ; POLYP
55    (CONST 13)                          ; GGRM
56    (CATCH-OPEN L92)
58    (CONST&PUSH 8)                      ; $%E
59    (LOAD&PUSH 21)
60    (CALL2&PUSH 9)                      ; POWER
62    (NIL&PUSH)
63    (CALL2 14)                          ; GGR
65    (CATCH-CLOSE)
66    (SETVALUE 4)                        ; L
68    (JMPIF L96)
70    L70
70    (NIL)
71    (SKIP 1)
73    (UNBIND 4)
75    (SKIP 1)
77    (UNBIND1)
78    (SKIP 2)
80    (JMP L278)
83    L83
83    (CONST&PUSH 16)                     ; 0
84    (LOAD&PUSH 19)
85    (LIST 2)
87    (STORE 18)
89    (JMP L222)
92    L92
92    (SETVALUE 4)                        ; L
94    (JMPIFNOT L70)
96    L96
96    (NIL)
97    (SETVALUE 1)                        ; MTOINF*
99    (CONST&PUSH 15)                     ; -1
100   (CONST&PUSH 16)                     ; 0
101   (GETVALUE 4)                        ; L
103   (CDR)
104   (CAR&PUSH)
105   (CALL2&PUSH 17)                     ; SUBIN
107   (CALL2 18)                          ; MUL*
109   (STORE 13)
111   (PUSH)
112   (GETVALUE&PUSH 6)                   ; VAR
114   (CALL2&PUSH 19)                     ; ADD
116   (LOAD&PUSH 19)
117   (CALL2&PUSH 17)                     ; SUBIN
119   (LOAD&PUSH 14)
120   (CONST&PUSH 15)                     ; -1
121   (GETVALUE&PUSH 6)                   ; VAR
123   (CALL2&PUSH 20)                     ; MUL
125   (CALL2&PUSH 19)                     ; ADD
127   (LOAD&PUSH 20)
128   (CALL2&PUSH 17)                     ; SUBIN
130   (CALL2 21)                          ; ADD*
132   (STORE 18)
134   (GETVALUE 4)                        ; L
136   (CDR)
137   (CDR)
138   (CAR)
139   (STORE 17)
141   (GETVALUE 4)                        ; L
143   (CDR)
144   (CDR)
145   (CDR)
146   (CAR)
147   (SETVALUE 5)                        ; C
149   (CONST&PUSH 15)                     ; -1
150   (GETVALUE 4)                        ; L
152   (CAR&PUSH)
153   (CALL2 18)                          ; MUL*
155   (SETVALUE 4)                        ; L
157   (NIL)
158   (SETVALUE 0)                        ; E
160   (LOAD&PUSH 18)
161   (CALL1 22)                          ; NEWVAR
163   (LOAD&PUSH 18)
164   (CALL1 23)                          ; RATREP*
166   (CDR)
167   (STORE 18)
169   (CDR&PUSH)
170   (CALL1&PUSH 24)                     ; PDIS
172   (CONST&PUSH 15)                     ; -1
173   (CALL2 25)                          ; POWER*
175   (STORE 13)
177   (LOAD&CAR&STORE 18 18)
180   (GETVALUE&PUSH 6)                   ; VAR
182   (CALL1 23)                          ; RATREP*
184   (CDR)
185   (CAR)
186   (CAR)
187   (STORE 0)
188   (LOAD 18)
190   (JMPIFATOM L83)
193   (LOAD&PUSH 0)
194   (LOAD 19)
196   (CAR)
197   (BIND 26)                           ; B
199   (LOAD 3)
200   (BIND 27)                           ; A
202   (GETVALUE&PUSH 27)                  ; A
204   (CALLS1&PUSH 78)                    ; SYMBOL-VALUE
206   (GETVALUE&PUSH 26)                  ; B
208   (CALLS1&PUSH 78)                    ; SYMBOL-VALUE
210   (CALLSR 1 48)                       ; >
213   (UNBIND 2)
215   (SKIP 1)
217   (JMPIF L83)
220   (LOAD&CDR&STORE 18)
222   L222
222   (LOAD&PUSH 18)
223   (LOAD&JMPIFNOT 0 L251)
226   L226
226   (LOAD&CAR&PUSH 0)
228   (LOAD 1)
229   (CDR)
230   (CAR&PUSH)
231   (CALL1&PUSH 24)                     ; PDIS
233   (GETVALUE&PUSH 4)                   ; L
235   (LOAD&PUSH 21)
236   (CALL&PUSH 4 28)                    ; GGRM1
239   (GETVALUE 0)                        ; E
241   (CONS)
242   (SETVALUE 0)                        ; E
244   (LOAD 0)
245   (CDR)
246   (CDR)
247   (STORE 0)
248   (LOAD&JMPIF 0 L226)
251   L251
251   (CONST&PUSH 8)                      ; $%E
252   (GETVALUE&PUSH 5)                   ; C
254   (CALL2&PUSH 9)                      ; POWER
256   (LOAD&PUSH 19)
257   (CONST&PUSH 15)                     ; -1
258   (CALL2&PUSH 9)                      ; POWER
260   (LOAD&PUSH 16)
261   (GETVALUE&PUSH 0)                   ; E
263   (NIL&PUSH)
264   (CALL2&PUSH 29)                     ; ADDN
266   (CALL 4 18)                         ; MUL*
269   (SKIP 2)
271   (UNBIND 4)
273   (SKIP 1)
275   (UNBIND1)
276   (SKIP 2)
278   L278
278   (UNBIND1)
279   (SKIP&RET 2)


Disassembly of function #:|(DEFUN GGRM1 (D K A ...) ...)-81|
(CONST 0) = GGRM1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GGRM1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GGRM1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GGRM1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GGRM1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GGRM1
8     (SKIP&RET 1)


Disassembly of function GGRM1
(CONST 0) = D
(CONST 1) = K
(CONST 2) = A
(CONST 3) = B
(CONST 4) = 1
(CONST 5) = ADD
(CONST 6) = DIV*
(CONST 7) = (%GAMMA)
(CONST 8) = -1
(CONST 9) = MUL*
(CONST 10) = POWER*
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A K B D)
writes special variable : (B)
26 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; D
3     (LOAD 6)
4     (BIND 1)                            ; K
6     (LOAD 8)
7     (BIND 2)                            ; A
9     (LOAD 10)
10    (BIND 3)                            ; B
12    (CONST&PUSH 4)                      ; 1
13    (GETVALUE&PUSH 0)                   ; D
15    (CALL2&PUSH 5)                      ; ADD
17    (GETVALUE&PUSH 3)                   ; B
19    (CALL2 6)                           ; DIV*
21    (SETVALUE 3)                        ; B
23    (GETVALUE&PUSH 1)                   ; K
25    (CONST&PUSH 7)                      ; (%GAMMA)
26    (GETVALUE&PUSH 3)                   ; B
28    (LIST&PUSH 2)
30    (GETVALUE&PUSH 2)                   ; A
32    (CONST&PUSH 8)                      ; -1
33    (GETVALUE&PUSH 3)                   ; B
35    (CALL2&PUSH 9)                      ; MUL*
37    (CALL2&PUSH 10)                     ; POWER*
39    (CALL 3 9)                          ; MUL*
42    (UNBIND 4)
44    (SKIP&RET 5)


Disassembly of function #:|(DEFUN RADIC (E V) ...)-82|
(CONST 0) = RADIC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RADIC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RADIC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RADIC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RADIC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RADIC
8     (SKIP&RET 1)


Disassembly of function RADIC
(CONST 0) = E
(CONST 1) = V
(CONST 2) = RD*
(CONST 3) = RADICALP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (V E)
11 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; V
6     (NIL)
7     (BIND 2)                            ; RD*
9     (GETVALUE&PUSH 0)                   ; E
11    (GETVALUE&PUSH 1)                   ; V
13    (CALL2 3)                           ; RADICALP
15    (UNBIND 3)
17    (SKIP&RET 3)


Disassembly of function #:|(DEFUN KEYHOLE (N D VAR) ...)-83|
(CONST 0) = KEYHOLE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE KEYHOLE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; KEYHOLE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; KEYHOLE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE KEYHOLE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; KEYHOLE
8     (SKIP&RET 1)


Disassembly of function KEYHOLE
(CONST 0) = N
(CONST 1) = D
(CONST 2) = VAR
(CONST 3) = SEMIRAT*
(CONST 4) = #<COMPILED-CLOSURE KEYHOLE-1>
(CONST 5) = #<COMPILED-CLOSURE KEYHOLE-2>
(CONST 6) = RES
(CONST 7) = RSN*
(CONST 8) = 0
(CONST 9) = ADD*
(CONST 10) = $MULTTHRU
(CONST 11) = $RECTFORM
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D N)
writes special variable : (N)
43 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (NIL)
10    (BIND 3)                            ; SEMIRAT*
12    (GETVALUE&PUSH 0)                   ; N
14    (GETVALUE&PUSH 1)                   ; D
16    (CONST&PUSH 4)                      ; #<COMPILED-CLOSURE KEYHOLE-1>
17    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE KEYHOLE-2>
18    (CALL 4 6)                          ; RES
21    (SETVALUE 0)                        ; N
23    (T)
24    (BIND 7)                            ; RSN*
26    (GETVALUE 0)                        ; N
28    (CAR)
29    (JMPIF L51)
31    (CONST 8)                           ; 0
32    L32
32    (PUSH)
33    (GETVALUE 0)                        ; N
35    (CDR)
36    (CAR)
37    (JMPIF L56)
39    (CONST 8)                           ; 0
40    L40
40    (PUSH)
41    (CALL2&PUSH 9)                      ; ADD*
43    (CALL1&PUSH 10)                     ; $MULTTHRU
45    (CALL1 11)                          ; $RECTFORM
47    (UNBIND 5)
49    (SKIP&RET 4)
51    L51
51    (GETVALUE 0)                        ; N
53    (CAR)
54    (JMP L32)
56    L56
56    (GETVALUE 0)                        ; N
58    (CDR)
59    (CAR)
60    (JMP L40)


Disassembly of function KEYHOLE-1
(CONST 0) = $IMAGPART
(CONST 1) = 0
(CONST 2) = $ASKSIGN
(CONST 3) = $NEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
13 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $IMAGPART
3     (CONST 1)                           ; 0
4     (EQ)
5     (NOT)
6     (JMPIF1 L15)
8     (LOAD&PUSH 1)
9     (CALL1&PUSH 2)                      ; $ASKSIGN
11    (CONST 3)                           ; $NEG
12    (EQ)
13    (SKIP&RET 2)
15    L15
15    (SKIP&RET 2)


Disassembly of function KEYHOLE-2
(CONST 0) = $ASKSIGN
(CONST 1) = $POS
(CONST 2) = DIVERG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $ASKSIGN
3     (JMPIFEQTO 1 L10)                   ; $POS
6     (CALL0 2)                           ; DIVERG
8     (SKIP&RET 2)
10    L10
10    (T)
11    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SKR (E) ...)-84|
(CONST 0) = SKR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SKR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SKR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SKR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SKR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SKR
8     (SKIP&RET 1)


Disassembly of function SKR
(CONST 0) = E
(CONST 1) = M
(CONST 2) = R
(CONST 3) = K
(CONST 4) = VAR
(CONST 5) = 1
(CONST 6) = PARTITION
(CONST 7) = SINRX
(CONST 8) = MEXPTP
(CONST 9) = $INTEGER
(CONST 10) = ASK-INTEGER
(CONST 11) = $YES
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (K R M VAR E)
writes special variables : (K R M E)
61 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; M
6     (NIL)
7     (BIND 2)                            ; R
9     (NIL)
10    (BIND 3)                            ; K
12    (GETVALUE 0)                        ; E
14    (JMPIFATOM L70)
16    (GETVALUE&PUSH 0)                   ; E
18    (GETVALUE&PUSH 4)                   ; VAR
20    (CONST&PUSH 5)                      ; 1
21    (CALL 3 6)                          ; PARTITION
24    (SETVALUE 0)                        ; E
26    (CAR)
27    (SETVALUE 1)                        ; M
29    (GETVALUE 0)                        ; E
31    (CDR)
32    (SETVALUE 0)                        ; E
34    (PUSH)
35    (CALL1 7)                           ; SINRX
37    (SETVALUE 2)                        ; R
39    (JMPIF L76)
41    (GETVALUE&PUSH 0)                   ; E
43    (CALL1&JMPIFNOT 8 L70)              ; MEXPTP
46    (GETVALUE 0)                        ; E
48    (CDR)
49    (CDR)
50    (CAR)
51    (SETVALUE 3)                        ; K
53    (PUSH)
54    (CONST&PUSH 9)                      ; $INTEGER
55    (CALL2&PUSH 10)                     ; ASK-INTEGER
57    (JMPIFNOTEQTO 11 L70)               ; $YES
60    (GETVALUE 0)                        ; E
62    (CDR)
63    (CAR&PUSH)
64    (CALL1 7)                           ; SINRX
66    (SETVALUE 2)                        ; R
68    (JMPIF L83)
70    L70
70    (NIL)
71    (UNBIND 3)
73    L73
73    (UNBIND1)
74    (SKIP&RET 2)
76    L76
76    (GETVALUE&PUSH 1)                   ; M
78    (GETVALUE&PUSH 2)                   ; R
80    (CONST 5)                           ; 1
81    (JMP L89)
83    L83
83    (GETVALUE&PUSH 1)                   ; M
85    (GETVALUE&PUSH 2)                   ; R
87    (GETVALUE 3)                        ; K
89    L89
89    (PUSH)
90    (LIST 3)
92    (UNBIND 3)
94    (JMP L73)


Disassembly of function #:|(DEFUN SINRX (E) ...)-85|
(CONST 0) = SINRX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SINRX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SINRX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SINRX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SINRX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SINRX
8     (SKIP&RET 1)


Disassembly of function SINRX
(CONST 0) = E
(CONST 1) = %SIN
(CONST 2) = VAR
(CONST 3) = 1
(CONST 4) = PARTITION
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
writes special variable : (E)
37 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (CAR)
6     (CAR&PUSH)
7     (JMPIFEQTO 1 L22)                   ; %SIN
10    (NIL)
11    L11
11    (UNBIND1)
12    (SKIP&RET 2)
14    L14
14    (CONST 3)                           ; 1
15    (JMP L11)
17    L17
17    (GETVALUE 0)                        ; E
19    (CAR)
20    (JMP L11)
22    L22
22    (GETVALUE 0)                        ; E
24    (CDR)
25    (CAR&PUSH)
26    (GETVALUE 2)                        ; VAR
28    (JMPIFEQ L14)
30    (GETVALUE 0)                        ; E
32    (CDR)
33    (CAR&PUSH)
34    (GETVALUE&PUSH 2)                   ; VAR
36    (CONST&PUSH 3)                      ; 1
37    (CALL 3 4)                          ; PARTITION
40    (SETVALUE 0)                        ; E
42    (JMPIFNOT L49)
44    (CDR&PUSH)
45    (GETVALUE 2)                        ; VAR
47    (JMPIFEQ L17)
49    L49
49    (NIL)
50    (JMP L11)


Disassembly of function #:|(DECLARE-TOP (SPECIAL N))-86|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SSP (EXP) ...)-87|
(CONST 0) = SSP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SSP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SSP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SSP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SSP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SSP
8     (SKIP&RET 1)


Disassembly of function SSP
(CONST 0) = EXP
(CONST 1) = N
(CONST 2) = C
(CONST 3) = (%SIN)
(CONST 4) = VAR
(CONST 5) = 2
(CONST 6) = POWER
(CONST 7) = 1
(CONST 8) = -1
(CONST 9) = (%COS)
(CONST 10) = MUL*
(CONST 11) = ADD
(CONST 12) = $SUBSTITUTE
(CONST 13) = NUMDEN
(CONST 14) = NN*
(CONST 15) = DN*
(CONST 16) = FINDP
(CONST 17) = $INTEGER
(CONST 18) = ASK-INTEGER
(CONST 19) = $YES
(CONST 20) = SKR
(CONST 21) = SCMP
(CONST 22) = MPLUSP
(CONST 23) = ANDMAPCAR
(CONST 24) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C N DN* NN* EXP VAR)
writes special variables : (C N EXP)
83 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (NIL)
5     (BIND 1)                            ; N
7     (NIL)
8     (BIND 2)                            ; C
10    (CONST&PUSH 3)                      ; (%SIN)
11    (GETVALUE&PUSH 4)                   ; VAR
13    (LIST&PUSH 2)
15    (CONST&PUSH 5)                      ; 2
16    (CALL2&PUSH 6)                      ; POWER
18    (CONST&PUSH 7)                      ; 1
19    (CONST&PUSH 8)                      ; -1
20    (CONST&PUSH 9)                      ; (%COS)
21    (GETVALUE&PUSH 4)                   ; VAR
23    (LIST&PUSH 2)
25    (CONST&PUSH 5)                      ; 2
26    (CALL2&PUSH 6)                      ; POWER
28    (CALL2&PUSH 10)                     ; MUL*
30    (CALL2&PUSH 11)                     ; ADD
32    (GETVALUE&PUSH 0)                   ; EXP
34    (CALL 3 12)                         ; $SUBSTITUTE
37    (SETVALUE 0)                        ; EXP
39    (PUSH)
40    (CALL1 13)                          ; NUMDEN
42    (GETVALUE 14)                       ; NN*
44    (STORE 6)
45    (GETVALUE&PUSH 15)                  ; DN*
47    (CALL1 16)                          ; FINDP
49    (SETVALUE 1)                        ; N
51    (JMPIFNOT L81)
53    (PUSH)
54    (CONST&PUSH 17)                     ; $INTEGER
55    (CALL2&PUSH 18)                     ; ASK-INTEGER
57    (JMPIFNOTEQTO 19 L81)               ; $YES
60    (LOAD&PUSH 6)
61    (CALL1 20)                          ; SKR
63    (SETVALUE 2)                        ; C
65    (JMPIF L89)
67    (LOAD&PUSH 6)
68    (CALL1&JMPIFNOT 22 L81)             ; MPLUSP
71    (CONST&SYMBOL-FUNCTION&PUSH 20)     ; SKR
73    (LOAD&CDR&PUSH 7)
75    (CALL2 23)                          ; ANDMAPCAR
77    (SETVALUE 2)                        ; C
79    (JMPIF L96)
81    L81
81    (NIL)
82    (UNBIND 2)
84    (SKIP 1)
86    L86
86    (UNBIND1)
87    (SKIP&RET 2)
89    L89
89    (PUSH)
90    (GETVALUE&PUSH 1)                   ; N
92    (CALL2 21)                          ; SCMP
94    (JMP L127)
96    L96
96    (NIL&PUSH)
97    (GETVALUE&PUSH 2)                   ; C
99    (JMP L114)
101   L101
101   (LOAD&CAR&PUSH 0)
103   (LOAD&PUSH 0)
104   (GETVALUE&PUSH 1)                   ; N
106   (CALL2&PUSH 21)                     ; SCMP
108   (LOAD&CONS&STORE 2)
110   (SKIP 1)
112   (LOAD&CDR&STORE 0)
114   L114
114   (LOAD&PUSH 0)
115   (CALLS1&JMPIFNOT 146 L101)          ; ENDP
118   (SKIP 1)
120   (LOAD&PUSH 0)
121   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
124   (NIL&PUSH)
125   (CALL2 24)                          ; ADDN
127   L127
127   (UNBIND 2)
129   (SKIP 1)
131   (JMP L86)


Disassembly of function #:|(DECLARE-TOP (UNSPECIAL N))-88|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SCMP (C N) ...)-89|
(CONST 0) = SCMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SCMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SCMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SCMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SCMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SCMP
8     (SKIP&RET 1)


Disassembly of function SCMP
(CONST 0) = C
(CONST 1) = N
(CONST 2) = -1
(CONST 3) = ADD*
(CONST 4) = POWER*
(CONST 5) = (%SIGNUM)
(CONST 6) = SINSP
(CONST 7) = MUL*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N C)
27 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; C
3     (LOAD 4)
4     (BIND 1)                            ; N
6     (GETVALUE 0)                        ; C
8     (CAR&PUSH)
9     (GETVALUE 0)                        ; C
11    (CDR)
12    (CAR&PUSH)
13    (GETVALUE&PUSH 1)                   ; N
15    (CONST&PUSH 2)                      ; -1
16    (CALL2&PUSH 3)                      ; ADD*
18    (CALL2&PUSH 4)                      ; POWER*
20    (CONST&PUSH 5)                      ; (%SIGNUM)
21    (GETVALUE 0)                        ; C
23    (CDR)
24    (CAR&PUSH)
25    (LIST&PUSH 2)
27    (GETVALUE 0)                        ; C
29    (CDR)
30    (CDR)
31    (CAR&PUSH)
32    (GETVALUE&PUSH 1)                   ; N
34    (CALL2&PUSH 6)                      ; SINSP
36    (CALL 4 7)                          ; MUL*
39    (UNBIND 2)
41    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SEVN (N) ...)-90|
(CONST 0) = SEVN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SEVN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SEVN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SEVN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SEVN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SEVN
8     (SKIP&RET 1)


Disassembly of function SEVN
(CONST 0) = N
(CONST 1) = HALF%PI
(CONST 2) = (%BINOMIAL)
(CONST 3) = -1
(CONST 4) = ADD*
(CONST 5) = ((RAT) -1 2)
(CONST 6) = ADD
(CONST 7) = $MAKEGAMMA
(CONST 8) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N HALF%PI)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; N
3     (GETVALUE&PUSH 1)                   ; HALF%PI
5     (CONST&PUSH 2)                      ; (%BINOMIAL)
6     (GETVALUE&PUSH 0)                   ; N
8     (CONST&PUSH 3)                      ; -1
9     (CALL2&PUSH 4)                      ; ADD*
11    (CONST&PUSH 5)                      ; ((RAT) -1 2)
12    (CALL2&PUSH 6)                      ; ADD
14    (GETVALUE&PUSH 0)                   ; N
16    (CONST&PUSH 3)                      ; -1
17    (CALL2&PUSH 4)                      ; ADD*
19    (LIST&PUSH 3)
21    (CALL1&PUSH 7)                      ; $MAKEGAMMA
23    (CALL2 8)                           ; MUL*
25    (UNBIND1)
26    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SFORX (N) ...)-91|
(CONST 0) = SFORX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SFORX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SFORX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SFORX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SFORX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SFORX
8     (SKIP&RET 1)


Disassembly of function SFORX
(CONST 0) = N
(CONST 1) = 1
(CONST 2) = HALF%PI
(CONST 3) = -1
(CONST 4) = ADD*
(CONST 5) = 0
(CONST 6) = BYGAMMA
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (HALF%PI N)
15 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; N
3     (GETVALUE&PUSH 0)                   ; N
5     (JMPIFEQTO 1 L19)                   ; 1
8     (GETVALUE&PUSH 0)                   ; N
10    (CONST&PUSH 3)                      ; -1
11    (CALL2&PUSH 4)                      ; ADD*
13    (CONST&PUSH 5)                      ; 0
14    (CALL2 6)                           ; BYGAMMA
16    L16
16    (UNBIND1)
17    (SKIP&RET 2)
19    L19
19    (GETVALUE 2)                        ; HALF%PI
21    (JMP L16)


Disassembly of function #:|(DEFUN SINSP (L K) ...)-92|
(CONST 0) = SINSP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SINSP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SINSP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SINSP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SINSP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SINSP
8     (SKIP&RET 1)


Disassembly of function SINSP
(CONST 0) = L
(CONST 1) = K
(CONST 2) = -1
(CONST 3) = ADD*
(CONST 4) = MUL*
(CONST 5) = $SIGN
(CONST 6) = $NEG
(CONST 7) = DIVERG
(CONST 8) = EVEN1
(CONST 9) = 2
(CONST 10) = DIV*
(CONST 11) = SEVN
(CONST 12) = 1
(CONST 13) = SFORX
(CONST 14) = -2
(CONST 15) = $POS
(CONST 16) = POWER
(CONST 17) = POWER*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (K L)
89 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; L
3     (LOAD 4)
4     (BIND 1)                            ; K
6     (PUSH-NIL 2)
8     (GETVALUE&PUSH 0)                   ; L
10    (CONST&PUSH 2)                      ; -1
11    (GETVALUE&PUSH 1)                   ; K
13    (CONST&PUSH 2)                      ; -1
14    (CALL2&PUSH 3)                      ; ADD*
16    (CALL2&PUSH 4)                      ; MUL*
18    (CALL2&PUSH 3)                      ; ADD*
20    (CALL1&PUSH 5)                      ; $SIGN
22    (JMPIFEQTO 6 L61)                   ; $NEG
25    (GETVALUE&PUSH 0)                   ; L
27    (GETVALUE&PUSH 1)                   ; K
29    (CALL2&PUSH 3)                      ; ADD*
31    (CALL1&JMPIFNOT 8 L54)              ; EVEN1
34    (GETVALUE&PUSH 1)                   ; K
36    (JMPIFEQTO 9 L67)                   ; 2
39    (GETVALUE&PUSH 1)                   ; K
41    (JMPIFEQTO 12 L78)                  ; 1
44    (GETVALUE&PUSH 1)                   ; K
46    (CONST&PUSH 14)                     ; -2
47    (CALL2&PUSH 3)                      ; ADD*
49    (CALL1&PUSH 5)                      ; $SIGN
51    (JMPIFEQTO 15 L86)                  ; $POS
54    L54
54    (NIL)
55    (SKIP 2)
57    L57
57    (UNBIND 2)
59    (SKIP&RET 3)
61    L61
61    (CALL0 7)                           ; DIVERG
63    (SKIP 2)
65    (JMP L57)
67    L67
67    (GETVALUE&PUSH 0)                   ; L
69    (CONST&PUSH 9)                      ; 2
70    (CALL2&PUSH 10)                     ; DIV*
72    (CALL1 11)                          ; SEVN
74    (SKIP 2)
76    (JMP L57)
78    L78
78    (GETVALUE&PUSH 0)                   ; L
80    (CALL1 13)                          ; SFORX
82    (SKIP 2)
84    (JMP L57)
86    L86
86    (GETVALUE&PUSH 1)                   ; K
88    (CONST&PUSH 2)                      ; -1
89    (CALL2&PUSH 3)                      ; ADD*
91    (GETVALUE&PUSH 1)                   ; K
93    (CONST&PUSH 14)                     ; -2
94    (CALL2 3)                           ; ADD*
96    (STORE 1)
97    (PUSH)
98    (CALL2 4)                           ; MUL*
100   (STORE 1)
101   (GETVALUE&PUSH 0)                   ; L
103   (GETVALUE&PUSH 0)                   ; L
105   (CONST&PUSH 2)                      ; -1
106   (CALL2&PUSH 3)                      ; ADD*
108   (LOAD&PUSH 3)
109   (CONST&PUSH 2)                      ; -1
110   (CALL2&PUSH 16)                     ; POWER
112   (GETVALUE&PUSH 0)                   ; L
114   (CONST&PUSH 14)                     ; -2
115   (CALL2&PUSH 3)                      ; ADD*
117   (LOAD&PUSH 4)
118   (JSR&PUSH L0)
121   (CALL&PUSH 4 4)                     ; MUL*
124   (CONST&PUSH 2)                      ; -1
125   (GETVALUE&PUSH 0)                   ; L
127   (CONST&PUSH 9)                      ; 2
128   (CALL2&PUSH 17)                     ; POWER*
130   (CALL2&PUSH 4)                      ; MUL*
132   (LOAD&PUSH 3)
133   (CONST&PUSH 2)                      ; -1
134   (CALL2&PUSH 16)                     ; POWER
136   (GETVALUE&PUSH 0)                   ; L
138   (LOAD&PUSH 4)
139   (JSR&PUSH L0)
142   (CALL&PUSH 3 4)                     ; MUL*
145   (CALL2 3)                           ; ADD*
147   (SKIP 2)
149   (JMP L57)


Disassembly of function #:|(DEFUN FPART (A) ...)-93|
(CONST 0) = FPART
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FPART>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FPART
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FPART
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FPART>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FPART
8     (SKIP&RET 1)


Disassembly of function FPART
(CONST 0) = A
(CONST 1) = 0
(CONST 2) = MNUMP
(CONST 3) = ABLESS1
(CONST 4) = MPLUSP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (A)
62 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (GETVALUE 0)                        ; A
5     (JMPIFNOT L50)
7     (GETVALUE&PUSH 0)                   ; A
9     (CALLS2&JMPIF 8 L53)                ; NUMBERP
12    (GETVALUE&PUSH 0)                   ; A
14    (CALL1&JMPIF 2 L56)                 ; MNUMP
17    (GETVALUE 0)                        ; A
19    (JMPIFCONSP L26)
21    (GETVALUE&PUSH 0)                   ; A
23    (CALL1&JMPIF 3 L79)                 ; ABLESS1
26    L26
26    (GETVALUE&PUSH 0)                   ; A
28    (CALL1&JMPIFNOT 4 L46)              ; MPLUSP
31    (GETVALUE 0)                        ; A
33    (CDR)
34    (CDR)
35    (CDR)
36    (JMPIF L46)
38    (GETVALUE 0)                        ; A
40    (CDR)
41    (CDR)
42    (CAR&PUSH)
43    (CALL1&JMPIF 3 L83)                 ; ABLESS1
46    L46
46    (NIL)
47    L47
47    (UNBIND1)
48    (SKIP&RET 2)
50    L50
50    (CONST 1)                           ; 0
51    (JMP L47)
53    L53
53    (CONST 1)                           ; 0
54    (JMP L47)
56    L56
56    (GETVALUE 0)                        ; A
58    (CAR&PUSH)
59    (GETVALUE 0)                        ; A
61    (CDR)
62    (CAR&PUSH)
63    (GETVALUE 0)                        ; A
65    (CDR)
66    (CDR)
67    (CAR&PUSH)
68    (CALLS2&PUSH 184)                   ; REM
70    (GETVALUE 0)                        ; A
72    (CDR)
73    (CDR)
74    (CAR&PUSH)
75    (LIST 3)
77    (JMP L47)
79    L79
79    (GETVALUE 0)                        ; A
81    (JMP L47)
83    L83
83    (GETVALUE 0)                        ; A
85    (CDR)
86    (CDR)
87    (CAR)
88    (JMP L47)


Disassembly of function #:|(DEFUN THRAD (E) ...)-94|
(CONST 0) = THRAD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE THRAD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; THRAD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; THRAD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE THRAD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; THRAD
8     (SKIP&RET 1)


Disassembly of function THRAD
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = POLYINX
(CONST 3) = 0
(CONST 4) = MEXPTP
(CONST 5) = MNUMP
(CONST 6) = FPART
(CONST 7) = MTIMESP
(CONST 8) = THRAD
(CONST 9) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
43 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (GETVALUE&PUSH 1)                   ; VAR
7     (NIL&PUSH)
8     (CALL 3 2)                          ; POLYINX
11    (JMPIF L43)
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1&JMPIFNOT 4 L34)              ; MEXPTP
18    (GETVALUE 0)                        ; E
20    (CDR)
21    (CAR&PUSH)
22    (GETVALUE 1)                        ; VAR
24    (JMPIFNOTEQ L34)
26    (GETVALUE 0)                        ; E
28    (CDR)
29    (CDR)
30    (CAR&PUSH)
31    (CALL1&JMPIF 5 L46)                 ; MNUMP
34    L34
34    (GETVALUE&PUSH 0)                   ; E
36    (CALL1&JMPIF 7 L55)                 ; MTIMESP
39    (NIL)
40    L40
40    (UNBIND1)
41    (SKIP&RET 2)
43    L43
43    (CONST 3)                           ; 0
44    (JMP L40)
46    L46
46    (GETVALUE 0)                        ; E
48    (CDR)
49    (CDR)
50    (CAR&PUSH)
51    (CALL1 6)                           ; FPART
53    (JMP L40)
55    L55
55    (CONST&SYMBOL-FUNCTION&PUSH 8)      ; THRAD
57    (GETVALUE&PUSH 0)                   ; E
59    (CALLSR&PUSH 0 22)                  ; MAPCAR
62    (NIL&PUSH)
63    (CALL2 9)                           ; ADDN
65    (JMP L40)


Disassembly of function #:|(DEFUN PERIOD (P E VAR) ...)-95|
(CONST 0) = PERIOD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PERIOD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PERIOD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PERIOD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PERIOD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PERIOD
8     (SKIP&RET 1)


Disassembly of function PERIOD
(CONST 0) = P
(CONST 1) = E
(CONST 2) = VAR
(CONST 3) = NO-ERR-SUB
(CONST 4) = ADD*
(CONST 5) = ALIKE1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (P E VAR)
writes special variable : (E)
25 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; P
3     (LOAD 5)
4     (BIND 1)                            ; E
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (GETVALUE&PUSH 2)                   ; VAR
11    (GETVALUE&PUSH 1)                   ; E
13    (CALL2&PUSH 3)                      ; NO-ERR-SUB
15    (GETVALUE&PUSH 0)                   ; P
17    (GETVALUE&PUSH 2)                   ; VAR
19    (CALL2&PUSH 4)                      ; ADD*
21    (GETVALUE&PUSH 1)                   ; E
23    (CALL2 3)                           ; NO-ERR-SUB
25    (SETVALUE 1)                        ; E
27    (PUSH)
28    (CALL2 5)                           ; ALIKE1
30    (JMPIFNOT1 L37)
32    (GETVALUE&PUSH 1)                   ; E
34    (T)
35    (EQ)
36    (NOT)
37    L37
37    (UNBIND 3)
39    (SKIP&RET 4)


Disassembly of function #:|(DEFUN INFR (A) ...)-96|
(CONST 0) = INFR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INFR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INFR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INFR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INFR
8     (SKIP&RET 1)


Disassembly of function INFR
(CONST 0) = A
(CONST 1) = $%I
(CONST 2) = 0
(CONST 3) = SUBIN
(CONST 4) = R
(CONST 5) = C
(CONST 6) = VAR
(CONST 7) = 1
(CONST 8) = -1
(CONST 9) = MUL
(CONST 10) = ADD*
(CONST 11) = ((RAT) 1 2)
(CONST 12) = MUL*
(CONST 13) = IGPRT
(CONST 14) = -2
(CONST 15) = $%PI
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C R A)
writes special variables : (A C)
39 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (CONST&PUSH 1)                      ; $%I
4     (CONST&PUSH 2)                      ; 0
5     (GETVALUE&PUSH 0)                   ; A
7     (CALL2 3)                           ; SUBIN
9     (BIND 4)                            ; R
11    (NIL)
12    (BIND 5)                            ; C
14    (LOAD 6)
15    (BIND 6)                            ; VAR
17    (CONST&PUSH 7)                      ; 1
18    (GETVALUE&PUSH 0)                   ; A
20    (CONST&PUSH 8)                      ; -1
21    (GETVALUE&PUSH 4)                   ; R
23    (CALL2&PUSH 9)                      ; MUL
25    (CALL2&PUSH 10)                     ; ADD*
27    (CALL2 3)                           ; SUBIN
29    (SETVALUE 5)                        ; C
31    (CONST&PUSH 11)                     ; ((RAT) 1 2)
32    (GETVALUE&PUSH 5)                   ; C
34    (CALL2&PUSH 12)                     ; MUL*
36    (CALL1 13)                          ; IGPRT
38    (SETVALUE 0)                        ; A
40    (PUSH)
41    (GETVALUE&PUSH 4)                   ; R
43    (GETVALUE&PUSH 5)                   ; C
45    (CONST&PUSH 14)                     ; -2
46    (GETVALUE&PUSH 0)                   ; A
48    (CALL2&PUSH 12)                     ; MUL*
50    (CALL2&PUSH 10)                     ; ADD*
52    (CONST&PUSH 15)                     ; $%PI
53    (CALL2&PUSH 9)                      ; MUL
55    (CALL2 10)                          ; ADD*
57    (CONS)
58    (UNBIND 3)
60    (SKIP 1)
62    (UNBIND1)
63    (SKIP&RET 2)


Disassembly of function #:|(DEFUN IGPRT (R) ...)-97|
(CONST 0) = IGPRT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IGPRT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IGPRT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IGPRT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IGPRT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; IGPRT
8     (SKIP&RET 1)


Disassembly of function IGPRT
(CONST 0) = R
(CONST 1) = -1
(CONST 2) = FPART
(CONST 3) = MUL*
(CONST 4) = ADD*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (R)
10 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; R
3     (GETVALUE&PUSH 0)                   ; R
5     (CONST&PUSH 1)                      ; -1
6     (GETVALUE&PUSH 0)                   ; R
8     (CALL1&PUSH 2)                      ; FPART
10    (CALL2&PUSH 3)                      ; MUL*
12    (CALL2 4)                           ; ADD*
14    (UNBIND1)
15    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SCRAT (SC B) ...)-98|
(CONST 0) = SCRAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SCRAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SCRAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SCRAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SCRAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SCRAT
8     (SKIP&RET 1)


Disassembly of function SCRAT
(CONST 0) = B
(CONST 1) = SCONVERT
(CONST 2) = YY
(CONST 3) = $%E
(CONST 4) = $%I
(CONST 5) = VAR
(CONST 6) = MUL
(CONST 7) = POWER
(CONST 8) = MAXIMA-SUBSTITUTE
(CONST 9) = RATP
(CONST 10) = AMONG
(CONST 11) = %PI2
(CONST 12) = ALIKE1
(CONST 13) = ZTO%PI2
(CONST 14) = ANS
(CONST 15) = $%PI
(CONST 16) = EVENFN
(CONST 17) = ((RAT) 1 2)
(CONST 18) = HALF%PI
(CONST 19) = -1
(CONST 20) = ADD
(CONST 21) = NO-ERR-SUB
(CONST 22) = ((RAT) 1 4)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS HALF%PI %PI2 B VAR)
87 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; B
3     (LOAD&PUSH 5)
4     (CALL1&PUSH 1)                      ; SCONVERT
6     (CONST&PUSH 2)                      ; YY
7     (CONST&PUSH 3)                      ; $%E
8     (CONST&PUSH 4)                      ; $%I
9     (GETVALUE&PUSH 5)                   ; VAR
11    (CALL2&PUSH 6)                      ; MUL
13    (CALL2&PUSH 7)                      ; POWER
15    (LOAD&PUSH 2)
16    (CALL&PUSH 3 8)                     ; MAXIMA-SUBSTITUTE
19    (LOAD&PUSH 0)
20    (CONST&PUSH 2)                      ; YY
21    (CALL2&JMPIFNOT 9 L135)             ; RATP
25    (GETVALUE&PUSH 5)                   ; VAR
27    (LOAD&PUSH 1)
28    (CALL2&JMPIF 10 L135)               ; AMONG
32    (GETVALUE&PUSH 0)                   ; B
34    (GETVALUE&PUSH 11)                  ; %PI2
36    (CALL2&JMPIF 12 L100)               ; ALIKE1
39    (GETVALUE&PUSH 0)                   ; B
41    (JMPIFNOTEQTO 15 L51)               ; $%PI
44    (LOAD&PUSH 1)
45    (GETVALUE&PUSH 5)                   ; VAR
47    (CALL2&JMPIF 16 L116)               ; EVENFN
51    L51
51    (GETVALUE&PUSH 0)                   ; B
53    (GETVALUE&PUSH 18)                  ; HALF%PI
55    (CALL2&JMPIFNOT 12 L135)            ; ALIKE1
59    (LOAD&PUSH 1)
60    (GETVALUE&PUSH 5)                   ; VAR
62    (CALL2&JMPIFNOT 16 L135)            ; EVENFN
66    (LOAD&PUSH 0)
67    (CONST&PUSH 15)                     ; $%PI
68    (CONST&PUSH 19)                     ; -1
69    (GETVALUE&PUSH 5)                   ; VAR
71    (CALL2&PUSH 6)                      ; MUL
73    (CALL2&PUSH 20)                     ; ADD
75    (LOAD&PUSH 2)
76    (CALL2&PUSH 21)                     ; NO-ERR-SUB
78    (CALL2&JMPIFNOT 12 L135)            ; ALIKE1
81    (LOAD&PUSH 0)
82    (CONST&PUSH 2)                      ; YY
83    (CALL2 13)                          ; ZTO%PI2
85    (BIND 14)                           ; ANS
87    (GETVALUE 14)                       ; ANS
89    (JMPIFNOT L129)
91    (CONST 22)                          ; ((RAT) 1 4)
93    L93
93    (PUSH)
94    (GETVALUE&PUSH 14)                  ; ANS
96    (CALL2 6)                           ; MUL
98    (JMP L130)
100   L100
100   (LOAD&PUSH 0)
101   (CONST&PUSH 2)                      ; YY
102   (CALL2 13)                          ; ZTO%PI2
104   (BIND 14)                           ; ANS
106   (GETVALUE 14)                       ; ANS
108   (JMPIF L130)
110   (NIL)
111   (JMP L130)
113   L113
113   (CONST 17)                          ; ((RAT) 1 2)
114   (JMP L93)
116   L116
116   (LOAD&PUSH 0)
117   (CONST&PUSH 2)                      ; YY
118   (CALL2 13)                          ; ZTO%PI2
120   (BIND 14)                           ; ANS
122   (GETVALUE 14)                       ; ANS
124   (JMPIF L113)
126   (NIL)
127   (JMP L130)
129   L129
129   (NIL)
130   L130
130   (UNBIND1)
131   (SKIP 2)
133   (JMP L138)
135   L135
135   (NIL)
136   (SKIP 2)
138   L138
138   (UNBIND1)
139   (SKIP&RET 3)


Disassembly of function #:|(DEFUN INTSC1 (A B E) ...)-99|
(CONST 0) = INTSC1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTSC1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTSC1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTSC1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTSC1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTSC1
8     (SKIP&RET 1)


Disassembly of function INTSC1
(CONST 0) = A
(CONST 1) = B
(CONST 2) = E
(CONST 3) = -1
(CONST 4) = MUL*
(CONST 5) = ADD*
(CONST 6) = $%EMODE
(CONST 7) = $TRIGSIGN
(CONST 8) = SIN-COS-RECUR
(CONST 9) = ANS
(CONST 10) = D
(CONST 11) = L
(CONST 12) = $%PI
(CONST 13) = DIV*
(CONST 14) = MNUMP
(CONST 15) = %PI2
(CONST 16) = VAR
(CONST 17) = PERIOD
(CONST 18) = 0
(CONST 19) = MAXIMA-SUBSTITUTE
(CONST 20) = $FLOAT
(CONST 21) = $INTEGER
(CONST 22) = ASK-INTEGER
(CONST 23) = $YES
(CONST 24) = INTSC
(CONST 25) = RATGREATERP
(CONST 26) = INFR
(CONST 27) = MUL
(CONST 28) = ZEROP1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D ANS L VAR E %PI2 A B)
writes special variables : (ANS L D B A E)
172 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; A
3     (LOAD 5)
4     (BIND 1)                            ; B
6     (LOAD 7)
7     (BIND 2)                            ; E
9     (GETVALUE&PUSH 1)                   ; B
11    (CONST&PUSH 3)                      ; -1
12    (GETVALUE&PUSH 0)                   ; A
14    (CALL2&PUSH 4)                      ; MUL*
16    (CALL2&PUSH 5)                      ; ADD*
18    (T)
19    (BIND 6)                            ; $%EMODE
21    (T)
22    (BIND 7)                            ; $TRIGSIGN
24    (T)
25    (BIND 8)                            ; SIN-COS-RECUR
27    (NIL)
28    (BIND 9)                            ; ANS
30    (NIL)
31    (BIND 10)                           ; D
33    (NIL&PUSH)
34    (NIL)
35    (BIND 11)                           ; L
37    (LOAD&PUSH 19)
38    (CONST&PUSH 12)                     ; $%PI
39    (CALL2&PUSH 13)                     ; DIV*
41    (CALL1&JMPIFNOT 14 L223)            ; MNUMP
45    (GETVALUE&PUSH 15)                  ; %PI2
47    (GETVALUE&PUSH 2)                   ; E
49    (GETVALUE&PUSH 16)                  ; VAR
51    (CALL 3 17)                         ; PERIOD
54    (JMPIFNOT L223)
57    (GETVALUE&PUSH 0)                   ; A
59    (JMPIFEQTO 18 L84)                  ; 0
62    (GETVALUE&PUSH 0)                   ; A
64    (GETVALUE&PUSH 16)                  ; VAR
66    (CALL2&PUSH 5)                      ; ADD*
68    (GETVALUE&PUSH 16)                  ; VAR
70    (GETVALUE&PUSH 2)                   ; E
72    (CALL 3 19)                         ; MAXIMA-SUBSTITUTE
75    (SETVALUE 2)                        ; E
77    (CONST 18)                          ; 0
78    (SETVALUE 0)                        ; A
80    (LOAD 19)
82    (SETVALUE 1)                        ; B
84    L84
84    (NIL)
85    (BIND 20)                           ; $FLOAT
87    (LOAD&PUSH 22)
88    (GETVALUE&PUSH 15)                  ; %PI2
90    (CALL2 13)                          ; DIV*
92    (UNBIND1)
93    (SETVALUE 10)                       ; D
95    (PUSH)
96    (CONST&PUSH 21)                     ; $INTEGER
97    (CALL2&PUSH 22)                     ; ASK-INTEGER
99    (JMPIFEQTO 23 L226)                 ; $YES
103   (GETVALUE&PUSH 15)                  ; %PI2
105   (GETVALUE&PUSH 1)                   ; B
107   (CALL2&JMPIF 25 L245)               ; RATGREATERP
111   (GETVALUE 0)                        ; A
113   (SETVALUE 11)                       ; L
115   (CONST 18)                          ; 0
116   (SETVALUE 0)                        ; A
118   (GETVALUE&PUSH 1)                   ; B
120   (CALL1 26)                          ; INFR
122   (SETVALUE 1)                        ; B
124   (GETVALUE 11)                       ; L
126   (JMPIFNOT L256)
129   (GETVALUE&PUSH 11)                  ; L
131   (CALL1 26)                          ; INFR
133   (SETVALUE 11)                       ; L
135   (CONST&PUSH 3)                      ; -1
136   (GETVALUE&PUSH 2)                   ; E
138   (GETVALUE 11)                       ; L
140   (CDR&PUSH)
141   (GETVALUE&PUSH 16)                  ; VAR
143   (CALL 3 24)                         ; INTSC
146   (SETVALUE 9)                        ; ANS
148   (JMPIFNOT L213)
150   (PUSH)
151   (CALL2 27)                          ; MUL
153   (STORE 19)
155   (GETVALUE 1)                        ; B
157   (CAR&PUSH)
158   (CONST&PUSH 3)                      ; -1
159   (GETVALUE 11)                       ; L
161   (CAR&PUSH)
162   (CALL2&PUSH 4)                      ; MUL*
164   (CALL2 5)                           ; ADD*
166   (STORE 3)
167   L167
167   (LOAD&PUSH 3)
168   (CALL1&JMPIF 28 L266)               ; ZEROP1
172   (GETVALUE&PUSH 2)                   ; E
174   (GETVALUE&PUSH 15)                  ; %PI2
176   (GETVALUE&PUSH 16)                  ; VAR
178   (CALL 3 24)                         ; INTSC
181   (SETVALUE 9)                        ; ANS
183   (JMPIFNOT L270)
186   (LOAD&PUSH 3)
187   (GETVALUE&PUSH 9)                   ; ANS
189   (CALL2 27)                          ; MUL
191   L191
191   (PUSH)
192   (GETVALUE 1)                        ; B
194   (CDR&PUSH)
195   (CALL1&JMPIF 28 L273)               ; ZEROP1
199   (GETVALUE&PUSH 2)                   ; E
201   (GETVALUE 1)                        ; B
203   (CDR&PUSH)
204   (GETVALUE&PUSH 16)                  ; VAR
206   (CALL 3 24)                         ; INTSC
209   (SETVALUE 9)                        ; ANS
211   (JMPIF L274)
213   L213
213   (NIL)
214   (SKIP 1)
216   L216
216   (UNBIND1)
217   (SKIP 1)
219   (UNBIND 2)
221   (JMP L286)
223   L223
223   (NIL)
224   (JMP L216)
226   L226
226   (GETVALUE&PUSH 10)                  ; D
228   (GETVALUE&PUSH 2)                   ; E
230   (GETVALUE&PUSH 15)                  ; %PI2
232   (GETVALUE&PUSH 16)                  ; VAR
234   (CALL 3 24)                         ; INTSC
237   (SETVALUE 9)                        ; ANS
239   (JMPIFNOT L213)
241   (SKIP 1)
243   (JMP L281)
245   L245
245   (GETVALUE&PUSH 2)                   ; E
247   (GETVALUE&PUSH 1)                   ; B
249   (GETVALUE&PUSH 16)                  ; VAR
251   (CALL 3 24)                         ; INTSC
254   (JMP L281)
256   L256
256   (GETVALUE 1)                        ; B
258   (CAR)
259   (STORE 3)
260   (CONST 18)                          ; 0
261   (STORE 19)
263   (JMP L167)
266   L266
266   (CONST 18)                          ; 0
267   (JMP L191)
270   L270
270   (NIL)
271   (JMP L216)
273   L273
273   (CONST 18)                          ; 0
274   L274
274   (PUSH)
275   (LOAD&PUSH 21)
276   (CALL 3 5)                          ; ADD*
279   (SETVALUE 9)                        ; ANS
281   L281
281   (UNBIND1)
282   (SKIP 1)
284   (UNBIND 2)
286   L286
286   (UNBIND 3)
288   (SKIP 1)
290   (UNBIND 3)
292   (SKIP&RET 4)


Disassembly of function #:|(DEFUN INTSC (SC B VAR) ...)-100|
(CONST 0) = INTSC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTSC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTSC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTSC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTSC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTSC
8     (SKIP&RET 1)


Disassembly of function INTSC
(CONST 0) = B
(CONST 1) = VAR
(CONST 2) = $SIGN
(CONST 3) = $NEG
(CONST 4) = -1
(CONST 5) = MUL
(CONST 6) = SUBIN
(CONST 7) = MUL*
(CONST 8) = 1
(CONST 9) = PARTITION
(CONST 10) = INTSC0
(CONST 11) = RESIMPLIFY
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR B)
writes special variable : (B)
41 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; B
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; B
8     (CALL1&PUSH 2)                      ; $SIGN
10    (JMPIFNOTEQTO 3 L33)                ; $NEG
13    (CONST&PUSH 4)                      ; -1
14    (GETVALUE&PUSH 0)                   ; B
16    (CALL2 5)                           ; MUL
18    (SETVALUE 0)                        ; B
20    (CONST&PUSH 4)                      ; -1
21    (CONST&PUSH 4)                      ; -1
22    (GETVALUE&PUSH 1)                   ; VAR
24    (CALL2&PUSH 5)                      ; MUL
26    (LOAD&PUSH 11)
27    (CALL2&PUSH 6)                      ; SUBIN
29    (CALL2 7)                           ; MUL*
31    (STORE 9)
33    L33
33    (LOAD&PUSH 9)
34    (GETVALUE&PUSH 1)                   ; VAR
36    (CONST&PUSH 8)                      ; 1
37    (CALL 3 9)                          ; PARTITION
40    (STORE 9)
42    (CDR&PUSH)
43    (GETVALUE&PUSH 0)                   ; B
45    (GETVALUE&PUSH 1)                   ; VAR
47    (CALL 3 10)                         ; INTSC0
50    (SETVALUE 0)                        ; B
52    (JMPIF L59)
54    (NIL)
55    L55
55    (UNBIND 2)
57    (SKIP&RET 4)
59    L59
59    (LOAD&CAR&PUSH 9)
61    (CALL1&PUSH 11)                     ; RESIMPLIFY
63    (GETVALUE&PUSH 0)                   ; B
65    (CALL2 7)                           ; MUL*
67    (JMP L55)


Disassembly of function #:|(DEFUN INTSC0 (SC B VAR) ...)-101|
(CONST 0) = INTSC0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INTSC0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTSC0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INTSC0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INTSC0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INTSC0
8     (SKIP&RET 1)


Disassembly of function INTSC0
(CONST 0) = B
(CONST 1) = VAR
(CONST 2) = SCPROD
(CONST 3) = NN*
(CONST 4) = DN*
(CONST 5) = HALF%PI
(CONST 6) = ALIKE1
(CONST 7) = BYGAMMA
(CONST 8) = $%PI
(CONST 9) = -1
(CONST 10) = REAL-BRANCH
(CONST 11) = $YES
(CONST 12) = 1
(CONST 13) = POWER*
(CONST 14) = ADD*
(CONST 15) = MUL*
(CONST 16) = %PI2
(CONST 17) = $EVEN
(CONST 18) = ASK-INTEGER
(CONST 19) = RATNUMP
(CONST 20) = 4
(CONST 21) = $ODD
(CONST 22) = 0
(CONST 23) = HALF%PI3
(CONST 24) = ADDN
(CONST 25) = SCRAT
(CONST 26) = ANTIDERIV
(CONST 27) = SIN-COS-INTSUBS
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR DN* HALF%PI3 %PI2 HALF%PI B NN*)
writes special variables : (NN* DN*)
158 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; B
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (LOAD&PUSH 9)
7     (CALL1 2)                           ; SCPROD
9     (BIND 3)                            ; NN*
11    (NIL)
12    (BIND 4)                            ; DN*
14    (GETVALUE 3)                        ; NN*
16    (JMPIFNOT L221)
19    (GETVALUE&PUSH 0)                   ; B
21    (GETVALUE&PUSH 5)                   ; HALF%PI
23    (CALL2&JMPIF 6 L82)                 ; ALIKE1
26    (GETVALUE&PUSH 0)                   ; B
28    (JMPIFEQTO 8 L106)                  ; $%PI
32    (GETVALUE&PUSH 0)                   ; B
34    (GETVALUE&PUSH 16)                  ; %PI2
36    (CALL2&JMPIF 6 L128)                ; ALIKE1
40    (GETVALUE&PUSH 0)                   ; B
42    (GETVALUE&PUSH 23)                  ; HALF%PI3
44    (CALL2&JMPIFNOT 6 L203)             ; ALIKE1
48    (CONST&PUSH 12)                     ; 1
49    (CONST&PUSH 9)                      ; -1
50    (GETVALUE 3)                        ; NN*
52    (CDR)
53    (CAR&PUSH)
54    (CALL2&PUSH 13)                     ; POWER*
56    (CONST&PUSH 9)                      ; -1
57    (GETVALUE&PUSH 3)                   ; NN*
59    (NIL&PUSH)
60    (CALL2&PUSH 24)                     ; ADDN
62    (CALL2&PUSH 13)                     ; POWER*
64    (CALL 3 14)                         ; ADD*
67    L67
67    (PUSH)
68    (GETVALUE 3)                        ; NN*
70    (CAR&PUSH)
71    (GETVALUE 3)                        ; NN*
73    (CDR)
74    (CAR&PUSH)
75    (CALL2&PUSH 7)                      ; BYGAMMA
77    (CALL2 15)                          ; MUL*
79    (JMP L257)
82    L82
82    (GETVALUE 3)                        ; NN*
84    (CAR&PUSH)
85    (GETVALUE 3)                        ; NN*
87    (CDR)
88    (CAR&PUSH)
89    (CALL2 7)                           ; BYGAMMA
91    (JMP L257)
94    L94
94    (CONST&PUSH 12)                     ; 1
95    (CONST&PUSH 9)                      ; -1
96    (GETVALUE 3)                        ; NN*
98    (CDR)
99    (CAR&PUSH)
100   (CALL2&PUSH 13)                     ; POWER*
102   (CALL2 14)                          ; ADD*
104   (JMP L67)
106   L106
106   (GETVALUE 3)                        ; NN*
108   (CDR)
109   (CAR&PUSH)
110   (CONST&PUSH 9)                      ; -1
111   (CALL2&PUSH 10)                     ; REAL-BRANCH
113   (JMPIFEQTO 11 L94)                  ; $YES
116   (NIL)
117   (JMP L257)
120   L120
120   (CONST 20)                          ; 4
121   (JMP L67)
123   L123
123   (CONST 22)                          ; 0
125   (JMP L257)
128   L128
128   (GETVALUE 3)                        ; NN*
130   (CAR&PUSH)
131   (CONST&PUSH 17)                     ; $EVEN
132   (CALL2&PUSH 18)                     ; ASK-INTEGER
134   (JMPIFNOTEQTO 11 L147)              ; $YES
137   (GETVALUE 3)                        ; NN*
139   (CDR)
140   (CAR&PUSH)
141   (CONST&PUSH 17)                     ; $EVEN
142   (CALL2&PUSH 18)                     ; ASK-INTEGER
144   (JMPIFEQTO 11 L120)                 ; $YES
147   L147
147   (GETVALUE 3)                        ; NN*
149   (CAR&PUSH)
150   (CALL1&JMPIFNOT 19 L179)            ; RATNUMP
153   (GETVALUE 3)                        ; NN*
155   (CAR&PUSH)
156   (CONST&PUSH 9)                      ; -1
157   (CALL2&PUSH 10)                     ; REAL-BRANCH
159   (JMPIFNOTEQTO 11 L179)              ; $YES
162   (GETVALUE 3)                        ; NN*
164   (CDR)
165   (CAR&PUSH)
166   (CALL1&JMPIFNOT 19 L179)            ; RATNUMP
169   (GETVALUE 3)                        ; NN*
171   (CDR)
172   (CAR&PUSH)
173   (CONST&PUSH 9)                      ; -1
174   (CALL2&PUSH 10)                     ; REAL-BRANCH
176   (JMPIFEQTO 11 L120)                 ; $YES
179   L179
179   (GETVALUE 3)                        ; NN*
181   (CAR&PUSH)
182   (CONST&PUSH 21)                     ; $ODD
183   (CALL2&PUSH 18)                     ; ASK-INTEGER
185   (JMPIFEQTO 11 L123)                 ; $YES
189   (GETVALUE 3)                        ; NN*
191   (CDR)
192   (CAR&PUSH)
193   (CONST&PUSH 21)                     ; $ODD
194   (CALL2&PUSH 18)                     ; ASK-INTEGER
196   (JMPIFEQTO 11 L123)                 ; $YES
200   (NIL)
201   (JMP L257)
203   L203
203   (NIL)
204   (JMP L257)
206   L206
206   (GETVALUE 4)                        ; DN*
208   (JMP L257)
210   L210
210   (PUSH)
211   (GETVALUE&PUSH 1)                   ; VAR
213   (CONST&PUSH 22)                     ; 0
214   (GETVALUE&PUSH 0)                   ; B
216   (CALL 4 27)                         ; SIN-COS-INTSUBS
219   (JMP L257)
221   L221
221   (GETVALUE&PUSH 0)                   ; B
223   (JMPIFEQTO 8 L240)                  ; $%PI
226   (GETVALUE&PUSH 0)                   ; B
228   (GETVALUE&PUSH 16)                  ; %PI2
230   (CALL2&JMPIF 6 L240)                ; ALIKE1
233   (GETVALUE&PUSH 0)                   ; B
235   (GETVALUE&PUSH 5)                   ; HALF%PI
237   (CALL2&JMPIFNOT 6 L249)             ; ALIKE1
240   L240
240   (LOAD&PUSH 15)
241   (GETVALUE&PUSH 0)                   ; B
243   (CALL2 25)                          ; SCRAT
245   (SETVALUE 4)                        ; DN*
247   (JMPIF L206)
249   L249
249   (LOAD&PUSH 15)
250   (CALL1 26)                          ; ANTIDERIV
252   (SETVALUE 3)                        ; NN*
254   (JMPIF L210)
256   (NIL)
257   L257
257   (UNBIND 4)
259   (SKIP&RET 4)


Disassembly of function #:|(DEFUN SIN-COS-INTSUBS (EXP VAR LL ...) ...)-102|
(CONST 0) = SIN-COS-INTSUBS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIN-COS-INTSUBS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIN-COS-INTSUBS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIN-COS-INTSUBS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIN-COS-INTSUBS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIN-COS-INTSUBS
8     (SKIP&RET 1)


Disassembly of function SIN-COS-INTSUBS
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = MPLUSP
(CONST 5) = SIN-COS-INTSUBS1
(CONST 6) = ADDN
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
23 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CALL1&JMPIF 4 L25)                 ; MPLUSP
17    (GETVALUE&PUSH 0)                   ; EXP
19    (CALL1 5)                           ; SIN-COS-INTSUBS1
21    L21
21    (UNBIND 4)
23    (SKIP&RET 5)
25    L25
25    (CONST&SYMBOL-FUNCTION&PUSH 5)      ; SIN-COS-INTSUBS1
27    (GETVALUE 0)                        ; EXP
29    (CDR&PUSH)
30    (CALLSR&PUSH 0 22)                  ; MAPCAR
33    (NIL&PUSH)
34    (CALL2 6)                           ; ADDN
36    (JMP L21)


Disassembly of function #:|(DEFUN SIN-COS-INTSUBS1 (EXP) ...)-103|
(CONST 0) = SIN-COS-INTSUBS1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIN-COS-INTSUBS1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIN-COS-INTSUBS1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIN-COS-INTSUBS1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIN-COS-INTSUBS1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIN-COS-INTSUBS1
8     (SKIP&RET 1)


Disassembly of function SIN-COS-INTSUBS1
(CONST 0) = EXP
(CONST 1) = $RAT
(CONST 2) = PDIS
(CONST 3) = NUM
(CONST 4) = LL
(CONST 5) = UL
(CONST 6) = INTSUBS
(CONST 7) = 0
(CONST 8) = $ASKSIGN
(CONST 9) = $ZERO
(CONST 10) = $%PIARGS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL NUM EXP)
43 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&PUSH 1)                      ; $RAT
7     (LOAD 0)
8     (CDR)
9     (CAR&PUSH)
10    (CALL1 2)                           ; PDIS
12    (BIND 3)                            ; NUM
14    (LOAD 3)
15    (CDR)
16    (CDR&PUSH)
17    (CALL1&PUSH 2)                      ; PDIS
19    (GETVALUE&PUSH 3)                   ; NUM
21    (GETVALUE&PUSH 4)                   ; LL
23    (GETVALUE&PUSH 5)                   ; UL
25    (CALL&PUSH 3 6)                     ; INTSUBS
28    (JMPIFNOTEQTO 7 L58)                ; 0
31    (LOAD&PUSH 0)
32    (CALL1&PUSH 8)                      ; $ASKSIGN
34    (JMPIFNOTEQTO 9 L69)                ; $ZERO
37    (NIL)
38    (BIND 10)                           ; $%PIARGS
40    (GETVALUE&PUSH 0)                   ; EXP
42    (GETVALUE&PUSH 4)                   ; LL
44    (GETVALUE&PUSH 5)                   ; UL
46    (CALL 3 6)                          ; INTSUBS
49    (UNBIND1)
50    L50
50    (SKIP 1)
52    (UNBIND1)
53    (SKIP 1)
55    (UNBIND1)
56    (SKIP&RET 2)
58    L58
58    (GETVALUE&PUSH 0)                   ; EXP
60    (GETVALUE&PUSH 4)                   ; LL
62    (GETVALUE&PUSH 5)                   ; UL
64    (CALL 3 6)                          ; INTSUBS
67    (JMP L50)
69    L69
69    (CONST 7)                           ; 0
70    (JMP L50)


Disassembly of function #:|(DEFUN SCPROD (E) ...)-104|
(CONST 0) = SCPROD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SCPROD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SCPROD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SCPROD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SCPROD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SCPROD
8     (SKIP&RET 1)


Disassembly of function SCPROD
(CONST 0) = E
(CONST 1) = #<COMPILED-CLOSURE SCPROD-1>
(CONST 2) = M
(CONST 3) = N
(CONST 4) = (%SIN)
(CONST 5) = VAR
(CONST 6) = POWEROFX
(CONST 7) = 0
(CONST 8) = (%COS)
(CONST 9) = MTIMESP
(CONST 10) = (%SIN)
(CONST 11) = (%COS)
(CONST 12) = (%SIN)
(CONST 13) = (%COS)
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N M VAR E)
writes special variables : (N M)
106 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (CONST&PUSH 1)                      ; #<COMPILED-CLOSURE SCPROD-1>
4     (NIL)
5     (BIND 2)                            ; M
7     (NIL)
8     (BIND 3)                            ; N
10    (GETVALUE&PUSH 0)                   ; E
12    (CONST&PUSH 4)                      ; (%SIN)
13    (GETVALUE&PUSH 5)                   ; VAR
15    (LIST&PUSH 2)
17    (LOAD&PUSH 8)
18    (GETVALUE&PUSH 5)                   ; VAR
20    (CALL 4 6)                          ; POWEROFX
23    (SETVALUE 2)                        ; M
25    (JMPIF L132)
28    (GETVALUE&PUSH 0)                   ; E
30    (CONST&PUSH 8)                      ; (%COS)
31    (GETVALUE&PUSH 5)                   ; VAR
33    (LIST&PUSH 2)
35    (LOAD&PUSH 8)
36    (GETVALUE&PUSH 5)                   ; VAR
38    (CALL 4 6)                          ; POWEROFX
41    (SETVALUE 3)                        ; N
43    (JMPIF L136)
46    (GETVALUE&PUSH 0)                   ; E
48    (CALL1&JMPIFNOT 9 L161)             ; MTIMESP
52    (GETVALUE 0)                        ; E
54    (CDR)
55    (CAR&PUSH)
56    (CONST&PUSH 10)                     ; (%SIN)
57    (GETVALUE&PUSH 5)                   ; VAR
59    (LIST&PUSH 2)
61    (LOAD&PUSH 8)
62    (GETVALUE&PUSH 5)                   ; VAR
64    (CALL 4 6)                          ; POWEROFX
67    (SETVALUE 2)                        ; M
69    (JMPIF L91)
71    (GETVALUE 0)                        ; E
73    (CDR)
74    (CAR&PUSH)
75    (CONST&PUSH 11)                     ; (%COS)
76    (GETVALUE&PUSH 5)                   ; VAR
78    (LIST&PUSH 2)
80    (LOAD&PUSH 8)
81    (GETVALUE&PUSH 5)                   ; VAR
83    (CALL 4 6)                          ; POWEROFX
86    (SETVALUE 3)                        ; N
88    (JMPIFNOT L161)
91    L91
91    (GETVALUE 2)                        ; M
93    (JMPIFNOT L141)
95    (GETVALUE 0)                        ; E
97    (CDR)
98    (CDR)
99    (CAR&PUSH)
100   (CONST&PUSH 13)                     ; (%COS)
101   (GETVALUE&PUSH 5)                   ; VAR
103   (LIST&PUSH 2)
105   (LOAD&PUSH 8)
106   (GETVALUE&PUSH 5)                   ; VAR
108   (CALL 4 6)                          ; POWEROFX
111   (SETVALUE 3)                        ; N
113   (JMPIFNOT L161)
115   L115
115   (GETVALUE 0)                        ; E
117   (CDR)
118   (CDR)
119   (CDR)
120   (JMPIF L161)
122   (GETVALUE 2)                        ; M
124   L124
124   (PUSH)
125   (GETVALUE 3)                        ; N
127   L127
127   (PUSH)
128   (LIST 2)
130   (JMP L162)
132   L132
132   (PUSH)
133   (CONST 7)                           ; 0
134   (JMP L127)
136   L136
136   (CONST 7)                           ; 0
137   (SETVALUE 2)                        ; M
139   (JMP L124)
141   L141
141   (GETVALUE 0)                        ; E
143   (CDR)
144   (CDR)
145   (CAR&PUSH)
146   (CONST&PUSH 12)                     ; (%SIN)
147   (GETVALUE&PUSH 5)                   ; VAR
149   (LIST&PUSH 2)
151   (LOAD&PUSH 8)
152   (GETVALUE&PUSH 5)                   ; VAR
154   (CALL 4 6)                          ; POWEROFX
157   (SETVALUE 2)                        ; M
159   (JMPIF L115)
161   L161
161   (NIL)
162   L162
162   (UNBIND 2)
164   (SKIP 1)
166   (UNBIND1)
167   (SKIP&RET 2)


Disassembly of function SCPROD-1
(CONST 0) = TEMP
(CONST 1) = -1
(CONST 2) = RATGREATERP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (TEMP)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; TEMP
3     (GETVALUE&PUSH 0)                   ; TEMP
5     (CONST&PUSH 1)                      ; -1
6     (CALL2 2)                           ; RATGREATERP
8     (UNBIND1)
9     (SKIP&RET 2)


Disassembly of function #:|(DEFUN REAL-BRANCH (EXPONENT VALUE) ...)-105|
(CONST 0) = REAL-BRANCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REAL-BRANCH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REAL-BRANCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REAL-BRANCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REAL-BRANCH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REAL-BRANCH
8     (SKIP&RET 1)


Disassembly of function REAL-BRANCH
(CONST 0) = 1
(CONST 1) = $YES
(CONST 2) = $INTEGER
(CONST 3) = ASK-INTEGER
(CONST 4) = RATNUMP
(CONST 5) = $ODDP
(CONST 6) = $NO
(CONST 7) = $UNKNOWN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
29 byte-code instructions:
0     (LOAD&PUSH 1)
1     (JMPIFEQTO 0 L18)                   ; 1
4     (LOAD&PUSH 2)
5     (CONST&PUSH 2)                      ; $INTEGER
6     (CALL2&PUSH 3)                      ; ASK-INTEGER
8     (JMPIFEQTO 1 L21)                   ; $YES
11    (LOAD&PUSH 2)
12    (CALL1&JMPIF 4 L27)                 ; RATNUMP
15    (CONST 7)                           ; $UNKNOWN
16    (SKIP&RET 3)
18    L18
18    (CONST 1)                           ; $YES
19    (SKIP&RET 3)
21    L21
21    (CONST 1)                           ; $YES
22    (SKIP&RET 3)
24    L24
24    (CONST 1)                           ; $YES
25    (SKIP&RET 3)
27    L27
27    (LOAD 2)
28    (CDR)
29    (CDR)
30    (CAR&PUSH)
31    (CALL1&PUSH 5)                      ; $ODDP
33    (T)
34    (JMPIFEQ L24)
36    (CONST 6)                           ; $NO
37    (SKIP&RET 3)


Disassembly of function #:|(DEFUN BYGAMMA (M N) ...)-106|
(CONST 0) = BYGAMMA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BYGAMMA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BYGAMMA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BYGAMMA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BYGAMMA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BYGAMMA
8     (SKIP&RET 1)


Disassembly of function BYGAMMA
(CONST 0) = M
(CONST 1) = N
(CONST 2) = 1
(CONST 3) = 2
(CONST 4) = DIV
(CONST 5) = ($BETA)
(CONST 6) = ADD
(CONST 7) = MUL*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N M)
24 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; M
3     (LOAD 4)
4     (BIND 1)                            ; N
6     (CONST&PUSH 2)                      ; 1
7     (CONST&PUSH 3)                      ; 2
8     (CALL2&PUSH 4)                      ; DIV
10    (LOAD&PUSH 0)
11    (CONST&PUSH 5)                      ; ($BETA)
12    (LOAD&PUSH 2)
13    (CONST&PUSH 2)                      ; 1
14    (GETVALUE&PUSH 0)                   ; M
16    (CALL2&PUSH 6)                      ; ADD
18    (CALL2&PUSH 7)                      ; MUL*
20    (LOAD&PUSH 3)
21    (CONST&PUSH 2)                      ; 1
22    (GETVALUE&PUSH 1)                   ; N
24    (CALL2&PUSH 6)                      ; ADD
26    (CALL2&PUSH 7)                      ; MUL*
28    (LIST&PUSH 3)
30    (CALL2 7)                           ; MUL*
32    (SKIP 1)
34    (UNBIND 2)
36    (SKIP&RET 3)


Disassembly of function #:|(DEFUN POWEROFX (E X P ...) ...)-107|
(CONST 0) = POWEROFX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POWEROFX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POWEROFX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POWEROFX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POWEROFX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POWEROFX
8     (SKIP&RET 1)


Disassembly of function POWEROFX
(CONST 0) = E
(CONST 1) = X
(CONST 2) = P
(CONST 3) = VAR
(CONST 4) = AMONG
(CONST 5) = ALIKE1
(CONST 6) = 1
(CONST 7) = MEXPTP
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (P X E VAR)
writes special variable : (E)
58 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; E
3     (LOAD 6)
4     (BIND 1)                            ; X
6     (LOAD 8)
7     (BIND 2)                            ; P
9     (LOAD 10)
10    (BIND 3)                            ; VAR
12    (GETVALUE&PUSH 3)                   ; VAR
14    (GETVALUE&PUSH 0)                   ; E
16    (CALL2&JMPIFNOT 4 L54)              ; AMONG
19    (GETVALUE&PUSH 0)                   ; E
21    (GETVALUE&PUSH 1)                   ; X
23    (CALL2&JMPIF 5 L75)                 ; ALIKE1
26    (GETVALUE 0)                        ; E
28    (JMPIFATOM L54)
30    (GETVALUE&PUSH 0)                   ; E
32    (CALL1&JMPIFNOT 7 L54)              ; MEXPTP
35    (GETVALUE 0)                        ; E
37    (CDR)
38    (CAR&PUSH)
39    (GETVALUE&PUSH 1)                   ; X
41    (CALL2&JMPIFNOT 5 L54)              ; ALIKE1
44    (GETVALUE&PUSH 3)                   ; VAR
46    (GETVALUE 0)                        ; E
48    (CDR)
49    (CDR)
50    (CAR&PUSH)
51    (CALL2&JMPIFNOT 4 L60)              ; AMONG
54    L54
54    (NIL)
55    (SETVALUE 0)                        ; E
57    L57
57    (NIL)
58    (JMP L87)
60    L60
60    (GETVALUE 0)                        ; E
62    (CDR)
63    (CDR)
64    (CAR)
65    (SETVALUE 0)                        ; E
67    (JMPIFNOT L57)
69    (JMP L78)
71    L71
71    (GETVALUE 0)                        ; E
73    (JMP L87)
75    L75
75    (CONST 6)                           ; 1
76    (SETVALUE 0)                        ; E
78    L78
78    (GETVALUE&PUSH 2)                   ; P
80    (GETVALUE&PUSH 0)                   ; E
82    (FUNCALL 1)
84    (JMPIF L71)
86    (NIL)
87    L87
87    (UNBIND 4)
89    (SKIP&RET 5)


Disassembly of function #:|(DECLARE-TOP (SPECIAL L C ...))-108|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(COMMENT (THE FOLLOWING FUNC ...))-109|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN BATA0 (E) ...)-110|
(CONST 0) = BATA0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BATA0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BATA0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BATA0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BATA0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BATA0
8     (SKIP&RET 1)


Disassembly of function BATA0
(CONST 0) = E
(CONST 1) = MTIMESP
(CONST 2) = FINDP
(CONST 3) = K
(CONST 4) = VAR
(CONST 5) = POLYINX
(CONST 6) = BXM
(CONST 7) = C
(CONST 8) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
writes special variables : (C K)
74 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L104)
8     (GETVALUE&PUSH 0)                   ; E
10    (CALL1&JMPIFNOT 1 L84)              ; MTIMESP
14    (GETVALUE 0)                        ; E
16    (CDR)
17    (CDR)
18    (CDR)
19    (JMPIF L84)
21    (GETVALUE 0)                        ; E
23    (CDR)
24    (CAR&PUSH)
25    (CALL1 2)                           ; FINDP
27    (SETVALUE 3)                        ; K
29    (JMPIFNOT L53)
31    (GETVALUE 0)                        ; E
33    (CDR)
34    (CDR)
35    (CAR&PUSH)
36    (GETVALUE 0)                        ; E
38    (CDR)
39    (CDR)
40    (CAR&PUSH)
41    (GETVALUE&PUSH 4)                   ; VAR
43    (NIL&PUSH)
44    (CALL&PUSH 3 5)                     ; POLYINX
47    (CALL2 6)                           ; BXM
49    (SETVALUE 7)                        ; C
51    (JMPIF L107)
53    L53
53    (GETVALUE 0)                        ; E
55    (CDR)
56    (CDR)
57    (CAR&PUSH)
58    (CALL1 2)                           ; FINDP
60    (SETVALUE 3)                        ; K
62    (JMPIFNOT L84)
64    (GETVALUE 0)                        ; E
66    (CDR)
67    (CAR&PUSH)
68    (GETVALUE 0)                        ; E
70    (CDR)
71    (CAR&PUSH)
72    (GETVALUE&PUSH 4)                   ; VAR
74    (NIL&PUSH)
75    (CALL&PUSH 3 5)                     ; POLYINX
78    (CALL2 6)                           ; BXM
80    (SETVALUE 7)                        ; C
82    (JMPIF L107)
84    L84
84    (GETVALUE&PUSH 0)                   ; E
86    (GETVALUE&PUSH 0)                   ; E
88    (GETVALUE&PUSH 4)                   ; VAR
90    (NIL&PUSH)
91    (CALL&PUSH 3 5)                     ; POLYINX
94    (CALL2 6)                           ; BXM
96    (SETVALUE 7)                        ; C
98    (JMPIF L110)
100   (NIL)
101   L101
101   (UNBIND1)
102   (SKIP&RET 2)
104   L104
104   (NIL)
105   (JMP L101)
107   L107
107   (T)
108   (JMP L101)
110   L110
110   (CONST 8)                           ; 0
111   (SETVALUE 3)                        ; K
113   (JMP L101)


Disassembly of function #:|(DEFUN ZTO1 (E) ...)-111|
(CONST 0) = ZTO1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZTO1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZTO1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZTO1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZTO1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZTO1
8     (SKIP&RET 1)


Disassembly of function ZTO1
(CONST 0) = E
(CONST 1) = MTIMESP
(CONST 2) = MEXPTP
(CONST 3) = 0
(CONST 4) = M
(CONST 5) = (%LOG)
(CONST 6) = VAR
(CONST 7) = #<COMPILED-CLOSURE ZTO1-1>
(CONST 8) = FREEOF
(CONST 9) = $INTEGER
(CONST 10) = ASK-INTEGER
(CONST 11) = $YES
(CONST 12) = $ASKSIGN
(CONST 13) = $NEG
(CONST 14) = (MEXPT)
(CONST 15) = DIV
(CONST 16) = BATAP-NEW
(CONST 17) = L
(CONST 18) = N
(CONST 19) = B
(CONST 20) = ($BETA)
(CONST 21) = SIMPLIFY
(CONST 22) = $ZERO
(CONST 23) = BETA
(CONST 24) = NEG
(CONST 25) = -1
(CONST 26) = ADD
(CONST 27) = POWER
(CONST 28) = UL
(CONST 29) = MUL
(CONST 30) = 1
(CONST 31) = ($BETA)
(CONST 32) = $DIFF
(CONST 33) = (MEQUAL)
(CONST 34) = $AT
(CONST 35) = $FULLRATSIMP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N UL B BETA L M VAR E)
writes special variable : (E)
126 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CALL1&JMPIF 1 L15)                 ; MTIMESP
8     (GETVALUE&PUSH 0)                   ; E
10    (CALL1 2)                           ; MEXPTP
12    (JMPIFNOT1 L221)
15    L15
15    (NIL)
16    (MAKE-VECTOR1&PUSH 1)
18    (CONST 3)                           ; 0
19    (BIND 4)                            ; M
21    (CONST&PUSH 5)                      ; (%LOG)
22    (GETVALUE&PUSH 6)                   ; VAR
24    (LIST 2)
26    (STOREC 3 0)
29    (LOAD&PUSH 3)
30    (COPY-CLOSURE&PUSH 7 1)             ; #<COMPILED-CLOSURE ZTO1-1>
33    (GETVALUE 0)                        ; E
35    (CDR&PUSH)
36    (PUSH-UNBOUND 4)
38    (CALLS2 93)                         ; FIND-IF
40    (GETVALUE&PUSH 6)                   ; VAR
42    (GETVALUE&PUSH 4)                   ; M
44    (CALL2 8)                           ; FREEOF
46    (JMPIFNOT1 L218)
49    (GETVALUE&PUSH 4)                   ; M
51    (CONST&PUSH 9)                      ; $INTEGER
52    (CALL2&PUSH 10)                     ; ASK-INTEGER
54    (CONST 11)                          ; $YES
55    (EQ)
56    (JMPIFNOT1 L218)
59    (GETVALUE&PUSH 4)                   ; M
61    (CALL1&PUSH 12)                     ; $ASKSIGN
63    (CONST 13)                          ; $NEG
64    (EQ)
65    (NOT)
66    (JMPIFNOT1 L218)
69    (GETVALUE&PUSH 0)                   ; E
71    (CONST&PUSH 14)                     ; (MEXPT)
72    (LOADC&PUSH 5 0)
75    (GETVALUE&PUSH 4)                   ; M
77    (LIST&PUSH 3)
79    (CALL2 15)                          ; DIV
81    (SETVALUE 0)                        ; E
83    (PUSH)
84    (CALL1 16)                          ; BATAP-NEW
86    (NV-TO-STACK 4)
88    (LOAD 2)
89    (BIND 17)                           ; L
91    (LOAD 4)
92    (BIND 18)                           ; N
94    (LOAD 6)
95    (BIND 19)                           ; B
97    (LOAD 12)
98    (JMPIFNOT1 L214)
101   (CONST&PUSH 20)                     ; ($BETA)
102   (LOAD&PUSH 13)
103   (GETVALUE&PUSH 17)                  ; L
105   (LIST&PUSH 3)
107   (CALL1&PUSH 21)                     ; SIMPLIFY
109   (GETVALUE&PUSH 4)                   ; M
111   (CALL1&PUSH 12)                     ; $ASKSIGN
113   (JMPIFEQTO 22 L224)                 ; $ZERO
117   (GETVALUE 4)                        ; M
119   L119
119   (BIND 4)                            ; M
121   (LOAD 3)
122   (BIND 23)                           ; BETA
124   (GETVALUE&PUSH 23)                  ; BETA
126   (GETVALUE&PUSH 19)                  ; B
128   (CALL1&PUSH 24)                     ; NEG
130   (CONST&PUSH 25)                     ; -1
131   (GETVALUE&PUSH 17)                  ; L
133   (CALL2&PUSH 26)                     ; ADD
135   (CALL2&PUSH 27)                     ; POWER
137   (GETVALUE&PUSH 28)                  ; UL
139   (GETVALUE&PUSH 18)                  ; N
141   (CONST&PUSH 25)                     ; -1
142   (GETVALUE&PUSH 17)                  ; L
144   (CALL2&PUSH 26)                     ; ADD
146   (CALL2&PUSH 29)                     ; MUL
148   (CALL2&PUSH 27)                     ; POWER
150   (GETVALUE&PUSH 18)                  ; N
152   (CONST&PUSH 30)                     ; 1
154   (GETVALUE&PUSH 4)                   ; M
156   (CALL2&PUSH 26)                     ; ADD
158   (CALL1&PUSH 24)                     ; NEG
160   (CALL2&PUSH 27)                     ; POWER
162   (GETVALUE&PUSH 28)                  ; UL
164   (GETVALUE&PUSH 18)                  ; N
166   (GETVALUE&PUSH 6)                   ; VAR
168   (CALL2&PUSH 29)                     ; MUL
170   (CALL2&PUSH 27)                     ; POWER
172   (CONST&PUSH 31)                     ; ($BETA)
174   (GETVALUE&PUSH 6)                   ; VAR
176   (GETVALUE&PUSH 17)                  ; L
178   (LIST&PUSH 3)
180   (CALL2&PUSH 29)                     ; MUL
182   (GETVALUE&PUSH 6)                   ; VAR
184   (GETVALUE&PUSH 4)                   ; M
186   (CALL&PUSH 3 32)                    ; $DIFF
189   (CONST&PUSH 33)                     ; (MEQUAL)
191   (GETVALUE&PUSH 6)                   ; VAR
193   (LOAD&PUSH 26)
195   (LIST&PUSH 3)
197   (CALL2&PUSH 34)                     ; $AT
199   (CALL&PUSH 4 29)                    ; MUL
202   (GETVALUE&PUSH 23)                  ; BETA
204   (CALL2&PUSH 15)                     ; DIV
206   (CALL1&PUSH 35)                     ; $FULLRATSIMP
208   (CALL2 29)                          ; MUL
210   (UNBIND 2)
212   (SKIP 1)
214   L214
214   (UNBIND 3)
216   (SKIP 4)
218   L218
218   (UNBIND1)
219   (SKIP 1)
221   L221
221   (UNBIND1)
222   (SKIP&RET 2)
224   L224
224   (CONST 3)                           ; 0
225   (JMP L119)


Disassembly of function ZTO1-1
(CONST 0) = NIL
(CONST 1) = #<COMPILED-CLOSURE ZTO1-SET-M>
(CONST 2) = VAR
(CONST 3) = POWEROFX
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
6 byte-code instructions:
0     (LOAD&PUSH 1)
1     (LOADV&PUSH 0 1)
4     (CONST&PUSH 1)                      ; #<COMPILED-CLOSURE ZTO1-SET-M>
5     (GETVALUE&PUSH 2)                   ; VAR
7     (CALL 4 3)                          ; POWEROFX
10    (SKIP&RET 2)


Disassembly of function ZTO1-SET-M
(CONST 0) = P
(CONST 1) = M
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (P)
writes special variable : (M)
6 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; P
3     (GETVALUE 0)                        ; P
5     (SETVALUE 1)                        ; M
7     (UNBIND1)
8     (SKIP&RET 2)


Disassembly of function #:|(DEFUN BATAP-NEW (E) ...)-112|
(CONST 0) = BATAP-NEW
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BATAP-NEW>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BATAP-NEW
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BATAP-NEW
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BATAP-NEW>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BATAP-NEW
8     (SKIP&RET 1)


Disassembly of function BATAP-NEW
(CONST 0) = E
(CONST 1) = K
(CONST 2) = C
(CONST 3) = BATA0
(CONST 4) = L
(CONST 5) = A
(CONST 6) = N
(CONST 7) = B
(CONST 8) = VAR
(CONST 9) = FREEOF
(CONST 10) = UL
(CONST 11) = POWER
(CONST 12) = MUL
(CONST 13) = NEG
(CONST 14) = ALIKE1
(CONST 15) = $ASKSIGN
(CONST 16) = $NEG
(CONST 17) = 1
(CONST 18) = ADD
(CONST 19) = $POS
(CONST 20) = DIV
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL B A L N K VAR C E)
writes special variables : (L K)
82 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; K
6     (NIL)
7     (BIND 2)                            ; C
9     (GETVALUE&PUSH 0)                   ; E
11    (CALL1 3)                           ; BATA0
13    (JMPIFNOT1 L140)
16    (GETVALUE 2)                        ; C
18    (LIST-TO-MV)
19    (NV-TO-STACK 4)
21    (LOAD 3)
22    (BIND 4)                            ; L
24    (LOAD 5)
25    (BIND 5)                            ; A
27    (LOAD 7)
28    (BIND 6)                            ; N
30    (LOAD 9)
31    (BIND 7)                            ; B
33    (GETVALUE&PUSH 8)                   ; VAR
35    (GETVALUE&PUSH 1)                   ; K
37    (CALL2 9)                           ; FREEOF
39    (JMPIFNOT1 L136)
42    (GETVALUE&PUSH 8)                   ; VAR
44    (GETVALUE&PUSH 6)                   ; N
46    (CALL2 9)                           ; FREEOF
48    (JMPIFNOT1 L136)
51    (GETVALUE&PUSH 8)                   ; VAR
53    (GETVALUE&PUSH 4)                   ; L
55    (CALL2 9)                           ; FREEOF
57    (JMPIFNOT1 L136)
60    (GETVALUE&PUSH 5)                   ; A
62    (GETVALUE&PUSH 7)                   ; B
64    (GETVALUE&PUSH 10)                  ; UL
66    (GETVALUE&PUSH 6)                   ; N
68    (CALL2&PUSH 11)                     ; POWER
70    (CALL2&PUSH 12)                     ; MUL
72    (CALL1&PUSH 13)                     ; NEG
74    (CALL2 14)                          ; ALIKE1
76    (JMPIFNOT1 L136)
78    (GETVALUE&PUSH 7)                   ; B
80    (CALL1&PUSH 15)                     ; $ASKSIGN
82    (CONST 16)                          ; $NEG
83    (EQ)
84    (JMPIFNOT1 L136)
86    (CONST&PUSH 17)                     ; 1
87    (GETVALUE&PUSH 1)                   ; K
89    (CALL2 18)                          ; ADD
91    (SETVALUE 1)                        ; K
93    (PUSH)
94    (CALL1&PUSH 15)                     ; $ASKSIGN
96    (CONST 19)                          ; $POS
97    (EQ)
98    (JMPIFNOT1 L136)
100   (CONST&PUSH 17)                     ; 1
101   (GETVALUE&PUSH 4)                   ; L
103   (CALL2 18)                          ; ADD
105   (SETVALUE 4)                        ; L
107   (PUSH)
108   (CALL1&PUSH 15)                     ; $ASKSIGN
110   (CONST 19)                          ; $POS
111   (EQ)
112   (JMPIFNOT1 L136)
114   (GETVALUE&PUSH 6)                   ; N
116   (CALL1&PUSH 15)                     ; $ASKSIGN
118   (CONST 19)                          ; $POS
119   (EQ)
120   (JMPIFNOT1 L136)
122   (GETVALUE&PUSH 1)                   ; K
124   (GETVALUE&PUSH 6)                   ; N
126   (CALL2&PUSH 20)                     ; DIV
128   (GETVALUE&PUSH 4)                   ; L
130   (GETVALUE&PUSH 6)                   ; N
132   (GETVALUE&PUSH 7)                   ; B
134   (STACK-TO-MV 4)
136   L136
136   (UNBIND 4)
138   (SKIP 4)
140   L140
140   (UNBIND 3)
142   (SKIP&RET 2)


Disassembly of function #:|(DEFUN BATAPP (E) ...)-113|
(CONST 0) = BATAPP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BATAPP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BATAPP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BATAPP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BATAPP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BATAPP
8     (SKIP&RET 1)


Disassembly of function BATAPP
(CONST 0) = E
(CONST 1) = K
(CONST 2) = C
(CONST 3) = D
(CONST 4) = L
(CONST 5) = LL
(CONST 6) = 0
(CONST 7) = $MINF
(CONST 8) = VAR
(CONST 9) = ADD*
(CONST 10) = SUBIN
(CONST 11) = BATA0
(CONST 12) = RATGREATERP
(CONST 13) = 1
(CONST 14) = DIV*
(CONST 15) = $ASKSIGN
(CONST 16) = $POS
(CONST 17) = -1
(CONST 18) = MUL*
(CONST 19) = MUL
(CONST 20) = ($BETA)
(CONST 21) = POWER*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D L K C E VAR LL)
writes special variables : (C D L K E)
94 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; K
6     (NIL)
7     (BIND 2)                            ; C
9     (NIL)
10    (BIND 3)                            ; D
12    (NIL)
13    (BIND 4)                            ; L
15    (NIL&PUSH)
16    (GETVALUE&PUSH 5)                   ; LL
18    (JMPIFEQTO 6 L38)                   ; 0
21    (GETVALUE&PUSH 5)                   ; LL
23    (JMPIFEQTO 7 L38)                   ; $MINF
26    (GETVALUE&PUSH 5)                   ; LL
28    (GETVALUE&PUSH 8)                   ; VAR
30    (CALL2&PUSH 9)                      ; ADD*
32    (GETVALUE&PUSH 0)                   ; E
34    (CALL2 10)                          ; SUBIN
36    (SETVALUE 0)                        ; E
38    L38
38    (GETVALUE&PUSH 0)                   ; E
40    (CALL1&JMPIFNOT 11 L108)            ; BATA0
44    (GETVALUE 2)                        ; C
46    (CDR)
47    (CDR)
48    (CAR)
49    (STORE 0)
50    (PUSH)
51    (CONST&PUSH 6)                      ; 0
52    (CALL2&JMPIFNOT 12 L108)            ; RATGREATERP
55    (CONST&PUSH 13)                     ; 1
56    (GETVALUE&PUSH 1)                   ; K
58    (CALL2&PUSH 9)                      ; ADD*
60    (LOAD&PUSH 1)
61    (CALL2 14)                          ; DIV*
63    (SETVALUE 1)                        ; K
65    (PUSH)
66    (CALL1&PUSH 15)                     ; $ASKSIGN
68    (JMPIFNOTEQTO 16 L108)              ; $POS
71    (CONST&PUSH 17)                     ; -1
72    (GETVALUE 2)                        ; C
74    (CAR&PUSH)
75    (CALL2 18)                          ; MUL*
77    (SETVALUE 4)                        ; L
79    (PUSH)
80    (GETVALUE&PUSH 1)                   ; K
82    (CALL2&JMPIFNOT 12 L108)            ; RATGREATERP
85    (GETVALUE 2)                        ; C
87    (CDR)
88    (CAR)
89    (SETVALUE 3)                        ; D
91    (PUSH)
92    (GETVALUE 2)                        ; C
94    (CDR)
95    (CDR)
96    (CDR)
97    (CAR)
98    (SETVALUE 2)                        ; C
100   (PUSH)
101   (CALL2&PUSH 18)                     ; MUL*
103   (CALL1&PUSH 15)                     ; $ASKSIGN
105   (JMPIFEQTO 16 L116)                 ; $POS
108   L108
108   (NIL)
109   (SKIP 1)
111   (UNBIND 4)
113   L113
113   (UNBIND1)
114   (SKIP&RET 2)
116   L116
116   (GETVALUE&PUSH 4)                   ; L
118   (CONST&PUSH 17)                     ; -1
119   (GETVALUE&PUSH 1)                   ; K
121   (CALL2&PUSH 19)                     ; MUL
123   (CALL2 9)                           ; ADD*
125   (SETVALUE 4)                        ; L
127   (CONST&PUSH 20)                     ; ($BETA)
128   (GETVALUE&PUSH 1)                   ; K
130   (GETVALUE&PUSH 4)                   ; L
132   (LIST&PUSH 3)
134   (LOAD&PUSH 1)
135   (GETVALUE&PUSH 2)                   ; C
137   (GETVALUE&PUSH 1)                   ; K
139   (CALL2&PUSH 21)                     ; POWER*
141   (GETVALUE&PUSH 3)                   ; D
143   (GETVALUE&PUSH 4)                   ; L
145   (CALL2&PUSH 21)                     ; POWER*
147   (CALL&PUSH 3 18)                    ; MUL*
150   (CALL2 14)                          ; DIV*
152   (SKIP 1)
154   (UNBIND 4)
156   (JMP L113)


Disassembly of function #:|(DECLARE-TOP (UNSPECIAL L C ...))-114|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN GAMMA1 (C A B ...) ...)-115|
(CONST 0) = GAMMA1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMA1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMA1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMA1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMA1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMA1
8     (SKIP&RET 1)


Disassembly of function GAMMA1
(CONST 0) = C
(CONST 1) = A
(CONST 2) = B
(CONST 3) = D
(CONST 4) = $%E
(CONST 5) = POWER
(CONST 6) = 1
(CONST 7) = ADD
(CONST 8) = DIV*
(CONST 9) = POWER*
(CONST 10) = MUL*
(CONST 11) = -1
(CONST 12) = (%GAMMA)
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C A B D)
writes special variable : (C)
30 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; C
3     (LOAD 6)
4     (BIND 1)                            ; A
6     (LOAD 8)
7     (BIND 2)                            ; B
9     (LOAD 10)
10    (BIND 3)                            ; D
12    (CONST&PUSH 4)                      ; $%E
13    (GETVALUE&PUSH 3)                   ; D
15    (CALL2&PUSH 5)                      ; POWER
17    (GETVALUE&PUSH 2)                   ; B
19    (GETVALUE&PUSH 1)                   ; A
21    (GETVALUE&PUSH 0)                   ; C
23    (CONST&PUSH 6)                      ; 1
24    (CALL2&PUSH 7)                      ; ADD
26    (GETVALUE&PUSH 2)                   ; B
28    (CALL2 8)                           ; DIV*
30    (SETVALUE 0)                        ; C
32    (PUSH)
33    (CALL2&PUSH 9)                      ; POWER*
35    (CALL2&PUSH 10)                     ; MUL*
37    (CONST&PUSH 11)                     ; -1
38    (CALL2&PUSH 9)                      ; POWER*
40    (CONST&PUSH 12)                     ; (%GAMMA)
41    (GETVALUE&PUSH 0)                   ; C
43    (LIST&PUSH 2)
45    (CALL 3 10)                         ; MUL*
48    (UNBIND 4)
50    (SKIP&RET 5)


Disassembly of function #:|(DEFUN ZTO%PI2 (GRAND VAR) ...)-116|
(CONST 0) = ZTO%PI2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZTO%PI2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZTO%PI2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZTO%PI2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZTO%PI2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZTO%PI2
8     (SKIP&RET 1)


Disassembly of function ZTO%PI2
(CONST 0) = VAR
(CONST 1) = DIV*
(CONST 2) = $RATSIMP
(CONST 3) = UNITCIR
(CONST 4) = -1
(CONST 5) = $%I
(CONST 6) = MUL*
(CONST 7) = SRATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
23 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR
3     (LOAD&PUSH 5)
4     (GETVALUE&PUSH 0)                   ; VAR
6     (CALL2&PUSH 1)                      ; DIV*
8     (CALL1&PUSH 2)                      ; $RATSIMP
10    (GETVALUE&PUSH 0)                   ; VAR
12    (CALL2&PUSH 3)                      ; UNITCIR
14    (LOAD&JMPIF 0 L23)
17    (NIL)
18    (SKIP 1)
20    L20
20    (UNBIND1)
21    (SKIP&RET 3)
23    L23
23    (CONST&PUSH 4)                      ; -1
24    (CONST&PUSH 5)                      ; $%I
25    (CALL2&PUSH 6)                      ; MUL*
27    (LOAD&PUSH 1)
28    (CALL2&PUSH 6)                      ; MUL*
30    (CALL1 7)                           ; SRATSIMP
32    (SKIP 1)
34    (JMP L20)


Disassembly of function #:|(DEFUN UNITCIR (GRAND VAR) ...)-117|
(CONST 0) = UNITCIR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE UNITCIR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; UNITCIR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; UNITCIR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE UNITCIR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; UNITCIR
8     (SKIP&RET 1)


Disassembly of function UNITCIR
(CONST 0) = VAR
(CONST 1) = NUMDEN
(CONST 2) = NN*
(CONST 3) = DN*
(CONST 4) = #<COMPILED-CLOSURE UNITCIR-1>
(CONST 5) = #<COMPILED-CLOSURE UNITCIR-2>
(CONST 6) = RES
(CONST 7) = PRINCIP
(CONST 8) = $%PI
(CONST 9) = MUL*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DN* NN*)
22 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR
3     (LOAD&PUSH 5)
4     (CALL1 1)                           ; NUMDEN
6     (GETVALUE&PUSH 2)                   ; NN*
8     (GETVALUE&PUSH 3)                   ; DN*
10    (CONST&PUSH 4)                      ; #<COMPILED-CLOSURE UNITCIR-1>
11    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE UNITCIR-2>
12    (CALL&PUSH 4 6)                     ; RES
15    (CALL1&PUSH 7)                      ; PRINCIP
17    (LOAD&JMPIF 0 L26)
20    (NIL)
21    (SKIP 1)
23    L23
23    (UNBIND1)
24    (SKIP&RET 3)
26    L26
26    (CONST&PUSH 8)                      ; $%PI
27    (LOAD&PUSH 1)
28    (CALL2 9)                           ; MUL*
30    (SKIP 1)
32    (JMP L23)


Disassembly of function UNITCIR-1
(CONST 0) = 1
(CONST 1) = CABS
(CONST 2) = RATGREATERP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; 1
1     (LOAD&PUSH 2)
2     (CALL1&PUSH 1)                      ; CABS
4     (CALL2 2)                           ; RATGREATERP
6     (SKIP&RET 2)


Disassembly of function UNITCIR-2
(CONST 0) = 1
(CONST 1) = CABS
(CONST 2) = ALIKE1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; 1
1     (LOAD&PUSH 2)
2     (CALL1&PUSH 1)                      ; CABS
4     (CALL2 2)                           ; ALIKE1
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN LOGX1 (EXP LL UL) ...)-118|
(CONST 0) = LOGX1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGX1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGX1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGX1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGX1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGX1
8     (SKIP&RET 1)


Disassembly of function LOGX1
(CONST 0) = EXP
(CONST 1) = LL
(CONST 2) = UL
(CONST 3) = ARG
(CONST 4) = (%SIN %COS %TAN %ATAN %ASIN %ACOS)
(CONST 5) = NOTINVOLVE
(CONST 6) = (%LOG)
(CONST 7) = INVOLVE
(CONST 8) = VAR
(CONST 9) = 1
(CONST 10) = RATGREATERP
(CONST 11) = $INF
(CONST 12) = $%E
(CONST 13) = -1
(CONST 14) = MUL*
(CONST 15) = POWER
(CONST 16) = (%LOG)
(CONST 17) = INTCV1
(CONST 18) = (%LOG)
(CONST 19) = INTCV
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR ARG EXP)
writes special variable : (ARG)
61 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; LL
6     (LOAD 7)
7     (BIND 2)                            ; UL
9     (NIL)
10    (BIND 3)                            ; ARG
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CONST&PUSH 4)                      ; (%SIN %COS %TAN %ATAN %ASIN %ACOS)
15    (CALL2&JMPIFNOT 5 L93)              ; NOTINVOLVE
19    (GETVALUE&PUSH 0)                   ; EXP
21    (CONST&PUSH 6)                      ; (%LOG)
22    (CALL2 7)                           ; INVOLVE
24    (SETVALUE 3)                        ; ARG
26    (JMPIFNOT L93)
29    (GETVALUE&PUSH 3)                   ; ARG
31    (GETVALUE 8)                        ; VAR
33    (JMPIFNOTEQ L83)
35    (CONST&PUSH 9)                      ; 1
36    (GETVALUE&PUSH 1)                   ; LL
38    (CALL2&JMPIFNOT 10 L93)             ; RATGREATERP
41    (GETVALUE&PUSH 2)                   ; UL
43    (JMPIFNOTEQTO 11 L64)               ; $INF
46    (CONST&PUSH 12)                     ; $%E
47    (GETVALUE&PUSH 8)                   ; VAR
49    (CALL2&PUSH 15)                     ; POWER
51    (NIL&PUSH)
52    (CONST&PUSH 18)                     ; (%LOG)
53    (GETVALUE&PUSH 8)                   ; VAR
55    (LIST 2)
57    L57
57    (PUSH)
58    (CALL 3 17)                         ; INTCV1
61    (UNBIND1)
62    (JMP L95)
64    L64
64    (CONST&PUSH 12)                     ; $%E
65    (CONST&PUSH 13)                     ; -1
66    (GETVALUE&PUSH 8)                   ; VAR
68    (CALL2&PUSH 14)                     ; MUL*
70    (CALL2&PUSH 15)                     ; POWER
72    (NIL&PUSH)
73    (CONST&PUSH 13)                     ; -1
74    (CONST&PUSH 16)                     ; (%LOG)
75    (GETVALUE&PUSH 8)                   ; VAR
77    (LIST&PUSH 2)
79    (CALL2 14)                          ; MUL*
81    (JMP L57)
83    L83
83    (GETVALUE&PUSH 3)                   ; ARG
85    (PUSH-NIL 2)
87    (CALL 3 19)                         ; INTCV
90    (UNBIND1)
91    (JMP L95)
93    L93
93    (NIL)
94    (UNBIND1)
95    L95
95    (UNBIND 3)
97    (SKIP&RET 4)


Disassembly of function #:|(DEFUN SCAXN (E) ...)-119|
(CONST 0) = SCAXN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SCAXN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SCAXN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SCAXN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SCAXN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SCAXN
8     (SKIP&RET 1)


Disassembly of function SCAXN
(CONST 0) = E
(CONST 1) = IND
(CONST 2) = S
(CONST 3) = %SIN
(CONST 4) = %COS
(CONST 5) = BX**N
(CONST 6) = 1
(CONST 7) = $IND
(CONST 8) = $ASKSIGN
(CONST 9) = SIGN
(CONST 10) = $POS
(CONST 11) = $NEG
(CONST 12) = -1
(CONST 13) = $ZERO
(CONST 14) = 0
(CONST 15) = ADD*
(CONST 16) = MUL*
(CONST 17) = GAMMA1
(CONST 18) = HALF%PI
(CONST 19) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (HALF%PI IND S SIGN E)
writes special variables : (S E IND)
118 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; IND
6     (NIL)
7     (BIND 2)                            ; S
9     (NIL&PUSH)
10    (GETVALUE 0)                        ; E
12    (JMPIFATOM L53)
14    (GETVALUE 0)                        ; E
16    (CAR)
17    (CAR&PUSH)
18    (JMPIFEQTO 3 L28)                   ; %SIN
21    (GETVALUE 0)                        ; E
23    (CAR)
24    (CAR&PUSH)
25    (JMPIFNOTEQTO 4 L46)                ; %COS
28    L28
28    (GETVALUE 0)                        ; E
30    (CAR)
31    (CAR)
32    (SETVALUE 1)                        ; IND
34    (JMPIFNOT L46)
36    (GETVALUE 0)                        ; E
38    (CDR)
39    (CAR&PUSH)
40    (CALL1 5)                           ; BX**N
42    (SETVALUE 0)                        ; E
44    (JMPIF L78)
46    L46
46    (NIL)
47    L47
47    (SKIP 1)
49    (UNBIND 3)
51    (SKIP&RET 2)
53    L53
53    (NIL)
54    (JMP L47)
56    L56
56    (CONST 7)                           ; $IND
57    (JMP L47)
59    L59
59    (CONST 6)                           ; 1
60    (JMP L108)
62    L62
62    (CONST 12)                          ; -1
63    (JMP L108)
65    L65
65    (CONST 14)                          ; 0
66    (JMP L108)
68    L68
68    (NIL)
69    (JMP L47)
71    L71
71    (NIL)
72    (JMP L47)
74    L74
74    (CONST 12)                          ; -1
75    (JMP L173)
78    L78
78    (GETVALUE 0)                        ; E
80    (CAR&PUSH)
81    (JMPIFEQTO 6 L56)                   ; 1
84    (GETVALUE 0)                        ; E
86    (CDR)
87    (CAR&PUSH)
88    (CALL1 8)                           ; $ASKSIGN
90    (BIND 9)                            ; SIGN
92    (GETVALUE&PUSH 9)                   ; SIGN
94    (JMPIFEQTO 10 L59)                  ; $POS
97    (GETVALUE&PUSH 9)                   ; SIGN
99    (JMPIFEQTO 11 L62)                  ; $NEG
102   (GETVALUE&PUSH 9)                   ; SIGN
104   (JMPIFEQTO 13 L65)                  ; $ZERO
107   (NIL)
108   L108
108   (UNBIND1)
109   (SETVALUE 2)                        ; S
111   (PUSH)
112   (CALLS2&JMPIF 145 L68)              ; ZEROP
115   (CONST&PUSH 12)                     ; -1
116   (GETVALUE 0)                        ; E
118   (CAR&PUSH)
119   (CALL2&PUSH 15)                     ; ADD*
121   (CALL1&PUSH 8)                      ; $ASKSIGN
123   (JMPIFNOTEQTO 10 L71)               ; $POS
126   (CONST&PUSH 14)                     ; 0
127   (GETVALUE&PUSH 2)                   ; S
129   (GETVALUE 0)                        ; E
131   (CDR)
132   (CAR&PUSH)
133   (CALL2&PUSH 16)                     ; MUL*
135   (GETVALUE 0)                        ; E
137   (CAR&PUSH)
138   (CONST&PUSH 14)                     ; 0
139   (CALL 4 17)                         ; GAMMA1
142   (STORE 0)
143   (PUSH)
144   (GETVALUE&PUSH 1)                   ; IND
146   (LIST&PUSH 1)
148   (GETVALUE&PUSH 18)                  ; HALF%PI
150   (GETVALUE 0)                        ; E
152   (CAR&PUSH)
153   (CALL2&PUSH 19)                     ; DIV*
155   (LIST&PUSH 2)
157   (CALL2 16)                          ; MUL*
159   (SETVALUE 0)                        ; E
161   (GETVALUE&PUSH 1)                   ; IND
163   (JMPIFNOTEQTO 3 L172)               ; %SIN
166   (GETVALUE&PUSH 2)                   ; S
168   (JMPIFEQTO 12 L74)                  ; -1
172   L172
172   (CONST 6)                           ; 1
173   L173
173   (PUSH)
174   (GETVALUE&PUSH 0)                   ; E
176   (CALL2 16)                          ; MUL*
178   (JMP L47)


Disassembly of function #:|(COMMENT THIS IS ...)-120|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (SPECIAL VAR PLM* ...))-121|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN P*LOGNXP (A S) ...)-122|
(CONST 0) = P*LOGNXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE P*LOGNXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; P*LOGNXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; P*LOGNXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE P*LOGNXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; P*LOGNXP
8     (SKIP&RET 1)


Disassembly of function P*LOGNXP
(CONST 0) = A
(CONST 1) = S
(CONST 2) = B
(CONST 3) = %LOG
(CONST 4) = AMONG
(CONST 5) = 1
(CONST 6) = (%LOG)
(CONST 7) = VAR
(CONST 8) = MAXIMA-SUBSTITUTE
(CONST 9) = POLYINX
(CONST 10) = DEG
(CONST 11) = ADD*
(CONST 12) = $SIGN
(CONST 13) = $POS
(CONST 14) = EVENFN
(CONST 15) = DIV*
(CONST 16) = $RATSIMP
(CONST 17) = LOGNXP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B S VAR A)
writes special variables : (A B)
51 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; A
3     (LOAD 4)
4     (BIND 1)                            ; S
6     (NIL)
7     (BIND 2)                            ; B
9     (CONST&PUSH 3)                      ; %LOG
10    (GETVALUE&PUSH 0)                   ; A
12    (CALL2&JMPIFNOT 4 L74)              ; AMONG
15    (CONST&PUSH 5)                      ; 1
16    (CONST&PUSH 6)                      ; (%LOG)
17    (GETVALUE&PUSH 7)                   ; VAR
19    (LIST&PUSH 2)
21    (GETVALUE&PUSH 0)                   ; A
23    (CALL 3 8)                          ; MAXIMA-SUBSTITUTE
26    (SETVALUE 2)                        ; B
28    (PUSH)
29    (GETVALUE&PUSH 7)                   ; VAR
31    (T&PUSH)
32    (CALL 3 9)                          ; POLYINX
35    (JMPIFNOT L74)
37    (GETVALUE&PUSH 1)                   ; S
39    (CONST&PUSH 5)                      ; 1
40    (GETVALUE&PUSH 2)                   ; B
42    (CALL1&PUSH 10)                     ; DEG
44    (CALL2&PUSH 11)                     ; ADD*
46    (CALL2&PUSH 11)                     ; ADD*
48    (CALL1&PUSH 12)                     ; $SIGN
50    (JMPIFNOTEQTO 13 L74)               ; $POS
53    (GETVALUE&PUSH 2)                   ; B
55    (GETVALUE&PUSH 7)                   ; VAR
57    (CALL2&JMPIFNOT 14 L74)             ; EVENFN
60    (GETVALUE&PUSH 0)                   ; A
62    (GETVALUE&PUSH 2)                   ; B
64    (CALL2&PUSH 15)                     ; DIV*
66    (CALL1&PUSH 16)                     ; $RATSIMP
68    (CALL1 17)                          ; LOGNXP
70    (SETVALUE 0)                        ; A
72    (JMPIF L80)
74    L74
74    (NIL)
75    (UNBIND1)
76    L76
76    (UNBIND 2)
78    (SKIP&RET 3)
80    L80
80    (GETVALUE&PUSH 2)                   ; B
82    (GETVALUE&PUSH 0)                   ; A
84    (LIST 2)
86    (UNBIND1)
87    (JMP L76)


Disassembly of function #:|(DEFUN LOGNXP (A) ...)-123|
(CONST 0) = LOGNXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGNXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGNXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGNXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGNXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGNXP
8     (SKIP&RET 1)


Disassembly of function LOGNXP
(CONST 0) = A
(CONST 1) = %LOG
(CONST 2) = VAR
(CONST 3) = 1
(CONST 4) = MEXPTP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR A)
44 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (GETVALUE 0)                        ; A
5     (JMPIFATOM L47)
7     (GETVALUE 0)                        ; A
9     (CAR)
10    (CAR&PUSH)
11    (JMPIFNOTEQTO 1 L22)                ; %LOG
14    (GETVALUE 0)                        ; A
16    (CDR)
17    (CAR&PUSH)
18    (GETVALUE 2)                        ; VAR
20    (JMPIFEQ L50)
22    L22
22    (GETVALUE&PUSH 0)                   ; A
24    (CALL1&JMPIFNOT 4 L43)              ; MEXPTP
27    (GETVALUE 0)                        ; A
29    (CDR)
30    (CDR)
31    (CAR&PUSH)
32    (CALLS2&JMPIFNOT 8 L43)             ; NUMBERP
35    (GETVALUE 0)                        ; A
37    (CDR)
38    (CAR&PUSH)
39    (JSR L0)
41    (JMPIF L53)
43    L43
43    (NIL)
44    L44
44    (UNBIND1)
45    (SKIP&RET 2)
47    L47
47    (NIL)
48    (JMP L44)
50    L50
50    (CONST 3)                           ; 1
51    (JMP L44)
53    L53
53    (GETVALUE 0)                        ; A
55    (CDR)
56    (CDR)
57    (CAR)
58    (JMP L44)


Disassembly of function #:|(COMMENT CHECK THE ...)-124|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN LOGCPI0 (N D) ...)-125|
(CONST 0) = LOGCPI0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGCPI0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGCPI0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGCPI0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGCPI0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGCPI0
8     (SKIP&RET 1)


Disassembly of function LOGCPI0
(CONST 0) = N
(CONST 1) = D
(CONST 2) = UPPERHALF
(CONST 3) = #<COMPILED-CLOSURE LOGCPI0-1>
(CONST 4) = POLELIST
(CONST 5) = FACTORS
(CONST 6) = VAR
(CONST 7) = SDIFF
(CONST 8) = PLM*
(CONST 9) = LEADCOEF
(CONST 10) = RESIDUE
(CONST 11) = RLM*
(CONST 12) = PL*
(CONST 13) = RES1
(CONST 14) = RL*
(CONST 15) = PL*1
(CONST 16) = RL*1
(CONST 17) = 1
(CONST 18) = 2
(CONST 19) = DIV
(CONST 20) = $%PI
(CONST 21) = NN*
(CONST 22) = ADDN
(CONST 23) = PRINCIP
(CONST 24) = MUL
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FACTORS RL*1 RLM* RL* PL*1 PL* PLM* LEADCOEF N VAR D)
writes special variables : (NN* RL*1 PL*1 RL* PL* RLM* PLM* FACTORS)
108 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (PUSH-NIL 2)
8     (GETVALUE&PUSH 1)                   ; D
10    (CONST&SYMBOL-FUNCTION&PUSH 2)      ; UPPERHALF
12    (CONST&PUSH 3)                      ; #<COMPILED-CLOSURE LOGCPI0-1>
13    (CALL 3 4)                          ; POLELIST
16    (STORE 1)
17    (JMPIFNOT L139)
20    (LOAD 1)
21    (CAR)
22    (SETVALUE 5)                        ; FACTORS
24    (LOAD&CDR&STORE 1)
26    (CDR)
27    (CAR)
28    (JMPIF L36)
30    (LOAD 1)
31    (CDR)
32    (CDR)
33    (CAR)
34    (JMPIFNOT L43)
36    L36
36    (GETVALUE&PUSH 1)                   ; D
38    (GETVALUE&PUSH 6)                   ; VAR
40    (CALL2 7)                           ; SDIFF
42    (STORE 0)
43    L43
43    (LOAD 1)
44    (CAR)
45    (SETVALUE 8)                        ; PLM*
47    (JMPIFNOT L66)
49    (GETVALUE&PUSH 0)                   ; N
51    (GETVALUE 9)                        ; LEADCOEF
53    (JMPIF L144)
56    (GETVALUE 1)                        ; D
58    L58
58    (PUSH)
59    (GETVALUE&PUSH 8)                   ; PLM*
61    (CALL 3 10)                         ; RESIDUE
64    (SETVALUE 11)                       ; RLM*
66    L66
66    (LOAD 1)
67    (CDR)
68    (CAR)
69    (SETVALUE 12)                       ; PL*
71    (JMPIFNOT L83)
73    (GETVALUE&PUSH 0)                   ; N
75    (LOAD&PUSH 1)
76    (GETVALUE&PUSH 12)                  ; PL*
78    (CALL 3 13)                         ; RES1
81    (SETVALUE 14)                       ; RL*
83    L83
83    (LOAD 1)
84    (CDR)
85    (CDR)
86    (CAR)
87    (SETVALUE 15)                       ; PL*1
89    (JMPIFNOT L101)
91    (GETVALUE&PUSH 0)                   ; N
93    (LOAD&PUSH 1)
94    (GETVALUE&PUSH 15)                  ; PL*1
96    (CALL 3 13)                         ; RES1
99    (SETVALUE 16)                       ; RL*1
101   L101
101   (CONST&PUSH 17)                     ; 1
102   (CONST&PUSH 18)                     ; 2
103   (CALL2&PUSH 19)                     ; DIV
105   (CONST&PUSH 20)                     ; $%PI
106   (GETVALUE&PUSH 14)                  ; RL*
108   (GETVALUE&PUSH 11)                  ; RLM*
110   (CALLSR 2 34)                       ; APPEND
113   (SETVALUE 21)                       ; NN*
115   (JMPIF L149)
117   (NIL)
118   L118
118   (PUSH)
119   (GETVALUE 16)                       ; RL*1
121   (JMPIF L155)
123   (NIL)
124   L124
124   (PUSH)
125   (LIST&PUSH 2)
127   (CALL1&PUSH 23)                     ; PRINCIP
129   (CALL2&PUSH 24)                     ; MUL
131   (CALL2 24)                          ; MUL
133   (SKIP 2)
135   L135
135   (UNBIND 2)
137   (SKIP&RET 3)
139   L139
139   (NIL)
140   (SKIP 2)
142   (JMP L135)
144   L144
144   (GETVALUE 5)                        ; FACTORS
146   (JMP L58)
149   L149
149   (PUSH)
150   (NIL&PUSH)
151   (CALL2 22)                          ; ADDN
153   (JMP L118)
155   L155
155   (PUSH)
156   (NIL&PUSH)
157   (CALL2 22)                          ; ADDN
159   (JMP L124)


Disassembly of function LOGCPI0-1
(CONST 0) = ZEROP1
(CONST 1) = $IMAGPART
(CONST 2) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&JMPIF 0 L10)                 ; ZEROP1
4     (LOAD&PUSH 1)
5     (CALL1&PUSH 1)                      ; $IMAGPART
7     (JMPIFEQTO 2 L13)                   ; 0
10    L10
10    (NIL)
11    (SKIP&RET 2)
13    L13
13    (T)
14    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LOGNX2 (NN DN PL ...) ...)-126|
(CONST 0) = LOGNX2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGNX2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGNX2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGNX2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGNX2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGNX2
8     (SKIP&RET 1)


Disassembly of function LOGNX2
(CONST 0) = ANS
(CONST 1) = (%PLOG)
(CONST 2) = POWER*
(CONST 3) = MUL*
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ANS)
writes special variable : (ANS)
26 byte-code instructions:
0     (LOAD&PUSH 2)
1     (LOAD&PUSH 2)
2     (NIL)
3     (BIND 0)                            ; ANS
5     (LOAD&JMPIFNOT 4 L39)
8     L8
8     (LOAD&JMPIFNOT 3 L39)
11    (LOAD&PUSH 8)
12    (LOAD&CAR&PUSH 4)
14    (CONST&PUSH 1)                      ; (%PLOG)
15    (LOAD&CAR&PUSH 7)
17    (LIST&PUSH 2)
19    (LOAD&PUSH 12)
20    (CALL2&PUSH 2)                      ; POWER*
22    (CALL&PUSH 3 3)                     ; MUL*
25    (GETVALUE 0)                        ; ANS
27    (CONS)
28    (SETVALUE 0)                        ; ANS
30    (LOAD&CDR&PUSH 4)
32    (LOAD&CDR&STORE 4)
34    (POP&STORE 4)
36    (LOAD&JMPIF 4 L8)
39    L39
39    (GETVALUE 0)                        ; ANS
41    (UNBIND1)
42    (SKIP&RET 7)


Disassembly of function #:|(DEFUN LOGCPJ (N D I) ...)-127|
(CONST 0) = LOGCPJ
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGCPJ>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGCPJ
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGCPJ
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGCPJ>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGCPJ
8     (SKIP&RET 1)


Disassembly of function LOGCPJ
(CONST 0) = N
(CONST 1) = D
(CONST 2) = PLM*
(CONST 3) = $%I
(CONST 4) = %PI2
(CONST 5) = MUL
(CONST 6) = (%PLOG)
(CONST 7) = VAR
(CONST 8) = POWER*
(CONST 9) = MUL*
(CONST 10) = RESIDUE
(CONST 11) = ADDN
(CONST 12) = PL*
(CONST 13) = RL*
(CONST 14) = LOGNX2
(CONST 15) = %P%I
(CONST 16) = PL*1
(CONST 17) = RL*1
(CONST 18) = 0
(CONST 19) = SIMPLIFY
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D VAR N RL*1 PL*1 %P%I RL* PL* %PI2 PLM*)
writes special variable : (N)
53 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (GETVALUE 2)                        ; PLM*
8     (JMPIF L53)
10    (NIL)
11    L11
11    (PUSH)
12    (LOAD&PUSH 8)
13    (CONST&PUSH 3)                      ; $%I
14    (GETVALUE&PUSH 4)                   ; %PI2
16    (CALL2&PUSH 5)                      ; MUL
18    (GETVALUE&PUSH 12)                  ; PL*
20    (GETVALUE&PUSH 13)                  ; RL*
22    (CALL&PUSH 4 14)                    ; LOGNX2
25    (LOAD&PUSH 9)
26    (GETVALUE&PUSH 15)                  ; %P%I
28    (GETVALUE&PUSH 16)                  ; PL*1
30    (GETVALUE&PUSH 17)                  ; RL*1
32    (CALL&PUSH 4 14)                    ; LOGNX2
35    (CALLSR 3 34)                       ; APPEND
38    (SETVALUE 0)                        ; N
40    (JMPIFNOT L87)
42    (GETVALUE&PUSH 0)                   ; N
44    (NIL&PUSH)
45    (CALL2&PUSH 11)                     ; ADDN
47    (CALL1 19)                          ; SIMPLIFY
49    L49
49    (UNBIND 2)
51    (SKIP&RET 4)
53    L53
53    (CONST&PUSH 3)                      ; $%I
54    (GETVALUE&PUSH 4)                   ; %PI2
56    (CALL2&PUSH 5)                      ; MUL
58    (CONST&PUSH 6)                      ; (%PLOG)
59    (GETVALUE&PUSH 7)                   ; VAR
61    (LIST&PUSH 2)
63    (LOAD&PUSH 9)
64    (CALL2&PUSH 8)                      ; POWER*
66    (GETVALUE&PUSH 0)                   ; N
68    (CALL2&PUSH 9)                      ; MUL*
70    (GETVALUE&PUSH 1)                   ; D
72    (GETVALUE&PUSH 2)                   ; PLM*
74    (CALL&PUSH 3 10)                    ; RESIDUE
77    (NIL&PUSH)
78    (CALL2&PUSH 11)                     ; ADDN
80    (CALL2&PUSH 9)                      ; MUL*
82    (LIST 1)
84    (JMP L11)
87    L87
87    (CONST 18)                          ; 0
88    (JMP L49)


Disassembly of function #:|(DEFUN LOG*RAT (N D M) ...)-128|
(CONST 0) = LOG*RAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOG*RAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOG*RAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOG*RAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOG*RAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOG*RAT
8     (SKIP&RET 1)


Disassembly of function LOG*RAT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = M
(CONST 3) = LEADCOEF
(CONST 4) = FACTORS
(CONST 5) = C
(CONST 6) = PLM*
(CONST 7) = PL*
(CONST 8) = RL*
(CONST 9) = PL*1
(CONST 10) = RL*1
(CONST 11) = RLM*
(CONST 12) = 1
(CONST 13) = ADD*
(CONST 14) = *ARRAY
(CONST 15) = *I*
(CONST 16) = *J*
(CONST 17) = 0
(CONST 18) = LOGCPI
(CONST 19) = LOGCPJ
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FACTORS D N *I* C *J* M)
writes special variables : (C *J* *I*)
89 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; M
9     (NIL)
10    (BIND 3)                            ; LEADCOEF
12    (NIL)
13    (BIND 4)                            ; FACTORS
15    (NIL)
16    (BIND 5)                            ; C
18    (NIL)
19    (BIND 6)                            ; PLM*
21    (NIL)
22    (BIND 7)                            ; PL*
24    (NIL)
25    (BIND 8)                            ; RL*
27    (NIL)
28    (BIND 9)                            ; PL*1
30    (NIL)
31    (BIND 10)                           ; RL*1
33    (NIL)
34    (BIND 11)                           ; RLM*
36    (NIL&PUSH)
37    (T&PUSH)
38    (CONST&PUSH 12)                     ; 1
39    (GETVALUE&PUSH 2)                   ; M
41    (CALL2&PUSH 13)                     ; ADD*
43    (CALL 3 14)                         ; *ARRAY
46    (SETVALUE 15)                       ; *I*
48    (NIL&PUSH)
49    (T&PUSH)
50    (CONST&PUSH 12)                     ; 1
51    (GETVALUE&PUSH 2)                   ; M
53    (CALL2&PUSH 13)                     ; ADD*
55    (CALL 3 14)                         ; *ARRAY
58    (SETVALUE 16)                       ; *J*
60    (CONST 17)                          ; 0
61    (SETVALUE 5)                        ; C
63    (GETVALUE&PUSH 16)                  ; *J*
65    (GETVALUE&PUSH 5)                   ; C
67    (LOAD&PUSH 1)
68    (LOAD&PUSH 1)
69    (CONST&PUSH 17)                     ; 0
70    (CALLSR 1 2)                        ; SYSTEM::STORE
73    (SKIP 2)
75    (CONST 17)                          ; 0
76    (BIND 5)                            ; C
78    (JMP L129)
80    L80
80    (GETVALUE&PUSH 15)                  ; *I*
82    (GETVALUE&PUSH 5)                   ; C
84    (GETVALUE&PUSH 0)                   ; N
86    (GETVALUE&PUSH 1)                   ; D
88    (GETVALUE&PUSH 5)                   ; C
90    (CALL&PUSH 3 18)                    ; LOGCPI
93    (LOAD&PUSH 2)
94    (LOAD&PUSH 2)
95    (LOAD&PUSH 2)
96    (CALLSR 1 2)                        ; SYSTEM::STORE
99    (SKIP 3)
101   (GETVALUE&PUSH 16)                  ; *J*
103   (GETVALUE&PUSH 5)                   ; C
105   (GETVALUE&PUSH 0)                   ; N
107   (GETVALUE&PUSH 4)                   ; FACTORS
109   (GETVALUE&PUSH 5)                   ; C
111   (CALL&PUSH 3 19)                    ; LOGCPJ
114   (LOAD&PUSH 2)
115   (LOAD&PUSH 2)
116   (LOAD&PUSH 2)
117   (CALLSR 1 2)                        ; SYSTEM::STORE
120   (SKIP 3)
122   (CONST&PUSH 12)                     ; 1
123   (GETVALUE&PUSH 5)                   ; C
125   (CALL2 13)                          ; ADD*
127   (SETVALUE 5)                        ; C
129   L129
129   (GETVALUE&PUSH 5)                   ; C
131   (GETVALUE&PUSH 2)                   ; M
133   (CALLS2&JMPIFNOT 2 L80)             ; EQUAL
136   (GETVALUE&PUSH 0)                   ; N
138   (GETVALUE&PUSH 1)                   ; D
140   (GETVALUE&PUSH 2)                   ; M
142   (CALL 3 18)                         ; LOGCPI
145   (UNBIND1)
146   (NIL)
147   (UNBIND 12)
149   (SKIP&RET 4)


Disassembly of function #:|(DEFUN LOGCPI (N D C) ...)-129|
(CONST 0) = LOGCPI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGCPI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGCPI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGCPI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGCPI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGCPI
8     (SKIP&RET 1)


Disassembly of function LOGCPI
(CONST 0) = N
(CONST 1) = D
(CONST 2) = C
(CONST 3) = 0
(CONST 4) = LOGCPI0
(CONST 5) = ((RAT) 1 2)
(CONST 6) = *J*
(CONST 7) = -1
(CONST 8) = SUMI
(CONST 9) = MUL*
(CONST 10) = ADD*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D N *J* C)
26 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; C
9     (GETVALUE&PUSH 2)                   ; C
11    (JMPIFEQTO 3 L37)                   ; 0
14    (CONST&PUSH 5)                      ; ((RAT) 1 2)
15    (GETVALUE&PUSH 6)                   ; *J*
17    (GETVALUE&PUSH 2)                   ; C
19    (CALLSR&PUSH 1 1)                   ; AREF
22    (CONST&PUSH 7)                      ; -1
23    (GETVALUE&PUSH 2)                   ; C
25    (CALL1&PUSH 8)                      ; SUMI
27    (CALL2&PUSH 9)                      ; MUL*
29    (CALL2&PUSH 10)                     ; ADD*
31    (CALL2 9)                           ; MUL*
33    L33
33    (UNBIND 3)
35    (SKIP&RET 4)
37    L37
37    (GETVALUE&PUSH 0)                   ; N
39    (GETVALUE&PUSH 1)                   ; D
41    (CALL2 4)                           ; LOGCPI0
43    (JMP L33)


Disassembly of function #:|(DEFUN SUMI (C) ...)-130|
(CONST 0) = SUMI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SUMI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUMI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SUMI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SUMI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SUMI
8     (SKIP&RET 1)


Disassembly of function SUMI
(CONST 0) = C
(CONST 1) = 1
(CONST 2) = K
(CONST 3) = ANS
(CONST 4) = (%BINOMIAL)
(CONST 5) = $MAKEGAMMA
(CONST 6) = $%PI
(CONST 7) = POWER
(CONST 8) = $%I
(CONST 9) = *I*
(CONST 10) = -1
(CONST 11) = MUL*
(CONST 12) = ADD*
(CONST 13) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS *I* K C)
writes special variables : (K ANS)
43 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; C
3     (CONST 1)                           ; 1
4     (BIND 2)                            ; K
6     (NIL)
7     (BIND 3)                            ; ANS
9     (JMP L59)
11    L11
11    (CONST&PUSH 4)                      ; (%BINOMIAL)
12    (GETVALUE&PUSH 0)                   ; C
14    (GETVALUE&PUSH 2)                   ; K
16    (LIST&PUSH 3)
18    (CALL1&PUSH 5)                      ; $MAKEGAMMA
20    (CONST&PUSH 6)                      ; $%PI
21    (GETVALUE&PUSH 2)                   ; K
23    (CALL2&PUSH 7)                      ; POWER
25    (CONST&PUSH 8)                      ; $%I
26    (GETVALUE&PUSH 2)                   ; K
28    (CALL2&PUSH 7)                      ; POWER
30    (GETVALUE&PUSH 9)                   ; *I*
32    (GETVALUE&PUSH 0)                   ; C
34    (CONST&PUSH 10)                     ; -1
35    (GETVALUE&PUSH 2)                   ; K
37    (CALL2&PUSH 11)                     ; MUL*
39    (CALL2&PUSH 12)                     ; ADD*
41    (CALLSR&PUSH 1 1)                   ; AREF
44    (CALL&PUSH 4 11)                    ; MUL*
47    (GETVALUE 3)                        ; ANS
49    (CONS)
50    (SETVALUE 3)                        ; ANS
52    (CONST&PUSH 1)                      ; 1
53    (GETVALUE&PUSH 2)                   ; K
55    (CALL2 12)                          ; ADD*
57    (SETVALUE 2)                        ; K
59    L59
59    (GETVALUE&PUSH 2)                   ; K
61    (GETVALUE&PUSH 0)                   ; C
63    (CALLS2&JMPIFNOT 2 L11)             ; EQUAL
66    (GETVALUE&PUSH 3)                   ; ANS
68    (NIL&PUSH)
69    (CALL2 13)                          ; ADDN
71    (UNBIND 3)
73    (SKIP&RET 2)


Disassembly of function #:|(DEFUN FAN (P M A ...) ...)-131|
(CONST 0) = FAN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FAN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FAN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FAN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FAN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FAN
8     (SKIP&RET 1)


Disassembly of function FAN
(CONST 0) = P
(CONST 1) = M
(CONST 2) = A
(CONST 3) = N
(CONST 4) = B
(CONST 5) = DIV*
(CONST 6) = $INTEGER
(CONST 7) = ASK-INTEGER
(CONST 8) = $YES
(CONST 9) = $IMAGPART
(CONST 10) = 0
(CONST 11) = $ASKSIGN
(CONST 12) = IND
(CONST 13) = $ZERO
(CONST 14) = $NEG
(CONST 15) = RATGREATERP
(CONST 16) = $%PI
(CONST 17) = (%BINOMIAL)
(CONST 18) = -1
(CONST 19) = MUL*
(CONST 20) = ADD*
(CONST 21) = ADD
(CONST 22) = $MAKEGAMMA
(CONST 23) = (MABS)
(CONST 24) = POWER*
(CONST 25) = (%SIN)
(CONST 26) = MUL
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M IND B A N P)
86 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; P
3     (LOAD 7)
4     (BIND 1)                            ; M
6     (LOAD 9)
7     (BIND 2)                            ; A
9     (LOAD 11)
10    (BIND 3)                            ; N
12    (LOAD 13)
13    (BIND 4)                            ; B
15    (GETVALUE&PUSH 0)                   ; P
17    (GETVALUE&PUSH 3)                   ; N
19    (CALL2&PUSH 5)                      ; DIV*
21    (GETVALUE&PUSH 2)                   ; A
23    (GETVALUE&PUSH 4)                   ; B
25    (CALL2&PUSH 5)                      ; DIV*
27    (LOAD&PUSH 1)
28    (CONST&PUSH 6)                      ; $INTEGER
29    (CALL2&PUSH 7)                      ; ASK-INTEGER
31    (JMPIFEQTO 8 L131)                  ; $YES
35    (LOAD&PUSH 0)
36    (CALL1&PUSH 9)                      ; $IMAGPART
38    (JMPIFNOTEQTO 10 L131)              ; 0
42    (LOAD&PUSH 0)
43    (CALL1 11)                          ; $ASKSIGN
45    (BIND 12)                           ; IND
47    (GETVALUE&PUSH 12)                  ; IND
49    (JMPIFEQTO 13 L136)                 ; $ZERO
53    (GETVALUE&PUSH 12)                  ; IND
55    (JMPIFEQTO 14 L139)                 ; $NEG
59    (GETVALUE&PUSH 1)                   ; M
61    (LOAD&PUSH 5)
62    (CALL2&JMPIFNOT 15 L142)            ; RATGREATERP
66    (CONST&PUSH 16)                     ; $%PI
67    (CONST&PUSH 17)                     ; (%BINOMIAL)
68    (CONST&PUSH 18)                     ; -1
69    (GETVALUE&PUSH 1)                   ; M
71    (CONST&PUSH 18)                     ; -1
72    (LOAD&PUSH 9)
73    (CALL2&PUSH 19)                     ; MUL*
75    (CALL&PUSH 3 20)                    ; ADD*
78    (CONST&PUSH 18)                     ; -1
79    (GETVALUE&PUSH 1)                   ; M
81    (CALL2&PUSH 21)                     ; ADD
83    (LIST&PUSH 3)
85    (CALL1&PUSH 22)                     ; $MAKEGAMMA
87    (CONST&PUSH 23)                     ; (MABS)
88    (GETVALUE&PUSH 2)                   ; A
90    (LOAD&PUSH 8)
91    (CONST&PUSH 18)                     ; -1
92    (GETVALUE&PUSH 1)                   ; M
94    (CALL2&PUSH 19)                     ; MUL*
96    (CALL2&PUSH 20)                     ; ADD*
98    (CALL2&PUSH 24)                     ; POWER*
100   (LIST&PUSH 2)
102   (CALL&PUSH 3 19)                    ; MUL*
105   (GETVALUE&PUSH 4)                   ; B
107   (LOAD&PUSH 6)
108   (CALL2&PUSH 24)                     ; POWER*
110   (GETVALUE&PUSH 3)                   ; N
112   (CONST&PUSH 25)                     ; (%SIN)
113   (CONST&PUSH 16)                     ; $%PI
114   (LOAD&PUSH 9)
115   (CALL2&PUSH 26)                     ; MUL
117   (LIST&PUSH 2)
119   (CALL&PUSH 3 19)                    ; MUL*
122   (CALL2 5)                           ; DIV*
124   L124
124   (UNBIND1)
125   (SKIP 2)
127   L127
127   (UNBIND 5)
129   (SKIP&RET 6)
131   L131
131   (NIL)
132   (SKIP 2)
134   (JMP L127)
136   L136
136   (NIL)
137   (JMP L124)
139   L139
139   (NIL)
140   (JMP L124)
142   L142
142   (NIL)
143   (JMP L124)


Disassembly of function #:|(DEFUN MAKPOLY (P) ...)-132|
(CONST 0) = MAKPOLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKPOLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKPOLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKPOLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKPOLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKPOLY
8     (SKIP&RET 1)


Disassembly of function MAKPOLY
(CONST 0) = P
(CONST 1) = DEG
(CONST 2) = N
(CONST 3) = ANS
(CONST 4) = VARLIST
(CONST 5) = 1
(CONST 6) = ADD*
(CONST 7) = GENPOLY
(CONST 8) = VAR
(CONST 9) = $%I
(CONST 10) = %PI2
(CONST 11) = MUL
(CONST 12) = ADD
(CONST 13) = -1
(CONST 14) = MUL*
(CONST 15) = SUBIN
(CONST 16) = NEWVAR
(CONST 17) = RATREP*
(CONST 18) = GENFIND
(CONST 19) = 0
(CONST 20) = COEFSOLVE
(CONST 21) = $SUBSTITUTE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (%PI2 ANS VAR N P)
writes special variables : (VARLIST ANS)
85 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; P
3     (GETVALUE&PUSH 0)                   ; P
5     (CALL1 1)                           ; DEG
7     (BIND 2)                            ; N
9     (NIL)
10    (BIND 3)                            ; ANS
12    (NIL)
13    (BIND 4)                            ; VARLIST
15    (PUSH-NIL 3)
17    (CONST&PUSH 5)                      ; 1
18    (GETVALUE&PUSH 2)                   ; N
20    (CALL2&PUSH 6)                      ; ADD*
22    (CALL1 7)                           ; GENPOLY
24    (SETVALUE 3)                        ; ANS
26    (CDR)
27    (STORE 1)
28    (PUSH)
29    (GETVALUE&PUSH 8)                   ; VAR
31    (LIST&PUSH 1)
33    (CALLSR 2 34)                       ; APPEND
36    (SETVALUE 4)                        ; VARLIST
38    (GETVALUE 3)                        ; ANS
40    (CAR)
41    (STORE 2)
42    (PUSH)
43    (CONST&PUSH 9)                      ; $%I
44    (GETVALUE&PUSH 10)                  ; %PI2
46    (CALL2&PUSH 11)                     ; MUL
48    (GETVALUE&PUSH 8)                   ; VAR
50    (CALL2&PUSH 12)                     ; ADD
52    (CONST&PUSH 13)                     ; -1
53    (LOAD&PUSH 5)
54    (CALL2&PUSH 14)                     ; MUL*
56    (CALL2&PUSH 15)                     ; SUBIN
58    (CONST&PUSH 13)                     ; -1
59    (GETVALUE&PUSH 0)                   ; P
61    (CALL2&PUSH 14)                     ; MUL*
63    (CALL 3 6)                          ; ADD*
66    (SETVALUE 3)                        ; ANS
68    (PUSH)
69    (CALL1 16)                          ; NEWVAR
71    (GETVALUE&PUSH 3)                   ; ANS
73    (CALL1 17)                          ; RATREP*
75    (SETVALUE 3)                        ; ANS
77    (GETVALUE&PUSH 2)                   ; N
79    (LOAD&PUSH 2)
80    (GETVALUE 3)                        ; ANS
82    (CDR)
83    (CAR)
84    (CAR&PUSH)
85    (GETVALUE 3)                        ; ANS
87    (CAR&PUSH)
88    (GETVALUE&PUSH 8)                   ; VAR
90    (CALL2 18)                          ; GENFIND
92    (JMPIFNOTEQ L122)
94    (GETVALUE 3)                        ; ANS
96    (CDR)
97    (CAR)
98    (CDR)
99    (JMPIF L102)
101   (NIL)
102   L102
102   (PUSH)
103   (CALL 3 20)                         ; COEFSOLVE
106   (STORE 0)
107   (JMPIFNOT L131)
109   (LOAD&JMPIFNOT 2 L131)
112   (LOAD&PUSH 0)
113   (LOAD&PUSH 3)
114   (CALL2 21)                          ; $SUBSTITUTE
116   L116
116   (SKIP 3)
118   (UNBIND 4)
120   (SKIP&RET 2)
122   L122
122   (CONST&PUSH 19)                     ; 0
123   (GETVALUE 3)                        ; ANS
125   (CDR)
126   (CAR&PUSH)
127   (LIST 2)
129   (JMP L102)
131   L131
131   (CONST 13)                          ; -1
132   (JMP L116)


Disassembly of function #:|(DEFUN COEFSOLVE (N CL E) ...)-133|
(CONST 0) = COEFSOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COEFSOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COEFSOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COEFSOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COEFSOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COEFSOLVE
8     (SKIP&RET 1)


Disassembly of function COEFSOLVE
(CONST 0) = N
(CONST 1) = E
(CONST 2) = PTERM
(CONST 3) = PDIS
(CONST 4) = -1
(CONST 5) = ADD*
(CONST 6) = M
(CONST 7) = $BREAKUP
(CONST 8) = 0
(CONST 9) = SOLVEX
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M N E)
writes special variable : (M)
44 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; E
6     (NIL&PUSH)
7     (GETVALUE&PUSH 1)                   ; E
9     (GETVALUE&PUSH 0)                   ; N
11    (CALL2&PUSH 2)                      ; PTERM
13    (CALL1&PUSH 3)                      ; PDIS
15    (NIL)
16    (CONS&PUSH)
17    (GETVALUE&PUSH 0)                   ; N
19    (CONST&PUSH 4)                      ; -1
20    (CALL2 5)                           ; ADD*
22    (BIND 6)                            ; M
24    (LOAD 4)
25    (BIND 7)                            ; $BREAKUP
27    (JMP L48)
29    L29
29    (GETVALUE&PUSH 1)                   ; E
31    (GETVALUE&PUSH 6)                   ; M
33    (CALL2&PUSH 2)                      ; PTERM
35    (CALL1&PUSH 3)                      ; PDIS
37    (LOAD 7)
38    (CONS&PUSH)
39    (GETVALUE&PUSH 6)                   ; M
41    (CONST&PUSH 4)                      ; -1
42    (CALL2 5)                           ; ADD*
44    (SETVALUE 6)                        ; M
46    (POP&STORE 6)
48    L48
48    (GETVALUE&PUSH 6)                   ; M
50    (CALLS2&JMPIFNOT 8 L29)             ; NUMBERP
53    (GETVALUE&PUSH 6)                   ; M
55    (CONST&PUSH 8)                      ; 0
56    (CALLSR&JMPIFNOT 1 47 L29)          ; <
60    (LOAD&PUSH 6)
61    (LOAD&PUSH 17)
62    (PUSH-NIL 2)
64    (CALL 4 9)                          ; SOLVEX
67    (UNBIND 2)
69    (SKIP 2)
71    (UNBIND 2)
73    (SKIP&RET 4)


Disassembly of function #:|(DEFUN RECTZTO%PI2 (P PE D) ...)-134|
(CONST 0) = RECTZTO%PI2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RECTZTO%PI2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RECTZTO%PI2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RECTZTO%PI2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RECTZTO%PI2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RECTZTO%PI2
8     (SKIP&RET 1)


Disassembly of function RECTZTO%PI2
(CONST 0) = P
(CONST 1) = D
(CONST 2) = N
(CONST 3) = A
(CONST 4) = B
(CONST 5) = C
(CONST 6) = PIN%EX
(CONST 7) = %E-INTEGER-COEFF
(CONST 8) = -1
(CONST 9) = $%I
(CONST 10) = %PI2
(CONST 11) = MAKPOLY
(CONST 12) = MUL
(CONST 13) = $EXPAND
(CONST 14) = MUL*
(CONST 15) = Z*
(CONST 16) = VAR
(CONST 17) = LEADCOEF
(CONST 18) = #<COMPILED-CLOSURE RECTZTO%PI2-1>
(CONST 19) = #<COMPILED-CLOSURE RECTZTO%PI2-2>
(CONST 20) = POLELIST
(CONST 21) = SDIFF
(CONST 22) = LOG-IMAG-0-2%PI
(CONST 23) = RES1
(CONST 24) = ADDN
(CONST 25) = 0
(CONST 26) = TEMP
(CONST 27) = ADD*
(CONST 28) = $%E
(CONST 29) = POWER
(CONST 30) = DIV*
(CONST 31) = EXP
(CONST 32) = $RESIDUE
(CONST 33) = ((RAT) 1 2)
(CONST 34) = SRATSIMP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A EXP VAR C TEMP B N %PI2 P D)
writes special variables : (A C B N)
220 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; P
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (NIL&PUSH)
7     (NIL)
8     (BIND 2)                            ; N
10    (NIL&PUSH)
11    (NIL)
12    (BIND 3)                            ; A
14    (NIL)
15    (BIND 4)                            ; B
17    (NIL)
18    (BIND 5)                            ; C
20    (NIL&PUSH)
21    (CONST 6)                           ; PIN%EX
22    (CATCH-OPEN L37)
24    (GETVALUE&PUSH 1)                   ; D
26    (CALL1 6)                           ; PIN%EX
28    (CATCH-CLOSE)
29    (STORE 0)
30    (JMPIFNOT L91)
32    (JMP L40)
34    L34
34    (CONST 8)                           ; -1
35    (JMP L65)
37    L37
37    (STORE 0)
38    (JMPIFNOT L91)
40    L40
40    (LOAD&PUSH 23)
41    (CALL1&JMPIFNOT 7 L91)              ; %E-INTEGER-COEFF
44    (GETVALUE&PUSH 1)                   ; D
46    (CALL1&JMPIFNOT 7 L91)              ; %E-INTEGER-COEFF
49    (GETVALUE 0)                        ; P
51    (JMPIFNOT L34)
53    (CONST&PUSH 9)                      ; $%I
54    (GETVALUE&PUSH 10)                  ; %PI2
56    (GETVALUE&PUSH 0)                   ; P
58    (CALL1&PUSH 11)                     ; MAKPOLY
60    (CALL&PUSH 3 12)                    ; MUL
63    (CALL1 13)                          ; $EXPAND
65    L65
65    (PUSH)
66    (LOAD&PUSH 24)
67    (CALL2 14)                          ; MUL*
69    (SETVALUE 2)                        ; N
71    (CONST 15)                          ; Z*
72    (BIND 16)                           ; VAR
74    (NIL)
75    (BIND 17)                           ; LEADCOEF
77    (LOAD&PUSH 6)
78    (CONST&PUSH 18)                     ; #<COMPILED-CLOSURE RECTZTO%PI2-1>
79    (CONST&PUSH 19)                     ; #<COMPILED-CLOSURE RECTZTO%PI2-2>
80    (CALL 3 20)                         ; POLELIST
83    (CDR)
84    (STORE 16)
86    (UNBIND 2)
88    (JMPIF L271)
91    L91
91    (NIL)
92    (SKIP 1)
94    (UNBIND 3)
96    (SKIP 1)
98    (UNBIND1)
99    (SKIP 1)
101   (JMP L344)
104   L104
104   (CONST&SYMBOL-FUNCTION&PUSH 22)     ; LOG-IMAG-0-2%PI
106   (LOAD 11)
107   (CDR)
108   (CAR&PUSH)
109   (CALLSR 0 22)                       ; MAPCAR
112   (SETVALUE 4)                        ; B
114   (GETVALUE&PUSH 2)                   ; N
116   (LOAD&PUSH 15)
117   (GETVALUE&PUSH 4)                   ; B
119   (CALL 3 23)                         ; RES1
122   (SETVALUE 4)                        ; B
124   (PUSH)
125   (NIL&PUSH)
126   (CALL2 24)                          ; ADDN
128   (SETVALUE 4)                        ; B
130   (JMP L300)
133   L133
133   (CONST&SYMBOL-FUNCTION&PUSH 22)     ; LOG-IMAG-0-2%PI
135   (LOAD 11)
136   (CDR)
137   (CDR)
138   (CAR&PUSH)
139   (CALLSR 0 22)                       ; MAPCAR
142   (BIND 26)                           ; TEMP
144   (GETVALUE&PUSH 26)                  ; TEMP
146   (NIL&PUSH)
147   (GETVALUE&PUSH 26)                  ; TEMP
149   (JMP L167)
151   L151
151   (LOAD&CAR&PUSH 0)
153   (CONST&PUSH 9)                      ; $%I
154   (GETVALUE&PUSH 10)                  ; %PI2
156   (CALL2&PUSH 12)                     ; MUL
158   (LOAD&PUSH 1)
159   (CALL2&PUSH 27)                     ; ADD*
161   (LOAD&CONS&STORE 2)
163   (SKIP 1)
165   (LOAD&CDR&STORE 0)
167   L167
167   (LOAD&PUSH 0)
168   (CALLS1&JMPIFNOT 146 L151)          ; ENDP
171   (SKIP 1)
173   (LOAD&PUSH 0)
174   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
177   (CALLSR 2 34)                       ; APPEND
180   (SETVALUE 5)                        ; C
182   (GETVALUE&PUSH 2)                   ; N
184   (LOAD&PUSH 18)
185   (GETVALUE&PUSH 5)                   ; C
187   (CALL 3 23)                         ; RES1
190   (SETVALUE 5)                        ; C
192   (PUSH)
193   (NIL&PUSH)
194   (CALL2 24)                          ; ADDN
196   (SETVALUE 5)                        ; C
198   (UNBIND1)
199   (JMP L311)
202   L202
202   (CONST&SYMBOL-FUNCTION&PUSH 22)     ; LOG-IMAG-0-2%PI
204   (LOAD 11)
205   (CAR)
206   (CAR&PUSH)
207   (CALLSR&PUSH 0 22)                  ; MAPCAR
210   (GETVALUE&PUSH 2)                   ; N
212   (CONST&PUSH 28)                     ; $%E
213   (GETVALUE&PUSH 16)                  ; VAR
215   (CALL2&PUSH 29)                     ; POWER
217   (CONST&PUSH 15)                     ; Z*
218   (LOAD&PUSH 4)
219   (PUSH-UNBOUND 3)
221   (CALLS1&PUSH 172)                   ; SUBST
223   (CALL2 30)                          ; DIV*
225   (BIND 31)                           ; EXP
227   (NIL&PUSH)
228   (LOAD&PUSH 4)
229   (JMP L247)
231   L231
231   (LOAD&CAR&PUSH 0)
233   (GETVALUE&PUSH 31)                  ; EXP
235   (GETVALUE&PUSH 16)                  ; VAR
237   (LOAD&PUSH 2)
238   (CALL&PUSH 3 32)                    ; $RESIDUE
241   (LOAD&CONS&STORE 2)
243   (SKIP 1)
245   (LOAD&CDR&STORE 0)
247   L247
247   (LOAD&PUSH 0)
248   (CALLS1&JMPIFNOT 146 L231)          ; ENDP
251   (SKIP 1)
253   (LOAD&PUSH 0)
254   (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
256   (SKIP 1)
258   (SETVALUE 3)                        ; A
260   (PUSH)
261   (NIL&PUSH)
262   (CALL2 24)                          ; ADDN
264   (SETVALUE 3)                        ; A
266   (UNBIND1)
267   (SKIP 1)
269   (JMP L320)
271   L271
271   (LOAD 10)
272   (CDR)
273   (CAR)
274   (JMPIF L282)
276   (LOAD 10)
277   (CDR)
278   (CDR)
279   (CAR)
280   (JMPIFNOT L290)
282   L282
282   (GETVALUE&PUSH 1)                   ; D
284   (GETVALUE&PUSH 16)                  ; VAR
286   (CALL2 21)                          ; SDIFF
288   (STORE 14)
290   L290
290   (LOAD 10)
291   (CDR)
292   (CAR)
293   (JMPIF L104)
296   (CONST 25)                          ; 0
298   (SETVALUE 4)                        ; B
300   L300
300   (LOAD 10)
301   (CDR)
302   (CDR)
303   (CAR)
304   (JMPIF L133)
307   (CONST 25)                          ; 0
309   (SETVALUE 5)                        ; C
311   L311
311   (LOAD 10)
312   (CAR)
313   (JMPIF L202)
316   (CONST 25)                          ; 0
318   (SETVALUE 3)                        ; A
320   L320
320   (GETVALUE&PUSH 3)                   ; A
322   (GETVALUE&PUSH 4)                   ; B
324   (CONST&PUSH 33)                     ; ((RAT) 1 2)
326   (GETVALUE&PUSH 5)                   ; C
328   (CALL2&PUSH 14)                     ; MUL*
330   (CALL&PUSH 3 27)                    ; ADD*
333   (CALL1 34)                          ; SRATSIMP
335   (SKIP 1)
337   (UNBIND 3)
339   (SKIP 1)
341   (UNBIND1)
342   (SKIP 1)
344   L344
344   (UNBIND 2)
346   (SKIP&RET 4)


Disassembly of function RECTZTO%PI2-1
(CONST 0) = $IMAGPART
(CONST 1) = 0
(CONST 2) = $REALPART
(CONST 3) = $ASKSIGN
(CONST 4) = $NEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $IMAGPART
3     (CONST 1)                           ; 0
4     (EQ)
5     (NOT)
6     (JMPIF1 L17)
8     (LOAD&PUSH 1)
9     (CALL1&PUSH 2)                      ; $REALPART
11    (CALL1&PUSH 3)                      ; $ASKSIGN
13    (CONST 4)                           ; $NEG
14    (EQ)
15    (SKIP&RET 2)
17    L17
17    (SKIP&RET 2)


Disassembly of function RECTZTO%PI2-2
(CONST 0) = $REALPART
(CONST 1) = $ASKSIGN
(CONST 2) = $ZERO
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; $REALPART
3     (CALL1&PUSH 1)                      ; $ASKSIGN
5     (CONST 2)                           ; $ZERO
6     (EQ)
7     (NOT)
8     (SKIP&RET 2)


Disassembly of function #:|(DEFUN GENPOLY (I) ...)-135|
(CONST 0) = GENPOLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GENPOLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GENPOLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GENPOLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GENPOLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GENPOLY
8     (SKIP&RET 1)


Disassembly of function GENPOLY
(CONST 0) = C
(CONST 1) = ANS
(CONST 2) = VAR
(CONST 3) = POWER
(CONST 4) = MUL*
(CONST 5) = -1
(CONST 6) = ADD*
(CONST 7) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR C)
writes special variables : (C ANS)
38 byte-code instructions:
0     (LOAD&PUSH 1)
1     (PUSH-UNBOUND 1)
3     (CALLS2 143)                        ; GENSYM
5     (BIND 0)                            ; C
7     (NIL&PUSH)
8     (NIL)
9     (BIND 1)                            ; ANS
11    (JMP L43)
13    L13
13    (GETVALUE&PUSH 0)                   ; C
15    (GETVALUE&PUSH 2)                   ; VAR
17    (LOAD&PUSH 9)
18    (CALL2&PUSH 3)                      ; POWER
20    (CALL2&PUSH 4)                      ; MUL*
22    (GETVALUE 1)                        ; ANS
24    (CONS)
25    (SETVALUE 1)                        ; ANS
27    (GETVALUE&PUSH 0)                   ; C
29    (LOAD&CONS&STORE 3)
31    (LOAD&PUSH 7)
32    (CONST&PUSH 5)                      ; -1
33    (CALL2&PUSH 6)                      ; ADD*
35    (PUSH-UNBOUND 1)
37    (CALLS2 143)                        ; GENSYM
39    (SETVALUE 0)                        ; C
41    (POP&STORE 7)
43    L43
43    (LOAD&PUSH 7)
44    (CALLS2&JMPIFNOT 145 L13)           ; ZEROP
47    (GETVALUE&PUSH 1)                   ; ANS
49    (NIL&PUSH)
50    (CALL2&PUSH 7)                      ; ADDN
52    (LOAD 4)
53    (CONS)
54    (UNBIND1)
55    (SKIP 1)
57    (UNBIND1)
58    (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPECIAL *FAILFLAG *LHFLAG ...))-136|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN %E-INTEGER-COEFF (EXP) ...)-137|
(CONST 0) = %E-INTEGER-COEFF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE %E-INTEGER-COEFF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; %E-INTEGER-COEFF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; %E-INTEGER-COEFF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE %E-INTEGER-COEFF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; %E-INTEGER-COEFF
8     (SKIP&RET 1)


Disassembly of function %E-INTEGER-COEFF
(CONST 0) = EXP
(CONST 1) = MAPATOM
(CONST 2) = MEXPTP
(CONST 3) = $%E
(CONST 4) = VAR
(CONST 5) = $COEFF
(CONST 6) = $INTEGER
(CONST 7) = ASK-INTEGER
(CONST 8) = $YES
(CONST 9) = %E-INTEGER-COEFF
(CONST 10) = ANDMAPC
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
33 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&JMPIF 1 L44)                 ; MAPATOM
8     (GETVALUE&PUSH 0)                   ; EXP
10    (CALL1&JMPIFNOT 2 L35)              ; MEXPTP
13    (GETVALUE 0)                        ; EXP
15    (CDR)
16    (CAR&PUSH)
17    (JMPIFNOTEQTO 3 L35)                ; $%E
20    (GETVALUE 0)                        ; EXP
22    (CDR)
23    (CDR)
24    (CAR&PUSH)
25    (GETVALUE&PUSH 4)                   ; VAR
27    (CALL2&PUSH 5)                      ; $COEFF
29    (CONST&PUSH 6)                      ; $INTEGER
30    (CALL2&PUSH 7)                      ; ASK-INTEGER
32    (JMPIFEQTO 8 L47)                   ; $YES
35    L35
35    (CONST&PUSH 9)                      ; %E-INTEGER-COEFF
36    (GETVALUE 0)                        ; EXP
38    (CDR&PUSH)
39    (CALL2 10)                          ; ANDMAPC
41    L41
41    (UNBIND1)
42    (SKIP&RET 2)
44    L44
44    (T)
45    (JMP L41)
47    L47
47    (T)
48    (JMP L41)


Disassembly of function #:|(DEFUN WLINEARPOLY (E VAR) ...)-138|
(CONST 0) = WLINEARPOLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE WLINEARPOLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; WLINEARPOLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; WLINEARPOLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE WLINEARPOLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; WLINEARPOLY
8     (SKIP&RET 1)


Disassembly of function WLINEARPOLY
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = POLYINX
(CONST 3) = DEG
(CONST 4) = 1
(CONST 5) = SUBIN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
writes special variable : (E)
23 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; E
8     (GETVALUE&PUSH 1)                   ; VAR
10    (T&PUSH)
11    (CALL 3 2)                          ; POLYINX
14    (SETVALUE 0)                        ; E
16    (JMPIFNOT L24)
18    (PUSH)
19    (CALL1&PUSH 3)                      ; DEG
21    (JMPIFEQTO 4 L29)                   ; 1
24    L24
24    (NIL)
25    L25
25    (UNBIND 2)
27    (SKIP&RET 3)
29    L29
29    (CONST&PUSH 4)                      ; 1
30    (GETVALUE&PUSH 0)                   ; E
32    (CALL2 5)                           ; SUBIN
34    (JMP L25)


Disassembly of function #:|(DECLARE-TOP (SPECIAL E $EXPONENTIALIZE))-139|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN PIN%EX (EXP) ...)-140|
(CONST 0) = PIN%EX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PIN%EX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PIN%EX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PIN%EX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PIN%EX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PIN%EX
8     (SKIP&RET 1)


Disassembly of function PIN%EX
(CONST 0) = EXP
(CONST 1) = (%SINH %COSH %TANH)
(CONST 2) = NOTINVOLVE
(CONST 3) = $EXPONENTIALIZE
(CONST 4) = $EXPAND
(CONST 5) = PIN%EX0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
writes special variable : (EXP)
19 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CONST&PUSH 1)                      ; (%SINH %COSH %TANH)
6     (CALL2&JMPIF 2 L25)                 ; NOTINVOLVE
9     (T)
10    (BIND 3)                            ; $EXPONENTIALIZE
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CALL1 4)                           ; $EXPAND
16    (UNBIND1)
17    (SETVALUE 0)                        ; EXP
19    L19
19    (PUSH)
20    (CALL1 5)                           ; PIN%EX0
22    (UNBIND1)
23    (SKIP&RET 2)
25    L25
25    (GETVALUE 0)                        ; EXP
27    (JMP L19)


Disassembly of function #:|(DEFUN PIN%EX0 (E) ...)-141|
(CONST 0) = PIN%EX0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PIN%EX0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PIN%EX0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PIN%EX0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PIN%EX0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PIN%EX0
8     (SKIP&RET 1)


Disassembly of function PIN%EX0
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = PIN%EX
(CONST 4) = MEXPTP
(CONST 5) = $%E
(CONST 6) = Z*
(CONST 7) = WLINEARPOLY
(CONST 8) = 0
(CONST 9) = SUBIN
(CONST 10) = POWER
(CONST 11) = MUL*
(CONST 12) = MTIMESP
(CONST 13) = PIN%EX0
(CONST 14) = MULN
(CONST 15) = MPLUSP
(CONST 16) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR)
80 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAR
5     (GETVALUE&PUSH 0)                   ; E
7     (CALL2&JMPIFNOT 2 L42)              ; AMONG
10    (GETVALUE 0)                        ; E
12    (JMPIFATOM L47)
14    (GETVALUE&PUSH 0)                   ; E
16    (CALL1&JMPIFNOT 4 L26)              ; MEXPTP
19    (GETVALUE 0)                        ; E
21    (CDR)
22    (CAR&PUSH)
23    (JMPIFEQTO 5 L71)                   ; $%E
26    L26
26    (GETVALUE&PUSH 0)                   ; E
28    (CALL1&JMPIF 12 L99)                ; MTIMESP
32    (GETVALUE&PUSH 0)                   ; E
34    (CALL1&JMPIF 15 L112)               ; MPLUSP
38    (CONST 3)                           ; PIN%EX
39    L39
39    (PUSH)
40    (NIL)
41    (THROW)
42    L42
42    (GETVALUE 0)                        ; E
44    (JMP L123)
47    L47
47    (CONST 3)                           ; PIN%EX
48    (JMP L39)
50    L50
50    (CONST 6)                           ; Z*
51    (JMP L123)
54    L54
54    (CONST&PUSH 8)                      ; 0
55    (GETVALUE&PUSH 0)                   ; E
57    (CALL2&PUSH 9)                      ; SUBIN
59    (CONST&PUSH 6)                      ; Z*
60    (LOAD&PUSH 2)
61    (CALL2&PUSH 10)                     ; POWER
63    (CALL2 11)                          ; MUL*
65    (SKIP 1)
67    (JMPIF1 L123)
69    (JMP L96)
71    L71
71    (GETVALUE 0)                        ; E
73    (CDR)
74    (CDR)
75    (CAR&PUSH)
76    (GETVALUE 1)                        ; VAR
78    (JMPIFEQ L50)
80    (GETVALUE 0)                        ; E
82    (CDR)
83    (CDR)
84    (CAR&PUSH)
85    (GETVALUE&PUSH 1)                   ; VAR
87    (CALL2&PUSH 7)                      ; WLINEARPOLY
89    (LOAD&JMPIF 0 L54)
92    (SKIP 1)
94    (JMPIF1 L123)
96    L96
96    (CONST 3)                           ; PIN%EX
97    (JMP L39)
99    L99
99    (CONST&SYMBOL-FUNCTION&PUSH 13)     ; PIN%EX0
101   (GETVALUE 0)                        ; E
103   (CDR&PUSH)
104   (CALLSR&PUSH 0 22)                  ; MAPCAR
107   (NIL&PUSH)
108   (CALL2 14)                          ; MULN
110   (JMP L123)
112   L112
112   (CONST&SYMBOL-FUNCTION&PUSH 13)     ; PIN%EX0
114   (GETVALUE 0)                        ; E
116   (CDR&PUSH)
117   (CALLSR&PUSH 0 22)                  ; MAPCAR
120   (NIL&PUSH)
121   (CALL2 16)                          ; ADDN
123   L123
123   (UNBIND1)
124   (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (UNSPECIAL E))-142|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN P*PIN%EX (ND*) ...)-143|
(CONST 0) = P*PIN%EX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE P*PIN%EX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; P*PIN%EX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; P*PIN%EX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE P*PIN%EX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; P*PIN%EX
8     (SKIP&RET 1)


Disassembly of function P*PIN%EX
(CONST 0) = ND*
(CONST 1) = $FACTOR
(CONST 2) = VAR
(CONST 3) = POLYINX
(CONST 4) = P*
(CONST 5) = PIN%EX
(CONST 6) = PE*
(CONST 7) = MTIMESP
(CONST 8) = P*PIN%EX
(CONST 9) = ANDMAPCAR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (P* PE* VAR ND*)
writes special variables : (P* PE* ND*)
45 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ND*
3     (GETVALUE&PUSH 0)                   ; ND*
5     (CALL1 1)                           ; $FACTOR
7     (SETVALUE 0)                        ; ND*
9     (PUSH)
10    (GETVALUE&PUSH 2)                   ; VAR
12    (NIL&PUSH)
13    (CALL 3 3)                          ; POLYINX
16    (JMPIF L38)
18    (CONST 5)                           ; PIN%EX
19    (CATCH-OPEN L57)
21    (GETVALUE&PUSH 0)                   ; ND*
23    (CALL1 5)                           ; PIN%EX
25    (CATCH-CLOSE)
26    (JMPIFNOT L59)
28    L28
28    (GETVALUE&PUSH 0)                   ; ND*
30    (GETVALUE 6)                        ; PE*
32    (CONS)
33    (SETVALUE 6)                        ; PE*
35    (T)
36    (JMP L65)
38    L38
38    (GETVALUE&PUSH 0)                   ; ND*
40    (GETVALUE 4)                        ; P*
42    (CONS)
43    (SETVALUE 4)                        ; P*
45    (T)
46    (JMP L65)
48    L48
48    (CONST&SYMBOL-FUNCTION&PUSH 8)      ; P*PIN%EX
50    (GETVALUE 0)                        ; ND*
52    (CDR&PUSH)
53    (CALL2 9)                           ; ANDMAPCAR
55    (JMP L65)
57    L57
57    (JMPIF L28)
59    L59
59    (GETVALUE&PUSH 0)                   ; ND*
61    (CALL1&JMPIF 7 L48)                 ; MTIMESP
64    (NIL)
65    L65
65    (UNBIND1)
66    (SKIP&RET 2)


Disassembly of function #:|(DEFUN FINDSUB (P) ...)-144|
(CONST 0) = FINDSUB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FINDSUB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FINDSUB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FINDSUB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FINDSUB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FINDSUB
8     (SKIP&RET 1)


Disassembly of function FINDSUB
(CONST 0) = P
(CONST 1) = FINDP
(CONST 2) = BX**N
(CONST 3) = ND*
(CONST 4) = VAR
(CONST 5) = POWER
(CONST 6) = BX**N+A
(CONST 7) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ND* VAR P)
writes special variables : (P ND*)
36 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; P
3     (GETVALUE&PUSH 0)                   ; P
5     (CALL1&JMPIF 1 L28)                 ; FINDP
8     (GETVALUE&PUSH 0)                   ; P
10    (CALL1 2)                           ; BX**N
12    (SETVALUE 3)                        ; ND*
14    (JMPIF L31)
16    (GETVALUE&PUSH 0)                   ; P
18    (CALL1 6)                           ; BX**N+A
20    (SETVALUE 0)                        ; P
22    (JMPIF L40)
24    (NIL)
25    L25
25    (UNBIND1)
26    (SKIP&RET 2)
28    L28
28    (NIL)
29    (JMP L25)
31    L31
31    (GETVALUE&PUSH 4)                   ; VAR
33    (GETVALUE 3)                        ; ND*
35    (CAR&PUSH)
36    (CALL2 5)                           ; POWER
38    (JMP L25)
40    L40
40    (CDR)
41    (CDR)
42    (CAR&PUSH)
43    (GETVALUE&PUSH 4)                   ; VAR
45    (GETVALUE 0)                        ; P
47    (CDR)
48    (CAR&PUSH)
49    (CALL2&PUSH 5)                      ; POWER
51    (CALL2 7)                           ; MUL*
53    (JMP L25)


Disassembly of function #:|(DEFUN FUNCLOGOR%E (E) ...)-145|
(CONST 0) = FUNCLOGOR%E
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FUNCLOGOR%E>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FUNCLOGOR%E
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FUNCLOGOR%E
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FUNCLOGOR%E>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FUNCLOGOR%E
8     (SKIP&RET 1)


Disassembly of function FUNCLOGOR%E
(CONST 0) = E
(CONST 1) = ANS
(CONST 2) = ARG
(CONST 3) = NVAR
(CONST 4) = R
(CONST 5) = VAR
(CONST 6) = RATP
(CONST 7) = (%SIN %COS %TAN)
(CONST 8) = INVOLVE
(CONST 9) = (%LOG)
(CONST 10) = %LOG
(CONST 11) = %EINVOLVE
(CONST 12) = XOR
(CONST 13) = (%LOG)
(CONST 14) = $%E
(CONST 15) = POWER
(CONST 16) = YX
(CONST 17) = -1
(CONST 18) = MAXIMA-SUBSTITUTE
(CONST 19) = AMONG
(CONST 20) = FINDSUB
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS NVAR ARG R VAR E)
writes special variables : (ANS NVAR R ARG)
80 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; ANS
6     (NIL)
7     (BIND 2)                            ; ARG
9     (NIL)
10    (BIND 3)                            ; NVAR
12    (NIL)
13    (BIND 4)                            ; R
15    (GETVALUE&PUSH 0)                   ; E
17    (GETVALUE&PUSH 5)                   ; VAR
19    (CALL2&JMPIF 6 L106)                ; RATP
23    (GETVALUE&PUSH 0)                   ; E
25    (CONST&PUSH 7)                      ; (%SIN %COS %TAN)
26    (CALL2&JMPIF 8 L106)                ; INVOLVE
30    (GETVALUE&PUSH 0)                   ; E
32    (CONST&PUSH 9)                      ; (%LOG)
33    (CALL2 8)                           ; INVOLVE
35    (SETVALUE 2)                        ; ARG
37    (JMPIFNOT L42)
39    (CONST 10)                          ; %LOG
40    (SETVALUE 4)                        ; R
42    L42
42    (PUSH)
43    (GETVALUE&PUSH 0)                   ; E
45    (CALL1&PUSH 11)                     ; %EINVOLVE
47    (CALL2 12)                          ; XOR
49    (SETVALUE 2)                        ; ARG
51    (JMPIFNOT L106)
53    L53
53    (GETVALUE&PUSH 4)                   ; R
55    (JMPIFEQTO 10 L112)                 ; %LOG
58    (CONST&PUSH 14)                     ; $%E
59    (GETVALUE&PUSH 2)                   ; ARG
61    (CALL2 15)                          ; POWER
63    L63
63    (SETVALUE 3)                        ; NVAR
65    (CONST&PUSH 16)                     ; YX
66    (CONST&PUSH 17)                     ; -1
67    (CALL2&PUSH 15)                     ; POWER
69    (GETVALUE&PUSH 3)                   ; NVAR
71    (CONST&PUSH 17)                     ; -1
72    (CALL2&PUSH 15)                     ; POWER
74    (CONST&PUSH 16)                     ; YX
75    (GETVALUE&PUSH 3)                   ; NVAR
77    (GETVALUE&PUSH 0)                   ; E
79    (CALL&PUSH 3 18)                    ; MAXIMA-SUBSTITUTE
82    (CALL 3 18)                         ; MAXIMA-SUBSTITUTE
85    (SETVALUE 1)                        ; ANS
87    (GETVALUE&PUSH 5)                   ; VAR
89    (GETVALUE&PUSH 1)                   ; ANS
91    (CALL2&JMPIFNOT 19 L119)            ; AMONG
94    (GETVALUE 4)                        ; R
96    (JMPIF L106)
98    (GETVALUE&PUSH 2)                   ; ARG
100   (CALL1 20)                          ; FINDSUB
102   (SETVALUE 2)                        ; ARG
104   (JMPIF L53)
106   L106
106   (NIL)
107   (UNBIND 4)
109   L109
109   (UNBIND1)
110   (SKIP&RET 2)
112   L112
112   (CONST&PUSH 13)                     ; (%LOG)
113   (GETVALUE&PUSH 2)                   ; ARG
115   (LIST 2)
117   (JMP L63)
119   L119
119   (GETVALUE&PUSH 5)                   ; VAR
121   (CONST&PUSH 16)                     ; YX
122   (GETVALUE&PUSH 1)                   ; ANS
124   (PUSH-UNBOUND 3)
126   (CALLS1&PUSH 172)                   ; SUBST
128   (GETVALUE&PUSH 3)                   ; NVAR
130   (LIST 2)
132   (UNBIND 4)
134   (JMP L109)


Disassembly of function #:|(DEFUN DINTBYPART (U V A ...) ...)-146|
(CONST 0) = DINTBYPART
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DINTBYPART>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DINTBYPART
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DINTBYPART
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DINTBYPART>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DINTBYPART
8     (SKIP&RET 1)


Disassembly of function DINTBYPART
(CONST 0) = V
(CONST 1) = A
(CONST 2) = B
(CONST 3) = ANTIDERIV
(CONST 4) = (%LOG)
(CONST 5) = INVOLVE
(CONST 6) = MUL*
(CONST 7) = VAR
(CONST 8) = SDIFF
(CONST 9) = $MINUS
(CONST 10) = GET-LIMIT
(CONST 11) = $PLUS
(CONST 12) = *DEF2*
(CONST 13) = DEFINT
(CONST 14) = -1
(CONST 15) = ADD*
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A B VAR V)
66 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; V
3     (LOAD 5)
4     (BIND 1)                            ; A
6     (LOAD 7)
7     (BIND 2)                            ; B
9     (GETVALUE&PUSH 0)                   ; V
11    (CALL1&PUSH 3)                      ; ANTIDERIV
13    (LOAD&JMPIFNOT 0 L83)
17    (LOAD&PUSH 0)
18    (CONST&PUSH 4)                      ; (%LOG)
19    (CALL2&JMPIF 5 L83)                 ; INVOLVE
22    (LOAD&PUSH 14)
23    (LOAD&PUSH 1)
24    (CALL2&PUSH 6)                      ; MUL*
26    (LOAD&PUSH 1)
27    (LOAD&PUSH 16)
28    (GETVALUE&PUSH 7)                   ; VAR
30    (CALL2&PUSH 8)                      ; SDIFF
32    (CALL2&PUSH 6)                      ; MUL*
34    (LOAD&PUSH 1)
35    (GETVALUE&PUSH 7)                   ; VAR
37    (GETVALUE&PUSH 2)                   ; B
39    (CONST&PUSH 9)                      ; $MINUS
40    (CALL&PUSH 4 10)                    ; GET-LIMIT
43    (LOAD&PUSH 2)
44    (GETVALUE&PUSH 7)                   ; VAR
46    (GETVALUE&PUSH 1)                   ; A
48    (CONST&PUSH 11)                     ; $PLUS
49    (CALL&PUSH 4 10)                    ; GET-LIMIT
52    (LOAD&JMPIFNOT 1 L88)
55    (LOAD&JMPIFNOT 0 L88)
58    (T)
59    (BIND 12)                           ; *DEF2*
61    (LOAD&PUSH 5)
62    (GETVALUE&PUSH 7)                   ; VAR
64    (GETVALUE&PUSH 1)                   ; A
66    (GETVALUE&PUSH 2)                   ; B
68    (CALL 4 13)                         ; DEFINT
71    (UNBIND1)
72    (PUSH)
73    (LOAD&JMPIF 0 L93)
76    (NIL)
77    (SKIP 6)
79    L79
79    (UNBIND 3)
81    (SKIP&RET 5)
83    L83
83    (NIL)
84    (SKIP 1)
86    (JMP L79)
88    L88
88    (NIL)
89    (SKIP 5)
91    (JMP L79)
93    L93
93    (LOAD&PUSH 2)
94    (CONST&PUSH 14)                     ; -1
95    (LOAD&PUSH 3)
96    (CALL2&PUSH 6)                      ; MUL*
98    (CONST&PUSH 14)                     ; -1
99    (LOAD&PUSH 3)
100   (CALL2&PUSH 6)                      ; MUL*
102   (CALL 3 15)                         ; ADD*
105   (SKIP 6)
107   (JMP L79)


Disassembly of function #:|(DEFUN DINTEXP (EXP ARG &AUX ...) ...)-147|
(CONST 0) = DINTEXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DINTEXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DINTEXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DINTEXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DINTEXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DINTEXP
8     (SKIP&RET 1)


Disassembly of function DINTEXP
(CONST 0) = EXP
(CONST 1) = ARG
(CONST 2) = ANS
(CONST 3) = DINTEXP-RECUR
(CONST 4) = VAR
(CONST 5) = SININTP
(CONST 6) = ANTIDERIV
(CONST 7) = LL
(CONST 8) = UL
(CONST 9) = INTSUBS
(CONST 10) = FUNCLOGOR%E
(CONST 11) = 0
(CONST 12) = $INF
(CONST 13) = 1
(CONST 14) = ADD
(CONST 15) = SUBIN
(CONST 16) = -1
(CONST 17) = INTCV
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS ARG UL LL VAR EXP)
writes special variables : (EXP ANS)
69 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; ARG
6     (NIL)
7     (BIND 2)                            ; ANS
9     (T)
10    (BIND 3)                            ; DINTEXP-RECUR
12    (GETVALUE&PUSH 0)                   ; EXP
14    (GETVALUE&PUSH 4)                   ; VAR
16    (CALL2&JMPIFNOT 5 L40)              ; SININTP
19    (GETVALUE&PUSH 0)                   ; EXP
21    (CALL1 6)                           ; ANTIDERIV
23    (SETVALUE 2)                        ; ANS
25    (JMPIFNOT L40)
27    (PUSH)
28    (GETVALUE&PUSH 7)                   ; LL
30    (GETVALUE&PUSH 8)                   ; UL
32    (CALL 3 9)                          ; INTSUBS
35    (SETVALUE 2)                        ; ANS
37    (JMPIF1 L106)
40    L40
40    (GETVALUE&PUSH 0)                   ; EXP
42    (CALL1 10)                          ; FUNCLOGOR%E
44    (SETVALUE 2)                        ; ANS
46    (JMPIF L75)
48    (NIL)
49    (UNBIND1)
50    (JMP L107)
52    L52
52    (CONST&PUSH 13)                     ; 1
53    (GETVALUE&PUSH 1)                   ; ARG
55    (CALL2&PUSH 14)                     ; ADD
57    (GETVALUE 2)                        ; ANS
59    (CAR&PUSH)
60    (CALL2 15)                          ; SUBIN
62    (SETVALUE 0)                        ; EXP
64    (CONST&PUSH 16)                     ; -1
65    (GETVALUE 2)                        ; ANS
67    (CDR)
68    (CAR&PUSH)
69    (CALL2 14)                          ; ADD
71    (SETVALUE 2)                        ; ANS
73    (JMP L96)
75    L75
75    (GETVALUE&PUSH 7)                   ; LL
77    (JMPIFNOTEQTO 11 L85)               ; 0
80    (GETVALUE&PUSH 8)                   ; UL
82    (JMPIFEQTO 12 L52)                  ; $INF
85    L85
85    (GETVALUE 2)                        ; ANS
87    (CAR)
88    (SETVALUE 0)                        ; EXP
90    (GETVALUE 2)                        ; ANS
92    (CDR)
93    (CAR)
94    (SETVALUE 2)                        ; ANS
96    L96
96    (GETVALUE&PUSH 2)                   ; ANS
98    (T&PUSH)
99    (NIL&PUSH)
100   (CALL 3 17)                         ; INTCV
103   (UNBIND1)
104   (JMP L107)
106   L106
106   (UNBIND1)
107   L107
107   (UNBIND 3)
109   (SKIP&RET 3)


Disassembly of function #:|(DEFUN DINTLOG (EXP ARG) ...)-148|
(CONST 0) = DINTLOG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DINTLOG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DINTLOG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DINTLOG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DINTLOG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DINTLOG
8     (SKIP&RET 1)


Disassembly of function DINTLOG
(CONST 0) = EXP
(CONST 1) = ARG
(CONST 2) = DINTLOG-RECUR
(CONST 3) = ANS
(CONST 4) = D
(CONST 5) = UL
(CONST 6) = $INF
(CONST 7) = LL
(CONST 8) = 0
(CONST 9) = VAR
(CONST 10) = -1
(CONST 11) = POWER
(CONST 12) = SUBIN
(CONST 13) = MUL*
(CONST 14) = -2
(CONST 15) = DIV*
(CONST 16) = $RATSIMP
(CONST 17) = 1
(CONST 18) = ANTIDERIV
(CONST 19) = INTSUBS
(CONST 20) = LOGX1
(CONST 21) = (%LOG)
(CONST 22) = (%LOG)
(CONST 23) = INVOLVE
(CONST 24) = NO-ERR-SUB
(CONST 25) = *DEF2*
(CONST 26) = *Z*
(CONST 27) = DEFINT
(CONST 28) = DERIVAT
(CONST 29) = (%LOG)
(CONST 30) = DINTBYPART
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D ANS EXP VAR ARG LL UL DINTLOG-RECUR)
writes special variables : (D ANS)
107 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; ARG
6     (GETVALUE&PUSH 2)                   ; DINTLOG-RECUR
8     (CALLS2 150)                        ; 1+
10    (BIND 2)                            ; DINTLOG-RECUR
12    (NIL)
13    (BIND 3)                            ; ANS
15    (NIL)
16    (BIND 4)                            ; D
18    (GETVALUE&PUSH 5)                   ; UL
20    (JMPIFNOTEQTO 6 L63)                ; $INF
23    (GETVALUE&PUSH 7)                   ; LL
25    (JMPIFNOTEQTO 8 L63)                ; 0
28    (GETVALUE&PUSH 1)                   ; ARG
30    (GETVALUE 9)                        ; VAR
32    (JMPIFNOTEQ L63)
34    (GETVALUE&PUSH 0)                   ; EXP
36    (CONST&PUSH 10)                     ; -1
37    (GETVALUE&PUSH 9)                   ; VAR
39    (CONST&PUSH 10)                     ; -1
40    (CALL2&PUSH 11)                     ; POWER
42    (GETVALUE&PUSH 0)                   ; EXP
44    (CALL2&PUSH 12)                     ; SUBIN
46    (CALL2&PUSH 13)                     ; MUL*
48    (GETVALUE&PUSH 9)                   ; VAR
50    (CONST&PUSH 14)                     ; -2
51    (CALL2&PUSH 11)                     ; POWER
53    (CALL2&PUSH 13)                     ; MUL*
55    (CALL2&PUSH 15)                     ; DIV*
57    (CALL1&PUSH 16)                     ; $RATSIMP
59    (JMPIFEQTO 17 L166)                 ; 1
63    L63
63    (GETVALUE&PUSH 0)                   ; EXP
65    (CALL1 18)                          ; ANTIDERIV
67    (SETVALUE 3)                        ; ANS
69    (JMPIF L169)
72    (GETVALUE&PUSH 0)                   ; EXP
74    (GETVALUE&PUSH 7)                   ; LL
76    (GETVALUE&PUSH 5)                   ; UL
78    (CALL 3 20)                         ; LOGX1
81    (SETVALUE 3)                        ; ANS
83    (JMPIF L162)
86    (GETVALUE&PUSH 0)                   ; EXP
88    (CONST&PUSH 21)                     ; (%LOG)
89    (GETVALUE&PUSH 1)                   ; ARG
91    (LIST&PUSH 2)
93    (CALL2 15)                          ; DIV*
95    (SETVALUE 3)                        ; ANS
97    (PUSH)
98    (CONST&PUSH 22)                     ; (%LOG)
99    (CALL2&JMPIF 23 L179)               ; INVOLVE
103   (GETVALUE&PUSH 1)                   ; ARG
105   (GETVALUE 9)                        ; VAR
107   (JMPIFNOTEQ L143)
109   (CONST&PUSH 8)                      ; 0
110   (GETVALUE&PUSH 3)                   ; ANS
112   (CALL2&PUSH 24)                     ; NO-ERR-SUB
114   (JMPIFNOTEQTO 8 L143)               ; 0
117   (T)
118   (BIND 25)                           ; *DEF2*
120   (GETVALUE&PUSH 3)                   ; ANS
122   (GETVALUE&PUSH 9)                   ; VAR
124   (CONST&PUSH 26)                     ; *Z*
125   (CALL2&PUSH 11)                     ; POWER
127   (CALL2&PUSH 13)                     ; MUL*
129   (GETVALUE&PUSH 9)                   ; VAR
131   (GETVALUE&PUSH 7)                   ; LL
133   (GETVALUE&PUSH 5)                   ; UL
135   (CALL 4 27)                         ; DEFINT
138   (UNBIND1)
139   (SETVALUE 4)                        ; D
141   (JMPIF L182)
143   L143
143   (CONST&PUSH 29)                     ; (%LOG)
144   (GETVALUE&PUSH 1)                   ; ARG
146   (LIST&PUSH 2)
148   (GETVALUE&PUSH 3)                   ; ANS
150   (GETVALUE&PUSH 7)                   ; LL
152   (GETVALUE&PUSH 5)                   ; UL
154   (CALL 4 30)                         ; DINTBYPART
157   (SETVALUE 3)                        ; ANS
159   (JMPIF L162)
161   (NIL)
162   L162
162   (UNBIND 5)
164   (SKIP&RET 3)
166   L166
166   (CONST 8)                           ; 0
167   (JMP L162)
169   L169
169   (PUSH)
170   (GETVALUE&PUSH 7)                   ; LL
172   (GETVALUE&PUSH 5)                   ; UL
174   (CALL 3 19)                         ; INTSUBS
177   (JMP L162)
179   L179
179   (NIL)
180   (JMP L162)
182   L182
182   (CONST&PUSH 26)                     ; *Z*
183   (CONST&PUSH 17)                     ; 1
184   (GETVALUE&PUSH 4)                   ; D
186   (CONST&PUSH 8)                      ; 0
187   (CALL 4 28)                         ; DERIVAT
190   (JMP L162)


Disassembly of function #:|(DEFUN DERIVAT (VAR N E ...) ...)-149|
(CONST 0) = DERIVAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DERIVAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DERIVAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DERIVAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DERIVAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DERIVAT
8     (SKIP&RET 1)


Disassembly of function DERIVAT
(CONST 0) = VAR
(CONST 1) = N
(CONST 2) = E
(CONST 3) = $DIFF
(CONST 4) = SUBIN
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N VAR E)
16 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; VAR
3     (LOAD 6)
4     (BIND 1)                            ; N
6     (LOAD 8)
7     (BIND 2)                            ; E
9     (LOAD&PUSH 10)
10    (CONST&PUSH 3)                      ; $DIFF
11    (GETVALUE&PUSH 2)                   ; E
13    (GETVALUE&PUSH 0)                   ; VAR
15    (GETVALUE&PUSH 1)                   ; N
17    (LIST 3)
19    (APPLY&PUSH 0)
21    (CALL2 4)                           ; SUBIN
23    (UNBIND 3)
25    (SKIP&RET 5)


Disassembly of function #:|(DEFUN MAYBPC (E VAR) ...)-150|
(CONST 0) = MAYBPC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAYBPC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAYBPC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAYBPC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAYBPC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAYBPC
8     (SKIP&RET 1)


Disassembly of function MAYBPC
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = MTOINF*
(CONST 3) = GGRM
(CONST 4) = LINPOWER0
(CONST 5) = BX**N+A
(CONST 6) = $%I
(CONST 7) = AMONG
(CONST 8) = $REALPART
(CONST 9) = ZEROP1
(CONST 10) = $IMAGPART
(CONST 11) = ZN
(CONST 12) = $ASKSIGN
(CONST 13) = $POS
(CONST 14) = $NEG
(CONST 15) = -1
(CONST 16) = MUL*
(CONST 17) = 1
(CONST 18) = $%E
(CONST 19) = $%PI
(CONST 20) = ND*
(CONST 21) = ADD
(CONST 22) = 2
(CONST 23) = MUL
(CONST 24) = DIV*
(CONST 25) = POWER
(CONST 26) = ZD
(CONST 27) = $ZERO
(CONST 28) = 0
(CONST 29) = RATGREATERP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ND* ZN VAR E MTOINF*)
writes special variables : (ZD VAR ZN E)
122 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 2)                        ; MTOINF*
8     (JMPIF L125)
11    (GETVALUE 2)                        ; MTOINF*
13    (JMPIF L24)
15    (GETVALUE&PUSH 0)                   ; E
17    (CALL1 5)                           ; BX**N+A
19    (SETVALUE 0)                        ; E
21    (JMPIFNOT L133)
24    L24
24    (CONST&PUSH 6)                      ; $%I
25    (GETVALUE 0)                        ; E
27    (CDR)
28    (CDR)
29    (CAR&PUSH)
30    (CALL2&JMPIFNOT 7 L64)              ; AMONG
33    (GETVALUE 0)                        ; E
35    (CDR)
36    (CDR)
37    (CAR&PUSH)
38    (CALL1&PUSH 8)                      ; $REALPART
40    (CALL1&JMPIFNOT 9 L64)              ; ZEROP1
43    (GETVALUE 0)                        ; E
45    (CDR)
46    (CDR)
47    (CAR&PUSH)
48    (CALL1 10)                          ; $IMAGPART
50    (SETVALUE 11)                       ; ZN
52    (JMPIFNOT L64)
54    (GETVALUE 0)                        ; E
56    (CDR)
57    (CAR&PUSH)
58    (CALL1&PUSH 12)                     ; $ASKSIGN
60    (JMPIFEQTO 13 L148)                 ; $POS
64    L64
64    (GETVALUE 0)                        ; E
66    (CDR)
67    (CDR)
68    (CAR&PUSH)
69    (CALL1&PUSH 8)                      ; $REALPART
71    (CALL1 12)                          ; $ASKSIGN
73    (SETVALUE 1)                        ; VAR
75    (PUSH)
76    (JMPIFEQTO 14 L85)                  ; $NEG
79    (GETVALUE&PUSH 1)                   ; VAR
81    (JMPIFNOTEQTO 27 L189)              ; $ZERO
85    L85
85    (GETVALUE 0)                        ; E
87    (CDR)
88    (CAR&PUSH)
89    (CALL1&PUSH 10)                     ; $IMAGPART
91    (JMPIFNOTEQTO 28 L189)              ; 0
95    (GETVALUE 0)                        ; E
97    (CDR)
98    (CAR&PUSH)
99    (CONST&PUSH 28)                     ; 0
100   (CALL2&JMPIFNOT 29 L189)            ; RATGREATERP
104   (CONST&PUSH 15)                     ; -1
105   (GETVALUE 0)                        ; E
107   (CDR)
108   (CDR)
109   (CAR&PUSH)
110   (CALL2 16)                          ; MUL*
112   L112
112   (PUSH)
113   (GETVALUE 0)                        ; E
115   (CDR)
116   (CAR&PUSH)
117   (GETVALUE 0)                        ; E
119   (CAR&PUSH)
120   (LIST 3)
122   (JMP L190)
125   L125
125   (CONST&PUSH 3)                      ; GGRM
126   (GETVALUE&PUSH 0)                   ; E
128   (GETVALUE&PUSH 1)                   ; VAR
130   (CALL2 4)                           ; LINPOWER0
132   (THROW)
133   L133
133   (NIL)
134   (JMP L190)
136   L136
136   (CONST 15)                          ; -1
137   (SETVALUE 1)                        ; VAR
139   (PUSH)
140   (GETVALUE&PUSH 11)                  ; ZN
142   (CALL2 16)                          ; MUL*
144   (SETVALUE 11)                       ; ZN
146   (JMP L158)
148   L148
148   (GETVALUE&PUSH 11)                  ; ZN
150   (CALL1&PUSH 12)                     ; $ASKSIGN
152   (JMPIFEQTO 14 L136)                 ; $NEG
155   (CONST 17)                          ; 1
156   (SETVALUE 1)                        ; VAR
158   L158
158   (CONST&PUSH 18)                     ; $%E
159   (GETVALUE&PUSH 1)                   ; VAR
161   (CONST&PUSH 6)                      ; $%I
162   (CONST&PUSH 19)                     ; $%PI
163   (CONST&PUSH 17)                     ; 1
164   (GETVALUE&PUSH 20)                  ; ND*
166   (CALL2&PUSH 21)                     ; ADD
168   (CALL&PUSH 4 16)                    ; MUL*
171   (CONST&PUSH 22)                     ; 2
172   (GETVALUE 0)                        ; E
174   (CDR)
175   (CAR&PUSH)
176   (CALL2&PUSH 23)                     ; MUL
178   (CALL2&PUSH 24)                     ; DIV*
180   (CALL2 25)                          ; POWER
182   (SETVALUE 26)                       ; ZD
184   (GETVALUE 11)                       ; ZN
186   (JMP L112)
189   L189
189   (NIL)
190   L190
190   (UNBIND 2)
192   (SKIP&RET 3)


Disassembly of function #:|(DEFUN GGR (E IND) ...)-151|
(CONST 0) = GGR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GGR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GGR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GGR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GGR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GGR
8     (SKIP&RET 1)


Disassembly of function GGR
(CONST 0) = E
(CONST 1) = IND
(CONST 2) = C
(CONST 3) = ZD
(CONST 4) = ZN
(CONST 5) = NN*
(CONST 6) = DN*
(CONST 7) = ND*
(CONST 8) = DOSIMP
(CONST 9) = $%EMODE
(CONST 10) = 0
(CONST 11) = $EXPAND
(CONST 12) = MPLUSP
(CONST 13) = *NODIVERG
(CONST 14) = DIVERGENT
(CONST 15) = #<COMPILED-CLOSURE GGR-1>
(CONST 16) = ANDMAPCAR
(CONST 17) = (MPLUS)
(CONST 18) = SRATSIMP
(CONST 19) = RMCONST1
(CONST 20) = VAR
(CONST 21) = GGR1
(CONST 22) = GAMMA1
(CONST 23) = MUL*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C ZD VAR E IND)
writes special variables : (DOSIMP $%EMODE C E ND*)
96 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; IND
6     (NIL)
7     (BIND 2)                            ; C
9     (NIL)
10    (BIND 3)                            ; ZD
12    (NIL)
13    (BIND 4)                            ; ZN
15    (NIL)
16    (BIND 5)                            ; NN*
18    (NIL)
19    (BIND 6)                            ; DN*
21    (NIL)
22    (BIND 7)                            ; ND*
24    (NIL)
25    (BIND 8)                            ; DOSIMP
27    (NIL)
28    (BIND 9)                            ; $%EMODE
30    (CONST 10)                          ; 0
31    (SETVALUE 7)                        ; ND*
33    (GETVALUE 1)                        ; IND
35    (JMPIFNOT L70)
37    (GETVALUE&PUSH 0)                   ; E
39    (CALL1 11)                          ; $EXPAND
41    (SETVALUE 0)                        ; E
43    (PUSH)
44    (CALL1&JMPIFNOT 12 L70)             ; MPLUSP
47    (T)
48    (BIND 13)                           ; *NODIVERG
50    (CONST 14)                          ; DIVERGENT
51    (CATCH-OPEN L60)
53    (CONST&PUSH 15)                     ; #<COMPILED-CLOSURE GGR-1>
54    (GETVALUE 0)                        ; E
56    (CDR&PUSH)
57    (CALL2 16)                          ; ANDMAPCAR
59    (CATCH-CLOSE)
60    L60
60    (SETVALUE 0)                        ; E
62    (UNBIND1)
63    (JMPIFNOT L70)
65    (GETVALUE&PUSH 0)                   ; E
67    (JMPIFNOTEQTO 14 L118)              ; DIVERGENT
70    L70
70    (GETVALUE&PUSH 0)                   ; E
72    (CALL1 19)                          ; RMCONST1
74    (SETVALUE 0)                        ; E
76    (CAR)
77    (SETVALUE 2)                        ; C
79    (GETVALUE 0)                        ; E
81    (CDR)
82    (SETVALUE 0)                        ; E
84    (PUSH)
85    (GETVALUE&PUSH 20)                  ; VAR
87    (CALL2 21)                          ; GGR1
89    (SETVALUE 0)                        ; E
91    (JMPIFNOT L104)
93    (CONST&PUSH 22)                     ; GAMMA1
94    (GETVALUE 0)                        ; E
96    (APPLY 0)
98    (SETVALUE 0)                        ; E
100   (GETVALUE 3)                        ; ZD
102   (JMPIF L126)
104   L104
104   (GETVALUE 0)                        ; E
106   (JMPIFNOT L143)
108   L108
108   (GETVALUE&PUSH 2)                   ; C
110   (GETVALUE&PUSH 0)                   ; E
112   (CALL2 23)                          ; MUL*
114   L114
114   (UNBIND 8)
116   (JMP L146)
118   L118
118   (CONST&PUSH 17)                     ; (MPLUS)
119   (GETVALUE 0)                        ; E
121   (CONS&PUSH)
122   (CALL1 18)                          ; SRATSIMP
124   (JMP L114)
126   L126
126   (T)
127   (SETVALUE 9)                        ; $%EMODE
129   (SETVALUE 8)                        ; DOSIMP
131   (GETVALUE&PUSH 3)                   ; ZD
133   (GETVALUE&PUSH 0)                   ; E
135   (CALL2 23)                          ; MUL*
137   (SETVALUE 0)                        ; E
139   (GETVALUE 0)                        ; E
141   (JMPIF L108)
143   L143
143   (NIL)
144   (UNBIND 8)
146   L146
146   (UNBIND 2)
148   (SKIP&RET 3)


Disassembly of function GGR-1
(CONST 0) = GGR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
4 byte-code instructions:
0     (LOAD&PUSH 1)
1     (NIL&PUSH)
2     (CALL2 0)                           ; GGR
4     (SKIP&RET 2)


Disassembly of function #:|(DEFUN GGR1 (E VAR) ...)-152|
(CONST 0) = GGR1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GGR1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GGR1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GGR1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GGR1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GGR1
8     (SKIP&RET 1)


Disassembly of function GGR1
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = MEXPTP
(CONST 3) = $%E
(CONST 4) = MAYBPC
(CONST 5) = 0
(CONST 6) = MTIMESP
(CONST 7) = XTORTERM
(CONST 8) = DN*
(CONST 9) = $REALPART
(CONST 10) = ND*
(CONST 11) = -1
(CONST 12) = RATGREATERP
(CONST 13) = NN*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DN* NN* VAR E)
writes special variables : (E NN* ND* DN*)
93 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 0)                        ; E
8     (JMPIFATOM L116)
11    (GETVALUE&PUSH 0)                   ; E
13    (CALL1&JMPIFNOT 2 L24)              ; MEXPTP
16    (GETVALUE 0)                        ; E
18    (CDR)
19    (CAR&PUSH)
20    (JMPIFEQTO 3 L125)                  ; $%E
24    L24
24    (GETVALUE&PUSH 0)                   ; E
26    (CALL1&JMPIFNOT 6 L111)             ; MTIMESP
30    (GETVALUE 0)                        ; E
32    (CDR)
33    (CDR)
34    (CDR)
35    (JMPIF L111)
38    (GETVALUE 0)                        ; E
40    (CDR)
41    (CAR&PUSH)
42    (GETVALUE&PUSH 1)                   ; VAR
44    (CALL2 7)                           ; XTORTERM
46    (SETVALUE 8)                        ; DN*
48    (JMPIFNOT L75)
50    (PUSH)
51    (CALL1 9)                           ; $REALPART
53    (SETVALUE 10)                       ; ND*
55    (PUSH)
56    (CONST&PUSH 11)                     ; -1
57    (CALL2&JMPIFNOT 12 L75)             ; RATGREATERP
60    (GETVALUE 0)                        ; E
62    (CDR)
63    (CDR)
64    (CAR&PUSH)
65    (GETVALUE&PUSH 1)                   ; VAR
67    (JSR L0)
70    (SETVALUE 13)                       ; NN*
72    (JMPIF L141)
75    L75
75    (GETVALUE 0)                        ; E
77    (CDR)
78    (CDR)
79    (CAR&PUSH)
80    (GETVALUE&PUSH 1)                   ; VAR
82    (CALL2 7)                           ; XTORTERM
84    (SETVALUE 8)                        ; DN*
86    (JMPIFNOT L111)
88    (PUSH)
89    (CALL1 9)                           ; $REALPART
91    (SETVALUE 10)                       ; ND*
93    (PUSH)
94    (CONST&PUSH 11)                     ; -1
95    (CALL2&JMPIFNOT 12 L111)            ; RATGREATERP
98    (GETVALUE 0)                        ; E
100   (CDR)
101   (CAR&PUSH)
102   (GETVALUE&PUSH 1)                   ; VAR
104   (JSR L0)
107   (SETVALUE 13)                       ; NN*
109   (JMPIF L141)
111   L111
111   (NIL)
112   L112
112   (UNBIND 2)
114   (SKIP&RET 3)
116   L116
116   (NIL)
117   (JMP L112)
119   L119
119   (CONST&PUSH 5)                      ; 0
120   (GETVALUE 0)                        ; E
122   (CONS)
123   (JMP L112)
125   L125
125   (GETVALUE 0)                        ; E
127   (CDR)
128   (CDR)
129   (CAR&PUSH)
130   (GETVALUE&PUSH 1)                   ; VAR
132   (CALL2 4)                           ; MAYBPC
134   (SETVALUE 0)                        ; E
136   (JMPIF L119)
138   (NIL)
139   (JMP L112)
141   L141
141   (GETVALUE&PUSH 13)                  ; NN*
143   (GETVALUE&PUSH 8)                   ; DN*
145   (CALLS1 168)                        ; RPLACA
147   (JMP L112)


Disassembly of function #:|(DEFUN BX**N+A (E) ...)-153|
(CONST 0) = BX**N+A
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BX**N+A>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BX**N+A
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BX**N+A
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BX**N+A>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BX**N+A
8     (SKIP&RET 1)


Disassembly of function BX**N+A
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = 0
(CONST 3) = 1
(CONST 4) = MNUMP
(CONST 5) = NO-ERR-SUB
(CONST 6) = A
(CONST 7) = -1
(CONST 8) = MUL
(CONST 9) = ADD*
(CONST 10) = BX**N
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A VAR E)
writes special variable : (E)
46 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (GETVALUE 1)                        ; VAR
7     (JMPIFEQ L52)
9     (GETVALUE 0)                        ; E
11    (JMPIFATOM L59)
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1&JMPIF 4 L59)                 ; MNUMP
18    (CONST&PUSH 2)                      ; 0
19    (GETVALUE&PUSH 0)                   ; E
21    (CALL2 5)                           ; NO-ERR-SUB
23    (BIND 6)                            ; A
25    (GETVALUE 6)                        ; A
27    (JMPIFNOT L47)
29    (GETVALUE&PUSH 0)                   ; E
31    (CONST&PUSH 7)                      ; -1
32    (GETVALUE&PUSH 6)                   ; A
34    (CALL2&PUSH 8)                      ; MUL
36    (CALL2 9)                           ; ADD*
38    (SETVALUE 0)                        ; E
40    (PUSH)
41    (CALL1 10)                          ; BX**N
43    (SETVALUE 0)                        ; E
45    (JMPIF L62)
47    L47
47    (NIL)
48    (UNBIND1)
49    L49
49    (UNBIND1)
50    (SKIP&RET 2)
52    L52
52    (CONST&PUSH 2)                      ; 0
53    (CONST&PUSH 3)                      ; 1
54    (CONST&PUSH 3)                      ; 1
55    (LIST 3)
57    (JMP L49)
59    L59
59    (NIL)
60    (JMP L49)
62    L62
62    (GETVALUE&PUSH 6)                   ; A
64    (GETVALUE 0)                        ; E
66    (CONS)
67    (UNBIND1)
68    (JMP L49)


Disassembly of function #:|(DEFUN BX**N (E) ...)-154|
(CONST 0) = BX**N
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BX**N>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BX**N
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BX**N
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BX**N>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BX**N
8     (SKIP&RET 1)


Disassembly of function BX**N
(CONST 0) = E
(CONST 1) = N
(CONST 2) = VAR
(CONST 3) = XEXPONGET
(CONST 4) = 1
(CONST 5) = $MAXPOSEX
(CONST 6) = $MAXNEGEX
(CONST 7) = POWER
(CONST 8) = DIV*
(CONST 9) = $EXPAND
(CONST 10) = AMONG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N VAR E)
writes special variables : (E N)
36 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; N
6     (GETVALUE&PUSH 0)                   ; E
8     (GETVALUE&PUSH 2)                   ; VAR
10    (CALL2 3)                           ; XEXPONGET
12    (SETVALUE 1)                        ; N
14    (JMPIFNOT1 L55)
16    (GETVALUE&PUSH 2)                   ; VAR
18    (CONST 4)                           ; 1
19    (BIND 5)                            ; $MAXPOSEX
21    (CONST 4)                           ; 1
22    (BIND 6)                            ; $MAXNEGEX
24    (GETVALUE&PUSH 0)                   ; E
26    (GETVALUE&PUSH 2)                   ; VAR
28    (GETVALUE&PUSH 1)                   ; N
30    (CALL2&PUSH 7)                      ; POWER
32    (CALL2&PUSH 8)                      ; DIV*
34    (CALL1 9)                           ; $EXPAND
36    (UNBIND 2)
38    (SETVALUE 0)                        ; E
40    (PUSH)
41    (CALL2 10)                          ; AMONG
43    (NOT)
44    (JMPIFNOT1 L55)
46    (GETVALUE&PUSH 1)                   ; N
48    (GETVALUE&PUSH 0)                   ; E
50    (LIST 2)
52    (UNBIND1)
53    (JMP L56)
55    L55
55    (UNBIND1)
56    L56
56    (UNBIND1)
57    (SKIP&RET 2)


Disassembly of function #:|(DEFUN XEXPONGET (E NN*) ...)-155|
(CONST 0) = XEXPONGET
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE XEXPONGET>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; XEXPONGET
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; XEXPONGET
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE XEXPONGET>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; XEXPONGET
8     (SKIP&RET 1)


Disassembly of function XEXPONGET
(CONST 0) = E
(CONST 1) = NN*
(CONST 2) = VAR
(CONST 3) = 1
(CONST 4) = MNUMP
(CONST 5) = MEXPTP
(CONST 6) = AMONG
(CONST 7) = #<COMPILED-CLOSURE XEXPONGET-1>
(CONST 8) = ORMAPC
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR NN* E)
47 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; NN*
6     (GETVALUE 0)                        ; E
8     (JMPIFATOM L51)
10    (GETVALUE&PUSH 0)                   ; E
12    (CALL1&JMPIF 4 L60)                 ; MNUMP
15    (GETVALUE&PUSH 0)                   ; E
17    (CALL1&JMPIFNOT 5 L38)              ; MEXPTP
20    (GETVALUE 0)                        ; E
22    (CDR)
23    (CAR&PUSH)
24    (GETVALUE 1)                        ; NN*
26    (JMPIFNOTEQ L38)
28    (GETVALUE&PUSH 1)                   ; NN*
30    (GETVALUE 0)                        ; E
32    (CDR)
33    (CDR)
34    (CAR&PUSH)
35    (CALL2&JMPIFNOT 6 L63)              ; AMONG
38    L38
38    (CONST&PUSH 7)                      ; #<COMPILED-CLOSURE XEXPONGET-1>
39    (GETVALUE 0)                        ; E
41    (CDR&PUSH)
42    (CALL2 8)                           ; ORMAPC
44    L44
44    (UNBIND 2)
46    (SKIP&RET 3)
48    L48
48    (CONST 3)                           ; 1
49    (JMP L44)
51    L51
51    (GETVALUE&PUSH 0)                   ; E
53    (GETVALUE 2)                        ; VAR
55    (JMPIFEQ L48)
57    (NIL)
58    (JMP L44)
60    L60
60    (NIL)
61    (JMP L44)
63    L63
63    (GETVALUE 0)                        ; E
65    (CDR)
66    (CDR)
67    (CAR)
68    (JMP L44)


Disassembly of function XEXPONGET-1
(CONST 0) = NN*
(CONST 1) = XEXPONGET
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (NN*)
4 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; NN*
3     (CALL2 1)                           ; XEXPONGET
5     (SKIP&RET 2)


Disassembly of function #:|(DEFUN BXM (E IND) ...)-156|
(CONST 0) = BXM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BXM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BXM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BXM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BXM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BXM
8     (SKIP&RET 1)


Disassembly of function BXM
(CONST 0) = E
(CONST 1) = IND
(CONST 2) = M
(CONST 3) = R
(CONST 4) = MNUMP
(CONST 5) = (%LOG %SIN %COS %TAN)
(CONST 6) = INVOLVE
(CONST 7) = %EINVOLVE
(CONST 8) = MTIMESP
(CONST 9) = MEXPTP
(CONST 10) = VAR
(CONST 11) = AMONG
(CONST 12) = BX**N+A
(CONST 13) = 1
(CONST 14) = SDIFF
(CONST 15) = DIV*
(CONST 16) = NUMDEN
(CONST 17) = NN*
(CONST 18) = DN*
(CONST 19) = $RATSIMP
(CONST 20) = -1
(CONST 21) = ADD
(CONST 22) = POWER
(CONST 23) = MUL*
(CONST 24) = 0
(CONST 25) = SUBIN
(CONST 26) = POWER*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (R M DN* NN* VAR IND E)
writes special variables : (E M R)
147 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; IND
6     (NIL)
7     (BIND 2)                            ; M
9     (NIL)
10    (BIND 3)                            ; R
12    (GETVALUE 0)                        ; E
14    (JMPIFATOM L164)
17    (GETVALUE&PUSH 0)                   ; E
19    (CALL1&JMPIF 4 L164)                ; MNUMP
23    (GETVALUE&PUSH 0)                   ; E
25    (CONST&PUSH 5)                      ; (%LOG %SIN %COS %TAN)
26    (CALL2&JMPIF 6 L164)                ; INVOLVE
30    (GETVALUE&PUSH 0)                   ; E
32    (CALL1&JMPIF 7 L164)                ; %EINVOLVE
36    (GETVALUE&PUSH 0)                   ; E
38    (CALL1&JMPIF 8 L168)                ; MTIMESP
42    (GETVALUE&PUSH 0)                   ; E
44    (CALL1&JMPIF 9 L183)                ; MEXPTP
48    (GETVALUE&PUSH 0)                   ; E
50    (CALL1 12)                          ; BX**N+A
52    (SETVALUE 3)                        ; R
54    (JMPIF L206)
57    (GETVALUE 1)                        ; IND
59    (JMPIFNOT L249)
62    (GETVALUE&PUSH 0)                   ; E
64    (GETVALUE&PUSH 10)                  ; VAR
66    (CALL2&PUSH 14)                     ; SDIFF
68    (GETVALUE&PUSH 0)                   ; E
70    (CALL2 15)                          ; DIV*
72    (SETVALUE 2)                        ; M
74    (PUSH)
75    (CALL1 16)                          ; NUMDEN
77    (GETVALUE 17)                       ; NN*
79    (SETVALUE 2)                        ; M
81    (GETVALUE 18)                       ; DN*
83    (SETVALUE 3)                        ; R
85    (PUSH)
86    (CALL1&PUSH 19)                     ; $RATSIMP
88    (CALL1 12)                          ; BX**N+A
90    (SETVALUE 3)                        ; R
92    (JMPIFNOT L246)
95    (GETVALUE&PUSH 10)                  ; VAR
97    (GETVALUE&PUSH 2)                   ; M
99    (GETVALUE 3)                        ; R
101   (CDR)
102   (CAR&PUSH)
103   (GETVALUE 3)                        ; R
105   (CDR)
106   (CDR)
107   (CAR&PUSH)
108   (GETVALUE&PUSH 10)                  ; VAR
110   (CONST&PUSH 20)                     ; -1
111   (GETVALUE 3)                        ; R
113   (CDR)
114   (CAR&PUSH)
115   (CALL2&PUSH 21)                     ; ADD
117   (CALL2&PUSH 22)                     ; POWER
119   (CALL&PUSH 3 23)                    ; MUL*
122   (CALL2 15)                          ; DIV*
124   (SETVALUE 2)                        ; M
126   (PUSH)
127   (CALL2&JMPIF 11 L246)               ; AMONG
131   (CONST&PUSH 24)                     ; 0
132   (GETVALUE&PUSH 0)                   ; E
134   (CALL2&PUSH 25)                     ; SUBIN
136   (GETVALUE 3)                        ; R
138   (CAR&PUSH)
139   (GETVALUE&PUSH 2)                   ; M
141   (CALL2&PUSH 22)                     ; POWER
143   (CALL2 15)                          ; DIV*
145   (SETVALUE 0)                        ; E
147   (JMPIFNOT L246)
150   (GETVALUE&PUSH 0)                   ; E
152   (JMPIFNOTEQTO 13 L209)              ; 1
155   (GETVALUE 2)                        ; M
157   L157
157   (PUSH)
158   (GETVALUE 3)                        ; R
160   (CONS)
161   (JMP L250)
164   L164
164   (NIL)
165   (JMP L250)
168   L168
168   (NIL)
169   (JMP L250)
172   L172
172   (NIL)
173   (JMP L250)
176   L176
176   (GETVALUE 0)                        ; E
178   (CDR)
179   (CDR)
180   (CAR)
181   (JMP L157)
183   L183
183   (GETVALUE&PUSH 10)                  ; VAR
185   (GETVALUE 0)                        ; E
187   (CDR)
188   (CDR)
189   (CAR&PUSH)
190   (CALL2&JMPIF 11 L172)               ; AMONG
193   (GETVALUE 0)                        ; E
195   (CDR)
196   (CAR&PUSH)
197   (CALL1 12)                          ; BX**N+A
199   (SETVALUE 3)                        ; R
201   (JMPIF L176)
203   (NIL)
204   (JMP L250)
206   L206
206   (CONST 13)                          ; 1
207   (JMP L157)
209   L209
209   (GETVALUE&PUSH 0)                   ; E
211   (CONST&PUSH 13)                     ; 1
212   (GETVALUE&PUSH 2)                   ; M
214   (CALL2&PUSH 15)                     ; DIV*
216   (CALL2 26)                          ; POWER*
218   (SETVALUE 0)                        ; E
220   (GETVALUE&PUSH 2)                   ; M
222   (GETVALUE&PUSH 0)                   ; E
224   (GETVALUE 3)                        ; R
226   (CAR&PUSH)
227   (CALL2&PUSH 23)                     ; MUL*
229   (GETVALUE 3)                        ; R
231   (CDR)
232   (CAR&PUSH)
233   (GETVALUE&PUSH 0)                   ; E
235   (GETVALUE 3)                        ; R
237   (CDR)
238   (CDR)
239   (CAR&PUSH)
240   (CALL2&PUSH 23)                     ; MUL*
242   (LIST 4)
244   (JMP L250)
246   L246
246   (NIL)
247   (JMP L250)
249   L249
249   (NIL)
250   L250
250   (UNBIND 4)
252   (SKIP&RET 3)


Disassembly of function #:|(DEFUN FINDP (E) ...)-157|
(CONST 0) = FINDP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FINDP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FINDP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FINDP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FINDP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FINDP
8     (SKIP&RET 1)


Disassembly of function FINDP
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = 0
(CONST 4) = XTORTERM
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR)
14 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAR
5     (GETVALUE&PUSH 0)                   ; E
7     (CALL2&JMPIFNOT 2 L19)              ; AMONG
10    (GETVALUE&PUSH 0)                   ; E
12    (GETVALUE&PUSH 1)                   ; VAR
14    (CALL2 4)                           ; XTORTERM
16    L16
16    (UNBIND1)
17    (SKIP&RET 2)
19    L19
19    (CONST 3)                           ; 0
20    (JMP L16)


Disassembly of function #:|(DEFUN XTORTERM (E VAR1) ...)-158|
(CONST 0) = XTORTERM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE XTORTERM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; XTORTERM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; XTORTERM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE XTORTERM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; XTORTERM
8     (SKIP&RET 1)


Disassembly of function XTORTERM
(CONST 0) = E
(CONST 1) = ALIKE1
(CONST 2) = 1
(CONST 3) = MEXPTP
(CONST 4) = VAR
(CONST 5) = AMONG
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
37 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (LOAD&PUSH 5)
6     (CALL2&JMPIF 1 L40)                 ; ALIKE1
9     (GETVALUE 0)                        ; E
11    (JMPIFATOM L43)
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1&JMPIFNOT 3 L36)              ; MEXPTP
18    (GETVALUE 0)                        ; E
20    (CDR)
21    (CAR&PUSH)
22    (LOAD&PUSH 5)
23    (CALL2&JMPIFNOT 1 L36)              ; ALIKE1
26    (GETVALUE&PUSH 4)                   ; VAR
28    (GETVALUE 0)                        ; E
30    (CDR)
31    (CDR)
32    (CAR&PUSH)
33    (CALL2&JMPIFNOT 5 L46)              ; AMONG
36    L36
36    (NIL)
37    L37
37    (UNBIND1)
38    (SKIP&RET 3)
40    L40
40    (CONST 2)                           ; 1
41    (JMP L37)
43    L43
43    (NIL)
44    (JMP L37)
46    L46
46    (GETVALUE 0)                        ; E
48    (CDR)
49    (CDR)
50    (CAR)
51    (JMP L37)


Disassembly of function #:|(DEFUN TBF (L) ...)-159|
(CONST 0) = TBF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TBF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TBF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TBF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TBF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TBF
8     (SKIP&RET 1)


Disassembly of function TBF
(CONST 0) = L
(CONST 1) = ((RAT) 1 2)
(CONST 2) = POWER*
(CONST 3) = MUL*
(CONST 4) = ((RAT) 1 2)
(CONST 5) = ADD*
(CONST 6) = -1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (L)
26 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (CDR)
6     (CDR)
7     (CAR&PUSH)
8     (CONST&PUSH 1)                      ; ((RAT) 1 2)
9     (CALL2&PUSH 2)                      ; POWER*
11    (GETVALUE 0)                        ; L
13    (CDR)
14    (CAR&PUSH)
15    (GETVALUE 0)                        ; L
17    (CAR&PUSH)
18    (GETVALUE 0)                        ; L
20    (CDR)
21    (CDR)
22    (CAR&PUSH)
23    (CALL2&PUSH 3)                      ; MUL*
25    (CONST&PUSH 4)                      ; ((RAT) 1 2)
26    (CALL2&PUSH 2)                      ; POWER*
28    (CALL2&PUSH 5)                      ; ADD*
30    (CALL2&PUSH 3)                      ; MUL*
32    (CONST&PUSH 6)                      ; -1
33    (CALL2 2)                           ; POWER*
35    (UNBIND1)
36    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RADBYTERM (D L) ...)-160|
(CONST 0) = RADBYTERM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RADBYTERM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RADBYTERM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RADBYTERM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RADBYTERM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RADBYTERM
8     (SKIP&RET 1)


Disassembly of function RADBYTERM
(CONST 0) = D
(CONST 1) = L
(CONST 2) = ANS
(CONST 3) = RMCONST1
(CONST 4) = DINTRAD0
(CONST 5) = MUL*
(CONST 6) = ADDN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS D L)
writes special variables : (L ANS)
37 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; D
3     (LOAD 4)
4     (BIND 1)                            ; L
6     (GETVALUE 1)                        ; L
8     (BIND 1)                            ; L
10    (NIL)
11    (BIND 2)                            ; ANS
13    (GETVALUE 1)                        ; L
15    (JMPIFNOT L52)
17    L17
17    (NIL&PUSH)
18    (GETVALUE 1)                        ; L
20    (CAR&PUSH)
21    (CALL1&PUSH 3)                      ; RMCONST1
23    (LOAD&CAR&STORE 0 1)
26    (LOAD&CDR&STORE 0)
28    (LOAD&PUSH 1)
29    (LOAD&PUSH 1)
30    (GETVALUE&PUSH 0)                   ; D
32    (CALL2&PUSH 4)                      ; DINTRAD0
34    (CALL2&PUSH 5)                      ; MUL*
36    (GETVALUE 2)                        ; ANS
38    (CONS)
39    (SETVALUE 2)                        ; ANS
41    (SKIP 2)
43    (GETVALUE 1)                        ; L
45    (CDR)
46    (SETVALUE 1)                        ; L
48    (GETVALUE 1)                        ; L
50    (JMPIF L17)
52    L52
52    (GETVALUE&PUSH 2)                   ; ANS
54    (NIL&PUSH)
55    (CALL2 6)                           ; ADDN
57    (UNBIND 4)
59    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SQDTC (E IND) ...)-161|
(CONST 0) = SQDTC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SQDTC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SQDTC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SQDTC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SQDTC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SQDTC
8     (SKIP&RET 1)


Disassembly of function SQDTC
(CONST 0) = E
(CONST 1) = IND
(CONST 2) = A
(CONST 3) = B
(CONST 4) = C
(CONST 5) = VARLIST
(CONST 6) = VAR
(CONST 7) = NEWVAR
(CONST 8) = RATREP*
(CONST 9) = 0
(CONST 10) = PTERM
(CONST 11) = PDIS
(CONST 12) = 1
(CONST 13) = 2
(CONST 14) = DIV
(CONST 15) = MUL
(CONST 16) = MUL*
(CONST 17) = ((RAT) 1 2)
(CONST 18) = POWER*
(CONST 19) = ADD*
(CONST 20) = $ASKSIGN
(CONST 21) = $POS
(CONST 22) = $NEG
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (IND C A B E VAR)
writes special variables : (A B C E VARLIST)
79 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; IND
6     (NIL)
7     (BIND 2)                            ; A
9     (NIL)
10    (BIND 3)                            ; B
12    (NIL)
13    (BIND 4)                            ; C
15    (NIL)
16    (BIND 5)                            ; VARLIST
18    (GETVALUE&PUSH 6)                   ; VAR
20    (LIST 1)
22    (SETVALUE 5)                        ; VARLIST
24    (GETVALUE&PUSH 0)                   ; E
26    (CALL1 7)                           ; NEWVAR
28    (GETVALUE&PUSH 0)                   ; E
30    (CALL1 8)                           ; RATREP*
32    (CDR)
33    (CAR)
34    (CDR)
35    (SETVALUE 0)                        ; E
37    (PUSH)
38    (CONST&PUSH 9)                      ; 0
39    (CALL2&PUSH 10)                     ; PTERM
41    (CALL1 11)                          ; PDIS
43    (SETVALUE 4)                        ; C
45    (CONST&PUSH 12)                     ; 1
46    (CONST&PUSH 13)                     ; 2
47    (CALL2&PUSH 14)                     ; DIV
49    (GETVALUE&PUSH 0)                   ; E
51    (CONST&PUSH 12)                     ; 1
52    (CALL2&PUSH 10)                     ; PTERM
54    (CALL1&PUSH 11)                     ; PDIS
56    (CALL2 15)                          ; MUL
58    (SETVALUE 3)                        ; B
60    (GETVALUE&PUSH 0)                   ; E
62    (CONST&PUSH 13)                     ; 2
63    (CALL2&PUSH 10)                     ; PTERM
65    (CALL1 11)                          ; PDIS
67    (SETVALUE 2)                        ; A
69    (GETVALUE&PUSH 3)                   ; B
71    (GETVALUE&PUSH 2)                   ; A
73    (GETVALUE&PUSH 4)                   ; C
75    (CALL2&PUSH 16)                     ; MUL*
77    (CONST&PUSH 17)                     ; ((RAT) 1 2)
78    (CALL2&PUSH 18)                     ; POWER*
80    (CALL2&PUSH 19)                     ; ADD*
82    (CALL1&PUSH 20)                     ; $ASKSIGN
84    (JMPIFNOTEQTO 21 L119)              ; $POS
87    (GETVALUE 1)                        ; IND
89    (JMPIFNOT L105)
91    (GETVALUE&PUSH 2)                   ; A
93    (CALL1&PUSH 20)                     ; $ASKSIGN
95    (JMPIFEQTO 22 L105)                 ; $NEG
98    (GETVALUE&PUSH 4)                   ; C
100   (CALL1&PUSH 20)                     ; $ASKSIGN
102   (JMPIFEQTO 21 L126)                 ; $POS
105   L105
105   (GETVALUE&PUSH 2)                   ; A
107   (CALL1&PUSH 20)                     ; $ASKSIGN
109   (JMPIFNOTEQTO 21 L119)              ; $POS
112   (GETVALUE&PUSH 4)                   ; C
114   (CALL1&PUSH 20)                     ; $ASKSIGN
116   (JMPIFNOTEQTO 22 L126)              ; $NEG
119   L119
119   (NIL)
120   (UNBIND 4)
122   L122
122   (UNBIND 2)
124   (SKIP&RET 3)
126   L126
126   (GETVALUE&PUSH 2)                   ; A
128   (GETVALUE&PUSH 3)                   ; B
130   (GETVALUE&PUSH 4)                   ; C
132   (LIST 3)
134   (UNBIND 4)
136   (JMP L122)


Disassembly of function #:|(DEFUN DIFAP1 (E PWR VAR ...) ...)-162|
(CONST 0) = DIFAP1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DIFAP1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DIFAP1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DIFAP1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DIFAP1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DIFAP1
8     (SKIP&RET 1)


Disassembly of function DIFAP1
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = M
(CONST 3) = $EVEN
(CONST 4) = ASK-INTEGER
(CONST 5) = $YES
(CONST 6) = 1
(CONST 7) = -1
(CONST 8) = (%GAMMA)
(CONST 9) = DERIVAT
(CONST 10) = MUL*
(CONST 11) = (%GAMMA)
(CONST 12) = ADD*
(CONST 13) = DIV*
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR M)
33 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; E
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; M
9     (GETVALUE&PUSH 2)                   ; M
11    (CONST&PUSH 3)                      ; $EVEN
12    (CALL2&PUSH 4)                      ; ASK-INTEGER
14    (JMPIFEQTO 5 L50)                   ; $YES
17    (CONST 7)                           ; -1
18    L18
18    (PUSH)
19    (CONST&PUSH 8)                      ; (%GAMMA)
20    (LOAD&PUSH 15)
21    (LIST&PUSH 2)
23    (GETVALUE&PUSH 1)                   ; VAR
25    (GETVALUE&PUSH 2)                   ; M
27    (GETVALUE&PUSH 0)                   ; E
29    (LOAD&PUSH 15)
30    (CALL&PUSH 4 9)                     ; DERIVAT
33    (CALL&PUSH 3 10)                    ; MUL*
36    (CONST&PUSH 11)                     ; (%GAMMA)
37    (LOAD&PUSH 15)
38    (GETVALUE&PUSH 2)                   ; M
40    (CALL2&PUSH 12)                     ; ADD*
42    (LIST&PUSH 2)
44    (CALL2 13)                          ; DIV*
46    (UNBIND 3)
48    (SKIP&RET 6)
50    L50
50    (CONST 6)                           ; 1
51    (JMP L18)


Disassembly of function #:|(DEFUN SQRTINVOLVE (E) ...)-163|
(CONST 0) = SQRTINVOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SQRTINVOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SQRTINVOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SQRTINVOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SQRTINVOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SQRTINVOLVE
8     (SKIP&RET 1)


Disassembly of function SQRTINVOLVE
(CONST 0) = E
(CONST 1) = MNUMP
(CONST 2) = MEXPTP
(CONST 3) = 2
(CONST 4) = VAR
(CONST 5) = AMONG
(CONST 6) = SQRTINVOLVE
(CONST 7) = ORMAPC
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
50 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L63)
7     (GETVALUE&PUSH 0)                   ; E
9     (CALL1&JMPIF 1 L66)                 ; MNUMP
12    (GETVALUE&PUSH 0)                   ; E
14    (CALL1&JMPIFNOT 2 L53)              ; MEXPTP
17    (GETVALUE 0)                        ; E
19    (CDR)
20    (CDR)
21    (CAR&PUSH)
22    (CALL1&JMPIFNOT 1 L53)              ; MNUMP
25    (GETVALUE 0)                        ; E
27    (CDR)
28    (CDR)
29    (CAR&PUSH)
30    (CALLS2&JMPIF 8 L53)                ; NUMBERP
33    (GETVALUE 0)                        ; E
35    (CDR)
36    (CDR)
37    (CAR)
38    (CDR)
39    (CDR)
40    (CAR&PUSH)
41    (JMPIFNOTEQTO 3 L53)                ; 2
44    (GETVALUE&PUSH 4)                   ; VAR
46    (GETVALUE 0)                        ; E
48    (CDR)
49    (CAR&PUSH)
50    (CALL2&JMPIF 5 L69)                 ; AMONG
53    L53
53    (CONST&SYMBOL-FUNCTION&PUSH 6)      ; SQRTINVOLVE
55    (GETVALUE 0)                        ; E
57    (CDR&PUSH)
58    (CALL2 7)                           ; ORMAPC
60    L60
60    (UNBIND1)
61    (SKIP&RET 2)
63    L63
63    (NIL)
64    (JMP L60)
66    L66
66    (NIL)
67    (JMP L60)
69    L69
69    (GETVALUE 0)                        ; E
71    (CDR)
72    (CAR)
73    (JMP L60)


Disassembly of function #:|(DEFUN BYDIF (R S D) ...)-164|
(CONST 0) = BYDIF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BYDIF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BYDIF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BYDIF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BYDIF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BYDIF
8     (SKIP&RET 1)


Disassembly of function BYDIF
(CONST 0) = R
(CONST 1) = S
(CONST 2) = D
(CONST 3) = 1
(CONST 4) = B
(CONST 5) = P
(CONST 6) = *Z*
(CONST 7) = VAR
(CONST 8) = MUL
(CONST 9) = ADD*
(CONST 10) = -1
(CONST 11) = ZEROP1
(CONST 12) = ((RAT) 3 2)
(CONST 13) = POWER*
(CONST 14) = DINTRAD0
(CONST 15) = ((RAT) 3 2)
(CONST 16) = 0
(CONST 17) = DIFAP1
(CONST 18) = $ASKSIGN
(CONST 19) = $POS
(CONST 20) = Z**
(CONST 21) = ADD
(CONST 22) = ((RAT) 3 2)
(CONST 23) = ((RAT) 3 2)
(CONST 24) = ((RAT) 3 2)
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B P R S D VAR)
writes special variables : (B P D)
71 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; R
3     (LOAD 5)
4     (BIND 1)                            ; S
6     (LOAD 7)
7     (BIND 2)                            ; D
9     (CONST 3)                           ; 1
10    (BIND 4)                            ; B
12    (NIL)
13    (BIND 5)                            ; P
15    (CONST&PUSH 6)                      ; *Z*
16    (GETVALUE&PUSH 7)                   ; VAR
18    (CALL2&PUSH 8)                      ; MUL
20    (GETVALUE&PUSH 2)                   ; D
22    (CALL2 9)                           ; ADD*
24    (SETVALUE 2)                        ; D
26    (GETVALUE&PUSH 1)                   ; S
28    (CONST&PUSH 10)                     ; -1
29    (GETVALUE&PUSH 0)                   ; R
31    (CALL2&PUSH 8)                      ; MUL
33    (CALL2 9)                           ; ADD*
35    (SETVALUE 5)                        ; P
37    (PUSH)
38    (CALL1&JMPIF 11 L92)                ; ZEROP1
41    (CONST&PUSH 3)                      ; 1
42    (GETVALUE&PUSH 5)                   ; P
44    (CALL2&PUSH 9)                      ; ADD*
46    (CALL1&JMPIFNOT 11 L55)             ; ZEROP1
49    (GETVALUE 7)                        ; VAR
51    (SETVALUE 4)                        ; B
53    (JMPIF L92)
55    L55
55    (GETVALUE&PUSH 5)                   ; P
57    (CALL1&PUSH 18)                     ; $ASKSIGN
59    (JMPIFNOTEQTO 19 L108)              ; $POS
62    (CONST&PUSH 3)                      ; 1
63    (CONST&PUSH 20)                     ; Z**
64    (GETVALUE&PUSH 2)                   ; D
66    (CALL2&PUSH 21)                     ; ADD
68    (CONST&PUSH 22)                     ; ((RAT) 3 2)
69    (CALL2&PUSH 13)                     ; POWER*
71    (CALL2&PUSH 14)                     ; DINTRAD0
73    (CONST&PUSH 23)                     ; ((RAT) 3 2)
74    (CONST&PUSH 6)                      ; *Z*
75    (GETVALUE&PUSH 0)                   ; R
77    (CONST&PUSH 16)                     ; 0
78    (CALL&PUSH 5 17)                    ; DIFAP1
81    (CONST&PUSH 24)                     ; ((RAT) 3 2)
82    (CONST&PUSH 20)                     ; Z**
83    (GETVALUE&PUSH 5)                   ; P
85    (CONST 16)                          ; 0
86    L86
86    (PUSH)
87    (CALL 5 17)                         ; DIFAP1
90    (JMP L109)
92    L92
92    (GETVALUE&PUSH 4)                   ; B
94    (GETVALUE&PUSH 2)                   ; D
96    (CONST&PUSH 12)                     ; ((RAT) 3 2)
97    (CALL2&PUSH 13)                     ; POWER*
99    (CALL2&PUSH 14)                     ; DINTRAD0
101   (CONST&PUSH 15)                     ; ((RAT) 3 2)
102   (CONST&PUSH 6)                      ; *Z*
103   (GETVALUE&PUSH 0)                   ; R
105   (CONST 16)                          ; 0
106   (JMP L86)
108   L108
108   (NIL)
109   L109
109   (UNBIND 5)
111   (SKIP&RET 4)


Disassembly of function #:|(DEFUN DINTRAD0 (N D) ...)-165|
(CONST 0) = DINTRAD0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DINTRAD0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DINTRAD0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DINTRAD0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DINTRAD0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DINTRAD0
8     (SKIP&RET 1)


Disassembly of function DINTRAD0
(CONST 0) = N
(CONST 1) = D
(CONST 2) = L
(CONST 3) = R
(CONST 4) = S
(CONST 5) = MEXPTP
(CONST 6) = DEG
(CONST 7) = 2
(CONST 8) = ((RAT) 3 2)
(CONST 9) = ALIKE1
(CONST 10) = 1
(CONST 11) = SQDTC
(CONST 12) = TBF
(CONST 13) = VAR
(CONST 14) = FINDP
(CONST 15) = -1
(CONST 16) = MUL*
(CONST 17) = MUL
(CONST 18) = ADD*
(CONST 19) = $ASKSIGN
(CONST 20) = $POS
(CONST 21) = DIVERG
(CONST 22) = ((RAT) -3 2)
(CONST 23) = $INTEGER
(CONST 24) = ASK-INTEGER
(CONST 25) = $YES
(CONST 26) = BYDIF
(CONST 27) = POLYINX
(CONST 28) = RADBYTERM
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (S R L VAR N D)
writes special variables : (S R L)
118 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (NIL)
7     (BIND 2)                            ; L
9     (NIL)
10    (BIND 3)                            ; R
12    (NIL)
13    (BIND 4)                            ; S
15    (GETVALUE&PUSH 1)                   ; D
17    (CALL1&JMPIFNOT 5 L191)             ; MEXPTP
21    (GETVALUE 1)                        ; D
23    (CDR)
24    (CAR&PUSH)
25    (CALL1&PUSH 6)                      ; DEG
27    (JMPIFNOTEQTO 7 L191)               ; 2
31    (GETVALUE 1)                        ; D
33    (CDR)
34    (CDR)
35    (CAR&PUSH)
36    (CONST&PUSH 8)                      ; ((RAT) 3 2)
37    (CALL2&JMPIFNOT 9 L116)             ; ALIKE1
41    (GETVALUE&PUSH 0)                   ; N
43    (JMPIFNOTEQTO 10 L57)               ; 1
46    (GETVALUE 1)                        ; D
48    (CDR)
49    (CAR&PUSH)
50    (T&PUSH)
51    (CALL2 11)                          ; SQDTC
53    (SETVALUE 2)                        ; L
55    (JMPIF L84)
57    L57
57    (GETVALUE&PUSH 0)                   ; N
59    (GETVALUE 13)                       ; VAR
61    (JMPIFNOTEQ L88)
63    (GETVALUE 1)                        ; D
65    (CDR)
66    (CAR&PUSH)
67    (NIL&PUSH)
68    (CALL2 11)                          ; SQDTC
70    (SETVALUE 2)                        ; L
72    (JMPIFNOT L88)
74    (GETVALUE&PUSH 2)                   ; L
76    (CALLS2 72)                         ; REVERSE
78    L78
78    (PUSH)
79    (CALL1 12)                          ; TBF
81    (JMP L192)
84    L84
84    (GETVALUE 2)                        ; L
86    (JMP L78)
88    L88
88    (NIL)
89    (JMP L192)
92    L92
92    (GETVALUE&PUSH 3)                   ; R
94    (GETVALUE&PUSH 4)                   ; S
96    (GETVALUE 1)                        ; D
98    (CDR)
99    (CAR&PUSH)
100   (CALL 3 26)                         ; BYDIF
103   (JMP L192)
106   L106
106   (GETVALUE&PUSH 1)                   ; D
108   (GETVALUE 0)                        ; N
110   (CDR&PUSH)
111   (CALL2 28)                          ; RADBYTERM
113   (JMP L192)
116   L116
116   (GETVALUE&PUSH 0)                   ; N
118   (CALL1 14)                          ; FINDP
120   (SETVALUE 3)                        ; R
122   (JMPIFNOT L177)
124   (CONST&PUSH 15)                     ; -1
125   (CONST&PUSH 15)                     ; -1
126   (GETVALUE&PUSH 3)                   ; R
128   (CALL2&PUSH 16)                     ; MUL*
130   (CONST&PUSH 7)                      ; 2
131   (GETVALUE 1)                        ; D
133   (CDR)
134   (CDR)
135   (CAR&PUSH)
136   (CALL2&PUSH 17)                     ; MUL
138   (CALL&PUSH 3 18)                    ; ADD*
141   (CALL1&PUSH 19)                     ; $ASKSIGN
143   (JMPIFEQTO 20 L150)                 ; $POS
146   (CALL0 21)                          ; DIVERG
148   (JMPIFNOT L177)
150   L150
150   (CONST&PUSH 22)                     ; ((RAT) -3 2)
151   (GETVALUE 1)                        ; D
153   (CDR)
154   (CDR)
155   (CAR&PUSH)
156   (CALL2 18)                          ; ADD*
158   (SETVALUE 4)                        ; S
160   (JMPIFNOT L177)
162   (PUSH)
163   (CALL1&PUSH 19)                     ; $ASKSIGN
165   (JMPIFNOTEQTO 20 L177)              ; $POS
168   (GETVALUE&PUSH 4)                   ; S
170   (CONST&PUSH 23)                     ; $INTEGER
171   (CALL2&PUSH 24)                     ; ASK-INTEGER
173   (JMPIFEQTO 25 L92)                  ; $YES
177   L177
177   (GETVALUE&PUSH 0)                   ; N
179   (GETVALUE&PUSH 13)                  ; VAR
181   (NIL&PUSH)
182   (CALL 3 27)                         ; POLYINX
185   (JMPIF L106)
188   (NIL)
189   (JMP L192)
191   L191
191   (NIL)
192   L192
192   (UNBIND 5)
194   (SKIP&RET 3)


Disassembly of function #:|(DEFUN LOG-IMAG-0-2%PI (X) ...)-166|
(CONST 0) = LOG-IMAG-0-2%PI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOG-IMAG-0-2%PI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOG-IMAG-0-2%PI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOG-IMAG-0-2%PI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOG-IMAG-0-2%PI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOG-IMAG-0-2%PI
8     (SKIP&RET 1)


Disassembly of function LOG-IMAG-0-2%PI
(CONST 0) = X
(CONST 1) = (%PLOG)
(CONST 2) = SIMPLIFY
(CONST 3) = %PLOG
(CONST 4) = FREE
(CONST 5) = %LOG
(CONST 6) = TRISPLIT
(CONST 7) = $ASKSIGN
(CONST 8) = $NEG
(CONST 9) = %PI2
(CONST 10) = ADD*
(CONST 11) = SUB*
(CONST 12) = $POS
(CONST 13) = $%I
(CONST 14) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (%PI2 X)
50 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; (%PLOG)
4     (GETVALUE&PUSH 0)                   ; X
6     (LIST&PUSH 2)
8     (CALL1&PUSH 2)                      ; SIMPLIFY
10    (LOAD&PUSH 0)
11    (CONST&PUSH 3)                      ; %PLOG
12    (CALL2&JMPIFNOT 4 L58)              ; FREE
15    (NIL&PUSH)
16    (LOAD&PUSH 1)
17    (CALL1&PUSH 6)                      ; TRISPLIT
19    (LOAD&CAR&STORE 0 1)
22    (LOAD&CDR&STORE 0)
24    (PUSH)
25    (CALL1&PUSH 7)                      ; $ASKSIGN
27    (JMPIFEQTO 8 L69)                   ; $NEG
30    (LOAD&PUSH 0)
31    (GETVALUE&PUSH 9)                   ; %PI2
33    (CALL2&PUSH 11)                     ; SUB*
35    (CALL1&PUSH 7)                      ; $ASKSIGN
37    (JMPIFNOTEQTO 12 L46)               ; $POS
40    (LOAD&PUSH 0)
41    (GETVALUE&PUSH 9)                   ; %PI2
43    (CALL2 11)                          ; SUB*
45    (STORE 0)
46    L46
46    (LOAD&PUSH 1)
47    (CONST&PUSH 13)                     ; $%I
48    (LOAD&PUSH 2)
49    (CALL2&PUSH 14)                     ; MUL*
51    (CALL2 10)                          ; ADD*
53    (SKIP 3)
55    L55
55    (UNBIND1)
56    (SKIP&RET 2)
58    L58
58    (CONST&PUSH 5)                      ; %LOG
59    (CONST&PUSH 3)                      ; %PLOG
60    (LOAD&PUSH 2)
61    (PUSH-UNBOUND 3)
63    (CALLS1 172)                        ; SUBST
65    (SKIP 1)
67    (JMP L55)
69    L69
69    (LOAD&PUSH 0)
70    (GETVALUE&PUSH 9)                   ; %PI2
72    (CALL2 10)                          ; ADD*
74    (STORE 0)
75    (JMP L46)


Disassembly of function #:|(DEFUN %I-OUT-OF-DENOM (EXP) ...)-167|
(CONST 0) = %I-OUT-OF-DENOM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE %I-OUT-OF-DENOM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; %I-OUT-OF-DENOM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; %I-OUT-OF-DENOM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE %I-OUT-OF-DENOM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; %I-OUT-OF-DENOM
8     (SKIP&RET 1)


Disassembly of function %I-OUT-OF-DENOM
(CONST 0) = EXP
(CONST 1) = $DENOM
(CONST 2) = $%I
(CONST 3) = AMONG
(CONST 4) = -1
(CONST 5) = MUL*
(CONST 6) = MAXIMA-SUBSTITUTE
(CONST 7) = DIV*
(CONST 8) = $RATSIMP
(CONST 9) = SRATSIMP
(CONST 10) = $MULTTHRU
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
writes special variable : (EXP)
35 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&PUSH 1)                      ; $DENOM
7     (NIL&PUSH)
8     (CONST&PUSH 2)                      ; $%I
9     (LOAD&PUSH 2)
10    (CALL2&JMPIF 3 L20)                 ; AMONG
13    (GETVALUE 0)                        ; EXP
15    (SKIP 2)
17    L17
17    (UNBIND1)
18    (SKIP&RET 2)
20    L20
20    (CONST&PUSH 4)                      ; -1
21    (CONST&PUSH 2)                      ; $%I
22    (CALL2&PUSH 5)                      ; MUL*
24    (CONST&PUSH 2)                      ; $%I
25    (LOAD&PUSH 3)
26    (CALL 3 6)                          ; MAXIMA-SUBSTITUTE
29    (STORE 0)
30    (PUSH)
31    (GETVALUE&PUSH 0)                   ; EXP
33    (LOAD&PUSH 2)
34    (CALL2&PUSH 7)                      ; DIV*
36    (CALL1&PUSH 8)                      ; $RATSIMP
38    (CALL2 5)                           ; MUL*
40    (SETVALUE 0)                        ; EXP
42    (PUSH)
43    (CALL1&PUSH 9)                      ; SRATSIMP
45    (CALL1&PUSH 10)                     ; $MULTTHRU
47    (CALL1 11)                          ; SIMPLIFY
49    (SETVALUE 0)                        ; EXP
51    (SKIP 2)
53    (JMP L17)


Disassembly of function #:|(DEFUN POLES-IN-INTERVAL (EXP VAR LL ...) ...)-168|
(CONST 0) = POLES-IN-INTERVAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POLES-IN-INTERVAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POLES-IN-INTERVAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POLES-IN-INTERVAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POLES-IN-INTERVAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POLES-IN-INTERVAL
8     (SKIP&RET 1)


Disassembly of function POLES-IN-INTERVAL
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = MPLUSP
(CONST 5) = SRATSIMP
(CONST 6) = $DENOM
(CONST 7) = MEXPTP
(CONST 8) = FREE
(CONST 9) = $ASKSIGN
(CONST 10) = $NEG
(CONST 11) = -1
(CONST 12) = MUL*
(CONST 13) = POWER*
(CONST 14) = REAL-ROOTS
(CONST 15) = $PLUS
(CONST 16) = LIMIT-POLE
(CONST 17) = $MINUS
(CONST 18) = $FAILURE
(CONST 19) = $UNKNOWN
(CONST 20) = $NO
(CONST 21) = 1
(CONST 22) = IN-INTERVAL
(CONST 23) = $YES
(CONST 24) = IS-A-POLE
(CONST 25) = 0
(CONST 26) = SORT-POLES
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (UL LL VAR EXP)
150 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CALL1&JMPIF 4 L178)                ; MPLUSP
18    (GETVALUE&PUSH 0)                   ; EXP
20    (CALL1&JMPIFNOT 7 L44)              ; MEXPTP
23    (GETVALUE 0)                        ; EXP
25    (CDR)
26    (CDR)
27    (CAR&PUSH)
28    (GETVALUE&PUSH 1)                   ; VAR
30    (CALL2&JMPIFNOT 8 L44)              ; FREE
33    (GETVALUE 0)                        ; EXP
35    (CDR)
36    (CDR)
37    (CAR&PUSH)
38    (CALL1&PUSH 9)                      ; $ASKSIGN
40    (JMPIFEQTO 10 L185)                 ; $NEG
44    L44
44    (GETVALUE 0)                        ; EXP
46    L46
46    (PUSH)
47    (CALL1 6)                           ; $DENOM
49    L49
49    (PUSH)
50    (LOAD&PUSH 0)
51    (GETVALUE&PUSH 1)                   ; VAR
53    (CALL2&PUSH 14)                     ; REAL-ROOTS
55    (GETVALUE&PUSH 0)                   ; EXP
57    (GETVALUE&PUSH 1)                   ; VAR
59    (GETVALUE&PUSH 2)                   ; LL
61    (CONST&PUSH 15)                     ; $PLUS
62    (CALL&PUSH 4 16)                    ; LIMIT-POLE
65    (GETVALUE&PUSH 0)                   ; EXP
67    (GETVALUE&PUSH 1)                   ; VAR
69    (GETVALUE&PUSH 3)                   ; UL
71    (CONST&PUSH 17)                     ; $MINUS
72    (CALL&PUSH 4 16)                    ; LIMIT-POLE
75    (LOAD&PUSH 2)
76    (JMPIFEQTO 18 L202)                 ; $FAILURE
80    (LOAD&JMPIFNOT 1 L202)
84    (LOAD&JMPIFNOT 0 L202)
88    (LOAD&PUSH 2)
89    (JMPIFNOTEQTO 20 L101)              ; $NO
92    (LOAD&PUSH 1)
93    (JMPIFNOTEQTO 20 L101)              ; $NO
96    (LOAD&PUSH 0)
97    (JMPIFEQTO 20 L207)                 ; $NO
101   L101
101   (LOAD&PUSH 2)
102   (JMPIFNOTEQTO 20 L107)              ; $NO
105   (NIL&STORE 2)
107   L107
107   (LOAD&PUSH 2)
108   (LOAD&PUSH 2)
109   (JMPIFNOTEQTO 20 L212)              ; $NO
113   (NIL)
114   L114
114   (PUSH)
115   (LOAD&JMPIFNOT 1 L160)
118   L118
118   (LOAD 1)
119   (CAR)
120   (CAR&PUSH)
121   (LOAD&PUSH 0)
122   (GETVALUE&PUSH 2)                   ; LL
124   (GETVALUE&PUSH 3)                   ; UL
126   (CALL&PUSH 3 22)                    ; IN-INTERVAL
129   (LOAD&PUSH 0)
130   (JMPIFEQTO 20 L153)                 ; $NO
133   (LOAD&PUSH 0)
134   (JMPIFNOTEQTO 23 L153)              ; $YES
137   (GETVALUE&PUSH 0)                   ; EXP
139   (LOAD&PUSH 2)
140   (CALL2&PUSH 24)                     ; IS-A-POLE
142   (LOAD&JMPIFNOT 0 L222)
146   (LOAD&PUSH 0)
147   (JMPIFNOTEQTO 25 L227)              ; 0
151   (SKIP 1)
153   L153
153   (SKIP 2)
155   (LOAD&CDR&STORE 1)
157   (LOAD&JMPIF 1 L118)
160   L160
160   (LOAD&PUSH 2)
161   (JMPIFNOTEQTO 20 L236)              ; $NO
165   (LOAD&JMPIFNOT 0 L246)
169   (LOAD 0)
170   L170
170   (PUSH)
171   (CALL1 26)                          ; SORT-POLES
173   (SKIP 6)
175   (JMP L249)
178   L178
178   (GETVALUE&PUSH 0)                   ; EXP
180   (CALL1 5)                           ; SRATSIMP
182   (JMP L46)
185   L185
185   (GETVALUE 0)                        ; EXP
187   (CDR)
188   (CAR&PUSH)
189   (CONST&PUSH 11)                     ; -1
190   (GETVALUE 0)                        ; EXP
192   (CDR)
193   (CDR)
194   (CAR&PUSH)
195   (CALL2&PUSH 12)                     ; MUL*
197   (CALL2 13)                          ; POWER*
199   (JMP L49)
202   L202
202   (CONST 19)                          ; $UNKNOWN
203   (SKIP 4)
205   (JMP L249)
207   L207
207   (CONST 20)                          ; $NO
208   (SKIP 4)
210   (JMP L249)
212   L212
212   (GETVALUE&PUSH 2)                   ; LL
214   (CONST 21)                          ; 1
216   (CONS&PUSH)
217   (LIST 1)
219   (JMP L114)
222   L222
222   (CONST 19)                          ; $UNKNOWN
223   (SKIP 9)
225   (JMP L249)
227   L227
227   (LOAD&CAR&PUSH 4)
229   (LOAD&CONS&STORE 3)
231   (SKIP 1)
233   (JMP L153)
236   L236
236   (GETVALUE&PUSH 3)                   ; UL
238   (CONST 21)                          ; 1
240   (CONS&PUSH)
241   (LOAD&CONS&STORE 0)
243   (JMP L170)
246   L246
246   (CONST 20)                          ; $NO
247   (SKIP 6)
249   L249
249   (UNBIND 4)
251   (SKIP&RET 5)


Disassembly of function #:|(DEFUN LIMIT-POLE (EXP VAR LIMIT ...) ...)-169|
(CONST 0) = LIMIT-POLE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-POLE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-POLE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-POLE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-POLE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT-POLE
8     (SKIP&RET 1)


Disassembly of function LIMIT-POLE
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = ($MINF $INF)
(CONST 3) = MEMQ
(CONST 4) = SPECIAL-CONVERGENT-FORMP
(CONST 5) = $YES
(CONST 6) = $NO
(CONST 7) = MUL*
(CONST 8) = GET-LIMIT
(CONST 9) = ANS
(CONST 10) = 0
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP ANS)
49 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD&PUSH 8)
7     (CONST&PUSH 2)                      ; ($MINF $INF)
8     (CALL2&JMPIF 3 L37)                 ; MEMQ
11    (CONST 6)                           ; $NO
12    L12
12    (BIND 9)                            ; ANS
14    (GETVALUE&PUSH 9)                   ; ANS
16    (JMPIFEQTO 6 L60)                   ; $NO
19    (GETVALUE 9)                        ; ANS
21    (JMPIFNOT L64)
23    (GETVALUE&PUSH 9)                   ; ANS
25    (JMPIFEQTO 10 L68)                  ; 0
28    (CONST 5)                           ; $YES
29    (UNBIND1)
30    L30
30    (UNBIND 2)
32    (SKIP&RET 5)
34    L34
34    (CONST 6)                           ; $NO
35    (JMP L12)
37    L37
37    (GETVALUE&PUSH 0)                   ; EXP
39    (LOAD&PUSH 9)
40    (CALL2&PUSH 4)                      ; SPECIAL-CONVERGENT-FORMP
42    (JMPIFEQTO 5 L34)                   ; $YES
45    (GETVALUE&PUSH 0)                   ; EXP
47    (GETVALUE&PUSH 1)                   ; VAR
49    (CALL2&PUSH 7)                      ; MUL*
51    (GETVALUE&PUSH 1)                   ; VAR
53    (LOAD&PUSH 10)
54    (LOAD&PUSH 10)
55    (CALL 4 8)                          ; GET-LIMIT
58    (JMP L12)
60    L60
60    (CONST 6)                           ; $NO
61    (UNBIND1)
62    (JMP L30)
64    L64
64    (NIL)
65    (UNBIND1)
66    (JMP L30)
68    L68
68    (CONST 6)                           ; $NO
69    (UNBIND1)
70    (JMP L30)


Disassembly of function #:|(DEFUN SPECIAL-CONVERGENT-FORMP (EXP LIMIT) ...)-170|
(CONST 0) = SPECIAL-CONVERGENT-FORMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SPECIAL-CONVERGENT-FORMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SPECIAL-CONVERGENT-FORMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SPECIAL-CONVERGENT-FORMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SPECIAL-CONVERGENT-FORMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SPECIAL-CONVERGENT-FORMP
8     (SKIP&RET 1)


Disassembly of function SPECIAL-CONVERGENT-FORMP
(CONST 0) = EXP
(CONST 1) = OSCIP
(CONST 2) = $NO
(CONST 3) = SC-CONVERG-FORM
(CONST 4) = $YES
(CONST 5) = EXP-CONVERG-FORM
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
22 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&JMPIFNOT 1 L28)              ; OSCIP
8     (GETVALUE&PUSH 0)                   ; EXP
10    (LOAD&PUSH 5)
11    (CALL2&PUSH 3)                      ; SC-CONVERG-FORM
13    (JMPIFEQTO 4 L31)                   ; $YES
16    (GETVALUE&PUSH 0)                   ; EXP
18    (LOAD&PUSH 5)
19    (CALL2&PUSH 5)                      ; EXP-CONVERG-FORM
21    (JMPIFEQTO 4 L31)                   ; $YES
24    (CONST 2)                           ; $NO
25    L25
25    (UNBIND1)
26    (SKIP&RET 3)
28    L28
28    (CONST 2)                           ; $NO
29    (JMP L25)
31    L31
31    (CONST 4)                           ; $YES
32    (JMP L25)


Disassembly of function #:|(DEFUN EXP-CONVERG-FORM (EXP LIMIT) ...)-171|
(CONST 0) = EXP-CONVERG-FORM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXP-CONVERG-FORM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXP-CONVERG-FORM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXP-CONVERG-FORM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXP-CONVERG-FORM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXP-CONVERG-FORM
8     (SKIP&RET 1)


Disassembly of function EXP-CONVERG-FORM
(CONST 0) = EXP
(CONST 1) = %EINVOLVE
(CONST 2) = $%I
(CONST 3) = FREEOF
(CONST 4) = $NO
(CONST 5) = $%E
(CONST 6) = POWER
(CONST 7) = DIV*
(CONST 8) = SRATSIMP
(CONST 9) = VAR
(CONST 10) = GET-LIMIT
(CONST 11) = 0
(CONST 12) = $YES
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
40 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (GETVALUE&PUSH 0)                   ; EXP
6     (CALL1 1)                           ; %EINVOLVE
8     (STORE 0)
9     (JMPIFNOT L52)
11    (CONST&PUSH 2)                      ; $%I
12    (LOAD&PUSH 1)
13    (CALL2&JMPIF 3 L52)                 ; FREEOF
16    (CONST&PUSH 2)                      ; $%I
17    (GETVALUE&PUSH 0)                   ; EXP
19    (CONST&PUSH 5)                      ; $%E
20    (LOAD&PUSH 3)
21    (CALL2&PUSH 6)                      ; POWER
23    (CALL2&PUSH 7)                      ; DIV*
25    (CALL1 8)                           ; SRATSIMP
27    (SETVALUE 0)                        ; EXP
29    (PUSH)
30    (CALL1&PUSH 1)                      ; %EINVOLVE
32    (CALL2&JMPIFNOT 3 L46)              ; FREEOF
35    (GETVALUE&PUSH 0)                   ; EXP
37    (GETVALUE&PUSH 9)                   ; VAR
39    (LOAD&PUSH 7)
40    (CALL&PUSH 3 10)                    ; GET-LIMIT
43    (JMPIFEQTO 11 L57)                  ; 0
46    L46
46    (CONST 4)                           ; $NO
47    (SKIP 1)
49    L49
49    (UNBIND1)
50    (SKIP&RET 3)
52    L52
52    (CONST 4)                           ; $NO
53    (SKIP 1)
55    (JMP L49)
57    L57
57    (CONST 12)                          ; $YES
58    (SKIP 1)
60    (JMP L49)


Disassembly of function #:|(DEFUN SC-CONVERG-FORM (EXP LIMIT) ...)-172|
(CONST 0) = SC-CONVERG-FORM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SC-CONVERG-FORM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SC-CONVERG-FORM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SC-CONVERG-FORM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SC-CONVERG-FORM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SC-CONVERG-FORM
8     (SKIP&RET 1)


Disassembly of function SC-CONVERG-FORM
(CONST 0) = EXP
(CONST 1) = $EXPAND
(CONST 2) = SIN-SQ-COS-SQ-SUB
(CONST 3) = (%SIN %COS)
(CONST 4) = INVOLVE
(CONST 5) = $NO
(CONST 6) = VAR
(CONST 7) = POLYINX
(CONST 8) = $HIPOW
(CONST 9) = 1
(CONST 10) = SUB*
(CONST 11) = $ASKSIGN
(CONST 12) = $POS
(CONST 13) = $YES
(CONST 14) = SDIFF
(CONST 15) = FREEOF
(CONST 16) = (%SIN)
(CONST 17) = $ODD
(CONST 18) = ASK-INTEGER
(CONST 19) = (%SIN)
(CONST 20) = DIV*
(CONST 21) = GET-LIMIT
(CONST 22) = 0
(CONST 23) = (%COS)
(CONST 24) = (%COS)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
97 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (PUSH-NIL 2)
5     (GETVALUE&PUSH 0)                   ; EXP
7     (CALL1 1)                           ; $EXPAND
9     (SETVALUE 0)                        ; EXP
11    (PUSH)
12    (CALL1&PUSH 2)                      ; SIN-SQ-COS-SQ-SUB
14    (CONST&PUSH 3)                      ; (%SIN %COS)
15    (CALL2 4)                           ; INVOLVE
17    (STORE 1)
18    (JMPIFNOT L131)
21    (LOAD&PUSH 1)
22    (GETVALUE&PUSH 6)                   ; VAR
24    (NIL&PUSH)
25    (CALL 3 7)                          ; POLYINX
28    (JMPIFNOT L44)
30    (LOAD&PUSH 1)
31    (GETVALUE&PUSH 6)                   ; VAR
33    (CALL2&PUSH 8)                      ; $HIPOW
35    (CONST&PUSH 9)                      ; 1
36    (CALL2&PUSH 10)                     ; SUB*
38    (CALL1&PUSH 11)                     ; $ASKSIGN
40    (JMPIFEQTO 12 L136)                 ; $POS
44    L44
44    (GETVALUE&PUSH 6)                   ; VAR
46    (LOAD&PUSH 2)
47    (GETVALUE&PUSH 6)                   ; VAR
49    (CALL2&PUSH 14)                     ; SDIFF
51    (CALL2&JMPIFNOT 15 L141)            ; FREEOF
55    (GETVALUE&PUSH 0)                   ; EXP
57    (CONST&PUSH 16)                     ; (%SIN)
58    (LOAD&PUSH 3)
59    (LIST&PUSH 2)
61    (CALL2 8)                           ; $HIPOW
63    (STORE 0)
64    (JMPIFNOT L90)
66    (PUSH)
67    (CONST&PUSH 17)                     ; $ODD
68    (CALL2&PUSH 18)                     ; ASK-INTEGER
70    (JMPIFNOTEQTO 13 L90)               ; $YES
73    (GETVALUE&PUSH 0)                   ; EXP
75    (CONST&PUSH 19)                     ; (%SIN)
76    (LOAD&PUSH 3)
77    (LIST&PUSH 2)
79    (CALL2&PUSH 20)                     ; DIV*
81    (GETVALUE&PUSH 6)                   ; VAR
83    (LOAD&PUSH 8)
84    (CALL&PUSH 3 21)                    ; GET-LIMIT
87    (JMPIFEQTO 22 L146)                 ; 0
90    L90
90    (GETVALUE&PUSH 0)                   ; EXP
92    (CONST&PUSH 23)                     ; (%COS)
93    (LOAD&PUSH 3)
94    (LIST&PUSH 2)
96    (CALL2 8)                           ; $HIPOW
98    (STORE 0)
99    (JMPIFNOT L125)
101   (PUSH)
102   (CONST&PUSH 17)                     ; $ODD
103   (CALL2&PUSH 18)                     ; ASK-INTEGER
105   (JMPIFNOTEQTO 13 L125)              ; $YES
108   (GETVALUE&PUSH 0)                   ; EXP
110   (CONST&PUSH 24)                     ; (%COS)
111   (LOAD&PUSH 3)
112   (LIST&PUSH 2)
114   (CALL2&PUSH 20)                     ; DIV*
116   (GETVALUE&PUSH 6)                   ; VAR
118   (LOAD&PUSH 8)
119   (CALL&PUSH 3 21)                    ; GET-LIMIT
122   (JMPIFEQTO 22 L151)                 ; 0
125   L125
125   (CONST 5)                           ; $NO
126   (SKIP 2)
128   L128
128   (UNBIND1)
129   (SKIP&RET 3)
131   L131
131   (CONST 5)                           ; $NO
132   (SKIP 2)
134   (JMP L128)
136   L136
136   (CONST 13)                          ; $YES
137   (SKIP 2)
139   (JMP L128)
141   L141
141   (CONST 5)                           ; $NO
142   (SKIP 2)
144   (JMP L128)
146   L146
146   (CONST 13)                          ; $YES
147   (SKIP 2)
149   (JMP L128)
151   L151
151   (CONST 13)                          ; $YES
152   (SKIP 2)
154   (JMP L128)


Disassembly of function #:|(DEFUN IS-A-POLE (EXP SOLTN) ...)-173|
(CONST 0) = IS-A-POLE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IS-A-POLE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IS-A-POLE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IS-A-POLE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IS-A-POLE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; IS-A-POLE
8     (SKIP&RET 1)


Disassembly of function IS-A-POLE
(CONST 0) = EXP
(CONST 1) = EPSILON
(CONST 2) = ADD*
(CONST 3) = VAR
(CONST 4) = MAXIMA-SUBSTITUTE
(CONST 5) = MUL*
(CONST 6) = $RADCAN
(CONST 7) = 0
(CONST 8) = $PLUS
(CONST 9) = GET-LIMIT
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP VAR)
17 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (CONST&PUSH 1)                      ; EPSILON
4     (LOAD&PUSH 5)
5     (CALL2&PUSH 2)                      ; ADD*
7     (GETVALUE&PUSH 3)                   ; VAR
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CALL&PUSH 3 4)                     ; MAXIMA-SUBSTITUTE
14    (CONST&PUSH 1)                      ; EPSILON
15    (CALL2&PUSH 5)                      ; MUL*
17    (CALL1&PUSH 6)                      ; $RADCAN
19    (CONST&PUSH 1)                      ; EPSILON
20    (CONST&PUSH 7)                      ; 0
21    (CONST&PUSH 8)                      ; $PLUS
22    (CALL 4 9)                          ; GET-LIMIT
25    (UNBIND1)
26    (SKIP&RET 3)


Disassembly of function #:|(DEFUN IN-INTERVAL (PLACE LL UL) ...)-174|
(CONST 0) = IN-INTERVAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IN-INTERVAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-INTERVAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-INTERVAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IN-INTERVAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; IN-INTERVAL
8     (SKIP&RET 1)


Disassembly of function IN-INTERVAL
(CONST 0) = LL
(CONST 1) = UL
(CONST 2) = ASK-GREATEQ
(CONST 3) = $YES
(CONST 4) = $NO
(CONST 5) = TEMP
(CONST 6) = "Incorrect limits given to DEFINT:~%~M"
(CONST 7) = (MLIST SIMP)
(CONST 8) = MERROR
(CONST 9) = $IMAGPART
(CONST 10) = 0
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (TEMP LL UL)
writes special variables : (LL UL)
54 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; LL
3     (LOAD 4)
4     (BIND 1)                            ; UL
6     (GETVALUE&PUSH 1)                   ; UL
8     (GETVALUE&PUSH 0)                   ; LL
10    (CALL2&PUSH 2)                      ; ASK-GREATEQ
12    (LOAD&PUSH 0)
13    (JMPIFEQTO 3 L30)                   ; $YES
16    (LOAD&PUSH 0)
17    (JMPIFEQTO 4 L63)                   ; $NO
20    (CONST&PUSH 6)                      ; "Incorrect limits given to DEFINT:~%~M"
21    (CONST&PUSH 7)                      ; (MLIST SIMP)
22    (GETVALUE&PUSH 0)                   ; LL
24    (GETVALUE&PUSH 1)                   ; UL
26    (LIST&PUSH 3)
28    (CALL2 8)                           ; MERROR
30    L30
30    (SKIP 1)
32    (LOAD&PUSH 9)
33    (CALL1&PUSH 9)                      ; $IMAGPART
35    (JMPIFNOTEQTO 10 L78)               ; 0
38    (GETVALUE&PUSH 1)                   ; UL
40    (LOAD&PUSH 10)
41    (CALL2&PUSH 2)                      ; ASK-GREATEQ
43    (LOAD&PUSH 10)
44    (GETVALUE&PUSH 0)                   ; LL
46    (CALL2&PUSH 2)                      ; ASK-GREATEQ
48    (LOAD&PUSH 1)
49    (JMPIFNOTEQTO 3 L56)                ; $YES
52    (LOAD&PUSH 0)
53    (JMPIFEQTO 3 L81)                   ; $YES
56    L56
56    (CONST 4)                           ; $NO
57    (SKIP 2)
59    L59
59    (UNBIND 2)
61    (SKIP&RET 4)
63    L63
63    (GETVALUE 1)                        ; UL
65    (BIND 5)                            ; TEMP
67    (GETVALUE 0)                        ; LL
69    (SETVALUE 1)                        ; UL
71    (GETVALUE 5)                        ; TEMP
73    (SETVALUE 0)                        ; LL
75    (UNBIND1)
76    (JMP L30)
78    L78
78    (CONST 4)                           ; $NO
79    (JMP L59)
81    L81
81    (CONST 3)                           ; $YES
82    (SKIP 2)
84    (JMP L59)


Disassembly of function #:|(DEFUN REAL-ROOTS (EXP VAR) ...)-175|
(CONST 0) = REAL-ROOTS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REAL-ROOTS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REAL-ROOTS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REAL-ROOTS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REAL-ROOTS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REAL-ROOTS
8     (SKIP&RET 1)


Disassembly of function REAL-ROOTS
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = DEFINTDEBUG
(CONST 3) = $%I
(CONST 4) = AMONG
(CONST 5) = $%E
(CONST 6) = $SOLVERADCAN
(CONST 7) = *ROOTS
(CONST 8) = *FAILURES
(CONST 9) = $SOLVETRIGWARN
(CONST 10) = $NO
(CONST 11) = 1
(CONST 12) = SOLVE
(CONST 13) = $FAILURE
(CONST 14) = ROOTLIST
(CONST 15) = $IMAGPART
(CONST 16) = 0
(CONST 17) = $RECTFORM
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ROOTLIST *ROOTS *FAILURES VAR EXP DEFINTDEBUG)
writes special variable : (ROOTLIST)
91 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 2)                        ; DEFINTDEBUG
8     (JMPIF L117)
11    (NIL)
12    L12
12    (PUSH)
13    (CONST&PUSH 3)                      ; $%I
14    (GETVALUE&PUSH 0)                   ; EXP
16    (CALL2&JMPIF 4 L121)                ; AMONG
20    (CONST&PUSH 5)                      ; $%E
21    (GETVALUE&PUSH 0)                   ; EXP
23    (CALL2&JMPIF 4 L121)                ; AMONG
27    (NIL)
28    L28
28    (BIND 6)                            ; $SOLVERADCAN
30    (NIL)
31    (BIND 7)                            ; *ROOTS
33    (NIL)
34    (BIND 8)                            ; *FAILURES
36    (LOAD 9)
37    (BIND 9)                            ; $SOLVETRIGWARN
39    (GETVALUE&PUSH 1)                   ; VAR
41    (GETVALUE&PUSH 0)                   ; EXP
43    (CALL2&JMPIFNOT 4 L125)             ; AMONG
47    (GETVALUE&PUSH 0)                   ; EXP
49    (GETVALUE&PUSH 1)                   ; VAR
51    (CONST&PUSH 11)                     ; 1
52    (CALL 3 12)                         ; SOLVE
55    (GETVALUE 8)                        ; *FAILURES
57    (JMPIF L128)
60    (GETVALUE&PUSH 7)                   ; *ROOTS
62    (NIL)
63    (BIND 14)                           ; ROOTLIST
65    (LOAD&JMPIFNOT 3 L101)
68    L68
68    (LOAD 3)
69    (CAR)
70    (CDR)
71    (CDR)
72    (CAR&PUSH)
73    (CALL1&PUSH 15)                     ; $IMAGPART
75    (JMPIFNOTEQTO 16 L94)               ; 0
78    (LOAD 3)
79    (CAR)
80    (CDR)
81    (CDR)
82    (CAR&PUSH)
83    (CALL1&PUSH 17)                     ; $RECTFORM
85    (LOAD 4)
86    (CDR)
87    (CAR)
88    (CONS&PUSH)
89    (GETVALUE 14)                       ; ROOTLIST
91    (CONS)
92    (SETVALUE 14)                       ; ROOTLIST
94    L94
94    (LOAD 3)
95    (CDR)
96    (CDR)
97    (STORE 3)
98    (LOAD&JMPIF 3 L68)
101   L101
101   (GETVALUE 14)                       ; ROOTLIST
103   (JMPIF L131)
105   (CONST 10)                          ; $NO
106   L106
106   (UNBIND1)
107   (SKIP 1)
109   L109
109   (UNBIND 4)
111   (SKIP 1)
113   (UNBIND 2)
115   (SKIP&RET 3)
117   L117
117   (T)
118   (JMP L12)
121   L121
121   (T)
122   (JMP L28)
125   L125
125   (CONST 10)                          ; $NO
126   (JMP L109)
128   L128
128   (CONST 13)                          ; $FAILURE
129   (JMP L109)
131   L131
131   (GETVALUE 14)                       ; ROOTLIST
133   (JMP L106)


Disassembly of function #:|(DEFUN ASK-GREATEQ (X Y) ...)-176|
(CONST 0) = ASK-GREATEQ
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ASK-GREATEQ>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ASK-GREATEQ
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ASK-GREATEQ
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ASK-GREATEQ>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ASK-GREATEQ
8     (SKIP&RET 1)


Disassembly of function ASK-GREATEQ
(CONST 0) = X
(CONST 1) = Y
(CONST 2) = ZEROA
(CONST 3) = AMONG
(CONST 4) = 0
(CONST 5) = ZEROB
(CONST 6) = EPSILON
(CONST 7) = $INF
(CONST 8) = $MINF
(CONST 9) = $LIMIT
(CONST 10) = $YES
(CONST 11) = $NO
(CONST 12) = -1
(CONST 13) = MUL*
(CONST 14) = ADD*
(CONST 15) = $ASKSIGN
(CONST 16) = ANS
(CONST 17) = ($ZERO $POS)
(CONST 18) = MEMQ
(CONST 19) = $NEG
(CONST 20) = $UNKNOWN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS Y X)
131 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; X
3     (LOAD 4)
4     (BIND 1)                            ; Y
6     (CONST&PUSH 2)                      ; ZEROA
7     (GETVALUE&PUSH 0)                   ; X
9     (CALL2&JMPIF 3 L35)                 ; AMONG
12    (CONST&PUSH 5)                      ; ZEROB
13    (GETVALUE&PUSH 0)                   ; X
15    (CALL2&JMPIF 3 L39)                 ; AMONG
18    (CONST&PUSH 6)                      ; EPSILON
19    (GETVALUE&PUSH 0)                   ; X
21    (CALL2&JMPIFNOT 3 L57)              ; AMONG
24    (CONST&PUSH 4)                      ; 0
25    (CONST 6)                           ; EPSILON
26    L26
26    (PUSH)
27    (GETVALUE&PUSH 0)                   ; X
29    (PUSH-UNBOUND 3)
31    (CALLS1 172)                        ; SUBST
33    (JMP L71)
35    L35
35    (CONST&PUSH 4)                      ; 0
36    (CONST 2)                           ; ZEROA
37    (JMP L26)
39    L39
39    (CONST&PUSH 4)                      ; 0
40    (CONST 5)                           ; ZEROB
41    (JMP L26)
43    L43
43    (GETVALUE&PUSH 0)                   ; X
45    (CALL1 9)                           ; $LIMIT
47    (JMP L71)
49    L49
49    (CONST&PUSH 4)                      ; 0
50    (CONST 2)                           ; ZEROA
51    (JMP L92)
53    L53
53    (CONST&PUSH 4)                      ; 0
54    (CONST 5)                           ; ZEROB
55    (JMP L92)
57    L57
57    (CONST&PUSH 7)                      ; $INF
58    (GETVALUE&PUSH 0)                   ; X
60    (CALL2&JMPIF 3 L43)                 ; AMONG
63    (CONST&PUSH 8)                      ; $MINF
64    (GETVALUE&PUSH 0)                   ; X
66    (CALL2&JMPIF 3 L43)                 ; AMONG
69    (GETVALUE 0)                        ; X
71    L71
71    (PUSH)
72    (CONST&PUSH 2)                      ; ZEROA
73    (GETVALUE&PUSH 1)                   ; Y
75    (CALL2&JMPIF 3 L49)                 ; AMONG
78    (CONST&PUSH 5)                      ; ZEROB
79    (GETVALUE&PUSH 1)                   ; Y
81    (CALL2&JMPIF 3 L53)                 ; AMONG
84    (CONST&PUSH 6)                      ; EPSILON
85    (GETVALUE&PUSH 1)                   ; Y
87    (CALL2&JMPIFNOT 3 L133)             ; AMONG
90    (CONST&PUSH 4)                      ; 0
91    (CONST 6)                           ; EPSILON
92    L92
92    (PUSH)
93    (GETVALUE&PUSH 1)                   ; Y
95    (PUSH-UNBOUND 3)
97    (CALLS1 172)                        ; SUBST
99    (JMP L147)
101   L101
101   (GETVALUE&PUSH 1)                   ; Y
103   (CALL1 9)                           ; $LIMIT
105   (JMP L147)
107   L107
107   (CONST 10)                          ; $YES
108   (JMP L200)
111   L111
111   (CONST 11)                          ; $NO
112   (JMP L200)
115   L115
115   (CONST 11)                          ; $NO
116   (JMP L200)
119   L119
119   (CONST 10)                          ; $YES
120   (JMP L200)
123   L123
123   (CONST 10)                          ; $YES
124   (UNBIND1)
125   (JMP L200)
128   L128
128   (CONST 11)                          ; $NO
129   (UNBIND1)
130   (JMP L200)
133   L133
133   (CONST&PUSH 7)                      ; $INF
134   (GETVALUE&PUSH 1)                   ; Y
136   (CALL2&JMPIF 3 L101)                ; AMONG
139   (CONST&PUSH 8)                      ; $MINF
140   (GETVALUE&PUSH 1)                   ; Y
142   (CALL2&JMPIF 3 L101)                ; AMONG
145   (GETVALUE 1)                        ; Y
147   L147
147   (BIND 1)                            ; Y
149   (LOAD 3)
150   (BIND 0)                            ; X
152   (GETVALUE&PUSH 0)                   ; X
154   (JMPIFEQTO 7 L107)                  ; $INF
157   (GETVALUE&PUSH 0)                   ; X
159   (JMPIFEQTO 8 L111)                  ; $MINF
162   (GETVALUE&PUSH 1)                   ; Y
164   (JMPIFEQTO 7 L115)                  ; $INF
167   (GETVALUE&PUSH 1)                   ; Y
169   (JMPIFEQTO 8 L119)                  ; $MINF
172   (GETVALUE&PUSH 0)                   ; X
174   (CONST&PUSH 12)                     ; -1
175   (GETVALUE&PUSH 1)                   ; Y
177   (CALL2&PUSH 13)                     ; MUL*
179   (CALL2&PUSH 14)                     ; ADD*
181   (CALL1 15)                          ; $ASKSIGN
183   (BIND 16)                           ; ANS
185   (GETVALUE&PUSH 16)                  ; ANS
187   (CONST&PUSH 17)                     ; ($ZERO $POS)
188   (CALL2&JMPIF 18 L123)               ; MEMQ
192   (GETVALUE&PUSH 16)                  ; ANS
194   (JMPIFEQTO 19 L128)                 ; $NEG
198   (CONST 20)                          ; $UNKNOWN
199   (UNBIND1)
200   L200
200   (UNBIND 2)
202   (SKIP 1)
204   (UNBIND 2)
206   (SKIP&RET 3)


Disassembly of function #:|(DEFUN SORT-POLES (POLE-LIST) ...)-177|
(CONST 0) = SORT-POLES
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SORT-POLES>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SORT-POLES
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SORT-POLES
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SORT-POLES>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SORT-POLES
8     (SKIP&RET 1)


Disassembly of function SORT-POLES
(CONST 0) = #<COMPILED-CLOSURE SORT-POLES-1>
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE SORT-POLES-1>
2     (PUSH-UNBOUND 3)
4     (CALLS2 103)                        ; SORT
6     (SKIP&RET 2)


Disassembly of function SORT-POLES-1
(CONST 0) = X
(CONST 1) = Y
(CONST 2) = ASK-GREATEQ
(CONST 3) = $YES
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (Y X)
17 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; X
3     (LOAD 4)
4     (BIND 1)                            ; Y
6     (GETVALUE 0)                        ; X
8     (CAR&PUSH)
9     (GETVALUE 1)                        ; Y
11    (CAR&PUSH)
12    (CALL2&PUSH 2)                      ; ASK-GREATEQ
14    (JMPIFEQTO 3 L22)                   ; $YES
17    (T)
18    L18
18    (UNBIND 2)
20    (SKIP&RET 3)
22    L22
22    (NIL)
23    (JMP L18)


Wrote file binary-clisp/defint.fas
Wrote file /cygdrive/e/temp/maxima/src/defint.lis