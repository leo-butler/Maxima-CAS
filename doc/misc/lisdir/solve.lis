Listing of compilation of file /cygdrive/e/temp/maxima/src/solve.lisp
on 2002-12-17 13:35:29 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/solve.lisp ...

Disassembly of function #:|(IN-PACKAGE "MAXIMA")-1|
(CONST 0) = "MAXIMA"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "MAXIMA"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(MACSYMA-MODULE SOLVE)-2|
(CONST 0) = SOLVE
(CONST 1) = MACSYMA-MODULE
(CONST 2) = (RUNTIME)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE
1     (CONST&PUSH 1)                      ; MACSYMA-MODULE
2     (CONST&PUSH 2)                      ; (RUNTIME)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(LOAD-MACSYMA-MACROS RATMAC STRMAC)-3|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (GENPREFIX V_) (SPECIAL VAR-LIST EXPSUMSPLIT ...) ...)-4|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $BREAKUP T ...)-5-1|
(CONST 0) = $BREAKUP
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $BREAKUP
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $BREAKUP
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $BREAKUP T ...)-5-2|
(CONST 0) = (SPECIAL $BREAKUP)
(CONST 1) = $BREAKUP
(CONST 2) = VARIABLE
(CONST 3) = 
"Causes solutions to cubic and quartic equations to be expressed in
	 terms of common subexpressions."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $BREAKUP)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $BREAKUP
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $BREAKUP
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $BREAKUP
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes solutions to cubic and quartic equations to be expressed in
	 terms of common subexpressions."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $BREAKUP
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $MULTIPLICITIES '$NOT_SET_YET ...)-6-1|
(CONST 0) = $MULTIPLICITIES
(CONST 1) = *VARIABLE-INITIAL-VALUES*
(CONST 2) = $NOT_SET_YET
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $MULTIPLICITIES
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $MULTIPLICITIES
11    (LOAD&PUSH 1)
12    (CONST&PUSH 2)                      ; $NOT_SET_YET
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $MULTIPLICITIES '$NOT_SET_YET ...)-6-2|
(CONST 0) = (SPECIAL $MULTIPLICITIES)
(CONST 1) = $MULTIPLICITIES
(CONST 2) = $NOT_SET_YET
(CONST 3) = VARIABLE
(CONST 4) = 
"Set to a list of the multiplicities of the individual solutions
	 returned by SOLVE, REALROOTS, or ALLROOTS."
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $MULTIPLICITIES)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $MULTIPLICITIES
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $MULTIPLICITIES
8     (CONST&PUSH 2)                      ; $NOT_SET_YET
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $MULTIPLICITIES
12    (CONST&PUSH 3)                      ; VARIABLE
13    (CONST&PUSH 4)                      ; "Set to a list of the multiplicities of the individual solutions
	 returned by SOLVE, REALROOTS, or ALLROOTS."
14    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $MULTIPLICITIES
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $LINSOLVEWARN T ...)-7-1|
(CONST 0) = $LINSOLVEWARN
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $LINSOLVEWARN
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $LINSOLVEWARN
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $LINSOLVEWARN T ...)-7-2|
(CONST 0) = (SPECIAL $LINSOLVEWARN)
(CONST 1) = $LINSOLVEWARN
(CONST 2) = VARIABLE
(CONST 3) = "Needs to be documented."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $LINSOLVEWARN)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $LINSOLVEWARN
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $LINSOLVEWARN
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $LINSOLVEWARN
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Needs to be documented."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $LINSOLVEWARN
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVE_INCONSISTENT_ERROR T ...)-8-1|
(CONST 0) = $SOLVE_INCONSISTENT_ERROR
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVE_INCONSISTENT_ERROR
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVE_INCONSISTENT_ERROR
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVE_INCONSISTENT_ERROR T ...)-8-2|
(CONST 0) = (SPECIAL $SOLVE_INCONSISTENT_ERROR)
(CONST 1) = $SOLVE_INCONSISTENT_ERROR
(CONST 2) = VARIABLE
(CONST 3) = 
"If T gives an MAXIMA-ERROR if SOLVE meets up with inconsistent linear
	 equations.  If NIL, returns ((MLIST SIMP)) in this case."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVE_INCONSISTENT_ERROR)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVE_INCONSISTENT_ERROR
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVE_INCONSISTENT_ERROR
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVE_INCONSISTENT_ERROR
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "If T gives an MAXIMA-ERROR if SOLVE meets up with inconsistent linear
	 equations.  If NIL, returns ((MLIST SIMP)) in this case."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVE_INCONSISTENT_ERROR
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $PROGRAMMODE T ...)-9-1|
(CONST 0) = $PROGRAMMODE
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $PROGRAMMODE
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $PROGRAMMODE
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $PROGRAMMODE T ...)-9-2|
(CONST 0) = (SPECIAL $PROGRAMMODE)
(CONST 1) = $PROGRAMMODE
(CONST 2) = VARIABLE
(CONST 3) = 
"Causes SOLVE to return its answers explicitly as elements
	 in a list rather than printing E-labels."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $PROGRAMMODE)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $PROGRAMMODE
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $PROGRAMMODE
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $PROGRAMMODE
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes SOLVE to return its answers explicitly as elements
	 in a list rather than printing E-labels."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $PROGRAMMODE
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEDECOMPOSES T ...)-10-1|
(CONST 0) = $SOLVEDECOMPOSES
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVEDECOMPOSES
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVEDECOMPOSES
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEDECOMPOSES T ...)-10-2|
(CONST 0) = (SPECIAL $SOLVEDECOMPOSES)
(CONST 1) = $SOLVEDECOMPOSES
(CONST 2) = VARIABLE
(CONST 3) = "Causes SOLVE to use POLYDECOMP in attempting to solve polynomials."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVEDECOMPOSES)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVEDECOMPOSES
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVEDECOMPOSES
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVEDECOMPOSES
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes SOLVE to use POLYDECOMP in attempting to solve polynomials."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVEDECOMPOSES
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEEXPLICIT NIL ...)-11-1|
(CONST 0) = $SOLVEEXPLICIT
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVEEXPLICIT
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVEEXPLICIT
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEEXPLICIT NIL ...)-11-2|
(CONST 0) = (SPECIAL $SOLVEEXPLICIT)
(CONST 1) = $SOLVEEXPLICIT
(CONST 2) = VARIABLE
(CONST 3) = "Causes SOLVE to return implicit solutions i.e. of the form F(x)=0."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVEEXPLICIT)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVEEXPLICIT
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVEEXPLICIT
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVEEXPLICIT
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes SOLVE to return implicit solutions i.e. of the form F(x)=0."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVEEXPLICIT
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEFACTORS T ...)-12-1|
(CONST 0) = $SOLVEFACTORS
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVEFACTORS
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVEFACTORS
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVEFACTORS T ...)-12-2|
(CONST 0) = (SPECIAL $SOLVEFACTORS)
(CONST 1) = $SOLVEFACTORS
(CONST 2) = VARIABLE
(CONST 3) = 
"If T, then SOLVE will try to factor the expression.  The FALSE
	 setting may be desired in zl-SOME cases where factoring is not
	 necessary."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVEFACTORS)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVEFACTORS
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVEFACTORS
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVEFACTORS
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "If T, then SOLVE will try to factor the expression.  The FALSE
	 setting may be desired in zl-SOME cases where factoring is not
	 necessary."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVEFACTORS
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVENULLWARN T ...)-13-1|
(CONST 0) = $SOLVENULLWARN
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVENULLWARN
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVENULLWARN
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVENULLWARN T ...)-13-2|
(CONST 0) = (SPECIAL $SOLVENULLWARN)
(CONST 1) = $SOLVENULLWARN
(CONST 2) = VARIABLE
(CONST 3) = 
"Causes the user will be warned if SOLVE is called with either a
	 null equation list or a null variable list.  For example,
	 SOLVE([],[]); would print two warning messages and return []."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVENULLWARN)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVENULLWARN
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVENULLWARN
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVENULLWARN
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes the user will be warned if SOLVE is called with either a
	 null equation list or a null variable list.  For example,
	 SOLVE([],[]); would print two warning messages and return []."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVENULLWARN
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVETRIGWARN T ...)-14-1|
(CONST 0) = $SOLVETRIGWARN
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVETRIGWARN
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVETRIGWARN
11    (LOAD&PUSH 1)
12    (T&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVETRIGWARN T ...)-14-2|
(CONST 0) = (SPECIAL $SOLVETRIGWARN)
(CONST 1) = $SOLVETRIGWARN
(CONST 2) = VARIABLE
(CONST 3) = 
"Causes SOLVE to print a warning message when it is uses
	 inverse trigonometric functions to solve an equation,
	 thereby losing solutions."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVETRIGWARN)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVETRIGWARN
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVETRIGWARN
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVETRIGWARN
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Causes SOLVE to print a warning message when it is uses
	 inverse trigonometric functions to solve an equation,
	 thereby losing solutions."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVETRIGWARN
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVERADCAN NIL ...)-15-1|
(CONST 0) = $SOLVERADCAN
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVERADCAN
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $SOLVERADCAN
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $SOLVERADCAN NIL ...)-15-2|
(CONST 0) = (SPECIAL $SOLVERADCAN)
(CONST 1) = $SOLVERADCAN
(CONST 2) = VARIABLE
(CONST 3) = 
"SOLVE will use RADCAN which will make SOLVE slower but will allow
	 certain problems containing exponentials and logs to be solved."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $SOLVERADCAN)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $SOLVERADCAN
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $SOLVERADCAN
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; $SOLVERADCAN
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "SOLVE will use RADCAN which will make SOLVE slower but will allow
	 certain problems containing exponentials and logs to be solved."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; $SOLVERADCAN
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMACRO SUBR-FUNCALL (FUNCTION . ARGS) ...)-16|
(CONST 0) = SUBR-FUNCALL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SUBR-FUNCALL>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUBR-FUNCALL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SUBR-FUNCALL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SUBR-FUNCALL>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (CONST 0)                           ; SUBR-FUNCALL
10    (SKIP&RET 1)


Disassembly of function SUBR-FUNCALL
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = ARGS
(CONST 3) = FUNCALL
1 required argument
1 optional argument
No rest parameter
No keyword parameters
reads special variable: (ARGS)
21 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 47 L25)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (BIND 2)                            ; ARGS
16    (CONST&PUSH 3)                      ; FUNCALL
17    (LOAD&PUSH 4)
18    (GETVALUE 2)                        ; ARGS
20    (LIST* 2)
22    (UNBIND1)
23    (SKIP&RET 4)
25    L25
25    (LOAD&PUSH 2)
26    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
28    (SKIP&RET 3)


Disassembly of function #:|(DEFMACRO NZLIST (LLIST) ...)-17|
(CONST 0) = NZLIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NZLIST>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; NZLIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NZLIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NZLIST>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (CONST 0)                           ; NZLIST
10    (SKIP&RET 1)


Disassembly of function NZLIST
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = DO
(CONST 3) = L
(CONST 4) = ((CDR L))
(CONST 5) = ((ZCOUNT 0))
(CONST 6) = 
(((NULL L) ZCOUNT)
 (IF (AND (INTEGERP (CAR L)) (ZEROP (CAR L))) (INCREMENT ZCOUNT)))
1 required argument
1 optional argument
No rest parameter
No keyword parameters
21 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 46 L24)             ; /=
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (CONST&PUSH 2)                      ; DO
12    (CONST&PUSH 3)                      ; L
13    (LOAD&PUSH 2)
14    (CONST 4)                           ; ((CDR L))
15    (LIST*&PUSH 2)
17    (CONST 5)                           ; ((ZCOUNT 0))
18    (CONS&PUSH)
19    (CONST 6)                           ; ((# ZCOUNT) (IF # #))
20    (LIST* 2)
22    (SKIP&RET 4)
24    L24
24    (LOAD&PUSH 2)
25    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
27    (SKIP&RET 3)


Disassembly of function #:|(DEFMACRO ALLROOT (EXP) ...)-18|
(CONST 0) = ALLROOT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ALLROOT>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; ALLROOT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ALLROOT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ALLROOT>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (CONST 0)                           ; ALLROOT
10    (SKIP&RET 1)


Disassembly of function ALLROOT
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = EXP
(CONST 3) = SETQ
(CONST 4) = *FAILURES
(CONST 5) = LIST*
(CONST 6) = MAKE-MEQUAL-SIMP
(CONST 7) = (1 *FAILURES)
1 required argument
1 optional argument
No rest parameter
No keyword parameters
reads special variable: (EXP)
24 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 46 L31)             ; /=
8     (LOAD 2)
9     (CDR)
10    (CAR)
11    (BIND 2)                            ; EXP
13    (CONST&PUSH 3)                      ; SETQ
14    (CONST&PUSH 4)                      ; *FAILURES
15    (CONST&PUSH 5)                      ; LIST*
16    (CONST&PUSH 6)                      ; MAKE-MEQUAL-SIMP
17    (GETVALUE&PUSH 2)                   ; EXP
19    (GETVALUE&PUSH 2)                   ; EXP
21    (LIST&PUSH 3)
23    (CONST 7)                           ; (1 *FAILURES)
24    (LIST*&PUSH 2)
26    (LIST 3)
28    (UNBIND1)
29    (SKIP&RET 3)
31    L31
31    (LOAD&PUSH 2)
32    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
34    (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN $SOLVE (*EQL &OPTIONAL #) ...)-19|
(CONST 0) = $SOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $SOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $SOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $SOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $SOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $SOLVE
8     (SKIP&RET 1)


Disassembly of function $SOLVE
(CONST 0) = (MLIST)
(CONST 1) = $MULTIPLICITIES
(CONST 2) = $KEEPFLOAT
(CONST 3) = $RATFAC
(CONST 4) = *ROOTS
(CONST 5) = *FAILURES
(CONST 6) = BROKEN-NOT-FREEOF
(CONST 7) = MLIST
(CONST 8) = MEQHK
(CONST 9) = MEVAL
(CONST 10) = (MNOTEQUAL MGREATERP MLESSP MGEQP MLEQP)
(CONST 11) = MEMQ
(CONST 12) = "Cannot solve inequalities. -SOLVE"
(CONST 13) = MERROR
(CONST 14) = $LISTCONSTVARS
(CONST 15) = L
(CONST 16) = 0
(CONST 17) = $LISTOFVARS
(CONST 18) = REMC
(CONST 19) = $LISTP
(CONST 20) = $SOLVENULLWARN
(CONST 21) = "~&Got a null variable list, continuing - SOLVE~%"
(CONST 22) = MTELL
(CONST 23) = "~&Got a null equation list, continuing - SOLVE~%"
(CONST 24) = MNUMP
(CONST 25) = ORMAPC
(CONST 26) = "A number was found where a variable was expected -SOLVE"
(CONST 27) = (0)
(CONST 28) = $ALL
(CONST 29) = (MLIST SIMP)
(CONST 30) = SSOLVE
(CONST 31) = $PROGRAMMODE
(CONST 32) = SOLVEX
(CONST 33) = (MLIST)
(CONST 34) = E
(CONST 35) = 
"More unknowns than equations -SOLVE~
		  ~%Unknowns given :  ~%~M~
		  ~%Equations given:  ~%~M"
(CONST 36) = 
"More equations than unknowns -SOLVE~
		  ~%Unknowns given :  ~%~M~
		  ~%Equations given:  ~%~M"
1 required argument
1 optional argument
No rest parameter
No keyword parameters
reads special variables: (E $SOLVENULLWARN L $PROGRAMMODE)
writes special variables : (L $MULTIPLICITIES)
215 byte-code instructions:
0     (BOUNDP 1)
2     (PUSH)
3     (UNBOUND->NIL 2)
5     (CONST&PUSH 0)                      ; (MLIST)
6     (LIST 1)
8     (SETVALUE 1)                        ; $MULTIPLICITIES
10    (NIL&PUSH)
11    (NIL)
12    (BIND 2)                            ; $KEEPFLOAT
14    (NIL)
15    (BIND 3)                            ; $RATFAC
17    (NIL)
18    (BIND 4)                            ; *ROOTS
20    (NIL)
21    (BIND 5)                            ; *FAILURES
23    (NIL)
24    (BIND 6)                            ; BROKEN-NOT-FREEOF
26    (LOAD 19)
28    (JMPIFATOM L73)
30    (LOAD 19)
32    (CAR)
33    (CAR&PUSH)
34    (JMPIFEQTO 7 L77)                   ; MLIST
37    (LOAD 19)
39    (CAR)
40    (CAR&PUSH)
41    (CONST&PUSH 10)                     ; (MNOTEQUAL MGREATERP MLESSP ...)
42    (CALL2&JMPIF 11 L89)                ; MEMQ
45    (LOAD&PUSH 19)
46    (CALL1 8)                           ; MEQHK
48    L48
48    (PUSH)
49    (NIL)
50    (CONS)
51    L51
51    (STORE 15)
53    (LOAD&JMPIFNOT 16 L187)
57    (LOAD&PUSH 18)
58    (CALL1&JMPIF 19 L104)               ; $LISTP
61    (LOAD&PUSH 18)
62    (LIST 1)
64    L64
64    (STORE 18)
66    (LOAD&JMPIFNOT 18 L244)
70    (JMP L249)
73    L73
73    (LOAD 19)
75    (JMP L48)
77    L77
77    (CONST&PUSH 8)                      ; MEQHK
78    (CONST&PUSH 9)                      ; MEVAL
79    (LOAD&CDR&PUSH 21)
81    (CALLSR&PUSH 0 22)                  ; MAPCAR
84    (CALLSR 0 22)                       ; MAPCAR
87    (JMP L51)
89    L89
89    (CONST&PUSH 12)                     ; "Cannot solve inequalities. -SOLVE"
90    (CALL1 13)                          ; MERROR
92    (JMP L51)
94    L94
94    (LOAD 22)
96    (JMP L231)
99    L99
99    (PUSH)
100   (CALL1 18)                          ; REMC
102   (JMP L64)
104   L104
104   (CONST&SYMBOL-FUNCTION&PUSH 9)      ; MEVAL
106   (LOAD&CDR&PUSH 19)
108   (CALLSR 0 22)                       ; MAPCAR
111   (JMP L64)
113   L113
113   (CONST&PUSH 21)                     ; "~&Got a null variable list, continuing - SOLVE~%"
114   (CALL1 22)                          ; MTELL
116   (LOAD&JMPIFNOT 15 L252)
120   (JMP L259)
123   L123
123   (CONST 28)                          ; $ALL
125   (JMP L348)
128   L128
128   (CONST&PUSH 29)                     ; (MLIST SIMP)
129   (LIST 1)
131   (JMP L348)
134   L134
134   (LOAD&CAR&PUSH 15)
136   (LOAD&CAR&PUSH 19)
138   (CALL2 30)                          ; SSOLVE
140   (JMP L348)
143   L143
143   (CONST&PUSH 0)                      ; (MLIST)
144   (LOAD&PUSH 16)
145   (LIST 2)
147   (JMP L348)
150   L150
150   (LOAD&PUSH 15)
151   (LOAD&PUSH 19)
152   (GETVALUE 31)                       ; $PROGRAMMODE
154   (NOT)
155   (PUSH)
156   (T&PUSH)
157   (CALL 4 32)                         ; SOLVEX
160   (STORE 15)
162   (CDR)
163   (JMPIFNOT L172)
165   (LOAD 15)
167   (CDR)
168   (CAR&PUSH)
169   (CALL1&JMPIFNOT 19 L143)            ; $LISTP
172   L172
172   (LOAD 15)
174   (JMP L348)
177   L177
177   (LOAD 20)
179   (JMP L322)
182   L182
182   (CONST 35)                          ; "More unknowns than equations -SOLVE~
		  ~%Unknowns given :  ~%~M~
		  ~%Equations given:  ~%~M"
184   (JMP L337)
187   L187
187   (NIL)
188   (BIND 14)                           ; $LISTCONSTVARS
190   (LOAD 18)
192   (BIND 15)                           ; L
194   (CONST&PUSH 16)                     ; 0
195   (GETVALUE 15)                       ; L
197   (JMPIFNOT L222)
199   L199
199   (GETVALUE 15)                       ; L
201   (CAR&PUSH)
202   (CALLS2&JMPIFNOT 12 L213)           ; INTEGERP
205   (GETVALUE 15)                       ; L
207   (CAR&PUSH)
208   (CALLS2&JMPIFNOT 145 L213)          ; ZEROP
211   (LOAD&INC&STORE 0)
213   L213
213   (GETVALUE 15)                       ; L
215   (CDR)
216   (SETVALUE 15)                       ; L
218   (GETVALUE 15)                       ; L
220   (JMPIF L199)
222   L222
222   (POP)
223   (UNBIND1)
224   (PUSH)
225   (CALLS2&JMPIF 145 L94)              ; ZEROP
229   (LOAD 18)
231   L231
231   (PUSH)
232   (CALL1 17)                          ; $LISTOFVARS
234   (CDR)
235   (UNBIND1)
236   (STORE 18)
238   (JMPIF L99)
241   (LOAD&JMPIF 18 L249)
244   L244
244   (GETVALUE 20)                       ; $SOLVENULLWARN
246   (JMPIF L113)
249   L249
249   (LOAD&JMPIF 15 L259)
252   L252
252   (GETVALUE 20)                       ; $SOLVENULLWARN
254   (JMPIFNOT L259)
256   (CONST&PUSH 23)                     ; "~&Got a null equation list, continuing - SOLVE~%"
257   (CALL1 22)                          ; MTELL
259   L259
259   (CONST&SYMBOL-FUNCTION&PUSH 24)     ; MNUMP
261   (LOAD&PUSH 19)
262   (CALL2&JMPIFNOT 25 L268)            ; ORMAPC
265   (CONST&PUSH 26)                     ; "A number was found where a variable was expected -SOLVE"
266   (CALL1 13)                          ; MERROR
268   L268
268   (LOAD&PUSH 15)
269   (CONST&PUSH 27)                     ; (0)
270   (CALLS2&JMPIF 2 L123)               ; EQUAL
274   (LOAD&JMPIFNOT 18 L128)
278   (LOAD&JMPIFNOT 15 L128)
282   (LOAD 18)
284   (CDR)
285   (JMPIF L293)
287   (LOAD 15)
289   (CDR)
290   (JMPIFNOT L134)
293   L293
293   (LOAD&JMPIF 16 L150)
297   (LOAD&PUSH 18)
298   (CALLS2&PUSH 71)                    ; LENGTH
300   (LOAD&PUSH 16)
301   (CALLS2&PUSH 71)                    ; LENGTH
303   (CALLSR&JMPIF 1 45 L150)            ; =
308   (CONST&PUSH 33)                     ; (MLIST)
310   (LOAD 19)
312   (CONS&PUSH)
313   (LOAD&PUSH 20)
314   (CALL1&JMPIF 19 L177)               ; $LISTP
318   (CONST&PUSH 0)                      ; (MLIST)
319   (LOAD&PUSH 21)
320   (LIST 2)
322   L322
322   (BIND 34)                           ; E
324   (LOAD&PUSH 22)
325   (CALLS2&PUSH 71)                    ; LENGTH
327   (LOAD&PUSH 20)
328   (CALLS2&PUSH 71)                    ; LENGTH
330   (CALLSR&JMPIF 1 48 L182)            ; >
335   (CONST 36)                          ; "More equations than unknowns -SOLVE~
		  ~%Unknowns given :  ~%~M~
		  ~%Equations given:  ~%~M"
337   L337
337   (PUSH)
338   (LOAD&PUSH 4)
339   (GETVALUE&PUSH 34)                  ; E
341   (CALL 3 13)                         ; MERROR
344   (UNBIND1)
345   (SKIP 1)
347   (NIL)
348   L348
348   (UNBIND 5)
350   (SKIP&RET 5)


Disassembly of function #:|(DEFUN REMC (LST) ...)-20|
(CONST 0) = REMC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REMC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REMC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REMC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REMC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REMC
8     (SKIP&RET 1)


Disassembly of function REMC
(CONST 0) = L
(CONST 1) = MAXIMA-CONSTANTP
(CONST 2) = $CONSTANTP
(CONST 3) = ANDMAPC
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (L)
writes special variable : (L)
31 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (PUSH-NIL 2)
5     (GETVALUE 0)                        ; L
7     (JMPIFNOT L34)
9     L9
9     (GETVALUE 0)                        ; L
11    (CAR)
12    (STORE 1)
13    (JMPIFATOM L40)
15    (CONST&SYMBOL-FUNCTION&PUSH 2)      ; $CONSTANTP
17    (LOAD&CDR&PUSH 2)
19    (CALL2&JMPIFNOT 3 L25)              ; ANDMAPC
22    L22
22    (LOAD&PUSH 1)
23    (LOAD&CONS&STORE 0)
25    L25
25    (GETVALUE 0)                        ; L
27    (CDR)
28    (SETVALUE 0)                        ; L
30    (GETVALUE 0)                        ; L
32    (JMPIF L9)
34    L34
34    (POP)
35    (SKIP 1)
37    (UNBIND1)
38    (SKIP&RET 2)
40    L40
40    (LOAD&PUSH 1)
41    (CALL1&JMPIFNOT 1 L22)              ; MAXIMA-CONSTANTP
44    (JMP L25)


Disassembly of function #:|(DECLARE-TOP (SPECIAL MULTI))-21|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SSOLVE (EXP *VAR &AUX ...) ...)-22|
(CONST 0) = SSOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SSOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SSOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SSOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SSOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SSOLVE
8     (SKIP&RET 1)


Disassembly of function SSOLVE
(CONST 0) = EXP
(CONST 1) = *VAR
(CONST 2) = EQUATIONS
(CONST 3) = MULTI
(CONST 4) = $SOLVETRIGWARN
(CONST 5) = $ALL
(CONST 6) = 1
(CONST 7) = SOLVE
(CONST 8) = *ROOTS
(CONST 9) = *FAILURES
(CONST 10) = (MLIST)
(CONST 11) = $PROGRAMMODE
(CONST 12) = (MLIST)
(CONST 13) = #<COMPILED-CLOSURE SSOLVE-1>
(CONST 14) = $SOLVEEXPLICIT
(CONST 15) = MAP2C
(CONST 16) = $MULTIPLICITIES
(CONST 17) = $DISPFLAG
(CONST 18) = "The roots of:~%"
(CONST 19) = MTELL
(CONST 20) = SOLVE2
(CONST 21) = "Solution:~%"
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(MULTI EQUATIONS $DISPFLAG $SOLVEEXPLICIT $PROGRAMMODE *FAILURES *ROOTS EXP
 *VAR $SOLVETRIGWARN)
writes special variable : ($MULTIPLICITIES)
90 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; *VAR
6     (NIL)
7     (BIND 2)                            ; EQUATIONS
9     (NIL)
10    (BIND 3)                            ; MULTI
12    (GETVALUE 4)                        ; $SOLVETRIGWARN
14    (BIND 4)                            ; $SOLVETRIGWARN
16    (GETVALUE 1)                        ; *VAR
18    (JMPIFNOT L73)
20    (GETVALUE&PUSH 0)                   ; EXP
22    (GETVALUE&PUSH 1)                   ; *VAR
24    (CONST&PUSH 6)                      ; 1
25    (CALL 3 7)                          ; SOLVE
28    (GETVALUE 8)                        ; *ROOTS
30    (JMPIF L36)
32    (GETVALUE 9)                        ; *FAILURES
34    (JMPIFNOT L77)
36    L36
36    (GETVALUE 11)                       ; $PROGRAMMODE
38    (JMPIF L87)
40    (GETVALUE 9)                        ; *FAILURES
42    (JMPIFNOT L49)
44    (GETVALUE 14)                       ; $SOLVEEXPLICIT
46    (JMPIFNOT L118)
49    L49
49    (GETVALUE 8)                        ; *ROOTS
51    (JMPIFNOT L64)
53    L53
53    (GETVALUE 17)                       ; $DISPFLAG
55    (JMPIFNOT L60)
57    (CONST&PUSH 21)                     ; "Solution:~%"
58    (CALL1 19)                          ; MTELL
60    L60
60    (GETVALUE&PUSH 8)                   ; *ROOTS
62    (CALL1 20)                          ; SOLVE2
64    L64
64    (CONST&PUSH 12)                     ; (MLIST)
65    (GETVALUE 2)                        ; EQUATIONS
67    (CONS)
68    (UNBIND1)
69    L69
69    (UNBIND 4)
71    (SKIP&RET 3)
73    L73
73    (CONST 5)                           ; $ALL
74    (UNBIND1)
75    (JMP L69)
77    L77
77    (CONST&PUSH 10)                     ; (MLIST)
78    (LIST 1)
80    (UNBIND1)
81    (JMP L69)
83    L83
83    (GETVALUE 8)                        ; *ROOTS
85    (JMP L100)
87    L87
87    (CONST&PUSH 12)                     ; (MLIST)
88    (CONST&PUSH 13)                     ; #<COMPILED-CLOSURE SSOLVE-1>
89    (GETVALUE 14)                       ; $SOLVEEXPLICIT
91    (JMPIF L83)
93    (GETVALUE&PUSH 8)                   ; *ROOTS
95    (GETVALUE&PUSH 9)                   ; *FAILURES
97    (CALLSR 2 35)                       ; NCONC
100   L100
100   (PUSH)
101   (CALL2&PUSH 15)                     ; MAP2C
103   (CALLS2 73)                         ; NREVERSE
105   (CONS&PUSH)
106   (CONST&PUSH 12)                     ; (MLIST)
107   (GETVALUE&PUSH 3)                   ; MULTI
109   (CALLS2 73)                         ; NREVERSE
111   (CONS)
112   (SETVALUE 16)                       ; $MULTIPLICITIES
114   (POP)
115   (UNBIND1)
116   (JMP L69)
118   L118
118   (GETVALUE 17)                       ; $DISPFLAG
120   (JMPIFNOT L125)
122   (CONST&PUSH 18)                     ; "The roots of:~%"
123   (CALL1 19)                          ; MTELL
125   L125
125   (GETVALUE&PUSH 9)                   ; *FAILURES
127   (CALL1 20)                          ; SOLVE2
129   (GETVALUE 8)                        ; *ROOTS
131   (JMPIFNOT L64)
134   (JMP L53)


Disassembly of function SSOLVE-1
(CONST 0) = MULT
(CONST 1) = MULTI
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULTI MULT)
writes special variable : (MULTI)
9 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; MULT
3     (GETVALUE&PUSH 0)                   ; MULT
5     (GETVALUE 1)                        ; MULTI
7     (CONS)
8     (SETVALUE 1)                        ; MULTI
10    (LOAD 5)
11    (UNBIND1)
12    (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN SOLVE (*EXP *VAR MULT ...) ...)-23|
(CONST 0) = SOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVE
8     (SKIP&RET 1)


Disassembly of function SOLVE
(CONST 0) = *EXP
(CONST 1) = *VAR
(CONST 2) = MULT
(CONST 3) = GENVAR
(CONST 4) = $DERIVSUBST
(CONST 5) = MRATCHECK
(CONST 6) = FLOAT2RAT
(CONST 7) = EXP
(CONST 8) = *MYVAR
(CONST 9) = $SAVEFACTORS
(CONST 10) = FACTORS
(CONST 11) = *HAS*VAR
(CONST 12) = GENPAIRS
(CONST 13) = $DONTFACTOR
(CONST 14) = TEMP
(CONST 15) = *G
(CONST 16) = CHECKFACTORS
(CONST 17) = VARLIST
(CONST 18) = EXPSUMSPLIT
(CONST 19) = $RATFAC
(CONST 20) = RATF
(CONST 21) = RATDISREP
(CONST 22) = 0
(CONST 23) = SOLVE3
(CONST 24) = (MEQUAL SIMP)
(CONST 25) = 1
(CONST 26) = *FAILURES
(CONST 27) = MEQHK
(CONST 28) = (0)
(CONST 29) = FREE
(CONST 30) = MAXIMA-SUBSTITUTE
(CONST 31) = $SOLVERADCAN
(CONST 32) = RADCAN1
(CONST 33) = EASY-CASES
(CONST 34) = *ROOTS
(CONST 35) = ROOTSORT
(CONST 36) = FIRST-ORDER-P
(CONST 37) = (MTIMES)
(CONST 38) = -1
(CONST 39) = DIV*
(CONST 40) = FNEWVAR
(CONST 41) = VARSORT
(CONST 42) = RATREP*
(CONST 43) = TRIG-SUBST-P
(CONST 44) = TRIG-SUBST
(CONST 45) = SPECASEP
(CONST 46) = SOLVE1A
(CONST 47) = SOLVENTHP
(CONST 48) = SOLVENTH
(CONST 49) = $SOLVEFACTORS
(CONST 50) = PFACTOR
(CONST 51) = MAP2C
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
($SOLVEFACTORS *G VARLIST MULT FACTORS $SOLVERADCAN *FAILURES *ROOTS TEMP EXP
 *VAR *EXP)
writes special variables : (*G VARLIST FACTORS *MYVAR *VAR TEMP *FAILURES *ROOTS EXP)
266 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; *EXP
3     (LOAD 5)
4     (BIND 1)                            ; *VAR
6     (LOAD 7)
7     (BIND 2)                            ; MULT
9     (NIL)
10    (BIND 3)                            ; GENVAR
12    (NIL)
13    (BIND 4)                            ; $DERIVSUBST
15    (GETVALUE&PUSH 0)                   ; *EXP
17    (CALL1&PUSH 5)                      ; MRATCHECK
19    (CALL1 6)                           ; FLOAT2RAT
21    (BIND 7)                            ; EXP
23    (GETVALUE 1)                        ; *VAR
25    (BIND 8)                            ; *MYVAR
27    (T)
28    (BIND 9)                            ; $SAVEFACTORS
30    (NIL)
31    (BIND 10)                           ; FACTORS
33    (NIL)
34    (BIND 11)                           ; *HAS*VAR
36    (NIL)
37    (BIND 12)                           ; GENPAIRS
39    (NIL)
40    (BIND 13)                           ; $DONTFACTOR
42    (NIL)
43    (BIND 14)                           ; TEMP
45    (NIL&PUSH)
46    (NIL)
47    (BIND 15)                           ; *G
49    (NIL)
50    (BIND 16)                           ; CHECKFACTORS
52    (NIL)
53    (BIND 17)                           ; VARLIST
55    (NIL)
56    (BIND 18)                           ; EXPSUMSPLIT
58    (T)
59    (BIND 19)                           ; $RATFAC
61    (GETVALUE&PUSH 7)                   ; EXP
63    (CALL1&PUSH 20)                     ; RATF
65    (CALL1 21)                          ; RATDISREP
67    (SETVALUE 7)                        ; EXP
69    (UNBIND1)
70    L70
70    (GETVALUE 7)                        ; EXP
72    (JMPIFCONSP L216)
75    (GETVALUE&PUSH 7)                   ; EXP
77    (GETVALUE 1)                        ; *VAR
79    (JMPIFEQ L132)
81    (GETVALUE&PUSH 7)                   ; EXP
83    (JMPIFEQTO 22 L137)                 ; 0
86    (LOAD&JMPIFNOT 12 L113)
89    L89
89    (GETVALUE&PUSH 14)                  ; TEMP
91    (GETVALUE&PUSH 1)                   ; *VAR
93    (GETVALUE&PUSH 34)                  ; *ROOTS
95    (PUSH-UNBOUND 3)
97    (CALLS1 172)                        ; SUBST
99    (SETVALUE 34)                       ; *ROOTS
101   (GETVALUE&PUSH 14)                  ; TEMP
103   (GETVALUE&PUSH 1)                   ; *VAR
105   (GETVALUE&PUSH 26)                  ; *FAILURES
107   (PUSH-UNBOUND 3)
109   (CALLS1 172)                        ; SUBST
111   (SETVALUE 26)                       ; *FAILURES
113   L113
113   (GETVALUE&PUSH 34)                  ; *ROOTS
115   (CALL1 35)                          ; ROOTSORT
117   (GETVALUE&PUSH 26)                  ; *FAILURES
119   (CALL1 35)                          ; ROOTSORT
121   L121
121   (NIL)
122   (UNBIND 4)
124   (SKIP 1)
126   (UNBIND 5)
128   L128
128   (UNBIND 8)
130   (SKIP&RET 4)
132   L132
132   (CONST 22)                          ; 0
134   (JMP L289)
137   L137
137   (CONST&PUSH 24)                     ; (MEQUAL SIMP)
138   (GETVALUE&PUSH 1)                   ; *VAR
140   (GETVALUE&PUSH 1)                   ; *VAR
142   (LIST&PUSH 3)
144   (CONST&PUSH 25)                     ; 1
145   (GETVALUE 26)                       ; *FAILURES
147   (LIST* 2)
149   (SETVALUE 26)                       ; *FAILURES
151   (LOAD&JMPIFNOT 12 L113)
154   (JMP L89)
157   L157
157   (CONST&PUSH 24)                     ; (MEQUAL SIMP)
158   (GETVALUE&PUSH 1)                   ; *VAR
160   (GETVALUE&PUSH 1)                   ; *VAR
162   (LIST&PUSH 3)
164   (CONST&PUSH 25)                     ; 1
165   (GETVALUE 26)                       ; *FAILURES
167   (LIST* 2)
169   (SETVALUE 26)                       ; *FAILURES
171   (UNBIND 4)
173   (SKIP 1)
175   (UNBIND 5)
177   (JMP L128)
179   L179
179   (PUSH-UNBOUND 1)
181   (CALLS2&STORE 143 12)               ; GENSYM
184   (PUSH)
185   (GETVALUE&PUSH 1)                   ; *VAR
187   (GETVALUE&PUSH 7)                   ; EXP
189   (CALL 3 30)                         ; MAXIMA-SUBSTITUTE
192   (SETVALUE 7)                        ; EXP
194   (GETVALUE 1)                        ; *VAR
196   (SETVALUE 14)                       ; TEMP
198   (LOAD 12)
199   (SETVALUE 1)                        ; *VAR
201   (SETVALUE 8)                        ; *MYVAR
203   (GETVALUE 31)                       ; $SOLVERADCAN
205   (JMPIFNOT L253)
207   (JMP L244)
209   L209
209   (LOAD&JMPIFNOT 12 L113)
213   (JMP L89)
216   L216
216   (GETVALUE&PUSH 7)                   ; EXP
218   (CALL1 27)                          ; MEQHK
220   (SETVALUE 7)                        ; EXP
222   (PUSH)
223   (CONST&PUSH 28)                     ; (0)
224   (CALLS2&JMPIF 2 L157)               ; EQUAL
228   (GETVALUE&PUSH 7)                   ; EXP
230   (GETVALUE&PUSH 1)                   ; *VAR
232   (CALL2&JMPIF 29 L121)               ; FREE
236   (GETVALUE 1)                        ; *VAR
238   (JMPIFCONSP L179)
240   (GETVALUE 31)                       ; $SOLVERADCAN
242   (JMPIFNOT L253)
244   L244
244   (GETVALUE&PUSH 7)                   ; EXP
246   (CALL1 32)                          ; RADCAN1
248   (SETVALUE 7)                        ; EXP
250   (JMPIFATOM L70)
253   L253
253   (GETVALUE&PUSH 7)                   ; EXP
255   (GETVALUE&PUSH 1)                   ; *VAR
257   (CALL2&JMPIF 33 L209)               ; EASY-CASES
260   (GETVALUE&PUSH 7)                   ; EXP
262   (GETVALUE&PUSH 1)                   ; *VAR
264   (CALL2 36)                          ; FIRST-ORDER-P
266   (SETVALUE 10)                       ; FACTORS
268   (JMPIFNOT L364)
271   (CONST&PUSH 37)                     ; (MTIMES)
273   (CONST&PUSH 38)                     ; -1
275   (GETVALUE 10)                       ; FACTORS
277   (CDR&PUSH)
278   (GETVALUE 10)                       ; FACTORS
280   (CAR&PUSH)
281   (CALL2&PUSH 39)                     ; DIV*
283   (LIST&PUSH 3)
285   (CALL1&PUSH 20)                     ; RATF
287   (CALL1 21)                          ; RATDISREP
289   L289
289   (PUSH)
290   (GETVALUE&PUSH 2)                   ; MULT
292   (CALL2 23)                          ; SOLVE3
294   (LOAD&JMPIFNOT 12 L113)
298   (JMP L89)
301   L301
301   (GETVALUE&PUSH 7)                   ; EXP
303   (LOAD&PUSH 1)
304   (CALL2 44)                          ; TRIG-SUBST
306   (SETVALUE 7)                        ; EXP
308   (PUSH)
309   (CALL1 40)                          ; FNEWVAR
311   (GETVALUE&PUSH 17)                  ; VARLIST
313   (CALL1 41)                          ; VARSORT
315   (SETVALUE 17)                       ; VARLIST
317   (GETVALUE&PUSH 7)                   ; EXP
319   (CALL1 42)                          ; RATREP*
321   (CDR)
322   (CAR)
323   (SETVALUE 7)                        ; EXP
325   (GETVALUE 17)                       ; VARLIST
327   (STORE 3)
328   (JMP L408)
331   L331
331   (GETVALUE&PUSH 7)                   ; EXP
333   (GETVALUE&PUSH 2)                   ; MULT
335   (CALL2 46)                          ; SOLVE1A
337   (LOAD&JMPIFNOT 12 L113)
341   (JMP L89)
344   L344
344   (GETVALUE&PUSH 7)                   ; EXP
346   (GETVALUE&PUSH 15)                  ; *G
348   (CALL2 48)                          ; SOLVENTH
350   (LOAD&JMPIFNOT 12 L113)
354   (JMP L89)
357   L357
357   (GETVALUE&PUSH 7)                   ; EXP
359   (CALL1 50)                          ; PFACTOR
361   (JMP L464)
364   L364
364   (GETVALUE&PUSH 1)                   ; *VAR
366   (LIST 1)
368   (SETVALUE 17)                       ; VARLIST
370   (GETVALUE&PUSH 7)                   ; EXP
372   (CALL1 40)                          ; FNEWVAR
374   (GETVALUE&PUSH 17)                  ; VARLIST
376   (CALL1 41)                          ; VARSORT
378   (SETVALUE 17)                       ; VARLIST
380   (NIL&PUSH)
381   (GETVALUE&PUSH 7)                   ; EXP
383   (CALL1 42)                          ; RATREP*
385   (CDR)
386   (CAR&PUSH)
387   (GETVALUE&PUSH 17)                  ; VARLIST
389   (GETVALUE&PUSH 17)                  ; VARLIST
391   (CALL1&PUSH 43)                     ; TRIG-SUBST-P
393   (GETVALUE&PUSH 1)                   ; *VAR
395   (NIL)
396   (CONS)
397   (SETVALUE 17)                       ; VARLIST
399   (LOAD&JMPIF 0 L301)
403   (LOAD 1)
404   (STORE 3)
405   (LOAD 2)
406   (SETVALUE 7)                        ; EXP
408   L408
408   (LOAD 3)
409   (SETVALUE 17)                       ; VARLIST
411   (SKIP 4)
413   (GETVALUE 7)                        ; EXP
415   (JMPIFATOM L70)
418   (GETVALUE&PUSH 7)                   ; EXP
420   (CALL1&JMPIF 45 L331)               ; SPECASEP
424   (GETVALUE 7)                        ; EXP
426   (JMPIFATOM L452)
428   (GETVALUE 7)                        ; EXP
430   (CDR)
431   (CDR)
432   (JMPIFNOT L452)
434   (GETVALUE 7)                        ; EXP
436   (CDR)
437   (CDR)
438   (CDR&PUSH)
439   (GETVALUE 7)                        ; EXP
441   (CDR)
442   (CAR&PUSH)
443   (CALL2 47)                          ; SOLVENTHP
445   (SETVALUE 15)                       ; *G
447   (PUSH)
448   (JMPIFNOTEQTO 25 L344)              ; 1
452   L452
452   (CONST&SYMBOL-FUNCTION&PUSH 46)     ; SOLVE1A
454   (GETVALUE 49)                       ; $SOLVEFACTORS
456   (JMPIF L357)
459   (GETVALUE&PUSH 7)                   ; EXP
461   (CONST&PUSH 25)                     ; 1
462   (LIST 2)
464   L464
464   (PUSH)
465   (CALL2 51)                          ; MAP2C
467   (LOAD&JMPIFNOT 12 L113)
471   (JMP L89)


Disassembly of function #:|(DEFUN FLOAT2RAT (EXP) ...)-24|
(CONST 0) = FLOAT2RAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FLOAT2RAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FLOAT2RAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FLOAT2RAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FLOAT2RAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FLOAT2RAT
8     (SKIP&RET 1)


Disassembly of function FLOAT2RAT
(CONST 0) = EXP
(CONST 1) = PREP1
(CONST 2) = (RAT SIMP)
(CONST 3) = SPECREPP
(CONST 4) = FLOAT2RAT
(CONST 5) = RECUR-APPLY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
writes special variable : (EXP)
28 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALLS2&JMPIF 15 L26)               ; FLOATP
8     (GETVALUE 0)                        ; EXP
10    (JMPIFATOM L43)
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CALL1&JMPIF 3 L43)                 ; SPECREPP
17    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; FLOAT2RAT
19    (GETVALUE&PUSH 0)                   ; EXP
21    (CALL2 5)                           ; RECUR-APPLY
23    L23
23    (UNBIND1)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE&PUSH 0)                   ; EXP
28    (CALL1 1)                           ; PREP1
30    (SETVALUE 0)                        ; EXP
32    (CONST&PUSH 2)                      ; (RAT SIMP)
33    (GETVALUE 0)                        ; EXP
35    (CAR&PUSH)
36    (GETVALUE 0)                        ; EXP
38    (CDR&PUSH)
39    (LIST 3)
41    (JMP L23)
43    L43
43    (GETVALUE 0)                        ; EXP
45    (JMP L23)


Disassembly of function #:|(DEFUN EASY-CASES (*EXP *VAR) ...)-25|
(CONST 0) = EASY-CASES
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EASY-CASES>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EASY-CASES
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EASY-CASES
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EASY-CASES>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EASY-CASES
8     (SKIP&RET 1)


Disassembly of function EASY-CASES
(CONST 0) = *EXP
(CONST 1) = *VAR
(CONST 2) = MTIMES
(CONST 3) = 1
(CONST 4) = SOLVE
(CONST 5) = MEXP
(CONST 6) = MEXPRAT
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*VAR *EXP)
57 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; *EXP
3     (LOAD 4)
4     (BIND 1)                            ; *VAR
6     (GETVALUE 0)                        ; *EXP
8     (CAR)
9     (CAR&PUSH)
10    (JMPIFEQTO 2 L25)                   ; MTIMES
13    (GETVALUE 0)                        ; *EXP
15    (CAR)
16    (CAR&PUSH)
17    (JMPIFEQTO 5 L66)                   ; MEXP
20    (NIL)
21    L21
21    (UNBIND 2)
23    (SKIP&RET 3)
25    L25
25    (GETVALUE 0)                        ; *EXP
27    (CDR&PUSH)
28    (LOAD&JMPIFNOT 0 L44)
31    L31
31    (LOAD&CAR&PUSH 0)
33    (GETVALUE&PUSH 1)                   ; *VAR
35    (CONST&PUSH 3)                      ; 1
36    (CALL 3 4)                          ; SOLVE
39    (LOAD&CDR&STORE 0)
41    (LOAD&JMPIF 0 L31)
44    L44
44    (SKIP 1)
46    (CONST 2)                           ; MTIMES
47    (JMP L21)
49    L49
49    (GETVALUE 0)                        ; *EXP
51    (CDR)
52    (CAR&PUSH)
53    (GETVALUE&PUSH 1)                   ; *VAR
55    (GETVALUE 0)                        ; *EXP
57    (CDR)
58    (CDR)
59    (CAR&PUSH)
60    (CALL 3 4)                          ; SOLVE
63    (CONST 6)                           ; MEXPRAT
64    (JMP L21)
66    L66
66    (GETVALUE 0)                        ; *EXP
68    (CDR)
69    (CDR)
70    (CAR&PUSH)
71    (CALLS2&JMPIFNOT 12 L82)            ; INTEGERP
74    (GETVALUE 0)                        ; *EXP
76    (CDR)
77    (CDR)
78    (CAR&PUSH)
79    (CALLS2&JMPIF 146 L49)              ; PLUSP
82    L82
82    (NIL)
83    (JMP L21)


Disassembly of function #:|(DEFUN TRIG-SUBST-P (VLIST) ...)-26|
(CONST 0) = TRIG-SUBST-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRIG-SUBST-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRIG-SUBST-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRIG-SUBST-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRIG-SUBST-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRIG-SUBST-P
8     (SKIP&RET 1)


Disassembly of function TRIG-SUBST-P
(CONST 0) = VLIST
(CONST 1) = TRIG-NOT-SUBST-P
(CONST 2) = VAR
(CONST 3) = TRIG-CANNON
(CONST 4) = *VAR
(CONST 5) = FREE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*VAR VAR VLIST)
writes special variables : (VAR VLIST)
49 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VLIST
3     (GETVALUE&PUSH 0)                   ; VLIST
5     (CALL1 1)                           ; TRIG-NOT-SUBST-P
7     (NOT)
8     (JMPIFNOT1 L73)
10    (GETVALUE 0)                        ; VLIST
12    (CAR&PUSH)
13    (GETVALUE 0)                        ; VLIST
15    (CDR)
16    (BIND 0)                            ; VLIST
18    (NIL&PUSH)
19    (LOAD 4)
20    (BIND 2)                            ; VAR
22    (GETVALUE 2)                        ; VAR
24    (JMPIFNOT L66)
26    L26
26    (GETVALUE 2)                        ; VAR
28    (JMPIFATOM L51)
30    (GETVALUE 2)                        ; VAR
32    (CAR)
33    (CAR&PUSH)
34    (CONST&PUSH 3)                      ; TRIG-CANNON
35    (PUSH-UNBOUND 1)
37    (CALLS2&JMPIFNOT 132 L51)           ; GET
40    (GETVALUE&PUSH 2)                   ; VAR
42    (GETVALUE&PUSH 4)                   ; *VAR
44    (CALL2&JMPIF 5 L51)                 ; FREE
47    (GETVALUE&PUSH 2)                   ; VAR
49    (LOAD&CONS&STORE 3)
51    L51
51    (GETVALUE 0)                        ; VLIST
53    (CAR&PUSH)
54    (GETVALUE 0)                        ; VLIST
56    (CDR)
57    (SETVALUE 0)                        ; VLIST
59    (POP)
60    (SETVALUE 2)                        ; VAR
62    (GETVALUE 2)                        ; VAR
64    (JMPIF L26)
66    L66
66    (LOAD 3)
67    (UNBIND1)
68    (SKIP 1)
70    (UNBIND1)
71    (SKIP 1)
73    L73
73    (UNBIND1)
74    (SKIP&RET 2)


Disassembly of function #:|(DEFUN TRIG-NOT-SUBST-P (VLIST) ...)-27|
(CONST 0) = TRIG-NOT-SUBST-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRIG-NOT-SUBST-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRIG-NOT-SUBST-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRIG-NOT-SUBST-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRIG-NOT-SUBST-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRIG-NOT-SUBST-P
8     (SKIP&RET 1)


Disassembly of function TRIG-NOT-SUBST-P
(CONST 0) = VLIST
(CONST 1) = SIGN-GJC
(CONST 2) = (%SIN %COS %TAN %COT %CSC %SEC)
(CONST 3) = OPERATOR-FREQUENCY-TABLE
(CONST 4) = MEASURE
(CONST 5) = 2
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VLIST)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VLIST
3     (CONST&SYMBOL-FUNCTION&PUSH 1)      ; SIGN-GJC
5     (GETVALUE&PUSH 0)                   ; VLIST
7     (CONST&PUSH 2)                      ; (%SIN %COS %TAN %COT %CSC %SEC)
8     (CALL2&PUSH 3)                      ; OPERATOR-FREQUENCY-TABLE
10    (CONST&PUSH 2)                      ; (%SIN %COS %TAN %COT %CSC %SEC)
11    (CALL&PUSH 3 4)                     ; MEASURE
14    (CONST&PUSH 5)                      ; 2
15    (CALLSR 1 47)                       ; <
18    (UNBIND1)
19    (SKIP&RET 2)


Disassembly of function #:|(DEFUN MEASURE (F ALIST SET ...) ...)-28|
(CONST 0) = MEASURE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MEASURE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MEASURE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MEASURE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MEASURE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MEASURE
8     (SKIP&RET 1)


Disassembly of function MEASURE
(CONST 0) = F
(CONST 1) = ALIST
(CONST 2) = 0
(CONST 3) = ASSQ
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ALIST F)
26 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; F
3     (LOAD 5)
4     (BIND 1)                            ; ALIST
6     (CONST&PUSH 2)                      ; 0
7     (LOAD&PUSH 8)
8     (NIL&PUSH)
9     (JMP L31)
11    L11
11    (LOAD&CAR&STORE 1 0)
14    (LOAD&PUSH 2)
15    (GETVALUE&PUSH 0)                   ; F
17    (LOAD&PUSH 2)
18    (GETVALUE&PUSH 1)                   ; ALIST
20    (CALL2 3)                           ; ASSQ
22    (CDR&PUSH)
23    (FUNCALL&PUSH 1)
25    (CALLSR&STORE 2 53 2)               ; +
29    (LOAD&CDR&STORE 1)
31    L31
31    (LOAD&PUSH 1)
32    (CALLS1&JMPIFNOT 146 L11)           ; ENDP
35    (SKIP 2)
37    (POP)
38    (UNBIND 2)
40    (SKIP&RET 4)


Disassembly of function #:|(DEFUN SIGN-GJC (X) ...)-29|
(CONST 0) = SIGN-GJC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIGN-GJC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIGN-GJC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIGN-GJC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIGN-GJC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIGN-GJC
8     (SKIP&RET 1)


Disassembly of function SIGN-GJC
(CONST 0) = X
(CONST 1) = 0
(CONST 2) = 1
(CONST 3) = -1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
20 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE 0)                        ; X
5     (JMPIFNOT L25)
7     (GETVALUE&PUSH 0)                   ; X
9     (CONST&PUSH 1)                      ; 0
10    (CALLSR&JMPIF 1 45 L25)             ; =
14    (CONST&PUSH 1)                      ; 0
15    (GETVALUE&PUSH 0)                   ; X
17    (CALLSR&JMPIF 1 47 L28)             ; <
21    (CONST 3)                           ; -1
22    L22
22    (UNBIND1)
23    (SKIP&RET 2)
25    L25
25    (CONST 1)                           ; 0
26    (JMP L22)
28    L28
28    (CONST 2)                           ; 1
29    (JMP L22)


Disassembly of function #:|(DEFUN EXTEND (F L1 L2 ...) ...)-30|
(CONST 0) = EXTEND
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXTEND>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXTEND
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXTEND
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXTEND>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXTEND
8     (SKIP&RET 1)


Disassembly of function EXTEND
(CONST 0) = F
(CONST 1) = S
(CONST 2) = 0
(CONST 3) = J
(CONST 4) = ZL-ASSOC
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (F S J)
writes special variable : (J)
39 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; F
3     (LOAD 4)
4     (BIND 1)                            ; S
6     (CONST 2)                           ; 0
7     (BIND 3)                            ; J
9     (NIL&PUSH)
10    (JMP L51)
12    L12
12    (GETVALUE&PUSH 3)                   ; J
14    (GETVALUE&PUSH 1)                   ; S
16    (CALLS1&PUSH 148)                   ; NTH
18    (GETVALUE&PUSH 0)                   ; F
20    (GETVALUE&PUSH 3)                   ; J
22    (GETVALUE&PUSH 1)                   ; S
24    (CALLS1&PUSH 148)                   ; NTH
26    (LOAD&PUSH 16)
27    (CALL2 4)                           ; ZL-ASSOC
29    (CDR&PUSH)
30    (GETVALUE&PUSH 3)                   ; J
32    (GETVALUE&PUSH 1)                   ; S
34    (CALLS1&PUSH 148)                   ; NTH
36    (LOAD&PUSH 16)
37    (CALL2 4)                           ; ZL-ASSOC
39    (CDR&PUSH)
40    (FUNCALL 2)
42    (CONS&PUSH)
43    (LOAD&CONS&STORE 0)
45    (GETVALUE&PUSH 3)                   ; J
47    (CALLS2 150)                        ; 1+
49    (SETVALUE 3)                        ; J
51    L51
51    (GETVALUE&PUSH 3)                   ; J
53    (GETVALUE&PUSH 1)                   ; S
55    (CALLS2&PUSH 71)                    ; LENGTH
57    (CALLSR&JMPIFNOT 1 45 L12)          ; =
61    (POP)
62    (UNBIND 3)
64    (SKIP&RET 5)


Disassembly of function #:|(DEFUN +MSET (A B) ...)-31|
(CONST 0) = +MSET
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE +MSET>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; +MSET
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; +MSET
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE +MSET>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; +MSET
8     (SKIP&RET 1)


Disassembly of function +MSET
(CONST 0) = A
(CONST 1) = B
(CONST 2) = 0
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B A)
17 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; A
3     (LOAD 4)
4     (BIND 1)                            ; B
6     (GETVALUE 0)                        ; A
8     (JMPIF L11)
10    (CONST 2)                           ; 0
11    L11
11    (PUSH)
12    (GETVALUE 1)                        ; B
14    (JMPIF L17)
16    (CONST 2)                           ; 0
17    L17
17    (PUSH)
18    (CALLSR 2 53)                       ; +
21    (UNBIND 2)
23    (SKIP&RET 3)


Disassembly of function #:|(DEFUN OPERATOR-FREQUENCY-TABLE (VLIST SET) ...)-32|
(CONST 0) = OPERATOR-FREQUENCY-TABLE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE OPERATOR-FREQUENCY-TABLE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; OPERATOR-FREQUENCY-TABLE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; OPERATOR-FREQUENCY-TABLE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE OPERATOR-FREQUENCY-TABLE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; OPERATOR-FREQUENCY-TABLE
8     (SKIP&RET 1)


Disassembly of function OPERATOR-FREQUENCY-TABLE
(CONST 0) = VLIST
(CONST 1) = 0
(CONST 2) = K
(CONST 3) = J
(CONST 4) = +MSET
(CONST 5) = 1
(CONST 6) = EXTEND
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VLIST J K)
writes special variables : (J K)
69 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; VLIST
3     (CONST&PUSH 1)                      ; 0
4     (NIL&PUSH)
5     (CONST 1)                           ; 0
6     (BIND 2)                            ; K
8     (NIL&PUSH)
9     (JMP L26)
11    L11
11    (GETVALUE&PUSH 2)                   ; K
13    (LOAD&PUSH 11)
14    (CALLS1&PUSH 148)                   ; NTH
16    (CONST 1)                           ; 0
17    (CONS&PUSH)
18    (LOAD&CONS&STORE 0)
20    (GETVALUE&PUSH 2)                   ; K
22    (CALLS2 150)                        ; 1+
24    (SETVALUE 2)                        ; K
26    L26
26    (GETVALUE&PUSH 2)                   ; K
28    (LOAD&PUSH 11)
29    (CALLS2&PUSH 71)                    ; LENGTH
31    (CALLSR&JMPIFNOT 1 45 L11)          ; =
35    (POP)
36    (UNBIND1)
37    (PUSH)
38    (LOAD 2)
39    (BIND 3)                            ; J
41    (JMP L87)
43    L43
43    (GETVALUE&PUSH 3)                   ; J
45    (GETVALUE&PUSH 0)                   ; VLIST
47    (CALLS1&STORE 148 4)                ; NTH
50    (JMPIFATOM L81)
52    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; +MSET
54    (LOAD 5)
55    (CAR)
56    (CAR&PUSH)
57    (CONST 5)                           ; 1
58    (CONS&PUSH)
59    (NIL)
60    (CONS&PUSH)
61    (LOAD&PUSH 5)
62    (LOAD&PUSH 13)
63    (CALL 4 6)                          ; EXTEND
66    (STORE 3)
67    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; +MSET
69    (LOAD&PUSH 4)
70    (LOAD&CDR&PUSH 6)
72    (LOAD&PUSH 13)
73    (JSR&PUSH L0)
76    (LOAD&PUSH 13)
77    (CALL 4 6)                          ; EXTEND
80    (STORE 3)
81    L81
81    (GETVALUE&PUSH 3)                   ; J
83    (CALLS2 150)                        ; 1+
85    (SETVALUE 3)                        ; J
87    L87
87    (GETVALUE&PUSH 3)                   ; J
89    (GETVALUE&PUSH 0)                   ; VLIST
91    (CALLS2&PUSH 71)                    ; LENGTH
93    (CALLSR&JMPIFNOT 1 45 L43)          ; =
97    (LOAD 3)
98    (UNBIND1)
99    (SKIP 3)
101   (UNBIND1)
102   (SKIP&RET 3)


Disassembly of function #:|(DEFUN TRIG-SUBST (EXP SUB-LIST) ...)-33|
(CONST 0) = TRIG-SUBST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRIG-SUBST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRIG-SUBST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRIG-SUBST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRIG-SUBST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRIG-SUBST
8     (SKIP&RET 1)


Disassembly of function TRIG-SUBST
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = TRIG-CANNON
(CONST 3) = (MLIST)
(CONST 4) = MAXIMA-SUBSTITUTE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variables : (VAR EXP)
40 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (LOAD&CDR&PUSH 5)
7     (LOAD 6)
8     (CAR)
9     (BIND 1)                            ; VAR
11    (LOAD 4)
12    (BIND 0)                            ; EXP
14    (GETVALUE 1)                        ; VAR
16    (JMPIFNOT L55)
18    L18
18    (GETVALUE 1)                        ; VAR
20    (CAR)
21    (CAR&PUSH)
22    (CONST&PUSH 2)                      ; TRIG-CANNON
23    (PUSH-UNBOUND 1)
25    (CALLS2&PUSH 132)                   ; GET
27    (CONST&PUSH 3)                      ; (MLIST)
28    (GETVALUE 1)                        ; VAR
30    (CDR)
31    (CONS&PUSH)
32    (FUNCALL&PUSH 1)
34    (GETVALUE&PUSH 1)                   ; VAR
36    (GETVALUE&PUSH 0)                   ; EXP
38    (CALL 3 4)                          ; MAXIMA-SUBSTITUTE
41    (SETVALUE 0)                        ; EXP
43    (LOAD&CDR&PUSH 6)
45    (LOAD 7)
46    (CAR)
47    (SETVALUE 1)                        ; VAR
49    (POP&STORE 6)
51    (GETVALUE 1)                        ; VAR
53    (JMPIF L18)
55    L55
55    (GETVALUE 0)                        ; EXP
57    (UNBIND 2)
59    (SKIP 2)
61    (UNBIND1)
62    (SKIP&RET 3)


Disassembly of function #:|(DEFUN-PROP (%SEC TRIG-CANNON) (X) ...)-34-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%SEC TRIG-CANNON) (X) ...)-34-2-1|>
(CONST 1) = %SEC
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%SEC TRIG-CANNON) (X) ...)-34-2-1|>
1     (CONST&PUSH 1)                      ; %SEC
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%SEC TRIG-CANNON) (X) ...)-34-2-1|
(CONST 0) = X
(CONST 1) = %COS
(CONST 2) = -1
(CONST 3) = POWER*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %COS
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; -1
13    (CALL2 3)                           ; POWER*
15    (UNBIND1)
16    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%CSC TRIG-CANNON) (X) ...)-35-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%CSC TRIG-CANNON) (X) ...)-35-2-1|>
(CONST 1) = %CSC
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%CSC TRIG-CANNON) (X) ...)-35-2-1|>
1     (CONST&PUSH 1)                      ; %CSC
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%CSC TRIG-CANNON) (X) ...)-35-2-1|
(CONST 0) = X
(CONST 1) = %SIN
(CONST 2) = -1
(CONST 3) = POWER*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %SIN
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; -1
13    (CALL2 3)                           ; POWER*
15    (UNBIND1)
16    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%TAN TRIG-CANNON) (X) ...)-36-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%TAN TRIG-CANNON) (X) ...)-36-2-1|>
(CONST 1) = %TAN
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%TAN TRIG-CANNON) (X) ...)-36-2-1|>
1     (CONST&PUSH 1)                      ; %TAN
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%TAN TRIG-CANNON) (X) ...)-36-2-1|
(CONST 0) = X
(CONST 1) = %SIN
(CONST 2) = %COS
(CONST 3) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %SIN
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; %COS
13    (LIST&PUSH 1)
15    (GETVALUE 0)                        ; X
17    (CDR)
18    (CAR&PUSH)
19    (LIST&PUSH 2)
21    (CALL2 3)                           ; DIV*
23    (UNBIND1)
24    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%COT TRIG-CANNON) (X) ...)-37-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%COT TRIG-CANNON) (X) ...)-37-2-1|>
(CONST 1) = %COT
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%COT TRIG-CANNON) (X) ...)-37-2-1|>
1     (CONST&PUSH 1)                      ; %COT
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%COT TRIG-CANNON) (X) ...)-37-2-1|
(CONST 0) = X
(CONST 1) = %COS
(CONST 2) = %SIN
(CONST 3) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %COS
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; %SIN
13    (LIST&PUSH 1)
15    (GETVALUE 0)                        ; X
17    (CDR)
18    (CAR&PUSH)
19    (LIST&PUSH 2)
21    (CALL2 3)                           ; DIV*
23    (UNBIND1)
24    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%SECH TRIG-CANNON) (X) ...)-38-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%SECH TRIG-CANNON) (X) ...)-38-2-1|>
(CONST 1) = %SECH
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%SECH TRIG-CANNON) (X) ...)-38-2-1|>
1     (CONST&PUSH 1)                      ; %SECH
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%SECH TRIG-CANNON) (X) ...)-38-2-1|
(CONST 0) = X
(CONST 1) = %COSH
(CONST 2) = -1
(CONST 3) = POWER*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %COSH
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; -1
13    (CALL2 3)                           ; POWER*
15    (UNBIND1)
16    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%CSCH TRIG-CANNON) (X) ...)-39-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%CSCH TRIG-CANNON) (X) ...)-39-2-1|>
(CONST 1) = %CSCH
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%CSCH TRIG-CANNON) (X) ...)-39-2-1|>
1     (CONST&PUSH 1)                      ; %CSCH
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%CSCH TRIG-CANNON) (X) ...)-39-2-1|
(CONST 0) = X
(CONST 1) = %SINH
(CONST 2) = -1
(CONST 3) = POWER*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
12 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %SINH
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; -1
13    (CALL2 3)                           ; POWER*
15    (UNBIND1)
16    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%TANH TRIG-CANNON) (X) ...)-40-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%TANH TRIG-CANNON) (X) ...)-40-2-1|>
(CONST 1) = %TANH
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%TANH TRIG-CANNON) (X) ...)-40-2-1|>
1     (CONST&PUSH 1)                      ; %TANH
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%TANH TRIG-CANNON) (X) ...)-40-2-1|
(CONST 0) = X
(CONST 1) = %SINH
(CONST 2) = %COSH
(CONST 3) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %SINH
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; %COSH
13    (LIST&PUSH 1)
15    (GETVALUE 0)                        ; X
17    (CDR)
18    (CAR&PUSH)
19    (LIST&PUSH 2)
21    (CALL2 3)                           ; DIV*
23    (UNBIND1)
24    (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%COTH TRIG-CANNON) (X) ...)-41-2|
(CONST 0) = #<COMPILED-CLOSURE #:|(DEFUN-PROP (%COTH TRIG-CANNON) (X) ...)-41-2-1|>
(CONST 1) = %COTH
(CONST 2) = TRIG-CANNON
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; #<COMPILED-CLOSURE #:|(DEFUN-PROP (%COTH TRIG-CANNON) (X) ...)-41-2-1|>
1     (CONST&PUSH 1)                      ; %COTH
2     (CONST&PUSH 2)                      ; TRIG-CANNON
3     (LOAD&PUSH 2)
4     (CALLS2 136)                        ; SYSTEM::%PUT
6     (SKIP&RET 2)


Disassembly of function #:|(DEFUN-PROP (%COTH TRIG-CANNON) (X) ...)-41-2-1|
(CONST 0) = X
(CONST 1) = %COSH
(CONST 2) = %SINH
(CONST 3) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
17 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (CONST&PUSH 1)                      ; %COSH
4     (LIST&PUSH 1)
6     (GETVALUE 0)                        ; X
8     (CDR)
9     (CAR&PUSH)
10    (LIST&PUSH 2)
12    (CONST&PUSH 2)                      ; %SINH
13    (LIST&PUSH 1)
15    (GETVALUE 0)                        ; X
17    (CDR)
18    (CAR&PUSH)
19    (LIST&PUSH 2)
21    (CALL2 3)                           ; DIV*
23    (UNBIND1)
24    (SKIP&RET 2)


Disassembly of function #:|(DEFUN FIRST-ORDER-P (EXP VAR &AUX ...) ...)-42|
(CONST 0) = FIRST-ORDER-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FIRST-ORDER-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST-ORDER-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FIRST-ORDER-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FIRST-ORDER-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FIRST-ORDER-P
8     (SKIP&RET 1)


Disassembly of function FIRST-ORDER-P
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = TEMP
(CONST 3) = 1
(CONST 4) = EXPAND1
(CONST 5) = MTIMES
(CONST 6) = LINEAR-TERM-P
(CONST 7) = 0
(CONST 8) = MPLUS
(CONST 9) = ARG
(CONST 10) = BROKEN-FREEOF
(CONST 11) = (MPLUS)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ARG VAR EXP)
writes special variables : (ARG TEMP EXP)
97 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (NIL)
7     (BIND 2)                            ; TEMP
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CONST&PUSH 3)                      ; 1
12    (CONST&PUSH 3)                      ; 1
13    (CALL 3 4)                          ; EXPAND1
16    (SETVALUE 0)                        ; EXP
18    (JMPIFATOM L39)
20    (GETVALUE 0)                        ; EXP
22    (CAR)
23    (CAR&PUSH)
24    (LOAD&PUSH 0)
25    (JMPIFEQTO 5 L42)                   ; MTIMES
28    (LOAD&PUSH 0)
29    (JMPIFEQTO 8 L75)                   ; MPLUS
32    L32
32    (NIL)
33    (SKIP 1)
35    L35
35    (UNBIND 3)
37    (SKIP&RET 3)
39    L39
39    (NIL)
40    (JMP L35)
42    L42
42    (GETVALUE&PUSH 0)                   ; EXP
44    (GETVALUE&PUSH 1)                   ; VAR
46    (CALL2 6)                           ; LINEAR-TERM-P
48    (SETVALUE 2)                        ; TEMP
50    (JMPIFNOT L32)
52    (PUSH)
53    (CONST 7)                           ; 0
54    (CONS)
55    (SKIP 1)
57    (JMP L35)
59    L59
59    (PUSH)
60    (LOAD&CONS&STORE 7)
62    (JMP L116)
64    L64
64    (NIL)
65    (JMP L139)
68    L68
68    (CONST&PUSH 11)                     ; (MPLUS)
69    (LOAD 8)
70    (CONS)
71    (CONS)
72    (JMP L139)
75    L75
75    (GETVALUE 0)                        ; EXP
77    (CDR)
78    (CAR&PUSH)
79    (GETVALUE 0)                        ; EXP
81    (CDR)
82    (CDR&PUSH)
83    (PUSH-NIL 2)
85    (NIL)
86    (BIND 2)                            ; TEMP
88    (LOAD 6)
89    (BIND 9)                            ; ARG
91    (GETVALUE 9)                        ; ARG
93    (JMPIFNOT L127)
95    L95
95    (GETVALUE&PUSH 9)                   ; ARG
97    (GETVALUE&PUSH 1)                   ; VAR
99    (CALL2 6)                           ; LINEAR-TERM-P
101   (SETVALUE 2)                        ; TEMP
103   (JMPIF L59)
105   (GETVALUE&PUSH 1)                   ; VAR
107   (GETVALUE&PUSH 9)                   ; ARG
109   (CALL2&JMPIFNOT 10 L64)             ; BROKEN-FREEOF
112   (GETVALUE&PUSH 9)                   ; ARG
114   (LOAD&CONS&STORE 6)
116   L116
116   (LOAD&CAR&PUSH 8)
118   (LOAD&CDR&STORE 9)
120   (POP)
121   (SETVALUE 9)                        ; ARG
123   (GETVALUE 9)                        ; ARG
125   (JMPIF L95)
127   L127
127   (LOAD 7)
128   (JMPIFNOT1 L139)
130   (CONST&PUSH 11)                     ; (MPLUS)
131   (LOAD 8)
132   (CONS&PUSH)
133   (LOAD&JMPIF 7 L68)
137   (CONST 7)                           ; 0
138   (CONS)
139   L139
139   (UNBIND 2)
141   (SKIP 5)
143   (JMP L35)


Disassembly of function #:|(DEFUN LINEAR-TERM-P (EXP VAR) ...)-43|
(CONST 0) = LINEAR-TERM-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LINEAR-TERM-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LINEAR-TERM-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LINEAR-TERM-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LINEAR-TERM-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LINEAR-TERM-P
8     (SKIP&RET 1)


Disassembly of function LINEAR-TERM-P
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = 1
(CONST 3) = MTIMES
(CONST 4) = BROKEN-FREEOF
(CONST 5) = (MTIMES)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
66 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 0)                        ; EXP
8     (JMPIFATOM L28)
10    (GETVALUE 0)                        ; EXP
12    (CAR)
13    (CAR&PUSH)
14    (LOAD&PUSH 0)
15    (JMPIFEQTO 3 L46)                   ; MTIMES
18    (NIL)
19    (SKIP 1)
21    L21
21    (UNBIND 2)
23    (SKIP&RET 3)
25    L25
25    (CONST 2)                           ; 1
26    (JMP L21)
28    L28
28    (GETVALUE&PUSH 0)                   ; EXP
30    (GETVALUE 1)                        ; VAR
32    (JMPIFEQ L25)
34    (NIL)
35    (JMP L21)
37    L37
37    (T&STORE 1)
39    (JMP L73)
41    L41
41    (NIL)
42    (SKIP 5)
44    (JMP L21)
46    L46
46    (GETVALUE 0)                        ; EXP
48    (CDR)
49    (CAR&PUSH)
50    (GETVALUE 0)                        ; EXP
52    (CDR)
53    (CDR&PUSH)
54    (PUSH-NIL 2)
56    (LOAD&JMPIFNOT 3 L82)
59    L59
59    (LOAD&PUSH 3)
60    (GETVALUE 1)                        ; VAR
62    (JMPIFEQ L37)
64    (GETVALUE&PUSH 1)                   ; VAR
66    (LOAD&PUSH 4)
67    (CALL2&JMPIFNOT 4 L41)              ; BROKEN-FREEOF
70    (LOAD&PUSH 3)
71    (LOAD&CONS&STORE 0)
73    L73
73    (LOAD&CAR&PUSH 2)
75    (LOAD&CDR&STORE 3)
77    (POP&STORE 3)
79    (LOAD&JMPIF 3 L59)
82    L82
82    (LOAD 1)
83    (JMPIFNOT1 L93)
85    (CONST&PUSH 5)                      ; (MTIMES)
86    (LOAD 1)
87    (CONS)
88    (SKIP 5)
90    (JMP L21)
93    L93
93    (SKIP 5)
95    (JMP L21)


Disassembly of function #:|(DEFUN SOLVE1A (EXP MULT) ...)-44|
(CONST 0) = SOLVE1A
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVE1A>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE1A
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVE1A
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVE1A>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVE1A
8     (SKIP&RET 1)


Disassembly of function SOLVE1A
(CONST 0) = EXP
(CONST 1) = MULT
(CONST 2) = *MYVAR
(CONST 3) = *G
(CONST 4) = 1
(CONST 5) = PDIS
(CONST 6) = *HAS*VAR
(CONST 7) = MEMALIKE
(CONST 8) = SOLVELIN
(CONST 9) = SPECASEP
(CONST 10) = SOLVESPEC
(CONST 11) = 2
(CONST 12) = SOLVEQUAD
(CONST 13) = SOLVENTHP
(CONST 14) = SOLVENTH
(CONST 15) = 3
(CONST 16) = SOLVECUBIC
(CONST 17) = 4
(CONST 18) = SOLVEQUARTIC
(CONST 19) = SOLVE-BY-DECOMPOSITION
(CONST 20) = *FAILURES
(CONST 21) = *ROOTS
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*G *ROOTS *FAILURES *HAS*VAR EXP *MYVAR)
writes special variables : (*ROOTS *FAILURES *G *MYVAR)
96 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; MULT
6     (GETVALUE 2)                        ; *MYVAR
8     (BIND 2)                            ; *MYVAR
10    (NIL)
11    (BIND 3)                            ; *G
13    (GETVALUE 0)                        ; EXP
15    (JMPIFATOM L122)
18    (GETVALUE 0)                        ; EXP
20    (CAR&PUSH)
21    (CONST&PUSH 4)                      ; 1
22    (CONST&PUSH 4)                      ; 1
23    (LIST&PUSH 3)
25    (CALL1 5)                           ; PDIS
27    (SETVALUE 2)                        ; *MYVAR
29    (PUSH)
30    (GETVALUE&PUSH 6)                   ; *HAS*VAR
32    (CALL2&JMPIFNOT 7 L125)             ; MEMALIKE
36    (GETVALUE 0)                        ; EXP
38    (CDR)
39    (CAR&PUSH)
40    (JMPIFEQTO 4 L128)                  ; 1
44    (GETVALUE&PUSH 0)                   ; EXP
46    (CALL1&JMPIF 9 L134)                ; SPECASEP
50    (GETVALUE 0)                        ; EXP
52    (CDR)
53    (CAR&PUSH)
54    (JMPIFEQTO 11 L141)                 ; 2
58    (GETVALUE 0)                        ; EXP
60    (CDR)
61    (CDR)
62    (CDR&PUSH)
63    (GETVALUE 0)                        ; EXP
65    (CDR)
66    (CAR&PUSH)
67    (CALL2 13)                          ; SOLVENTHP
69    (SETVALUE 3)                        ; *G
71    (PUSH)
72    (JMPIFNOTEQTO 4 L147)               ; 1
76    (GETVALUE 0)                        ; EXP
78    (CDR)
79    (CAR&PUSH)
80    (JMPIFEQTO 15 L155)                 ; 3
84    (GETVALUE 0)                        ; EXP
86    (CDR)
87    (CAR&PUSH)
88    (JMPIFEQTO 17 L161)                 ; 4
92    (GETVALUE&PUSH 0)                   ; EXP
94    (GETVALUE&PUSH 2)                   ; *MYVAR
96    (CALL2&PUSH 19)                     ; SOLVE-BY-DECOMPOSITION
98    (LOAD&CDR&PUSH 0)
100   (GETVALUE&PUSH 20)                  ; *FAILURES
102   (CALLSR 2 34)                       ; APPEND
105   (SETVALUE 20)                       ; *FAILURES
107   (LOAD&CAR&PUSH 0)
109   (GETVALUE&PUSH 21)                  ; *ROOTS
111   (CALLSR 2 34)                       ; APPEND
114   (SETVALUE 21)                       ; *ROOTS
116   (SKIP 1)
118   L118
118   (UNBIND 4)
120   (SKIP&RET 3)
122   L122
122   (NIL)
123   (JMP L118)
125   L125
125   (NIL)
126   (JMP L118)
128   L128
128   (GETVALUE&PUSH 0)                   ; EXP
130   (CALL1 8)                           ; SOLVELIN
132   (JMP L118)
134   L134
134   (GETVALUE&PUSH 0)                   ; EXP
136   (T&PUSH)
137   (CALL2 10)                          ; SOLVESPEC
139   (JMP L118)
141   L141
141   (GETVALUE&PUSH 0)                   ; EXP
143   (CALL1 12)                          ; SOLVEQUAD
145   (JMP L118)
147   L147
147   (GETVALUE&PUSH 0)                   ; EXP
149   (GETVALUE&PUSH 3)                   ; *G
151   (CALL2 14)                          ; SOLVENTH
153   (JMP L118)
155   L155
155   (GETVALUE&PUSH 0)                   ; EXP
157   (CALL1 16)                          ; SOLVECUBIC
159   (JMP L118)
161   L161
161   (GETVALUE&PUSH 0)                   ; EXP
163   (CALL1 18)                          ; SOLVEQUARTIC
165   (JMP L118)


Disassembly of function #:|(DEFUN SOLVE-SIMPLIST (LIST-OF-THINGS) ...)-45|
(CONST 0) = SOLVE-SIMPLIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVE-SIMPLIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE-SIMPLIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVE-SIMPLIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVE-SIMPLIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVE-SIMPLIST
8     (SKIP&RET 1)


Disassembly of function SOLVE-SIMPLIST
(CONST 0) = (MLIST)
(CONST 1) = SIMPLIFYA
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; (MLIST)
1     (LOAD 2)
2     (CONS&PUSH)
3     (NIL&PUSH)
4     (CALL2 1)                           ; SIMPLIFYA
6     (CDR)
7     (SKIP&RET 2)


Disassembly of function #:|(DEFUN SOLVE-BY-DECOMPOSITION (POLY *$VAR) ...)-46|
(CONST 0) = SOLVE-BY-DECOMPOSITION
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVE-BY-DECOMPOSITION>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE-BY-DECOMPOSITION
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVE-BY-DECOMPOSITION
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVE-BY-DECOMPOSITION>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVE-BY-DECOMPOSITION
8     (SKIP&RET 1)


Disassembly of function SOLVE-BY-DECOMPOSITION
(CONST 0) = $SOLVEDECOMPOSES
(CONST 1) = POLYDECOMP
(CONST 2) = 1
(CONST 3) = (MEQUAL)
(CONST 4) = 0
(CONST 5) = PDIS
(CONST 6) = (1)
(CONST 7) = RDIS
(CONST 8) = DECOMP-TRACE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: ($SOLVEDECOMPOSES)
33 byte-code instructions:
0     (NIL&PUSH)
1     (GETVALUE 0)                        ; $SOLVEDECOMPOSES
3     (JMPIFNOT L37)
5     (LOAD&PUSH 3)
6     (LOAD&CAR&PUSH 4)
8     (CALL2 1)                           ; POLYDECOMP
10    (STORE 0)
11    (PUSH)
12    (CALLS2&PUSH 71)                    ; LENGTH
14    (CONST&PUSH 2)                      ; 1
15    (CALLSR&JMPIF 1 45 L37)             ; =
19    (CONST&PUSH 3)                      ; (MEQUAL)
20    (CONST&PUSH 4)                      ; 0
21    (LOAD&CAR&PUSH 2)
23    (CALL1&PUSH 7)                      ; RDIS
25    (LIST&PUSH 3)
27    (LOAD&PUSH 1)
28    (LOAD&CAR&PUSH 5)
30    (LOAD&PUSH 5)
31    (CONST&PUSH 2)                      ; 1
32    (CALL 5 8)                          ; DECOMP-TRACE
35    (SKIP&RET 4)
37    L37
37    (NIL&PUSH)
38    (CONST&PUSH 3)                      ; (MEQUAL)
39    (CONST&PUSH 4)                      ; 0
40    (LOAD&PUSH 6)
41    (CALL1&PUSH 5)                      ; PDIS
43    (LIST&PUSH 3)
45    (CONST 6)                           ; (1)
46    (CONS)
47    (CONS)
48    (SKIP&RET 4)


Disassembly of function #:|(DEFUN DECOMP-TRACE (EQN DECOMP VAR ...) ...)-47|
(CONST 0) = DECOMP-TRACE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DECOMP-TRACE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DECOMP-TRACE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DECOMP-TRACE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DECOMP-TRACE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DECOMP-TRACE
8     (SKIP&RET 1)


Disassembly of function DECOMP-TRACE
(CONST 0) = VAR
(CONST 1) = MULT
(CONST 2) = SOL
(CONST 3) = RE-SOLVE
(CONST 4) = (1)
(CONST 5) = L
(CONST 6) = DECOMP-CHAIN
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT VAR L SOL)
writes special variables : (L SOL)
69 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; MULT
6     (NIL)
7     (BIND 2)                            ; SOL
9     (PUSH-NIL 3)
11    (LOAD&JMPIF 16 L93)
15    (LOAD&PUSH 17)
16    (CONST 4)                           ; (1)
17    (CONS&PUSH)
18    (NIL)
19    (CONS)
20    L20
20    (SETVALUE 2)                        ; SOL
22    (CDR)
23    (JMPIF L103)
26    (LOAD&JMPIFNOT 16 L107)
30    (GETVALUE 2)                        ; SOL
32    (CAR)
33    (BIND 5)                            ; L
35    (GETVALUE 5)                        ; L
37    (JMPIFNOT L83)
39    L39
39    (GETVALUE 5)                        ; L
41    (CAR&PUSH)
42    (LOAD&CDR&PUSH 20)
44    (GETVALUE&PUSH 0)                   ; VAR
46    (LOAD&PUSH 20)
47    (GETVALUE 5)                        ; L
49    (CDR)
50    (CAR&PUSH)
51    (CALL 5 6)                          ; DECOMP-CHAIN
54    (STORE 5)
55    (LOAD&PUSH 4)
56    (LOAD&CAR&PUSH 6)
58    (CALLS1&PUSH 158)                   ; COPY-LIST
60    (CALLSR&STORE 2 35 4)               ; NCONC
64    (LOAD&PUSH 3)
65    (LOAD&CDR&PUSH 6)
67    (CALLS1&PUSH 158)                   ; COPY-LIST
69    (CALLSR&STORE 2 35 3)               ; NCONC
73    (GETVALUE 5)                        ; L
75    (CDR)
76    (CDR)
77    (SETVALUE 5)                        ; L
79    (GETVALUE 5)                        ; L
81    (JMPIF L39)
83    L83
83    (UNBIND1)
84    (LOAD&PUSH 1)
85    (LOAD 1)
86    (CONS)
87    L87
87    (SKIP 3)
89    (UNBIND 3)
91    (SKIP&RET 6)
93    L93
93    (LOAD&PUSH 17)
94    (LOAD&PUSH 15)
95    (GETVALUE&PUSH 1)                   ; MULT
97    (CALL 3 3)                          ; RE-SOLVE
100   (JMP L20)
103   L103
103   (GETVALUE 2)                        ; SOL
105   (JMP L87)
107   L107
107   (GETVALUE 2)                        ; SOL
109   (JMP L87)


Disassembly of function #:|(DEFUN DECOMP-CHAIN (RSOL DECOMP VAR ...) ...)-48|
(CONST 0) = DECOMP-CHAIN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DECOMP-CHAIN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DECOMP-CHAIN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DECOMP-CHAIN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DECOMP-CHAIN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DECOMP-CHAIN
8     (SKIP&RET 1)


Disassembly of function DECOMP-CHAIN
(CONST 0) = VAR
(CONST 1) = MULT
(CONST 2) = (MEQUAL)
(CONST 3) = (1 1)
(CONST 4) = 1
(CONST 5) = RDIS
(CONST 6) = SIMPLIFY
(CONST 7) = SOL
(CONST 8) = DECOMP-TRACE
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT SOL VAR)
32 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; MULT
6     (CONST&PUSH 2)                      ; (MEQUAL)
7     (LOAD&JMPIF 11 L44)
10    (GETVALUE&PUSH 0)                   ; VAR
12    (CONST 3)                           ; (1 1)
13    (CONS&PUSH)
14    (CONST 4)                           ; 1
15    (CONS)
16    L16
16    (PUSH)
17    (CALL1&PUSH 5)                      ; RDIS
19    (LOAD 13)
20    (CDR)
21    (CDR)
22    (CAR&PUSH)
23    (LIST&PUSH 3)
25    (CALL1 6)                           ; SIMPLIFY
27    (BIND 7)                            ; SOL
29    (GETVALUE&PUSH 7)                   ; SOL
31    (LOAD&PUSH 14)
32    (GETVALUE&PUSH 0)                   ; VAR
34    (LOAD&PUSH 14)
35    (GETVALUE&PUSH 1)                   ; MULT
37    (CALL 5 8)                          ; DECOMP-TRACE
40    (UNBIND 3)
42    (SKIP&RET 6)
44    L44
44    (CAR)
45    (JMP L16)


Disassembly of function #:|(DEFUN RE-SOLVE (EQN VAR MULT) ...)-49|
(CONST 0) = RE-SOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RE-SOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RE-SOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RE-SOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RE-SOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RE-SOLVE
8     (SKIP&RET 1)


Disassembly of function RE-SOLVE
(CONST 0) = VAR
(CONST 1) = MULT
(CONST 2) = *ROOTS
(CONST 3) = *FAILURES
(CONST 4) = $SOLVEDECOMPOSES
(CONST 5) = $SOLVEFACTORS
(CONST 6) = SOLVE
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*FAILURES *ROOTS MULT VAR)
21 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; MULT
6     (NIL)
7     (BIND 2)                            ; *ROOTS
9     (NIL)
10    (BIND 3)                            ; *FAILURES
12    (NIL)
13    (BIND 4)                            ; $SOLVEDECOMPOSES
15    (NIL)
16    (BIND 5)                            ; $SOLVEFACTORS
18    (LOAD&PUSH 21)
19    (GETVALUE&PUSH 0)                   ; VAR
21    (GETVALUE&PUSH 1)                   ; MULT
23    (CALL 3 6)                          ; SOLVE
26    (GETVALUE&PUSH 2)                   ; *ROOTS
28    (GETVALUE 3)                        ; *FAILURES
30    (CONS)
31    (UNBIND 6)
33    (SKIP&RET 4)


Disassembly of function #:|(DEFUN SOLVENTHP (L GCD) ...)-50|
(CONST 0) = SOLVENTHP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVENTHP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVENTHP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVENTHP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVENTHP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVENTHP
8     (SKIP&RET 1)


Disassembly of function SOLVENTHP
(CONST 0) = L
(CONST 1) = GCD
(CONST 2) = 1
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (GCD L)
26 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; L
3     (LOAD 4)
4     (BIND 1)                            ; GCD
6     (GETVALUE 0)                        ; L
8     (JMPIFNOT L33)
10    (GETVALUE&PUSH 1)                   ; GCD
12    (JMPIFEQTO 2 L37)                   ; 1
15    (GETVALUE 0)                        ; L
17    (CDR)
18    (CDR&PUSH)
19    (GETVALUE 0)                        ; L
21    (CAR&PUSH)
22    (GETVALUE&PUSH 1)                   ; GCD
24    (CALLSR&PUSH 2 57)                  ; GCD
27    (JSR L0)
29    L29
29    (UNBIND 2)
31    (SKIP&RET 3)
33    L33
33    (GETVALUE 1)                        ; GCD
35    (JMP L29)
37    L37
37    (CONST 2)                           ; 1
38    (JMP L29)


Disassembly of function #:|(DEFUN SOLVENTH (EXP *G) ...)-51|
(CONST 0) = SOLVENTH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVENTH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVENTH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVENTH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVENTH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVENTH
8     (SKIP&RET 1)


Disassembly of function SOLVENTH
(CONST 0) = EXP
(CONST 1) = *G
(CONST 2) = (1 1)
(CONST 3) = PDIS
(CONST 4) = SOLVENTH1
(CONST 5) = *VARB
(CONST 6) = RE-SOLVE-FULL
(CONST 7) = (MEXPT)
(CONST 8) = *POWER
(CONST 9) = #<COMPILED-CLOSURE SOLVENTH-1>
(CONST 10) = MAP2C
(CONST 11) = #<COMPILED-CLOSURE SOLVENTH-2>
(CONST 12) = *ROOTS
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*ROOTS *G *VARB EXP)
42 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; *G
6     (GETVALUE 0)                        ; EXP
8     (CAR&PUSH)
9     (CONST 2)                           ; (1 1)
10    (CONS&PUSH)
11    (CALL1&PUSH 3)                      ; PDIS
13    (GETVALUE 0)                        ; EXP
15    (CAR&PUSH)
16    (GETVALUE 0)                        ; EXP
18    (CDR&PUSH)
19    (CALL1 4)                           ; SOLVENTH1
21    (CONS)
22    (BIND 0)                            ; EXP
24    (LOAD 3)
25    (BIND 5)                            ; *VARB
27    (GETVALUE&PUSH 0)                   ; EXP
29    (CALL1&PUSH 3)                      ; PDIS
31    (GETVALUE&PUSH 5)                   ; *VARB
33    (CALL2&PUSH 6)                      ; RE-SOLVE-FULL
35    (LOAD&CDR&PUSH 0)
37    (LOAD&CAR&PUSH 1)
39    (CONST&PUSH 7)                      ; (MEXPT)
40    (GETVALUE&PUSH 5)                   ; *VARB
42    (GETVALUE&PUSH 1)                   ; *G
44    (LIST 3)
46    (BIND 8)                            ; *POWER
48    (CONST&PUSH 9)                      ; #<COMPILED-CLOSURE SOLVENTH-1>
49    (LOAD&PUSH 4)
50    (CALL2 10)                          ; MAP2C
52    (CONST&PUSH 11)                     ; #<COMPILED-CLOSURE SOLVENTH-2>
53    (LOAD&PUSH 5)
54    (CALL2 10)                          ; MAP2C
56    (GETVALUE 12)                       ; *ROOTS
58    (UNBIND1)
59    (SKIP 3)
61    (UNBIND 2)
63    (SKIP 1)
65    (UNBIND 2)
67    (SKIP&RET 3)


Disassembly of function SOLVENTH-1
(CONST 0) = W
(CONST 1) = *VARB
(CONST 2) = (MEQUAL)
(CONST 3) = *POWER
(CONST 4) = SOLVE
(CONST 5) = RE-SOLVE-FULL
(CONST 6) = #<COMPILED-CLOSURE SOLVENTH-1-1>
(CONST 7) = MAP2C
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (W *POWER *VARB)
32 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; W
3     (GETVALUE 1)                        ; *VARB
5     (JMPIFATOM L31)
7     (CONST&PUSH 2)                      ; (MEQUAL)
8     (GETVALUE&PUSH 3)                   ; *POWER
10    (GETVALUE 0)                        ; W
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LIST&PUSH 3)
17    (GETVALUE&PUSH 1)                   ; *VARB
19    (CALL2&PUSH 5)                      ; RE-SOLVE-FULL
21    (CONST&PUSH 6)                      ; #<COMPILED-CLOSURE SOLVENTH-1-1>
22    (LOAD&CAR&PUSH 1)
24    (CALL2 7)                           ; MAP2C
26    (SKIP 1)
28    L28
28    (UNBIND1)
29    (SKIP&RET 3)
31    L31
31    (CONST&PUSH 2)                      ; (MEQUAL)
32    (GETVALUE&PUSH 3)                   ; *POWER
34    (GETVALUE 0)                        ; W
36    (CDR)
37    (CDR)
38    (CAR&PUSH)
39    (LIST&PUSH 3)
41    (GETVALUE&PUSH 1)                   ; *VARB
43    (LOAD&PUSH 6)
44    (CALL 3 4)                          ; SOLVE
47    (JMP L28)


Disassembly of function SOLVENTH-1-1
(CONST 0) = MULT
(CONST 1) = (MEQUAL)
(CONST 2) = 0
(CONST 3) = *MYVAR
(CONST 4) = SOLVE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT *MYVAR)
14 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; MULT
3     (CONST&PUSH 1)                      ; (MEQUAL)
4     (LOAD 6)
5     (CDR)
6     (CDR)
7     (CAR&PUSH)
8     (CONST&PUSH 2)                      ; 0
9     (LIST&PUSH 3)
11    (GETVALUE&PUSH 3)                   ; *MYVAR
13    (GETVALUE&PUSH 0)                   ; MULT
15    (CALL 3 4)                          ; SOLVE
18    (UNBIND1)
19    (SKIP&RET 3)


Disassembly of function SOLVENTH-2
(CONST 0) = W
(CONST 1) = *FAILURES
(CONST 2) = *POWER
(CONST 3) = *VARB
(CONST 4) = SOLVENTH3
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*VARB *POWER W *FAILURES)
writes special variable : (*FAILURES)
15 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; W
3     (LOAD&PUSH 4)
4     (GETVALUE 1)                        ; *FAILURES
6     (CONS)
7     (SETVALUE 1)                        ; *FAILURES
9     (GETVALUE&PUSH 0)                   ; W
11    (GETVALUE&PUSH 2)                   ; *POWER
13    (GETVALUE&PUSH 3)                   ; *VARB
15    (CALL&PUSH 3 4)                     ; SOLVENTH3
18    (GETVALUE 1)                        ; *FAILURES
20    (CONS)
21    (SETVALUE 1)                        ; *FAILURES
23    (UNBIND1)
24    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SOLVENTH3 (W *POWER *VARB ...) ...)-52|
(CONST 0) = SOLVENTH3
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVENTH3>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVENTH3
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVENTH3
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVENTH3>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVENTH3
8     (SKIP&RET 1)


Disassembly of function SOLVENTH3
(CONST 0) = W
(CONST 1) = *POWER
(CONST 2) = *VARB
(CONST 3) = VARLIST
(CONST 4) = GENVAR
(CONST 5) = *FLG
(CONST 6) = BROKEN-FREEOF
(CONST 7) = RATF
(CONST 8) = ALIKE1
(CONST 9) = RDIS
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*FLG *POWER VARLIST W *VARB)
writes special variables : (VARLIST *FLG)
73 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; W
3     (LOAD 5)
4     (BIND 1)                            ; *POWER
6     (LOAD 7)
7     (BIND 2)                            ; *VARB
9     (NIL)
10    (BIND 3)                            ; VARLIST
12    (NIL)
13    (BIND 4)                            ; GENVAR
15    (NIL)
16    (BIND 5)                            ; *FLG
18    (PUSH-NIL 2)
20    (GETVALUE&PUSH 2)                   ; *VARB
22    (GETVALUE&PUSH 0)                   ; W
24    (CALL2&JMPIF 6 L47)                 ; BROKEN-FREEOF
27    (GETVALUE 0)                        ; W
29    (CDR)
30    (CAR&PUSH)
31    (CALL1 7)                           ; RATF
33    (STORE 1)
34    (GETVALUE 0)                        ; W
36    (CDR)
37    (CDR)
38    (CAR&PUSH)
39    (CALL1 7)                           ; RATF
41    (STORE 0)
42    (NIL&PUSH)
43    (GETVALUE&PUSH 3)                   ; VARLIST
45    (JMP L81)
47    L47
47    (GETVALUE 0)                        ; W
49    (JMP L107)
51    L51
51    (LOAD 0)
52    (JMP L74)
54    L54
54    (T)
55    (SETVALUE 5)                        ; *FLG
57    (GETVALUE 1)                        ; *POWER
59    (JMP L74)
61    L61
61    (LOAD&CAR&PUSH 0)
63    (GETVALUE 5)                        ; *FLG
65    (JMPIF L51)
67    (LOAD&PUSH 0)
68    (GETVALUE&PUSH 2)                   ; *VARB
70    (CALL2&JMPIF 8 L54)                 ; ALIKE1
73    (LOAD 0)
74    L74
74    (PUSH)
75    (LOAD&CONS&STORE 2)
77    (SKIP 1)
79    (LOAD&CDR&STORE 0)
81    L81
81    (LOAD&PUSH 0)
82    (CALLS1&JMPIFNOT 146 L61)           ; ENDP
85    (SKIP 1)
87    (LOAD&PUSH 0)
88    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
90    (SKIP 1)
92    (SETVALUE 3)                        ; VARLIST
94    (GETVALUE 0)                        ; W
96    (CAR&PUSH)
97    (LOAD&CDR&PUSH 2)
99    (CALL1&PUSH 9)                      ; RDIS
101   (LOAD&CDR&PUSH 2)
103   (CALL1&PUSH 9)                      ; RDIS
105   (LIST 3)
107   L107
107   (SKIP 2)
109   (UNBIND 6)
111   (SKIP&RET 4)


Disassembly of function #:|(DECLARE-TOP (MUZZLED T))-53|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SOLVENTH1 (L) ...)-54|
(CONST 0) = SOLVENTH1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVENTH1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVENTH1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVENTH1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVENTH1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVENTH1
8     (SKIP&RET 1)


Disassembly of function SOLVENTH1
(CONST 0) = L
(CONST 1) = *G
(CONST 2) = QUOT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*G L)
24 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (JMPIFNOT L29)
7     (GETVALUE 0)                        ; L
9     (CAR&PUSH)
10    (GETVALUE&PUSH 1)                   ; *G
12    (CALL2&PUSH 2)                      ; QUOT
14    (GETVALUE 0)                        ; L
16    (CDR)
17    (CAR&PUSH)
18    (GETVALUE 0)                        ; L
20    (CDR)
21    (CDR&PUSH)
22    (JSR L0)
24    (CONS)
25    (CONS)
26    L26
26    (UNBIND1)
27    (SKIP&RET 2)
29    L29
29    (NIL)
30    (JMP L26)


Disassembly of function #:|(DECLARE-TOP (MUZZLED NIL))-55|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN RE-SOLVE-FULL (X VAR &AUX ...) ...)-56|
(CONST 0) = RE-SOLVE-FULL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RE-SOLVE-FULL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RE-SOLVE-FULL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RE-SOLVE-FULL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RE-SOLVE-FULL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RE-SOLVE-FULL
8     (SKIP&RET 1)


Disassembly of function RE-SOLVE-FULL
(CONST 0) = X
(CONST 1) = VAR
(CONST 2) = *ROOTS
(CONST 3) = *FAILURES
(CONST 4) = MULT
(CONST 5) = SOLVE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*FAILURES *ROOTS MULT VAR X)
17 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; X
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (NIL)
7     (BIND 2)                            ; *ROOTS
9     (NIL)
10    (BIND 3)                            ; *FAILURES
12    (GETVALUE&PUSH 0)                   ; X
14    (GETVALUE&PUSH 1)                   ; VAR
16    (GETVALUE&PUSH 4)                   ; MULT
18    (CALL 3 5)                          ; SOLVE
21    (GETVALUE&PUSH 2)                   ; *ROOTS
23    (GETVALUE 3)                        ; *FAILURES
25    (CONS)
26    (UNBIND 4)
28    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SPECASEP (E) ...)-57|
(CONST 0) = SPECASEP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SPECASEP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SPECASEP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SPECASEP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SPECASEP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SPECASEP
8     (SKIP&RET 1)


Disassembly of function SPECASEP
(CONST 0) = E
(CONST 1) = 1
(CONST 2) = PDIS
(CONST 3) = *HAS*VAR
(CONST 4) = MEMALIKE
(CONST 5) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*HAS*VAR E)
46 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (CAR&PUSH)
6     (CONST&PUSH 1)                      ; 1
7     (CONST&PUSH 1)                      ; 1
8     (LIST&PUSH 3)
10    (CALL1&PUSH 2)                      ; PDIS
12    (GETVALUE&PUSH 3)                   ; *HAS*VAR
14    (CALL2 4)                           ; MEMALIKE
16    (JMPIFNOT1 L60)
18    (GETVALUE 0)                        ; E
20    (CDR)
21    (CDR)
22    (CAR)
23    (JMPIFATOM L44)
25    (GETVALUE 0)                        ; E
27    (CDR)
28    (CDR)
29    (CAR)
30    (CAR&PUSH)
31    (CONST&PUSH 1)                      ; 1
32    (CONST&PUSH 1)                      ; 1
33    (LIST&PUSH 3)
35    (CALL1&PUSH 2)                      ; PDIS
37    (GETVALUE&PUSH 3)                   ; *HAS*VAR
39    (CALL2 4)                           ; MEMALIKE
41    (NOT)
42    (JMPIFNOT1 L60)
44    L44
44    (GETVALUE 0)                        ; E
46    (CDR)
47    (CDR)
48    (CDR)
49    (NOT)
50    (JMPIF1 L60)
52    (GETVALUE 0)                        ; E
54    (CDR)
55    (CDR)
56    (CDR)
57    (CAR&PUSH)
58    (CONST 5)                           ; 0
59    (EQ)
60    L60
60    (UNBIND1)
61    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (MUZZLED T))-58|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SOLVESPEC (EXP $%EMODE) ...)-59|
(CONST 0) = SOLVESPEC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVESPEC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVESPEC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVESPEC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVESPEC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVESPEC
8     (SKIP&RET 1)


Disassembly of function SOLVESPEC
(CONST 0) = EXP
(CONST 1) = $%EMODE
(CONST 2) = A
(CONST 3) = B
(CONST 4) = C
(CONST 5) = PDIS
(CONST 6) = 1
(CONST 7) = *VAR
(CONST 8) = MULT
(CONST 9) = SOLVE
(CONST 10) = PMINUS
(CONST 11) = DIV*
(CONST 12) = SIMPNRT
(CONST 13) = (RAT)
(CONST 14) = SOLVESPEC1
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT *VAR A B C EXP)
writes special variables : (B C A)
68 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; $%EMODE
6     (NIL)
7     (BIND 2)                            ; A
9     (NIL)
10    (BIND 3)                            ; B
12    (NIL)
13    (BIND 4)                            ; C
15    (GETVALUE 0)                        ; EXP
17    (CDR)
18    (CDR)
19    (CAR&PUSH)
20    (CALL1 5)                           ; PDIS
22    (SETVALUE 2)                        ; A
24    (GETVALUE 0)                        ; EXP
26    (CAR&PUSH)
27    (CONST&PUSH 6)                      ; 1
28    (CONST&PUSH 6)                      ; 1
29    (LIST&PUSH 3)
31    (CALL1 5)                           ; PDIS
33    (SETVALUE 4)                        ; C
35    (GETVALUE 0)                        ; EXP
37    (CDR)
38    (CDR)
39    (CDR)
40    (JMPIFNOT L88)
42    (GETVALUE 0)                        ; EXP
44    (CDR)
45    (CDR)
46    (CDR)
47    (CDR)
48    (CAR&PUSH)
49    (CALL1&PUSH 10)                     ; PMINUS
51    (CALL1 5)                           ; PDIS
53    (SETVALUE 3)                        ; B
55    (GETVALUE&PUSH 4)                   ; C
57    (GETVALUE&PUSH 3)                   ; B
59    (GETVALUE&PUSH 2)                   ; A
61    (CALL2&PUSH 11)                     ; DIV*
63    (GETVALUE 0)                        ; EXP
65    (CDR)
66    (CAR&PUSH)
67    (CALL2&PUSH 12)                     ; SIMPNRT
69    (CONST&PUSH 13)                     ; (RAT)
70    (CONST&PUSH 6)                      ; 1
71    (GETVALUE 0)                        ; EXP
73    (CDR)
74    (CAR&PUSH)
75    (LIST&PUSH 3)
77    (GETVALUE 0)                        ; EXP
79    (CDR)
80    (CAR&PUSH)
81    (CALL 4 14)                         ; SOLVESPEC1
84    L84
84    (UNBIND 5)
86    (SKIP&RET 3)
88    L88
88    (GETVALUE&PUSH 4)                   ; C
90    (GETVALUE&PUSH 7)                   ; *VAR
92    (GETVALUE 0)                        ; EXP
94    (CDR)
95    (CAR&PUSH)
96    (GETVALUE&PUSH 8)                   ; MULT
98    (CALLSR&PUSH 2 55)                  ; *
101   (CALL 3 9)                          ; SOLVE
104   (JMP L84)


Disassembly of function #:|(DECLARE-TOP (MUZZLED NIL))-60|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SOLVESPEC1 (VAR ROOT N ...) ...)-61|
(CONST 0) = SOLVESPEC1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVESPEC1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVESPEC1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVESPEC1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVESPEC1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVESPEC1
8     (SKIP&RET 1)


Disassembly of function SOLVESPEC1
(CONST 0) = VAR
(CONST 1) = N
(CONST 2) = -1
(CONST 3) = $%E
(CONST 4) = 2
(CONST 5) = $%PI
(CONST 6) = $%I
(CONST 7) = MUL*
(CONST 8) = POWER*
(CONST 9) = ADD*
(CONST 10) = *VAR
(CONST 11) = MULT
(CONST 12) = SOLVE
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT *VAR N VAR)
31 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; VAR
3     (LOAD 5)
4     (BIND 1)                            ; N
6     (LOAD&PUSH 7)
7     (JMP L39)
9     L9
9     (GETVALUE&PUSH 0)                   ; VAR
11    (CONST&PUSH 2)                      ; -1
12    (LOAD&PUSH 12)
13    (CONST&PUSH 3)                      ; $%E
14    (CONST&PUSH 4)                      ; 2
15    (CONST&PUSH 5)                      ; $%PI
16    (CONST&PUSH 6)                      ; $%I
17    (LOAD&PUSH 7)
18    (GETVALUE&PUSH 1)                   ; N
20    (CALL&PUSH 5 7)                     ; MUL*
23    (CALL2&PUSH 8)                      ; POWER*
25    (CALL&PUSH 3 7)                     ; MUL*
28    (CALL2&PUSH 9)                      ; ADD*
30    (GETVALUE&PUSH 10)                  ; *VAR
32    (GETVALUE&PUSH 11)                  ; MULT
34    (CALL 3 12)                         ; SOLVE
37    (LOAD&DEC&STORE 0)
39    L39
39    (LOAD&PUSH 0)
40    (CALLS2&JMPIFNOT 145 L9)            ; ZEROP
43    (NIL)
44    (SKIP 1)
46    (UNBIND 2)
48    (SKIP&RET 5)


Disassembly of function #:|(DEFUN ADISPLINE (LINE) ...)-62|
(CONST 0) = ADISPLINE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ADISPLINE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ADISPLINE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ADISPLINE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ADISPLINE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ADISPLINE
8     (SKIP&RET 1)


Disassembly of function ADISPLINE
(CONST 0) = $BREAKUP
(CONST 1) = $PROGRAMMODE
(CONST 2) = DISPLINE
(CONST 3) = *VAR
(CONST 4) = BROKEN-FREEOF
(CONST 5) = BROKEN-NOT-FREEOF
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (BROKEN-NOT-FREEOF *VAR $PROGRAMMODE $BREAKUP)
writes special variable : (BROKEN-NOT-FREEOF)
20 byte-code instructions:
0     (GETVALUE 0)                        ; $BREAKUP
2     (JMPIFNOT L26)
4     (GETVALUE 1)                        ; $PROGRAMMODE
6     (JMPIF L26)
8     (LOAD&PUSH 1)
9     (CALL1&PUSH 2)                      ; DISPLINE
11    (GETVALUE&PUSH 3)                   ; *VAR
13    (LOAD&PUSH 3)
14    (CALL2&JMPIF 4 L23)                 ; BROKEN-FREEOF
17    (LOAD&PUSH 0)
18    (GETVALUE 5)                        ; BROKEN-NOT-FREEOF
20    (CONS)
21    (SETVALUE 5)                        ; BROKEN-NOT-FREEOF
23    L23
23    (POP)
24    (SKIP&RET 2)
26    L26
26    (LOAD&PUSH 1)
27    (CALL1 2)                           ; DISPLINE
29    (SKIP&RET 2)


Disassembly of function #:|(SETQ BROKEN-NOT-FREEOF NIL)-63|
(CONST 0) = BROKEN-NOT-FREEOF
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (BROKEN-NOT-FREEOF)
3 byte-code instructions:
0     (NIL)
1     (SETVALUE 0)                        ; BROKEN-NOT-FREEOF
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN BROKEN-FREEOF (VAR EXP) ...)-64|
(CONST 0) = BROKEN-FREEOF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BROKEN-FREEOF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BROKEN-FREEOF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BROKEN-FREEOF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BROKEN-FREEOF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BROKEN-FREEOF
8     (SKIP&RET 1)


Disassembly of function BROKEN-FREEOF
(CONST 0) = VAR
(CONST 1) = EXP
(CONST 2) = $BREAKUP
(CONST 3) = BROKEN-NOT-FREEOF
(CONST 4) = ARGSFREEOF
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (BROKEN-NOT-FREEOF EXP VAR $BREAKUP)
32 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; EXP
6     (GETVALUE 2)                        ; $BREAKUP
8     (JMPIF L25)
10    (GETVALUE&PUSH 0)                   ; VAR
12    (GETVALUE&PUSH 1)                   ; EXP
14    (CALL2 4)                           ; ARGSFREEOF
16    L16
16    (UNBIND 2)
18    (SKIP&RET 3)
20    L20
20    (NIL)
21    (SKIP 2)
23    (JMP L16)
25    L25
25    (GETVALUE&PUSH 0)                   ; VAR
27    (GETVALUE&PUSH 3)                   ; BROKEN-NOT-FREEOF
29    (LOAD&JMPIFNOT 1 L47)
32    L32
32    (LOAD&PUSH 1)
33    (GETVALUE&PUSH 1)                   ; EXP
35    (CALL2&JMPIFNOT 4 L20)              ; ARGSFREEOF
38    (LOAD&CAR&PUSH 0)
40    (LOAD&CDR&STORE 1)
42    (POP&STORE 1)
44    (LOAD&JMPIF 1 L32)
47    L47
47    (T)
48    (SKIP 2)
50    (JMP L16)


Disassembly of function #:|(DEFUN SOLVE3 (EXP MULT) ...)-65|
(CONST 0) = SOLVE3
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVE3>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVE3
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVE3
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVE3>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVE3
8     (SKIP&RET 1)


Disassembly of function SOLVE3
(CONST 0) = EXP
(CONST 1) = MULT
(CONST 2) = SIMPLIFY
(CONST 3) = *VAR
(CONST 4) = BROKEN-FREEOF
(CONST 5) = *FAILURES
(CONST 6) = (MEQUAL SIMP)
(CONST 7) = *MYVAR
(CONST 8) = *ROOTS
(CONST 9) = USOLVE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*ROOTS *FAILURES MULT *MYVAR *VAR EXP)
writes special variables : (*ROOTS *FAILURES EXP)
60 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; MULT
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1 2)                           ; SIMPLIFY
10    (SETVALUE 0)                        ; EXP
12    (GETVALUE&PUSH 3)                   ; *VAR
14    (GETVALUE&PUSH 0)                   ; EXP
16    (CALL2&JMPIFNOT 4 L51)              ; BROKEN-FREEOF
19    (GETVALUE&PUSH 7)                   ; *MYVAR
21    (GETVALUE 3)                        ; *VAR
23    (JMPIFEQ L65)
25    (GETVALUE 7)                        ; *MYVAR
27    (JMPIFCONSP L86)
29    (GETVALUE&PUSH 1)                   ; MULT
31    (GETVALUE 5)                        ; *FAILURES
33    (CONS)
34    (SETVALUE 5)                        ; *FAILURES
36    (CONST&PUSH 6)                      ; (MEQUAL SIMP)
37    (GETVALUE 7)                        ; *MYVAR
39    L39
39    (PUSH)
40    (GETVALUE&PUSH 0)                   ; EXP
42    (LIST&PUSH 3)
44    (GETVALUE 5)                        ; *FAILURES
46    (CONS)
47    (SETVALUE 5)                        ; *FAILURES
49    (JMP L94)
51    L51
51    (GETVALUE&PUSH 1)                   ; MULT
53    (GETVALUE 5)                        ; *FAILURES
55    (CONS)
56    (SETVALUE 5)                        ; *FAILURES
58    (CONST&PUSH 6)                      ; (MEQUAL SIMP)
59    (GETVALUE&PUSH 7)                   ; *MYVAR
61    (CALL1 2)                           ; SIMPLIFY
63    (JMP L39)
65    L65
65    (GETVALUE&PUSH 1)                   ; MULT
67    (GETVALUE 8)                        ; *ROOTS
69    (CONS)
70    (SETVALUE 8)                        ; *ROOTS
72    (CONST&PUSH 6)                      ; (MEQUAL SIMP)
73    (GETVALUE&PUSH 3)                   ; *VAR
75    (GETVALUE&PUSH 0)                   ; EXP
77    (LIST&PUSH 3)
79    (GETVALUE 8)                        ; *ROOTS
81    (CONS)
82    (SETVALUE 8)                        ; *ROOTS
84    (JMP L94)
86    L86
86    (GETVALUE&PUSH 0)                   ; EXP
88    (GETVALUE 7)                        ; *MYVAR
90    (CAR)
91    (CAR&PUSH)
92    (CALL2 9)                           ; USOLVE
94    L94
94    (UNBIND 2)
96    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SOLVELIN (EXP) ...)-66|
(CONST 0) = SOLVELIN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVELIN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVELIN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVELIN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVELIN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVELIN
8     (SKIP&RET 1)


Disassembly of function SOLVELIN
(CONST 0) = EXP
(CONST 1) = 0
(CONST 2) = PTERM
(CONST 3) = MULT
(CONST 4) = SOLVE1A
(CONST 5) = PMINUS
(CONST 6) = RATREDUCE
(CONST 7) = RDIS
(CONST 8) = SOLVE3
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT EXP)
29 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (CDR&PUSH)
6     (CONST&PUSH 1)                      ; 0
7     (CALL2&PUSH 2)                      ; PTERM
9     (JMPIFNOTEQTO 1 L21)                ; 0
12    (GETVALUE 0)                        ; EXP
14    (CDR)
15    (CDR)
16    (CAR&PUSH)
17    (GETVALUE&PUSH 3)                   ; MULT
19    (CALL2 4)                           ; SOLVE1A
21    L21
21    (GETVALUE 0)                        ; EXP
23    (CDR&PUSH)
24    (CONST&PUSH 1)                      ; 0
25    (CALL2&PUSH 2)                      ; PTERM
27    (CALL1&PUSH 5)                      ; PMINUS
29    (GETVALUE 0)                        ; EXP
31    (CDR)
32    (CDR)
33    (CAR&PUSH)
34    (CALL2&PUSH 6)                      ; RATREDUCE
36    (CALL1&PUSH 7)                      ; RDIS
38    (GETVALUE&PUSH 3)                   ; MULT
40    (CALL2 8)                           ; SOLVE3
42    (UNBIND1)
43    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (MUZZLED T))-67|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN SOLVEQUAD (EXP &AUX DISCRIM ...) ...)-68|
(CONST 0) = SOLVEQUAD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVEQUAD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVEQUAD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVEQUAD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVEQUAD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVEQUAD
8     (SKIP&RET 1)


Disassembly of function SOLVEQUAD
(CONST 0) = EXP
(CONST 1) = A
(CONST 2) = B
(CONST 3) = C
(CONST 4) = 1
(CONST 5) = PTERM
(CONST 6) = 0
(CONST 7) = 2
(CONST 8) = PEXPT
(CONST 9) = 4
(CONST 10) = PTIMES
(CONST 11) = PMINUS
(CONST 12) = PPLUS
(CONST 13) = PDIS
(CONST 14) = SIMPLIFY
(CONST 15) = VARLIST
(CONST 16) = (MQUOTIENT)
(CONST 17) = FULLRATSIMP
(CONST 18) = MULT
(CONST 19) = SOLVE3
(CONST 20) = SIMPNRT
(CONST 21) = (MQUOTIENT)
(CONST 22) = (MPLUS)
(CONST 23) = (MQUOTIENT)
(CONST 24) = (MPLUS)
(CONST 25) = (MMINUS)
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (MULT C A B EXP)
writes special variables : (C B A)
92 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (NIL)
5     (BIND 1)                            ; A
7     (NIL)
8     (BIND 2)                            ; B
10    (NIL)
11    (BIND 3)                            ; C
13    (GETVALUE 0)                        ; EXP
15    (CDR)
16    (CDR)
17    (CAR)
18    (SETVALUE 1)                        ; A
20    (GETVALUE 0)                        ; EXP
22    (CDR&PUSH)
23    (CONST&PUSH 4)                      ; 1
24    (CALL2 5)                           ; PTERM
26    (SETVALUE 2)                        ; B
28    (GETVALUE 0)                        ; EXP
30    (CDR&PUSH)
31    (CONST&PUSH 6)                      ; 0
32    (CALL2 5)                           ; PTERM
34    (SETVALUE 3)                        ; C
36    (GETVALUE&PUSH 2)                   ; B
38    (CONST&PUSH 7)                      ; 2
39    (CALL2&PUSH 8)                      ; PEXPT
41    (CONST&PUSH 9)                      ; 4
42    (GETVALUE&PUSH 1)                   ; A
44    (GETVALUE&PUSH 3)                   ; C
46    (CALL2&PUSH 10)                     ; PTIMES
48    (CALL2&PUSH 10)                     ; PTIMES
50    (CALL1&PUSH 11)                     ; PMINUS
52    (CALL2&PUSH 12)                     ; PPLUS
54    (CALL1&PUSH 13)                     ; PDIS
56    (CALL1 14)                          ; SIMPLIFY
58    (STORE 9)
60    (GETVALUE&PUSH 2)                   ; B
62    (CALL1&PUSH 11)                     ; PMINUS
64    (CALL1 13)                          ; PDIS
66    (SETVALUE 2)                        ; B
68    (CONST&PUSH 7)                      ; 2
69    (GETVALUE&PUSH 1)                   ; A
71    (CALL2&PUSH 10)                     ; PTIMES
73    (CALL1 13)                          ; PDIS
75    (SETVALUE 1)                        ; A
77    (NIL)
78    (BIND 15)                           ; VARLIST
80    (LOAD&PUSH 12)
81    (JMPIFEQTO 6 L135)                  ; 0
84    (LOAD&PUSH 12)
85    (CONST&PUSH 7)                      ; 2
86    (CALL2 20)                          ; SIMPNRT
88    (STORE 12)
90    (CONST&PUSH 21)                     ; (MQUOTIENT)
91    (CONST&PUSH 22)                     ; (MPLUS)
92    (GETVALUE&PUSH 2)                   ; B
94    (LOAD&PUSH 15)
95    (LIST&PUSH 3)
97    (GETVALUE&PUSH 1)                   ; A
99    (LIST&PUSH 3)
101   (CALL1&PUSH 17)                     ; FULLRATSIMP
103   (GETVALUE&PUSH 18)                  ; MULT
105   (CALL2 19)                          ; SOLVE3
107   (CONST&PUSH 23)                     ; (MQUOTIENT)
108   (CONST&PUSH 24)                     ; (MPLUS)
109   (GETVALUE&PUSH 2)                   ; B
111   (CONST&PUSH 25)                     ; (MMINUS)
112   (LOAD&PUSH 16)
113   (LIST&PUSH 2)
115   (LIST&PUSH 3)
117   (GETVALUE&PUSH 1)                   ; A
119   (LIST&PUSH 3)
121   (CALL1&PUSH 17)                     ; FULLRATSIMP
123   (GETVALUE 18)                       ; MULT
125   L125
125   (PUSH)
126   (CALL2 19)                          ; SOLVE3
128   (UNBIND 4)
130   (SKIP 1)
132   (UNBIND1)
133   (SKIP&RET 2)
135   L135
135   (CONST&PUSH 16)                     ; (MQUOTIENT)
136   (GETVALUE&PUSH 2)                   ; B
138   (GETVALUE&PUSH 1)                   ; A
140   (LIST&PUSH 3)
142   (CALL1&PUSH 17)                     ; FULLRATSIMP
144   (CONST&PUSH 7)                      ; 2
145   (GETVALUE&PUSH 18)                  ; MULT
147   (CALLSR 2 55)                       ; *
150   (JMP L125)


Disassembly of function #:|(DECLARE-TOP (MUZZLED NIL))-69|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN VARSORT (V) ...)-70|
(CONST 0) = VARSORT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE VARSORT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; VARSORT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; VARSORT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE VARSORT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; VARSORT
8     (SKIP&RET 1)


Disassembly of function VARSORT
(CONST 0) = V
(CONST 1) = *V
(CONST 2) = *VAR
(CONST 3) = BROKEN-FREEOF
(CONST 4) = 1
(CONST 5) = ZL-DELETE
(CONST 6) = $DONTFACTOR
(CONST 7) = *HAS*VAR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*VAR *V V)
writes special variables : (*HAS*VAR $DONTFACTOR *V)
42 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; V
3     (NIL&PUSH)
4     (GETVALUE&PUSH 0)                   ; V
6     (CALLS1 158)                        ; COPY-LIST
8     (BIND 1)                            ; *V
10    (GETVALUE&PUSH 0)                   ; V
12    (LOAD&PUSH 0)
13    (JMP L43)
15    L15
15    (LOAD&PUSH 0)
16    (LOAD&CONS&STORE 6)
18    (LOAD&PUSH 0)
19    (GETVALUE&PUSH 1)                   ; *V
21    (CONST&PUSH 4)                      ; 1
22    (CALL 3 5)                          ; ZL-DELETE
25    (SETVALUE 1)                        ; *V
27    (SKIP 1)
29    (JMP L41)
31    L31
31    (LOAD&CAR&PUSH 0)
33    (GETVALUE&PUSH 2)                   ; *VAR
35    (LOAD&PUSH 1)
36    (CALL2&JMPIF 3 L15)                 ; BROKEN-FREEOF
39    (SKIP 1)
41    L41
41    (LOAD&CDR&STORE 0)
43    L43
43    (LOAD&PUSH 0)
44    (CALLS1&JMPIFNOT 146 L31)           ; ENDP
47    (SKIP 2)
49    (LOAD 3)
50    (SETVALUE 6)                        ; $DONTFACTOR
52    (GETVALUE 1)                        ; *V
54    (SETVALUE 7)                        ; *HAS*VAR
56    (LOAD&PUSH 3)
57    (GETVALUE&PUSH 1)                   ; *V
59    (CALLSR 2 34)                       ; APPEND
62    (UNBIND1)
63    (SKIP 1)
65    (UNBIND1)
66    (SKIP&RET 2)


Disassembly of function #:|(DEFUN USOLVE (EXP OP) ...)-71|
(CONST 0) = USOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE USOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; USOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; USOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE USOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; USOLVE
8     (SKIP&RET 1)


Disassembly of function USOLVE
(CONST 0) = EXP
(CONST 1) = MEXPT
(CONST 2) = *VAR
(CONST 3) = *MYVAR
(CONST 4) = BROKEN-FREEOF
(CONST 5) = 0
(CONST 6) = (MPLUS)
(CONST 7) = (MMINUS)
(CONST 8) = (%LOG)
(CONST 9) = (%LOG)
(CONST 10) = DIV*
(CONST 11) = MNEGP
(CONST 12) = $INTEGER
(CONST 13) = ASK-INTEGER
(CONST 14) = $YES
(CONST 15) = $%I
(CONST 16) = FREE
(CONST 17) = $ASKSIGN
(CONST 18) = $NEG
(CONST 19) = (MPLUS)
(CONST 20) = (MMINUS)
(CONST 21) = (MEXPT)
(CONST 22) = 1
(CONST 23) = $INVERSE
(CONST 24) = $SOLVETRIGWARN
(CONST 25) = (%SIN %COS %TAN %SEC %CSC %COT %COSH %SECH)
(CONST 26) = MEMQ
(CONST 27) = 
"~&SOLVE is using arc-trig functions to get ~
			    a solution.~%Some solutions will be lost.~%"
(CONST 28) = MTELL
(CONST 29) = (MPLUS)
(CONST 30) = (MMINUS)
(CONST 31) = %LOG
(CONST 32) = (MPLUS)
(CONST 33) = (MMINUS)
(CONST 34) = (MEXPT)
(CONST 35) = $%E
(CONST 36) = SIMPLIFY
(CONST 37) = MULT
(CONST 38) = SOLVE
(CONST 39) = (MEQUAL)
(CONST 40) = *FAILURES
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*FAILURES MULT *VAR EXP *MYVAR $SOLVETRIGWARN)
writes special variables : (*FAILURES $SOLVETRIGWARN)
146 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (LOAD&PUSH 5)
5     (JMPIFEQTO 1 L164)                  ; MEXPT
9     (LOAD&PUSH 5)
10    (CONST&PUSH 23)                     ; $INVERSE
11    (PUSH-UNBOUND 1)
13    (CALLS2&STORE 132 0)                ; GET
16    (JMPIFNOT L122)
19    (GETVALUE 24)                       ; $SOLVETRIGWARN
21    (JMPIFNOT L34)
23    (LOAD&PUSH 5)
24    (CONST&PUSH 25)                     ; (%SIN %COS %TAN %SEC %CSC %COT ...)
25    (CALL2&JMPIFNOT 26 L34)             ; MEMQ
28    (CONST&PUSH 27)                     ; "~&SOLVE is using arc-trig functions to get ~
			    a solution.~%Some solutions will be lost.~%"
29    (CALL1 28)                          ; MTELL
31    (NIL)
32    (SETVALUE 24)                       ; $SOLVETRIGWARN
34    L34
34    (CONST&PUSH 29)                     ; (MPLUS)
35    (CONST&PUSH 30)                     ; (MMINUS)
37    (GETVALUE 3)                        ; *MYVAR
39    (CDR)
40    (CAR&PUSH)
41    (LIST&PUSH 2)
43    (LOAD&PUSH 2)
44    (LIST&PUSH 1)
46    (GETVALUE 0)                        ; EXP
48    L48
48    (PUSH)
49    (LIST 2)
51    (JMP L145)
54    L54
54    (GETVALUE&PUSH 0)                   ; EXP
56    (JMPIFEQTO 5 L217)                  ; 0
60    (CONST&PUSH 6)                      ; (MPLUS)
61    (CONST&PUSH 7)                      ; (MMINUS)
62    (GETVALUE 3)                        ; *MYVAR
64    (CDR)
65    (CDR)
66    (CAR&PUSH)
67    (LIST&PUSH 2)
69    (CONST&PUSH 8)                      ; (%LOG)
70    (GETVALUE&PUSH 0)                   ; EXP
72    (LIST&PUSH 2)
74    (CONST&PUSH 9)                      ; (%LOG)
75    (GETVALUE 3)                        ; *MYVAR
77    (CDR)
78    (CAR&PUSH)
79    (LIST&PUSH 2)
81    (CALL2 10)                          ; DIV*
83    (JMP L145)
85    L85
85    (GETVALUE 3)                        ; *MYVAR
87    (CDR)
88    (CDR)
89    (CAR&PUSH)
90    (CALL1&JMPIF 11 L217)               ; MNEGP
94    (GETVALUE 3)                        ; *MYVAR
96    (CDR)
97    (CAR)
98    (JMP L148)
100   L100
100   (CONST&PUSH 19)                     ; (MPLUS)
101   (GETVALUE 3)                        ; *MYVAR
103   (CDR)
104   (CAR&PUSH)
105   (CONST&PUSH 20)                     ; (MMINUS)
106   (CONST&PUSH 21)                     ; (MEXPT)
107   (GETVALUE&PUSH 0)                   ; EXP
109   (CONST&PUSH 22)                     ; 1
110   (GETVALUE 3)                        ; *MYVAR
112   (CDR)
113   (CDR)
114   (CAR&PUSH)
115   (CALL2&PUSH 10)                     ; DIV*
117   (LIST 3)
119   (JMP L48)
122   L122
122   (LOAD&PUSH 5)
123   (JMPIFNOTEQTO 31 L217)              ; %LOG
127   (CONST&PUSH 32)                     ; (MPLUS)
129   (CONST&PUSH 33)                     ; (MMINUS)
131   (GETVALUE 3)                        ; *MYVAR
133   (CDR)
134   (CAR&PUSH)
135   (LIST&PUSH 2)
137   (CONST&PUSH 34)                     ; (MEXPT)
139   (CONST&PUSH 35)                     ; $%E
141   (GETVALUE&PUSH 0)                   ; EXP
143   (LIST 3)
145   L145
145   (PUSH)
146   (LIST 3)
148   L148
148   (STORE 0)
149   (PUSH)
150   (CALL1&PUSH 36)                     ; SIMPLIFY
152   (GETVALUE&PUSH 2)                   ; *VAR
154   (GETVALUE&PUSH 37)                  ; MULT
156   (CALL 3 38)                         ; SOLVE
159   (SKIP 1)
161   (JMP L237)
164   L164
164   (GETVALUE&PUSH 2)                   ; *VAR
166   (GETVALUE 3)                        ; *MYVAR
168   (CDR)
169   (CAR&PUSH)
170   (CALL2&JMPIF 4 L54)                 ; BROKEN-FREEOF
174   (GETVALUE&PUSH 2)                   ; *VAR
176   (GETVALUE 3)                        ; *MYVAR
178   (CDR)
179   (CDR)
180   (CAR&PUSH)
181   (CALL2&JMPIFNOT 4 L217)             ; BROKEN-FREEOF
184   (GETVALUE&PUSH 0)                   ; EXP
186   (JMPIFEQTO 5 L85)                   ; 0
190   (GETVALUE 3)                        ; *MYVAR
192   (CDR)
193   (CDR)
194   (CAR&PUSH)
195   (CONST&PUSH 12)                     ; $INTEGER
196   (CALL2&PUSH 13)                     ; ASK-INTEGER
198   (JMPIFEQTO 14 L100)                 ; $YES
202   (GETVALUE&PUSH 0)                   ; EXP
204   (CONST&PUSH 15)                     ; $%I
205   (CALL2&JMPIFNOT 16 L100)            ; FREE
209   (GETVALUE&PUSH 0)                   ; EXP
211   (CALL1&PUSH 17)                     ; $ASKSIGN
213   (JMPIFNOTEQTO 18 L100)              ; $NEG
217   L217
217   (CONST&PUSH 39)                     ; (MEQUAL)
219   (GETVALUE&PUSH 3)                   ; *MYVAR
221   (GETVALUE&PUSH 0)                   ; EXP
223   (LIST&PUSH 3)
225   (CALL1&PUSH 36)                     ; SIMPLIFY
227   (GETVALUE&PUSH 37)                  ; MULT
229   (GETVALUE 40)                       ; *FAILURES
231   (CONS)
232   (CONS)
233   (SETVALUE 40)                       ; *FAILURES
235   (SKIP 1)
237   L237
237   (UNBIND1)
238   (SKIP&RET 3)


Disassembly of function #:|(DEFUN COMPLICATED (EXP) ...)-72|
(CONST 0) = COMPLICATED
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COMPLICATED>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COMPLICATED
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COMPLICATED
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COMPLICATED>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COMPLICATED
8     (SKIP&RET 1)


Disassembly of function COMPLICATED
(CONST 0) = EXP
(CONST 1) = $BREAKUP
(CONST 2) = $PROGRAMMODE
(CONST 3) = MPLUS
(CONST 4) = FREE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP $PROGRAMMODE $BREAKUP)
14 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 1)                        ; $BREAKUP
5     (JMPIFNOT1 L18)
7     (GETVALUE 2)                        ; $PROGRAMMODE
9     (NOT)
10    (JMPIFNOT1 L18)
12    (GETVALUE&PUSH 0)                   ; EXP
14    (CONST&PUSH 3)                      ; MPLUS
15    (CALL2 4)                           ; FREE
17    (NOT)
18    L18
18    (UNBIND1)
19    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (MUZZLED T))-73|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN ROOTSORT (L) ...)-74|
(CONST 0) = ROOTSORT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ROOTSORT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ROOTSORT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ROOTSORT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ROOTSORT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ROOTSORT
8     (SKIP&RET 1)


Disassembly of function ROOTSORT
(CONST 0) = L
(CONST 1) = A
(CONST 2) = ALIKE1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A L)
writes special variables : (L A)
61 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (NIL)
4     (BIND 1)                            ; A
6     (PUSH-NIL 2)
8     (GETVALUE 0)                        ; L
10    (JMPIFNOT L75)
12    L12
12    (GETVALUE 0)                        ; L
14    (STORE 1)
15    (CAR)
16    (SETVALUE 1)                        ; A
18    (LOAD 1)
19    (CDR)
20    (STORE 0)
21    (JMP L60)
23    L23
23    (LOAD&PUSH 0)
24    (LOAD&CAR&PUSH 1)
26    (LOAD 3)
27    (CDR)
28    (CDR)
29    (CDR)
30    (CAR&PUSH)
31    (CALLSR&PUSH 2 53)                  ; +
34    (CALLS1 168)                        ; RPLACA
36    (LOAD&CDR&PUSH 1)
38    (LOAD 2)
39    (CDR)
40    (CDR)
41    (CDR)
42    (CDR&PUSH)
43    (CALLS1 170)                        ; RPLACD
45    (JMP L60)
47    L47
47    (LOAD 1)
48    (CDR)
49    (CDR)
50    (CAR&PUSH)
51    (GETVALUE&PUSH 1)                   ; A
53    (CALL2&JMPIF 2 L23)                 ; ALIKE1
56    (LOAD 1)
57    (CDR)
58    (CDR)
59    (STORE 1)
60    L60
60    (LOAD 1)
61    (CDR)
62    (CDR)
63    (JMPIF L47)
65    (GETVALUE 0)                        ; L
67    (CDR)
68    (CDR)
69    (SETVALUE 0)                        ; L
71    (GETVALUE 0)                        ; L
73    (JMPIF L12)
75    L75
75    (NIL)
76    (SKIP 2)
78    (UNBIND 2)
80    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (MUZZLED NIL))-75|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN $LINSOLVE (EQL VARL) ...)-76|
(CONST 0) = $LINSOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $LINSOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $LINSOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $LINSOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $LINSOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $LINSOLVE
8     (SKIP&RET 1)


Disassembly of function $LINSOLVE
(CONST 0) = $RATFAC
(CONST 1) = $LISTP
(CONST 2) = REMRED
(CONST 3) = MNUMP
(CONST 4) = "Unacceptable variable to SOLVE: ~M"
(CONST 5) = MERROR
(CONST 6) = (MLIST SIMP)
(CONST 7) = MEQHK
(CONST 8) = $PROGRAMMODE
(CONST 9) = SOLVEX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: ($PROGRAMMODE)
54 byte-code instructions:
0     (NIL)
1     (BIND 0)                            ; $RATFAC
3     (LOAD&PUSH 5)
4     (CALL1&JMPIF 1 L60)                 ; $LISTP
7     (LOAD&PUSH 5)
8     (NIL)
9     (CONS)
10    L10
10    (STORE 5)
11    (LOAD&PUSH 4)
12    (CALL1&JMPIF 1 L64)                 ; $LISTP
15    (LOAD&PUSH 4)
16    (NIL)
17    (CONS)
18    L18
18    (STORE 4)
19    (PUSH)
20    (LOAD&JMPIFNOT 0 L38)
23    L23
23    (LOAD&CAR&PUSH 0)
25    (CALL1&JMPIFNOT 3 L33)              ; MNUMP
28    (CONST&PUSH 4)                      ; "Unacceptable variable to SOLVE: ~M"
29    (LOAD&CAR&PUSH 1)
31    (CALL2 5)                           ; MERROR
33    L33
33    (LOAD&CDR&STORE 0)
35    (LOAD&JMPIF 0 L23)
38    L38
38    (SKIP 1)
40    (LOAD&JMPIFNOT 4 L70)
43    (CONST&PUSH 7)                      ; MEQHK
44    (LOAD&PUSH 6)
45    (CALLSR&PUSH 0 22)                  ; MAPCAR
48    (LOAD&PUSH 5)
49    (GETVALUE 8)                        ; $PROGRAMMODE
51    (NOT)
52    (PUSH)
53    (NIL&PUSH)
54    (CALL 4 9)                          ; SOLVEX
57    L57
57    (UNBIND1)
58    (SKIP&RET 3)
60    L60
60    (LOAD 5)
61    (CDR)
62    (JMP L10)
64    L64
64    (LOAD&CDR&PUSH 4)
66    (CALL1 2)                           ; REMRED
68    (JMP L18)
70    L70
70    (CONST&PUSH 6)                      ; (MLIST SIMP)
71    (LIST 1)
73    (JMP L57)


Disassembly of function #:|(DEFUN REMRED (L) ...)-77|
(CONST 0) = REMRED
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REMRED>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REMRED
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REMRED
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REMRED>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REMRED
8     (SKIP&RET 1)


Disassembly of function REMRED
(CONST 0) = L
(CONST 1) = UNION1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (L)
11 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (JMPIFNOT1 L13)
7     (PUSH)
8     (NIL&PUSH)
9     (CALL2&PUSH 1)                      ; UNION1
11    (CALLS2 73)                         ; NREVERSE
13    L13
13    (UNBIND1)
14    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SOLVEX (EQL VARL IND ...) ...)-78|
(CONST 0) = SOLVEX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SOLVEX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SOLVEX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SOLVEX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SOLVEX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SOLVEX
8     (SKIP&RET 1)


Disassembly of function SOLVEX
(CONST 0) = IND
(CONST 1) = FLAG
(CONST 2) = $ALGEBRAIC
(CONST 3) = ANS
(CONST 4) = VARLIST
(CONST 5) = GENVAR
(CONST 6) = LSOLVEFLAG
(CONST 7) = XM*
(CONST 8) = XN*
(CONST 9) = MUL*
(CONST 10) = SOLVEXP
(CONST 11) = X
(CONST 12) = $RATNUMER
(CONST 13) = $RATDISREP
(CONST 14) = ERRRJFFLAG
(CONST 15) = RATERR
(CONST 16) = XA*
(CONST 17) = FORMX
(CONST 18) = (MLIST)
(CONST 19) = $ALGSYS
(CONST 20) = "LINSOLVE ran into a nonlinear equation."
(CONST 21) = MERROR
(CONST 22) = TFGELI
(CONST 23) = $LINSOLVEWARN
(CONST 24) = "~&Dependent equations eliminated:  ~A~%"
(CONST 25) = MTELL
(CONST 26) = $SOLVE_INCONSISTENT_ERROR
(CONST 27) = "Inconsistent equations:  ~A"
(CONST 28) = ((MLIST SIMP))
(CONST 29) = 0
(CONST 30) = J
(CONST 31) = PTORAT
(CONST 32) = ITH
(CONST 33) = XRUTOUT
(CONST 34) = *REARRAY
(CONST 35) = $PROGRAMMODE
(CONST 36) = LINSORT
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
($PROGRAMMODE IND J XA* $SOLVE_INCONSISTENT_ERROR ANS $LINSOLVEWARN XM* XN* X
 FLAG $ALGEBRAIC)
writes special variables : (J ANS LSOLVEFLAG SOLVEXP)
185 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; IND
3     (LOAD 4)
4     (BIND 1)                            ; FLAG
6     (GETVALUE 2)                        ; $ALGEBRAIC
8     (BIND 2)                            ; $ALGEBRAIC
10    (NIL&PUSH)
11    (NIL)
12    (BIND 3)                            ; ANS
14    (NIL)
15    (BIND 4)                            ; VARLIST
17    (NIL)
18    (BIND 5)                            ; GENVAR
20    (NIL)
21    (BIND 6)                            ; LSOLVEFLAG
23    (NIL)
24    (BIND 7)                            ; XM*
26    (NIL)
27    (BIND 8)                            ; XN*
29    (NIL)
30    (BIND 9)                            ; MUL*
32    (NIL)
33    (BIND 10)                           ; SOLVEXP
35    (LOAD 37)
37    (STORE 24)
39    (GETVALUE 1)                        ; FLAG
41    (SETVALUE 10)                       ; SOLVEXP
43    (T)
44    (SETVALUE 6)                        ; LSOLVEFLAG
46    (NIL&PUSH)
47    (LOAD&PUSH 39)
49    (JMP L92)
51    L51
51    (CONST&PUSH 18)                     ; (MLIST)
52    (LOAD 39)
54    (CONS&PUSH)
55    (CONST&PUSH 18)                     ; (MLIST)
56    (LOAD 39)
58    (CONS&PUSH)
59    (CALL2 19)                          ; $ALGSYS
61    (JMP L290)
64    L64
64    (CONST 28)                          ; ((MLIST SIMP))
66    (UNBIND 8)
68    (SKIP 1)
70    (JMP L294)
73    L73
73    (LOAD&CAR&PUSH 0)
75    (LOAD 0)
76    (BIND 11)                           ; X
78    (GETVALUE&PUSH 11)                  ; X
80    (CALL1&PUSH 12)                     ; $RATNUMER
82    (CALL1 13)                          ; $RATDISREP
84    (UNBIND1)
85    (PUSH)
86    (LOAD&CONS&STORE 2)
88    (SKIP 1)
90    (LOAD&CDR&STORE 0)
92    L92
92    (LOAD&PUSH 0)
93    (CALLS1&JMPIFNOT 146 L73)           ; ENDP
96    (SKIP 1)
98    (LOAD&PUSH 0)
99    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
101   (SKIP 1)
103   (STORE 38)
105   (T)
106   (BIND 14)                           ; ERRRJFFLAG
108   (CONST 15)                          ; RATERR
109   (CATCH-OPEN L122)
111   (GETVALUE&PUSH 1)                   ; FLAG
113   (CONST&PUSH 16)                     ; XA*
114   (LOAD&PUSH 46)
116   (LOAD&PUSH 46)
118   (CALL 4 17)                         ; FORMX
121   (CATCH-CLOSE)
122   L122
122   (UNBIND1)
123   (JMPIFCONSP L133)
125   (GETVALUE 1)                        ; FLAG
127   (JMPIF L51)
130   (CONST&PUSH 20)                     ; "LINSOLVE ran into a nonlinear equation."
131   (CALL1 21)                          ; MERROR
133   L133
133   (CONST&PUSH 16)                     ; XA*
134   (GETVALUE&PUSH 8)                   ; XN*
136   (GETVALUE&PUSH 7)                   ; XM*
138   (CALL 3 22)                         ; TFGELI
141   (SETVALUE 3)                        ; ANS
143   (GETVALUE 23)                       ; $LINSOLVEWARN
145   (JMPIFNOT L158)
147   (GETVALUE 3)                        ; ANS
149   (CAR)
150   (JMPIFNOT L158)
152   (CONST&PUSH 24)                     ; "~&Dependent equations eliminated:  ~A~%"
153   (GETVALUE 3)                        ; ANS
155   (CAR&PUSH)
156   (CALL2 25)                          ; MTELL
158   L158
158   (GETVALUE 3)                        ; ANS
160   (CDR)
161   (CAR)
162   (JMPIFNOT L176)
164   (GETVALUE 26)                       ; $SOLVE_INCONSISTENT_ERROR
166   (JMPIFNOT L64)
169   (CONST&PUSH 27)                     ; "Inconsistent equations:  ~A"
170   (GETVALUE 3)                        ; ANS
172   (CDR)
173   (CAR&PUSH)
174   (CALL2 21)                          ; MERROR
176   L176
176   (CONST 29)                          ; 0
178   (BIND 30)                           ; J
180   (JMP L201)
182   L182
182   (GETVALUE&PUSH 16)                  ; XA*
184   (GETVALUE&PUSH 30)                  ; J
186   (LOAD&PUSH 1)
187   (CONST&PUSH 29)                     ; 0
188   (LOAD&PUSH 2)
189   (NIL&PUSH)
190   (CALLSR 2 2)                        ; SYSTEM::STORE
193   (SKIP 2)
195   (GETVALUE&PUSH 30)                  ; J
197   (CALLS2 150)                        ; 1+
199   (SETVALUE 30)                       ; J
201   L201
201   (GETVALUE&PUSH 30)                  ; J
203   (GETVALUE&PUSH 7)                   ; XM*
205   (CALLSR&JMPIFNOT 1 48 L182)         ; >
209   (UNBIND1)
210   (CONST&PUSH 16)                     ; XA*
211   (GETVALUE&PUSH 8)                   ; XN*
213   (GETVALUE&PUSH 7)                   ; XM*
215   (CALL 3 31)                         ; PTORAT
218   (CONST&PUSH 16)                     ; XA*
219   (GETVALUE&PUSH 8)                   ; XN*
221   (GETVALUE&PUSH 7)                   ; XM*
223   (NIL&PUSH)
224   (GETVALUE 3)                        ; ANS
226   (CDR)
227   (CDR)
228   (CAR&PUSH)
229   (JMP L264)
231   L231
231   (CONST&PUSH 18)                     ; (MLIST)
232   (LOAD&CDR&PUSH 38)
234   (LOAD&PUSH 26)
236   (CALL2 36)                          ; LINSORT
238   (CONS)
239   (STORE 37)
241   (LOAD 37)
243   (JMP L290)
245   L245
245   (LOAD&CAR&PUSH 0)
247   (LOAD 0)
248   (BIND 11)                           ; X
250   (LOAD&PUSH 46)
252   (GETVALUE&PUSH 11)                  ; X
254   (CALL2 32)                          ; ITH
256   (UNBIND1)
257   (PUSH)
258   (LOAD&CONS&STORE 2)
260   (SKIP 1)
262   (LOAD&CDR&STORE 0)
264   L264
264   (LOAD&PUSH 0)
265   (CALLS1&JMPIFNOT 146 L245)          ; ENDP
268   (SKIP 1)
270   (LOAD&PUSH 0)
271   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
274   (GETVALUE&PUSH 0)                   ; IND
276   (CALL 5 33)                         ; XRUTOUT
279   (STORE 37)
281   (CONST&PUSH 16)                     ; XA*
282   (CALL1 34)                          ; *REARRAY
284   (GETVALUE 35)                       ; $PROGRAMMODE
286   (JMPIF L231)
288   (LOAD 37)
290   L290
290   (UNBIND 8)
292   (SKIP 1)
294   L294
294   (UNBIND 3)
296   (SKIP&RET 5)


Disassembly of function #:|(DEFUN LINSORT (MEQ-LIST VAR-LIST) ...)-79|
(CONST 0) = LINSORT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LINSORT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LINSORT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LINSORT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LINSORT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LINSORT
8     (SKIP&RET 1)


Disassembly of function LINSORT
(CONST 0) = VAR-LIST
(CONST 1) = #.#'CDR
(CONST 2) = #<COMPILED-CLOSURE LINSORT-1>
(CONST 3) = SORTCAR
(CONST 4) = X
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
32 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAR-LIST
3     (NIL&PUSH)
4     (CONST&PUSH 1)                      ; #.#'CDR
5     (LOAD&PUSH 7)
6     (CALLSR&PUSH 0 22)                  ; MAPCAR
9     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LINSORT-1>
10    (CALL2&PUSH 3)                      ; SORTCAR
12    (JMP L33)
14    L14
14    (LOAD&CAR&PUSH 0)
16    (LOAD 0)
17    (BIND 4)                            ; X
19    (LOAD 11)
20    (CAR)
21    (CAR&PUSH)
22    (GETVALUE 4)                        ; X
24    (CONS)
25    (UNBIND1)
26    (PUSH)
27    (LOAD&CONS&STORE 2)
29    (SKIP 1)
31    (LOAD&CDR&STORE 0)
33    L33
33    (LOAD&PUSH 0)
34    (CALLS1&JMPIFNOT 146 L14)           ; ENDP
37    (SKIP 1)
39    (LOAD&PUSH 0)
40    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
42    (SKIP 1)
44    (UNBIND1)
45    (SKIP&RET 3)


Disassembly of function LINSORT-1
(CONST 0) = X
(CONST 1) = Y
(CONST 2) = VAR-LIST
(CONST 3) = ZL-MEMBER
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR-LIST X Y)
11 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; X
3     (LOAD 4)
4     (BIND 1)                            ; Y
6     (GETVALUE&PUSH 1)                   ; Y
8     (GETVALUE&PUSH 0)                   ; X
10    (GETVALUE&PUSH 2)                   ; VAR-LIST
12    (CALL2&PUSH 3)                      ; ZL-MEMBER
14    (CALL2 3)                           ; ZL-MEMBER
16    (UNBIND 2)
18    (SKIP&RET 3)


Wrote file binary-clisp/solve.fas
Wrote file /cygdrive/e/temp/maxima/src/solve.lis