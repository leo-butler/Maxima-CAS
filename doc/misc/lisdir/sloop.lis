Listing of compilation of file /cygdrive/e/temp/maxima/src/sloop.lisp
on 2002-12-17 13:31:50 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/sloop.lisp ...

Disassembly of function #:|(IN-PACKAGE "SLOOP")-1|
(CONST 0) = "SLOOP"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "SLOOP"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-1|
(CONST 0) = (SPECIAL *USE-LOCATIVES*)
(CONST 1) = *USE-LOCATIVES*
(CONST 2) = VARIABLE
(CONST 3) = "See sloop.lisp"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *USE-LOCATIVES*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *USE-LOCATIVES*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *USE-LOCATIVES*
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; *USE-LOCATIVES*
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "See sloop.lisp"
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-2|
(CONST 0) = (SPECIAL *AUTOMATIC-DECLARATIONS*)
(CONST 1) = *AUTOMATIC-DECLARATIONS*
(CONST 2) = (:FROM FIXNUM)
(CONST 3) = VARIABLE
(CONST 4) = "See sloop.lisp"
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *AUTOMATIC-DECLARATIONS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *AUTOMATIC-DECLARATIONS*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *AUTOMATIC-DECLARATIONS*
8     (CONST&PUSH 2)                      ; (:FROM FIXNUM)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; *AUTOMATIC-DECLARATIONS*
12    (CONST&PUSH 3)                      ; VARIABLE
13    (CONST&PUSH 4)                      ; "See sloop.lisp"
14    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-3|
(CONST 0) = (SPECIAL *AUTO-TYPE*)
(CONST 1) = *AUTO-TYPE*
(CONST 2) = (:FROM :IN :COLLECT)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *AUTO-TYPE*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *AUTO-TYPE*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *AUTO-TYPE*
8     (CONST&PUSH 2)                      ; (:FROM :IN :COLLECT)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (VALUES0)
12    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-4|
(CONST 0) = (SPECIAL *AUTO-REGISTER*)
(CONST 1) = *AUTO-REGISTER*
(CONST 2) = (:FROM :IN :COLLECT)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *AUTO-REGISTER*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *AUTO-REGISTER*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *AUTO-REGISTER*
8     (CONST&PUSH 2)                      ; (:FROM :IN :COLLECT)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (VALUES0)
12    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-5|
(CONST 0) = (DECLARATION :REGISTER)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; (DECLARATION :REGISTER)
1     (CALLS1 90)                         ; PROCLAIM
3     (VALUES0)
4     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-6|
(CONST 0) = (SPECIAL *TYPE-CHECK*)
(CONST 1) = *TYPE-CHECK*
(CONST 2) = VARIABLE
(CONST 3) = 
"If t adds a type check on bounds of from loop
if there is and automatic declare"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *TYPE-CHECK*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *TYPE-CHECK*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *TYPE-CHECK*
8     (T&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; *TYPE-CHECK*
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "If t adds a type check on bounds of from loop
if there is and automatic declare"
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE LOAD EVAL) (DEFVAR *USE-LOCATIVES* NIL ...) ...)-2-7|
(CONST 0) = (SPECIAL *MACROEXPAND-HOOK-FOR-NO-COPY*)
(CONST 1) = *MACROEXPAND-HOOK-FOR-NO-COPY*
(CONST 2) = FUNCALL
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL ...)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *MACROEXPAND-HOOK-FOR-NO-COPY*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *MACROEXPAND-HOOK-FOR-NO-COPY*
8     (CONST&PUSH 2)                      ; FUNCALL
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST 1)                           ; *MACROEXPAND-HOOK-FOR-NO-COPY*
12    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-1|
(CONST 0) = (SPECIAL *SLOOP-TRANSLATIONS*)
(CONST 1) = *SLOOP-TRANSLATIONS*
(CONST 2) = 
((APPENDING . APPEND) ((COLLECTING COLLECT) . COLLECT)
 ((MAXIMIZING MAXIMIZE) . MAXIMIZE) ((MINIMIZING MINIMIZE) . MINIMIZE)
 (NCONCING . NCONC) ((COUNT COUNTING) . COUNT) (SUMMING . SUM) (IF . WHEN)
 (AS . FOR) (IN-FRINGE . IN-FRINGE) (COLLATE . COLLATE) (IN-TABLE . IN-TABLE)
 (IN-CAREFULLY . IN-CAREFULLY) (AVERAGING . AVERAGING) (REPEAT . REPEAT)
 (FIRST-USE . FIRST-USE) (IN-ARRAY . IN-ARRAY))
(CONST 3) = VARIABLE
(CONST 4) = 
"A list of cons's where the translation is the cdr, and the car
is a list of names or name to be translated.  Essentially allows 'globalizing'
a symbol for the purposes of being a keyword in a sloop"
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *SLOOP-TRANSLATIONS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *SLOOP-TRANSLATIONS*
4     (CONST&PUSH 2)                      ; (# # # ...)
5     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
7     (CONST&PUSH 1)                      ; *SLOOP-TRANSLATIONS*
8     (CONST&PUSH 3)                      ; VARIABLE
9     (CONST&PUSH 4)                      ; "A list of cons's where the translation is the cdr, and the car
is a list of names or name to be translated.  Essentially allows 'globalizing'
a symbol for the purposes of being a keyword in a sloop"
10    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
13    (VALUES0)
14    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-2|
(CONST 0) = (SPECIAL *ADDITIONAL-COLLECTIONS*)
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *ADDITIONAL-COLLECTIONS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *ADDITIONAL-COLLECTIONS*
4     (NIL&PUSH)
5     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-3|
(CONST 0) = LCASE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LCASE>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; LCASE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LCASE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LCASE>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function LCASE
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = :COLLECT
(CONST 3) = (LOOP-COLLECT-KEYWORD-P .ITEM.)
(CONST 4) = :NO-BODY
(CONST 5) = (PARSE-NO-BODY .ITEM.)
(CONST 6) = (:SLOOP-MACRO :SLOOP-FOR :SLOOP-MAP)
(CONST 7) = AND
(CONST 8) = (SYMBOLP .ITEM.)
(CONST 9) = GET
(CONST 10) = .ITEM.
(CONST 11) = L-EQUAL
(CONST 12) = QUOTE
(CONST 13) = (T (ERROR "lcase fell off end ~a  " .ITEM.))
(CONST 14) = LET
(CONST 15) = TRANSLATE-NAME
(CONST 16) = COND
1 required argument
1 optional argument
No rest parameter
No keyword parameters
88 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 47 L105)            ; <
9     (LOAD 2)
10    (CDR)
11    (CAR&PUSH)
12    (LOAD 3)
13    (CDR)
14    (CDR&PUSH)
15    (PUSH-NIL 3)
17    (LOAD&PUSH 3)
18    (NIL&PUSH)
19    (LOAD&JMPIF 3 L78)
22    L22
22    (LOAD&JMPIFNOT 1 L78)
25    (LOAD&CAR&STORE 1 0)
28    (CAR&PUSH)
29    (T)
30    (JMPIFEQ L110)
33    (LOAD&CAR&PUSH 0)
35    (JMPIFEQTO 2 L115)                  ; :COLLECT
39    (LOAD&CAR&PUSH 0)
41    (JMPIFEQTO 4 L118)                  ; :NO-BODY
45    (LOAD&CAR&PUSH 0)
47    (CONST&PUSH 6)                      ; (:SLOOP-MACRO :SLOOP-FOR ...)
48    (PUSH-UNBOUND 3)
50    (CALLS1&STORE 180 2)                ; MEMBER
53    (JMPIF L121)
56    (CONST&PUSH 11)                     ; L-EQUAL
57    (CONST&PUSH 10)                     ; .ITEM.
58    (CONST&PUSH 12)                     ; QUOTE
59    (LOAD&CAR&PUSH 3)
61    (LIST 2)
63    L63
63    (PUSH)
64    (LIST 3)
66    L66
66    (PUSH)
67    (LOAD 1)
68    (CDR)
69    (CONS)
70    L70
70    (PUSH)
71    (LOAD&CONS&STORE 4)
73    (LOAD&CDR&STORE 1)
75    (LOAD&JMPIFNOT 3 L22)
78    L78
78    (SKIP 2)
80    (LOAD&JMPIF 1 L86)
83    (CONST&PUSH 13)                     ; (T #)
84    (LOAD&CONS&STORE 2)
86    L86
86    (CONST&PUSH 14)                     ; LET
87    (CONST&PUSH 10)                     ; .ITEM.
88    (CONST&PUSH 15)                     ; TRANSLATE-NAME
89    (LOAD&PUSH 7)
90    (LIST&PUSH 2)
92    (LIST&PUSH 2)
94    (LIST&PUSH 1)
96    (CONST&PUSH 16)                     ; COND
97    (LOAD&PUSH 5)
98    (CALLS2 73)                         ; NREVERSE
100   (CONS&PUSH)
101   (LIST 3)
103   (SKIP&RET 8)
105   L105
105   (LOAD&PUSH 2)
106   (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
108   (SKIP&RET 3)
110   L110
110   (T&STORE 3)
112   (LOAD 0)
113   (JMP L70)
115   L115
115   (CONST 3)                           ; (LOOP-COLLECT-KEYWORD-P .ITEM.)
116   (JMP L66)
118   L118
118   (CONST 5)                           ; (PARSE-NO-BODY .ITEM.)
119   (JMP L66)
121   L121
121   (CONST&PUSH 7)                      ; AND
122   (CONST&PUSH 8)                      ; (SYMBOLP .ITEM.)
123   (CONST&PUSH 9)                      ; GET
124   (CONST&PUSH 10)                     ; .ITEM.
125   (LOAD&CAR&PUSH 6)
127   (LIST 3)
129   (JMP L63)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-4|
(CONST 0) = DESETQ1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DESETQ1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DESETQ1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DESETQ1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DESETQ1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function DESETQ1
(CONST 0) = SETF
(CONST 1) = PROGN
(CONST 2) = CAR
(CONST 3) = CDR
(CONST 4) = ""
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
49 byte-code instructions:
0     L0
0     (LOAD&PUSH 2)
1     (CALLS2&JMPIF 6 L40)                ; SYMBOLP
4     (LOAD 2)
5     (JMPIFATOM L60)
7     (CONST&PUSH 1)                      ; PROGN
8     (LOAD&CAR&PUSH 3)
10    (CONST&PUSH 2)                      ; CAR
11    (LOAD&PUSH 4)
12    (LIST&PUSH 2)
14    (JSR&PUSH L0)
16    (LOAD 4)
17    (CDR)
18    (JMPIFCONSP L50)
20    (LOAD 4)
21    (CDR)
22    (JMPIFNOT L36)
24    (CONST&PUSH 0)                      ; SETF
25    (LOAD&CDR&PUSH 5)
27    (CONST&PUSH 3)                      ; CDR
28    (LOAD&PUSH 6)
29    (LIST&PUSH 2)
31    (LIST 3)
33    L33
33    (PUSH)
34    (LIST 1)
36    L36
36    (LIST* 2)
38    (SKIP&RET 3)
40    L40
40    (LOAD 2)
41    (JMPIFNOT1 L64)
43    (CONST&PUSH 0)                      ; SETF
44    (LOAD&PUSH 3)
45    (LOAD&PUSH 3)
46    (LIST 3)
48    (SKIP&RET 3)
50    L50
50    (LOAD&CDR&PUSH 4)
52    (CONST&PUSH 3)                      ; CDR
53    (LOAD&PUSH 5)
54    (LIST&PUSH 2)
56    (JSR L0)
58    (JMP L33)
60    L60
60    (CONST&PUSH 4)                      ; ""
61    (CALLSR 0 29)                       ; ERROR
64    L64
64    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-5|
(CONST 0) = DESETQ
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DESETQ>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; DESETQ
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DESETQ
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DESETQ>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function DESETQ
(CONST 0) = 3
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = DESETQ1
(CONST 3) = LET
1 required argument
1 optional argument
No rest parameter
No keyword parameters
34 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 3
4     (CALLSR&JMPIF 1 46 L37)             ; /=
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LOAD 0)
16    (JMPIFATOM L42)
18    (PUSH-UNBOUND 1)
20    (CALLS2&PUSH 143)                   ; GENSYM
22    (CONST&PUSH 3)                      ; LET
23    (LOAD&PUSH 1)
24    (LOAD&PUSH 3)
25    (LIST&PUSH 2)
27    (LIST&PUSH 1)
29    (LOAD&PUSH 4)
30    (LOAD&PUSH 3)
31    (CALL2&PUSH 2)                      ; DESETQ1
33    (LIST 3)
35    (SKIP&RET 6)
37    L37
37    (LOAD&PUSH 2)
38    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
40    (SKIP&RET 3)
42    L42
42    (LOAD&PUSH 1)
43    (LOAD&PUSH 1)
44    (CALL2 2)                           ; DESETQ1
46    (SKIP&RET 5)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-6|
(CONST 0) = LOOP-RETURN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-RETURN>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-RETURN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-RETURN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-RETURN>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function LOOP-RETURN
(CONST 0) = 1
(CONST 1) = RETURN
(CONST 2) = VALUES
1 required argument
1 optional argument
No rest parameter
No keyword parameters
16 byte-code instructions:
0     (LOAD&CDR&PUSH 2)
2     (LOAD&PUSH 0)
3     (CALLS2&PUSH 71)                    ; LENGTH
5     (CONST&PUSH 0)                      ; 1
6     (CALLSR&JMPIF 1 49 L18)             ; <=
10    (CONST&PUSH 1)                      ; RETURN
11    (CONST&PUSH 2)                      ; VALUES
12    (LOAD 2)
13    (CONS&PUSH)
14    (LIST 2)
16    (SKIP&RET 4)
18    L18
18    (CONST&PUSH 1)                      ; RETURN
19    (LOAD 1)
20    (CONS)
21    (SKIP&RET 4)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-7|
(CONST 0) = LOOP-FINISH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-FINISH>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-FINISH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-FINISH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-FINISH>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function LOOP-FINISH
(CONST 0) = 1
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = (GO FINISH-LOOP)
1 required argument
1 optional argument
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 1
4     (CALLSR&JMPIF 1 48 L11)             ; >
8     (CONST 2)                           ; (GO FINISH-LOOP)
9     (SKIP&RET 3)
11    L11
11    (LOAD&PUSH 2)
12    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
14    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-8|
(CONST 0) = LOCAL-FINISH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOCAL-FINISH>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOCAL-FINISH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOCAL-FINISH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOCAL-FINISH>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function LOCAL-FINISH
(CONST 0) = 1
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = (GO FINISH-LOOP)
1 required argument
1 optional argument
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 1
4     (CALLSR&JMPIF 1 48 L11)             ; >
8     (CONST 2)                           ; (GO FINISH-LOOP)
9     (SKIP&RET 3)
11    L11
11    (LOAD&PUSH 2)
12    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
14    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-9|
(CONST 0) = SLOOP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SLOOP>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SLOOP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SLOOP>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function SLOOP
(CONST 0) = PARSE-LOOP
1 required argument
1 optional argument
No rest parameter
No keyword parameters
4 byte-code instructions:
0     (LOAD&CDR&PUSH 2)
2     (LOAD&PUSH 0)
3     (CALL1 0)                           ; PARSE-LOOP
5     (SKIP&RET 4)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-10|
(CONST 0) = DEF-LOOP-MAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEF-LOOP-MAP>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEF-LOOP-MAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEF-LOOP-MAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEF-LOOP-MAP>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function DEF-LOOP-MAP
(CONST 0) = 3
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = MAP
(CONST 3) = DEF-LOOP-INTERNAL
1 required argument
1 optional argument
No rest parameter
No keyword parameters
25 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 3
4     (CALLSR&JMPIF 1 47 L28)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LOAD 4)
16    (CDR)
17    (CDR)
18    (CDR&PUSH)
19    (LOAD&PUSH 2)
20    (LOAD&PUSH 2)
21    (LOAD&PUSH 2)
22    (CONST&PUSH 2)                      ; MAP
23    (CALL 4 3)                          ; DEF-LOOP-INTERNAL
26    (SKIP&RET 6)
28    L28
28    (LOAD&PUSH 2)
29    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
31    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-11|
(CONST 0) = DEF-LOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEF-LOOP-FOR>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEF-LOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEF-LOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEF-LOOP-FOR>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function DEF-LOOP-FOR
(CONST 0) = 3
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = FOR
(CONST 3) = 1
(CONST 4) = DEF-LOOP-INTERNAL
1 required argument
1 optional argument
No rest parameter
No keyword parameters
27 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 3
4     (CALLSR&JMPIF 1 47 L30)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LOAD 4)
16    (CDR)
17    (CDR)
18    (CDR&PUSH)
19    (LOAD&PUSH 2)
20    (LOAD&PUSH 2)
21    (LOAD&PUSH 2)
22    (CONST&PUSH 2)                      ; FOR
23    (NIL&PUSH)
24    (CONST&PUSH 3)                      ; 1
25    (CALL 6 4)                          ; DEF-LOOP-INTERNAL
28    (SKIP&RET 6)
30    L30
30    (LOAD&PUSH 2)
31    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
33    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-12|
(CONST 0) = DEF-LOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEF-LOOP-MACRO>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEF-LOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEF-LOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEF-LOOP-MACRO>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function DEF-LOOP-MACRO
(CONST 0) = 3
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = MACRO
(CONST 3) = DEF-LOOP-INTERNAL
1 required argument
1 optional argument
No rest parameter
No keyword parameters
25 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 3
4     (CALLSR&JMPIF 1 47 L28)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LOAD 4)
16    (CDR)
17    (CDR)
18    (CDR&PUSH)
19    (LOAD&PUSH 2)
20    (LOAD&PUSH 2)
21    (LOAD&PUSH 2)
22    (CONST&PUSH 2)                      ; MACRO
23    (CALL 4 3)                          ; DEF-LOOP-INTERNAL
26    (SKIP&RET 6)
28    L28
28    (LOAD&PUSH 2)
29    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
31    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-13|
(CONST 0) = DEF-LOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = "Define function of 2 args arglist= (collect-var value-to-collect)"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE DEF-LOOP-COLLECT>
(CONST 6) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
12 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEF-LOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEF-LOOP-COLLECT
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Define function of 2 args arglist= (collect-var value-to-collect)"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; DEF-LOOP-COLLECT
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE DEF-LOOP-COLLECT>
11    (CALL1&PUSH 6)                      ; SYSTEM::MAKE-MACRO
13    (CALLS2 130)                        ; SYSTEM::%PUTD
15    (VALUES0)
16    (SKIP&RET 1)


Disassembly of function DEF-LOOP-COLLECT
(CONST 0) = 3
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = COLLECT
(CONST 3) = *ADDITIONAL-COLLECTIONS*
(CONST 4) = 2
(CONST 5) = DEF-LOOP-INTERNAL
1 required argument
1 optional argument
No rest parameter
No keyword parameters
28 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 3
4     (CALLSR&JMPIF 1 47 L31)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR)
14    (CAR&PUSH)
15    (LOAD 4)
16    (CDR)
17    (CDR)
18    (CDR&PUSH)
19    (LOAD&PUSH 2)
20    (LOAD&PUSH 2)
21    (LOAD&PUSH 2)
22    (CONST&PUSH 2)                      ; COLLECT
23    (CONST&PUSH 3)                      ; *ADDITIONAL-COLLECTIONS*
24    (CONST&PUSH 4)                      ; 2
25    (CONST&PUSH 4)                      ; 2
26    (CALL 7 5)                          ; DEF-LOOP-INTERNAL
29    (SKIP&RET 6)
31    L31
31    (LOAD&PUSH 2)
32    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
34    (SKIP&RET 3)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFPARAMETER *SLOOP-TRANSLATIONS* '# ...) ...)-3-14|
(CONST 0) = SLOOP-SWAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SLOOP-SWAP>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP-SWAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SLOOP-SWAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SLOOP-SWAP>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (CONST 0)                           ; SLOOP-SWAP
10    (SKIP&RET 1)


Disassembly of function SLOOP-SWAP
(CONST 0) = 1
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = 
(PROGN (ROTATEF A *LOOP-BINDINGS*) (ROTATEF B *LOOP-PROLOGUE*)
 (ROTATEF C *LOOP-EPILOGUE*) (ROTATEF E *LOOP-END-TEST*)
 (ROTATEF F *LOOP-INCREMENT*) (SETF *INNER-SLOOP* (NOT *INNER-SLOOP*)))
1 required argument
1 optional argument
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 1
4     (CALLSR&JMPIF 1 48 L11)             ; >
8     (CONST 2)                           ; (PROGN (ROTATEF A ...) ...)
9     (SKIP&RET 3)
11    L11
11    (LOAD&PUSH 2)
12    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
14    (SKIP&RET 3)


Disassembly of function #:|(DEFUN L-EQUAL (A B) ...)-4|
(CONST 0) = L-EQUAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE L-EQUAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; L-EQUAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; L-EQUAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE L-EQUAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; L-EQUAL
8     (SKIP&RET 1)


Disassembly of function L-EQUAL
(CONST 0) = L-EQUAL
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
25 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2 6)                          ; SYMBOLP
3     (JMPIFNOT1 L35)
5     (LOAD&PUSH 1)
6     (CALLS2&JMPIF 6 L16)                ; SYMBOLP
9     (LOAD&PUSH 1)
10    (CALLS2&JMPIF 11 L26)               ; LISTP
13    (NIL)
14    (SKIP&RET 3)
16    L16
16    (LOAD&PUSH 2)
17    (CALLS2&PUSH 140)                   ; SYMBOL-NAME
19    (LOAD&PUSH 2)
20    (CALLS2&PUSH 140)                   ; SYMBOL-NAME
22    (CALLS2 2)                          ; EQUAL
24    (SKIP&RET 3)
26    L26
26    (LOAD&PUSH 2)
27    (LOAD&PUSH 2)
28    (CONST&PUSH 0)                      ; L-EQUAL
29    (PUSH-UNBOUND 2)
31    (CALLS1 180)                        ; MEMBER
33    (SKIP&RET 3)
35    L35
35    (SKIP&RET 3)


Disassembly of function #:|(DEFUN LOOP-COLLECT-KEYWORD-P (COMMAND) ...)-5|
(CONST 0) = LOOP-COLLECT-KEYWORD-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-COLLECT-KEYWORD-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-COLLECT-KEYWORD-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-COLLECT-KEYWORD-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-COLLECT-KEYWORD-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-COLLECT-KEYWORD-P
8     (SKIP&RET 1)


Disassembly of function LOOP-COLLECT-KEYWORD-P
(CONST 0) = (COLLECT APPEND NCONC SUM COUNT)
(CONST 1) = L-EQUAL
(CONST 2) = *ADDITIONAL-COLLECTIONS*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
15 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CONST&PUSH 0)                      ; (COLLECT APPEND NCONC SUM COUNT)
2     (CONST&PUSH 1)                      ; L-EQUAL
3     (PUSH-UNBOUND 2)
5     (CALLS1 180)                        ; MEMBER
7     (JMPIF1 L20)
9     (LOAD&PUSH 1)
10    (GETVALUE&PUSH 2)                   ; *ADDITIONAL-COLLECTIONS*
12    (PUSH-UNBOUND 6)
14    (CONST 1)                           ; L-EQUAL
15    (STORE 1)
16    (CALLS2 92)                         ; FIND
18    (SKIP&RET 2)
20    L20
20    (SKIP&RET 2)


Disassembly of function #:|(DEFUN TRANSLATE-NAME (NAME) ...)-6|
(CONST 0) = TRANSLATE-NAME
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRANSLATE-NAME>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRANSLATE-NAME
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRANSLATE-NAME
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRANSLATE-NAME>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRANSLATE-NAME
8     (SKIP&RET 1)


Disassembly of function TRANSLATE-NAME
(CONST 0) = *SLOOP-TRANSLATIONS*
(CONST 1) = L-EQUAL
(CONST 2) = CAR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*SLOOP-TRANSLATIONS*)
16 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALLS2&JMPIFNOT 6 L17)             ; SYMBOLP
4     (LOAD&PUSH 1)
5     (GETVALUE&PUSH 0)                   ; *SLOOP-TRANSLATIONS*
7     (CONST&PUSH 1)                      ; L-EQUAL
8     (PUSH-UNBOUND 1)
10    (CONST&PUSH 2)                      ; CAR
11    (CALLS1 180)                        ; MEMBER
13    (CAR)
14    (CDR)
15    (JMPIF1 L20)
17    L17
17    (LOAD 1)
18    (SKIP&RET 2)
20    L20
20    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LOOP-POP NIL ...)-7|
(CONST 0) = LOOP-POP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-POP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-POP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-POP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-POP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-POP
8     (SKIP&RET 1)


Disassembly of function LOOP-POP
(CONST 0) = *LOOP-FORM*
(CONST 1) = *LAST-VAL*
(CONST 2) = EMPTY-FORM
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-FORM*)
writes special variables : (*LOOP-FORM* *LAST-VAL*)
14 byte-code instructions:
0     (GETVALUE 0)                        ; *LOOP-FORM*
2     (JMPIF L10)
4     (CONST 2)                           ; EMPTY-FORM
5     (SETVALUE 1)                        ; *LAST-VAL*
7     (NIL)
8     (SKIP&RET 1)
10    L10
10    (CAR&PUSH)
11    (GETVALUE 0)                        ; *LOOP-FORM*
13    (CDR)
14    (SETVALUE 0)                        ; *LOOP-FORM*
16    (POP)
17    (SETVALUE 1)                        ; *LAST-VAL*
19    (SKIP&RET 1)


Disassembly of function #:|(DEFUN LOOP-UN-POP NIL ...)-8|
(CONST 0) = LOOP-UN-POP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-UN-POP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-UN-POP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-UN-POP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-UN-POP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-UN-POP
8     (SKIP&RET 1)


Disassembly of function LOOP-UN-POP
(CONST 0) = *LAST-VAL*
(CONST 1) = EMPTY-FORM
(CONST 2) = ALREADY-UN-POPPED
(CONST 3) = "you are un-popping without popping"
(CONST 4) = *LOOP-FORM*
(CONST 5) = ALREAD-UN-POPPED
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-FORM* *LAST-VAL*)
writes special variables : (*LAST-VAL* *LOOP-FORM*)
18 byte-code instructions:
0     (GETVALUE&PUSH 0)                   ; *LAST-VAL*
2     (LOAD&PUSH 0)
3     (JMPIFEQTO 1 L22)                   ; EMPTY-FORM
6     (LOAD&PUSH 0)
7     (JMPIFEQTO 2 L25)                   ; ALREADY-UN-POPPED
10    (GETVALUE&PUSH 0)                   ; *LAST-VAL*
12    (GETVALUE 4)                        ; *LOOP-FORM*
14    (CONS)
15    (SETVALUE 4)                        ; *LOOP-FORM*
17    (CONST 5)                           ; ALREAD-UN-POPPED
18    (SETVALUE 0)                        ; *LAST-VAL*
20    (SKIP&RET 2)
22    L22
22    (NIL)
23    (SKIP&RET 2)
25    L25
25    (CONST&PUSH 3)                      ; "you are un-popping without popping"
26    (CALLSR 0 29)                       ; ERROR


Disassembly of function #:|(DEFUN LOOP-PEEK NIL ...)-9|
(CONST 0) = LOOP-PEEK
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-PEEK>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-PEEK
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-PEEK
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-PEEK>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-PEEK
8     (SKIP&RET 1)


Disassembly of function LOOP-PEEK
(CONST 0) = *LOOP-FORM*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-FORM*)
3 byte-code instructions:
0     (GETVALUE 0)                        ; *LOOP-FORM*
2     (CAR)
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN LOOP-LET-BINDINGS (BINDS) ...)-10|
(CONST 0) = LOOP-LET-BINDINGS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-LET-BINDINGS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-LET-BINDINGS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-LET-BINDINGS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-LET-BINDINGS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-LET-BINDINGS
8     (SKIP&RET 1)


Disassembly of function LOOP-LET-BINDINGS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
19 byte-code instructions:
0     (LOAD&CAR&PUSH 1)
2     (LOAD&JMPIFNOT 0 L21)
5     L5
5     (LOAD 0)
6     (CAR)
7     (CDR)
8     (JMPIF L16)
10    (LOAD&PUSH 0)
11    (LOAD 1)
12    (CAR)
13    (CAR&PUSH)
14    (CALLS1 169)                        ; SYSTEM::%RPLACA
16    L16
16    (LOAD&CDR&STORE 0)
18    (LOAD&JMPIF 0 L5)
21    L21
21    (LOAD&CAR&PUSH 2)
23    (CALLS2 73)                         ; NREVERSE
25    (SKIP&RET 3)


Disassembly of function #:|(DEFUN PARSE-LOOP (FORM &AUX INNER-BODY) ...)-11|
(CONST 0) = PARSE-LOOP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP
(CONST 0) = *LOOP-FORM*
(CONST 1) = *AUTOMATIC-DECLARATIONS*
(CONST 2) = *LAST-VAL*
(CONST 3) = *LOOP-MAP*
(CONST 4) = *LOOP-BODY*
(CONST 5) = *LOOP-NAME*
(CONST 6) = *LOOP-PROLOGUE*
(CONST 7) = *INNER-SLOOP*
(CONST 8) = *LOOP-EPILOGUE*
(CONST 9) = *LOOP-INCREMENT*
(CONST 10) = *LOOP-COLLECT-POINTERS*
(CONST 11) = *LOOP-MAP-DECLARES*
(CONST 12) = *LOOP-COLLECT-VAR*
(CONST 13) = *NO-DECLARE*
(CONST 14) = *LOOP-END-TEST*
(CONST 15) = *LOOP-BINDINGS*
(CONST 16) = *PRODUCT-FOR*
(CONST 17) = *TYPE-TEST-LIMIT*
(CONST 18) = FINISH-LOOP
(CONST 19) = DO
(CONST 20) = PARSE-LOOP1
(CONST 21) = "SLOOP"
(CONST 22) = "FINISH"
(CONST 23) = LOOP-RETURN
(CONST 24) = (&REST VALS)
(CONST 25) = SYSTEM::BACKQUOTE
(CONST 26) = RETURN-FROM
(CONST 27) = ((VALUES (SYSTEM::SPLICE (SYSTEM::UNQUOTE VALS))))
(CONST 28) = LIST
(CONST 29) = 'RETURN-FROM
(CONST 30) = QUOTE
(CONST 31) = ((CONS 'VALUES VALS))
(CONST 32) = LOOP-FINISH
(CONST 33) = GO
(CONST 34) = LOCAL-FINISH
(CONST 35) = SUBSTITUTE-SLOOP-BODY
(CONST 36) = NEXT-LOOP
(CONST 37) = ((GO NEXT-LOOP))
(CONST 38) = MACROLET
(CONST 39) = BLOCK
(CONST 40) = TAGBODY
(CONST 41) = *MACROEXPAND-HOOK*
(CONST 42) = *MACROEXPAND-HOOK-FOR-NO-COPY*
(CONST 43) = LET
(CONST 44) = LOOP-LET-BINDINGS
(CONST 45) = DECLARE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(*LOOP-BINDINGS* *MACROEXPAND-HOOK-FOR-NO-COPY* *MACROEXPAND-HOOK*
 *LOOP-PROLOGUE* *LOOP-INCREMENT* *LOOP-BODY* *LOOP-END-TEST* *LOOP-EPILOGUE*
 *LOOP-COLLECT-VAR* *LOOP-NAME* *PRODUCT-FOR* *LOOP-MAP* *LOOP-FORM*
 *AUTOMATIC-DECLARATIONS*)
writes special variables : (*LOOP-EPILOGUE* *LOOP-NAME* *LOOP-FORM*)
197 byte-code instructions:
0     (NIL&PUSH)
1     (LOAD 2)
2     (BIND 0)                            ; *LOOP-FORM*
4     (GETVALUE 1)                        ; *AUTOMATIC-DECLARATIONS*
6     (BIND 1)                            ; *AUTOMATIC-DECLARATIONS*
8     (NIL)
9     (BIND 2)                            ; *LAST-VAL*
11    (NIL)
12    (BIND 3)                            ; *LOOP-MAP*
14    (NIL)
15    (BIND 4)                            ; *LOOP-BODY*
17    (NIL)
18    (BIND 5)                            ; *LOOP-NAME*
20    (NIL)
21    (BIND 6)                            ; *LOOP-PROLOGUE*
23    (NIL)
24    (BIND 7)                            ; *INNER-SLOOP*
26    (NIL)
27    (BIND 8)                            ; *LOOP-EPILOGUE*
29    (NIL)
30    (BIND 9)                            ; *LOOP-INCREMENT*
32    (NIL)
33    (BIND 10)                           ; *LOOP-COLLECT-POINTERS*
35    (NIL)
36    (BIND 11)                           ; *LOOP-MAP-DECLARES*
38    (NIL)
39    (BIND 12)                           ; *LOOP-COLLECT-VAR*
41    (NIL)
42    (BIND 13)                           ; *NO-DECLARE*
44    (NIL)
45    (BIND 14)                           ; *LOOP-END-TEST*
47    (NIL)
48    (BIND 15)                           ; *LOOP-BINDINGS*
50    (NIL)
51    (BIND 16)                           ; *PRODUCT-FOR*
53    (NIL)
54    (BIND 17)                           ; *TYPE-TEST-LIMIT*
56    (NIL&PUSH)
57    (CONST&PUSH 18)                     ; FINISH-LOOP
58    (GETVALUE 0)                        ; *LOOP-FORM*
60    (CAR&PUSH)
61    (CALLS2&JMPIFNOT 6 L69)             ; SYMBOLP
64    (GETVALUE 0)                        ; *LOOP-FORM*
66    (CAR)
67    (JMPIF L75)
69    L69
69    (CONST&PUSH 19)                     ; DO
70    (GETVALUE 0)                        ; *LOOP-FORM*
72    (CONS)
73    (SETVALUE 0)                        ; *LOOP-FORM*
75    L75
75    (CALL0 20)                          ; PARSE-LOOP1
77    (GETVALUE 3)                        ; *LOOP-MAP*
79    (JMPIF L85)
81    (GETVALUE 16)                       ; *PRODUCT-FOR*
83    (JMPIFNOT L102)
85    L85
85    (GETVALUE 5)                        ; *LOOP-NAME*
87    (JMPIF L94)
89    (CONST&PUSH 21)                     ; "SLOOP"
90    (CALLS2 143)                        ; GENSYM
92    (SETVALUE 5)                        ; *LOOP-NAME*
94    L94
94    (LOAD&PUSH 0)
95    (JMPIFNOTEQTO 18 L102)              ; FINISH-LOOP
98    (CONST&PUSH 22)                     ; "FINISH"
99    (CALLS2&STORE 143 0)                ; GENSYM
102   L102
102   (CONST&PUSH 23)                     ; LOOP-RETURN
103   (CONST&PUSH 24)                     ; (&REST VALS)
104   (CONST&PUSH 25)                     ; SYSTEM::BACKQUOTE
105   (CONST&PUSH 26)                     ; RETURN-FROM
106   (GETVALUE&PUSH 5)                   ; *LOOP-NAME*
108   (CONST 27)                          ; ((VALUES (SYSTEM::SPLICE #)))
110   (LIST*&PUSH 2)
112   (CONST&PUSH 28)                     ; LIST
113   (CONST&PUSH 29)                     ; 'RETURN-FROM
114   (CONST&PUSH 30)                     ; QUOTE
116   (GETVALUE&PUSH 5)                   ; *LOOP-NAME*
118   (LIST&PUSH 2)
120   (CONST 31)                          ; ((CONS 'VALUES VALS))
122   (LIST*&PUSH 3)
124   (LIST&PUSH 3)
126   (LIST&PUSH 3)
128   (LOAD&CONS&STORE 1)
130   (CONST&PUSH 32)                     ; LOOP-FINISH
132   (NIL&PUSH)
133   (CONST&PUSH 25)                     ; SYSTEM::BACKQUOTE
134   (CONST&PUSH 33)                     ; GO
136   (LOAD&PUSH 4)
137   (LIST&PUSH 2)
139   (CONST&PUSH 30)                     ; QUOTE
141   (CONST&PUSH 33)                     ; GO
143   (LOAD&PUSH 6)
144   (LIST&PUSH 2)
146   (LIST&PUSH 2)
148   (LIST&PUSH 3)
150   (LIST&PUSH 3)
152   (LOAD&CONS&STORE 1)
154   (CONST&PUSH 34)                     ; LOCAL-FINISH
156   (NIL&PUSH)
157   (CONST&PUSH 25)                     ; SYSTEM::BACKQUOTE
158   (CONST&PUSH 33)                     ; GO
160   (LOAD&PUSH 4)
161   (LIST&PUSH 2)
163   (CONST&PUSH 30)                     ; QUOTE
165   (CONST&PUSH 33)                     ; GO
167   (LOAD&PUSH 6)
168   (LIST&PUSH 2)
170   (LIST&PUSH 2)
172   (LIST&PUSH 3)
174   (LIST&PUSH 3)
176   (LOAD&CONS&STORE 1)
178   (GETVALUE 12)                       ; *LOOP-COLLECT-VAR*
180   (JMPIFNOT L194)
182   (CONST&PUSH 26)                     ; RETURN-FROM
183   (GETVALUE&PUSH 5)                   ; *LOOP-NAME*
185   (GETVALUE&PUSH 12)                  ; *LOOP-COLLECT-VAR*
187   (LIST&PUSH 3)
189   (GETVALUE 8)                        ; *LOOP-EPILOGUE*
191   (CONS)
192   (SETVALUE 8)                        ; *LOOP-EPILOGUE*
194   L194
194   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
196   (GETVALUE&PUSH 4)                   ; *LOOP-BODY*
198   (CALLS2&PUSH 73)                    ; NREVERSE
200   (GETVALUE&PUSH 9)                   ; *LOOP-INCREMENT*
202   (CALLS2&PUSH 73)                    ; NREVERSE
204   (CALLSR&STORE 3 34 56)              ; APPEND
208   (GETVALUE 3)                        ; *LOOP-MAP*
210   (JMPIF L270)
212   (CONST&PUSH 36)                     ; NEXT-LOOP
214   (LOAD&PUSH 57)
216   (CONST&PUSH 37)                     ; ((GO NEXT-LOOP))
218   (CALLSR 2 34)                       ; APPEND
221   (CONS)
222   (STORE 56)
224   L224
224   (CONST&PUSH 38)                     ; MACROLET
226   (LOAD&PUSH 2)
227   (CONST&PUSH 39)                     ; BLOCK
229   (GETVALUE&PUSH 5)                   ; *LOOP-NAME*
231   (CONST&PUSH 40)                     ; TAGBODY
233   (GETVALUE&PUSH 6)                   ; *LOOP-PROLOGUE*
235   (CALLS2&PUSH 73)                    ; NREVERSE
237   (LOAD&PUSH 62)
239   (LOAD&PUSH 7)
240   (LIST&PUSH 1)
242   (GETVALUE&PUSH 8)                   ; *LOOP-EPILOGUE*
244   (CALLS2&PUSH 73)                    ; NREVERSE
246   (CALLSR 4 34)                       ; APPEND
249   (CONS&PUSH)
250   (LIST&PUSH 3)
252   (LIST&PUSH 3)
254   (GETVALUE&PUSH 41)                  ; *MACROEXPAND-HOOK*
256   (GETVALUE&PUSH 42)                  ; *MACROEXPAND-HOOK-FOR-NO-COPY*
258   (CALLS2&JMPIF 1 L265)               ; EQL
261   (LOAD&PUSH 0)
262   (CALLS1&STORE 161 0)                ; COPY-TREE
265   L265
265   (GETVALUE&PUSH 15)                  ; *LOOP-BINDINGS*
267   (NIL&PUSH)
268   (JMP L309)
270   L270
270   (LOAD&PUSH 56)
272   (CALL1 35)                          ; SUBSTITUTE-SLOOP-BODY
274   (STORE 56)
276   (JMP L224)
278   L278
278   (LOAD&CAR&STORE 1 0)
281   (CONST&PUSH 43)                     ; LET
283   (LOAD&PUSH 1)
284   (CALL1&PUSH 44)                     ; LOOP-LET-BINDINGS
286   (LOAD 2)
287   (CDR)
288   (JMPIFNOT L297)
290   (CONST&PUSH 45)                     ; DECLARE
292   (LOAD 3)
293   (CDR)
294   (CONS&PUSH)
295   (LIST 1)
297   L297
297   (PUSH)
298   (LOAD&PUSH 5)
299   (LIST&PUSH 1)
301   (CALLSR 2 34)                       ; APPEND
304   (LIST* 2)
306   (STORE 2)
307   (LOAD&CDR&STORE 1)
309   L309
309   (LOAD&PUSH 1)
310   (CALLS1&JMPIFNOT 146 L278)          ; ENDP
313   (SKIP 2)
315   (POP)
316   (SKIP 2)
318   (UNBIND 18)
320   (SKIP&RET 3)


Disassembly of function #:|(DEFUN PARSE-LOOP1 NIL ...)-12|
(CONST 0) = PARSE-LOOP1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP1
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP1
(CONST 0) = LOOP-PEEK
(CONST 1) = TRANSLATE-NAME
(CONST 2) = NAMED
(CONST 3) = L-EQUAL
(CONST 4) = LOOP-POP
(CONST 5) = *LOOP-NAME*
(CONST 6) = *LOOP-FORM*
(CONST 7) = PARSE-NO-BODY
(CONST 8) = FOR
(CONST 9) = PARSE-LOOP-FOR
(CONST 10) = WHILE
(CONST 11) = OR
(CONST 12) = ((LOCAL-FINISH))
(CONST 13) = *LOOP-BODY*
(CONST 14) = UNTIL
(CONST 15) = AND
(CONST 16) = ((LOCAL-FINISH))
(CONST 17) = DO
(CONST 18) = PARSE-LOOP-DO
(CONST 19) = (WHEN UNLESS)
(CONST 20) = PARSE-LOOP-WHEN
(CONST 21) = LOOP-COLLECT-KEYWORD-P
(CONST 22) = PARSE-LOOP-COLLECT
(CONST 23) = "lcase fell off end ~a  "
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-BODY* *LOOP-FORM*)
writes special variables : (*LOOP-BODY* *LOOP-NAME*)
84 byte-code instructions:
0     (CALL0 0)                           ; LOOP-PEEK
2     (PUSH)
3     (CALL1&PUSH 1)                      ; TRANSLATE-NAME
5     (LOAD&PUSH 0)
6     (CONST&PUSH 2)                      ; NAMED
7     (CALL2&JMPIFNOT 3 L16)              ; L-EQUAL
10    (CALL0 4)                           ; LOOP-POP
12    (CALL0 4)                           ; LOOP-POP
14    (SETVALUE 5)                        ; *LOOP-NAME*
16    L16
16    (SKIP 1)
18    (CALL0 4)                           ; LOOP-POP
20    (PUSH)
21    (LOAD&JMPIF 0 L29)
24    L24
24    (GETVALUE 6)                        ; *LOOP-FORM*
26    (JMPIFNOT L126)
29    L29
29    (LOAD&PUSH 0)
30    (CALL1&PUSH 1)                      ; TRANSLATE-NAME
32    (LOAD&PUSH 0)
33    (CALL1&JMPIF 7 L114)                ; PARSE-NO-BODY
37    (LOAD&PUSH 0)
38    (CONST&PUSH 8)                      ; FOR
39    (CALL2&JMPIF 3 L66)                 ; L-EQUAL
42    (LOAD&PUSH 0)
43    (CONST&PUSH 10)                     ; WHILE
44    (CALL2&JMPIF 3 L70)                 ; L-EQUAL
47    (LOAD&PUSH 0)
48    (CONST&PUSH 14)                     ; UNTIL
49    (CALL2&JMPIFNOT 3 L90)              ; L-EQUAL
52    (CONST&PUSH 15)                     ; AND
53    (CALL0 4)                           ; LOOP-POP
55    (PUSH)
56    (CONST 16)                          ; ((LOCAL-FINISH))
57    L57
57    (LIST*&PUSH 2)
59    (GETVALUE 13)                       ; *LOOP-BODY*
61    (CONS)
62    (SETVALUE 13)                       ; *LOOP-BODY*
64    (JMP L114)
66    L66
66    (CALL0 9)                           ; PARSE-LOOP-FOR
68    (JMP L114)
70    L70
70    (CONST&PUSH 11)                     ; OR
71    (CALL0 4)                           ; LOOP-POP
73    (PUSH)
74    (CONST 12)                          ; ((LOCAL-FINISH))
75    (JMP L57)
77    L77
77    (CALL0 18)                          ; PARSE-LOOP-DO
79    (JMP L106)
81    L81
81    (CALL0 20)                          ; PARSE-LOOP-WHEN
83    (JMP L106)
85    L85
85    (CONST&PUSH 23)                     ; "lcase fell off end ~a  "
86    (LOAD&PUSH 1)
87    (CALLSR 1 29)                       ; ERROR
90    L90
90    (LOAD&PUSH 0)
91    (CONST&PUSH 17)                     ; DO
92    (CALL2&JMPIF 3 L77)                 ; L-EQUAL
95    (LOAD&PUSH 0)
96    (CONST&PUSH 19)                     ; (WHEN UNLESS)
97    (CALL2&JMPIF 3 L81)                 ; L-EQUAL
100   (LOAD&PUSH 0)
101   (CALL1&JMPIFNOT 21 L85)             ; LOOP-COLLECT-KEYWORD-P
104   (CALL0 22)                          ; PARSE-LOOP-COLLECT
106   L106
106   (PUSH)
107   (GETVALUE&PUSH 13)                  ; *LOOP-BODY*
109   (CALLSR 2 34)                       ; APPEND
112   (SETVALUE 13)                       ; *LOOP-BODY*
114   L114
114   (SKIP 1)
116   (CALL0 4)                           ; LOOP-POP
118   (STORE 0)
119   (LOAD&JMPIFNOT 0 L24)
123   (JMP L29)
126   L126
126   (NIL)
127   (SKIP&RET 2)


Disassembly of function #:|(DEFUN PARSE-NO-BODY (COM &AUX # ...) ...)-13|
(CONST 0) = PARSE-NO-BODY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = 
"Reads successive no-body-contribution type forms, like declare,
initially, etc.  which can occur anywhere. Returns t if it finds some
otherwise nil"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE PARSE-NO-BODY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-NO-BODY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-NO-BODY
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Reads successive no-body-contribution type forms, like declare,
initially, etc.  which can occur anywhere. Returns t if it finds some
otherwise nil"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; PARSE-NO-BODY
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE PARSE-NO-BODY>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (CONST 0)                           ; PARSE-NO-BODY
14    (SKIP&RET 1)


Disassembly of function PARSE-NO-BODY
(CONST 0) = *LOOP-FORM*
(CONST 1) = TRANSLATE-NAME
(CONST 2) = (INITIALLY FINALLY)
(CONST 3) = L-EQUAL
(CONST 4) = PARSE-LOOP-INITIALLY
(CONST 5) = WITH
(CONST 6) = PARSE-LOOP-WITH
(CONST 7) = DECLARE
(CONST 8) = LOOP-POP
(CONST 9) = PARSE-LOOP-DECLARE
(CONST 10) = NODECLARE
(CONST 11) = *NO-DECLARE*
(CONST 12) = INCREMENT
(CONST 13) = PARSE-LOOP-DO
(CONST 14) = *LOOP-INCREMENT*
(CONST 15) = END-TEST
(CONST 16) = *LOOP-END-TEST*
(CONST 17) = WITH-UNIQUE
(CONST 18) = :SLOOP-MACRO
(CONST 19) = PARSE-LOOP-MACRO
(CONST 20) = LOOP-UN-POP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-END-TEST* *LOOP-INCREMENT* *LOOP-FORM*)
writes special variables : (*LOOP-END-TEST* *LOOP-INCREMENT* *NO-DECLARE*)
98 byte-code instructions:
0     (T&PUSH)
1     (T&PUSH)
2     (LOAD&PUSH 3)
3     (LOAD&JMPIFNOT 1 L85)
7     L7
7     (LOAD&PUSH 0)
8     (CALL1&PUSH 1)                      ; TRANSLATE-NAME
10    (LOAD&PUSH 0)
11    (CONST&PUSH 2)                      ; (INITIALLY FINALLY)
12    (CALL2&JMPIF 3 L95)                 ; L-EQUAL
16    (LOAD&PUSH 0)
17    (NIL&PUSH)
18    (CALL2&JMPIF 3 L74)                 ; L-EQUAL
21    (LOAD&PUSH 0)
22    (CONST&PUSH 5)                      ; WITH
23    (CALL2&JMPIF 3 L100)                ; L-EQUAL
27    (LOAD&PUSH 0)
28    (CONST&PUSH 7)                      ; DECLARE
29    (CALL2&JMPIF 3 L104)                ; L-EQUAL
33    (LOAD&PUSH 0)
34    (CONST&PUSH 10)                     ; NODECLARE
35    (CALL2&JMPIF 3 L112)                ; L-EQUAL
39    (LOAD&PUSH 0)
40    (CONST&PUSH 12)                     ; INCREMENT
41    (CALL2&JMPIF 3 L118)                ; L-EQUAL
45    (LOAD&PUSH 0)
46    (CONST&PUSH 15)                     ; END-TEST
47    (CALL2&JMPIF 3 L130)                ; L-EQUAL
51    (LOAD&PUSH 0)
52    (CONST&PUSH 17)                     ; WITH-UNIQUE
53    (CALL2&JMPIF 3 L143)                ; L-EQUAL
57    (LOAD&PUSH 0)
58    (CALLS2&JMPIFNOT 6 L156)            ; SYMBOLP
62    (LOAD&PUSH 0)
63    (CONST&PUSH 18)                     ; :SLOOP-MACRO
64    (PUSH-UNBOUND 1)
66    (CALLS2&JMPIFNOT 132 L156)          ; GET
70    (LOAD&PUSH 1)
71    (CONST&PUSH 18)                     ; :SLOOP-MACRO
72    (CALL2 19)                          ; PARSE-LOOP-MACRO
74    L74
74    (SKIP 1)
76    (NIL&STORE 1)
78    (CALL0 8)                           ; LOOP-POP
80    (STORE 0)
81    (LOAD&JMPIF 1 L7)
85    L85
85    (GETVALUE 0)                        ; *LOOP-FORM*
87    (JMPIF L7)
90    (SKIP 1)
92    L92
92    (LOAD 1)
93    (SKIP&RET 4)
95    L95
95    (LOAD&PUSH 1)
96    (CALL1 4)                           ; PARSE-LOOP-INITIALLY
98    (JMP L74)
100   L100
100   (CALL0 6)                           ; PARSE-LOOP-WITH
102   (JMP L74)
104   L104
104   (CALL0 8)                           ; LOOP-POP
106   (PUSH)
107   (T&PUSH)
108   (CALL2 9)                           ; PARSE-LOOP-DECLARE
110   (JMP L74)
112   L112
112   (CALL0 8)                           ; LOOP-POP
114   (SETVALUE 11)                       ; *NO-DECLARE*
116   (JMP L74)
118   L118
118   (CALL0 13)                          ; PARSE-LOOP-DO
120   (PUSH)
121   (GETVALUE&PUSH 14)                  ; *LOOP-INCREMENT*
123   (CALLSR 2 34)                       ; APPEND
126   (SETVALUE 14)                       ; *LOOP-INCREMENT*
128   (JMP L74)
130   L130
130   (CALL0 13)                          ; PARSE-LOOP-DO
132   (PUSH)
133   (GETVALUE&PUSH 16)                  ; *LOOP-END-TEST*
135   (CALLSR 2 34)                       ; APPEND
138   (SETVALUE 16)                       ; *LOOP-END-TEST*
140   (JMP L74)
143   L143
143   (NIL&PUSH)
144   (T&PUSH)
145   (CALL2 6)                           ; PARSE-LOOP-WITH
147   (JMP L74)
150   L150
150   (NIL&STORE 3)
152   (SKIP 2)
154   (JMP L92)
156   L156
156   (LOAD&JMPIF 2 L150)
159   (CALL0 20)                          ; LOOP-UN-POP
161   (SKIP 2)
163   (JMP L92)


Disassembly of function #:|(DEFUN PARSE-LOOP-WITH (&OPTIONAL AND-WITH ONLY-IF-NOT-THERE) ...)-14|
(CONST 0) = PARSE-LOOP-WITH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-WITH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-WITH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-WITH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-WITH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-WITH
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-WITH
(CONST 0) = LOOP-POP
(CONST 1) = LOOP-PEEK
(CONST 2) = TRANSLATE-NAME
(CONST 3) = =
(CONST 4) = L-EQUAL
(CONST 5) = "Not a variable ~a"
(CONST 6) = LOOP-ADD-BINDING
(CONST 7) = LOOP-ADD-TEMPS
(CONST 8) = AND
(CONST 9) = WITH
(CONST 10) = WITH-UNIQUE
(CONST 11) = LOOP-UN-POP
0 required arguments
2 optional arguments
No rest parameter
No keyword parameters
67 byte-code instructions:
0     L0
0     (UNBOUND->NIL 2)
2     (UNBOUND->NIL 1)
4     (CALL0 0)                           ; LOOP-POP
6     (PUSH)
7     (CALL0 1)                           ; LOOP-PEEK
9     (PUSH)
10    (CALL1&PUSH 2)                      ; TRANSLATE-NAME
12    (LOAD&PUSH 0)
13    (CONST&PUSH 3)                      ; =
14    (CALL2&JMPIF 4 L71)                 ; L-EQUAL
17    (LOAD&PUSH 1)
18    (PUSH-NIL 2)
20    (LOAD 7)
21    (NOT)
22    (PUSH)
23    (LOAD&PUSH 7)
24    (CALL 5 7)                          ; LOOP-ADD-TEMPS
27    L27
27    (SKIP 1)
29    (CALL0 1)                           ; LOOP-PEEK
31    (PUSH)
32    (CALL1&PUSH 2)                      ; TRANSLATE-NAME
34    (LOAD&PUSH 0)
35    (CONST&PUSH 8)                      ; AND
36    (CALL2&JMPIFNOT 4 L101)             ; L-EQUAL
39    (CALL0 0)                           ; LOOP-POP
41    (CALL0 0)                           ; LOOP-POP
43    (PUSH)
44    (CALL1&PUSH 2)                      ; TRANSLATE-NAME
46    (LOAD&PUSH 0)
47    (CONST&PUSH 9)                      ; WITH
48    (CALL2&JMPIF 4 L58)                 ; L-EQUAL
51    (LOAD&PUSH 0)
52    (CONST&PUSH 10)                     ; WITH-UNIQUE
53    (CALL2&JMPIF 4 L94)                 ; L-EQUAL
56    (CALL0 11)                          ; LOOP-UN-POP
58    L58
58    (T&PUSH)
59    (PUSH-UNBOUND 1)
61    (JMPTAIL 2 8 L0)
66    L66
66    (CONST&PUSH 5)                      ; "Not a variable ~a"
67    (LOAD&PUSH 2)
68    (CALLSR 1 29)                       ; ERROR
71    L71
71    (CALL0 0)                           ; LOOP-POP
73    (LOAD&PUSH 1)
74    (CALLS2&JMPIFNOT 6 L66)             ; SYMBOLP
77    (LOAD&PUSH 1)
78    (CALL0 0)                           ; LOOP-POP
80    (PUSH)
81    (LOAD 6)
82    (NOT)
83    (PUSH)
84    (PUSH-NIL 2)
86    (T&PUSH)
87    (LOAD&PUSH 9)
88    (CALL 7 6)                          ; LOOP-ADD-BINDING
91    (JMP L27)
94    L94
94    (T&PUSH)
95    (T&PUSH)
96    (JMPTAIL 2 8 L0)
101   L101
101   (NIL)
102   (SKIP&RET 5)


Disassembly of function #:|(DEFUN PARSE-LOOP-DO (&AUX RESULT) ...)-15|
(CONST 0) = PARSE-LOOP-DO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-DO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-DO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-DO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-DO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-DO
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-DO
(CONST 0) = LOOP-POP
(CONST 1) = *LOOP-FORM*
(CONST 2) = LOOP-UN-POP
(CONST 3) = "empty clause"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-FORM*)
23 byte-code instructions:
0     (NIL&PUSH)
1     (CALL0 0)                           ; LOOP-POP
3     (PUSH)
4     L4
4     (LOAD&PUSH 0)
5     (CALLS2&JMPIF 11 L18)               ; LISTP
8     (CALL0 2)                           ; LOOP-UN-POP
10    L10
10    (SKIP 1)
12    (LOAD&JMPIFNOT 0 L30)
15    (POP)
16    (SKIP&RET 1)
18    L18
18    (LOAD&PUSH 0)
19    (LOAD&CONS&STORE 1)
21    (GETVALUE 1)                        ; *LOOP-FORM*
23    (JMPIFNOT L10)
25    (CALL0 0)                           ; LOOP-POP
27    (STORE 0)
28    (JMP L4)
30    L30
30    (CONST&PUSH 3)                      ; "empty clause"
31    (CALLSR 0 29)                       ; ERROR


Disassembly of function #:|(DEFUN PARSE-LOOP-INITIALLY (COMMAND) ...)-16|
(CONST 0) = PARSE-LOOP-INITIALLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-INITIALLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-INITIALLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-INITIALLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-INITIALLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-INITIALLY
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-INITIALLY
(CONST 0) = TRANSLATE-NAME
(CONST 1) = INITIALLY
(CONST 2) = L-EQUAL
(CONST 3) = PARSE-LOOP-DO
(CONST 4) = (SETF SETQ)
(CONST 5) = 3
(CONST 6) = LOOP-ADD-BINDING
(CONST 7) = *LOOP-PROLOGUE*
(CONST 8) = FINALLY
(CONST 9) = *LOOP-EPILOGUE*
(CONST 10) = "lcase fell off end ~a  "
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-EPILOGUE* *LOOP-PROLOGUE*)
writes special variables : (*LOOP-EPILOGUE* *LOOP-PROLOGUE*)
70 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; TRANSLATE-NAME
3     (LOAD&PUSH 0)
4     (CONST&PUSH 1)                      ; INITIALLY
5     (CALL2&JMPIF 2 L19)                 ; L-EQUAL
8     (LOAD&PUSH 0)
9     (CONST&PUSH 8)                      ; FINALLY
10    (CALL2&JMPIF 2 L95)                 ; L-EQUAL
14    (CONST&PUSH 10)                     ; "lcase fell off end ~a  "
15    (LOAD&PUSH 1)
16    (CALLSR 1 29)                       ; ERROR
19    L19
19    (CALL0 3)                           ; PARSE-LOOP-DO
21    (PUSH)
22    (LOAD&PUSH 0)
23    (CALLS2&PUSH 73)                    ; NREVERSE
25    (NIL&PUSH)
26    (JMP L88)
28    L28
28    (LOAD&CAR&STORE 1 0)
31    (PUSH)
32    (CALLS2&JMPIFNOT 11 L80)            ; LISTP
35    (LOAD&CAR&PUSH 0)
37    (CONST&PUSH 4)                      ; (SETF SETQ)
38    (PUSH-UNBOUND 3)
40    (CALLS1&JMPIFNOT 180 L80)           ; MEMBER
43    (LOAD&PUSH 0)
44    (CALLS2&PUSH 71)                    ; LENGTH
46    (JMPIFNOTEQTO 5 L80)                ; 3
49    (LOAD 0)
50    (CDR)
51    (CAR&PUSH)
52    (CALLS2&JMPIFNOT 6 L80)             ; SYMBOLP
55    (LOAD 0)
56    (CDR)
57    (CDR)
58    (CAR&PUSH)
59    (PUSH-UNBOUND 1)
61    (CALLS1&JMPIFNOT 94 L80)            ; CONSTANTP
64    (LOAD 0)
65    (CDR)
66    (CAR&PUSH)
67    (LOAD 1)
68    (CDR)
69    (CDR)
70    (CAR&PUSH)
71    (PUSH-NIL 3)
73    (T&PUSH)
74    (T&PUSH)
75    (CALL 7 6)                          ; LOOP-ADD-BINDING
78    (JMPIF L86)
80    L80
80    (LOAD&PUSH 0)
81    (GETVALUE 7)                        ; *LOOP-PROLOGUE*
83    (CONS)
84    (SETVALUE 7)                        ; *LOOP-PROLOGUE*
86    L86
86    (LOAD&CDR&STORE 1)
88    L88
88    (LOAD&PUSH 1)
89    (CALLS1&JMPIFNOT 146 L28)           ; ENDP
92    (NIL)
93    (SKIP&RET 6)
95    L95
95    (CALL0 3)                           ; PARSE-LOOP-DO
97    (PUSH)
98    (GETVALUE&PUSH 9)                   ; *LOOP-EPILOGUE*
100   (CALLSR 2 34)                       ; APPEND
103   (SETVALUE 9)                        ; *LOOP-EPILOGUE*
105   (SKIP&RET 3)


Disassembly of function #:|(DEFUN PARSE-ONE-WHEN-CLAUSE (&AUX THIS-CASE # ...) ...)-17|
(CONST 0) = PARSE-ONE-WHEN-CLAUSE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-ONE-WHEN-CLAUSE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-ONE-WHEN-CLAUSE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-ONE-WHEN-CLAUSE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-ONE-WHEN-CLAUSE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-ONE-WHEN-CLAUSE
8     (SKIP&RET 1)


Disassembly of function PARSE-ONE-WHEN-CLAUSE
(CONST 0) = BODY
(CONST 1) = *LOOP-FORM*
(CONST 2) = LOOP-POP
(CONST 3) = TRANSLATE-NAME
(CONST 4) = PARSE-NO-BODY
(CONST 5) = LOOP-COLLECT-KEYWORD-P
(CONST 6) = PARSE-LOOP-COLLECT
(CONST 7) = AND
(CONST 8) = WHEN
(CONST 9) = L-EQUAL
(CONST 10) = PARSE-LOOP-WHEN
(CONST 11) = DO
(CONST 12) = PARSE-LOOP-DO
(CONST 13) = "Premature AND"
(CONST 14) = LOOP-UN-POP
(CONST 15) = "Hanging conditional"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-FORM*)
84 byte-code instructions:
0     (NIL&PUSH)
1     (CONST&PUSH 0)                      ; BODY
2     (NIL&PUSH)
3     (GETVALUE 1)                        ; *LOOP-FORM*
5     (JMPIFNOT L113)
8     L8
8     (CALL0 2)                           ; LOOP-POP
10    (STORE 0)
11    (PUSH)
12    (CALL1&PUSH 3)                      ; TRANSLATE-NAME
14    (LOAD&PUSH 0)
15    (CALL1&JMPIF 4 L106)                ; PARSE-NO-BODY
19    (LOAD&PUSH 0)
20    (CALL1&JMPIF 5 L48)                 ; LOOP-COLLECT-KEYWORD-P
23    (LOAD&PUSH 0)
24    (CONST&PUSH 8)                      ; WHEN
25    (CALL2&JMPIF 9 L64)                 ; L-EQUAL
28    (LOAD&PUSH 0)
29    (CONST&PUSH 11)                     ; DO
30    (CALL2&JMPIFNOT 9 L95)              ; L-EQUAL
33    (LOAD&PUSH 2)
34    (JMPIFEQTO 0 L80)                   ; BODY
37    L37
37    (SKIP 1)
39    (CALL0 14)                          ; LOOP-UN-POP
41    (LOAD&JMPIFNOT 2 L116)
45    (JMP L128)
48    L48
48    (LOAD&PUSH 2)
49    (JMPIFNOTEQTO 0 L37)                ; BODY
52    (CALL0 6)                           ; PARSE-LOOP-COLLECT
54    (PUSH)
55    (LOAD&PUSH 4)
56    (CALLSR&STORE 2 34 3)               ; APPEND
60    (CONST 7)                           ; AND
61    (STORE 2)
62    (JMP L106)
64    L64
64    (LOAD&PUSH 2)
65    (JMPIFNOTEQTO 0 L37)                ; BODY
68    (CALL0 10)                          ; PARSE-LOOP-WHEN
70    (PUSH)
71    (LOAD&PUSH 4)
72    (CALLSR&STORE 2 34 3)               ; APPEND
76    (CONST 7)                           ; AND
77    (STORE 2)
78    (JMP L106)
80    L80
80    (CALL0 12)                          ; PARSE-LOOP-DO
82    (PUSH)
83    (LOAD&PUSH 4)
84    (CALLSR&STORE 2 34 3)               ; APPEND
88    (CONST 7)                           ; AND
89    (STORE 2)
90    (JMP L106)
92    L92
92    (CONST 13)                          ; "Premature AND"
93    (JMP L117)
95    L95
95    (LOAD&PUSH 0)
96    (CONST&PUSH 7)                      ; AND
97    (CALL2&JMPIFNOT 9 L121)             ; L-EQUAL
100   (LOAD&PUSH 2)
101   (JMPIFNOTEQTO 7 L92)                ; AND
104   (CONST 0)                           ; BODY
105   (STORE 2)
106   L106
106   (SKIP 1)
108   (GETVALUE 1)                        ; *LOOP-FORM*
110   (JMPIF L8)
113   L113
113   (LOAD&JMPIF 2 L128)
116   L116
116   (CONST 15)                          ; "Hanging conditional"
117   L117
117   (PUSH)
118   (CALLSR 0 29)                       ; ERROR
121   L121
121   (CALL0 14)                          ; LOOP-UN-POP
123   (SKIP 1)
125   (LOAD&JMPIFNOT 2 L116)
128   L128
128   (LOAD 2)
129   (SKIP&RET 4)


Disassembly of function #:|(DEFUN PARSE-LOOP-WHEN (&AUX INITIAL ELSE ...) ...)-18|
(CONST 0) = PARSE-LOOP-WHEN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-WHEN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-WHEN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-WHEN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-WHEN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-WHEN
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-WHEN
(CONST 0) = *LAST-VAL*
(CONST 1) = UNLESS
(CONST 2) = L-EQUAL
(CONST 3) = NOT
(CONST 4) = LOOP-POP
(CONST 5) = PARSE-ONE-WHEN-CLAUSE
(CONST 6) = LOOP-PEEK
(CONST 7) = TRANSLATE-NAME
(CONST 8) = ELSE
(CONST 9) = COND
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LAST-VAL*)
42 byte-code instructions:
0     (PUSH-NIL 3)
2     (GETVALUE&PUSH 0)                   ; *LAST-VAL*
4     (CONST&PUSH 1)                      ; UNLESS
5     (CALL2&JMPIF 2 L55)                 ; L-EQUAL
8     (CALL0 4)                           ; LOOP-POP
10    L10
10    (PUSH)
11    (CALL0 5)                           ; PARSE-ONE-WHEN-CLAUSE
13    (STORE 3)
14    (CALL0 6)                           ; LOOP-PEEK
16    (PUSH)
17    (CALL1&PUSH 7)                      ; TRANSLATE-NAME
19    (LOAD&PUSH 0)
20    (CONST&PUSH 8)                      ; ELSE
21    (CALL2&JMPIFNOT 2 L31)              ; L-EQUAL
24    (CALL0 4)                           ; LOOP-POP
26    (T&STORE 3)
28    (CALL0 5)                           ; PARSE-ONE-WHEN-CLAUSE
30    (STORE 2)
31    L31
31    (SKIP 1)
33    (CONST&PUSH 9)                      ; COND
34    (LOAD&PUSH 1)
35    (LOAD&PUSH 5)
36    (CALLS2 73)                         ; NREVERSE
38    (CONS&PUSH)
39    (LOAD&JMPIFNOT 4 L49)
42    (T&PUSH)
43    (LOAD&PUSH 4)
44    (CALLS2 73)                         ; NREVERSE
46    (CONS&PUSH)
47    (LIST 1)
49    L49
49    (LIST*&PUSH 2)
51    (LIST 1)
53    (SKIP&RET 5)
55    L55
55    (CONST&PUSH 3)                      ; NOT
56    (CALL0 4)                           ; LOOP-POP
58    (PUSH)
59    (LIST 2)
61    (JMP L10)


Disassembly of function #:|(DEFUN POINTER-FOR-COLLECT (COLLECT-VAR) ...)-19|
(CONST 0) = POINTER-FOR-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POINTER-FOR-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POINTER-FOR-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POINTER-FOR-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POINTER-FOR-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POINTER-FOR-COLLECT
8     (SKIP&RET 1)


Disassembly of function POINTER-FOR-COLLECT
(CONST 0) = *LOOP-COLLECT-POINTERS*
(CONST 1) = "POIN"
(CONST 2) = :COLLECT
(CONST 3) = LOOP-ADD-BINDING
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-COLLECT-POINTERS*)
writes special variable : (*LOOP-COLLECT-POINTERS*)
21 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; *LOOP-COLLECT-POINTERS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 187)                        ; ASSOC
7     (CDR)
8     (JMPIF1 L30)
10    (CONST&PUSH 1)                      ; "POIN"
11    (CALLS2&PUSH 143)                   ; GENSYM
13    (PUSH-NIL 2)
15    (CONST&PUSH 2)                      ; :COLLECT
16    (CALL&PUSH 4 3)                     ; LOOP-ADD-BINDING
19    (LOAD&PUSH 2)
20    (LOAD 1)
21    (CONS&PUSH)
22    (GETVALUE 0)                        ; *LOOP-COLLECT-POINTERS*
24    (CONS)
25    (SETVALUE 0)                        ; *LOOP-COLLECT-POINTERS*
27    (POP)
28    (SKIP&RET 2)
30    L30
30    (SKIP&RET 2)


Disassembly of function #:|(DEFUN PARSE-LOOP-COLLECT (&AUX COLLECT-VAR POINTER ...) ...)-20|
(CONST 0) = PARSE-LOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-COLLECT
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-COLLECT
(CONST 0) = *INNER-SLOOP*
(CONST 1) = COLLECT
(CONST 2) = *LAST-VAL*
(CONST 3) = LOOP-POP
(CONST 4) = TRANSLATE-NAME
(CONST 5) = INTO
(CONST 6) = L-EQUAL
(CONST 7) = LOOP-ADD-BINDING
(CONST 8) = LOOP-UN-POP
(CONST 9) = *LOOP-COLLECT-VAR*
(CONST 10) = "COLL"
(CONST 11) = (APPEND NCONC COLLECT)
(CONST 12) = POINTER-FOR-COLLECT
(CONST 13) = *USE-LOCATIVES*
(CONST 14) = SETF
(CONST 15) = LOCF
(CONST 16) = *LOOP-PROLOGUE*
(CONST 17) = EQUAL
(CONST 18) = APPEND
(CONST 19) = LIST
(CONST 20) = COPY-LIST
(CONST 21) = "VAL"
(CONST 22) = (NCONC APPEND)
(CONST 23) = AND
(CONST 24) = CDR
(CONST 25) = LAST
(CONST 26) = COND
(CONST 27) = CONS
(CONST 28) = (NIL)
(CONST 29) = (NIL)
(CONST 30) = (NIL)
(CONST 31) = *ADDITIONAL-COLLECTIONS*
(CONST 32) = LOOP-PARSE-ADDITIONAL-COLLECTIONS
(CONST 33) = "loop fell off end ~a"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(*ADDITIONAL-COLLECTIONS* *LOOP-PROLOGUE* *USE-LOCATIVES* *LOOP-COLLECT-VAR*
 *LAST-VAL* *INNER-SLOOP*)
writes special variables : (*LOOP-PROLOGUE* *LOOP-COLLECT-VAR*)
229 byte-code instructions:
0     (PUSH-NIL 3)
2     (GETVALUE 0)                        ; *INNER-SLOOP*
4     (JMPIF L174)
7     (GETVALUE&PUSH 2)                   ; *LAST-VAL*
9     (CALL0 3)                           ; LOOP-POP
11    (PUSH)
12    (CALL0 3)                           ; LOOP-POP
14    (PUSH)
15    (CALL1&PUSH 4)                      ; TRANSLATE-NAME
17    (LOAD&PUSH 0)
18    (CONST&PUSH 5)                      ; INTO
19    (CALL2&JMPIF 6 L177)                ; L-EQUAL
23    (CALL0 8)                           ; LOOP-UN-POP
25    (GETVALUE 9)                        ; *LOOP-COLLECT-VAR*
27    (JMPIF L192)
30    (CONST&PUSH 10)                     ; "COLL"
31    (CALLS2&PUSH 143)                   ; GENSYM
33    (NIL&PUSH)
34    (CALL2 7)                           ; LOOP-ADD-BINDING
36    (SETVALUE 9)                        ; *LOOP-COLLECT-VAR*
38    (STORE 5)
39    L39
39    (SKIP 1)
41    (LOAD&PUSH 1)
42    (CALL1&PUSH 4)                      ; TRANSLATE-NAME
44    (LOAD&PUSH 0)
45    (CONST&PUSH 11)                     ; (APPEND NCONC COLLECT)
46    (CALL2&JMPIFNOT 6 L95)              ; L-EQUAL
49    (LOAD&PUSH 5)
50    (CALL1 12)                          ; POINTER-FOR-COLLECT
52    (STORE 4)
53    (GETVALUE 13)                       ; *USE-LOCATIVES*
55    (JMPIFNOT L74)
57    (CONST&PUSH 14)                     ; SETF
58    (LOAD&PUSH 5)
59    (CONST&PUSH 15)                     ; LOCF
60    (LOAD&PUSH 8)
61    (LIST&PUSH 2)
63    (LIST&PUSH 3)
65    (GETVALUE&PUSH 16)                  ; *LOOP-PROLOGUE*
67    (CONST&PUSH 17)                     ; EQUAL
68    (PUSH-UNBOUND 2)
70    (CALLS1 184)                        ; ADJOIN
72    (SETVALUE 16)                       ; *LOOP-PROLOGUE*
74    L74
74    (LOAD&PUSH 2)
75    (CALL1&PUSH 4)                      ; TRANSLATE-NAME
77    (LOAD&PUSH 0)
78    (CONST&PUSH 18)                     ; APPEND
79    (CALL2&JMPIFNOT 6 L93)              ; L-EQUAL
82    (LOAD&PUSH 2)
83    (CALLS2&JMPIFNOT 11 L196)           ; LISTP
87    (LOAD&CAR&PUSH 2)
89    (JMPIFNOTEQTO 19 L196)              ; LIST
93    L93
93    (SKIP 1)
95    L95
95    (SKIP 1)
97    (LOAD&PUSH 0)
98    (CALLS2&JMPIFNOT 11 L106)           ; LISTP
101   (GETVALUE 13)                       ; *USE-LOCATIVES*
103   (JMPIFNOT L206)
106   L106
106   (LOAD 0)
107   (STORE 2)
108   L108
108   (LOAD&PUSH 1)
109   (CALL1&PUSH 4)                      ; TRANSLATE-NAME
111   (LOAD&PUSH 0)
112   (CONST&PUSH 22)                     ; (NCONC APPEND)
113   (CALL2&JMPIFNOT 6 L238)             ; L-EQUAL
117   (CONST&PUSH 23)                     ; AND
118   (CONST&PUSH 14)                     ; SETF
119   (CONST&PUSH 24)                     ; CDR
120   (LOAD&PUSH 7)
121   (LIST&PUSH 2)
123   (LOAD&PUSH 6)
124   (LIST&PUSH 3)
126   (CONST&PUSH 14)                     ; SETF
127   (LOAD&PUSH 7)
128   (CONST&PUSH 25)                     ; LAST
129   (CONST&PUSH 24)                     ; CDR
130   (LOAD&PUSH 10)
131   (LIST&PUSH 2)
133   (LIST&PUSH 2)
135   (LIST&PUSH 3)
137   (LIST&PUSH 3)
139   (GETVALUE 13)                       ; *USE-LOCATIVES*
141   (JMPIF L218)
144   (CONST&PUSH 26)                     ; COND
145   (LOAD&PUSH 6)
146   (LOAD&PUSH 2)
147   (LIST&PUSH 2)
149   (T&PUSH)
150   (CONST&PUSH 14)                     ; SETF
151   (LOAD&PUSH 9)
152   (CONST&PUSH 25)                     ; LAST
153   (CONST&PUSH 14)                     ; SETF
154   (LOAD&PUSH 13)
155   (LOAD&PUSH 12)
156   (LIST&PUSH 3)
158   (LIST&PUSH 2)
160   (LIST&PUSH 3)
162   (LIST&PUSH 2)
164   (LIST 3)
166   L166
166   (PUSH)
167   (LIST 1)
169   (SKIP 1)
171   (JMP L321)
174   L174
174   (CONST&PUSH 1)                      ; COLLECT
175   (NIL)
176   (THROW)
177   L177
177   (CALL0 3)                           ; LOOP-POP
179   (STORE 5)
180   (PUSH)
181   (PUSH-NIL 2)
183   (T&PUSH)
184   (NIL&PUSH)
185   (T&PUSH)
186   (CALL 6 7)                          ; LOOP-ADD-BINDING
189   (JMP L39)
192   L192
192   (STORE 5)
193   (JMP L39)
196   L196
196   (CONST&PUSH 20)                     ; COPY-LIST
197   (LOAD&PUSH 3)
198   (LIST 2)
200   (STORE 2)
201   (SKIP 1)
203   (JMP L95)
206   L206
206   (CONST&PUSH 21)                     ; "VAL"
207   (CALLS2&PUSH 143)                   ; GENSYM
209   (PUSH-NIL 2)
211   (CALL 3 7)                          ; LOOP-ADD-BINDING
214   (STORE 2)
215   (JMP L108)
218   L218
218   (LOAD 0)
219   (JMP L166)
221   L221
221   (CONST&PUSH 14)                     ; SETF
222   (CONST&PUSH 24)                     ; CDR
223   (LOAD&PUSH 6)
224   (LIST&PUSH 2)
226   (CONST&PUSH 14)                     ; SETF
227   (LOAD&PUSH 7)
228   (CONST&PUSH 27)                     ; CONS
229   (LOAD&PUSH 8)
230   (CONST 28)                          ; (NIL)
232   (LIST*&PUSH 2)
234   (LIST 3)
236   (JMP L285)
238   L238
238   (LOAD&PUSH 0)
239   (CONST&PUSH 1)                      ; COLLECT
240   (CALL2&JMPIFNOT 6 L301)             ; L-EQUAL
243   (GETVALUE 13)                       ; *USE-LOCATIVES*
245   (JMPIF L221)
247   (CONST&PUSH 26)                     ; COND
248   (LOAD&PUSH 5)
249   (CONST&PUSH 14)                     ; SETF
250   (CONST&PUSH 24)                     ; CDR
251   (LOAD&PUSH 8)
252   (LIST&PUSH 2)
254   (CONST&PUSH 14)                     ; SETF
255   (LOAD&PUSH 9)
256   (CONST&PUSH 27)                     ; CONS
257   (LOAD&PUSH 10)
258   (CONST 29)                          ; (NIL)
260   (LIST*&PUSH 2)
262   (LIST&PUSH 3)
264   (LIST&PUSH 3)
266   (LIST&PUSH 2)
268   (T&PUSH)
269   (CONST&PUSH 14)                     ; SETF
270   (LOAD&PUSH 9)
271   (CONST&PUSH 14)                     ; SETF
272   (LOAD&PUSH 10)
273   (CONST&PUSH 27)                     ; CONS
274   (LOAD&PUSH 11)
275   (CONST 30)                          ; (NIL)
277   (LIST*&PUSH 2)
279   (LIST&PUSH 3)
281   (LIST&PUSH 3)
283   (LIST 2)
285   L285
285   (PUSH)
286   (LIST&PUSH 3)
288   (LIST 1)
290   (JMP L321)
292   L292
292   (CONST&PUSH 33)                     ; "loop fell off end ~a"
294   (LOAD&PUSH 3)
295   (CALLSR 1 29)                       ; ERROR
298   L298
298   (POP)
299   (SKIP&RET 6)
301   L301
301   (LOAD&PUSH 2)
302   (CALL1 4)                           ; TRANSLATE-NAME
304   (STORE 2)
305   (PUSH)
306   (GETVALUE&PUSH 31)                  ; *ADDITIONAL-COLLECTIONS*
308   (PUSH-UNBOUND 6)
310   (CONST 6)                           ; L-EQUAL
311   (STORE 1)
312   (CALLS2&JMPIFNOT 92 L292)           ; FIND
315   (LOAD&PUSH 2)
316   (LOAD&PUSH 6)
317   (LOAD&PUSH 5)
318   (CALL 3 32)                         ; LOOP-PARSE-ADDITIONAL-COLLECTIONS
321   L321
321   (STORE 0)
322   (LOAD&PUSH 3)
323   (LOAD&PUSH 2)
324   (CALLS2&JMPIF 1 L298)               ; EQL
327   (LOAD&PUSH 0)
328   (CONST&PUSH 14)                     ; SETF
329   (LOAD&PUSH 5)
330   (LOAD&PUSH 4)
331   (LIST&PUSH 3)
333   (LIST&PUSH 1)
335   (CALLSR 2 35)                       ; NCONC
338   (SKIP&RET 7)


Disassembly of function #:|(DEFUN LOOP-PARSE-ADDITIONAL-COLLECTIONS (COMMAND COLLECT-VAR NAME-VAL ...) ...)-21|
(CONST 0) = LOOP-PARSE-ADDITIONAL-COLLECTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-PARSE-ADDITIONAL-COLLECTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-PARSE-ADDITIONAL-COLLECTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-PARSE-ADDITIONAL-COLLECTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-PARSE-ADDITIONAL-COLLECTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-PARSE-ADDITIONAL-COLLECTIONS
8     (SKIP&RET 1)


Disassembly of function LOOP-PARSE-ADDITIONAL-COLLECTIONS
(CONST 0) = *ADDITIONAL-COLLECTIONS*
(CONST 1) = L-EQUAL
(CONST 2) = :SLOOP-COLLECT
(CONST 3) = *LOOP-FORM*
(CONST 4) = *LAST-VAL*
(CONST 5) = LOOP-POP
(CONST 6) = TRANSLATE-NAME
(CONST 7) = PARSE-NO-BODY
(CONST 8) = DO
(CONST 9) = PARSE-LOOP-DO
(CONST 10) = "lcase fell off end ~a  "
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-FORM* *ADDITIONAL-COLLECTIONS*)
48 byte-code instructions:
0     (NIL&PUSH)
1     (LOAD&PUSH 4)
2     (GETVALUE&PUSH 0)                   ; *ADDITIONAL-COLLECTIONS*
4     (PUSH-UNBOUND 6)
6     (CONST 1)                           ; L-EQUAL
7     (STORE 1)
8     (CALLS2&PUSH 92)                    ; FIND
10    (LOAD&PUSH 0)
11    (CONST&PUSH 2)                      ; :SLOOP-COLLECT
12    (PUSH-UNBOUND 1)
14    (CALLS2&PUSH 132)                   ; GET
16    (LOAD&PUSH 0)
17    (LOAD&PUSH 6)
18    (LOAD&PUSH 6)
19    (FUNCALL&PUSH 2)
21    (LOAD 0)
22    (BIND 3)                            ; *LOOP-FORM*
24    (NIL)
25    (BIND 4)                            ; *LAST-VAL*
27    (CALL0 5)                           ; LOOP-POP
29    (PUSH)
30    (GETVALUE 3)                        ; *LOOP-FORM*
32    (JMPIFNOT L59)
34    L34
34    (LOAD&PUSH 0)
35    (CALL1&PUSH 6)                      ; TRANSLATE-NAME
37    (LOAD&PUSH 0)
38    (CALL1&JMPIF 7 L50)                 ; PARSE-NO-BODY
41    (LOAD&PUSH 0)
42    (CONST&PUSH 8)                      ; DO
43    (CALL2&JMPIFNOT 1 L66)              ; L-EQUAL
46    (CALL0 9)                           ; PARSE-LOOP-DO
48    (STORE 11)
50    L50
50    (SKIP 1)
52    (CALL0 5)                           ; LOOP-POP
54    (STORE 0)
55    (GETVALUE 3)                        ; *LOOP-FORM*
57    (JMPIF L34)
59    L59
59    (SKIP 1)
61    (LOAD 9)
62    (UNBIND 2)
64    (SKIP&RET 8)
66    L66
66    (CONST&PUSH 10)                     ; "lcase fell off end ~a  "
67    (LOAD&PUSH 1)
68    (CALLSR 1 29)                       ; ERROR


Disassembly of function #:|(DEFUN THE-TYPE (SYMBOL TYPE) ...)-22|
(CONST 0) = THE-TYPE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE THE-TYPE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; THE-TYPE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; THE-TYPE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE THE-TYPE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; THE-TYPE
8     (SKIP&RET 1)


Disassembly of function THE-TYPE
(CONST 0) = *NO-DECLARE*
(CONST 1) = *AUTOMATIC-DECLARATIONS*
(CONST 2) = TYPE
(CONST 3) = THE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*AUTOMATIC-DECLARATIONS* *NO-DECLARE*)
44 byte-code instructions:
0     (GETVALUE 0)                        ; *NO-DECLARE*
2     (JMPIF L36)
4     (LOAD&JMPIFNOT 1 L22)
7     L7
7     (GETVALUE&PUSH 1)                   ; *AUTOMATIC-DECLARATIONS*
9     (LOAD&PUSH 2)
10    (PUSH-UNBOUND 1)
12    (CALLS2&JMPIF 133 L21)              ; GETF
15    (LOAD&PUSH 1)
16    (CALLS2 141)                        ; KEYWORDP
18    (NOT)
19    (JMPIF L43)
21    L21
21    (STORE 1)
22    L22
22    (LOAD 1)
23    (JMPIFATOM L30)
25    (LOAD&CAR&PUSH 1)
27    (JMPIFEQTO 2 L47)                   ; TYPE
30    L30
30    (LOAD&JMPIF 1 L54)
33    L33
33    (LOAD 2)
34    (SKIP&RET 3)
36    L36
36    (NIL&STORE 1)
38    (LOAD&JMPIFNOT 1 L22)
41    (JMP L7)
43    L43
43    (LOAD 1)
44    (STORE 1)
45    (JMP L22)
47    L47
47    (LOAD 1)
48    (CDR)
49    (CAR)
50    (STORE 1)
51    (LOAD&JMPIFNOT 1 L33)
54    L54
54    (CONST&PUSH 3)                      ; THE
55    (LOAD&PUSH 2)
56    (LOAD&PUSH 4)
57    (LIST 3)
59    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SLOOP-TYPE-ERROR NIL ...)-23|
(CONST 0) = SLOOP-TYPE-ERROR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SLOOP-TYPE-ERROR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP-TYPE-ERROR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SLOOP-TYPE-ERROR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SLOOP-TYPE-ERROR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SLOOP-TYPE-ERROR
8     (SKIP&RET 1)


Disassembly of function SLOOP-TYPE-ERROR
(CONST 0) = 
"While checking a bound of a sloop, I found the wrong type 
for something in sloop::*automatic-declarations*.
    Perhaps your limit is wrong? 
If not either use nodeclare t or set sloop::*automatic-declarations* to nil. 
recompile."
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST&PUSH 0)                      ; "While checking a bound of a sloop, I found the wrong type 
for something in sloop::*automatic-declarations*.
    Perhaps your limit is wrong? 
If not either use nodeclare t or set sloop::*automatic-declarations* to nil. 
recompile."
1     (CALLSR 0 29)                       ; ERROR


Disassembly of function #:|(DEFUN MAKE-VALUE (VALUE TYPE-KEY &AUX ...) ...)-24|
(CONST 0) = MAKE-VALUE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKE-VALUE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKE-VALUE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKE-VALUE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKE-VALUE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKE-VALUE
8     (SKIP&RET 1)


Disassembly of function MAKE-VALUE
(CONST 0) = *NO-DECLARE*
(CONST 1) = *TYPE-CHECK*
(CONST 2) = :FROM
(CONST 3) = *AUTOMATIC-DECLARATIONS*
(CONST 4) = TYPE
(CONST 5) = *TYPE-TEST-LIMIT*
(CONST 6) = THE-VALUE
(CONST 7) = TYPEP
(CONST 8) = 
"~&Sloop found the type of ~a was not type ~a,~%~
                      Maybe you want to insert SLOOP NODECLARE T ..."
(CONST 9) = LET
(CONST 10) = OR
(CONST 11) = QUOTE
(CONST 12) = ((SLOOP-TYPE-ERROR))
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*TYPE-TEST-LIMIT* *AUTOMATIC-DECLARATIONS* *TYPE-CHECK* *NO-DECLARE*)
104 byte-code instructions:
0     (NIL&PUSH)
1     (GETVALUE 0)                        ; *NO-DECLARE*
3     (JMPIF L151)
6     (GETVALUE 1)                        ; *TYPE-CHECK*
8     (JMPIFNOT L151)
11    (LOAD&PUSH 2)
12    (JMPIFNOTEQTO 2 L151)               ; :FROM
16    (GETVALUE&PUSH 3)                   ; *AUTOMATIC-DECLARATIONS*
18    (LOAD&PUSH 3)
19    (PUSH-UNBOUND 1)
21    (CALLS2&STORE 133 0)                ; GETF
24    (JMPIFNOT L151)
27    (LOAD 0)
28    (JMPIFATOM L35)
30    (LOAD&CAR&PUSH 0)
32    (JMPIFEQTO 4 L95)                   ; TYPE
35    L35
35    (LOAD 0)
36    L36
36    (STORE 0)
37    (LOAD&PUSH 3)
38    (PUSH-UNBOUND 1)
40    (CALLS1&JMPIF 94 L116)              ; CONSTANTP
44    (NIL&PUSH)
45    (CONST&PUSH 9)                      ; LET
46    (LOAD 5)
47    (JMPIFATOM L132)
50    (PUSH-UNBOUND 1)
52    (CALLS2&STORE 143 1)                ; GENSYM
55    (PUSH)
56    (LOAD&PUSH 6)
57    (LIST&PUSH 2)
59    (LIST 1)
61    L61
61    (PUSH)
62    (CONST&PUSH 10)                     ; OR
63    (CONST&PUSH 7)                      ; TYPEP
64    (GETVALUE 5)                        ; *TYPE-TEST-LIMIT*
66    (JMPIF L136)
69    (LOAD&JMPIF 4 L73)
72    (LOAD 8)
73    L73
73    (PUSH)
74    (CONST&PUSH 11)                     ; QUOTE
75    (LOAD&PUSH 7)
76    (LIST&PUSH 2)
78    (LIST&PUSH 3)
80    (CONST 12)                          ; ((SLOOP-TYPE-ERROR))
81    (LIST*&PUSH 2)
83    (LOAD&JMPIF 3 L87)
86    (LOAD 7)
87    L87
87    (PUSH)
88    (LIST 4)
90    L90
90    (PUSH)
91    (LIST 1)
93    (SKIP&RET 5)
95    L95
95    (LOAD 0)
96    (CDR)
97    (CAR)
98    (JMP L36)
100   L100
100   (LOAD&PUSH 3)
101   (CONST&PUSH 6)                      ; THE-VALUE
102   (GETVALUE&PUSH 5)                   ; *TYPE-TEST-LIMIT*
104   (PUSH-UNBOUND 3)
106   (CALLS1 172)                        ; SUBST
108   (JMP L121)
110   L110
110   (CONST&PUSH 8)                      ; "~&Sloop found the type of ~a was not type ~a,~%~
                      Maybe you want to insert SLOOP NODECLARE T ..."
111   (LOAD&PUSH 5)
112   (LOAD&PUSH 3)
113   (CALLSR 2 29)                       ; ERROR
116   L116
116   (GETVALUE 5)                        ; *TYPE-TEST-LIMIT*
118   (JMPIF L100)
120   (LOAD 3)
121   L121
121   (PUSH)
122   (CALLS1&PUSH 91)                    ; EVAL
124   (LOAD&PUSH 0)
125   (LOAD&PUSH 2)
126   (CALL2&JMPIFNOT 7 L110)             ; TYPEP
129   (LOAD 4)
130   (JMP L90)
132   L132
132   (NIL)
133   (JMP L61)
136   L136
136   (LOAD&JMPIF 4 L140)
139   (LOAD 8)
140   L140
140   (PUSH)
141   (CONST&PUSH 6)                      ; THE-VALUE
142   (GETVALUE&PUSH 5)                   ; *TYPE-TEST-LIMIT*
144   (PUSH-UNBOUND 3)
146   (CALLS1 172)                        ; SUBST
148   (JMP L73)
151   L151
151   (LOAD&PUSH 3)
152   (LIST 1)
154   (SKIP&RET 4)


Disassembly of function #:|(DEFUN LOOP-ADD-BINDING (VARIABLE VALUE &OPTIONAL ...) ...)-25|
(CONST 0) = LOOP-ADD-BINDING
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-ADD-BINDING>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-ADD-BINDING
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-ADD-BINDING
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-ADD-BINDING>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-ADD-BINDING
8     (SKIP&RET 1)


Disassembly of function LOOP-ADD-BINDING
(CONST 0) = *LOOP-BINDINGS*
(CONST 1) = MAKE-VALUE
(CONST 2) = LOOP-DECLARE-BINDING
2 required arguments
5 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-BINDINGS*)
writes special variable : (*LOOP-BINDINGS*)
107 byte-code instructions:
0     (JMPIFBOUNDP 5 L5)
3     (T&STORE 5)
5     L5
5     (UNBOUND->NIL 4)
7     (UNBOUND->NIL 3)
9     (JMPIFBOUNDP 2 L14)
12    (T&STORE 2)
14    L14
14    (UNBOUND->NIL 1)
16    (NIL&PUSH)
17    (LOAD&JMPIF 6 L24)
20    (GETVALUE 0)                        ; *LOOP-BINDINGS*
22    (JMPIF L32)
24    L24
24    (NIL&PUSH)
25    (NIL)
26    (CONS&PUSH)
27    (GETVALUE 0)                        ; *LOOP-BINDINGS*
29    (CONS)
30    (SETVALUE 0)                        ; *LOOP-BINDINGS*
32    L32
32    (LOAD&PUSH 8)
33    (GETVALUE 0)                        ; *LOOP-BINDINGS*
35    (CAR)
36    (CAR&PUSH)
37    (PUSH-UNBOUND 3)
39    (CALLS1&STORE 187 0)                ; ASSOC
42    (JMPIF L153)
45    (LOAD&JMPIF 2 L60)
48    (LOAD&PUSH 8)
49    (CALLS2&JMPIF 138 L125)             ; SYMBOL-PACKAGE
53    (LOAD&PUSH 7)
54    (PUSH-UNBOUND 1)
56    (CALLS1&JMPIFNOT 94 L125)           ; CONSTANTP
60    L60
60    (GETVALUE 0)                        ; *LOOP-BINDINGS*
62    (CDR&PUSH)
63    (NIL&PUSH)
64    L64
64    (LOAD&PUSH 1)
65    (CALLS1&JMPIF 146 L123)             ; ENDP
68    (LOAD&CAR&STORE 1 0)
71    (LOAD&PUSH 10)
72    (LOAD&CAR&PUSH 1)
74    (PUSH-UNBOUND 3)
76    (CALLS1&STORE 187 2)                ; ASSOC
79    (JMPIFNOT L119)
81    (LOAD&JMPIFNOT 5 L95)
84    (LOAD&PUSH 2)
85    (LOAD&JMPIFNOT 10 L92)
88    (PUSH)
89    (LOAD&PUSH 9)
90    (CALL2 1)                           ; MAKE-VALUE
92    L92
92    (PUSH)
93    (CALLS1 171)                        ; SYSTEM::%RPLACD
95    L95
95    (SKIP 2)
97    (LOAD&JMPIFNOT 5 L165)
101   (JMP L159)
103   L103
103   (LOAD&PUSH 0)
104   (LOAD&JMPIFNOT 8 L111)
107   (PUSH)
108   (LOAD&PUSH 7)
109   (CALL2 1)                           ; MAKE-VALUE
111   L111
111   (PUSH)
112   (CALLS1 171)                        ; SYSTEM::%RPLACD
114   (LOAD&JMPIFNOT 5 L165)
117   (JMP L159)
119   L119
119   (LOAD&CDR&STORE 1)
121   (JMP L64)
123   L123
123   (SKIP 2)
125   L125
125   (LOAD&PUSH 8)
126   (LOAD&JMPIFNOT 8 L133)
129   (PUSH)
130   (LOAD&PUSH 7)
131   (CALL2 1)                           ; MAKE-VALUE
133   L133
133   (CONS&PUSH)
134   (GETVALUE&PUSH 0)                   ; *LOOP-BINDINGS*
136   (LOAD 0)
137   (CAR)
138   (CAR&PUSH)
139   (LOAD&CAR&PUSH 1)
141   (LOAD&PUSH 3)
142   (LOAD 2)
143   (CONS&PUSH)
144   (CALLS1 169)                        ; SYSTEM::%RPLACA
146   (SKIP 3)
148   (LOAD&JMPIFNOT 5 L165)
151   (JMP L159)
153   L153
153   (LOAD&JMPIF 3 L103)
156   (LOAD&JMPIFNOT 5 L165)
159   L159
159   (LOAD&PUSH 8)
160   (LOAD&PUSH 6)
161   (LOAD&PUSH 6)
162   (CALL 3 2)                          ; LOOP-DECLARE-BINDING
165   L165
165   (LOAD 8)
166   (SKIP&RET 9)


Disassembly of function #:|(DEFUN LOOP-DECLARE-BINDING (VAR TYPE FORCE-TYPE ...) ...)-26|
(CONST 0) = LOOP-DECLARE-BINDING
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-DECLARE-BINDING>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-DECLARE-BINDING
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-DECLARE-BINDING
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-DECLARE-BINDING>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-DECLARE-BINDING
8     (SKIP&RET 1)


Disassembly of function LOOP-DECLARE-BINDING
(CONST 0) = *AUTO-TYPE*
(CONST 1) = *AUTOMATIC-DECLARATIONS*
(CONST 2) = *AUTO-REGISTER*
(CONST 3) = :REGISTER
(CONST 4) = *NO-DECLARE*
(CONST 5) = *LOOP-BINDINGS*
(CONST 6) = TYPE
(CONST 7) = EQUAL
(CONST 8) = *LOOP-MAP*
(CONST 9) = "Could not find variable ~a in bindings"
3 required arguments
1 optional argument
No rest parameter
No keyword parameters
reads special variables: 
(*LOOP-MAP* *LOOP-BINDINGS* *NO-DECLARE* *AUTO-REGISTER*
 *AUTOMATIC-DECLARATIONS* *AUTO-TYPE*)
93 byte-code instructions:
0     L0
0     (UNBOUND->NIL 1)
2     (NIL&PUSH)
3     (LOAD&JMPIFNOT 4 L28)
6     (PUSH)
7     (GETVALUE&PUSH 0)                   ; *AUTO-TYPE*
9     (PUSH-UNBOUND 3)
11    (CALLS1&JMPIFNOT 180 L28)           ; MEMBER
14    (GETVALUE&PUSH 1)                   ; *AUTOMATIC-DECLARATIONS*
16    (LOAD&PUSH 5)
17    (PUSH-UNBOUND 1)
19    (CALLS2&STORE 133 4)                ; GETF
22    (JMPIFNOT L28)
24    (GETVALUE 2)                        ; *AUTO-REGISTER*
26    (JMPIF L81)
28    L28
28    (LOAD&JMPIFNOT 4 L143)
32    L32
32    (LOAD&JMPIF 3 L40)
35    (GETVALUE 4)                        ; *NO-DECLARE*
37    (JMPIF L143)
40    L40
40    (GETVALUE&PUSH 5)                   ; *LOOP-BINDINGS*
42    (NIL&PUSH)
43    L43
43    (LOAD&PUSH 1)
44    (CALLS1&JMPIF 146 L134)             ; ENDP
48    (LOAD&CAR&STORE 1 0)
51    (LOAD&PUSH 7)
52    (LOAD&CAR&PUSH 1)
54    (PUSH-UNBOUND 3)
56    (CALLS1&JMPIFNOT 187 L124)          ; ASSOC
60    (T&STORE 2)
62    (LOAD 6)
63    (JMPIFATOM L70)
65    (LOAD&CAR&PUSH 6)
67    (JMPIFEQTO 6 L94)                   ; TYPE
70    L70
70    (LOAD&JMPIFNOT 4 L100)
73    (CONST&PUSH 6)                      ; TYPE
74    (LOAD 7)
75    L75
75    (PUSH)
76    (LOAD&PUSH 9)
77    (LIST 3)
79    (JMP L104)
81    L81
81    (LOAD&PUSH 5)
82    (CONST&PUSH 3)                      ; :REGISTER
83    (LOAD&PUSH 5)
84    (PUSH-UNBOUND 1)
86    (JSR L0)
89    (LOAD&JMPIFNOT 4 L143)
92    (JMP L32)
94    L94
94    (CONST&PUSH 6)                      ; TYPE
95    (LOAD 7)
96    (CDR)
97    (CAR)
98    (JMP L75)
100   L100
100   (LOAD&PUSH 6)
101   (LOAD&PUSH 8)
102   (LIST 2)
104   L104
104   (PUSH)
105   (LOAD&CDR&PUSH 1)
107   (LOAD&PUSH 2)
108   (LOAD&PUSH 2)
109   (LOAD&PUSH 2)
110   (CONST&PUSH 7)                      ; EQUAL
111   (PUSH-UNBOUND 2)
113   (CALLS1&PUSH 184)                   ; ADJOIN
115   (CALLS1 171)                        ; SYSTEM::%RPLACD
117   (SKIP 4)
119   (LOAD&JMPIFNOT 0 L139)
122   (JMP L143)
124   L124
124   (LOAD&CDR&STORE 1)
126   (JMP L43)
129   L129
129   (CONST&PUSH 9)                      ; "Could not find variable ~a in bindings"
130   (LOAD&PUSH 6)
131   (CALLSR 1 29)                       ; ERROR
134   L134
134   (SKIP 2)
136   (LOAD&JMPIF 0 L143)
139   L139
139   (GETVALUE 8)                        ; *LOOP-MAP*
141   (JMPIFNOT L129)
143   L143
143   (LOAD 5)
144   (SKIP&RET 6)


Disassembly of function #:|(DEFUN PARSE-LOOP-DECLARE (&OPTIONAL # #) ...)-27|
(CONST 0) = PARSE-LOOP-DECLARE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-DECLARE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-DECLARE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-DECLARE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-DECLARE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-DECLARE
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-DECLARE
(CONST 0) = LOOP-POP
(CONST 1) = TYPE
(CONST 2) = LOOP-DECLARE-BINDING
0 required arguments
2 optional arguments
No rest parameter
No keyword parameters
32 byte-code instructions:
0     (JMPIFBOUNDP 2 L6)
3     (CALL0 0)                           ; LOOP-POP
5     (STORE 2)
6     L6
6     (JMPIFBOUNDP 1 L11)
9     (T&STORE 1)
11    L11
11    (LOAD&CAR&PUSH 2)
13    (NIL&PUSH)
14    (LOAD&PUSH 1)
15    (JMPIFNOTEQTO 1 L24)                ; TYPE
18    (LOAD&CDR&STORE 4)
20    (CAR)
21    (STORE 1)
22    (T&STORE 0)
24    L24
24    (LOAD&CDR&PUSH 4)
26    (NIL&PUSH)
27    (JMP L42)
29    L29
29    (LOAD&CAR&STORE 1 0)
32    (PUSH)
33    (LOAD&CAR&PUSH 7)
35    (LOAD&PUSH 7)
36    (LOAD&PUSH 5)
37    (CALL 4 2)                          ; LOOP-DECLARE-BINDING
40    (LOAD&CDR&STORE 1)
42    L42
42    (LOAD&PUSH 1)
43    (CALLS1&JMPIFNOT 146 L29)           ; ENDP
46    (NIL)
47    (SKIP&RET 7)


Disassembly of function #:|(DEFUN LOOP-ADD-TEMPS (FORM &OPTIONAL VAL ...) ...)-28|
(CONST 0) = LOOP-ADD-TEMPS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOOP-ADD-TEMPS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOOP-ADD-TEMPS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOOP-ADD-TEMPS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOOP-ADD-TEMPS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOOP-ADD-TEMPS
8     (SKIP&RET 1)


Disassembly of function LOOP-ADD-TEMPS
(CONST 0) = LOOP-ADD-BINDING
1 required argument
4 optional arguments
No rest parameter
No keyword parameters
33 byte-code instructions:
0     L0
0     (UNBOUND->NIL 4)
2     (UNBOUND->NIL 3)
4     (UNBOUND->NIL 2)
6     (UNBOUND->NIL 1)
8     (LOAD 5)
9     (NOT)
10    (JMPIF1 L49)
12    (LOAD&PUSH 5)
13    (CALLS2&JMPIF 6 L23)                ; SYMBOLP
16    (LOAD&PUSH 5)
17    (CALLS2&JMPIF 11 L35)               ; LISTP
20    (NIL)
21    (SKIP&RET 6)
23    L23
23    (LOAD&PUSH 5)
24    (LOAD&PUSH 5)
25    (LOAD&PUSH 4)
26    (LOAD&PUSH 6)
27    (NIL&PUSH)
28    (T&PUSH)
29    (LOAD&PUSH 7)
30    (CALL 7 0)                          ; LOOP-ADD-BINDING
33    (SKIP&RET 6)
35    L35
35    (LOAD&CAR&PUSH 5)
37    (PUSH-UNBOUND 4)
39    (JSR L0)
41    (LOAD&CDR&PUSH 5)
43    (PUSH-UNBOUND 4)
45    (JMPTAIL 5 11 L0)
49    L49
49    (SKIP&RET 6)


Disassembly of function #:|(DEFUN ADD-FROM-DATA (DATA &REST ARGS) ...)-29|
(CONST 0) = ADD-FROM-DATA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = "rest = var begin end  incr direction or-eql"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE ADD-FROM-DATA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; ADD-FROM-DATA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ADD-FROM-DATA
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "rest = var begin end  incr direction or-eql"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; ADD-FROM-DATA
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE ADD-FROM-DATA>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (CONST 0)                           ; ADD-FROM-DATA
14    (SKIP&RET 1)


Disassembly of function ADD-FROM-DATA
(CONST 0) = (NIL 0 NIL 1 + NIL)
1 required argument
0 optional arguments
Rest parameter
No keyword parameters
23 byte-code instructions:
0     (LOAD&JMPIF 2 L7)
3     (CONST&PUSH 0)                      ; (NIL 0 NIL 1 + NIL)
4     (CALLS1&STORE 158 2)                ; COPY-LIST
7     L7
7     (LOAD&PUSH 2)
8     (LOAD&PUSH 2)
9     (LOAD&JMPIFNOT 0 L30)
12    L12
12    (LOAD 0)
13    (CAR)
14    (JMPIFNOT L21)
16    (LOAD&PUSH 1)
17    (LOAD&CAR&PUSH 1)
19    (CALLS1 169)                        ; SYSTEM::%RPLACA
21    L21
21    (LOAD&CDR&PUSH 1)
23    (LOAD&CDR&STORE 1)
25    (POP&STORE 1)
27    (LOAD&JMPIF 0 L12)
30    L30
30    (SKIP 2)
32    (LOAD 2)
33    (SKIP&RET 3)


Disassembly of function #:|(DEFUN PARSE-LOOP-FOR (&AUX INC FROM-DATA) ...)-30|
(CONST 0) = PARSE-LOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-FOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-FOR
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-FOR
(CONST 0) = LOOP-POP
(CONST 1) = TRANSLATE-NAME
(CONST 2) = IN
(CONST 3) = L-EQUAL
(CONST 4) = "LIS"
(CONST 5) = :IN
(CONST 6) = LOOP-ADD-TEMPS
(CONST 7) = LOOP-ADD-BINDING
(CONST 8) = DESETQ
(CONST 9) = CAR
(CONST 10) = *LOOP-BODY*
(CONST 11) = SETF
(CONST 12) = CDR
(CONST 13) = NULL
(CONST 14) = ON
(CONST 15) = "LIS"
(CONST 16) = (UPFROM FROM)
(CONST 17) = +
(CONST 18) = ADD-FROM-DATA
(CONST 19) = DOWNFROM
(CONST 20) = -
(CONST 21) = BY
(CONST 22) = QUOTE
(CONST 23) = #(NIL)
(CONST 24) = :NAME
(CONST 25) = CONTINUE
(CONST 26) = :INVOKE-FUNCTION
(CONST 27) = #<COMPILED-CLOSURE PARSE-LOOP-FOR-1>
(CONST 28) = :REPORT
(CONST 29) = SYSTEM::REPORT-NO-NEW-VALUE
(CONST 30) = :INTERACTIVE
(CONST 31) = SYSTEM::ASSERT-RESTART-NO-PROMPTS
(CONST 32) = SYSTEM::MAKE-RESTART
(CONST 33) = SYSTEM::*ACTIVE-RESTARTS*
(CONST 34) = SYSTEM::*CONDITION-RESTARTS*
(CONST 35) = (#(CONDITION 193) 1 . 1)
(CONST 36) = SYSTEM::ADD-CONDITION-RESTARTS
(CONST 37) = SIGNAL
(CONST 38) = "~A"
(CONST 39) = (EQ (CAR (THIRD INCR)) 'CDR)
(CONST 40) = SYSTEM::ASSERT-ERROR-STRING
(CONST 41) = BELOW
(CONST 42) = ABOVE
(CONST 43) = TO
(CONST 44) = :SLOOP-FOR
(CONST 45) = PARSE-LOOP-MACRO
(CONST 46) = :SLOOP-MAP
(CONST 47) = PARSE-LOOP-MAP
(CONST 48) = LOOP-UN-POP
(CONST 49) = 4
(CONST 50) = 5
(CONST 51) = :FROM
(CONST 52) = *NO-DECLARE*
(CONST 53) = THE-TYPE
(CONST 54) = "LIM"
(CONST 55) = 1
(CONST 56) = THE-VALUE
(CONST 57) = *TYPE-TEST-LIMIT*
(CONST 58) = >
(CONST 59) = <
(CONST 60) = >=
(CONST 61) = <=
(CONST 62) = *TYPE-CHECK*
(CONST 63) = *AUTOMATIC-DECLARATIONS*
(CONST 64) = TYPE
(CONST 65) = FIXNUM
(CONST 66) = SUBTYPEP
(CONST 67) = "increment must be constant."
(CONST 68) = OR
(CONST 69) = #.MOST-POSITIVE-FIXNUM
(CONST 70) = #.MOST-NEGATIVE-FIXNUM
(CONST 71) = ((SLOOP-TYPE-ERROR))
(CONST 72) = *LOOP-INCREMENT*
(CONST 73) = AND
(CONST 74) = ((LOCAL-FINISH))
(CONST 75) = *LOOP-END-TEST*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(*LOOP-END-TEST* *LOOP-INCREMENT* *AUTOMATIC-DECLARATIONS* *TYPE-CHECK*
 *NO-DECLARE* SYSTEM::*CONDITION-RESTARTS* SYSTEM::*ACTIVE-RESTARTS*
 *LOOP-BODY*)
writes special variables : (*LOOP-END-TEST* *LOOP-INCREMENT* *NO-DECLARE* *LOOP-BODY*)
454 byte-code instructions:
0     (PUSH-NIL 2)
2     (CALL0 0)                           ; LOOP-POP
4     (PUSH)
5     (PUSH-NIL 2)
7     (CALL0 0)                           ; LOOP-POP
9     (PUSH)
10    L10
10    (LOAD&PUSH 0)
11    (CALL1&PUSH 1)                      ; TRANSLATE-NAME
13    (LOAD&PUSH 0)
14    (CONST&PUSH 2)                      ; IN
15    (CALL2&JMPIF 3 L73)                 ; L-EQUAL
18    (LOAD&PUSH 0)
19    (CONST&PUSH 14)                     ; ON
20    (CALL2&JMPIFNOT 3 L306)             ; L-EQUAL
24    (LOAD&PUSH 4)
25    (CALLS2&JMPIF 6 L116)               ; SYMBOLP
29    (CONST&PUSH 15)                     ; "LIS"
30    (CALLS2 143)                        ; GENSYM
32    L32
32    (PUSH)
33    (LOAD&PUSH 5)
34    (NIL&PUSH)
35    (CONST&PUSH 5)                      ; :IN
36    (T&PUSH)
37    (CALL 4 6)                          ; LOOP-ADD-TEMPS
40    (LOAD&PUSH 0)
41    (CALL0 0)                           ; LOOP-POP
43    (PUSH)
44    (NIL&PUSH)
45    (CALL 3 7)                          ; LOOP-ADD-BINDING
48    (CONST&PUSH 11)                     ; SETF
49    (LOAD&PUSH 1)
50    (CONST&PUSH 12)                     ; CDR
51    (LOAD&PUSH 3)
52    (LIST&PUSH 2)
54    (LIST 3)
56    (STORE 3)
57    (LOAD&PUSH 0)
58    (LOAD&PUSH 6)
59    (CALLS2&JMPIFNOT 1 L120)            ; EQL
62    (CONST 13)                          ; NULL
63    L63
63    (PUSH)
64    (LOAD&PUSH 1)
65    (LIST 2)
67    (STORE 4)
68    (SKIP 1)
70    (JMP L386)
73    L73
73    (CONST&PUSH 4)                      ; "LIS"
74    (CALLS2&PUSH 143)                   ; GENSYM
76    (LOAD&PUSH 5)
77    (NIL&PUSH)
78    (CONST&PUSH 5)                      ; :IN
79    (T&PUSH)
80    (CALL 4 6)                          ; LOOP-ADD-TEMPS
83    (LOAD&PUSH 0)
84    (CALL0 0)                           ; LOOP-POP
86    (PUSH)
87    (NIL&PUSH)
88    (CALL 3 7)                          ; LOOP-ADD-BINDING
91    (CONST&PUSH 8)                      ; DESETQ
92    (LOAD&PUSH 6)
93    (CONST&PUSH 9)                      ; CAR
94    (LOAD&PUSH 3)
95    (LIST&PUSH 2)
97    (LIST&PUSH 3)
99    (GETVALUE 10)                       ; *LOOP-BODY*
101   (CONS)
102   (SETVALUE 10)                       ; *LOOP-BODY*
104   (CONST&PUSH 11)                     ; SETF
105   (LOAD&PUSH 1)
106   (CONST&PUSH 12)                     ; CDR
107   (LOAD&PUSH 3)
108   (LIST&PUSH 2)
110   (LIST 3)
112   (STORE 3)
113   (CONST 13)                          ; NULL
114   (JMP L63)
116   L116
116   (LOAD 4)
117   (JMP L32)
120   L120
120   (CONST&PUSH 8)                      ; DESETQ
121   (LOAD&PUSH 6)
122   (LOAD&PUSH 2)
123   (LIST&PUSH 3)
125   (GETVALUE 10)                       ; *LOOP-BODY*
127   (CONS)
128   (SETVALUE 10)                       ; *LOOP-BODY*
130   (CONST 13)                          ; NULL
131   (JMP L63)
134   L134
134   (LOAD&PUSH 5)
135   (LOAD&PUSH 5)
136   (CALL0 0)                           ; LOOP-POP
138   (PUSH)
139   (PUSH-NIL 2)
141   (CONST 17)                          ; +
142   (JMP L345)
145   L145
145   (LOAD&PUSH 5)
146   (LOAD&PUSH 5)
147   (CALL0 0)                           ; LOOP-POP
149   (PUSH)
150   (PUSH-NIL 2)
152   (CONST 20)                          ; -
153   (JMP L345)
156   L156
156   (LOAD 6)
157   (CDR)
158   (CAR)
159   (STORE 6)
160   (LOAD&JMPIFNOT 5 L271)
164   (JMP L182)
166   L166
166   (CALL0 0)                           ; LOOP-POP
168   (STORE 6)
169   (PUSH)
170   (CALLS2&JMPIFNOT 11 L178)           ; LISTP
173   (LOAD&CAR&PUSH 6)
175   (JMPIFEQTO 22 L156)                 ; QUOTE
178   L178
178   (LOAD&JMPIFNOT 5 L271)
182   L182
182   (PUSH)
183   (PUSH-NIL 3)
185   (LOAD&PUSH 10)
186   (CALL 5 18)                         ; ADD-FROM-DATA
189   (STORE 5)
190   (JMP L386)
193   L193
193   (HANDLER-BEGIN&PUSH)
194   (LOAD&PUSH 0)
195   (LOADI&PUSH 0 0 6)
199   (CALL2 36)                          ; SYSTEM::ADD-CONDITION-RESTARTS
201   (LOAD&PUSH 0)
202   (CALL1 37)                          ; SIGNAL
204   (SKIPSP 2 1)
207   (SKIP&RET 2)
209   L209
209   (NIL)
210   (MAKE-VECTOR1&PUSH 1)
212   (NIL)
213   (STOREC 0 0)
216   (TAGBODY-OPEN 23 L262)              ; #(NIL)
219   (CONST&PUSH 24)                     ; :NAME
220   (CONST&PUSH 25)                     ; CONTINUE
221   (CONST&PUSH 26)                     ; :INVOKE-FUNCTION
222   (LOAD&PUSH 7)
223   (LOAD&PUSH 6)
224   (COPY-CLOSURE&PUSH 27 2)            ; #<COMPILED-CLOSURE PARSE-LOOP-FOR-1>
227   (CONST&PUSH 28)                     ; :REPORT
228   (CONST&SYMBOL-FUNCTION&PUSH 29)     ; SYSTEM::REPORT-NO-NEW-VALUE
230   (CONST&PUSH 30)                     ; :INTERACTIVE
232   (CONST&SYMBOL-FUNCTION&PUSH 31)     ; SYSTEM::ASSERT-RESTART-NO-PROMPTS
234   (CALL&PUSH 8 32)                    ; SYSTEM::MAKE-RESTART
237   (LIST&PUSH 1)
239   (LOAD&PUSH 0)
240   (GETVALUE&PUSH 33)                  ; SYSTEM::*ACTIVE-RESTARTS*
242   (CALLSR 2 34)                       ; APPEND
245   (BIND 33)                           ; SYSTEM::*ACTIVE-RESTARTS*
247   (GETVALUE 34)                       ; SYSTEM::*CONDITION-RESTARTS*
249   (BIND 34)                           ; SYSTEM::*CONDITION-RESTARTS*
251   (HANDLER-OPEN 35 L193)              ; (#(CONDITION 193) 1 . 1)
253   (CONST&PUSH 38)                     ; "~A"
255   (CONST&PUSH 39)                     ; (EQ (CAR (THIRD INCR)) 'CDR)
257   (CALL1&PUSH 40)                     ; SYSTEM::ASSERT-ERROR-STRING
259   (CALLSR 1 29)                       ; ERROR
262   L262
262   (LOADC 4 0)
265   (UNLIST 0 0)
268   (TAGBODY-CLOSE)
269   (SKIP 1)
271   L271
271   (LOAD 2)
272   (CDR)
273   (CDR)
274   (CAR)
275   (CAR&PUSH)
276   (JMPIFNOTEQTO 12 L209)              ; CDR
280   (CONST&PUSH 11)                     ; SETF
281   (LOAD 3)
282   (CDR)
283   (CAR&PUSH)
284   (LOAD&PUSH 8)
285   (LOAD 5)
286   (CDR)
287   (CAR&PUSH)
288   (LIST&PUSH 2)
290   (LIST 3)
292   (STORE 2)
293   (JMP L386)
296   L296
296   (LOAD&PUSH 5)
297   (LOAD&PUSH 5)
298   (NIL&PUSH)
299   (CALL0 0)                           ; LOOP-POP
301   (PUSH)
302   (NIL&PUSH)
303   (CONST 17)                          ; +
304   (JMP L345)
306   L306
306   (LOAD&PUSH 0)
307   (CONST&PUSH 16)                     ; (UPFROM FROM)
308   (CALL2&JMPIF 3 L134)                ; L-EQUAL
312   (LOAD&PUSH 0)
313   (CONST&PUSH 19)                     ; DOWNFROM
314   (CALL2&JMPIF 3 L145)                ; L-EQUAL
318   (LOAD&PUSH 0)
319   (CONST&PUSH 21)                     ; BY
320   (CALL2&JMPIF 3 L166)                ; L-EQUAL
324   (LOAD&PUSH 0)
325   (CONST&PUSH 41)                     ; BELOW
327   (CALL2&JMPIF 3 L296)                ; L-EQUAL
330   (LOAD&PUSH 0)
331   (CONST&PUSH 42)                     ; ABOVE
333   (CALL2&JMPIFNOT 3 L493)             ; L-EQUAL
337   (LOAD&PUSH 5)
338   (LOAD&PUSH 5)
339   (NIL&PUSH)
340   (CALL0 0)                           ; LOOP-POP
342   (PUSH)
343   (NIL&PUSH)
344   (CONST 20)                          ; -
345   L345
345   (PUSH)
346   (CALL 6 18)                         ; ADD-FROM-DATA
349   (STORE 5)
350   (JMP L386)
352   L352
352   (LOAD&PUSH 1)
353   (CALL1&PUSH 1)                      ; TRANSLATE-NAME
355   (CONST&PUSH 44)                     ; :SLOOP-FOR
357   (LOAD&PUSH 6)
358   (CALL 3 45)                         ; PARSE-LOOP-MACRO
361   (JMP L528)
364   L364
364   (LOAD&PUSH 1)
365   (CALL1&PUSH 1)                      ; TRANSLATE-NAME
367   (LOAD&PUSH 5)
368   (CALL2 47)                          ; PARSE-LOOP-MAP
370   (JMP L528)
373   L373
373   (LOAD&PUSH 5)
374   (LOAD&PUSH 5)
375   (NIL&PUSH)
376   (CALL0 0)                           ; LOOP-POP
378   (PUSH)
379   (PUSH-NIL 2)
381   (T&PUSH)
382   (CALL 7 18)                         ; ADD-FROM-DATA
385   (STORE 5)
386   L386
386   (SKIP 1)
388   (CALL0 0)                           ; LOOP-POP
390   (STORE 0)
391   (JMP L10)
394   L394
394   (NIL)
395   (JMP L433)
397   L397
397   (CONST 58)                          ; >
399   (JMP L454)
401   L401
401   (LOAD&PUSH 9)
402   (JMPIFEQTO 17 L397)                 ; +
405   (CONST 59)                          ; <
407   (JMP L454)
409   L409
409   (CONST 60)                          ; >=
411   (JMP L454)
413   L413
413   (CONST&PUSH 54)                     ; "LIM"
415   (CALLS2&PUSH 143)                   ; GENSYM
417   (LOAD&PUSH 2)
418   (JMPIFNOTEQTO 55 L427)              ; 1
421   (CONST&PUSH 50)                     ; 5
423   (LOAD&PUSH 11)
424   (CALLS1&JMPIFNOT 148 L394)          ; NTH
427   L427
427   (LOAD&PUSH 6)
428   (CONST&PUSH 56)                     ; THE-VALUE
430   (LOAD&PUSH 4)
431   (LIST 3)
433   L433
433   (BIND 57)                           ; *TYPE-TEST-LIMIT*
435   (LOAD&PUSH 3)
436   (LOAD&PUSH 7)
437   (NIL&PUSH)
438   (CONST&PUSH 51)                     ; :FROM
440   (PUSH-NIL 2)
442   (CALL 6 7)                          ; LOOP-ADD-BINDING
445   (LOAD&JMPIF 8 L401)
448   (LOAD&PUSH 9)
449   (JMPIFEQTO 17 L409)                 ; +
452   (CONST 61)                          ; <=
454   L454
454   (PUSH)
455   (LOAD&PUSH 8)
456   (LOAD&PUSH 5)
457   (LIST 3)
459   (STORE 11)
461   (UNBIND1)
462   (SKIP 7)
464   (LOAD&JMPIFNOT 1 L698)
468   (JMP L676)
471   L471
471   (CONST&PUSH 67)                     ; "increment must be constant."
473   (CALLSR 0 29)                       ; ERROR
476   L476
476   (CONST&PUSH 59)                     ; <
478   (LOAD&PUSH 5)
479   (CONST&PUSH 69)                     ; #.MOST-POSITIVE-FIXNUM
481   (LOAD&JMPIF 5 L486)
484   (CONST 55)                          ; 1
486   L486
486   (PUSH)
487   (CALLSR 1 54)                       ; -
490   (JMP L659)
493   L493
493   (LOAD&PUSH 0)
494   (CONST&PUSH 43)                     ; TO
496   (CALL2&JMPIF 3 L373)                ; L-EQUAL
500   (LOAD&PUSH 0)
501   (CALLS2&JMPIFNOT 6 L513)            ; SYMBOLP
504   (LOAD&PUSH 0)
505   (CONST&PUSH 44)                     ; :SLOOP-FOR
507   (PUSH-UNBOUND 1)
509   (CALLS2&JMPIF 132 L352)             ; GET
513   L513
513   (LOAD&PUSH 0)
514   (CALLS2&JMPIFNOT 6 L526)            ; SYMBOLP
517   (LOAD&PUSH 0)
518   (CONST&PUSH 46)                     ; :SLOOP-MAP
520   (PUSH-UNBOUND 1)
522   (CALLS2&JMPIF 132 L364)             ; GET
526   L526
526   (CALL0 48)                          ; LOOP-UN-POP
528   L528
528   (SKIP 2)
530   (LOAD&JMPIFNOT 3 L695)
534   (CONST&PUSH 49)                     ; 4
536   (LOAD&PUSH 4)
537   (CALLS1&PUSH 148)                   ; NTH
539   (CONST&PUSH 50)                     ; 5
541   (LOAD&PUSH 5)
542   (CALLS1&PUSH 148)                   ; NTH
544   (LOAD&CAR&PUSH 5)
546   (LOAD 6)
547   (CDR)
548   (CDR)
549   (CAR&PUSH)
550   (LOAD 7)
551   (CDR)
552   (CDR)
553   (CDR)
554   (CAR&PUSH)
555   (NIL&PUSH)
556   (LOAD&PUSH 3)
557   (LOAD 10)
558   (CDR)
559   (CAR&PUSH)
560   (T&PUSH)
561   (CONST&PUSH 51)                     ; :FROM
563   (CALL 4 7)                          ; LOOP-ADD-BINDING
566   (LOAD&PUSH 1)
567   (PUSH-UNBOUND 1)
569   (CALLS1&JMPIF 94 L575)              ; CONSTANTP
572   (T)
573   (SETVALUE 52)                       ; *NO-DECLARE*
575   L575
575   (CONST&PUSH 11)                     ; SETF
576   (LOAD&PUSH 4)
577   (LOAD&PUSH 7)
578   (LOAD&PUSH 6)
579   (LOAD&PUSH 5)
580   (LIST&PUSH 3)
582   (CONST&PUSH 51)                     ; :FROM
584   (CALL2&PUSH 53)                     ; THE-TYPE
586   (LIST 3)
588   (STORE 6)
589   (LOAD&JMPIF 2 L413)
593   (GETVALUE 52)                       ; *NO-DECLARE*
595   (JMPIF L671)
598   (GETVALUE 62)                       ; *TYPE-CHECK*
600   (JMPIFNOT L671)
603   (GETVALUE&PUSH 63)                  ; *AUTOMATIC-DECLARATIONS*
605   (CONST&PUSH 51)                     ; :FROM
607   (PUSH-UNBOUND 1)
609   (CALLS2&STORE 133 0)                ; GETF
612   (JMPIFNOT L671)
614   (JMPIFATOM L625)
616   (LOAD&CAR&PUSH 0)
618   (JMPIFNOTEQTO 64 L625)              ; TYPE
621   (LOAD 0)
622   (CDR)
623   (CAR)
624   (STORE 0)
625   L625
625   (LOAD&PUSH 0)
626   (CONST&PUSH 65)                     ; FIXNUM
628   (CALL2&JMPIFNOT 66 L671)            ; SUBTYPEP
631   (LOAD&PUSH 1)
632   (PUSH-UNBOUND 1)
634   (CALLS1&JMPIFNOT 94 L471)           ; CONSTANTP
638   (CONST&PUSH 68)                     ; OR
640   (LOAD&PUSH 6)
641   (JMPIFEQTO 17 L476)                 ; +
645   (CONST&PUSH 58)                     ; >
647   (LOAD&PUSH 5)
648   (CONST&PUSH 70)                     ; #.MOST-NEGATIVE-FIXNUM
650   (LOAD&JMPIF 5 L655)
653   (CONST 55)                          ; 1
655   L655
655   (PUSH)
656   (CALLSR 2 53)                       ; +
659   L659
659   (PUSH)
660   (LIST&PUSH 3)
662   (CONST 71)                          ; ((SLOOP-TYPE-ERROR))
664   (LIST*&PUSH 2)
666   (GETVALUE 72)                       ; *LOOP-INCREMENT*
668   (CONS)
669   (SETVALUE 72)                       ; *LOOP-INCREMENT*
671   L671
671   (SKIP 6)
673   (LOAD&JMPIFNOT 1 L698)
676   L676
676   (CONST&PUSH 73)                     ; AND
678   (LOAD&PUSH 2)
679   (CONST 74)                          ; ((LOCAL-FINISH))
681   (LIST*&PUSH 2)
683   (CALLS1&PUSH 161)                   ; COPY-TREE
685   (GETVALUE 75)                       ; *LOOP-END-TEST*
687   (CONS)
688   (SETVALUE 75)                       ; *LOOP-END-TEST*
690   (LOAD 0)
691   (JMPIFNOT1 L709)
693   (JMP L701)
695   L695
695   (LOAD&JMPIF 1 L676)
698   L698
698   (LOAD 0)
699   (JMPIFNOT1 L709)
701   L701
701   (PUSH)
702   (GETVALUE 72)                       ; *LOOP-INCREMENT*
704   (CONS)
705   (SETVALUE 72)                       ; *LOOP-INCREMENT*
707   (SKIP&RET 6)
709   L709
709   (SKIP&RET 6)


Disassembly of function PARSE-LOOP-FOR-1
(CONST 0) = NIL
(CONST 1) = NIL
0 required arguments
0 optional arguments
Rest parameter
No keyword parameters
3 byte-code instructions:
0     (LOAD 1)
1     (STOREV 0 1)
4     (GO 1 0)


Disassembly of function #:|(DEFUN PARSE-LOOP-MACRO (V TYPE &OPTIONAL ...) ...)-31|
(CONST 0) = PARSE-LOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-MACRO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-MACRO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-MACRO
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-MACRO
(CONST 0) = :SLOOP-FOR
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = "sloop-for macro needs at least one arg"
(CONST 3) = :SLOOP-MACRO
(CONST 4) = :SLOOP-MACRO-ARGS
(CONST 5) = TYPE-ERROR
(CONST 6) = :DATUM
(CONST 7) = :EXPECTED-TYPE
(CONST 8) = (MEMBER :SLOOP-FOR :SLOOP-MACRO)
(CONST 9) = SYSTEM::TYPE-ERROR-STRING
(CONST 10) = TYPE
(CONST 11) = (:SLOOP-FOR :SLOOP-MACRO)
(CONST 12) = SYSTEM::CASE-ERROR-STRING
(CONST 13) = &REST
(CONST 14) = *LOOP-FORM*
(CONST 15) = 0
2 required arguments
1 optional argument
No rest parameter
No keyword parameters
reads special variable: (*LOOP-FORM*)
writes special variable : (*LOOP-FORM*)
98 byte-code instructions:
0     (UNBOUND->NIL 1)
2     (NIL&PUSH)
3     (LOAD&PUSH 4)
4     (LOAD&PUSH 4)
5     (PUSH-UNBOUND 1)
7     (CALLS2&PUSH 132)                   ; GET
9     (NIL&PUSH)
10    (LOAD&PUSH 5)
11    (JMPIFEQTO 0 L43)                   ; :SLOOP-FOR
14    (LOAD&PUSH 5)
15    (JMPIFNOTEQTO 3 L59)                ; :SLOOP-MACRO
18    (LOAD&PUSH 6)
19    (CONST&PUSH 4)                      ; :SLOOP-MACRO-ARGS
20    (PUSH-UNBOUND 1)
22    (CALLS2 132)                        ; GET
24    L24
24    (STORE 0)
25    (CONST&PUSH 13)                     ; &REST
26    (LOAD&PUSH 1)
27    (PUSH-UNBOUND 3)
29    (CALLS1&JMPIF 180 L75)              ; MEMBER
32    (CONST&PUSH 15)                     ; 0
33    (LOAD&PUSH 1)
34    (CALLS2&PUSH 71)                    ; LENGTH
36    (JMP L108)
39    L39
39    (CONST&PUSH 2)                      ; "sloop-for macro needs at least one arg"
40    (CALLSR 0 29)                       ; ERROR
43    L43
43    (LOAD&PUSH 6)
44    (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
45    (PUSH-UNBOUND 1)
47    (CALLS2&PUSH 132)                   ; GET
49    (LOAD 0)
50    (CDR)
51    (JMPIFNOT L39)
53    (LOAD 0)
54    (CDR)
55    (SKIP 1)
57    (JMP L24)
59    L59
59    (CONST&PUSH 5)                      ; TYPE-ERROR
60    (CONST&PUSH 6)                      ; :DATUM
61    (LOAD&PUSH 7)
62    (CONST&PUSH 7)                      ; :EXPECTED-TYPE
63    (CONST&PUSH 8)                      ; (MEMBER :SLOOP-FOR :SLOOP-MACRO)
64    (CALL0 9)                           ; SYSTEM::TYPE-ERROR-STRING
66    (PUSH)
67    (CONST&PUSH 10)                     ; TYPE
68    (CONST&PUSH 11)                     ; (:SLOOP-FOR :SLOOP-MACRO)
69    (CALL2&PUSH 12)                     ; SYSTEM::CASE-ERROR-STRING
71    (LOAD&PUSH 12)
72    (CALLSR 6 30)                       ; SYSTEM::ERROR-OF-TYPE
75    L75
75    (GETVALUE&PUSH 14)                  ; *LOOP-FORM*
77    (NIL)
78    (SETVALUE 14)                       ; *LOOP-FORM*
80    (POP)
81    (JMP L119)
83    L83
83    (LOAD&PUSH 2)
84    (LOAD&PUSH 6)
85    (LOAD 2)
86    (APPLY 1)
88    (JMP L129)
90    L90
90    (LOAD&PUSH 2)
91    (LOAD 1)
92    (APPLY 0)
94    (JMP L129)
96    L96
96    (GETVALUE 14)                       ; *LOOP-FORM*
98    (CAR&PUSH)
99    (LOAD&CONS&STORE 4)
101   (GETVALUE 14)                       ; *LOOP-FORM*
103   (CDR)
104   (SETVALUE 14)                       ; *LOOP-FORM*
106   (LOAD&INC&STORE 1)
108   L108
108   (LOAD&PUSH 1)
109   (LOAD&PUSH 1)
110   (CALLSR&JMPIFNOT 1 50 L96)          ; >=
114   (LOAD&PUSH 4)
115   (CALLS2 73)                         ; NREVERSE
117   (SKIP 2)
119   L119
119   (PUSH)
120   (LOAD&PUSH 6)
121   (JMPIFEQTO 0 L83)                   ; :SLOOP-FOR
124   (LOAD&PUSH 6)
125   (JMPIFEQTO 3 L90)                   ; :SLOOP-MACRO
128   (NIL)
129   L129
129   (PUSH)
130   (GETVALUE&PUSH 14)                  ; *LOOP-FORM*
132   (CALLSR 2 34)                       ; APPEND
135   (SETVALUE 14)                       ; *LOOP-FORM*
137   (SKIP&RET 8)


Disassembly of function #:|(DEFUN PARSE-LOOP-MAP (V VAR) ...)-32|
(CONST 0) = PARSE-LOOP-MAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PARSE-LOOP-MAP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PARSE-LOOP-MAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PARSE-LOOP-MAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PARSE-LOOP-MAP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PARSE-LOOP-MAP
8     (SKIP&RET 1)


Disassembly of function PARSE-LOOP-MAP
(CONST 0) = *LOOP-MAP*
(CONST 1) = "Sorry only one allowed loop-map per sloop"
(CONST 2) = :SLOOP-MAP
(CONST 3) = :SLOOP-MAP-ARGS
(CONST 4) = "map needs one arg before the key word"
(CONST 5) = &REST
(CONST 6) = "Build this in two steps if you want &rest"
(CONST 7) = 0
(CONST 8) = *LOOP-FORM*
(CONST 9) = LOOP-POP
(CONST 10) = DECLARE
(CONST 11) = L-EQUAL
(CONST 12) = LOOP-UN-POP
(CONST 13) = *LOOP-MAP-DECLARES*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-FORM* *LOOP-MAP*)
writes special variables : (*LOOP-MAP* *LOOP-MAP-DECLARES* *LOOP-FORM*)
80 byte-code instructions:
0     (GETVALUE 0)                        ; *LOOP-MAP*
2     (JMPIF L31)
4     (LOAD&PUSH 2)
5     (CONST&PUSH 2)                      ; :SLOOP-MAP
6     (PUSH-UNBOUND 1)
8     (CALLS2&PUSH 132)                   ; GET
10    (LOAD&PUSH 3)
11    (CONST&PUSH 3)                      ; :SLOOP-MAP-ARGS
12    (PUSH-UNBOUND 1)
14    (CALLS2&PUSH 132)                   ; GET
16    (LOAD&JMPIFNOT 0 L34)
19    (CONST&PUSH 5)                      ; &REST
20    (LOAD&PUSH 1)
21    (PUSH-UNBOUND 3)
23    (CALLS1&JMPIFNOT 180 L37)           ; MEMBER
26    (CONST 6)                           ; "Build this in two steps if you want &rest"
27    L27
27    (PUSH)
28    (CALLSR 0 29)                       ; ERROR
31    L31
31    (CONST 1)                           ; "Sorry only one allowed loop-map per sloop"
32    (JMP L27)
34    L34
34    (CONST 4)                           ; "map needs one arg before the key word"
35    (JMP L27)
37    L37
37    (NIL&PUSH)
38    (CONST&PUSH 7)                      ; 0
39    (LOAD&PUSH 2)
40    (CALLS2&PUSH 71)                    ; LENGTH
42    (CALLS2&PUSH 151)                   ; 1-
44    (JMP L58)
46    L46
46    (GETVALUE 8)                        ; *LOOP-FORM*
48    (CAR&PUSH)
49    (LOAD&CONS&STORE 2)
51    (GETVALUE 8)                        ; *LOOP-FORM*
53    (CDR)
54    (SETVALUE 8)                        ; *LOOP-FORM*
56    (LOAD&INC&STORE 1)
58    L58
58    (LOAD&PUSH 1)
59    (LOAD&PUSH 1)
60    (CALLSR&JMPIFNOT 1 50 L46)          ; >=
64    (LOAD&PUSH 2)
65    (CALLS2 73)                         ; NREVERSE
67    (SKIP 1)
69    (STORE 0)
70    (CALL0 9)                           ; LOOP-POP
72    (PUSH)
73    (NIL&PUSH)
74    (JMP L91)
76    L76
76    (CONST&PUSH 10)                     ; DECLARE
77    (LOAD 1)
78    (CONS)
79    (SKIP 2)
81    (JMP L103)
83    L83
83    (CALL0 9)                           ; LOOP-POP
85    (PUSH)
86    (LOAD&CONS&STORE 0)
88    (CALL0 9)                           ; LOOP-POP
90    (STORE 1)
91    L91
91    (LOAD&PUSH 1)
92    (CONST&PUSH 10)                     ; DECLARE
93    (CALL2&JMPIF 11 L83)                ; L-EQUAL
96    (CALL0 12)                          ; LOOP-UN-POP
98    (LOAD&JMPIF 0 L76)
101   (SKIP 2)
103   L103
103   (SETVALUE 13)                       ; *LOOP-MAP-DECLARES*
105   (LOAD&PUSH 3)
106   (LOAD&PUSH 6)
107   (LOAD 2)
108   (APPLY 1)
110   (SETVALUE 0)                        ; *LOOP-MAP*
112   (NIL)
113   (SKIP&RET 7)


Disassembly of function #:|(DEFUN SUBSTITUTE-SLOOP-BODY (INNER-BODY) ...)-33|
(CONST 0) = SUBSTITUTE-SLOOP-BODY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SUBSTITUTE-SLOOP-BODY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUBSTITUTE-SLOOP-BODY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SUBSTITUTE-SLOOP-BODY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SUBSTITUTE-SLOOP-BODY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SUBSTITUTE-SLOOP-BODY
8     (SKIP&RET 1)


Disassembly of function SUBSTITUTE-SLOOP-BODY
(CONST 0) = *LOOP-MAP*
(CONST 1) = PROGN
(CONST 2) = :SLOOP-BODY
(CONST 3) = *LOOP-MAP-DECLARES*
(CONST 4) = :SLOOP-MAP-DECLARES
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LOOP-MAP-DECLARES* *LOOP-MAP*)
21 byte-code instructions:
0     (GETVALUE 0)                        ; *LOOP-MAP*
2     (JMPIFNOT L29)
4     (CONST&PUSH 1)                      ; PROGN
5     (LOAD 2)
6     (CONS&PUSH)
7     (CONST&PUSH 2)                      ; :SLOOP-BODY
8     (GETVALUE&PUSH 0)                   ; *LOOP-MAP*
10    (PUSH-UNBOUND 3)
12    (CALLS1&PUSH 172)                   ; SUBST
14    (LIST 1)
16    (STORE 1)
17    (GETVALUE 3)                        ; *LOOP-MAP-DECLARES*
19    (JMPIFNOT L29)
21    (PUSH)
22    (CONST&PUSH 4)                      ; :SLOOP-MAP-DECLARES
23    (LOAD&PUSH 3)
24    (PUSH-UNBOUND 3)
26    (CALLS1&STORE 172 1)                ; SUBST
29    L29
29    (LOAD 1)
30    (SKIP&RET 2)


Disassembly of function #:|(EVAL-WHEN (COMPILE EVAL LOAD) (DEFUN DEF-LOOP-INTERNAL # ...))-34|
(CONST 0) = DEF-LOOP-INTERNAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEF-LOOP-INTERNAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEF-LOOP-INTERNAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEF-LOOP-INTERNAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEF-LOOP-INTERNAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DEF-LOOP-INTERNAL
8     (SKIP&RET 1)


Disassembly of function DEF-LOOP-INTERNAL
(CONST 0) = :UPCASE
(CONST 1) = *PRINT-CASE*
(CONST 2) = "-SLOOP-"
(CONST 3) = "need more args"
(CONST 4) = "need less args"
(CONST 5) = EVAL-WHEN
(CONST 6) = (LOAD COMPILE EVAL)
(CONST 7) = DEFUN
(CONST 8) = PUSHNEW
(CONST 9) = QUOTE
(CONST 10) = SETF
(CONST 11) = GET
(CONST 12) = "SLOOP-"
(CONST 13) = KEYWORD
(CONST 14) = "SLOOP-"
(CONST 15) = "-ARGS"
4 required arguments
3 optional arguments
No rest parameter
No keyword parameters
115 byte-code instructions:
0     (UNBOUND->NIL 3)
2     (UNBOUND->NIL 2)
4     (UNBOUND->NIL 1)
6     (CONST 0)                           ; :UPCASE
7     (BIND 1)                            ; *PRINT-CASE*
9     (PUSH-UNBOUND 2)
11    (CALLS2&PUSH 117)                   ; MAKE-STRING-OUTPUT-STREAM
13    (LOAD&PUSH 11)
14    (LOAD&PUSH 1)
15    (CALLS1 132)                        ; PRINC
17    (CONST&PUSH 2)                      ; "-SLOOP-"
18    (LOAD&PUSH 1)
19    (PUSH-UNBOUND 2)
21    (CALLS1 137)                        ; WRITE-STRING
23    (LOAD&PUSH 8)
24    (LOAD&PUSH 1)
25    (CALLS1 132)                        ; PRINC
27    (LOAD&PUSH 0)
28    (CALLS2&STORE 118 0)                ; GET-OUTPUT-STREAM-STRING
31    (PUSH-UNBOUND 1)
33    (CALLS1&PUSH 212)                   ; INTERN
35    (LOAD&JMPIFNOT 6 L46)
38    (LOAD&PUSH 10)
39    (CALLS2&PUSH 71)                    ; LENGTH
41    (LOAD&PUSH 7)
42    (CALLSR&JMPIFNOT 1 50 L62)          ; >=
46    L46
46    (LOAD&JMPIFNOT 5 L65)
49    (LOAD&PUSH 10)
50    (CALLS2&PUSH 71)                    ; LENGTH
52    (LOAD&PUSH 6)
53    (CALLSR&JMPIF 1 49 L65)             ; <=
57    (CONST 4)                           ; "need less args"
58    L58
58    (PUSH)
59    (CALLSR 0 29)                       ; ERROR
62    L62
62    (CONST 3)                           ; "need more args"
63    (JMP L58)
65    L65
65    (CONST&PUSH 5)                      ; EVAL-WHEN
66    (CONST&PUSH 6)                      ; (LOAD COMPILE EVAL)
67    (CONST&PUSH 7)                      ; DEFUN
68    (LOAD&PUSH 3)
69    (LOAD&PUSH 14)
70    (LOAD 14)
71    (LIST*&PUSH 3)
73    (LOAD&JMPIFNOT 10 L86)
76    (CONST&PUSH 8)                      ; PUSHNEW
77    (CONST&PUSH 9)                      ; QUOTE
78    (LOAD&PUSH 16)
79    (LIST&PUSH 2)
81    (LOAD&PUSH 12)
82    (LIST&PUSH 3)
84    (LIST 1)
86    L86
86    (PUSH)
87    (CONST&PUSH 10)                     ; SETF
88    (CONST&PUSH 11)                     ; GET
89    (CONST&PUSH 9)                      ; QUOTE
90    (LOAD&PUSH 18)
91    (LIST&PUSH 2)
93    (PUSH-UNBOUND 2)
95    (CALLS2&PUSH 117)                   ; MAKE-STRING-OUTPUT-STREAM
97    (CONST&PUSH 12)                     ; "SLOOP-"
98    (LOAD&PUSH 1)
99    (PUSH-UNBOUND 2)
101   (CALLS1 137)                        ; WRITE-STRING
103   (LOAD&PUSH 16)
104   (LOAD&PUSH 1)
105   (CALLS1 132)                        ; PRINC
107   (LOAD&PUSH 0)
108   (CALLS2&STORE 118 0)                ; GET-OUTPUT-STREAM-STRING
111   (CONST&PUSH 13)                     ; KEYWORD
112   (CALLS1&PUSH 204)                   ; FIND-PACKAGE
114   (CALLS1&PUSH 212)                   ; INTERN
116   (LIST&PUSH 3)
118   (CONST&PUSH 9)                      ; QUOTE
119   (LOAD&PUSH 7)
120   (LIST&PUSH 2)
122   (LIST&PUSH 3)
124   (CONST&PUSH 10)                     ; SETF
125   (CONST&PUSH 11)                     ; GET
126   (CONST&PUSH 9)                      ; QUOTE
127   (LOAD&PUSH 19)
128   (LIST&PUSH 2)
130   (PUSH-UNBOUND 2)
132   (CALLS2&PUSH 117)                   ; MAKE-STRING-OUTPUT-STREAM
134   (CONST&PUSH 14)                     ; "SLOOP-"
135   (LOAD&PUSH 1)
136   (PUSH-UNBOUND 2)
138   (CALLS1 137)                        ; WRITE-STRING
140   (LOAD&PUSH 17)
141   (LOAD&PUSH 1)
142   (CALLS1 132)                        ; PRINC
144   (CONST&PUSH 15)                     ; "-ARGS"
145   (LOAD&PUSH 1)
146   (PUSH-UNBOUND 2)
148   (CALLS1 137)                        ; WRITE-STRING
150   (LOAD&PUSH 0)
151   (CALLS2&STORE 118 0)                ; GET-OUTPUT-STREAM-STRING
154   (CONST&PUSH 13)                     ; KEYWORD
155   (CALLS1&PUSH 204)                   ; FIND-PACKAGE
157   (CALLS1&PUSH 212)                   ; INTERN
159   (LIST&PUSH 3)
161   (CONST&PUSH 9)                      ; QUOTE
162   (LOAD&PUSH 18)
163   (LIST&PUSH 2)
165   (LIST&PUSH 3)
167   (LIST&PUSH 2)
169   (CALLSR 2 34)                       ; APPEND
172   (LIST* 3)
174   (SKIP 1)
176   (UNBIND1)
177   (SKIP&RET 8)


Disassembly of function #:|(DEF-LOOP-COLLECT SUM (ANS VAL) ...)-35-1|
(CONST 0) = SUM-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SUM-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUM-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SUM-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SUM-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function SUM-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (0)
(CONST 3) = DO
(CONST 4) = +
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
15 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (0)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 1)                      ; SETQ
8     (LOAD&PUSH 6)
9     (CONST&PUSH 4)                      ; +
10    (LOAD&PUSH 8)
11    (LOAD&PUSH 8)
12    (LIST&PUSH 3)
14    (LIST&PUSH 3)
16    (LIST 4)
18    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT SUM (ANS VAL) ...)-35-2|
(CONST 0) = SUM
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUM
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT SUM (ANS VAL) ...)-35-3|
(CONST 0) = SUM
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = SUM-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUM
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; SUM-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT SUM (ANS VAL) ...)-35-4|
(CONST 0) = SUM
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; SUM
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT LOGXOR (ANS VAL) ...)-36-1|
(CONST 0) = LOGXOR-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGXOR-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGXOR-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGXOR-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGXOR-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function LOGXOR-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETF
(CONST 2) = (0)
(CONST 3) = DO
(CONST 4) = LOGXOR
(CONST 5) = DECLARE
(CONST 6) = FIXNUM
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
20 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETF
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (0)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 1)                      ; SETF
8     (LOAD&PUSH 6)
9     (CONST&PUSH 4)                      ; LOGXOR
10    (LOAD&PUSH 8)
11    (LOAD&PUSH 8)
12    (LIST&PUSH 3)
14    (LIST&PUSH 3)
16    (CONST&PUSH 5)                      ; DECLARE
17    (CONST&PUSH 6)                      ; FIXNUM
18    (LOAD&PUSH 8)
19    (LOAD&PUSH 8)
20    (LIST&PUSH 3)
22    (LIST 6)
24    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT LOGXOR (ANS VAL) ...)-36-2|
(CONST 0) = LOGXOR
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGXOR
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT LOGXOR (ANS VAL) ...)-36-3|
(CONST 0) = LOGXOR
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = LOGXOR-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGXOR
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; LOGXOR-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT LOGXOR (ANS VAL) ...)-36-4|
(CONST 0) = LOGXOR
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGXOR
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MAXIMIZE (ANS VAL) ...)-37-1|
(CONST 0) = MAXIMIZE-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAXIMIZE-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAXIMIZE-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAXIMIZE-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAXIMIZE-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function MAXIMIZE-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (NIL)
(CONST 3) = DO
(CONST 4) = IF
(CONST 5) = SETF
(CONST 6) = MAX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
22 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (NIL)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 4)                      ; IF
8     (LOAD&PUSH 6)
9     (CONST&PUSH 5)                      ; SETF
10    (LOAD&PUSH 8)
11    (CONST&PUSH 6)                      ; MAX
12    (LOAD&PUSH 10)
13    (LOAD&PUSH 10)
14    (LIST&PUSH 3)
16    (LIST&PUSH 3)
18    (CONST&PUSH 5)                      ; SETF
19    (LOAD&PUSH 9)
20    (LOAD&PUSH 9)
21    (LIST&PUSH 3)
23    (LIST&PUSH 4)
25    (LIST 4)
27    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT MAXIMIZE (ANS VAL) ...)-37-2|
(CONST 0) = MAXIMIZE
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAXIMIZE
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MAXIMIZE (ANS VAL) ...)-37-3|
(CONST 0) = MAXIMIZE
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = MAXIMIZE-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAXIMIZE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; MAXIMIZE-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MAXIMIZE (ANS VAL) ...)-37-4|
(CONST 0) = MAXIMIZE
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAXIMIZE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MINIMIZE (ANS VAL) ...)-38-1|
(CONST 0) = MINIMIZE-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MINIMIZE-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MINIMIZE-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MINIMIZE-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MINIMIZE-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function MINIMIZE-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (NIL)
(CONST 3) = DO
(CONST 4) = IF
(CONST 5) = SETF
(CONST 6) = MIN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
22 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (NIL)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 4)                      ; IF
8     (LOAD&PUSH 6)
9     (CONST&PUSH 5)                      ; SETF
10    (LOAD&PUSH 8)
11    (CONST&PUSH 6)                      ; MIN
12    (LOAD&PUSH 10)
13    (LOAD&PUSH 10)
14    (LIST&PUSH 3)
16    (LIST&PUSH 3)
18    (CONST&PUSH 5)                      ; SETF
19    (LOAD&PUSH 9)
20    (LOAD&PUSH 9)
21    (LIST&PUSH 3)
23    (LIST&PUSH 4)
25    (LIST 4)
27    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT MINIMIZE (ANS VAL) ...)-38-2|
(CONST 0) = MINIMIZE
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MINIMIZE
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MINIMIZE (ANS VAL) ...)-38-3|
(CONST 0) = MINIMIZE
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = MINIMIZE-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; MINIMIZE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; MINIMIZE-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT MINIMIZE (ANS VAL) ...)-38-4|
(CONST 0) = MINIMIZE
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; MINIMIZE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT COUNT (ANS VAL) ...)-39-1|
(CONST 0) = COUNT-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COUNT-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COUNT-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COUNT-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COUNT-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function COUNT-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (0)
(CONST 3) = DO
(CONST 4) = AND
(CONST 5) = SETF
(CONST 6) = 1+
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
17 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (0)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 4)                      ; AND
8     (LOAD&PUSH 5)
9     (CONST&PUSH 5)                      ; SETF
10    (LOAD&PUSH 8)
11    (CONST&PUSH 6)                      ; 1+
12    (LOAD&PUSH 10)
13    (LIST&PUSH 2)
15    (LIST&PUSH 3)
17    (LIST&PUSH 3)
19    (LIST 4)
21    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT COUNT (ANS VAL) ...)-39-2|
(CONST 0) = COUNT
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COUNT
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT COUNT (ANS VAL) ...)-39-3|
(CONST 0) = COUNT
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = COUNT-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; COUNT
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; COUNT-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT COUNT (ANS VAL) ...)-39-4|
(CONST 0) = COUNT
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; COUNT
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT THEREIS (ANS VAL) ...)-40-1|
(CONST 0) = THEREIS-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE THEREIS-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; THEREIS-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; THEREIS-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE THEREIS-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function THEREIS-SLOOP-COLLECT
(CONST 0) = DO
(CONST 1) = IF
(CONST 2) = LOOP-RETURN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
9 byte-code instructions:
0     (CONST&PUSH 0)                      ; DO
1     (CONST&PUSH 1)                      ; IF
2     (LOAD&PUSH 3)
3     (CONST&PUSH 2)                      ; LOOP-RETURN
4     (LOAD&PUSH 5)
5     (LIST&PUSH 2)
7     (LIST&PUSH 3)
9     (LIST 2)
11    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT THEREIS (ANS VAL) ...)-40-2|
(CONST 0) = THEREIS
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; THEREIS
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT THEREIS (ANS VAL) ...)-40-3|
(CONST 0) = THEREIS
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = THEREIS-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; THEREIS
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; THEREIS-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT THEREIS (ANS VAL) ...)-40-4|
(CONST 0) = THEREIS
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; THEREIS
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT ALWAYS (ANS VAL) ...)-41-1|
(CONST 0) = ALWAYS-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ALWAYS-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ALWAYS-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ALWAYS-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ALWAYS-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function ALWAYS-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (T)
(CONST 3) = DO
(CONST 4) = AND
(CONST 5) = NULL
(CONST 6) = ((LOOP-RETURN NIL))
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (T)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 4)                      ; AND
8     (CONST&PUSH 5)                      ; NULL
9     (LOAD&PUSH 6)
10    (LIST&PUSH 2)
12    (CONST 6)                           ; ((LOOP-RETURN NIL))
13    (LIST*&PUSH 2)
15    (LIST 4)
17    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT ALWAYS (ANS VAL) ...)-41-2|
(CONST 0) = ALWAYS
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ALWAYS
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT ALWAYS (ANS VAL) ...)-41-3|
(CONST 0) = ALWAYS
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = ALWAYS-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; ALWAYS
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; ALWAYS-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT ALWAYS (ANS VAL) ...)-41-4|
(CONST 0) = ALWAYS
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; ALWAYS
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT NEVER (ANS VAL) ...)-42-1|
(CONST 0) = NEVER-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NEVER-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NEVER-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NEVER-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NEVER-SLOOP-COLLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function NEVER-SLOOP-COLLECT
(CONST 0) = INITIALLY
(CONST 1) = SETQ
(CONST 2) = (T)
(CONST 3) = DO
(CONST 4) = AND
(CONST 5) = ((LOOP-RETURN NIL))
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
12 byte-code instructions:
0     (CONST&PUSH 0)                      ; INITIALLY
1     (CONST&PUSH 1)                      ; SETQ
2     (LOAD&PUSH 4)
3     (CONST 2)                           ; (T)
4     (LIST*&PUSH 2)
6     (CONST&PUSH 3)                      ; DO
7     (CONST&PUSH 4)                      ; AND
8     (LOAD&PUSH 5)
9     (CONST 5)                           ; ((LOOP-RETURN NIL))
10    (LIST*&PUSH 2)
12    (LIST 4)
14    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT NEVER (ANS VAL) ...)-42-2|
(CONST 0) = NEVER
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NEVER
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT NEVER (ANS VAL) ...)-42-3|
(CONST 0) = NEVER
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = NEVER-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; NEVER
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; NEVER-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT NEVER (ANS VAL) ...)-42-4|
(CONST 0) = NEVER
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; NEVER
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO AVERAGING (X) ...)-43-1|
(CONST 0) = AVERAGING-SLOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE AVERAGING-SLOOP-MACRO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; AVERAGING-SLOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; AVERAGING-SLOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE AVERAGING-SLOOP-MACRO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function AVERAGING-SLOOP-MACRO
(CONST 0) = WITH-UNIQUE
(CONST 1) = .AVERAGE.
(CONST 2) = =
(CONST 3) = 0.0
(CONST 4) = AND
(CONST 5) = .N-TO-AVERAGE.
(CONST 6) = 0
(CONST 7) = DECLARE
(CONST 8) = (FLOAT .AVERAGE.)
(CONST 9) = (FIXNUM .N-TO-AVERAGE.)
(CONST 10) = DO
(CONST 11) = SETF
(CONST 12) = /
(CONST 13) = +
(CONST 14) = (* .N-TO-AVERAGE. .AVERAGE.)
(CONST 15) = ((INCF .N-TO-AVERAGE.))
(CONST 16) = (FINALLY (LOOP-RETURN .AVERAGE.))
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
27 byte-code instructions:
0     (CONST&PUSH 0)                      ; WITH-UNIQUE
1     (CONST&PUSH 1)                      ; .AVERAGE.
2     (CONST&PUSH 2)                      ; =
3     (CONST&PUSH 3)                      ; 0.0
4     (CONST&PUSH 4)                      ; AND
5     (CONST&PUSH 0)                      ; WITH-UNIQUE
6     (CONST&PUSH 5)                      ; .N-TO-AVERAGE.
7     (CONST&PUSH 2)                      ; =
8     (CONST&PUSH 6)                      ; 0
9     (CONST&PUSH 7)                      ; DECLARE
10    (CONST&PUSH 8)                      ; (FLOAT .AVERAGE.)
11    (CONST&PUSH 7)                      ; DECLARE
12    (CONST&PUSH 9)                      ; (FIXNUM .N-TO-AVERAGE.)
13    (CONST&PUSH 10)                     ; DO
14    (CONST&PUSH 11)                     ; SETF
15    (CONST&PUSH 1)                      ; .AVERAGE.
16    (CONST&PUSH 12)                     ; /
17    (CONST&PUSH 13)                     ; +
18    (CONST&PUSH 14)                     ; (* .N-TO-AVERAGE. .AVERAGE.)
19    (LOAD&PUSH 20)
20    (LIST&PUSH 3)
22    (CONST 15)                          ; ((INCF .N-TO-AVERAGE.))
23    (LIST*&PUSH 2)
25    (LIST&PUSH 3)
27    (CONST 16)                          ; (FINALLY (LOOP-RETURN .AVERAGE.))
28    (LIST* 15)
30    (SKIP&RET 2)


Disassembly of function #:|(DEF-LOOP-MACRO AVERAGING (X) ...)-43-2|
(CONST 0) = AVERAGING
(CONST 1) = :SLOOP-MACRO
(CONST 2) = AVERAGING-SLOOP-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; AVERAGING
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO
2     (CONST&PUSH 2)                      ; AVERAGING-SLOOP-MACRO
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO AVERAGING (X) ...)-43-3|
(CONST 0) = AVERAGING
(CONST 1) = :SLOOP-MACRO-ARGS
(CONST 2) = (X)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; AVERAGING
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO-ARGS
2     (CONST&PUSH 2)                      ; (X)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO REPEAT (X) ...)-44-1|
(CONST 0) = REPEAT-SLOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REPEAT-SLOOP-MACRO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REPEAT-SLOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REPEAT-SLOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REPEAT-SLOOP-MACRO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function REPEAT-SLOOP-MACRO
(CONST 0) = FOR
(CONST 1) = BELOW
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (PUSH-UNBOUND 1)
2     (CALLS2&PUSH 143)                   ; GENSYM
4     (CONST&PUSH 0)                      ; FOR
5     (LOAD&PUSH 1)
6     (CONST&PUSH 1)                      ; BELOW
7     (LOAD&PUSH 5)
8     (LIST 4)
10    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-MACRO REPEAT (X) ...)-44-2|
(CONST 0) = REPEAT
(CONST 1) = :SLOOP-MACRO
(CONST 2) = REPEAT-SLOOP-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; REPEAT
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO
2     (CONST&PUSH 2)                      ; REPEAT-SLOOP-MACRO
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO REPEAT (X) ...)-44-3|
(CONST 0) = REPEAT
(CONST 1) = :SLOOP-MACRO-ARGS
(CONST 2) = (X)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; REPEAT
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO-ARGS
2     (CONST&PUSH 2)                      ; (X)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO RETURN (X) ...)-45-1|
(CONST 0) = RETURN-SLOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RETURN-SLOOP-MACRO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RETURN-SLOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RETURN-SLOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RETURN-SLOOP-MACRO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function RETURN-SLOOP-MACRO
(CONST 0) = DO
(CONST 1) = LOOP-RETURN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; DO
1     (CONST&PUSH 1)                      ; LOOP-RETURN
2     (LOAD&PUSH 3)
3     (LIST&PUSH 2)
5     (LIST 2)
7     (SKIP&RET 2)


Disassembly of function #:|(DEF-LOOP-MACRO RETURN (X) ...)-45-2|
(CONST 0) = RETURN
(CONST 1) = :SLOOP-MACRO
(CONST 2) = RETURN-SLOOP-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; RETURN
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO
2     (CONST&PUSH 2)                      ; RETURN-SLOOP-MACRO
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO RETURN (X) ...)-45-3|
(CONST 0) = RETURN
(CONST 1) = :SLOOP-MACRO-ARGS
(CONST 2) = (X)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; RETURN
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO-ARGS
2     (CONST&PUSH 2)                      ; (X)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MAP IN-TABLE (VAR TABLE) ...)-46-1|
(CONST 0) = IN-TABLE-SLOOP-MAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IN-TABLE-SLOOP-MAP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-TABLE-SLOOP-MAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-TABLE-SLOOP-MAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IN-TABLE-SLOOP-MAP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function IN-TABLE-SLOOP-MAP
(CONST 0) = MAPHASH
(CONST 1) = FUNCTION
(CONST 2) = LAMBDA
(CONST 3) = (:SLOOP-MAP-DECLARES :SLOOP-BODY)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAPHASH
1     (CONST&PUSH 1)                      ; FUNCTION
2     (CONST&PUSH 2)                      ; LAMBDA
3     (LOAD&PUSH 5)
4     (CONST 3)                           ; (:SLOOP-MAP-DECLARES :SLOOP-BODY)
5     (LIST*&PUSH 2)
7     (LIST&PUSH 2)
9     (LOAD&PUSH 3)
10    (LIST 3)
12    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-MAP IN-TABLE (VAR TABLE) ...)-46-2|
(CONST 0) = IN-TABLE
(CONST 1) = :SLOOP-MAP
(CONST 2) = IN-TABLE-SLOOP-MAP
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-TABLE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP
2     (CONST&PUSH 2)                      ; IN-TABLE-SLOOP-MAP
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MAP IN-TABLE (VAR TABLE) ...)-46-3|
(CONST 0) = IN-TABLE
(CONST 1) = :SLOOP-MAP-ARGS
(CONST 2) = (VAR TABLE)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-TABLE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP-ARGS
2     (CONST&PUSH 2)                      ; (VAR TABLE)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MAP IN-PACKAGE (VAR PKG) ...)-47-1|
(CONST 0) = IN-PACKAGE-SLOOP-MAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IN-PACKAGE-SLOOP-MAP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-PACKAGE-SLOOP-MAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-PACKAGE-SLOOP-MAP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IN-PACKAGE-SLOOP-MAP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function IN-PACKAGE-SLOOP-MAP
(CONST 0) = DO-SYMBOLS
(CONST 1) = FIND-PACKAGE
(CONST 2) = (:SLOOP-BODY)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
9 byte-code instructions:
0     (CONST&PUSH 0)                      ; DO-SYMBOLS
1     (LOAD&PUSH 3)
2     (CONST&PUSH 1)                      ; FIND-PACKAGE
3     (LOAD&PUSH 4)
4     (LIST&PUSH 2)
6     (LIST&PUSH 2)
8     (CONST 2)                           ; (:SLOOP-BODY)
9     (LIST* 2)
11    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-MAP IN-PACKAGE (VAR PKG) ...)-47-2|
(CONST 0) = IN-PACKAGE
(CONST 1) = :SLOOP-MAP
(CONST 2) = IN-PACKAGE-SLOOP-MAP
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-PACKAGE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP
2     (CONST&PUSH 2)                      ; IN-PACKAGE-SLOOP-MAP
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MAP IN-PACKAGE (VAR PKG) ...)-47-3|
(CONST 0) = IN-PACKAGE
(CONST 1) = :SLOOP-MAP-ARGS
(CONST 2) = (VAR PKG)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-PACKAGE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP-ARGS
2     (CONST&PUSH 2)                      ; (VAR PKG)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR IN-ARRAY (VARS ARRAY &REST ...) ...)-48-1|
(CONST 0) = IN-ARRAY-SLOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE IN-ARRAY-SLOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-ARRAY-SLOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-ARRAY-SLOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE IN-ARRAY-SLOOP-FOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function IN-ARRAY-SLOOP-FOR
(CONST 0) = "INDEX"
(CONST 1) = TRANSLATE-NAME
(CONST 2) = (FROM DOWNFROM)
(CONST 3) = L-EQUAL
(CONST 4) = (TO BELOW ABOVE)
(CONST 5) = BY
(CONST 6) = BELOW
(CONST 7) = LENGTH
(CONST 8) = FOR
(CONST 9) = WITH
(CONST 10) = DO
(CONST 11) = SETF
(CONST 12) = AREF
2 required arguments
0 optional arguments
Rest parameter
No keyword parameters
77 byte-code instructions:
0     (PUSH-NIL 3)
2     (LOAD&PUSH 6)
3     (CALLS2&JMPIF 11 L16)               ; LISTP
6     (LOAD 6)
7     (STORE 2)
8     (CONST&PUSH 0)                      ; "INDEX"
9     (CALLS2&STORE 143 1)                ; GENSYM
12    L12
12    (LOAD&PUSH 4)
13    (NIL&PUSH)
14    (JMP L42)
16    L16
16    (LOAD&CAR&STORE 6 2)
19    (LOAD 6)
20    (CDR)
21    (CAR)
22    (STORE 1)
23    (JMP L12)
25    L25
25    (T&STORE 3)
27    L27
27    (SKIP 1)
29    (LOAD&CAR&PUSH 1)
31    (LOAD&CONS&STORE 0)
33    (LOAD 1)
34    (CDR)
35    (CAR&PUSH)
36    (LOAD&CONS&STORE 0)
38    (LOAD 1)
39    (CDR)
40    (CDR)
41    (STORE 1)
42    L42
42    (LOAD&CAR&PUSH 1)
44    (CALL1&PUSH 1)                      ; TRANSLATE-NAME
46    (LOAD&PUSH 0)
47    (CONST&PUSH 2)                      ; (FROM DOWNFROM)
48    (CALL2&JMPIF 3 L27)                 ; L-EQUAL
51    (LOAD&PUSH 0)
52    (CONST&PUSH 4)                      ; (TO BELOW ABOVE)
53    (CALL2&JMPIF 3 L25)                 ; L-EQUAL
56    (LOAD&PUSH 0)
57    (CONST&PUSH 5)                      ; BY
58    (CALL2&JMPIF 3 L27)                 ; L-EQUAL
61    (LOAD&PUSH 2)
62    (CALLS1&STORE 158 7)                ; COPY-LIST
65    (LOAD&PUSH 1)
66    (CALLS2 73)                         ; NREVERSE
68    (SKIP 2)
70    (STORE 0)
71    (LOAD&JMPIF 1 L86)
74    (CONST&PUSH 6)                      ; BELOW
75    (CONST&PUSH 7)                      ; LENGTH
76    (LOAD&PUSH 8)
77    (LIST&PUSH 2)
79    (LIST&PUSH 2)
81    (LOAD&PUSH 1)
82    (CALLSR&STORE 2 35 0)               ; NCONC
86    L86
86    (CONST&PUSH 8)                      ; FOR
87    (LOAD&PUSH 3)
88    (LOAD&PUSH 2)
89    (CONST&PUSH 9)                      ; WITH
90    (LOAD&PUSH 7)
91    (CONST&PUSH 10)                     ; DO
92    (CONST&PUSH 11)                     ; SETF
93    (LOAD&PUSH 10)
94    (CONST&PUSH 12)                     ; AREF
95    (LOAD&PUSH 15)
96    (LOAD&PUSH 12)
97    (LIST&PUSH 3)
99    (LIST&PUSH 3)
101   (LOAD 12)
102   (LIST*&PUSH 4)
104   (CALLSR 2 34)                       ; APPEND
107   (LIST* 2)
109   (SKIP&RET 8)


Disassembly of function #:|(DEF-LOOP-FOR IN-ARRAY (VARS ARRAY &REST ...) ...)-48-2|
(CONST 0) = IN-ARRAY
(CONST 1) = :SLOOP-FOR
(CONST 2) = IN-ARRAY-SLOOP-FOR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-ARRAY
1     (CONST&PUSH 1)                      ; :SLOOP-FOR
2     (CONST&PUSH 2)                      ; IN-ARRAY-SLOOP-FOR
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR IN-ARRAY (VARS ARRAY &REST ...) ...)-48-3|
(CONST 0) = IN-ARRAY
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = (VARS ARRAY &REST ARGS)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-ARRAY
1     (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
2     (CONST&PUSH 2)                      ; (VARS ARRAY &REST ARGS)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR = (VAR VAL) ...)-49-1|
(CONST 0) = =-SLOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE =-SLOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; =-SLOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; =-SLOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE =-SLOOP-FOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function =-SLOOP-FOR
(CONST 0) = LOOP-PEEK
(CONST 1) = TRANSLATE-NAME
(CONST 2) = THEN
(CONST 3) = L-EQUAL
(CONST 4) = LOOP-POP
(CONST 5) = WITH
(CONST 6) = INITIALLY
(CONST 7) = DESETQ
(CONST 8) = INCREMENT
(CONST 9) = DO
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
32 byte-code instructions:
0     (CALL0 0)                           ; LOOP-PEEK
2     (PUSH)
3     (CALL1&PUSH 1)                      ; TRANSLATE-NAME
5     (LOAD&PUSH 0)
6     (CONST&PUSH 2)                      ; THEN
7     (CALL2&JMPIF 3 L22)                 ; L-EQUAL
10    (CONST&PUSH 5)                      ; WITH
11    (LOAD&PUSH 4)
12    (CONST&PUSH 9)                      ; DO
13    (CONST&PUSH 7)                      ; DESETQ
14    (LOAD&PUSH 7)
15    (LOAD&PUSH 7)
16    (LIST&PUSH 3)
18    (LIST 4)
20    (SKIP&RET 4)
22    L22
22    (CALL0 4)                           ; LOOP-POP
24    (CONST&PUSH 5)                      ; WITH
25    (LOAD&PUSH 4)
26    (CONST&PUSH 6)                      ; INITIALLY
27    (CONST&PUSH 7)                      ; DESETQ
28    (LOAD&PUSH 7)
29    (LOAD&PUSH 7)
30    (LIST&PUSH 3)
32    (CONST&PUSH 8)                      ; INCREMENT
33    (CONST&PUSH 7)                      ; DESETQ
34    (LOAD&PUSH 9)
35    (CALL0 4)                           ; LOOP-POP
37    (PUSH)
38    (LIST&PUSH 3)
40    (LIST 6)
42    (SKIP&RET 4)


Disassembly of function #:|(DEF-LOOP-FOR = (VAR VAL) ...)-49-2|
(CONST 0) = =
(CONST 1) = :SLOOP-FOR
(CONST 2) = =-SLOOP-FOR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; =
1     (CONST&PUSH 1)                      ; :SLOOP-FOR
2     (CONST&PUSH 2)                      ; =-SLOOP-FOR
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR = (VAR VAL) ...)-49-3|
(CONST 0) = =
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = (VAR VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; =
1     (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
2     (CONST&PUSH 2)                      ; (VAR VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO SLOOP (FOR-LOOP) ...)-50-1|
(CONST 0) = SLOOP-SLOOP-MACRO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SLOOP-SLOOP-MACRO>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP-SLOOP-MACRO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SLOOP-SLOOP-MACRO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SLOOP-SLOOP-MACRO>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function SLOOP-SLOOP-MACRO
(CONST 0) = TRANSLATE-NAME
(CONST 1) = FOR
(CONST 2) = L-EQUAL
(CONST 3) = "lcase fell off end ~a  "
(CONST 4) = "FINISH"
(CONST 5) = *LOOP-FORM*
(CONST 6) = *INNER-SLOOP*
(CONST 7) = *LOOP-BODY*
(CONST 8) = *LOOP-MAP*
(CONST 9) = *PRODUCT-FOR*
(CONST 10) = LOOP-POP
(CONST 11) = *LOOP-BINDINGS*
(CONST 12) = *LOOP-PROLOGUE*
(CONST 13) = *LOOP-EPILOGUE*
(CONST 14) = *LOOP-END-TEST*
(CONST 15) = *LOOP-INCREMENT*
(CONST 16) = PARSE-LOOP-FOR
(CONST 17) = COLLECT
(CONST 18) = PARSE-LOOP1
(CONST 19) = PARSE-LOOP-COLLECT
(CONST 20) = SUBSTITUTE-SLOOP-BODY
(CONST 21) = MACROLET
(CONST 22) = LOCAL-FINISH
(CONST 23) = SYSTEM::BACKQUOTE
(CONST 24) = GO
(CONST 25) = QUOTE
(CONST 26) = TAGBODY
(CONST 27) = (NEXT-LOOP)
(CONST 28) = ((GO NEXT-LOOP))
(CONST 29) = LET
(CONST 30) = LOOP-LET-BINDINGS
(CONST 31) = DECLARE
(CONST 32) = DO
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(*LOOP-MAP* *LOOP-BODY* *LOOP-FORM* *INNER-SLOOP* *LOOP-INCREMENT*
 *LOOP-END-TEST* *LOOP-EPILOGUE* *LOOP-PROLOGUE* *LOOP-BINDINGS*)
writes special variables : 
(*INNER-SLOOP* *LOOP-INCREMENT* *LOOP-END-TEST* *LOOP-EPILOGUE* *LOOP-PROLOGUE*
 *LOOP-BINDINGS* *PRODUCT-FOR*)
365 byte-code instructions:
0     (LOAD&CAR&PUSH 1)
2     (CALL1&PUSH 0)                      ; TRANSLATE-NAME
4     (LOAD&PUSH 0)
5     (CONST&PUSH 1)                      ; FOR
6     (CALL2&JMPIFNOT 2 L320)             ; L-EQUAL
10    (SKIP 1)
12    (PUSH-NIL 4)
14    (CONST&PUSH 4)                      ; "FINISH"
15    (CALLS2&PUSH 143)                   ; GENSYM
17    (PUSH-NIL 5)
19    (LOAD 11)
20    (BIND 5)                            ; *LOOP-FORM*
22    (LOAD 12)
23    (BIND 6)                            ; *INNER-SLOOP*
25    (LOAD 14)
26    (BIND 7)                            ; *LOOP-BODY*
28    (LOAD 16)
30    (BIND 8)                            ; *LOOP-MAP*
32    (T)
33    (SETVALUE 9)                        ; *PRODUCT-FOR*
35    (CALL0 10)                          ; LOOP-POP
37    (LOAD&PUSH 16)
38    (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
40    (LOAD 0)
41    (STORE 18)
43    (LOAD 1)
44    (SETVALUE 11)                       ; *LOOP-BINDINGS*
46    (SKIP 2)
48    (LOAD&PUSH 15)
49    (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
51    (LOAD 0)
52    (STORE 17)
54    (LOAD 1)
55    (SETVALUE 12)                       ; *LOOP-PROLOGUE*
57    (SKIP 2)
59    (LOAD&PUSH 14)
60    (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
62    (LOAD 0)
63    (STORE 16)
65    (LOAD 1)
66    (SETVALUE 13)                       ; *LOOP-EPILOGUE*
68    (SKIP 2)
70    (LOAD&PUSH 13)
71    (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
73    (LOAD 0)
74    (STORE 15)
76    (LOAD 1)
77    (SETVALUE 14)                       ; *LOOP-END-TEST*
79    (SKIP 2)
81    (LOAD&PUSH 12)
82    (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
84    (LOAD 0)
85    (STORE 14)
87    (LOAD 1)
88    (SETVALUE 15)                       ; *LOOP-INCREMENT*
90    (SKIP 2)
92    (GETVALUE 6)                        ; *INNER-SLOOP*
94    (NOT)
95    (SETVALUE 6)                        ; *INNER-SLOOP*
97    (CALL0 16)                          ; PARSE-LOOP-FOR
99    (LOAD&PUSH 16)
100   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
102   (LOAD 0)
103   (STORE 18)
105   (LOAD 1)
106   (SETVALUE 11)                       ; *LOOP-BINDINGS*
108   (SKIP 2)
110   (LOAD&PUSH 15)
111   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
113   (LOAD 0)
114   (STORE 17)
116   (LOAD 1)
117   (SETVALUE 12)                       ; *LOOP-PROLOGUE*
119   (SKIP 2)
121   (LOAD&PUSH 14)
122   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
124   (LOAD 0)
125   (STORE 16)
127   (LOAD 1)
128   (SETVALUE 13)                       ; *LOOP-EPILOGUE*
130   (SKIP 2)
132   (LOAD&PUSH 13)
133   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
135   (LOAD 0)
136   (STORE 15)
138   (LOAD 1)
139   (SETVALUE 14)                       ; *LOOP-END-TEST*
141   (SKIP 2)
143   (LOAD&PUSH 12)
144   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
146   (LOAD 0)
147   (STORE 14)
149   (LOAD 1)
150   (SETVALUE 15)                       ; *LOOP-INCREMENT*
152   (SKIP 2)
154   (GETVALUE 6)                        ; *INNER-SLOOP*
156   (NOT)
157   (SETVALUE 6)                        ; *INNER-SLOOP*
159   (GETVALUE 5)                        ; *LOOP-FORM*
161   (JMPIFNOT L333)
164   L164
164   (CONST 17)                          ; COLLECT
165   (CATCH-OPEN L325)
168   (CALL0 18)                          ; PARSE-LOOP1
170   (CATCH-CLOSE)
171   (JMPIF L328)
174   L174
174   (GETVALUE 5)                        ; *LOOP-FORM*
176   (JMPIFNOT L333)
179   (GETVALUE&PUSH 5)                   ; *LOOP-FORM*
181   (PUSH-UNBOUND 1)
183   (CALLS1 130)                        ; PRINT
185   (LOAD&PUSH 16)
186   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
188   (LOAD 0)
189   (STORE 18)
191   (LOAD 1)
192   (SETVALUE 11)                       ; *LOOP-BINDINGS*
194   (SKIP 2)
196   (LOAD&PUSH 15)
197   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
199   (LOAD 0)
200   (STORE 17)
202   (LOAD 1)
203   (SETVALUE 12)                       ; *LOOP-PROLOGUE*
205   (SKIP 2)
207   (LOAD&PUSH 14)
208   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
210   (LOAD 0)
211   (STORE 16)
213   (LOAD 1)
214   (SETVALUE 13)                       ; *LOOP-EPILOGUE*
216   (SKIP 2)
218   (LOAD&PUSH 13)
219   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
221   (LOAD 0)
222   (STORE 15)
224   (LOAD 1)
225   (SETVALUE 14)                       ; *LOOP-END-TEST*
227   (SKIP 2)
229   (LOAD&PUSH 12)
230   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
232   (LOAD 0)
233   (STORE 14)
235   (LOAD 1)
236   (SETVALUE 15)                       ; *LOOP-INCREMENT*
238   (SKIP 2)
240   (GETVALUE 6)                        ; *INNER-SLOOP*
242   (NOT)
243   (SETVALUE 6)                        ; *INNER-SLOOP*
245   (CALL0 19)                          ; PARSE-LOOP-COLLECT
247   (LOAD&PUSH 16)
248   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
250   (LOAD 0)
251   (STORE 18)
253   (LOAD 1)
254   (SETVALUE 11)                       ; *LOOP-BINDINGS*
256   (SKIP 2)
258   (LOAD&PUSH 15)
259   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
261   (LOAD 0)
262   (STORE 17)
264   (LOAD 1)
265   (SETVALUE 12)                       ; *LOOP-PROLOGUE*
267   (SKIP 2)
269   (LOAD&PUSH 14)
270   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
272   (LOAD 0)
273   (STORE 16)
275   (LOAD 1)
276   (SETVALUE 13)                       ; *LOOP-EPILOGUE*
278   (SKIP 2)
280   (LOAD&PUSH 13)
281   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
283   (LOAD 0)
284   (STORE 15)
286   (LOAD 1)
287   (SETVALUE 14)                       ; *LOOP-END-TEST*
289   (SKIP 2)
291   (LOAD&PUSH 12)
292   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
294   (LOAD 0)
295   (STORE 14)
297   (LOAD 1)
298   (SETVALUE 15)                       ; *LOOP-INCREMENT*
300   (SKIP 2)
302   (GETVALUE 6)                        ; *INNER-SLOOP*
304   (NOT)
305   (SETVALUE 6)                        ; *INNER-SLOOP*
307   (GETVALUE&PUSH 5)                   ; *LOOP-FORM*
309   (PUSH-UNBOUND 1)
311   (CALLS1 130)                        ; PRINT
313   (GETVALUE 5)                        ; *LOOP-FORM*
315   (JMPIFNOT L333)
317   (JMP L164)
320   L320
320   (CONST&PUSH 3)                      ; "lcase fell off end ~a  "
321   (LOAD&PUSH 1)
322   (CALLSR 1 29)                       ; ERROR
325   L325
325   (JMPIFNOT L174)
328   L328
328   (GETVALUE 5)                        ; *LOOP-FORM*
330   (JMPIF L164)
333   L333
333   (LOAD&PUSH 16)
334   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
336   (LOAD 0)
337   (STORE 18)
339   (LOAD 1)
340   (SETVALUE 11)                       ; *LOOP-BINDINGS*
342   (SKIP 2)
344   (LOAD&PUSH 15)
345   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
347   (LOAD 0)
348   (STORE 17)
350   (LOAD 1)
351   (SETVALUE 12)                       ; *LOOP-PROLOGUE*
353   (SKIP 2)
355   (LOAD&PUSH 14)
356   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
358   (LOAD 0)
359   (STORE 16)
361   (LOAD 1)
362   (SETVALUE 13)                       ; *LOOP-EPILOGUE*
364   (SKIP 2)
366   (LOAD&PUSH 13)
367   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
369   (LOAD 0)
370   (STORE 15)
372   (LOAD 1)
373   (SETVALUE 14)                       ; *LOOP-END-TEST*
375   (SKIP 2)
377   (LOAD&PUSH 12)
378   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
380   (LOAD 0)
381   (STORE 14)
383   (LOAD 1)
384   (SETVALUE 15)                       ; *LOOP-INCREMENT*
386   (SKIP 2)
388   (GETVALUE 6)                        ; *INNER-SLOOP*
390   (NOT)
391   (SETVALUE 6)                        ; *INNER-SLOOP*
393   (GETVALUE&PUSH 7)                   ; *LOOP-BODY*
395   (CALLS2&STORE 73 18)                ; NREVERSE
398   (GETVALUE 8)                        ; *LOOP-MAP*
400   (JMPIFNOT L407)
402   (LOAD&PUSH 18)
403   (CALL1 20)                          ; SUBSTITUTE-SLOOP-BODY
405   (STORE 18)
407   L407
407   (CONST&PUSH 21)                     ; MACROLET
408   (CONST&PUSH 22)                     ; LOCAL-FINISH
409   (NIL&PUSH)
410   (CONST&PUSH 23)                     ; SYSTEM::BACKQUOTE
411   (CONST&PUSH 24)                     ; GO
412   (LOAD&PUSH 22)
413   (LIST&PUSH 2)
415   (CONST&PUSH 25)                     ; QUOTE
416   (CONST&PUSH 24)                     ; GO
417   (LOAD&PUSH 24)
418   (LIST&PUSH 2)
420   (LIST&PUSH 2)
422   (LIST&PUSH 3)
424   (LIST&PUSH 3)
426   (LIST&PUSH 1)
428   (CONST&PUSH 26)                     ; TAGBODY
429   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
431   (CALLS2&PUSH 73)                    ; NREVERSE
433   (GETVALUE 8)                        ; *LOOP-MAP*
435   (NOT)
436   (JMPIFNOT L440)
438   (CONST 27)                          ; (NEXT-LOOP)
440   L440
440   (PUSH)
441   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
443   (CALLS2&PUSH 73)                    ; NREVERSE
445   (LOAD&PUSH 24)
446   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
448   (CALLS2&PUSH 73)                    ; NREVERSE
450   (GETVALUE 8)                        ; *LOOP-MAP*
452   (NOT)
453   (JMPIFNOT L457)
455   (CONST 28)                          ; ((GO NEXT-LOOP))
457   L457
457   (PUSH)
458   (LOAD&PUSH 26)
460   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
462   (CALLS2 73)                         ; NREVERSE
464   (CONS&PUSH)
465   (CALLSR 7 34)                       ; APPEND
468   (CONS&PUSH)
469   (LIST&PUSH 3)
471   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
473   (NIL&PUSH)
474   (JMP L506)
476   L476
476   (LOAD&CAR&STORE 1 0)
479   (CONST&PUSH 29)                     ; LET
480   (LOAD&PUSH 1)
481   (CALL1&PUSH 30)                     ; LOOP-LET-BINDINGS
483   (LOAD 2)
484   (CDR)
485   (JMPIFNOT L494)
487   (CONST&PUSH 31)                     ; DECLARE
489   (LOAD 3)
490   (CDR)
491   (CONS&PUSH)
492   (LIST 1)
494   L494
494   (PUSH)
495   (LOAD&PUSH 5)
496   (LIST&PUSH 1)
498   (CALLSR 2 34)                       ; APPEND
501   (LIST* 2)
503   (STORE 2)
504   (LOAD&CDR&STORE 1)
506   L506
506   (LOAD&PUSH 1)
507   (CALLS1&JMPIFNOT 146 L476)          ; ENDP
510   (SKIP 2)
512   (LOAD&PUSH 17)
513   (GETVALUE&PUSH 11)                  ; *LOOP-BINDINGS*
515   (LOAD 0)
516   (STORE 19)
518   (LOAD 1)
519   (SETVALUE 11)                       ; *LOOP-BINDINGS*
521   (SKIP 2)
523   (LOAD&PUSH 16)
524   (GETVALUE&PUSH 12)                  ; *LOOP-PROLOGUE*
526   (LOAD 0)
527   (STORE 18)
529   (LOAD 1)
530   (SETVALUE 12)                       ; *LOOP-PROLOGUE*
532   (SKIP 2)
534   (LOAD&PUSH 15)
535   (GETVALUE&PUSH 13)                  ; *LOOP-EPILOGUE*
537   (LOAD 0)
538   (STORE 17)
540   (LOAD 1)
541   (SETVALUE 13)                       ; *LOOP-EPILOGUE*
543   (SKIP 2)
545   (LOAD&PUSH 14)
546   (GETVALUE&PUSH 14)                  ; *LOOP-END-TEST*
548   (LOAD 0)
549   (STORE 16)
551   (LOAD 1)
552   (SETVALUE 14)                       ; *LOOP-END-TEST*
554   (SKIP 2)
556   (LOAD&PUSH 13)
557   (GETVALUE&PUSH 15)                  ; *LOOP-INCREMENT*
559   (LOAD 0)
560   (STORE 15)
562   (LOAD 1)
563   (SETVALUE 15)                       ; *LOOP-INCREMENT*
565   (SKIP 2)
567   (GETVALUE 6)                        ; *INNER-SLOOP*
569   (NOT)
570   (SETVALUE 6)                        ; *INNER-SLOOP*
572   (CONST&PUSH 32)                     ; DO
574   (LOAD&PUSH 1)
575   (LIST 2)
577   (SKIP 1)
579   (UNBIND 4)
581   (SKIP&RET 12)


Disassembly of function #:|(DEF-LOOP-MACRO SLOOP (FOR-LOOP) ...)-50-2|
(CONST 0) = SLOOP
(CONST 1) = :SLOOP-MACRO
(CONST 2) = SLOOP-SLOOP-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO
2     (CONST&PUSH 2)                      ; SLOOP-SLOOP-MACRO
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MACRO SLOOP (FOR-LOOP) ...)-50-3|
(CONST 0) = SLOOP
(CONST 1) = :SLOOP-MACRO-ARGS
(CONST 2) = (FOR-LOOP)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; SLOOP
1     (CONST&PUSH 1)                      ; :SLOOP-MACRO-ARGS
2     (CONST&PUSH 2)                      ; (FOR-LOOP)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR IN-CAREFULLY (VAR LIS) ...)-51-1|
(CONST 0) = IN-CAREFULLY-SLOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = "Path with var in lis except lis may end with a non nil cdr"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE IN-CAREFULLY-SLOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-CAREFULLY-SLOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-CAREFULLY-SLOOP-FOR
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Path with var in lis except lis may end with a non nil cdr"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; IN-CAREFULLY-SLOOP-FOR
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE IN-CAREFULLY-SLOOP-FOR>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (VALUES0)
14    (SKIP&RET 1)


Disassembly of function IN-CAREFULLY-SLOOP-FOR
(CONST 0) = "POINT"
(CONST 1) = WITH
(CONST 2) = AND
(CONST 3) = INITIALLY
(CONST 4) = SETF
(CONST 5) = DO
(CONST 6) = DESETQ
(CONST 7) = CAR
(CONST 8) = END-TEST
(CONST 9) = ATOM
(CONST 10) = ((LOCAL-FINISH))
(CONST 11) = INCREMENT
(CONST 12) = CDR
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
35 byte-code instructions:
0     (CONST&PUSH 0)                      ; "POINT"
1     (CALLS2&PUSH 143)                   ; GENSYM
3     (CONST&PUSH 1)                      ; WITH
4     (LOAD&PUSH 1)
5     (CONST&PUSH 2)                      ; AND
6     (CONST&PUSH 1)                      ; WITH
7     (LOAD&PUSH 7)
8     (CONST&PUSH 3)                      ; INITIALLY
9     (CONST&PUSH 4)                      ; SETF
10    (LOAD&PUSH 7)
11    (LOAD&PUSH 10)
12    (LIST&PUSH 3)
14    (CONST&PUSH 5)                      ; DO
15    (CONST&PUSH 6)                      ; DESETQ
16    (LOAD&PUSH 12)
17    (CONST&PUSH 7)                      ; CAR
18    (LOAD&PUSH 11)
19    (LIST&PUSH 2)
21    (LIST&PUSH 3)
23    (CONST&PUSH 8)                      ; END-TEST
24    (CONST&PUSH 2)                      ; AND
25    (CONST&PUSH 9)                      ; ATOM
26    (LOAD&PUSH 12)
27    (LIST&PUSH 2)
29    (CONST 10)                          ; ((LOCAL-FINISH))
30    (LIST*&PUSH 2)
32    (CONST&PUSH 11)                     ; INCREMENT
33    (CONST&PUSH 4)                      ; SETF
34    (LOAD&PUSH 13)
35    (CONST&PUSH 12)                     ; CDR
36    (LOAD&PUSH 15)
37    (LIST&PUSH 2)
39    (LIST&PUSH 3)
41    (LIST 13)
43    (SKIP&RET 4)


Disassembly of function #:|(DEF-LOOP-FOR IN-CAREFULLY (VAR LIS) ...)-51-2|
(CONST 0) = IN-CAREFULLY
(CONST 1) = :SLOOP-FOR
(CONST 2) = IN-CAREFULLY-SLOOP-FOR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-CAREFULLY
1     (CONST&PUSH 1)                      ; :SLOOP-FOR
2     (CONST&PUSH 2)                      ; IN-CAREFULLY-SLOOP-FOR
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR IN-CAREFULLY (VAR LIS) ...)-51-3|
(CONST 0) = IN-CAREFULLY
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = (VAR LIS)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-CAREFULLY
1     (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
2     (CONST&PUSH 2)                      ; (VAR LIS)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR FIRST-USE (VAR EXPR1 THEN ...) ...)-52-1|
(CONST 0) = FIRST-USE-SLOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FIRST-USE-SLOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST-USE-SLOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FIRST-USE-SLOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FIRST-USE-SLOOP-FOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function FIRST-USE-SLOOP-FOR
(CONST 0) = THEN
(CONST 1) = L-EQUAL
(CONST 2) = "First must be followed by then"
(CONST 3) = WITH
(CONST 4) = INITIALLY
(CONST 5) = DESETQ
(CONST 6) = INCREMENT
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
20 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CONST&PUSH 0)                      ; THEN
2     (CALL2&JMPIFNOT 1 L23)              ; L-EQUAL
5     (CONST&PUSH 3)                      ; WITH
6     (LOAD&PUSH 5)
7     (CONST&PUSH 4)                      ; INITIALLY
8     (CONST&PUSH 5)                      ; DESETQ
9     (LOAD&PUSH 8)
10    (LOAD&PUSH 8)
11    (LIST&PUSH 3)
13    (CONST&PUSH 6)                      ; INCREMENT
14    (CONST&PUSH 5)                      ; DESETQ
15    (LOAD&PUSH 10)
16    (LOAD&PUSH 8)
17    (LIST&PUSH 3)
19    (LIST 6)
21    (SKIP&RET 5)
23    L23
23    (CONST&PUSH 2)                      ; "First must be followed by then"
24    (CALLSR 0 29)                       ; ERROR


Disassembly of function #:|(DEF-LOOP-FOR FIRST-USE (VAR EXPR1 THEN ...) ...)-52-2|
(CONST 0) = FIRST-USE
(CONST 1) = :SLOOP-FOR
(CONST 2) = FIRST-USE-SLOOP-FOR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST-USE
1     (CONST&PUSH 1)                      ; :SLOOP-FOR
2     (CONST&PUSH 2)                      ; FIRST-USE-SLOOP-FOR
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR FIRST-USE (VAR EXPR1 THEN ...) ...)-52-3|
(CONST 0) = FIRST-USE
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = (VAR EXPR1 THEN EXPR2)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST-USE
1     (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
2     (CONST&PUSH 2)                      ; (VAR EXPR1 THEN EXPR2)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)

WARNING in FIRST-SLOOP-FOR in lines 1139..1154 :
*LOOP-INCREMENT* is neither declared nor bound,
it will be treated as if it were declared SPECIAL.

Disassembly of function #:|(DEF-LOOP-FOR FIRST (VAR EXPR1 THEN ...) ...)-53-1|
(CONST 0) = FIRST-SLOOP-FOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FIRST-SLOOP-FOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST-SLOOP-FOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FIRST-SLOOP-FOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FIRST-SLOOP-FOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function FIRST-SLOOP-FOR
(CONST 0) = THEN
(CONST 1) = L-EQUAL
(CONST 2) = "First must be followed by then"
(CONST 3) = *LOOP-INCREMENT*
(CONST 4) = WITH
(CONST 5) = INITIALLY
(CONST 6) = DESETQ
(CONST 7) = INCREMENT
(CONST 8) = DO
(CONST 9) = COND
(CONST 10) = (T)
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*LOOP-INCREMENT*)
51 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CONST&PUSH 0)                      ; THEN
2     (CALL2&JMPIFNOT 1 L47)              ; L-EQUAL
5     (GETVALUE 3)                        ; *LOOP-INCREMENT*
7     (JMPIFNOT L51)
9     (PUSH-UNBOUND 1)
11    (CALLS2&PUSH 143)                   ; GENSYM
13    (CONST&PUSH 4)                      ; WITH
14    (LOAD&PUSH 6)
15    (CONST&PUSH 4)                      ; WITH
16    (LOAD&PUSH 3)
17    (CONST&PUSH 8)                      ; DO
18    (CONST&PUSH 9)                      ; COND
19    (LOAD&PUSH 6)
20    (CONST&PUSH 6)                      ; DESETQ
21    (LOAD&PUSH 13)
22    (LOAD&PUSH 11)
23    (LIST&PUSH 3)
25    (LIST&PUSH 2)
27    (T&PUSH)
28    (CONST&PUSH 6)                      ; DESETQ
29    (LOAD&PUSH 14)
30    (LOAD&PUSH 14)
31    (LIST&PUSH 3)
33    (LIST&PUSH 2)
35    (LIST&PUSH 3)
37    (CONST&PUSH 7)                      ; INCREMENT
38    (CONST&PUSH 6)                      ; DESETQ
39    (LOAD&PUSH 8)
40    (CONST 10)                          ; (T)
41    (LIST*&PUSH 2)
43    (LIST 8)
45    (SKIP&RET 6)
47    L47
47    (CONST&PUSH 2)                      ; "First must be followed by then"
48    (CALLSR 0 29)                       ; ERROR
51    L51
51    (CONST&PUSH 4)                      ; WITH
52    (LOAD&PUSH 5)
53    (CONST&PUSH 5)                      ; INITIALLY
54    (CONST&PUSH 6)                      ; DESETQ
55    (LOAD&PUSH 8)
56    (LOAD&PUSH 8)
57    (LIST&PUSH 3)
59    (CONST&PUSH 7)                      ; INCREMENT
60    (CONST&PUSH 6)                      ; DESETQ
61    (LOAD&PUSH 10)
62    (LOAD&PUSH 8)
63    (LIST&PUSH 3)
65    (LIST 6)
67    (SKIP&RET 5)


Disassembly of function #:|(DEF-LOOP-FOR FIRST (VAR EXPR1 THEN ...) ...)-53-2|
(CONST 0) = FIRST
(CONST 1) = :SLOOP-FOR
(CONST 2) = FIRST-SLOOP-FOR
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST
1     (CONST&PUSH 1)                      ; :SLOOP-FOR
2     (CONST&PUSH 2)                      ; FIRST-SLOOP-FOR
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-FOR FIRST (VAR EXPR1 THEN ...) ...)-53-3|
(CONST 0) = FIRST
(CONST 1) = :SLOOP-FOR-ARGS
(CONST 2) = (VAR EXPR1 THEN EXPR2)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIRST
1     (CONST&PUSH 1)                      ; :SLOOP-FOR-ARGS
2     (CONST&PUSH 2)                      ; (VAR EXPR1 THEN EXPR2)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEFVAR *COLLATE-ORDER* #'<)-54|
(CONST 0) = (SPECIAL *COLLATE-ORDER*)
(CONST 1) = *COLLATE-ORDER*
(CONST 2) = #.#'<
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *COLLATE-ORDER*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *COLLATE-ORDER*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *COLLATE-ORDER*
8     (CONST&PUSH 2)                      ; #.#'<
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST 1)                           ; *COLLATE-ORDER*
12    (SKIP&RET 1)


Disassembly of function #:|(DEFUN FIND-IN-ORDERED-LIST (IT LIST &OPTIONAL ...) ...)-55|
(CONST 0) = FIND-IN-ORDERED-LIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FIND-IN-ORDERED-LIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FIND-IN-ORDERED-LIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FIND-IN-ORDERED-LIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FIND-IN-ORDERED-LIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FIND-IN-ORDERED-LIST
8     (SKIP&RET 1)


Disassembly of function FIND-IN-ORDERED-LIST
(CONST 0) = *COLLATE-ORDER*
2 required arguments
1 optional argument
No rest parameter
No keyword parameters
reads special variable: (*COLLATE-ORDER*)
32 byte-code instructions:
0     (JMPIFBOUNDP 1 L6)
3     (GETVALUE 0)                        ; *COLLATE-ORDER*
5     (STORE 1)
6     L6
6     (NIL&PUSH)
7     (LOAD&PUSH 3)
8     (LOAD&JMPIFNOT 0 L32)
11    L11
11    (LOAD&CAR&PUSH 0)
13    (LOAD&PUSH 6)
14    (CALLS2&JMPIF 1 L39)                ; EQL
17    (LOAD&PUSH 3)
18    (LOAD&PUSH 6)
19    (LOAD&CAR&PUSH 2)
21    (FUNCALL 2)
23    (JMPIF L32)
25    (LOAD 0)
26    (STORE 1)
27    (CDR)
28    (STORE 0)
29    (LOAD&JMPIF 0 L11)
32    L32
32    (LOAD&PUSH 1)
33    (NIL)
34    L34
34    (PUSH)
35    (STACK-TO-MV 2)
37    (SKIP&RET 6)
39    L39
39    (LOAD&PUSH 0)
40    (T)
41    (JMP L34)


Disassembly of function #:|(DEF-LOOP-COLLECT COLLATE (ANS VAL) ...)-56-1|
(CONST 0) = COLLATE-SLOOP-COLLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = 
"Collects values into a sorted list without duplicates.
Order based order function *collate-order*"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE COLLATE-SLOOP-COLLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; COLLATE-SLOOP-COLLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COLLATE-SLOOP-COLLECT
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Collects values into a sorted list without duplicates.
Order based order function *collate-order*"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; COLLATE-SLOOP-COLLECT
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE COLLATE-SLOOP-COLLECT>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (VALUES0)
14    (SKIP&RET 1)


Disassembly of function COLLATE-SLOOP-COLLECT
(CONST 0) = DO
(CONST 1) = MULTIPLE-VALUE-BIND
(CONST 2) = (AFTER ALREADY-THERE)
(CONST 3) = FIND-IN-ORDERED-LIST
(CONST 4) = UNLESS
(CONST 5) = ALREADY-THERE
(CONST 6) = COND
(CONST 7) = AFTER
(CONST 8) = SETF
(CONST 9) = (CDR AFTER)
(CONST 10) = CONS
(CONST 11) = ((CDR AFTER))
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
33 byte-code instructions:
0     (CONST&PUSH 0)                      ; DO
1     (CONST&PUSH 1)                      ; MULTIPLE-VALUE-BIND
2     (CONST&PUSH 2)                      ; (AFTER ALREADY-THERE)
3     (CONST&PUSH 3)                      ; FIND-IN-ORDERED-LIST
4     (LOAD&PUSH 5)
5     (LOAD&PUSH 7)
6     (LIST&PUSH 3)
8     (CONST&PUSH 4)                      ; UNLESS
9     (CONST&PUSH 5)                      ; ALREADY-THERE
10    (CONST&PUSH 6)                      ; COND
11    (CONST&PUSH 7)                      ; AFTER
12    (CONST&PUSH 8)                      ; SETF
13    (CONST&PUSH 9)                      ; (CDR AFTER)
14    (CONST&PUSH 10)                     ; CONS
15    (LOAD&PUSH 12)
16    (CONST 11)                          ; ((CDR AFTER))
17    (LIST*&PUSH 2)
19    (LIST&PUSH 3)
21    (LIST&PUSH 2)
23    (T&PUSH)
24    (CONST&PUSH 8)                      ; SETF
25    (LOAD&PUSH 12)
26    (CONST&PUSH 10)                     ; CONS
27    (LOAD&PUSH 13)
28    (LOAD&PUSH 15)
29    (LIST&PUSH 3)
31    (LIST&PUSH 3)
33    (LIST&PUSH 2)
35    (LIST&PUSH 3)
37    (LIST&PUSH 3)
39    (LIST&PUSH 4)
41    (LIST 2)
43    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-COLLECT COLLATE (ANS VAL) ...)-56-2|
(CONST 0) = COLLATE
(CONST 1) = *ADDITIONAL-COLLECTIONS*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*ADDITIONAL-COLLECTIONS*)
writes special variable : (*ADDITIONAL-COLLECTIONS*)
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COLLATE
1     (GETVALUE&PUSH 1)                   ; *ADDITIONAL-COLLECTIONS*
3     (PUSH-UNBOUND 3)
5     (CALLS1 184)                        ; ADJOIN
7     (SETVALUE 1)                        ; *ADDITIONAL-COLLECTIONS*
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT COLLATE (ANS VAL) ...)-56-3|
(CONST 0) = COLLATE
(CONST 1) = :SLOOP-COLLECT
(CONST 2) = COLLATE-SLOOP-COLLECT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; COLLATE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT
2     (CONST&PUSH 2)                      ; COLLATE-SLOOP-COLLECT
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-COLLECT COLLATE (ANS VAL) ...)-56-4|
(CONST 0) = COLLATE
(CONST 1) = :SLOOP-COLLECT-ARGS
(CONST 2) = (ANS VAL)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; COLLATE
1     (CONST&PUSH 1)                      ; :SLOOP-COLLECT-ARGS
2     (CONST&PUSH 2)                      ; (ANS VAL)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DEFUN MAP-FRINGE (FUN TREE) ...)-57|
(CONST 0) = MAP-FRINGE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAP-FRINGE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAP-FRINGE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAP-FRINGE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAP-FRINGE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAP-FRINGE
8     (SKIP&RET 1)


Disassembly of function MAP-FRINGE
(CONST 0) = DONE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
27 byte-code instructions:
0     L0
0     (LOAD&PUSH 1)
1     (JMP L21)
3     L3
3     (LOAD&PUSH 3)
4     (LOAD&CAR&PUSH 1)
6     (FUNCALL 1)
8     (JMP L19)
10    L10
10    (LOAD 0)
11    (CAR)
12    (JMPIFATOM L3)
14    (LOAD&PUSH 3)
15    (LOAD&CAR&PUSH 1)
17    (JSR L0)
19    L19
19    (LOAD&CDR&STORE 0)
21    L21
21    (LOAD 0)
22    (JMPIFCONSP L10)
24    (LOAD&JMPIFNOT 0 L31)
27    (LOAD&PUSH 3)
28    (LOAD&PUSH 1)
29    (FUNCALL 1)
31    L31
31    (CONST 0)                           ; DONE
32    (SKIP&RET 4)


Disassembly of function #:|(DEF-LOOP-MAP IN-FRINGE (VAR TREE) ...)-58-1|
(CONST 0) = IN-FRINGE-SLOOP-MAP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = "Map over the non nil atoms in the fringe of tree"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE IN-FRINGE-SLOOP-MAP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-FRINGE-SLOOP-MAP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; IN-FRINGE-SLOOP-MAP
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Map over the non nil atoms in the fringe of tree"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; IN-FRINGE-SLOOP-MAP
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE IN-FRINGE-SLOOP-MAP>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (VALUES0)
14    (SKIP&RET 1)


Disassembly of function IN-FRINGE-SLOOP-MAP
(CONST 0) = MAP-FRINGE
(CONST 1) = FUNCTION
(CONST 2) = LAMBDA
(CONST 3) = (:SLOOP-MAP-DECLARES :SLOOP-BODY)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAP-FRINGE
1     (CONST&PUSH 1)                      ; FUNCTION
2     (CONST&PUSH 2)                      ; LAMBDA
3     (LOAD&PUSH 5)
4     (LIST&PUSH 1)
6     (CONST 3)                           ; (:SLOOP-MAP-DECLARES :SLOOP-BODY)
7     (LIST*&PUSH 2)
9     (LIST&PUSH 2)
11    (LOAD&PUSH 3)
12    (LIST 3)
14    (SKIP&RET 3)


Disassembly of function #:|(DEF-LOOP-MAP IN-FRINGE (VAR TREE) ...)-58-2|
(CONST 0) = IN-FRINGE
(CONST 1) = :SLOOP-MAP
(CONST 2) = IN-FRINGE-SLOOP-MAP
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-FRINGE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP
2     (CONST&PUSH 2)                      ; IN-FRINGE-SLOOP-MAP
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (VALUES0)
6     (SKIP&RET 1)


Disassembly of function #:|(DEF-LOOP-MAP IN-FRINGE (VAR TREE) ...)-58-3|
(CONST 0) = IN-FRINGE
(CONST 1) = :SLOOP-MAP-ARGS
(CONST 2) = (VAR TREE)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; IN-FRINGE
1     (CONST&PUSH 1)                      ; :SLOOP-MAP-ARGS
2     (CONST&PUSH 2)                      ; (VAR TREE)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Wrote file binary-clisp/sloop.fas
Wrote file /cygdrive/e/temp/maxima/src/sloop.lis