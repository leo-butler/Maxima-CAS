Listing of compilation of file /cygdrive/e/temp/maxima/src/csimp2.lisp
on 2002-12-17 13:33:16 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/csimp2.lisp ...

Disassembly of function #:|(IN-PACKAGE "MAXIMA")-1|
(CONST 0) = "MAXIMA"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "MAXIMA"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(MACSYMA-MODULE CSIMP2)-2|
(CONST 0) = CSIMP2
(CONST 1) = MACSYMA-MODULE
(CONST 2) = (RUNTIME)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; CSIMP2
1     (CONST&PUSH 1)                      ; MACSYMA-MODULE
2     (CONST&PUSH 2)                      ; (RUNTIME)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(LOAD-MACSYMA-MACROS RZMAC)-3|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (GENPREFIX C/#))-4|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE PLOG) (SPECIAL VAR %P%I ...))-5|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN SIMPPLOG (X VESTIGIAL Z) ...)-6|
(CONST 0) = SIMPPLOG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPPLOG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPPLOG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPPLOG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPPLOG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPPLOG
8     (SKIP&RET 1)


Disassembly of function SIMPPLOG
(CONST 0) = X
(CONST 1) = VARLIST
(CONST 2) = Y
(CONST 3) = ONEARGCHECK
(CONST 4) = SIMPCHECK
(CONST 5) = 0
(CONST 6) = "PLOG(0) is undefined"
(CONST 7) = MERROR
(CONST 8) = VAR
(CONST 9) = AMONG
(CONST 10) = (%PLOG)
(CONST 11) = EQTEST
(CONST 12) = NEWVAR
(CONST 13) = $%I
(CONST 14) = #.#'ATOM
(CONST 15) = ORMAPC
(CONST 16) = TRISPLIT
(CONST 17) = PATAN
(CONST 18) = (%LOG)
(CONST 19) = (MEXPT)
(CONST 20) = (MPLUS)
(CONST 21) = (MEXPT)
(CONST 22) = 2
(CONST 23) = (MEXPT)
(CONST 24) = $EXPAND
(CONST 25) = ((RAT) 1 2)
(CONST 26) = 1
(CONST 27) = SIMPEXPT
(CONST 28) = SIMPLN
(CONST 29) = (MTIMES)
(CONST 30) = ADD2*
(CONST 31) = FREE
(CONST 32) = $SIGN
(CONST 33) = $PNZ
(CONST 34) = (%PLOG)
(CONST 35) = $IMAGPART
(CONST 36) = $ASKSIGN
(CONST 37) = $POS
(CONST 38) = (%LOG)
(CONST 39) = PLOGABS
(CONST 40) = $NEG
(CONST 41) = (%LOG)
(CONST 42) = (MTIMES)
(CONST 43) = -1
(CONST 44) = %P%I
(CONST 45) = (%LOG)
(CONST 46) = (MTIMES)
(CONST 47) = ADD2
(CONST 48) = "PLOG(0) is undefined"
(CONST 49) = DIV*
(CONST 50) = $ZERO
(CONST 51) = "PLOG(0) is undefined"
(CONST 52) = (%LOG)
(CONST 53) = (MTIMES)
(CONST 54) = (MTIMES)
(CONST 55) = ((RAT) 1 2)
(CONST 56) = $%PI
(CONST 57) = (%PLOG)
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (%P%I PLOGABS Y VAR VARLIST X)
writes special variables : (Y X)
199 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; X
3     (NIL)
4     (BIND 1)                            ; VARLIST
6     (PUSH-NIL 2)
8     (NIL)
9     (BIND 2)                            ; Y
11    (GETVALUE&PUSH 0)                   ; X
13    (CALL1 3)                           ; ONEARGCHECK
15    (GETVALUE 0)                        ; X
17    (STORE 3)
18    (CDR)
19    (CAR&PUSH)
20    (LOAD&PUSH 13)
21    (CALL2 4)                           ; SIMPCHECK
23    (SETVALUE 0)                        ; X
25    (PUSH)
26    (JMPIFNOTEQTO 5 L119)               ; 0
30    (CONST&PUSH 6)                      ; "PLOG(0) is undefined"
31    (CALL1 7)                           ; MERROR
33    L33
33    (GETVALUE&PUSH 0)                   ; X
35    (CALL1 12)                          ; NEWVAR
37    (GETVALUE 1)                        ; VARLIST
39    (CAR&PUSH)
40    (JMPIFNOTEQTO 13 L51)               ; $%I
43    (CONST&PUSH 14)                     ; #.#'ATOM
44    (GETVALUE 1)                        ; VARLIST
46    (CDR&PUSH)
47    (CALL2&JMPIFNOT 15 L130)            ; ORMAPC
51    L51
51    (GETVALUE&PUSH 0)                   ; X
53    (CONST&PUSH 13)                     ; $%I
54    (CALL2&JMPIFNOT 31 L65)             ; FREE
57    (GETVALUE&PUSH 0)                   ; X
59    (CALL1&PUSH 32)                     ; $SIGN
61    (JMPIFEQTO 33 L186)                 ; $PNZ
65    L65
65    (GETVALUE&PUSH 0)                   ; X
67    (CALL1&PUSH 35)                     ; $IMAGPART
69    (JMPIFNOTEQTO 5 L81)                ; 0
72    (GETVALUE&PUSH 0)                   ; X
74    (CALL1 36)                          ; $ASKSIGN
76    (SETVALUE 2)                        ; Y
78    (JMPIF L201)
81    L81
81    (GETVALUE&PUSH 0)                   ; X
83    (CONST&PUSH 13)                     ; $%I
84    (CALL2 49)                          ; DIV*
86    (STORE 12)
88    (PUSH)
89    (CALL1&PUSH 35)                     ; $IMAGPART
91    (JMPIFNOTEQTO 5 L102)               ; 0
94    (LOAD&PUSH 12)
95    (CALL1 36)                          ; $ASKSIGN
97    (SETVALUE 2)                        ; Y
99    (JMPIF L275)
102   L102
102   (CONST 57)                          ; (%PLOG)
104   L104
104   (PUSH)
105   (GETVALUE&PUSH 0)                   ; X
107   (LIST&PUSH 2)
109   (LOAD&PUSH 4)
110   (CALL2 11)                          ; EQTEST
112   L112
112   (UNBIND1)
113   (SKIP 2)
115   (UNBIND 2)
117   (SKIP&RET 4)
119   L119
119   (GETVALUE&PUSH 8)                   ; VAR
121   (GETVALUE&PUSH 0)                   ; X
123   (CALL2&JMPIFNOT 9 L33)              ; AMONG
127   (CONST 10)                          ; (%PLOG)
128   (JMP L104)
130   L130
130   (GETVALUE&PUSH 0)                   ; X
132   (CALL1 16)                          ; TRISPLIT
134   (STORE 4)
135   (CAR&PUSH)
136   (LOAD&CDR&PUSH 5)
138   (CALL2 17)                          ; PATAN
140   (STORE 12)
142   (JMPIFNOT L102)
144   (CONST&PUSH 18)                     ; (%LOG)
145   (CONST&PUSH 19)                     ; (MEXPT)
146   (CONST&PUSH 20)                     ; (MPLUS)
147   (CONST&PUSH 21)                     ; (MEXPT)
148   (LOAD&CAR&PUSH 8)
150   (CONST&PUSH 22)                     ; 2
151   (LIST&PUSH 3)
153   (CONST&PUSH 23)                     ; (MEXPT)
154   (LOAD&CDR&PUSH 9)
156   (CONST&PUSH 22)                     ; 2
157   (LIST&PUSH 3)
159   (LIST&PUSH 3)
161   (CALL1&PUSH 24)                     ; $EXPAND
163   (CONST&PUSH 25)                     ; ((RAT) 1 2)
164   (LIST&PUSH 3)
166   (CONST&PUSH 26)                     ; 1
167   (NIL&PUSH)
168   (CALL&PUSH 3 27)                    ; SIMPEXPT
171   (LIST&PUSH 2)
173   (CONST&PUSH 26)                     ; 1
174   (T&PUSH)
175   (CALL&PUSH 3 28)                    ; SIMPLN
178   (CONST&PUSH 29)                     ; (MTIMES)
179   (LOAD&PUSH 14)
180   (CONST&PUSH 13)                     ; $%I
181   (LIST 3)
183   (JMP L321)
186   L186
186   (CONST 34)                          ; (%PLOG)
188   (JMP L104)
191   L191
191   (CONST&PUSH 38)                     ; (%LOG)
193   (GETVALUE&PUSH 0)                   ; X
195   (LIST&PUSH 2)
197   (CONST&PUSH 26)                     ; 1
198   (T)
199   (JMP L229)
201   L201
201   (GETVALUE&PUSH 2)                   ; Y
203   (JMPIFEQTO 37 L191)                 ; $POS
206   (GETVALUE 39)                       ; PLOGABS
208   (JMPIFNOT L260)
210   (GETVALUE&PUSH 2)                   ; Y
212   (JMPIFNOTEQTO 40 L260)              ; $NEG
215   (CONST&PUSH 41)                     ; (%LOG)
217   (CONST&PUSH 42)                     ; (MTIMES)
219   (CONST&PUSH 43)                     ; -1
221   (GETVALUE&PUSH 0)                   ; X
223   (LIST&PUSH 3)
225   (LIST&PUSH 2)
227   (CONST&PUSH 26)                     ; 1
228   (NIL)
229   L229
229   (PUSH)
230   (CALL 3 28)                         ; SIMPLN
233   (JMP L112)
236   L236
236   (GETVALUE&PUSH 44)                  ; %P%I
238   (CONST&PUSH 45)                     ; (%LOG)
240   (CONST&PUSH 46)                     ; (MTIMES)
242   (CONST&PUSH 43)                     ; -1
244   (GETVALUE&PUSH 0)                   ; X
246   (LIST&PUSH 3)
248   (LIST&PUSH 2)
250   (CONST&PUSH 26)                     ; 1
251   (NIL&PUSH)
252   (CALL&PUSH 3 28)                    ; SIMPLN
255   (CALL2 47)                          ; ADD2
257   (JMP L112)
260   L260
260   (GETVALUE&PUSH 2)                   ; Y
262   (JMPIFEQTO 40 L236)                 ; $NEG
265   (CONST 48)                          ; "PLOG(0) is undefined"
267   (JMP L329)
269   L269
269   (CONST 26)                          ; 1
271   (SETVALUE 2)                        ; Y
273   (JMP L294)
275   L275
275   (GETVALUE&PUSH 2)                   ; Y
277   (JMPIFEQTO 50 L327)                 ; $ZERO
280   (GETVALUE&PUSH 2)                   ; Y
282   (JMPIFEQTO 37 L269)                 ; $POS
285   (GETVALUE&PUSH 2)                   ; Y
287   (JMPIFNOTEQTO 40 L294)              ; $NEG
290   (CONST 43)                          ; -1
292   (SETVALUE 2)                        ; Y
294   L294
294   (CONST&PUSH 52)                     ; (%LOG)
296   (CONST&PUSH 53)                     ; (MTIMES)
298   (GETVALUE&PUSH 2)                   ; Y
300   (LOAD&PUSH 15)
301   (LIST&PUSH 3)
303   (LIST&PUSH 2)
305   (CONST&PUSH 26)                     ; 1
306   (NIL&PUSH)
307   (CALL&PUSH 3 28)                    ; SIMPLN
310   (CONST&PUSH 54)                     ; (MTIMES)
312   (GETVALUE&PUSH 2)                   ; Y
314   (CONST&PUSH 55)                     ; ((RAT) 1 2)
316   (CONST&PUSH 13)                     ; $%I
317   (CONST&PUSH 56)                     ; $%PI
319   (LIST 5)
321   L321
321   (PUSH)
322   (CALL2 30)                          ; ADD2*
324   (JMP L112)
327   L327
327   (CONST 51)                          ; "PLOG(0) is undefined"
329   L329
329   (PUSH)
330   (CALL1 7)                           ; MERROR
332   (CONST 57)                          ; (%PLOG)
334   (JMP L104)


Disassembly of function #:|(DEFUN PATAN (R I) ...)-7|
(CONST 0) = PATAN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PATAN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PATAN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PATAN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PATAN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PATAN
8     (SKIP&RET 1)


Disassembly of function PATAN
(CONST 0) = $NUMER
(CONST 1) = VAR
(CONST 2) = SIMPLIFYA
(CONST 3) = ZEROP1
(CONST 4) = $ASKSIGN
(CONST 5) = $POS
(CONST 6) = HALF%PI
(CONST 7) = SIMPLIFY
(CONST 8) = $NEG
(CONST 9) = -1
(CONST 10) = MUL2
(CONST 11) = "ATAN(0//0) has been generated."
(CONST 12) = MERROR
(CONST 13) = 0
(CONST 14) = $%PI
(CONST 15) = "ATAN(0//0) has been generated."
(CONST 16) = %COS
(CONST 17) = AMONG
(CONST 18) = %SIN
(CONST 19) = XZ
(CONST 20) = DIV*
(CONST 21) = NUMDEN
(CONST 22) = NN*
(CONST 23) = DN*
(CONST 24) = $SIGN
(CONST 25) = 1
(CONST 26) = $ZERO
(CONST 27) = ((RAT SIMP) -1 2)
(CONST 28) = (MTIMES)
(CONST 29) = SIMPTIMES
(CONST 30) = ONEP1
(CONST 31) = (MTIMES)
(CONST 32) = ((RAT) 1 4)
(CONST 33) = ARCHK
(CONST 34) = ((MEXPT) 3 ((RAT) 1 2))
(CONST 35) = ALIKE1
(CONST 36) = (MTIMES)
(CONST 37) = ((RAT) 1 3)
(CONST 38) = ((MEXPT) 3 ((RAT) -1 2))
(CONST 39) = (MTIMES)
(CONST 40) = ((RAT) 1 6)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DN* NN* HALF%PI $NUMER)
writes special variables : (VAR $NUMER)
205 byte-code instructions:
0     (GETVALUE 0)                        ; $NUMER
2     (BIND 0)                            ; $NUMER
4     (PUSH-NIL 2)
6     (NIL)
7     (BIND 1)                            ; VAR
9     (LOAD&PUSH 9)
10    (NIL&PUSH)
11    (CALL2 2)                           ; SIMPLIFYA
13    (STORE 9)
15    (LOAD&PUSH 10)
16    (NIL&PUSH)
17    (CALL2 2)                           ; SIMPLIFYA
19    (STORE 10)
21    (PUSH)
22    (CALL1&JMPIF 3 L132)                ; ZEROP1
26    (LOAD&PUSH 9)
27    (CALL1&JMPIFNOT 3 L164)             ; ZEROP1
31    (LOAD&PUSH 10)
32    (CALLS2&JMPIFNOT 15 L38)            ; FLOATP
35    (T)
36    (SETVALUE 0)                        ; $NUMER
38    L38
38    (LOAD&PUSH 10)
39    (CALL1 4)                           ; $ASKSIGN
41    (STORE 10)
43    (PUSH)
44    (JMPIFEQTO 5 L156)                  ; $POS
48    (LOAD&PUSH 10)
49    (JMPIFEQTO 8 L160)                  ; $NEG
53    (CONST 15)                          ; "ATAN(0//0) has been generated."
54    L54
54    (PUSH)
55    (CALL1 12)                          ; MERROR
57    L57
57    (LOAD&PUSH 10)
58    (CALL1 24)                          ; $SIGN
60    (STORE 4)
61    (LOAD&PUSH 9)
62    (CALL1 24)                          ; $SIGN
64    (STORE 3)
65    (LOAD&PUSH 4)
66    (JMPIFEQTO 5 L208)                  ; $POS
70    (LOAD&PUSH 4)
71    (JMPIFEQTO 8 L214)                  ; $NEG
75    (LOAD&PUSH 4)
76    (JMPIFNOTEQTO 26 L81)               ; $ZERO
79    (CONST 13)                          ; 0
80    (STORE 4)
81    L81
81    (LOAD&PUSH 3)
82    (JMPIFEQTO 5 L219)                  ; $POS
86    (LOAD&PUSH 3)
87    (JMPIFEQTO 8 L225)                  ; $NEG
91    (LOAD&PUSH 4)
92    (JMPIFNOTEQTO 26 L97)               ; $ZERO
95    (CONST 13)                          ; 0
96    (STORE 3)
97    L97
97    (LOAD&PUSH 9)
98    (JMPIFEQTO 13 L234)                 ; 0
102   (LOAD&PUSH 10)
103   (JMPIFNOTEQTO 13 L282)              ; 0
107   (LOAD&PUSH 3)
108   (JMPIFEQTO 25 L241)                 ; 1
112   (CONST&PUSH 27)                     ; ((RAT SIMP) -1 2)
113   (CONST 14)                          ; $%PI
114   L114
114   (PUSH)
115   (CALL1&PUSH 7)                      ; SIMPLIFY
117   (CALL2 10)                          ; MUL2
119   (JMP L315)
122   L122
122   (GETVALUE 6)                        ; HALF%PI
124   (JMP L243)
127   L127
127   (CONST&PUSH 9)                      ; -1
128   (GETVALUE 6)                        ; HALF%PI
130   (JMP L114)
132   L132
132   (LOAD&PUSH 9)
133   (CALLS2&JMPIFNOT 15 L139)           ; FLOATP
136   (T)
137   (SETVALUE 0)                        ; $NUMER
139   L139
139   (LOAD&PUSH 9)
140   (CALL1 4)                           ; $ASKSIGN
142   (STORE 9)
144   (PUSH)
145   (JMPIFEQTO 5 L122)                  ; $POS
148   (LOAD&PUSH 9)
149   (JMPIFEQTO 8 L127)                  ; $NEG
152   (CONST 11)                          ; "ATAN(0//0) has been generated."
153   (JMP L54)
156   L156
156   (CONST 13)                          ; 0
157   (JMP L315)
160   L160
160   (CONST 14)                          ; $%PI
161   (JMP L243)
164   L164
164   (CONST&PUSH 16)                     ; %COS
165   (LOAD&PUSH 11)
166   (CALL2&JMPIFNOT 17 L57)             ; AMONG
170   (CONST&PUSH 18)                     ; %SIN
171   (LOAD&PUSH 10)
172   (CALL2&JMPIFNOT 17 L57)             ; AMONG
176   (CONST 19)                          ; XZ
177   (SETVALUE 1)                        ; VAR
179   (LOAD&PUSH 10)
180   (LOAD&PUSH 10)
181   (CALL2&PUSH 20)                     ; DIV*
183   (CALL1 21)                          ; NUMDEN
185   (GETVALUE 22)                       ; NN*
187   (CAR)
188   (CAR&PUSH)
189   (JMPIFNOTEQTO 16 L57)               ; %COS
193   (GETVALUE 23)                       ; DN*
195   (CAR)
196   (CAR&PUSH)
197   (JMPIFNOTEQTO 18 L57)               ; %SIN
201   (GETVALUE 22)                       ; NN*
203   (CDR)
204   (CAR)
205   (JMP L315)
208   L208
208   (CONST 25)                          ; 1
210   (STORE 4)
211   (JMP L81)
214   L214
214   (CONST 9)                           ; -1
215   (STORE 4)
216   (JMP L81)
219   L219
219   (CONST 25)                          ; 1
221   (STORE 3)
222   (JMP L97)
225   L225
225   (CONST 9)                           ; -1
226   (STORE 3)
227   (JMP L97)
230   L230
230   (CONST 13)                          ; 0
231   (JMP L315)
234   L234
234   (LOAD&PUSH 4)
235   (JMPIFEQTO 25 L230)                 ; 1
238   (CONST 14)                          ; $%PI
239   (JMP L243)
241   L241
241   (GETVALUE 6)                        ; HALF%PI
243   L243
243   (PUSH)
244   (CALL1 7)                           ; SIMPLIFY
246   (JMP L315)
249   L249
249   (LOAD&PUSH 4)
250   (LOAD&PUSH 4)
251   (CONST&PUSH 31)                     ; (MTIMES)
253   (CONST&PUSH 32)                     ; ((RAT) 1 4)
255   (CONST 14)                          ; $%PI
256   (JMP L274)
258   L258
258   (LOAD&PUSH 4)
259   (LOAD&PUSH 4)
260   (CONST&PUSH 36)                     ; (MTIMES)
262   (CONST&PUSH 37)                     ; ((RAT) 1 3)
264   (CONST 14)                          ; $%PI
265   (JMP L274)
267   L267
267   (LOAD&PUSH 4)
268   (LOAD&PUSH 4)
269   (CONST&PUSH 39)                     ; (MTIMES)
271   (CONST&PUSH 40)                     ; ((RAT) 1 6)
273   (CONST 14)                          ; $%PI
274   L274
274   (PUSH)
275   (LIST&PUSH 3)
277   (CALL 3 33)                         ; ARCHK
280   (JMP L315)
282   L282
282   (CONST&PUSH 28)                     ; (MTIMES)
283   (LOAD&PUSH 5)
284   (LOAD&PUSH 5)
285   (LOAD&PUSH 12)
286   (LOAD&PUSH 14)
287   (CALL2&PUSH 20)                     ; DIV*
289   (LIST&PUSH 4)
291   (CONST&PUSH 25)                     ; 1
292   (NIL&PUSH)
293   (CALL 3 29)                         ; SIMPTIMES
296   (STORE 10)
298   (PUSH)
299   (CALL1&JMPIF 30 L249)               ; ONEP1
302   (LOAD&PUSH 10)
303   (CONST&PUSH 34)                     ; ((MEXPT) 3 ((RAT) 1 2))
305   (CALL2&JMPIF 35 L258)               ; ALIKE1
308   (LOAD&PUSH 10)
309   (CONST&PUSH 38)                     ; ((MEXPT) 3 ((RAT) -1 2))
311   (CALL2&JMPIF 35 L267)               ; ALIKE1
314   (NIL)
315   L315
315   (UNBIND1)
316   (SKIP 2)
318   (UNBIND1)
319   (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE BINOML))-8|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN SIMPBINOCOEF (X VESTIGIAL Z) ...)-9|
(CONST 0) = SIMPBINOCOEF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPBINOCOEF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPBINOCOEF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPBINOCOEF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPBINOCOEF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPBINOCOEF
8     (SKIP&RET 1)


Disassembly of function SIMPBINOCOEF
(CONST 0) = X
(CONST 1) = TWOARGCHECK
(CONST 2) = SIMPCHECK
(CONST 3) = Y
(CONST 4) = BINCOMP
(CONST 5) = 0
(CONST 6) = 1
(CONST 7) = SUB
(CONST 8) = (%BINOMIAL)
(CONST 9) = $MAKEGAMMA
(CONST 10) = (%BINOMIAL)
(CONST 11) = EQTEST
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (Y X)
writes special variable : (Y)
110 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CALL1 1)                           ; TWOARGCHECK
7     (GETVALUE 0)                        ; X
9     (CDR)
10    (CAR&PUSH)
11    (LOAD&PUSH 5)
12    (CALL2&PUSH 2)                      ; SIMPCHECK
14    (GETVALUE 0)                        ; X
16    (CDR)
17    (CDR)
18    (CAR&PUSH)
19    (LOAD&PUSH 6)
20    (CALL2&PUSH 2)                      ; SIMPCHECK
22    (NIL)
23    (BIND 3)                            ; Y
25    (LOAD&PUSH 3)
26    (CALLS2&JMPIF 12 L114)              ; INTEGERP
30    (LOAD&PUSH 4)
31    (LOAD&PUSH 4)
32    (CALL2 7)                           ; SUB
34    (SETVALUE 3)                        ; Y
36    (PUSH)
37    (CALLS2&JMPIFNOT 12 L149)           ; INTEGERP
41    (LOAD&PUSH 4)
42    (GETVALUE 3)                        ; Y
44    L44
44    (PUSH)
45    (CALL2 4)                           ; BINCOMP
47    (JMP L166)
50    L50
50    (LOAD&PUSH 4)
51    (LOAD 5)
52    (BIND 0)                            ; X
54    (LOAD 7)
55    (BIND 3)                            ; Y
57    (GETVALUE&PUSH 0)                   ; X
59    (GETVALUE&PUSH 3)                   ; Y
61    (CALLSR 1 54)                       ; -
64    (UNBIND 2)
66    (JMP L44)
68    L68
68    (LOAD&PUSH 4)
69    (CALLS2&JMPIFNOT 12 L82)            ; INTEGERP
72    (LOAD&PUSH 4)
73    (CALLS2&JMPIFNOT 147 L82)           ; MINUSP
76    (LOAD&PUSH 3)
77    (LOAD&PUSH 5)
78    (CALLSR&JMPIF 1 47 L50)             ; <
82    L82
82    (CONST 5)                           ; 0
83    (JMP L166)
86    L86
86    (CONST 6)                           ; 1
87    (JMP L166)
90    L90
90    (LOAD&PUSH 4)
91    (LOAD&PUSH 4)
92    (LOAD 6)
93    (BIND 0)                            ; X
95    (LOAD 8)
96    (BIND 3)                            ; Y
98    (GETVALUE&PUSH 0)                   ; X
100   (GETVALUE&PUSH 3)                   ; Y
102   (CALLSR 1 54)                       ; -
105   (UNBIND 2)
107   (PUSH)
108   (CALLSR 1 52)                       ; MIN
111   (JMP L44)
114   L114
114   (LOAD&PUSH 3)
115   (CALLS2&JMPIF 147 L68)              ; MINUSP
118   (LOAD&PUSH 3)
119   (CALLS2&JMPIF 145 L86)              ; ZEROP
122   (LOAD&PUSH 4)
123   (LOAD&PUSH 4)
124   (CALLS2&JMPIF 2 L86)                ; EQUAL
127   (LOAD&PUSH 4)
128   (CALLS2&JMPIFNOT 12 L135)           ; INTEGERP
131   (LOAD&PUSH 4)
132   (CALLS2&JMPIFNOT 147 L90)           ; MINUSP
135   L135
135   (LOAD&PUSH 4)
136   (LOAD 4)
137   (JMP L44)
140   L140
140   (CONST&PUSH 8)                      ; (%BINOMIAL)
141   (LOAD&PUSH 5)
142   (LOAD&PUSH 5)
143   (LIST&PUSH 3)
145   (CALL1 9)                           ; $MAKEGAMMA
147   (JMP L166)
149   L149
149   (LOAD&PUSH 4)
150   (CALLS2&JMPIFNOT 15 L157)           ; FLOATP
153   (LOAD&PUSH 3)
154   (CALLS2&JMPIF 15 L140)              ; FLOATP
157   L157
157   (CONST&PUSH 10)                     ; (%BINOMIAL)
158   (LOAD&PUSH 5)
159   (LOAD&PUSH 5)
160   (LIST&PUSH 3)
162   (GETVALUE&PUSH 0)                   ; X
164   (CALL2 11)                          ; EQTEST
166   L166
166   (UNBIND1)
167   (SKIP 2)
169   (UNBIND1)
170   (SKIP&RET 4)


Disassembly of function #:|(DEFUN BINCOMP (U V) ...)-10|
(CONST 0) = BINCOMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BINCOMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BINCOMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BINCOMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BINCOMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BINCOMP
8     (SKIP&RET 1)


Disassembly of function BINCOMP
(CONST 0) = 0
(CONST 1) = 1
(CONST 2) = MNUMP
(CONST 3) = BINOCOMP
(CONST 4) = BINCOMP1
(CONST 5) = MULN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
23 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALLS2&JMPIF 147 L21)              ; MINUSP
4     (LOAD&PUSH 1)
5     (CALLS2&JMPIF 145 L24)              ; ZEROP
8     (LOAD&PUSH 2)
9     (CALL1&JMPIF 2 L27)                 ; MNUMP
12    (LOAD&PUSH 2)
13    (LOAD&PUSH 2)
14    (CALL2&PUSH 4)                      ; BINCOMP1
16    (NIL&PUSH)
17    (CALL2 5)                           ; MULN
19    (SKIP&RET 3)
21    L21
21    (CONST 0)                           ; 0
22    (SKIP&RET 3)
24    L24
24    (CONST 1)                           ; 1
25    (SKIP&RET 3)
27    L27
27    (LOAD&PUSH 2)
28    (LOAD&PUSH 2)
29    (CALL2 3)                           ; BINOCOMP
31    (SKIP&RET 3)


Disassembly of function #:|(DEFUN BINCOMP1 (U V) ...)-11|
(CONST 0) = BINCOMP1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BINCOMP1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BINCOMP1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BINCOMP1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BINCOMP1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BINCOMP1
8     (SKIP&RET 1)


Disassembly of function BINCOMP1
(CONST 0) = 1
(CONST 1) = (MEXPT)
(CONST 2) = -1
(CONST 3) = ADD2
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
20 byte-code instructions:
0     L0
0     (LOAD&PUSH 1)
1     (JMPIFEQTO 0 L22)                   ; 1
4     (LOAD&PUSH 2)
5     (CONST&PUSH 1)                      ; (MEXPT)
6     (LOAD&PUSH 3)
7     (CONST&PUSH 2)                      ; -1
8     (LIST&PUSH 3)
10    (CONST&PUSH 2)                      ; -1
11    (LOAD&PUSH 5)
12    (CALL2&PUSH 3)                      ; ADD2
14    (LOAD&DEC&PUSH 4)
16    (JSR L0)
18    (LIST* 2)
20    (SKIP&RET 3)
22    L22
22    (LOAD&PUSH 2)
23    (NIL)
24    (CONS)
25    (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN BINOCOMP (U V) ...)-12|
(CONST 0) = BINOCOMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BINOCOMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BINOCOMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BINOCOMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BINOCOMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BINOCOMP
8     (SKIP&RET 1)


Disassembly of function BINOCOMP
(CONST 0) = 1
(CONST 1) = TIMESK
(CONST 2) = (RAT)
(CONST 3) = SIMPLIFY
(CONST 4) = -1
(CONST 5) = ADDK
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
25 byte-code instructions:
0     (NIL&PUSH)
1     (CONST 0)                           ; 1
2     (STORE 0)
3     (JMP L26)
5     L5
5     (LOAD&PUSH 3)
6     (LOAD&PUSH 1)
7     (CALL2&PUSH 1)                      ; TIMESK
9     (CONST&PUSH 2)                      ; (RAT)
10    (CONST&PUSH 0)                      ; 1
11    (LOAD&PUSH 5)
12    (LIST&PUSH 3)
14    (CALL1&PUSH 3)                      ; SIMPLIFY
16    (CALL2 1)                           ; TIMESK
18    (STORE 0)
19    (CONST&PUSH 4)                      ; -1
20    (LOAD&PUSH 4)
21    (CALL2 5)                           ; ADDK
23    (STORE 3)
24    (LOAD&DEC&STORE 2)
26    L26
26    (LOAD&PUSH 2)
27    (CALLS2&JMPIFNOT 145 L5)            ; ZEROP
30    (POP)
31    (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE GAMMA) (SPECIAL $NUMER $GAMMALIM))-13|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $BETA_ARGS_SUM_TO_INTEGER NIL)-14-1|
(CONST 0) = $BETA_ARGS_SUM_TO_INTEGER
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; $BETA_ARGS_SUM_TO_INTEGER
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; $BETA_ARGS_SUM_TO_INTEGER
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR $BETA_ARGS_SUM_TO_INTEGER NIL)-14-2|
(CONST 0) = (SPECIAL $BETA_ARGS_SUM_TO_INTEGER)
(CONST 1) = $BETA_ARGS_SUM_TO_INTEGER
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL $BETA_ARGS_SUM_TO_INTEGER)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; $BETA_ARGS_SUM_TO_INTEGER
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; $BETA_ARGS_SUM_TO_INTEGER
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST 1)                           ; $BETA_ARGS_SUM_TO_INTEGER
12    (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN SIMPBETA (X VESTIGIAL Z ...) ...)-15|
(CONST 0) = SIMPBETA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPBETA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPBETA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPBETA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPBETA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPBETA
8     (SKIP&RET 1)


Disassembly of function SIMPBETA
(CONST 0) = X
(CONST 1) = TWOARGCHECK
(CONST 2) = SIMPCHECK
(CONST 3) = ZEROP1
(CONST 4) = ERRORSW
(CONST 5) = "Zero argument to BETA"
(CONST 6) = MERROR
(CONST 7) = $NUMER
(CONST 8) = ($BETA)
(CONST 9) = $MAKEGAMMA
(CONST 10) = ADD2
(CONST 11) = 1
(CONST 12) = SUB
(CONST 13) = (%BINOMIAL)
(CONST 14) = 2
(CONST 15) = SIMPLIFYA
(CONST 16) = MUL2
(CONST 17) = -1
(CONST 18) = POWER
(CONST 19) = (MFACTORIAL)
(CONST 20) = (MFACTORIAL)
(CONST 21) = DIV*
(CONST 22) = (MFACTORIAL)
(CONST 23) = MUL2*
(CONST 24) = RATNUMP
(CONST 25) = ADDK
(CONST 26) = $BETA_ARGS_SUM_TO_INTEGER
(CONST 27) = EXPAND1
(CONST 28) = $%PI
(CONST 29) = (%BINOMIAL)
(CONST 30) = NEG
(CONST 31) = (%SIN)
(CONST 32) = (MTIMES)
(CONST 33) = ($%PI)
(CONST 34) = ($BETA)
(CONST 35) = EQTEST
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ERRORSW $BETA_ARGS_SUM_TO_INTEGER $NUMER X)
writes special variable : (X)
180 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; X
3     (NIL&PUSH)
4     (GETVALUE&PUSH 0)                   ; X
6     (CALL1 1)                           ; TWOARGCHECK
8     (GETVALUE 0)                        ; X
10    (STORE 0)
11    (CDR)
12    (CAR&PUSH)
13    (LOAD&PUSH 6)
14    (CALL2&PUSH 2)                      ; SIMPCHECK
16    (GETVALUE 0)                        ; X
18    (CDR)
19    (CDR)
20    (CAR&PUSH)
21    (LOAD&PUSH 7)
22    (CALL2&PUSH 2)                      ; SIMPCHECK
24    (LOAD&PUSH 1)
25    (CALL1&JMPIF 3 L141)                ; ZEROP1
29    (LOAD&PUSH 0)
30    (CALL1&JMPIF 3 L141)                ; ZEROP1
34    (LOAD&PUSH 1)
35    (CALLS2&JMPIFNOT 15 L43)            ; FLOATP
38    (LOAD&PUSH 0)
39    (CALLS2&JMPIF 15 L152)              ; FLOATP
43    L43
43    (GETVALUE 7)                        ; $NUMER
45    (JMPIFNOT L56)
47    (LOAD&PUSH 1)
48    (CALLS2&JMPIFNOT 8 L56)             ; NUMBERP
51    (LOAD&PUSH 0)
52    (CALLS2&JMPIF 8 L152)               ; NUMBERP
56    L56
56    (LOAD&PUSH 1)
57    (CALLS2&JMPIFNOT 12 L65)            ; INTEGERP
60    (LOAD&PUSH 1)
61    (CALLS2&JMPIF 146 L166)             ; PLUSP
65    L65
65    (LOAD&PUSH 0)
66    (CALLS2&JMPIFNOT 12 L74)            ; INTEGERP
69    (LOAD&PUSH 0)
70    (CALLS2&JMPIF 146 L166)             ; PLUSP
74    L74
74    (LOAD&PUSH 1)
75    (CALLS2&JMPIFNOT 12 L83)            ; INTEGERP
78    (LOAD&PUSH 0)
79    (CALLS2&JMPIF 12 L210)              ; INTEGERP
83    L83
83    (LOAD&PUSH 1)
84    (CALL1&JMPIFNOT 24 L102)            ; RATNUMP
87    (LOAD&PUSH 0)
88    (CALL1&JMPIFNOT 24 L102)            ; RATNUMP
91    (LOAD&PUSH 1)
92    (LOAD&PUSH 1)
93    (CALL2 25)                          ; ADDK
95    (SETVALUE 0)                        ; X
97    (PUSH)
98    (CALLS2&JMPIF 12 L241)              ; INTEGERP
102   L102
102   (GETVALUE 26)                       ; $BETA_ARGS_SUM_TO_INTEGER
104   (JMPIFNOT L122)
106   (LOAD&PUSH 1)
107   (LOAD&PUSH 1)
108   (CALL2&PUSH 10)                     ; ADD2
110   (CONST&PUSH 11)                     ; 1
111   (CONST&PUSH 11)                     ; 1
112   (CALL 3 27)                         ; EXPAND1
115   (SETVALUE 0)                        ; X
117   (PUSH)
118   (CALLS2&JMPIF 12 L241)              ; INTEGERP
122   L122
122   (CONST&PUSH 34)                     ; ($BETA)
124   (LOAD&PUSH 2)
125   (LOAD&PUSH 2)
126   (LIST&PUSH 3)
128   (LOAD&PUSH 3)
129   (CALL2 35)                          ; EQTEST
131   (SKIP 2)
133   L133
133   (SKIP 1)
135   (UNBIND1)
136   (SKIP&RET 4)
138   L138
138   (CONST&PUSH 4)                      ; ERRORSW
139   (T)
140   (THROW)
141   L141
141   (GETVALUE 4)                        ; ERRORSW
143   (JMPIF L138)
145   (CONST&PUSH 5)                      ; "Zero argument to BETA"
146   (CALL1 6)                           ; MERROR
148   (SKIP 2)
150   (JMP L133)
152   L152
152   (CONST&PUSH 8)                      ; ($BETA)
153   (LOAD&PUSH 2)
154   (LOAD&PUSH 2)
155   (LIST&PUSH 3)
157   (CALL1 9)                           ; $MAKEGAMMA
159   (SKIP 2)
161   (JMP L133)
163   L163
163   (LOAD 4)
164   (JMP L191)
166   L166
166   (LOAD&PUSH 1)
167   (LOAD&PUSH 1)
168   (CALL2 10)                          ; ADD2
170   (SETVALUE 0)                        ; X
172   (PUSH)
173   (CONST&PUSH 11)                     ; 1
174   (CALL2&PUSH 12)                     ; SUB
176   (CONST&PUSH 13)                     ; (%BINOMIAL)
177   (GETVALUE&PUSH 0)                   ; X
179   (CONST&PUSH 14)                     ; 2
180   (CALL2&PUSH 12)                     ; SUB
182   (LOAD&PUSH 4)
183   (CALLS2&JMPIFNOT 12 L190)           ; INTEGERP
186   (LOAD&PUSH 4)
187   (CALLS2&JMPIF 146 L163)             ; PLUSP
190   L190
190   (LOAD 3)
191   L191
191   (PUSH)
192   (CONST&PUSH 11)                     ; 1
193   (CALL2&PUSH 12)                     ; SUB
195   (LIST&PUSH 3)
197   (T&PUSH)
198   (CALL2&PUSH 15)                     ; SIMPLIFYA
200   (CALL2&PUSH 16)                     ; MUL2
202   (CONST&PUSH 17)                     ; -1
203   (CALL2 18)                          ; POWER
205   (SKIP 2)
207   (JMP L133)
210   L210
210   (CONST&PUSH 19)                     ; (MFACTORIAL)
211   (LOAD&DEC&PUSH 2)
213   (LIST&PUSH 2)
215   (CONST&PUSH 20)                     ; (MFACTORIAL)
216   (CONST&PUSH 17)                     ; -1
217   (LOAD&PUSH 4)
218   (LOAD&PUSH 4)
219   (CALLSR&PUSH 3 53)                  ; +
222   (LIST&PUSH 2)
224   (CALL2&PUSH 21)                     ; DIV*
226   (CONST&PUSH 22)                     ; (MFACTORIAL)
227   (LOAD&DEC&PUSH 2)
229   (LIST&PUSH 2)
231   (CALL2 23)                          ; MUL2*
233   (SKIP 2)
235   (JMP L133)
238   L238
238   (LOAD 0)
239   (JMP L246)
241   L241
241   (LOAD&PUSH 0)
242   (CALLS2&JMPIF 6 L238)               ; SYMBOLP
245   (LOAD 1)
246   L246
246   (PUSH)
247   (CONST&PUSH 28)                     ; $%PI
248   (CONST&PUSH 29)                     ; (%BINOMIAL)
249   (GETVALUE&PUSH 0)                   ; X
251   (CALLS2&PUSH 151)                   ; 1-
253   (LOAD&PUSH 3)
254   (CALL1&PUSH 30)                     ; NEG
256   (CALL2&PUSH 10)                     ; ADD2
258   (GETVALUE&PUSH 0)                   ; X
260   (CALLS2&PUSH 151)                   ; 1-
262   (LIST&PUSH 3)
264   (CALL2&PUSH 23)                     ; MUL2*
266   (CONST&PUSH 31)                     ; (%SIN)
268   (CONST&PUSH 32)                     ; (MTIMES)
270   (LOAD&PUSH 3)
271   (CONST 33)                          ; ($%PI)
273   (LIST*&PUSH 2)
275   (LIST&PUSH 2)
277   (CALL2 21)                          ; DIV*
279   (SKIP 3)
281   (JMP L133)


Disassembly of function #:|(DEFMFUN SIMPGAMMA (X VESTIGIAL Z) ...)-16|
(CONST 0) = SIMPGAMMA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPGAMMA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPGAMMA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPGAMMA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPGAMMA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPGAMMA
8     (SKIP&RET 1)


Disassembly of function SIMPGAMMA
(CONST 0) = X
(CONST 1) = ONEARGCHECK
(CONST 2) = SIMPCHECK
(CONST 3) = GAMMAFLOAT
(CONST 4) = MNUMP
(CONST 5) = (%ABS)
(CONST 6) = 1
(CONST 7) = SIMPABS
(CONST 8) = $GAMMALIM
(CONST 9) = RATGREATERP
(CONST 10) = (%GAMMA)
(CONST 11) = EQTEST
(CONST 12) = 0
(CONST 13) = (MFACTORIAL)
(CONST 14) = SIMPFACT
(CONST 15) = ERRORSW
(CONST 16) = "GAMMA(~:M) is undefined"
(CONST 17) = MERROR
(CONST 18) = $NUMER
(CONST 19) = FPCOFRAT
(CONST 20) = ((RAT) 1 2)
(CONST 21) = ALIKE1
(CONST 22) = (MEXPT SIMP)
(CONST 23) = $%PI
(CONST 24) = GAMMARED
(CONST 25) = (%GAMMA)
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ERRORSW $NUMER $GAMMALIM X)
95 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CALL1 1)                           ; ONEARGCHECK
7     (GETVALUE 0)                        ; X
9     (CDR)
10    (CAR&PUSH)
11    (LOAD&PUSH 5)
12    (CALL2&PUSH 2)                      ; SIMPCHECK
14    (LOAD&PUSH 0)
15    (CALLS2&JMPIF 15 L56)               ; FLOATP
18    (LOAD&PUSH 0)
19    (CALL1&JMPIFNOT 4 L59)              ; MNUMP
22    (CONST&PUSH 5)                      ; (%ABS)
23    (LOAD&PUSH 1)
24    (LIST&PUSH 2)
26    (CONST&PUSH 6)                      ; 1
27    (T&PUSH)
28    (CALL&PUSH 3 7)                     ; SIMPABS
31    (GETVALUE&PUSH 8)                   ; $GAMMALIM
33    (CALL2&JMPIF 9 L59)                 ; RATGREATERP
36    (LOAD&PUSH 0)
37    (CALLS2&JMPIF 12 L81)               ; INTEGERP
40    (GETVALUE 18)                       ; $NUMER
42    (JMPIFNOT L115)
45    (LOAD&PUSH 0)
46    (CALL1 19)                          ; FPCOFRAT
48    L48
48    (PUSH)
49    (CALL1 3)                           ; GAMMAFLOAT
51    (SKIP 1)
53    (JMP L142)
56    L56
56    (LOAD 0)
57    (JMP L48)
59    L59
59    (CONST 10)                          ; (%GAMMA)
60    (JMP L132)
63    L63
63    (CONST&PUSH 13)                     ; (MFACTORIAL)
64    (LOAD&DEC&PUSH 1)
66    (LIST&PUSH 2)
68    (CONST&PUSH 6)                      ; 1
69    (NIL&PUSH)
70    (CALL 3 14)                         ; SIMPFACT
73    (SKIP 1)
75    (JMP L142)
78    L78
78    (CONST&PUSH 15)                     ; ERRORSW
79    (T)
80    (THROW)
81    L81
81    (LOAD&PUSH 0)
82    (CONST&PUSH 12)                     ; 0
83    (CALLSR&JMPIF 1 48 L63)             ; >
87    (GETVALUE 15)                       ; ERRORSW
89    (JMPIF L78)
91    (CONST&PUSH 16)                     ; "GAMMA(~:M) is undefined"
92    (LOAD&PUSH 1)
93    (CALL2 17)                          ; MERROR
95    (SKIP 1)
97    (JMP L142)
99    L99
99    (CONST&PUSH 22)                     ; (MEXPT SIMP)
100   (CONST&PUSH 23)                     ; $%PI
101   (LOAD&PUSH 2)
102   (LIST 3)
104   (SKIP 1)
106   (JMP L142)
108   L108
108   (LOAD&PUSH 0)
109   (CALL1 24)                          ; GAMMARED
111   (SKIP 1)
113   (JMP L142)
115   L115
115   (LOAD&PUSH 0)
116   (CONST&PUSH 20)                     ; ((RAT) 1 2)
117   (CALL2&JMPIF 21 L99)                ; ALIKE1
120   (LOAD&PUSH 0)
121   (CONST&PUSH 6)                      ; 1
122   (CALL2&JMPIF 9 L108)                ; RATGREATERP
125   (CONST&PUSH 12)                     ; 0
126   (LOAD&PUSH 1)
127   (CALL2&JMPIF 9 L108)                ; RATGREATERP
130   (CONST 25)                          ; (%GAMMA)
132   L132
132   (PUSH)
133   (LOAD&PUSH 1)
134   (LIST&PUSH 2)
136   (GETVALUE&PUSH 0)                   ; X
138   (CALL2 11)                          ; EQTEST
140   (SKIP 1)
142   L142
142   (UNBIND1)
143   (SKIP&RET 4)


Disassembly of function #:|(DECLARE-TOP (FLONUM SUM))-17|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN GAMMA (Y) ...)-18|
(CONST 0) = GAMMA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMA
8     (SKIP&RET 1)


Disassembly of function GAMMA
(CONST 0) = Y
(CONST 1) = 
(0.035868343 -0.193527817 0.48219939 -0.75670407 0.91820685 -0.89705693
 0.98820588 -0.57719165)
(CONST 2) = FPCOFRAT
(CONST 3) = 1.0
(CONST 4) = QUOT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (Y)
writes special variable : (Y)
29 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; Y
3     (PUSH-NIL 2)
5     (CONST 1)                           ; (0.035868343 -0.193527817 ...)
6     (STORE 0)
7     (GETVALUE 0)                        ; Y
9     (JMPIFATOM L17)
11    (GETVALUE&PUSH 0)                   ; Y
13    (CALL1 2)                           ; FPCOFRAT
15    (SETVALUE 0)                        ; Y
17    L17
17    (LOAD&CAR&STORE 0 1)
20    (LOAD&CDR&STORE 0)
22    L22
22    (LOAD&PUSH 1)
23    (GETVALUE&PUSH 0)                   ; Y
25    (CALLSR&PUSH 2 55)                  ; *
28    (LOAD&CAR&PUSH 1)
30    (CALLSR&STORE 2 53 1)               ; +
34    (LOAD&CDR&STORE 0)
36    (JMPIF L22)
38    (CONST&PUSH 3)                      ; 1.0
39    (GETVALUE&PUSH 0)                   ; Y
41    (CALL2&PUSH 4)                      ; QUOT
43    (LOAD&PUSH 2)
44    (CALLSR 2 53)                       ; +
47    (SKIP 2)
49    (UNBIND1)
50    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (NOTYPE SUM))-19|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN GAMMARED (A) ...)-20|
(CONST 0) = GAMMARED
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMARED>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMARED
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMARED
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMARED>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMARED
8     (SKIP&RET 1)


Disassembly of function GAMMARED
(CONST 0) = GAMMAFLOAT
(CONST 1) = X
(CONST 2) = Y
(CONST 3) = (MTIMES)
(CONST 4) = (MEXPT)
(CONST 5) = (%GAMMA)
(CONST 6) = (RAT)
(CONST 7) = 1
(CONST 8) = SIMPGAMMA
(CONST 9) = (MEXPT)
(CONST 10) = GAMMAC
(CONST 11) = -1
(CONST 12) = SIMPTIMES
(CONST 13) = (%GAMMA)
(CONST 14) = (RAT)
(CONST 15) = POWER*
(CONST 16) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (Y X)
93 byte-code instructions:
0     (PUSH-NIL 3)
2     (LOAD&PUSH 4)
3     (CALLS2&JMPIF 15 L83)               ; FLOATP
7     (LOAD 4)
8     (CDR)
9     (CAR)
10    (STORE 2)
11    (LOAD 4)
12    (CDR)
13    (CDR)
14    (CAR)
15    (STORE 0)
16    (LOAD 2)
17    (BIND 1)                            ; X
19    (LOAD 3)
20    (BIND 2)                            ; Y
22    (GETVALUE&PUSH 1)                   ; X
24    (CALLS2&JMPIFNOT 12 L32)            ; INTEGERP
27    (GETVALUE&PUSH 2)                   ; Y
29    (CALLS2&JMPIF 12 L88)               ; INTEGERP
32    L32
32    (GETVALUE&PUSH 1)                   ; X
34    (GETVALUE&PUSH 2)                   ; Y
36    (CALLSR 1 56)                       ; /
39    L39
39    (UNBIND 2)
41    (PUSH)
42    (CALLS2&STORE 158 1)                ; ABS
45    (LOAD&PUSH 2)
46    (CALLS2&JMPIF 147 L96)              ; MINUSP
49    (LOAD&PUSH 2)
50    (LOAD&PUSH 1)
51    (LOAD&PUSH 3)
52    (CALL&PUSH 3 10)                    ; GAMMAC
55    (CONST&PUSH 13)                     ; (%GAMMA)
56    (CONST&PUSH 14)                     ; (RAT)
57    (LOAD&PUSH 5)
58    (LOAD&PUSH 4)
59    (CALLS2&PUSH 184)                   ; REM
61    (LOAD&PUSH 4)
62    (LIST&PUSH 3)
64    (LIST&PUSH 2)
66    (CONST&PUSH 7)                      ; 1
67    (NIL&PUSH)
68    (CALL&PUSH 3 8)                     ; SIMPGAMMA
71    (LOAD&PUSH 2)
72    (LOAD&PUSH 4)
73    (CALLSR&PUSH 0 54)                  ; -
76    (CALL2&PUSH 15)                     ; POWER*
78    (CALL 3 16)                         ; MUL*
81    (SKIP&RET 5)
83    L83
83    (LOAD&PUSH 4)
84    (CALL1 0)                           ; GAMMAFLOAT
86    (SKIP&RET 5)
88    L88
88    (GETVALUE&PUSH 1)                   ; X
90    (GETVALUE&PUSH 2)                   ; Y
92    (CALLS2 181)                        ; TRUNCATE
94    (JMP L39)
96    L96
96    (LOAD&INC&STORE 1)
98    (LOAD&PUSH 2)
99    (LOAD&PUSH 1)
100   (LOAD&PUSH 3)
101   (CALLSR&PUSH 2 55)                  ; *
104   (CALLSR&STORE 2 53 2)               ; +
108   (CONST&PUSH 3)                      ; (MTIMES)
109   (CONST&PUSH 4)                      ; (MEXPT)
110   (LOAD&PUSH 2)
111   (LOAD&PUSH 4)
112   (LIST&PUSH 3)
114   (CONST&PUSH 5)                      ; (%GAMMA)
115   (CONST&PUSH 6)                      ; (RAT)
116   (LOAD&PUSH 6)
117   (LOAD&PUSH 5)
118   (LIST&PUSH 3)
120   (LIST&PUSH 2)
122   (CONST&PUSH 7)                      ; 1
123   (NIL&PUSH)
124   (CALL&PUSH 3 8)                     ; SIMPGAMMA
127   (CONST&PUSH 9)                      ; (MEXPT)
128   (LOAD&PUSH 6)
129   (LOAD&PUSH 5)
130   (LOAD&PUSH 7)
131   (CALL&PUSH 3 10)                    ; GAMMAC
134   (CONST&PUSH 11)                     ; -1
135   (LIST&PUSH 3)
137   (LIST&PUSH 4)
139   (CONST&PUSH 7)                      ; 1
140   (NIL&PUSH)
141   (CALL 3 12)                         ; SIMPTIMES
144   (SKIP&RET 5)


Disassembly of function #:|(DEFUN GAMMAC (M N Q) ...)-21|
(CONST 0) = GAMMAC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMAC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMAC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMAC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMAC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMAC
8     (SKIP&RET 1)


Disassembly of function GAMMAC
(CONST 0) = 1
(CONST 1) = X
(CONST 2) = Y
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (Y X)
22 byte-code instructions:
0     (CONST&PUSH 0)                      ; 1
1     (JMP L27)
3     L3
3     (LOAD&DEC&STORE 2)
5     (LOAD 4)
6     (BIND 1)                            ; X
8     (LOAD 6)
9     (BIND 2)                            ; Y
11    (GETVALUE&PUSH 1)                   ; X
13    (GETVALUE&PUSH 2)                   ; Y
15    (CALLSR 1 54)                       ; -
18    (UNBIND 2)
20    (STORE 4)
21    (PUSH)
22    (LOAD&PUSH 1)
23    (CALLSR&STORE 2 55 0)               ; *
27    L27
27    (LOAD&PUSH 2)
28    (CONST&PUSH 0)                      ; 1
29    (CALLSR&JMPIFNOT 1 47 L3)           ; <
33    (POP)
34    (SKIP&RET 4)

WARNING in GAMMA-LANCZOS in lines 244..341 :
variable G is not used.
Misspelled or missing IGNORE declaration?

Disassembly of function #:|(DEFUN GAMMA-LANCZOS (Z) ...)-22|
(CONST 0) = GAMMA-LANCZOS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMA-LANCZOS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMA-LANCZOS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMA-LANCZOS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMA-LANCZOS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMA-LANCZOS
8     (SKIP&RET 1)


Disassembly of function GAMMA-LANCZOS
(CONST 0) = 15
(CONST 1) = DOUBLE-FLOAT
(CONST 2) = 
(0.9999999999999971 57.15623566586292 -59.59796035547549 14.136097974741746
 -0.4919138160976202 3.399464998481189E-5 4.652362892704858E-5
 -9.837447530487956E-5 1.580887032249125E-4 -2.1026444172410488E-4
 2.1743961811521265E-4 -1.643181065367639E-4 8.441822398385275E-5
 -2.6190838401581408E-5 3.6899182659531625E-6)
(CONST 3) = PI
(CONST 4) = 1.0
(CONST 5) = 1/2
(CONST 6) = 607/128
(CONST 7) = 0.0
(CONST 8) = 1
(CONST 9) = 2
(CONST 10) = 0
(CONST 11) = EXP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (PI)
83 byte-code instructions:
0     L0
0     (CONST&PUSH 0)                      ; 15
1     (PUSH-UNBOUND 7)
3     (CONST 1)                           ; DOUBLE-FLOAT
4     (STORE 5)
5     (CONST 2)                           ; (0.9999999999999971 ...)
6     (STORE 3)
7     (CALLS1&PUSH 29)                    ; MAKE-ARRAY
9     (LOAD&PUSH 2)
10    (CALLS2&PUSH 197)                   ; REALPART
12    (CALLS2&JMPIF 147 L43)              ; MINUSP
15    (LOAD&DEC&PUSH 2)
17    (CONST&PUSH 5)                      ; 1/2
18    (LOAD&PUSH 1)
19    (CALLSR&PUSH 2 53)                  ; +
22    (CONST&PUSH 6)                      ; 607/128
23    (LOAD&PUSH 1)
24    (CALLSR&PUSH 2 53)                  ; +
27    (LOAD&PUSH 0)
28    (CONST&PUSH 5)                      ; 1/2
29    (LOAD&PUSH 3)
30    (CALLSR&PUSH 2 55)                  ; *
33    (CALLS2&PUSH 154)                   ; EXPT
35    (CONST&PUSH 7)                      ; 0.0
36    (LOAD&PUSH 5)
37    (CALLS2&PUSH 71)                    ; LENGTH
39    (CALLS2&PUSH 151)                   ; 1-
41    (JMP L98)
43    L43
43    (GETVALUE&PUSH 3)                   ; PI
45    (CONST&PUSH 4)                      ; 1.0
46    (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
48    (LOAD&PUSH 3)
49    (CALLSR&PUSH 0 54)                  ; -
52    (GETVALUE&PUSH 3)                   ; PI
54    (CONST&PUSH 4)                      ; 1.0
55    (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
57    (LOAD&PUSH 5)
58    (CALLSR&PUSH 2 55)                  ; *
61    (CALLS2&PUSH 161)                   ; SIN
63    (LOAD&PUSH 5)
64    (CALLSR&PUSH 0 54)                  ; -
67    (JSR&PUSH L0)
70    (CALLSR&PUSH 3 55)                  ; *
73    (CALLSR 1 56)                       ; /
76    (SKIP&RET 3)
78    L78
78    (LOAD&PUSH 1)
79    (LOAD&PUSH 7)
80    (LOAD&PUSH 2)
81    (CALLSR&PUSH 1 1)                   ; AREF
84    (LOAD&PUSH 7)
85    (LOAD&PUSH 3)
86    (CALLSR&PUSH 2 53)                  ; +
89    (CALLSR&PUSH 1 56)                  ; /
92    (CALLSR&STORE 2 53 1)               ; +
96    (LOAD&DEC&STORE 0)
98    L98
98    (LOAD&PUSH 0)
99    (CONST&PUSH 8)                      ; 1
100   (CALLSR&JMPIFNOT 1 47 L78)          ; <
104   (LOAD 1)
105   (SKIP 1)
107   (STORE 0)
108   (CONST&PUSH 9)                      ; 2
109   (GETVALUE&PUSH 3)                   ; PI
111   (CALLSR&PUSH 2 55)                  ; *
114   (CONST&PUSH 4)                      ; 1.0
115   (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
117   (CALLS2&PUSH 156)                   ; SQRT
119   (LOAD&PUSH 1)
120   (LOAD&PUSH 7)
121   (CONST&PUSH 10)                     ; 0
122   (CALLSR&PUSH 1 1)                   ; AREF
125   (CALLSR&PUSH 2 53)                  ; +
128   (LOAD&PUSH 3)
129   (LOAD&PUSH 5)
130   (CALLSR&PUSH 0 54)                  ; -
133   (CALL1&PUSH 11)                     ; EXP
135   (LOAD&PUSH 5)
136   (CALLSR&PUSH 3 55)                  ; *
139   (CALLSR 3 55)                       ; *
142   (SKIP&RET 8)


Disassembly of function #:|(DEFUN GAMMAFLOAT (A) ...)-23|
(CONST 0) = GAMMAFLOAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GAMMAFLOAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GAMMAFLOAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GAMMAFLOAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GAMMAFLOAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GAMMAFLOAT
8     (SKIP&RET 1)


Disassembly of function GAMMAFLOAT
(CONST 0) = 0.0
(CONST 1) = GAMMA-LANCZOS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CONST&PUSH 0)                      ; 0.0
2     (CALLS2&PUSH 196)                   ; COMPLEX
4     (CALL1&PUSH 1)                      ; GAMMA-LANCZOS
6     (CALLS2 197)                        ; REALPART
8     (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (NOTYPE A R))-24|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE ERF) (SPECIAL $NUMER $TRIGSIGN))-25|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN SIMPERF (X VESTIGIAL Z ...) ...)-26|
(CONST 0) = SIMPERF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPERF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPERF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPERF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPERF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPERF
8     (SKIP&RET 1)


Disassembly of function SIMPERF
(CONST 0) = X
(CONST 1) = Y
(CONST 2) = ONEARGCHECK
(CONST 3) = SIMPCHECK
(CONST 4) = ZEROP1
(CONST 5) = $NUMER
(CONST 6) = 1.0
(CONST 7) = ERF
(CONST 8) = $INF
(CONST 9) = 1
(CONST 10) = $MINF
(CONST 11) = -1
(CONST 12) = $TRIGSIGN
(CONST 13) = MMINUSP*
(CONST 14) = (%ERF SIMP)
(CONST 15) = NEG
(CONST 16) = (%ERF)
(CONST 17) = EQTEST
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: ($TRIGSIGN $NUMER Y X)
writes special variable : (Y)
60 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; X
3     (NIL)
4     (BIND 1)                            ; Y
6     (GETVALUE&PUSH 0)                   ; X
8     (CALL1 2)                           ; ONEARGCHECK
10    (GETVALUE 0)                        ; X
12    (CDR)
13    (CAR&PUSH)
14    (LOAD&PUSH 8)
15    (CALL2 3)                           ; SIMPCHECK
17    (SETVALUE 1)                        ; Y
19    (PUSH)
20    (CALL1&JMPIF 4 L69)                 ; ZEROP1
23    (GETVALUE&PUSH 1)                   ; Y
25    (CALLS2&JMPIF 15 L73)               ; FLOATP
28    (GETVALUE 5)                        ; $NUMER
30    (JMPIFNOT L37)
32    (GETVALUE&PUSH 1)                   ; Y
34    (CALLS2&JMPIF 12 L73)               ; INTEGERP
37    L37
37    (GETVALUE&PUSH 1)                   ; Y
39    (JMPIFEQTO 8 L82)                   ; $INF
42    (GETVALUE&PUSH 1)                   ; Y
44    (JMPIFEQTO 10 L85)                  ; $MINF
47    (GETVALUE 12)                       ; $TRIGSIGN
49    (JMPIFNOT L56)
51    (GETVALUE&PUSH 1)                   ; Y
53    (CALL1&JMPIF 13 L88)                ; MMINUSP*
56    L56
56    (CONST&PUSH 16)                     ; (%ERF)
57    (GETVALUE&PUSH 1)                   ; Y
59    (LIST&PUSH 2)
61    (GETVALUE&PUSH 0)                   ; X
63    (CALL2 17)                          ; EQTEST
65    L65
65    (UNBIND 2)
67    (SKIP&RET 4)
69    L69
69    (GETVALUE 1)                        ; Y
71    (JMP L65)
73    L73
73    (GETVALUE&PUSH 1)                   ; Y
75    (CONST&PUSH 6)                      ; 1.0
76    (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
78    (CALL1 7)                           ; ERF
80    (JMP L65)
82    L82
82    (CONST 9)                           ; 1
83    (JMP L65)
85    L85
85    (CONST 11)                          ; -1
86    (JMP L65)
88    L88
88    (CONST&PUSH 14)                     ; (%ERF SIMP)
89    (GETVALUE&PUSH 1)                   ; Y
91    (CALL1&PUSH 15)                     ; NEG
93    (LIST&PUSH 2)
95    (CALL1 15)                          ; NEG
97    (JMP L65)


Disassembly of function #:|(DEFMFUN ERF (Y) ...)-27|
(CONST 0) = ERF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ERF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ERF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ERF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ERF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ERF
8     (SKIP&RET 1)


Disassembly of function ERF
(CONST 0) = Y
(CONST 1) = 1.0
(CONST 2) = SLATEC:DERF
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (Y)
8 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; Y
3     (GETVALUE&PUSH 0)                   ; Y
5     (CONST&PUSH 1)                      ; 1.0
6     (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
8     (CALL1 2)                           ; SLATEC:DERF
10    (UNBIND1)
11    (SKIP&RET 2)


Disassembly of function #:|(DEFMFUN ERFC (Y) ...)-28|
(CONST 0) = ERFC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ERFC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ERFC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ERFC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ERFC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ERFC
8     (SKIP&RET 1)


Disassembly of function ERFC
(CONST 0) = Y
(CONST 1) = 1.0
(CONST 2) = SLATEC:DERFC
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (Y)
8 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; Y
3     (GETVALUE&PUSH 0)                   ; Y
5     (CONST&PUSH 1)                      ; 1.0
6     (CALLS2&PUSH 174)                   ; COMMON-LISP:FLOAT
8     (CALL1 2)                           ; SLATEC:DERFC
10    (UNBIND1)
11    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE EMATRIX))-29|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN $ZEROMATRIX (M N) ...)-30|
(CONST 0) = $ZEROMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $ZEROMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $ZEROMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $ZEROMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $ZEROMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $ZEROMATRIX
8     (SKIP&RET 1)


Disassembly of function $ZEROMATRIX
(CONST 0) = 0
(CONST 1) = 1
(CONST 2) = $EMATRIX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (LOAD&PUSH 2)
1     (LOAD&PUSH 2)
2     (CONST&PUSH 0)                      ; 0
3     (CONST&PUSH 1)                      ; 1
4     (CONST&PUSH 1)                      ; 1
5     (CALL 5 2)                          ; $EMATRIX
8     (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN $EMATRIX (M N VAR ...) ...)-31|
(CONST 0) = $EMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $EMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $EMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $EMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $EMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $EMATRIX
8     (SKIP&RET 1)


Disassembly of function $EMATRIX
(CONST 0) = VAR
(CONST 1) = 0
(CONST 2) = ($MATRIX SIMP)
(CONST 3) = FIXNUMP
(CONST 4) = ($MATRIX SIMP)
(CONST 5) = LIST-OF-MLISTS
(CONST 6) = "Incorrect argument to EMATRIX:~%~M"
(CONST 7) = (MLIST SIMP)
(CONST 8) = MERROR
(CONST 9) = ONEN
(CONST 10) = ($MATRIX)
(CONST 11) = MXC
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
90 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; VAR
3     (PUSH-NIL 2)
5     (LOAD&PUSH 10)
6     (JMPIFEQTO 1 L76)                   ; 0
10    (LOAD&PUSH 9)
11    (JMPIFNOTEQTO 1 L24)                ; 0
14    (LOAD&PUSH 10)
15    (CALL1&JMPIFNOT 3 L24)              ; FIXNUMP
18    (LOAD&PUSH 10)
19    (CONST&PUSH 1)                      ; 0
20    (CALLSR&JMPIF 1 48 L80)             ; >
24    L24
24    (LOAD&PUSH 10)
25    (CALL1&JMPIFNOT 3 L64)              ; FIXNUMP
28    (LOAD&PUSH 9)
29    (CALL1&JMPIFNOT 3 L64)              ; FIXNUMP
32    (LOAD&PUSH 7)
33    (CALL1&JMPIFNOT 3 L64)              ; FIXNUMP
36    (LOAD&PUSH 6)
37    (CALL1&JMPIFNOT 3 L64)              ; FIXNUMP
40    (LOAD&PUSH 10)
41    (CONST&PUSH 1)                      ; 0
42    (CALLSR&JMPIFNOT 1 48 L64)          ; >
46    (LOAD&PUSH 9)
47    (CONST&PUSH 1)                      ; 0
48    (CALLSR&JMPIFNOT 1 48 L64)          ; >
52    (LOAD&PUSH 7)
53    (CONST&PUSH 1)                      ; 0
54    (CALLSR&JMPIFNOT 1 48 L64)          ; >
58    (LOAD&PUSH 6)
59    (CONST&PUSH 1)                      ; 0
60    (CALLSR&JMPIF 1 48 L118)            ; >
64    L64
64    (CONST&PUSH 6)                      ; "Incorrect argument to EMATRIX:~%~M"
65    (CONST&PUSH 7)                      ; (MLIST SIMP)
66    (LOAD&PUSH 12)
67    (LOAD&PUSH 12)
68    (LOAD&PUSH 11)
69    (LOAD&PUSH 11)
70    (LIST&PUSH 5)
72    (CALL2 8)                           ; MERROR
74    (JMP L118)
76    L76
76    (CONST&PUSH 2)                      ; ($MATRIX SIMP)
77    (NIL)
78    (JMP L132)
80    L80
80    (CONST&PUSH 4)                      ; ($MATRIX SIMP)
81    (LOAD&PUSH 11)
82    (CALL1 5)                           ; LIST-OF-MLISTS
84    (JMP L132)
86    L86
86    (LOAD&PUSH 6)
87    (LOAD&PUSH 10)
88    (GETVALUE&PUSH 0)                   ; VAR
90    (CONST&PUSH 1)                      ; 0
91    (CALL 4 9)                          ; ONEN
94    (STORE 0)
95    (JMP L113)
97    L97
97    (NIL&STORE 0)
99    (LOAD&PUSH 9)
100   (JMP L107)
102   L102
102   (CONST&PUSH 1)                      ; 0
103   (LOAD&CONS&STORE 1)
105   (LOAD&DEC&STORE 0)
107   L107
107   (LOAD&PUSH 0)
108   (CALLS2&JMPIFNOT 145 L102)          ; ZEROP
111   (SKIP 1)
113   L113
113   (LOAD&PUSH 0)
114   (LOAD&CONS&STORE 1)
116   (LOAD&DEC&STORE 10)
118   L118
118   (LOAD&PUSH 10)
119   (LOAD&PUSH 8)
120   (CALLSR&JMPIF 1 45 L86)             ; =
124   (LOAD&PUSH 10)
125   (CALLS2&JMPIFNOT 145 L97)           ; ZEROP
128   (CONST&PUSH 10)                     ; ($MATRIX)
129   (LOAD&PUSH 2)
130   (CALL1 11)                          ; MXC
132   L132
132   (CONS)
133   (SKIP 2)
135   (UNBIND1)
136   (SKIP&RET 6)


Disassembly of function #:|(DEFUN LIST-OF-MLISTS (N) ...)-32|
(CONST 0) = LIST-OF-MLISTS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIST-OF-MLISTS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIST-OF-MLISTS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIST-OF-MLISTS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIST-OF-MLISTS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIST-OF-MLISTS
8     (SKIP&RET 1)


Disassembly of function LIST-OF-MLISTS
(CONST 0) = 0
(CONST 1) = (MLIST SIMP)
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
15 byte-code instructions:
0     (LOAD&PUSH 1)
1     (NIL&PUSH)
2     (JMP L11)
4     L4
4     (LOAD&DEC&STORE 1)
6     (CONST&PUSH 1)                      ; (MLIST SIMP)
7     (NIL)
8     (CONS&PUSH)
9     (LOAD&CONS&STORE 0)
11    L11
11    (LOAD&PUSH 1)
12    (CONST&PUSH 0)                      ; 0
13    (CALLSR&JMPIFNOT 1 45 L4)           ; =
17    (POP)
18    (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE COEFM) (SPECIAL $RATMX))-33|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN $COEFMATRIX (EQL VARL) ...)-34|
(CONST 0) = $COEFMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $COEFMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $COEFMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $COEFMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $COEFMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $COEFMATRIX
8     (SKIP&RET 1)


Disassembly of function $COEFMATRIX
(CONST 0) = COEFMATRIX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (LOAD&PUSH 2)
1     (LOAD&PUSH 2)
2     (NIL&PUSH)
3     (CALL 3 0)                          ; COEFMATRIX
6     (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN $AUGCOEFMATRIX (EQL VARL) ...)-35|
(CONST 0) = $AUGCOEFMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $AUGCOEFMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $AUGCOEFMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $AUGCOEFMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $AUGCOEFMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $AUGCOEFMATRIX
8     (SKIP&RET 1)


Disassembly of function $AUGCOEFMATRIX
(CONST 0) = COEFMATRIX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (LOAD&PUSH 2)
1     (LOAD&PUSH 2)
2     (T&PUSH)
3     (CALL 3 0)                          ; COEFMATRIX
6     (SKIP&RET 3)


Disassembly of function #:|(DEFUN COEFMATRIX (EQL VARL IND) ...)-36|
(CONST 0) = COEFMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COEFMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COEFMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COEFMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COEFMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COEFMATRIX
8     (SKIP&RET 1)


Disassembly of function COEFMATRIX
(CONST 0) = $LISTP
(CONST 1) = $COEFMATRIX
(CONST 2) = IMPROPER-ARG-ERR
(CONST 3) = (MPLUS MTIMES)
(CONST 4) = MEMQ
(CONST 5) = "Improper variable to COEFMATRIX:~%~M"
(CONST 6) = MERROR
(CONST 7) = MEQHK
(CONST 8) = ($MATRIX)
(CONST 9) = MXC
(CONST 10) = CONST1
(CONST 11) = RATCOEF
(CONST 12) = $RATMX
(CONST 13) = RATDISREP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: ($RATMX)
78 byte-code instructions:
0     (PUSH-NIL 5)
2     (LOAD&PUSH 8)
3     (CALL1&JMPIF 0 L10)                 ; $LISTP
6     (LOAD&PUSH 8)
7     (CONST&PUSH 1)                      ; $COEFMATRIX
8     (CALL2 2)                           ; IMPROPER-ARG-ERR
10    L10
10    (LOAD&PUSH 7)
11    (CALL1&JMPIF 0 L18)                 ; $LISTP
14    (LOAD&PUSH 7)
15    (CONST&PUSH 1)                      ; $COEFMATRIX
16    (CALL2 2)                           ; IMPROPER-ARG-ERR
18    L18
18    (LOAD&CDR&PUSH 7)
20    (NIL&PUSH)
21    (JMP L45)
23    L23
23    (LOAD 0)
24    (JMP L101)
27    L27
27    (LOAD&CAR&STORE 1 0)
30    (JMPIFATOM L43)
32    (LOAD 0)
33    (CAR)
34    (CAR&PUSH)
35    (CONST&PUSH 3)                      ; (MPLUS MTIMES)
36    (CALL2&JMPIFNOT 4 L43)              ; MEMQ
39    (CONST&PUSH 5)                      ; "Improper variable to COEFMATRIX:~%~M"
40    (LOAD&PUSH 1)
41    (CALL2 6)                           ; MERROR
43    L43
43    (LOAD&CDR&STORE 1)
45    L45
45    (LOAD&PUSH 1)
46    (CALLS1&JMPIFNOT 146 L27)           ; ENDP
49    (SKIP 2)
51    (CONST&SYMBOL-FUNCTION&PUSH 7)      ; MEQHK
53    (LOAD&CDR&PUSH 9)
55    (CALLSR&PUSH 0 22)                  ; MAPCAR
58    (CALLS2&STORE 73 8)                 ; NREVERSE
61    (LOAD&CDR&PUSH 7)
63    (CALLS2&STORE 72 7)                 ; REVERSE
66    (LOAD&JMPIFNOT 8 L114)
69    L69
69    (LOAD&CAR&STORE 8 2)
72    (LOAD&CDR&STORE 8)
74    (NIL&STORE 3)
76    (LOAD&JMPIFNOT 6 L85)
79    (LOAD&PUSH 2)
80    (LOAD&PUSH 8)
81    (CALL2&PUSH 10)                     ; CONST1
83    (LOAD&CONS&STORE 3)
85    L85
85    (LOAD 7)
86    (STORE 1)
87    L87
87    (LOAD&PUSH 2)
88    (LOAD&CAR&PUSH 2)
90    (CALL2 11)                          ; RATCOEF
92    (STORE 0)
93    (GETVALUE 12)                       ; $RATMX
95    (JMPIF L23)
98    (LOAD&PUSH 0)
99    (CALL1 13)                          ; RATDISREP
101   L101
101   (PUSH)
102   (LOAD&CONS&STORE 3)
104   (LOAD&CDR&STORE 1)
106   (JMPIF L87)
108   (LOAD&PUSH 3)
109   (LOAD&CONS&STORE 4)
111   (LOAD&JMPIF 8 L69)
114   L114
114   (CONST&PUSH 8)                      ; ($MATRIX)
115   (LOAD&PUSH 5)
116   (CALL1 9)                           ; MXC
118   (CONS)
119   (SKIP&RET 9)


Disassembly of function #:|(DEFUN CONST1 (E VARL) ...)-37|
(CONST 0) = CONST1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CONST1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CONST1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CONST1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CONST1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CONST1
8     (SKIP&RET 1)


Disassembly of function CONST1
(CONST 0) = 0
(CONST 1) = MAXIMA-SUBSTITUTE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
17 byte-code instructions:
0     (LOAD&PUSH 1)
1     (NIL&PUSH)
2     (JMP L16)
4     L4
4     (LOAD&CAR&STORE 1 0)
7     (CONST&PUSH 0)                      ; 0
8     (LOAD&PUSH 1)
9     (LOAD&PUSH 6)
10    (CALL 3 1)                          ; MAXIMA-SUBSTITUTE
13    (STORE 4)
14    (LOAD&CDR&STORE 1)
16    L16
16    (LOAD&PUSH 1)
17    (CALLS1&JMPIFNOT 146 L4)            ; ENDP
20    (SKIP 2)
22    (LOAD 2)
23    (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE ENTERM))-38|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN $ENTERMATRIX (ROWS COLUMNS) ...)-39|
(CONST 0) = $ENTERMATRIX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $ENTERMATRIX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $ENTERMATRIX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $ENTERMATRIX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $ENTERMATRIX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $ENTERMATRIX
8     (SKIP&RET 1)


Disassembly of function $ENTERMATRIX
(CONST 0) = FIXNUMP
(CONST 1) = "ENTERMATRIX called with non-integer arguments"
(CONST 2) = MERROR
(CONST 3) = 0
(CONST 4) = 
"
Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4 : "
(CONST 5) = RETRIEVE
(CONST 6) = (1 2 3 4)
(CONST 7) = ZL-MEMBER
(CONST 8) = #<COMPILED-CLOSURE $ENTERMATRIX-1>
(CONST 9) = *STANDARD-OUTPUT*
(CONST 10) = ($MATRIX)
(CONST 11) = MXC
(CONST 12) = 1
(CONST 13) = "Row "
(CONST 14) = " Column "
(CONST 15) = ":  "
(CONST 16) = MEVAL
(CONST 17) = ONEN
(CONST 18) = 2
(CONST 19) = CAR
(CONST 20) = CDR
(CONST 21) = 3
(CONST 22) = NEG
(CONST 23) = "Row "
(CONST 24) = " Column "
(CONST 25) = ":  "
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*STANDARD-OUTPUT*)
158 byte-code instructions:
0     (PUSH-NIL 6)
2     (LOAD&PUSH 8)
3     (CALL1&JMPIFNOT 0 L10)              ; FIXNUMP
6     (LOAD&PUSH 7)
7     (CALL1&JMPIF 0 L13)                 ; FIXNUMP
10    L10
10    (CONST&PUSH 1)                      ; "ENTERMATRIX called with non-integer arguments"
11    (CALL1 2)                           ; MERROR
13    L13
13    (CONST 3)                           ; 0
14    (STORE 5)
15    (LOAD&PUSH 8)
16    (LOAD&PUSH 8)
17    (CALLSR&JMPIF 1 45 L70)             ; =
21    (NIL&STORE 1)
23    L23
23    (LOAD&INC&STORE 5)
25    (PUSH)
26    (LOAD&PUSH 9)
27    (CALLSR&JMPIF 1 48 L242)            ; >
32    (LOAD&PUSH 1)
33    (JMPIFEQTO 12 L87)                  ; 1
36    (LOAD&PUSH 1)
37    (JMPIFEQTO 18 L130)                 ; 2
41    (LOAD&PUSH 1)
42    (JMPIFEQTO 21 L163)                 ; 3
46    (CONST 3)                           ; 0
47    (STORE 4)
48    (NIL&STORE 3)
50    L50
50    (LOAD&INC&STORE 4)
52    (PUSH)
53    (LOAD&PUSH 8)
54    (CALLSR&JMPIFNOT 1 48 L201)         ; >
59    (LOAD&PUSH 2)
60    (LOAD 4)
61    L61
61    (PUSH)
62    (NIL)
63    (CONS&PUSH)
64    (CALLSR&STORE 2 35 2)               ; NCONC
68    (JMP L23)
70    L70
70    (CONST&PUSH 4)                      ; "
Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4 : "
71    (PUSH-UNBOUND 1)
73    (CALLS1 132)                        ; PRINC
75    (PUSH-NIL 2)
77    (CALL2 5)                           ; RETRIEVE
79    (STORE 1)
80    (PUSH)
81    (CONST&PUSH 6)                      ; (1 2 3 4)
82    (CALL2&JMPIFNOT 7 L70)              ; ZL-MEMBER
85    (JMP L23)
87    L87
87    (LOAD 5)
88    (STORE 4)
89    (CONST&PUSH 13)                     ; "Row "
90    (PUSH-UNBOUND 1)
92    (CALLS1 132)                        ; PRINC
94    (LOAD&PUSH 5)
95    (PUSH-UNBOUND 1)
97    (CALLS1 132)                        ; PRINC
99    (CONST&PUSH 14)                     ; " Column "
100   (PUSH-UNBOUND 1)
102   (CALLS1 132)                        ; PRINC
104   (LOAD&PUSH 4)
105   (PUSH-UNBOUND 1)
107   (CALLS1 132)                        ; PRINC
109   (CONST&PUSH 15)                     ; ":  "
110   (PUSH-UNBOUND 1)
112   (CALLS1 132)                        ; PRINC
114   (LOAD&PUSH 2)
115   (LOAD&PUSH 6)
116   (LOAD&PUSH 9)
117   (PUSH-NIL 2)
119   (CALL2&PUSH 5)                      ; RETRIEVE
121   (CALL1&PUSH 16)                     ; MEVAL
123   (CONST&PUSH 3)                      ; 0
124   (CALL 4 17)                         ; ONEN
127   (JMP L61)
130   L130
130   (LOAD&PUSH 5)
131   (CALLS2&STORE 151 4)                ; 1-
134   (LOAD&PUSH 5)
135   (JMPIFEQTO 12 L50)                  ; 1
139   (LOAD&PUSH 4)
140   (LOAD&PUSH 4)
141   (CALLS1&PUSH 155)                   ; NTHCDR
143   (LOAD&CONS&STORE 0)
145   (CONST&PUSH 19)                     ; CAR
146   (LOAD&PUSH 1)
147   (CALLSR&PUSH 0 22)                  ; MAPCAR
150   (CALLS2&STORE 73 3)                 ; NREVERSE
153   (CONST 20)                          ; CDR
154   (JMP L192)
156   L156
156   (CONST&PUSH 3)                      ; 0
157   (NIL)
158   (CONS)
159   (STORE 3)
160   (JMP L50)
163   L163
163   (LOAD 5)
164   (STORE 4)
165   (PUSH)
166   (JMPIFEQTO 12 L156)                 ; 1
169   (CONST&PUSH 22)                     ; NEG
170   (LOAD&DEC&PUSH 5)
172   (LOAD&PUSH 5)
173   (CALLS1&PUSH 155)                   ; NTHCDR
175   (CALLSR&PUSH 0 22)                  ; MAPCAR
178   (LOAD&CONS&STORE 0)
180   (CONST&PUSH 19)                     ; CAR
181   (LOAD&PUSH 1)
182   (CALLSR&PUSH 0 22)                  ; MAPCAR
185   (CONST&PUSH 3)                      ; 0
186   (NIL)
187   (CONS&PUSH)
188   (CALLS1&STORE 163 3)                ; NRECONC
191   (CONST 20)                          ; CDR
192   L192
192   (PUSH)
193   (LOAD&PUSH 1)
194   (CALLSR&STORE 0 22 0)               ; MAPCAR
198   (JMP L50)
201   L201
201   (CONST&PUSH 23)                     ; "Row "
202   (PUSH-UNBOUND 1)
204   (CALLS1 132)                        ; PRINC
206   (LOAD&PUSH 5)
207   (PUSH-UNBOUND 1)
209   (CALLS1 132)                        ; PRINC
211   (CONST&PUSH 24)                     ; " Column "
212   (PUSH-UNBOUND 1)
214   (CALLS1 132)                        ; PRINC
216   (LOAD&PUSH 4)
217   (PUSH-UNBOUND 1)
219   (CALLS1 132)                        ; PRINC
221   (CONST&PUSH 25)                     ; ":  "
222   (PUSH-UNBOUND 1)
224   (CALLS1 132)                        ; PRINC
226   (LOAD&PUSH 3)
227   (PUSH-NIL 2)
229   (CALL2&PUSH 5)                      ; RETRIEVE
231   (CALL1&PUSH 16)                     ; MEVAL
233   (NIL)
234   (CONS&PUSH)
235   (CALLSR&STORE 2 35 3)               ; NCONC
239   (JMP L50)
242   L242
242   (CONST&PUSH 8)                      ; #<COMPILED-CLOSURE $ENTERMATRIX-1>
243   (GETVALUE&PUSH 9)                   ; *STANDARD-OUTPUT*
245   (CALLSR 1 21)                       ; FUNCALL
248   (CONST&PUSH 10)                     ; ($MATRIX)
249   (LOAD&PUSH 3)
250   (CALL1 11)                          ; MXC
252   (CONS)
253   (SKIP&RET 9)


Disassembly of function $ENTERMATRIX-1
(CONST 0) = 
"
Matrix entered.
"
1 required argument
0 optional arguments
Rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; "
Matrix entered.
"
1     (LOAD&PUSH 3)
2     (PUSH-UNBOUND 2)
4     (CALLS1 137)                        ; WRITE-STRING
6     (LOAD 1)
7     (SKIP&RET 3)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE XTHRU) (SPECIAL SN* SD* ...))-40|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMFUN $XTHRU (E) ...)-41|
(CONST 0) = $XTHRU
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $XTHRU>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $XTHRU
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $XTHRU
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $XTHRU>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $XTHRU
8     (SKIP&RET 1)


Disassembly of function $XTHRU
(CONST 0) = MTIMESP
(CONST 1) = $XTHRU
(CONST 2) = MULN
(CONST 3) = MPLUSP
(CONST 4) = COMDENOM
(CONST 5) = SIMPLIFY
(CONST 6) = MEXPTP
(CONST 7) = POWER
(CONST 8) = (MEQUAL MLIST $MATRIX)
(CONST 9) = MEMQ
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
50 byte-code instructions:
0     L0
0     (LOAD 1)
1     (JMPIFATOM L22)
3     (LOAD&PUSH 1)
4     (CALL1&JMPIF 0 L25)                 ; MTIMESP
7     (LOAD&PUSH 1)
8     (CALL1&JMPIF 3 L36)                 ; MPLUSP
11    (LOAD&PUSH 1)
12    (CALL1&JMPIF 6 L49)                 ; MEXPTP
15    (LOAD 1)
16    (CAR)
17    (CAR&PUSH)
18    (CONST&PUSH 8)                      ; (MEQUAL MLIST $MATRIX)
19    (CALL2&JMPIF 9 L62)                 ; MEMQ
22    L22
22    (LOAD 1)
23    (SKIP&RET 2)
25    L25
25    (CONST&PUSH 1)                      ; $XTHRU
26    (LOAD&CDR&PUSH 2)
28    (CALLSR&PUSH 0 22)                  ; MAPCAR
31    (NIL&PUSH)
32    (CALL2 2)                           ; MULN
34    (SKIP&RET 2)
36    L36
36    (CONST&PUSH 1)                      ; $XTHRU
37    (LOAD&CDR&PUSH 2)
39    (CALLSR&PUSH 0 22)                  ; MAPCAR
42    (T&PUSH)
43    (CALL2&PUSH 4)                      ; COMDENOM
45    (CALL1 5)                           ; SIMPLIFY
47    (SKIP&RET 2)
49    L49
49    (LOAD 1)
50    (CDR)
51    (CAR&PUSH)
52    (JSR&PUSH L0)
54    (LOAD 2)
55    (CDR)
56    (CDR)
57    (CAR&PUSH)
58    (CALL2 7)                           ; POWER
60    (SKIP&RET 2)
62    L62
62    (LOAD&CAR&PUSH 1)
64    (CONST&PUSH 1)                      ; $XTHRU
65    (LOAD&CDR&PUSH 3)
67    (CALLSR 0 22)                       ; MAPCAR
70    (CONS)
71    (SKIP&RET 2)


Disassembly of function #:|(DEFUN COMDENOM (L IND) ...)-42|
(CONST 0) = COMDENOM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COMDENOM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COMDENOM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COMDENOM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COMDENOM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COMDENOM
8     (SKIP&RET 1)


Disassembly of function COMDENOM
(CONST 0) = PRODNUMDEN
(CONST 1) = SN*
(CONST 2) = MULN
(CONST 3) = SD*
(CONST 4) = RSN*
(CONST 5) = $RATSIMP
(CONST 6) = DIV*
(CONST 7) = COMDENOM1
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (RSN* SD* SN*)
writes special variables : (SD* SN*)
56 byte-code instructions:
0     (PUSH-NIL 2)
2     (LOAD&CAR&PUSH 4)
4     (CALL1 0)                           ; PRODNUMDEN
6     (GETVALUE&PUSH 1)                   ; SN*
8     (NIL&PUSH)
9     (CALL2 2)                           ; MULN
11    (STORE 1)
12    (NIL)
13    (SETVALUE 1)                        ; SN*
15    (GETVALUE&PUSH 3)                   ; SD*
17    (NIL&PUSH)
18    (CALL2 2)                           ; MULN
20    (STORE 0)
21    (NIL)
22    (SETVALUE 3)                        ; SD*
24    L24
24    (LOAD&CDR&STORE 4)
26    (JMPIFNOT L72)
28    (LOAD&CAR&PUSH 4)
30    (CALL1 0)                           ; PRODNUMDEN
32    (LOAD&PUSH 1)
33    (LOAD&PUSH 1)
34    (GETVALUE&PUSH 1)                   ; SN*
36    (NIL&PUSH)
37    (CALL2&PUSH 2)                      ; MULN
39    (GETVALUE&PUSH 3)                   ; SD*
41    (NIL&PUSH)
42    (CALL2&PUSH 2)                      ; MULN
44    (CALL 4 7)                          ; COMDENOM1
47    (STORE 0)
48    (CAR)
49    (STORE 1)
50    (LOAD 0)
51    (CDR)
52    (CAR)
53    (STORE 0)
54    (JMP L24)
56    L56
56    (LOAD&PUSH 1)
57    (CALL1 5)                           ; $RATSIMP
59    (JMP L66)
61    L61
61    (GETVALUE 4)                        ; RSN*
63    (JMPIF L56)
65    (LOAD 1)
66    L66
66    (PUSH)
67    (LOAD&PUSH 1)
68    (CALL2 6)                           ; DIV*
70    (SKIP&RET 5)
72    L72
72    (LOAD&JMPIF 3 L61)
75    (LOAD&PUSH 1)
76    (LOAD&PUSH 1)
77    (LIST 2)
79    (SKIP&RET 5)


Disassembly of function #:|(DEFUN PRODNUMDEN (E) ...)-43|
(CONST 0) = PRODNUMDEN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PRODNUMDEN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRODNUMDEN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PRODNUMDEN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PRODNUMDEN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PRODNUMDEN
8     (SKIP&RET 1)


Disassembly of function PRODNUMDEN
(CONST 0) = PRODND
(CONST 1) = MTIMES
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
17 byte-code instructions:
0     (LOAD 1)
1     (JMPIFATOM L9)
3     (LOAD 1)
4     (CAR)
5     (CAR&PUSH)
6     (JMPIFEQTO 1 L17)                   ; MTIMES
9     L9
9     (LOAD&PUSH 1)
10    (LIST 1)
12    L12
12    (PUSH)
13    (CALL1 0)                           ; PRODND
15    (SKIP&RET 2)
17    L17
17    (LOAD 1)
18    (CDR)
19    (JMP L12)


Disassembly of function #:|(DEFUN PRODND (L) ...)-44|
(CONST 0) = PRODND
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PRODND>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRODND
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PRODND
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PRODND>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PRODND
8     (SKIP&RET 1)


Disassembly of function PRODND
(CONST 0) = SN*
(CONST 1) = SD*
(CONST 2) = RATNUMP
(CONST 3) = 1
(CONST 4) = MEXPT
(CONST 5) = MNEGP
(CONST 6) = -1
(CONST 7) = TIMESK
(CONST 8) = POWER
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SD* SN*)
writes special variables : (SD* SN*)
66 byte-code instructions:
0     (NIL&PUSH)
1     (LOAD&PUSH 2)
2     (CALLS2&STORE 72 2)                 ; REVERSE
5     (NIL)
6     (SETVALUE 0)                        ; SN*
8     (SETVALUE 1)                        ; SD*
10    (LOAD&JMPIFNOT 2 L46)
13    L13
13    (LOAD&CAR&STORE 2 0)
16    (JMPIFATOM L35)
18    (LOAD&PUSH 0)
19    (CALL1&JMPIF 2 L49)                 ; RATNUMP
22    (LOAD 0)
23    (CAR)
24    (CAR&PUSH)
25    (JMPIFNOTEQTO 4 L35)                ; MEXPT
28    (LOAD 0)
29    (CDR)
30    (CDR)
31    (CAR&PUSH)
32    (CALL1&JMPIF 5 L69)                 ; MNEGP
35    L35
35    (LOAD&PUSH 0)
36    (GETVALUE 0)                        ; SN*
38    (CONS)
39    (SETVALUE 0)                        ; SN*
41    L41
41    (LOAD&CDR&STORE 2)
43    (LOAD&JMPIF 2 L13)
46    L46
46    (NIL)
47    (SKIP&RET 3)
49    L49
49    (LOAD 0)
50    (CDR)
51    (CAR&PUSH)
52    (JMPIFEQTO 3 L63)                   ; 1
55    (LOAD 0)
56    (CDR)
57    (CAR&PUSH)
58    (GETVALUE 0)                        ; SN*
60    (CONS)
61    (SETVALUE 0)                        ; SN*
63    L63
63    (LOAD 0)
64    (CDR)
65    (CDR)
66    (CAR)
67    (JMP L81)
69    L69
69    (LOAD 0)
70    (CDR)
71    (CAR&PUSH)
72    (CONST&PUSH 6)                      ; -1
73    (LOAD 2)
74    (CDR)
75    (CDR)
76    (CAR&PUSH)
77    (CALL2&PUSH 7)                      ; TIMESK
79    (CALL2 8)                           ; POWER
81    L81
81    (PUSH)
82    (GETVALUE 1)                        ; SD*
84    (CONS)
85    (SETVALUE 1)                        ; SD*
87    (JMP L41)


Disassembly of function #:|(DEFUN COMDENOM1 (A B C ...) ...)-45|
(CONST 0) = COMDENOM1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COMDENOM1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COMDENOM1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COMDENOM1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COMDENOM1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COMDENOM1
8     (SKIP&RET 1)


Disassembly of function COMDENOM1
(CONST 0) = DIV*
(CONST 1) = PRODNUMDEN
(CONST 2) = SN*
(CONST 3) = MULN
(CONST 4) = SD*
(CONST 5) = MUL*
(CONST 6) = ADD2
(CONST 7) = MUL2
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SD* SN*)
writes special variables : (SD* SN*)
29 byte-code instructions:
0     (PUSH-NIL 2)
2     (LOAD&PUSH 5)
3     (LOAD&PUSH 4)
4     (CALL2&PUSH 0)                      ; DIV*
6     (CALL1 1)                           ; PRODNUMDEN
8     (GETVALUE&PUSH 2)                   ; SN*
10    (NIL&PUSH)
11    (CALL2 3)                           ; MULN
13    (STORE 1)
14    (NIL)
15    (SETVALUE 2)                        ; SN*
17    (GETVALUE&PUSH 4)                   ; SD*
19    (NIL&PUSH)
20    (CALL2 3)                           ; MULN
22    (STORE 0)
23    (NIL)
24    (SETVALUE 4)                        ; SD*
26    (LOAD&PUSH 6)
27    (LOAD&PUSH 1)
28    (CALL2&PUSH 5)                      ; MUL*
30    (LOAD&PUSH 5)
31    (LOAD&PUSH 3)
32    (CALL2&PUSH 5)                      ; MUL*
34    (CALL2&PUSH 6)                      ; ADD2
36    (LOAD&PUSH 4)
37    (LOAD&PUSH 3)
38    (CALL2&PUSH 7)                      ; MUL2
40    (LIST 2)
42    (SKIP&RET 7)


Disassembly of function #:|(DECLARE-TOP (SPLITFILE XRTOUT) (SPECIAL $GLOBALSOLVE $BACKSUBST ...) ...)-46|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN XRUTOUT (AX N M ...) ...)-47|
(CONST 0) = XRUTOUT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE XRUTOUT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; XRUTOUT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; XRUTOUT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE XRUTOUT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; XRUTOUT
8     (SKIP&RET 1)


Disassembly of function XRUTOUT
(CONST 0) = AX
(CONST 1) = $BACKSUBST
(CONST 2) = $LINSOLVE_PARAMS
(CONST 3) = SOL
(CONST 4) = GET-ARRAY-POINTER
(CONST 5) = 0
(CONST 6) = (MLIST)
(CONST 7) = $%RNUM_LIST
(CONST 8) = (MLIST)
(CONST 9) = MAKE-PARAM
(CONST 10) = ITH
(CONST 11) = RFORM
(CONST 12) = RATTIMES
(CONST 13) = RATDIF
(CONST 14) = RATQUOTIENT
(CONST 15) = *MOSESFLAG
(CONST 16) = $GLOBALSOLVE
(CONST 17) = (MSETQ)
(CONST 18) = (MEQUAL)
(CONST 19) = RDIS
(CONST 20) = SIMPLIFY
(CONST 21) = MEVAL
(CONST 22) = $DISPFLAG
(CONST 23) = "Solution~%"
(CONST 24) = MTELL
(CONST 25) = (MLIST)
(CONST 26) = $LINECHAR
(CONST 27) = CHECKLABEL
(CONST 28) = (MLABLE)
(CONST 29) = $LINENUM
(CONST 30) = $NOLABELS
(CONST 31) = MAKELABEL
(CONST 32) = LINELABLE
(CONST 33) = SET
(CONST 34) = RUNTIME
(CONST 35) = DISPLA
(CONST 36) = TIMEORG
(CONST 37) = NODISP
(CONST 38) = PUTPROP
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: 
(SOL $LINENUM $LINECHAR $DISPFLAG LINELABLE $NOLABELS $GLOBALSOLVE *MOSESFLAG
 AX $LINSOLVE_PARAMS $BACKSUBST)
writes special variables : ($LINENUM SOL $%RNUM_LIST AX)
272 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; AX
3     (GETVALUE 1)                        ; $BACKSUBST
5     (JMPIFNOT L9)
7     (GETVALUE 2)                        ; $LINSOLVE_PARAMS
9     L9
9     (BIND 2)                            ; $LINSOLVE_PARAMS
11    (PUSH-NIL 5)
13    (NIL)
14    (BIND 3)                            ; SOL
16    (PUSH-NIL 3)
18    (GETVALUE&PUSH 0)                   ; AX
20    (CALL1 4)                           ; GET-ARRAY-POINTER
22    (SETVALUE 0)                        ; AX
24    (CONST 5)                           ; 0
25    (STORE 2)
26    (GETVALUE 2)                        ; $LINSOLVE_PARAMS
28    (JMPIFNOT L35)
30    (CONST&PUSH 6)                      ; (MLIST)
31    (LIST 1)
33    (SETVALUE 7)                        ; $%RNUM_LIST
35    L35
35    (LOAD&PUSH 20)
36    (CALLS2&STORE 151 6)                ; 1-
39    (PUSH)
40    (LOAD&PUSH 22)
41    (CALLSR&STORE 1 52 9)               ; MIN
45    (PUSH)
46    (LOAD&PUSH 20)
47    (CALLS2&PUSH 71)                    ; LENGTH
49    (CALLSR&STORE 1 51 10)              ; MAX
53    (JMP L338)
56    L56
56    (CONST&PUSH 8)                      ; (MLIST)
57    (LOAD 8)
58    (CONS)
59    (JMP L445)
62    L62
62    (CALL0 9)                           ; MAKE-PARAM
64    (JMP L275)
67    L67
67    (GETVALUE&PUSH 0)                   ; AX
69    (LOAD&PUSH 11)
70    (LOAD&PUSH 22)
71    (CALLSR&STORE 2 1 8)                ; AREF
75    (GETVALUE&PUSH 0)                   ; AX
77    (LOAD&PUSH 0)
78    (LOAD&PUSH 12)
79    (LOAD&PUSH 23)
80    (NIL&PUSH)
81    (CALLSR 2 2)                        ; SYSTEM::STORE
84    (SKIP 1)
86    (LOAD&INC&PUSH 10)
88    (JMP L126)
90    L90
90    (LOAD&PUSH 9)
91    (GETVALUE&PUSH 0)                   ; AX
93    (LOAD&PUSH 13)
94    (LOAD&PUSH 3)
95    (CALLSR&PUSH 2 1)                   ; AREF
98    (GETVALUE&PUSH 0)                   ; AX
100   (CONST&PUSH 5)                      ; 0
101   (LOAD&PUSH 4)
102   (CALLSR&PUSH 2 1)                   ; AREF
105   (T&PUSH)
106   (CALL&PUSH 3 12)                    ; RATTIMES
109   (CALL2 13)                          ; RATDIF
111   (STORE 9)
113   (GETVALUE&PUSH 0)                   ; AX
115   (LOAD&PUSH 0)
116   (LOAD&PUSH 13)
117   (LOAD&PUSH 3)
118   (NIL&PUSH)
119   (CALLSR 2 2)                        ; SYSTEM::STORE
122   (SKIP 1)
124   (LOAD&INC&STORE 0)
126   L126
126   (LOAD&PUSH 0)
127   (LOAD&PUSH 8)
128   (CALLSR&JMPIFNOT 1 48 L90)          ; >
132   (SKIP 1)
134   (GETVALUE&PUSH 0)                   ; AX
136   (LOAD&PUSH 9)
137   (GETVALUE&PUSH 0)                   ; AX
139   (LOAD&PUSH 13)
140   (LOAD&PUSH 14)
141   (CALLSR&PUSH 2 1)                   ; AREF
144   (CALL2&PUSH 14)                     ; RATQUOTIENT
146   (LOAD&PUSH 1)
147   (CONST&PUSH 5)                      ; 0
148   (LOAD&PUSH 14)
149   (LOAD&PUSH 3)
150   (CALLSR 2 2)                        ; SYSTEM::STORE
153   (SKIP 2)
155   (GETVALUE&PUSH 0)                   ; AX
157   (LOAD&PUSH 0)
158   (LOAD&PUSH 12)
159   (LOAD&PUSH 13)
160   (NIL&PUSH)
161   (CALLSR 2 2)                        ; SYSTEM::STORE
164   (SKIP 1)
166   (NIL&STORE 8)
168   (GETVALUE 15)                       ; *MOSESFLAG
170   (JMPIFNOT L296)
173   L173
173   (GETVALUE&PUSH 0)                   ; AX
175   (CONST&PUSH 5)                      ; 0
176   (LOAD&PUSH 12)
177   (CALLSR 2 1)                        ; AREF
180   (JMP L320)
183   L183
183   (CONST 17)                          ; (MSETQ)
184   (JMP L302)
187   L187
187   (GETVALUE&PUSH 0)                   ; AX
189   (LOAD&PUSH 20)
190   (LOAD&PUSH 12)
191   (CALL2&PUSH 10)                     ; ITH
193   (CALL1&PUSH 11)                     ; RFORM
195   (LOAD&PUSH 1)
196   (CONST&PUSH 5)                      ; 0
197   (LOAD&PUSH 14)
198   (LOAD&PUSH 3)
199   (CALLSR 2 2)                        ; SYSTEM::STORE
202   (SKIP 2)
204   (GETVALUE 16)                       ; $GLOBALSOLVE
206   (JMPIFNOT L336)
209   (JMP L332)
212   L212
212   (NIL&STORE 3)
214   (GETVALUE 30)                       ; $NOLABELS
216   (JMPIFNOT L389)
219   (JMP L387)
222   L222
222   (GETVALUE&PUSH 32)                  ; LINELABLE
224   (LOAD&PUSH 4)
225   (CALL2 33)                          ; SET
227   (JMP L409)
230   L230
230   (CALL0 34)                          ; RUNTIME
232   (STORE 3)
233   (PUSH-UNBOUND 1)
235   (CALLS1 139)                        ; TERPRI
237   (LOAD&PUSH 1)
238   (CALL1 35)                          ; DISPLA
240   (LOAD&PUSH 3)
241   (CALL1 36)                          ; TIMEORG
243   (JMP L435)
246   L246
246   (LOAD&PUSH 10)
247   (LOAD&PUSH 10)
248   (CALLSR&JMPIF 1 48 L264)            ; >
252   (GETVALUE&PUSH 0)                   ; AX
254   (LOAD&PUSH 11)
255   (LOAD&PUSH 12)
256   (CALLSR 2 1)                        ; AREF
259   (CAR&PUSH)
260   (JMPIFNOTEQTO 5 L67)                ; 0
264   L264
264   (GETVALUE&PUSH 0)                   ; AX
266   (GETVALUE 2)                        ; $LINSOLVE_PARAMS
268   (JMPIF L62)
271   (LOAD&PUSH 20)
272   (LOAD&PUSH 12)
273   (CALL2 10)                          ; ITH
275   L275
275   (PUSH)
276   (CALL1&PUSH 11)                     ; RFORM
278   (LOAD&PUSH 1)
279   (CONST&PUSH 5)                      ; 0
280   (LOAD&PUSH 14)
281   (LOAD&PUSH 3)
282   (CALLSR 2 2)                        ; SYSTEM::STORE
285   (SKIP 2)
287   (GETVALUE 2)                        ; $LINSOLVE_PARAMS
289   (JMPIFNOT L336)
291   (GETVALUE 15)                       ; *MOSESFLAG
293   (JMPIF L173)
296   L296
296   (GETVALUE 16)                       ; $GLOBALSOLVE
298   (JMPIF L183)
301   (CONST 18)                          ; (MEQUAL)
302   L302
302   (PUSH)
303   (LOAD&PUSH 20)
304   (LOAD&PUSH 12)
305   (CALL2&PUSH 10)                     ; ITH
307   (GETVALUE&PUSH 0)                   ; AX
309   (CONST&PUSH 5)                      ; 0
310   (LOAD&PUSH 14)
311   (CALLSR&PUSH 2 1)                   ; AREF
314   (CALL1&PUSH 19)                     ; RDIS
316   (CALL1&PUSH 20)                     ; SIMPLIFY
318   (LIST 3)
320   L320
320   (PUSH)
321   (LOAD&CONS&STORE 7)
323   (GETVALUE 1)                        ; $BACKSUBST
325   (JMPIFNOT L187)
328   (GETVALUE 16)                       ; $GLOBALSOLVE
330   (JMPIFNOT L336)
332   L332
332   (LOAD&CAR&PUSH 7)
334   (CALL1 21)                          ; MEVAL
336   L336
336   (LOAD&DEC&STORE 10)
338   L338
338   (LOAD&PUSH 10)
339   (CALLS2&JMPIFNOT 145 L246)          ; ZEROP
343   (LOAD&JMPIFNOT 18 L56)
347   (GETVALUE 22)                       ; $DISPFLAG
349   (JMPIFNOT L354)
351   (CONST&PUSH 23)                     ; "Solution~%"
352   (CALL1 24)                          ; MTELL
354   L354
354   (CONST&PUSH 25)                     ; (MLIST)
355   (LIST 1)
357   (SETVALUE 3)                        ; SOL
359   (GETVALUE&PUSH 26)                  ; $LINECHAR
361   (CALL1 27)                          ; CHECKLABEL
363   (STORE 1)
364   (LOAD&PUSH 7)
365   (LOAD&JMPIFNOT 0 L441)
369   L369
369   (LOAD&CAR&STORE 0 1)
372   (CONST&PUSH 28)                     ; (MLABLE)
373   (LOAD&JMPIF 3 L212)
377   (GETVALUE&PUSH 29)                  ; $LINENUM
379   (CALLS2 150)                        ; 1+
381   (SETVALUE 29)                       ; $LINENUM
383   (GETVALUE 30)                       ; $NOLABELS
385   (JMPIFNOT L389)
387   L387
387   (GETVALUE 16)                       ; $GLOBALSOLVE
389   L389
389   (BIND 30)                           ; $NOLABELS
391   (GETVALUE&PUSH 26)                  ; $LINECHAR
393   (CALL1 31)                          ; MAKELABEL
395   (UNBIND1)
396   (GETVALUE&PUSH 32)                  ; LINELABLE
398   (GETVALUE 30)                       ; $NOLABELS
400   (JMPIFNOT L222)
403   (GETVALUE 16)                       ; $GLOBALSOLVE
405   (JMPIFNOT L222)
408   (NIL)
409   L409
409   (PUSH)
410   (LIST 3)
412   (STORE 1)
413   (GETVALUE&PUSH 3)                   ; SOL
415   (GETVALUE&PUSH 32)                  ; LINELABLE
417   (NIL)
418   (CONS&PUSH)
419   (CALLSR 2 35)                       ; NCONC
422   (GETVALUE 22)                       ; $DISPFLAG
424   (JMPIF L230)
427   (GETVALUE&PUSH 32)                  ; LINELABLE
429   (T&PUSH)
430   (CONST&PUSH 37)                     ; NODISP
432   (CALL 3 38)                         ; PUTPROP
435   L435
435   (LOAD&CDR&STORE 0)
437   (LOAD&JMPIF 0 L369)
441   L441
441   (SKIP 1)
443   (GETVALUE 3)                        ; SOL
445   L445
445   (SKIP 3)
447   (UNBIND1)
448   (SKIP 5)
450   (UNBIND 2)
452   (SKIP&RET 6)


Wrote file binary-clisp/csimp2.fas
Wrote file /cygdrive/e/temp/maxima/src/csimp2.lis