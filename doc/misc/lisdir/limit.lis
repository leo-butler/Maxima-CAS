Listing of compilation of file /cygdrive/e/temp/maxima/src/limit.lisp
on 2002-12-17 13:35:21 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/limit.lisp ...

Disassembly of function #:|(IN-PACKAGE "MAXIMA")-1|
(CONST 0) = "MAXIMA"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "MAXIMA"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(MACSYMA-MODULE LIMIT)-2|
(CONST 0) = LIMIT
(CONST 1) = MACSYMA-MODULE
(CONST 2) = (RUNTIME)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT
1     (CONST&PUSH 1)                      ; MACSYMA-MODULE
2     (CONST&PUSH 2)                      ; (RUNTIME)
3     (CALLS2 136)                        ; SYSTEM::%PUT
5     (SKIP&RET 1)


Disassembly of function #:|(DECLARE-TOP (GENPREFIX L) (SPECIAL ERRORSW ERRRJFFLAG ...) ...)-3|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(LOAD-MACSYMA-MACROS RZMAC)-4|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INFINITIES '($INF $MINF $INFINITY) ...)-5-1|
(CONST 0) = INFINITIES
(CONST 1) = *VARIABLE-INITIAL-VALUES*
(CONST 2) = ($INF $MINF $INFINITY)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFINITIES
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; INFINITIES
11    (LOAD&PUSH 1)
12    (CONST&PUSH 2)                      ; ($INF $MINF $INFINITY)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INFINITIES '($INF $MINF $INFINITY) ...)-5-2|
(CONST 0) = (SPECIAL INFINITIES)
(CONST 1) = INFINITIES
(CONST 2) = ($INF $MINF $INFINITY)
(CONST 3) = VARIABLE
(CONST 4) = 
"The types of infinities recognized by Macsyma. 
   INFINITY is complex infinity"
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL INFINITIES)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; INFINITIES
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; INFINITIES
8     (CONST&PUSH 2)                      ; ($INF $MINF $INFINITY)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; INFINITIES
12    (CONST&PUSH 3)                      ; VARIABLE
13    (CONST&PUSH 4)                      ; "The types of infinities recognized by Macsyma. 
   INFINITY is complex infinity"
14    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; INFINITIES
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR REAL-INFINITIES '($INF $MINF) ...)-6-1|
(CONST 0) = REAL-INFINITIES
(CONST 1) = *VARIABLE-INITIAL-VALUES*
(CONST 2) = ($INF $MINF)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; REAL-INFINITIES
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; REAL-INFINITIES
11    (LOAD&PUSH 1)
12    (CONST&PUSH 2)                      ; ($INF $MINF)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR REAL-INFINITIES '($INF $MINF) ...)-6-2|
(CONST 0) = (SPECIAL REAL-INFINITIES)
(CONST 1) = REAL-INFINITIES
(CONST 2) = ($INF $MINF)
(CONST 3) = VARIABLE
(CONST 4) = "The real infinities, INF is positive infinity, MINF negative infinity"
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL REAL-INFINITIES)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; REAL-INFINITIES
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; REAL-INFINITIES
8     (CONST&PUSH 2)                      ; ($INF $MINF)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; REAL-INFINITIES
12    (CONST&PUSH 3)                      ; VARIABLE
13    (CONST&PUSH 4)                      ; "The real infinities, INF is positive infinity, MINF negative infinity"
14    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; REAL-INFINITIES
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INFINITESIMALS '($ZEROA $ZEROB) ...)-7-1|
(CONST 0) = INFINITESIMALS
(CONST 1) = *VARIABLE-INITIAL-VALUES*
(CONST 2) = ($ZEROA $ZEROB)
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFINITESIMALS
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; INFINITESIMALS
11    (LOAD&PUSH 1)
12    (CONST&PUSH 2)                      ; ($ZEROA $ZEROB)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR INFINITESIMALS '($ZEROA $ZEROB) ...)-7-2|
(CONST 0) = (SPECIAL INFINITESIMALS)
(CONST 1) = INFINITESIMALS
(CONST 2) = ($ZEROA $ZEROB)
(CONST 3) = VARIABLE
(CONST 4) = 
"The infinitesimals recognized by Macsyma. ZEROA zero from above,
   ZEROB zero from below"
(CONST 5) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL INFINITESIMALS)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; INFINITESIMALS
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; INFINITESIMALS
8     (CONST&PUSH 2)                      ; ($ZEROA $ZEROB)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; INFINITESIMALS
12    (CONST&PUSH 3)                      ; VARIABLE
13    (CONST&PUSH 4)                      ; "The infinitesimals recognized by Macsyma. ZEROA zero from above,
   ZEROB zero from below"
14    (CALL 3 5)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; INFINITESIMALS
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR RD* NIL ...)-8-1|
(CONST 0) = RD*
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; RD*
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; RD*
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR RD* NIL ...)-8-2|
(CONST 0) = (SPECIAL RD*)
(CONST 1) = RD*
(CONST 2) = VARIABLE
(CONST 3) = 
"The full implications of this flag have yet to be determined.
It appears in LIMIT and DEFINT......."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL RD*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; RD*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; RD*
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; RD*
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "The full implications of this flag have yet to be determined.
It appears in LIMIT and DEFINT......."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; RD*
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR SIMPLIMPLUS-PROBLEMS NIL ...)-9-1|
(CONST 0) = SIMPLIMPLUS-PROBLEMS
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMPLUS-PROBLEMS
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; SIMPLIMPLUS-PROBLEMS
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR SIMPLIMPLUS-PROBLEMS NIL ...)-9-2|
(CONST 0) = (SPECIAL SIMPLIMPLUS-PROBLEMS)
(CONST 1) = SIMPLIMPLUS-PROBLEMS
(CONST 2) = VARIABLE
(CONST 3) = "A list of all problems in the stack of recursive calls to simplimplus."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL SIMPLIMPLUS-PROBLEMS)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; SIMPLIMPLUS-PROBLEMS
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; SIMPLIMPLUS-PROBLEMS
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; SIMPLIMPLUS-PROBLEMS
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "A list of all problems in the stack of recursive calls to simplimplus."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; SIMPLIMPLUS-PROBLEMS
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR LIMIT-ANSWERS NIL ...)-10-1|
(CONST 0) = LIMIT-ANSWERS
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-ANSWERS
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; LIMIT-ANSWERS
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR LIMIT-ANSWERS NIL ...)-10-2|
(CONST 0) = (SPECIAL LIMIT-ANSWERS)
(CONST 1) = LIMIT-ANSWERS
(CONST 2) = VARIABLE
(CONST 3) = "An association list for storing limit answers."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL LIMIT-ANSWERS)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; LIMIT-ANSWERS
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; LIMIT-ANSWERS
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; LIMIT-ANSWERS
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "An association list for storing limit answers."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; LIMIT-ANSWERS
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR PRESERVE-DIRECTION NIL ...)-11-1|
(CONST 0) = PRESERVE-DIRECTION
(CONST 1) = *VARIABLE-INITIAL-VALUES*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (*VARIABLE-INITIAL-VALUES*)
13 byte-code instructions:
0     (CONST&PUSH 0)                      ; PRESERVE-DIRECTION
1     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
3     (PUSH-UNBOUND 1)
5     (CALLS1&JMPIF 99 L17)               ; GETHASH
8     (GETVALUE&PUSH 1)                   ; *VARIABLE-INITIAL-VALUES*
10    (CONST&PUSH 0)                      ; PRESERVE-DIRECTION
11    (LOAD&PUSH 1)
12    (NIL&PUSH)
13    (CALLS1 100)                        ; SYSTEM::PUTHASH
15    (SKIP 1)
17    L17
17    (VALUES0)
18    (SKIP&RET 1)


Disassembly of function #:|(DEFMVAR PRESERVE-DIRECTION NIL ...)-11-2|
(CONST 0) = (SPECIAL PRESERVE-DIRECTION)
(CONST 1) = PRESERVE-DIRECTION
(CONST 2) = VARIABLE
(CONST 3) = "Makes LIMIT return Direction info."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL PRESERVE-DIRECTION)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; PRESERVE-DIRECTION
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; PRESERVE-DIRECTION
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST&PUSH 1)                      ; PRESERVE-DIRECTION
12    (CONST&PUSH 2)                      ; VARIABLE
13    (CONST&PUSH 3)                      ; "Makes LIMIT return Direction info."
14    (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
17    (CONST 1)                           ; PRESERVE-DIRECTION
18    (SKIP&RET 1)


Disassembly of function #:|(IF (NOT #) (SETQ INTEGER-INFO NIL))-12|
(CONST 0) = INTEGER-INFO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (INTEGER-INFO)
9 byte-code instructions:
0     (CONST&PUSH 0)                      ; INTEGER-INFO
1     (CALLS1 79)                         ; BOUNDP
3     (NOT)
4     (JMPIFNOT1 L11)
6     (NIL)
7     (SETVALUE 0)                        ; INTEGER-INFO
9     (SKIP&RET 1)
11    L11
11    (SKIP&RET 1)


Disassembly of function #:|(IF (NOT #) (SETQ BEHAVIOR-COUNT 4))-13|
(CONST 0) = BEHAVIOR-COUNT
(CONST 1) = 4
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (BEHAVIOR-COUNT)
9 byte-code instructions:
0     (CONST&PUSH 0)                      ; BEHAVIOR-COUNT
1     (CALLS1 79)                         ; BOUNDP
3     (NOT)
4     (JMPIFNOT1 L11)
6     (CONST 1)                           ; 4
7     (SETVALUE 0)                        ; BEHAVIOR-COUNT
9     (SKIP&RET 1)
11    L11
11    (SKIP&RET 1)


Disassembly of function #:|(DEFUN PUTLIMVAL (E V &AUX ...) ...)-14|
(CONST 0) = PUTLIMVAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PUTLIMVAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PUTLIMVAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PUTLIMVAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PUTLIMVAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PUTLIMVAL
8     (SKIP&RET 1)


Disassembly of function PUTLIMVAL
(CONST 0) = E
(CONST 1) = V
(CONST 2) = EXP
(CONST 3) = (%LIMIT)
(CONST 4) = VAR
(CONST 5) = VAL
(CONST 6) = LIMIT-ANSWERS
(CONST 7) = ASSOLIKE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP V LIMIT-ANSWERS VAL VAR E)
writes special variables : (LIMIT-ANSWERS EXP)
28 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; V
6     (NIL)
7     (BIND 2)                            ; EXP
9     (CONST&PUSH 3)                      ; (%LIMIT)
10    (GETVALUE&PUSH 0)                   ; E
12    (GETVALUE&PUSH 4)                   ; VAR
14    (GETVALUE&PUSH 5)                   ; VAL
16    (LIST 4)
18    (SETVALUE 2)                        ; EXP
20    (PUSH)
21    (GETVALUE&PUSH 6)                   ; LIMIT-ANSWERS
23    (CALL2&JMPIFNOT 7 L32)              ; ASSOLIKE
26    (GETVALUE 1)                        ; V
28    L28
28    (UNBIND 3)
30    (SKIP&RET 3)
32    L32
32    (GETVALUE&PUSH 2)                   ; EXP
34    (GETVALUE 1)                        ; V
36    (CONS&PUSH)
37    (GETVALUE 6)                        ; LIMIT-ANSWERS
39    (CONS)
40    (SETVALUE 6)                        ; LIMIT-ANSWERS
42    (GETVALUE 1)                        ; V
44    (JMP L28)


Disassembly of function #:|(DEFUN GETLIMVAL (E) ...)-15|
(CONST 0) = GETLIMVAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GETLIMVAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GETLIMVAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GETLIMVAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GETLIMVAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GETLIMVAL
8     (SKIP&RET 1)


Disassembly of function GETLIMVAL
(CONST 0) = E
(CONST 1) = (%LIMIT)
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = EXP
(CONST 5) = LIMIT-ANSWERS
(CONST 6) = ASSOLIKE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LIMIT-ANSWERS EXP VAL VAR E)
14 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (CONST&PUSH 1)                      ; (%LIMIT)
4     (GETVALUE&PUSH 0)                   ; E
6     (GETVALUE&PUSH 2)                   ; VAR
8     (GETVALUE&PUSH 3)                   ; VAL
10    (LIST 3)
12    (CONS)
13    (BIND 4)                            ; EXP
15    (GETVALUE&PUSH 4)                   ; EXP
17    (GETVALUE&PUSH 5)                   ; LIMIT-ANSWERS
19    (CALL2 6)                           ; ASSOLIKE
21    (UNBIND 2)
23    (SKIP&RET 2)


Disassembly of function #:|(DEFMACRO LIMIT-CATCH (EXP VAR VAL) ...)-16|
(CONST 0) = LIMIT-CATCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-CATCH>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-CATCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-CATCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-CATCH>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (CONST 0)                           ; LIMIT-CATCH
10    (SKIP&RET 1)


Disassembly of function LIMIT-CATCH
(CONST 0) = 4
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = EXP
(CONST 3) = VAR
(CONST 4) = VAL
(CONST 5) = LET
(CONST 6) = ((ERRORSW T))
(CONST 7) = ANS
(CONST 8) = CATCH
(CONST 9) = 'ERRORSW
(CONST 10) = 'LIMIT
(CONST 11) = LIMIT
(CONST 12) = ('THINK)
(CONST 13) = ((COND ((OR (NULL ANS) (EQ ANS T)) NIL) (T ANS)))
1 required argument
1 optional argument
No rest parameter
No keyword parameters
reads special variables: (VAL VAR EXP)
46 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 4
4     (CALLSR&JMPIF 1 46 L61)             ; /=
8     (LOAD 2)
9     (CDR)
10    (CAR)
11    (BIND 2)                            ; EXP
13    (LOAD 5)
14    (CDR)
15    (CDR)
16    (CAR)
17    (BIND 3)                            ; VAR
19    (LOAD 8)
20    (CDR)
21    (CDR)
22    (CDR)
23    (CAR)
24    (BIND 4)                            ; VAL
26    (CONST&PUSH 5)                      ; LET
27    (CONST&PUSH 6)                      ; ((ERRORSW T))
28    (CONST&PUSH 5)                      ; LET
29    (CONST&PUSH 7)                      ; ANS
30    (CONST&PUSH 8)                      ; CATCH
31    (CONST&PUSH 9)                      ; 'ERRORSW
32    (CONST&PUSH 8)                      ; CATCH
33    (CONST&PUSH 10)                     ; 'LIMIT
34    (CONST&PUSH 11)                     ; LIMIT
35    (GETVALUE&PUSH 2)                   ; EXP
37    (GETVALUE&PUSH 3)                   ; VAR
39    (GETVALUE&PUSH 4)                   ; VAL
41    (CONST 12)                          ; ('THINK)
42    (LIST*&PUSH 4)
44    (LIST&PUSH 3)
46    (LIST&PUSH 3)
48    (LIST&PUSH 2)
50    (LIST&PUSH 1)
52    (CONST 13)                          ; ((COND ((OR # #) NIL) (T ANS)))
53    (LIST*&PUSH 2)
55    (LIST 3)
57    (UNBIND 3)
59    (SKIP&RET 3)
61    L61
61    (LOAD&PUSH 2)
62    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
64    (SKIP&RET 3)


Disassembly of function #:|(DEFMFUN $LIMIT NARGS ...)-17|
(CONST 0) = $LIMIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $LIMIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $LIMIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $LIMIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $LIMIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $LIMIT
8     (SKIP&RET 1)


Disassembly of function $LIMIT
(CONST 0) = GLOBAL-ASSUMPTIONS
(CONST 1) = LIMIT-ASSUMPTIONS
(CONST 2) = OLD-INTEGER-INFO
(CONST 3) = $KEEPFLOAT
(CONST 4) = LIMIT-TOP
(CONST 5) = LIMITP
(CONST 6) = INTEGER-INFO
(CONST 7) = EXP1
(CONST 8) = RD*
(CONST 9) = $LHOSPITALLIM
(CONST 10) = LHCOUNT
(CONST 11) = 0
(CONST 12) = BEHAVIOR-COUNT-NOW
(CONST 13) = D
(CONST 14) = EXP
(CONST 15) = VAR
(CONST 16) = VAL
(CONST 17) = *INDICATOR
(CONST 18) = TAYLORED
(CONST 19) = ORIGVAL
(CONST 20) = LOGCOMBED
(CONST 21) = LHP?
(CONST 22) = $LOGEXPAND
(CONST 23) = VARLIST
(CONST 24) = ANS
(CONST 25) = GENVAR
(CONST 26) = LOGINPROD?
(CONST 27) = LIMIT-ANSWERS
(CONST 28) = SIMPLIMPLUS-PROBLEMS
(CONST 29) = 3
(CONST 30) = 4
(CONST 31) = 1
(CONST 32) = $LIMIT
(CONST 33) = WNA-ERR
(CONST 34) = LIMIT-LIST
(CONST 35) = LISTIFY1
(CONST 36) = NARG1
(CONST 37) = SPECREPCHECK
(CONST 38) = FOO
(CONST 39) = 2
(CONST 40) = $CONSTANTP
(CONST 41) = "Second argument cannot be a constant - LIMIT"
(CONST 42) = MERROR
(CONST 43) = $ZEROA
(CONST 44) = $PLUS
(CONST 45) = $ZEROB
(CONST 46) = $MINUS
(CONST 47) = ($PLUS $MINUS)
(CONST 48) = MEMQ
(CONST 49) = "Fourth argument must be either PLUS or MINUS - LIMIT"
(CONST 50) = AMONG
(CONST 51) = MAXIMA-SUBSTITUTE
(CONST 52) = LIMITSUB
(CONST 53) = PUTPROP
(CONST 54) = $LIMSUBST
(CONST 55) = LIMUNKNOWN
(CONST 56) = (%LIMIT)
(CONST 57) = LIMIT-CONTEXT
(CONST 58) = INFINITIES
(CONST 59) = ZEROP2
(CONST 60) = ADD*
(CONST 61) = SUBIN
(CONST 62) = $MINF
(CONST 63) = $INF
(CONST 64) = -1
(CONST 65) = MUL*
(CONST 66) = HIDE
(CONST 67) = $EXPAND
(CONST 68) = LIMITSIMP
(CONST 69) = LFIBTOPHI
(CONST 70) = TANSC
(CONST 71) = FACTOSIMP
(CONST 72) = RESIMPLIFY
(CONST 73) = MABS
(CONST 74) = MABS-SUBST
(CONST 75) = BOTH
(CONST 76) = BOTH-SIDE
(CONST 77) = NOUNLIMIT
(CONST 78) = $UND
(CONST 79) = RETN
(CONST 80) = ERRORSW
(CONST 81) = LIMIT
(CONST 82) = THINK
(CONST 83) = INFINITESIMALS
(CONST 84) = REAL-INFINITIES
(CONST 85) = CLEAN-LIMIT-EXP
(CONST 86) = RESTORE-ASSUMPTIONS
0 required arguments
0 optional arguments
Rest parameter
No keyword parameters
reads special variables: 
(REAL-INFINITIES INFINITESIMALS ANS D INFINITIES ORIGVAL EXP $LIMSUBST EXP1 VAR
 VAL $LHOSPITALLIM INTEGER-INFO LIMITP)
writes special variables : (D ORIGVAL GENVAR VARLIST EXP VAL VAR EXP1 ANS INTEGER-INFO OLD-INTEGER-INFO)
345 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (NIL)
4     (BIND 0)                            ; GLOBAL-ASSUMPTIONS
6     (NIL)
7     (BIND 1)                            ; LIMIT-ASSUMPTIONS
9     (NIL)
10    (BIND 2)                            ; OLD-INTEGER-INFO
12    (T)
13    (BIND 3)                            ; $KEEPFLOAT
15    (T)
16    (BIND 4)                            ; LIMIT-TOP
18    (GETVALUE 5)                        ; LIMITP
20    (JMPIF L29)
22    (GETVALUE 6)                        ; INTEGER-INFO
24    (SETVALUE 2)                        ; OLD-INTEGER-INFO
26    (NIL)
27    (SETVALUE 6)                        ; INTEGER-INFO
29    L29
29    (UNWIND-PROTECT-OPEN L624)
32    (NIL)
33    (BIND 7)                            ; EXP1
35    (T)
36    (BIND 8)                            ; RD*
38    (GETVALUE 9)                        ; $LHOSPITALLIM
40    (BIND 10)                           ; LHCOUNT
42    (CONST 11)                          ; 0
43    (BIND 12)                           ; BEHAVIOR-COUNT-NOW
45    (NIL)
46    (BIND 13)                           ; D
48    (NIL)
49    (BIND 14)                           ; EXP
51    (NIL)
52    (BIND 15)                           ; VAR
54    (NIL)
55    (BIND 16)                           ; VAL
57    (NIL&PUSH)
58    (NIL)
59    (BIND 17)                           ; *INDICATOR
61    (NIL)
62    (BIND 18)                           ; TAYLORED
64    (NIL)
65    (BIND 19)                           ; ORIGVAL
67    (NIL)
68    (BIND 20)                           ; LOGCOMBED
70    (NIL)
71    (BIND 21)                           ; LHP?
73    (T)
74    (BIND 22)                           ; $LOGEXPAND
76    (NIL)
77    (BIND 23)                           ; VARLIST
79    (NIL)
80    (BIND 24)                           ; ANS
82    (NIL)
83    (BIND 25)                           ; GENVAR
85    (NIL)
86    (BIND 26)                           ; LOGINPROD?
88    (NIL)
89    (BIND 27)                           ; LIMIT-ANSWERS
91    (T)
92    (BIND 5)                            ; LIMITP
94    (NIL)
95    (BIND 28)                           ; SIMPLIMPLUS-PROBLEMS
97    (LOAD&PUSH 81)
99    (CONST&PUSH 29)                     ; 3
100   (CALLSR&JMPIF 1 45 L124)            ; =
104   (LOAD&PUSH 81)
106   (CONST&PUSH 30)                     ; 4
108   (CALLSR&JMPIF 1 45 L124)            ; =
112   (LOAD&PUSH 81)
114   (CONST&PUSH 31)                     ; 1
116   (CALLSR&JMPIF 1 45 L124)            ; =
120   (CONST&PUSH 32)                     ; $LIMIT
122   (CALL1 33)                          ; WNA-ERR
124   L124
124   (CONST&SYMBOL-FUNCTION&PUSH 34)     ; LIMIT-LIST
126   (LOAD&PUSH 82)
128   (LOAD&PUSH 85)
130   (CALL2 35)                          ; LISTIFY1
132   (APPLY 0)
134   (SETVALUE 24)                       ; ANS
136   (JMPIF L617)
139   (CONST&PUSH 31)                     ; 1
141   (LOAD&PUSH 84)
143   (CALL2&PUSH 36)                     ; NARG1
145   (CALL1 37)                          ; SPECREPCHECK
147   (SETVALUE 7)                        ; EXP1
149   (LOAD&PUSH 81)
151   (CONST&PUSH 31)                     ; 1
153   (CALLSR&JMPIF 1 45 L472)            ; =
158   (CONST&PUSH 39)                     ; 2
160   (LOAD&PUSH 84)
162   (CALL2 36)                          ; NARG1
164   (SETVALUE 15)                       ; VAR
166   (PUSH)
167   (CALL1&JMPIFNOT 40 L174)            ; $CONSTANTP
170   (CONST&PUSH 41)                     ; "Second argument cannot be a constant - LIMIT"
172   (CALL1 42)                          ; MERROR
174   L174
174   (CONST&PUSH 29)                     ; 3
175   (LOAD&PUSH 84)
177   (CALL2 36)                          ; NARG1
179   (SETVALUE 16)                       ; VAL
181   (PUSH)
182   (JMPIFNOTEQTO 43 L189)              ; $ZEROA
185   (CONST 44)                          ; $PLUS
187   (STORE 39)
189   L189
189   (GETVALUE&PUSH 16)                  ; VAL
191   (JMPIFNOTEQTO 45 L198)              ; $ZEROB
194   (CONST 46)                          ; $MINUS
196   (STORE 39)
198   L198
198   (LOAD&PUSH 81)
200   (CONST&PUSH 30)                     ; 4
202   (CALLSR&JMPIFNOT 1 45 L229)         ; =
206   (CONST&PUSH 30)                     ; 4
208   (LOAD&PUSH 84)
210   (CALL2&PUSH 36)                     ; NARG1
212   (CONST&PUSH 47)                     ; ($PLUS $MINUS)
214   (CALL2&JMPIF 48 L221)               ; MEMQ
217   (CONST&PUSH 49)                     ; "Fourth argument must be either PLUS or MINUS - LIMIT"
219   (CALL1 42)                          ; MERROR
221   L221
221   (CONST&PUSH 30)                     ; 4
223   (LOAD&PUSH 84)
225   (CALL2 36)                          ; NARG1
227   (STORE 39)
229   L229
229   (GETVALUE 15)                       ; VAR
231   (JMPIFCONSP L241)
233   (GETVALUE&PUSH 15)                  ; VAR
235   (GETVALUE&PUSH 16)                  ; VAL
237   (CALL2&JMPIFNOT 50 L482)            ; AMONG
241   L241
241   (GETVALUE&PUSH 15)                  ; VAR
243   (PUSH-UNBOUND 1)
245   (CALLS2 143)                        ; GENSYM
247   (SETVALUE 15)                       ; VAR
249   (PUSH)
250   (LOAD&PUSH 1)
251   (GETVALUE&PUSH 7)                   ; EXP1
253   (CALL 3 51)                         ; MAXIMA-SUBSTITUTE
256   (SETVALUE 14)                       ; EXP
258   (GETVALUE&PUSH 15)                  ; VAR
260   (LOAD&PUSH 1)
261   (CONST&PUSH 52)                     ; LIMITSUB
263   (CALL 3 53)                         ; PUTPROP
266   (SKIP 1)
268   (GETVALUE 54)                       ; $LIMSUBST
270   (JMPIF L283)
272   L272
272   (GETVALUE&PUSH 15)                  ; VAR
274   (JMPIFEQTO 38 L283)                 ; FOO
277   (GETVALUE&PUSH 14)                  ; EXP
279   (CALL1&JMPIF 55 L494)               ; LIMUNKNOWN
283   L283
283   (GETVALUE&PUSH 15)                  ; VAR
285   (NIL)
286   (CONS)
287   (SETVALUE 23)                       ; VARLIST
289   (NIL)
290   (SETVALUE 25)                       ; GENVAR
292   (GETVALUE 16)                       ; VAL
294   (SETVALUE 19)                       ; ORIGVAL
296   (LOAD&PUSH 81)
298   (CONST&PUSH 31)                     ; 1
300   (CALLSR&JMPIF 1 45 L317)            ; =
304   (CONST&PUSH 39)                     ; 2
306   (LOAD&PUSH 84)
308   (CALL2&PUSH 36)                     ; NARG1
310   (GETVALUE&PUSH 19)                  ; ORIGVAL
312   (LOAD&PUSH 41)
314   (CALL 3 57)                         ; LIMIT-CONTEXT
317   L317
317   (GETVALUE&PUSH 16)                  ; VAL
319   (GETVALUE&PUSH 58)                  ; INFINITIES
321   (CALL2&JMPIF 48 L359)               ; MEMQ
324   (GETVALUE&PUSH 16)                  ; VAL
326   (CALL1&JMPIF 59 L341)               ; ZEROP2
329   (GETVALUE&PUSH 15)                  ; VAR
331   (GETVALUE&PUSH 16)                  ; VAL
333   (CALL2&PUSH 60)                     ; ADD*
335   (GETVALUE&PUSH 14)                  ; EXP
337   (CALL2 61)                          ; SUBIN
339   (SETVALUE 14)                       ; EXP
341   L341
341   (LOAD&PUSH 39)
343   (JMPIFEQTO 44 L510)                 ; $PLUS
347   (LOAD&PUSH 39)
349   (JMPIFEQTO 46 L515)                 ; $MINUS
353   (CONST 11)                          ; 0
354   L354
354   (SETVALUE 16)                       ; VAL
356   (CONST 11)                          ; 0
357   (SETVALUE 19)                       ; ORIGVAL
359   L359
359   (GETVALUE&PUSH 16)                  ; VAL
361   (JMPIFNOTEQTO 62 L382)              ; $MINF
364   (CONST 63)                          ; $INF
366   (SETVALUE 16)                       ; VAL
368   (SETVALUE 19)                       ; ORIGVAL
370   (CONST&PUSH 64)                     ; -1
372   (GETVALUE&PUSH 15)                  ; VAR
374   (CALL2&PUSH 65)                     ; MUL*
376   (GETVALUE&PUSH 14)                  ; EXP
378   (CALL2 61)                          ; SUBIN
380   (SETVALUE 14)                       ; EXP
382   L382
382   (GETVALUE&PUSH 14)                  ; EXP
384   (CALL1&PUSH 66)                     ; HIDE
386   (CONST&PUSH 31)                     ; 1
388   (CONST&PUSH 11)                     ; 0
389   (CALL&PUSH 3 67)                    ; $EXPAND
392   (GETVALUE&PUSH 15)                  ; VAR
394   (CALL2&PUSH 68)                     ; LIMITSIMP
396   (CALL1&PUSH 69)                     ; LFIBTOPHI
398   (CALL1&PUSH 70)                     ; TANSC
400   (CALL1&PUSH 71)                     ; FACTOSIMP
402   (CALL1 72)                          ; RESIMPLIFY
404   (SETVALUE 14)                       ; EXP
406   (CONST 73)                          ; MABS
408   (CATCH-OPEN L420)
410   (GETVALUE&PUSH 14)                  ; EXP
412   (GETVALUE&PUSH 15)                  ; VAR
414   (GETVALUE&PUSH 16)                  ; VAL
416   (CALL 3 74)                         ; MABS-SUBST
419   (CATCH-CLOSE)
420   L420
420   (SETVALUE 13)                       ; D
422   (PUSH)
423   (JMPIFEQTO 75 L520)                 ; BOTH
427   (GETVALUE&PUSH 13)                  ; D
429   (JMPIFEQTO 78 L546)                 ; $UND
433   (GETVALUE&PUSH 13)                  ; D
435   (JMPIFEQTO 79 L608)                 ; RETN
439   (GETVALUE 13)                       ; D
441   (SETVALUE 14)                       ; EXP
443   L443
443   (T)
444   (BIND 80)                           ; ERRORSW
446   (CONST 80)                          ; ERRORSW
448   (CATCH-OPEN L562)
451   (CONST 81)                          ; LIMIT
453   (CATCH-OPEN L561)
456   (GETVALUE&PUSH 14)                  ; EXP
458   (GETVALUE&PUSH 15)                  ; VAR
460   (GETVALUE&PUSH 16)                  ; VAL
462   (CONST&PUSH 82)                     ; THINK
464   (CALL 4 81)                         ; LIMIT
467   (CATCH-CLOSE)
468   (CATCH-CLOSE)
469   (JMP L562)
472   L472
472   (CONST 38)                          ; FOO
474   (SETVALUE 15)                       ; VAR
476   (CONST 11)                          ; 0
477   (SETVALUE 16)                       ; VAL
479   (JMP L198)
482   L482
482   (GETVALUE 7)                        ; EXP1
484   (SETVALUE 14)                       ; EXP
486   (GETVALUE 54)                       ; $LIMSUBST
488   (JMPIFNOT L272)
491   (JMP L283)
494   L494
494   (CONST&PUSH 56)                     ; (%LIMIT)
496   (GETVALUE&PUSH 7)                   ; EXP1
498   (LOAD&PUSH 83)
500   (LOAD&PUSH 86)
502   (CALL2 35)                          ; LISTIFY1
504   (CDR)
505   (LIST* 2)
507   (JMP L617)
510   L510
510   (CONST 43)                          ; $ZEROA
512   (JMP L354)
515   L515
515   (CONST 45)                          ; $ZEROB
517   (JMP L354)
520   L520
520   (GETVALUE&PUSH 14)                  ; EXP
522   (GETVALUE&PUSH 15)                  ; VAR
524   (GETVALUE&PUSH 16)                  ; VAL
526   (CALL 3 76)                         ; BOTH-SIDE
529   (SETVALUE 24)                       ; ANS
531   (JMPIF L443)
534   (GETVALUE&PUSH 14)                  ; EXP
536   (GETVALUE&PUSH 15)                  ; VAR
538   (GETVALUE&PUSH 16)                  ; VAL
540   (CALL 3 77)                         ; NOUNLIMIT
543   (JMP L443)
546   L546
546   (CONST 78)                          ; $UND
548   (JMP L617)
551   L551
551   (NIL)
552   (JMP L575)
554   L554
554   (GETVALUE 24)                       ; ANS
556   L556
556   (PUSH)
557   (CALL1 85)                          ; CLEAN-LIMIT-EXP
559   (JMP L617)
561   L561
561   (CATCH-CLOSE)
562   L562
562   (BIND 24)                           ; ANS
564   (GETVALUE 24)                       ; ANS
566   (JMPIFNOT L551)
568   (GETVALUE&PUSH 24)                  ; ANS
570   (T)
571   (JMPIFEQ L551)
573   (GETVALUE 24)                       ; ANS
575   L575
575   (UNBIND 2)
577   (SETVALUE 24)                       ; ANS
579   (JMPIF L554)
581   (GETVALUE&PUSH 16)                  ; VAL
583   (GETVALUE&PUSH 83)                  ; INFINITESIMALS
585   (CALL2&JMPIF 48 L608)               ; MEMQ
588   (GETVALUE&PUSH 16)                  ; VAL
590   (GETVALUE&PUSH 84)                  ; REAL-INFINITIES
592   (CALL2&JMPIF 48 L608)               ; MEMQ
595   (GETVALUE&PUSH 14)                  ; EXP
597   (GETVALUE&PUSH 15)                  ; VAR
599   (GETVALUE&PUSH 16)                  ; VAL
601   (CALL 3 76)                         ; BOTH-SIDE
604   (SETVALUE 24)                       ; ANS
606   (JMPIF L556)
608   L608
608   (GETVALUE&PUSH 14)                  ; EXP
610   (GETVALUE&PUSH 15)                  ; VAR
612   (GETVALUE&PUSH 16)                  ; VAL
614   (CALL 3 77)                         ; NOUNLIMIT
617   L617
617   (UNBIND 13)
619   (SKIP 1)
621   (UNBIND 8)
623   (UNWIND-PROTECT-NORMAL-EXIT)
624   L624
624   (CALL0 86)                          ; RESTORE-ASSUMPTIONS
626   (UNWIND-PROTECT-CLOSE)
627   (UNBIND 5)
629   (SKIP&RET 3)


Disassembly of function #:|(DEFUN CLEAN-LIMIT-EXP (EXP) ...)-18|
(CONST 0) = CLEAN-LIMIT-EXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CLEAN-LIMIT-EXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CLEAN-LIMIT-EXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CLEAN-LIMIT-EXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CLEAN-LIMIT-EXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CLEAN-LIMIT-EXP
8     (SKIP&RET 1)


Disassembly of function CLEAN-LIMIT-EXP
(CONST 0) = EXP
(CONST 1) = RESTORELIM
(CONST 2) = PRESERVE-DIRECTION
(CONST 3) = RIDOFAB
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (PRESERVE-DIRECTION EXP)
writes special variable : (EXP)
15 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1 1)                           ; RESTORELIM
7     (SETVALUE 0)                        ; EXP
9     (GETVALUE 2)                        ; PRESERVE-DIRECTION
11    (JMPIF L20)
13    (GETVALUE&PUSH 0)                   ; EXP
15    (CALL1 3)                           ; RIDOFAB
17    L17
17    (UNBIND1)
18    (SKIP&RET 2)
20    L20
20    (GETVALUE 0)                        ; EXP
22    (JMP L17)


Disassembly of function #:|(DEFMFUN LIMIT-LIST NARGS ...)-19|
(CONST 0) = LIMIT-LIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-LIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-LIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-LIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-LIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT-LIST
8     (SKIP&RET 1)


Disassembly of function LIMIT-LIST
(CONST 0) = LISTIFY1
(CONST 1) = EXP1
(CONST 2) = MBAGP
(CONST 3) = X
(CONST 4) = $LIMIT
0 required arguments
0 optional arguments
Rest parameter
No keyword parameters
reads special variables: (X EXP1)
writes special variable : (EXP1)
48 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (NIL&PUSH)
4     (LOAD&PUSH 1)
5     (LOAD&PUSH 4)
6     (CALL2&PUSH 0)                      ; LISTIFY1
8     (LOAD 1)
9     (BIND 1)                            ; EXP1
11    (LOAD 3)
12    (CAR)
13    (SETVALUE 1)                        ; EXP1
15    (LOAD&CDR&STORE 3)
17    (GETVALUE&PUSH 1)                   ; EXP1
19    (CALL1&JMPIF 2 L26)                 ; MBAGP
22    (NIL)
23    L23
23    (UNBIND1)
24    (SKIP&RET 5)
26    L26
26    (GETVALUE 1)                        ; EXP1
28    (CAR&PUSH)
29    (NIL&PUSH)
30    (GETVALUE 1)                        ; EXP1
32    (CDR&PUSH)
33    (JMP L55)
35    L35
35    (LOAD&CAR&PUSH 0)
37    (LOAD 0)
38    (BIND 3)                            ; X
40    (CONST&PUSH 4)                      ; $LIMIT
41    (GETVALUE&PUSH 3)                   ; X
43    (LOAD 12)
44    (CONS)
45    (APPLY 0)
47    (UNBIND1)
48    (PUSH)
49    (LOAD&CONS&STORE 2)
51    (SKIP 1)
53    (LOAD&CDR&STORE 0)
55    L55
55    (LOAD&PUSH 0)
56    (CALLS1&JMPIFNOT 146 L35)           ; ENDP
59    (SKIP 1)
61    (LOAD&PUSH 0)
62    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
64    (SKIP 1)
66    (CONS)
67    (JMP L23)


Disassembly of function #:|(DEFUN LIMIT-CONTEXT (VAR VAL DIRECTION) ...)-20|
(CONST 0) = LIMIT-CONTEXT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT-CONTEXT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT-CONTEXT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT-CONTEXT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT-CONTEXT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT-CONTEXT
8     (SKIP&RET 1)


Disassembly of function LIMIT-CONTEXT
(CONST 0) = VAR
(CONST 1) = VAL
(CONST 2) = LIMIT-TOP
(CONST 3) = FORGET
(CONST 4) = $FACTS
(CONST 5) = GLOBAL-ASSUMPTIONS
(CONST 6) = ((MGREATERP) EPSILON 0)
(CONST 7) = ASSUME
(CONST 8) = ((MLESSP) EPSILON 1.0E-8)
(CONST 9) = ((MGREATERP) PRIN-INF 1.0E8)
(CONST 10) = MAKE-LIMIT-ASSUMPTIONS
(CONST 11) = LIMIT-ASSUMPTIONS
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL GLOBAL-ASSUMPTIONS VAR LIMIT-ASSUMPTIONS LIMIT-TOP)
writes special variables : (LIMIT-TOP LIMIT-ASSUMPTIONS GLOBAL-ASSUMPTIONS)
34 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; VAR
3     (LOAD 5)
4     (BIND 1)                            ; VAL
6     (GETVALUE 2)                        ; LIMIT-TOP
8     (JMPIF L16)
10    (GETVALUE 11)                       ; LIMIT-ASSUMPTIONS
12    L12
12    (UNBIND 2)
14    (SKIP&RET 4)
16    L16
16    (CONST&PUSH 3)                      ; FORGET
17    (GETVALUE&PUSH 0)                   ; VAR
19    (CALL1 4)                           ; $FACTS
21    (CDR)
22    (SETVALUE 5)                        ; GLOBAL-ASSUMPTIONS
24    (PUSH)
25    (CALLSR 0 24)                       ; MAPC
28    (CONST&PUSH 6)                      ; ((MGREATERP) EPSILON 0)
29    (CALL1 7)                           ; ASSUME
31    (CONST&PUSH 8)                      ; ((MLESSP) EPSILON 1.0E-8)
32    (CALL1 7)                           ; ASSUME
34    (CONST&PUSH 9)                      ; ((MGREATERP) PRIN-INF 1.0E8)
35    (CALL1 7)                           ; ASSUME
37    (GETVALUE&PUSH 5)                   ; GLOBAL-ASSUMPTIONS
39    (GETVALUE&PUSH 0)                   ; VAR
41    (GETVALUE&PUSH 1)                   ; VAL
43    (LOAD&PUSH 10)
44    (CALL 4 10)                         ; MAKE-LIMIT-ASSUMPTIONS
47    (SETVALUE 11)                       ; LIMIT-ASSUMPTIONS
49    (NIL)
50    (SETVALUE 2)                        ; LIMIT-TOP
52    (GETVALUE 11)                       ; LIMIT-ASSUMPTIONS
54    (JMP L12)


Disassembly of function #:|(DEFUN MAKE-LIMIT-ASSUMPTIONS (OLD-ASSUMPTIONS VAR VAL ...) ...)-21|
(CONST 0) = MAKE-LIMIT-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKE-LIMIT-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKE-LIMIT-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKE-LIMIT-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKE-LIMIT-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKE-LIMIT-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function MAKE-LIMIT-ASSUMPTIONS
(CONST 0) = VAR
(CONST 1) = VAL
(CONST 2) = USE-OLD-CONTEXT
(CONST 3) = ASSUME
(CONST 4) = INFINITIES
(CONST 5) = MEMQ
(CONST 6) = $INF
(CONST 7) = (MGREATERP)
(CONST 8) = (1.0E8)
(CONST 9) = $MINF
(CONST 10) = (MGREATERP)
(CONST 11) = 1.0E8
(CONST 12) = $PLUS
(CONST 13) = (MGREATERP)
(CONST 14) = (0)
(CONST 15) = $MINUS
(CONST 16) = (MGREATERP)
(CONST 17) = 0
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL VAR)
66 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; VAR
3     (LOAD 5)
4     (BIND 1)                            ; VAL
6     (NIL&PUSH)
7     (LOAD&PUSH 11)
8     (GETVALUE&PUSH 0)                   ; VAR
10    (GETVALUE&PUSH 1)                   ; VAL
12    (CALL 3 2)                          ; USE-OLD-CONTEXT
15    (STORE 0)
16    (CONST&SYMBOL-FUNCTION&PUSH 3)      ; ASSUME
18    (LOAD&PUSH 1)
19    (CALLSR 0 24)                       ; MAPC
22    (GETVALUE 0)                        ; VAR
24    (JMPIFNOT L58)
26    (GETVALUE 1)                        ; VAL
28    (JMPIFNOT L58)
30    (GETVALUE&PUSH 1)                   ; VAL
32    (GETVALUE&PUSH 4)                   ; INFINITIES
34    (CALL2&JMPIF 5 L40)                 ; MEMQ
37    (LOAD&JMPIFNOT 8 L58)
40    L40
40    (GETVALUE&PUSH 1)                   ; VAL
42    (JMPIFEQTO 6 L65)                   ; $INF
45    (GETVALUE&PUSH 1)                   ; VAL
47    (JMPIFEQTO 9 L73)                   ; $MINF
50    (LOAD&PUSH 8)
51    (JMPIFEQTO 12 L77)                  ; $PLUS
54    (LOAD&PUSH 8)
55    (JMPIFEQTO 15 L85)                  ; $MINUS
58    L58
58    (NIL)
59    (SKIP 1)
61    L61
61    (UNBIND 2)
63    (SKIP&RET 5)
65    L65
65    (CONST&PUSH 7)                      ; (MGREATERP)
66    (GETVALUE&PUSH 0)                   ; VAR
68    (CONST 8)                           ; (1.0E8)
69    (LIST* 2)
71    (JMP L92)
73    L73
73    (CONST&PUSH 10)                     ; (MGREATERP)
74    (CONST 11)                          ; 1.0E8
75    (JMP L87)
77    L77
77    (CONST&PUSH 13)                     ; (MGREATERP)
78    (GETVALUE&PUSH 0)                   ; VAR
80    (CONST 14)                          ; (0)
81    (LIST* 2)
83    (JMP L92)
85    L85
85    (CONST&PUSH 16)                     ; (MGREATERP)
86    (CONST 17)                          ; 0
87    L87
87    (PUSH)
88    (GETVALUE&PUSH 0)                   ; VAR
90    (LIST 3)
92    L92
92    (PUSH)
93    (CALL1&PUSH 3)                      ; ASSUME
95    (LOAD 1)
96    (CONS)
97    (SKIP 1)
99    (JMP L61)


Disassembly of function #:|(DEFUN USE-OLD-CONTEXT (OLD-ASSUMPTIONS VAR VAL) ...)-22|
(CONST 0) = USE-OLD-CONTEXT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE USE-OLD-CONTEXT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; USE-OLD-CONTEXT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; USE-OLD-CONTEXT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE USE-OLD-CONTEXT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; USE-OLD-CONTEXT
8     (SKIP&RET 1)


Disassembly of function USE-OLD-CONTEXT
(CONST 0) = VAR
(CONST 1) = VAL
(CONST 2) = RIDOFAB
(CONST 3) = INFINITIES
(CONST 4) = MEMQ
(CONST 5) = (MGREATERP MLESSP)
(CONST 6) = MAKE-ASSUMP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL VAR)
writes special variable : (VAR)
56 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (GETVALUE&PUSH 0)                   ; VAR
8     (CALL1 2)                           ; RIDOFAB
10    (SETVALUE 0)                        ; VAR
12    (LOAD&JMPIFNOT 9 L27)
15    (GETVALUE&PUSH 1)                   ; VAL
17    (GETVALUE&PUSH 3)                   ; INFINITIES
19    (CALL2&JMPIFNOT 4 L30)              ; MEMQ
22    (NIL)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 4)
27    L27
27    (NIL)
28    (JMP L23)
30    L30
30    (LOAD&PUSH 9)
31    (PUSH-NIL 4)
33    (LOAD&JMPIFNOT 4 L74)
36    L36
36    (LOAD 4)
37    (CAR)
38    (CAR)
39    (CAR)
40    (STORE 3)
41    (LOAD 4)
42    (CAR)
43    (CDR)
44    (CAR)
45    (STORE 2)
46    (LOAD 4)
47    (CAR)
48    (CDR)
49    (CDR)
50    (CAR)
51    (STORE 1)
52    (LOAD&PUSH 3)
53    (CONST&PUSH 5)                      ; (MGREATERP MLESSP)
54    (CALL2&JMPIFNOT 4 L69)              ; MEMQ
57    (LOAD&PUSH 3)
58    (LOAD&PUSH 3)
59    (LOAD&PUSH 3)
60    (GETVALUE&PUSH 0)                   ; VAR
62    (GETVALUE&PUSH 1)                   ; VAL
64    (CALL&PUSH 5 6)                     ; MAKE-ASSUMP
67    (LOAD&CONS&STORE 0)
69    L69
69    (LOAD&CDR&STORE 4)
71    (LOAD&JMPIF 4 L36)
74    L74
74    (POP)
75    (SKIP 4)
77    (JMP L23)


Disassembly of function #:|(DEFUN MAKE-ASSUMP (PRED PART1 PART2 ...) ...)-23|
(CONST 0) = MAKE-ASSUMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAKE-ASSUMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAKE-ASSUMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAKE-ASSUMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAKE-ASSUMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAKE-ASSUMP
8     (SKIP&RET 1)


Disassembly of function MAKE-ASSUMP
(CONST 0) = VAR
(CONST 1) = VAL
(CONST 2) = $INF
(CONST 3) = FREE
(CONST 4) = $MINF
(CONST 5) = $INFINITY
(CONST 6) = -1
(CONST 7) = MUL
(CONST 8) = ADD
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR)
63 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (LOAD&PUSH 10)
7     (GETVALUE 0)                        ; VAR
9     (JMPIFEQ L43)
11    (LOAD&PUSH 9)
12    (GETVALUE 0)                        ; VAR
14    (JMPIFNOTEQ L85)
17    (LOAD&PUSH 10)
18    (CONST&PUSH 2)                      ; $INF
19    (CALL2&JMPIFNOT 3 L32)              ; FREE
22    (LOAD&PUSH 10)
23    (CONST&PUSH 4)                      ; $MINF
24    (CALL2&JMPIFNOT 3 L32)              ; FREE
27    (LOAD&PUSH 10)
28    (CONST&PUSH 5)                      ; $INFINITY
29    (CALL2&JMPIF 3 L72)                 ; FREE
32    L32
32    (LOAD&PUSH 11)
33    (LIST&PUSH 1)
35    (LOAD 11)
36    L36
36    (PUSH)
37    (LOAD 11)
38    L38
38    (PUSH)
39    (LIST 3)
41    (JMP L86)
43    L43
43    (LOAD&PUSH 9)
44    (CONST&PUSH 2)                      ; $INF
45    (CALL2&JMPIFNOT 3 L32)              ; FREE
48    (LOAD&PUSH 9)
49    (CONST&PUSH 4)                      ; $MINF
50    (CALL2&JMPIFNOT 3 L32)              ; FREE
53    (LOAD&PUSH 9)
54    (CONST&PUSH 5)                      ; $INFINITY
55    (CALL2&JMPIFNOT 3 L32)              ; FREE
58    (LOAD&PUSH 11)
59    (LIST&PUSH 1)
61    (LOAD&PUSH 11)
62    (LOAD&PUSH 11)
63    (CONST&PUSH 6)                      ; -1
64    (GETVALUE&PUSH 1)                   ; VAL
66    (CALL2&PUSH 7)                      ; MUL
68    (CALL2 8)                           ; ADD
70    (JMP L38)
72    L72
72    (LOAD&PUSH 11)
73    (LIST&PUSH 1)
75    (LOAD&PUSH 11)
76    (CONST&PUSH 6)                      ; -1
77    (GETVALUE&PUSH 1)                   ; VAL
79    (CALL2&PUSH 7)                      ; MUL
81    (CALL2 8)                           ; ADD
83    (JMP L36)
85    L85
85    (NIL)
86    L86
86    (UNBIND 2)
88    (SKIP&RET 6)


Disassembly of function #:|(DEFUN RESTORE-ASSUMPTIONS NIL ...)-24|
(CONST 0) = RESTORE-ASSUMPTIONS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RESTORE-ASSUMPTIONS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RESTORE-ASSUMPTIONS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RESTORE-ASSUMPTIONS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RESTORE-ASSUMPTIONS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RESTORE-ASSUMPTIONS
8     (SKIP&RET 1)


Disassembly of function RESTORE-ASSUMPTIONS
(CONST 0) = LIMIT-ASSUMPTIONS
(CONST 1) = FORGET
(CONST 2) = ((MGREATERP) EPSILON 0)
(CONST 3) = ((MLESSP) EPSILON 1.0E-8)
(CONST 4) = ((MGREATERP) PRIN-INF 1.0E8)
(CONST 5) = INTEGER-INFO
(CONST 6) = LIMITP
(CONST 7) = I-$REMOVE
(CONST 8) = OLD-INTEGER-INFO
(CONST 9) = GLOBAL-ASSUMPTIONS
(CONST 10) = ASSUME
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (GLOBAL-ASSUMPTIONS OLD-INTEGER-INFO LIMITP INTEGER-INFO LIMIT-ASSUMPTIONS)
writes special variable : (INTEGER-INFO)
50 byte-code instructions:
0     (GETVALUE&PUSH 0)                   ; LIMIT-ASSUMPTIONS
2     (LOAD&JMPIFNOT 0 L14)
5     L5
5     (LOAD&CAR&PUSH 0)
7     (CALL1 1)                           ; FORGET
9     (LOAD&CDR&STORE 0)
11    (LOAD&JMPIF 0 L5)
14    L14
14    (SKIP 1)
16    (CONST&PUSH 2)                      ; ((MGREATERP) EPSILON 0)
17    (CALL1 1)                           ; FORGET
19    (CONST&PUSH 3)                      ; ((MLESSP) EPSILON 1.0E-8)
20    (CALL1 1)                           ; FORGET
22    (CONST&PUSH 4)                      ; ((MGREATERP) PRIN-INF 1.0E8)
23    (CALL1 1)                           ; FORGET
25    (GETVALUE 5)                        ; INTEGER-INFO
27    (JMPIFNOT L62)
29    (GETVALUE 6)                        ; LIMITP
31    (JMPIF L62)
33    (GETVALUE&PUSH 5)                   ; INTEGER-INFO
35    (LOAD&JMPIFNOT 0 L56)
38    L38
38    (LOAD 0)
39    (CAR)
40    (CDR)
41    (CAR&PUSH)
42    (LOAD 1)
43    (CAR)
44    (CDR)
45    (CDR)
46    (CAR&PUSH)
47    (LIST&PUSH 2)
49    (CALL1 7)                           ; I-$REMOVE
51    (LOAD&CDR&STORE 0)
53    (LOAD&JMPIF 0 L38)
56    L56
56    (SKIP 1)
58    (GETVALUE 8)                        ; OLD-INTEGER-INFO
60    (SETVALUE 5)                        ; INTEGER-INFO
62    L62
62    (GETVALUE&PUSH 9)                   ; GLOBAL-ASSUMPTIONS
64    (LOAD&JMPIFNOT 0 L76)
67    L67
67    (LOAD&CAR&PUSH 0)
69    (CALL1 10)                          ; ASSUME
71    (LOAD&CDR&STORE 0)
73    (LOAD&JMPIF 0 L67)
76    L76
76    (T)
77    (SKIP&RET 2)


Disassembly of function #:|(DEFUN BOTH-SIDE (EXP VAR VAL) ...)-25|
(CONST 0) = BOTH-SIDE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BOTH-SIDE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BOTH-SIDE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BOTH-SIDE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BOTH-SIDE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BOTH-SIDE
8     (SKIP&RET 1)


Disassembly of function BOTH-SIDE
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = PRESERVE-DIRECTION
(CONST 4) = $PLUS
(CONST 5) = $LIMIT
(CONST 6) = $MINUS
(CONST 7) = LB
(CONST 8) = RIDOFAB
(CONST 9) = ALIKE1
(CONST 10) = %LIMIT
(CONST 11) = FREE
(CONST 12) = $UND
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LB VAL VAR EXP)
44 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (T)
10    (BIND 3)                            ; PRESERVE-DIRECTION
12    (GETVALUE&PUSH 0)                   ; EXP
14    (GETVALUE&PUSH 1)                   ; VAR
16    (GETVALUE&PUSH 2)                   ; VAL
18    (CONST&PUSH 4)                      ; $PLUS
19    (CALL&PUSH 4 5)                     ; $LIMIT
22    (GETVALUE&PUSH 0)                   ; EXP
24    (GETVALUE&PUSH 1)                   ; VAR
26    (GETVALUE&PUSH 2)                   ; VAL
28    (CONST&PUSH 6)                      ; $MINUS
29    (CALL 4 5)                          ; $LIMIT
32    (BIND 7)                            ; LB
34    (LOAD&PUSH 3)
35    (CALL1&PUSH 8)                      ; RIDOFAB
37    (GETVALUE&PUSH 7)                   ; LB
39    (CALL1&PUSH 8)                      ; RIDOFAB
41    (CALL2&JMPIF 9 L62)                 ; ALIKE1
44    (LOAD&PUSH 3)
45    (CONST&PUSH 10)                     ; %LIMIT
46    (CALL2&JMPIF 11 L54)                ; FREE
49    (LOAD&PUSH 3)
50    (CONST&PUSH 10)                     ; %LIMIT
51    (CALL2&JMPIFNOT 11 L67)             ; FREE
54    L54
54    (CONST 12)                          ; $UND
55    L55
55    (UNBIND1)
56    (SKIP 1)
58    (UNBIND 4)
60    (SKIP&RET 4)
62    L62
62    (LOAD&PUSH 3)
63    (CALL1 8)                           ; RIDOFAB
65    (JMP L55)
67    L67
67    (NIL)
68    (JMP L55)


Disassembly of function #:|(DEFUN LIMUNKNOWN (F) ...)-26|
(CONST 0) = LIMUNKNOWN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMUNKNOWN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMUNKNOWN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMUNKNOWN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMUNKNOWN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMUNKNOWN
8     (SKIP&RET 1)


Disassembly of function LIMUNKNOWN
(CONST 0) = F
(CONST 1) = LIMUNKNOWN
(CONST 2) = SPECREPCHECK
(CONST 3) = LIMUNKNOWN1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (F)
11 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; F
3     (CONST 1)                           ; LIMUNKNOWN
4     (CATCH-OPEN L13)
6     (GETVALUE&PUSH 0)                   ; F
8     (CALL1&PUSH 2)                      ; SPECREPCHECK
10    (CALL1 3)                           ; LIMUNKNOWN1
12    (CATCH-CLOSE)
13    L13
13    (UNBIND1)
14    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LIMUNKNOWN1 (F) ...)-27|
(CONST 0) = LIMUNKNOWN1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMUNKNOWN1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMUNKNOWN1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMUNKNOWN1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMUNKNOWN1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMUNKNOWN1
8     (SKIP&RET 1)


Disassembly of function LIMUNKNOWN1
(CONST 0) = F
(CONST 1) = MAPATOM
(CONST 2) = OPERATORS
(CONST 3) = SAFE-GET
(CONST 4) = (%SUM %PRODUCT %SIGNUM MNCEXPT)
(CONST 5) = MEMQ
(CONST 6) = MQAPPLY
(CONST 7) = SUBFUNNAME
(CONST 8) = SPECSIMP
(CONST 9) = VAR
(CONST 10) = FREE
(CONST 11) = LIMUNKNOWN
(CONST 12) = LIMUNKNOWN1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR F)
44 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; F
3     (GETVALUE&PUSH 0)                   ; F
5     (CALL1&JMPIF 1 L53)                 ; MAPATOM
8     (GETVALUE 0)                        ; F
10    (CAR)
11    (CAR&PUSH)
12    (CONST&PUSH 2)                      ; OPERATORS
13    (CALL2&JMPIFNOT 3 L56)              ; SAFE-GET
16    (GETVALUE 0)                        ; F
18    (CAR)
19    (CAR&PUSH)
20    (CONST&PUSH 4)                      ; (%SUM %PRODUCT %SIGNUM MNCEXPT)
21    (CALL2&JMPIF 5 L56)                 ; MEMQ
24    (GETVALUE 0)                        ; F
26    (CAR)
27    (CAR&PUSH)
28    (JMPIFNOTEQTO 6 L41)                ; MQAPPLY
31    (GETVALUE&PUSH 0)                   ; F
33    (CALL1&PUSH 7)                      ; SUBFUNNAME
35    (CONST&PUSH 8)                      ; SPECSIMP
36    (PUSH-UNBOUND 1)
38    (CALLS2&JMPIFNOT 132 L56)           ; GET
41    L41
41    (CONST&SYMBOL-FUNCTION&PUSH 12)     ; LIMUNKNOWN1
43    (GETVALUE 0)                        ; F
45    (CDR&PUSH)
46    (CALLSR 0 24)                       ; MAPC
49    (NIL)
50    L50
50    (UNBIND1)
51    (SKIP&RET 2)
53    L53
53    (NIL)
54    (JMP L50)
56    L56
56    (GETVALUE&PUSH 0)                   ; F
58    (GETVALUE&PUSH 9)                   ; VAR
60    (CALL2 10)                          ; FREE
62    (NOT)
63    (JMPIFNOT1 L50)
65    (CONST&PUSH 11)                     ; LIMUNKNOWN
66    (T)
67    (THROW)


Disassembly of function #:|(DEFUN FACTOSIMP (E) ...)-28|
(CONST 0) = FACTOSIMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FACTOSIMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FACTOSIMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FACTOSIMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FACTOSIMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FACTOSIMP
8     (SKIP&RET 1)


Disassembly of function FACTOSIMP
(CONST 0) = E
(CONST 1) = (%GAMMA)
(CONST 2) = INVOLVE
(CONST 3) = $MAKEFACT
(CONST 4) = (MFACTORIAL)
(CONST 5) = $MINFACTORIAL
(CONST 6) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
writes special variable : (E)
22 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CONST&PUSH 1)                      ; (%GAMMA)
6     (CALL2&JMPIFNOT 2 L15)              ; INVOLVE
9     (GETVALUE&PUSH 0)                   ; E
11    (CALL1 3)                           ; $MAKEFACT
13    (SETVALUE 0)                        ; E
15    L15
15    (GETVALUE&PUSH 0)                   ; E
17    (CONST&PUSH 4)                      ; (MFACTORIAL)
18    (CALL2&JMPIF 2 L26)                 ; INVOLVE
21    (GETVALUE 0)                        ; E
23    L23
23    (UNBIND1)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE&PUSH 0)                   ; E
28    (CALL1&PUSH 5)                      ; $MINFACTORIAL
30    (CALL1 6)                           ; SIMPLIFY
32    (SETVALUE 0)                        ; E
34    (JMP L23)


Disassembly of function #:|(DEFUN GETSIGNL (Z) ...)-29|
(CONST 0) = GETSIGNL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GETSIGNL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GETSIGNL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GETSIGNL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GETSIGNL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GETSIGNL
8     (SKIP&RET 1)


Disassembly of function GETSIGNL
(CONST 0) = RIDOFAB
(CONST 1) = VAR
(CONST 2) = FREE
(CONST 3) = VAL
(CONST 4) = $LIMIT
(CONST 5) = $ASKSIGN
(CONST 6) = SIGN
(CONST 7) = $POS
(CONST 8) = 1
(CONST 9) = $NEG
(CONST 10) = -1
(CONST 11) = $ZERO
(CONST 12) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SIGN VAL VAR)
33 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; RIDOFAB
3     (LOAD&PUSH 0)
4     (GETVALUE&PUSH 1)                   ; VAR
6     (CALL2&JMPIF 2 L18)                 ; FREE
9     (LOAD&PUSH 0)
10    (GETVALUE&PUSH 1)                   ; VAR
12    (GETVALUE&PUSH 3)                   ; VAL
14    (CALL 3 4)                          ; $LIMIT
17    (STORE 0)
18    L18
18    (LOAD&PUSH 0)
19    (CALL1 5)                           ; $ASKSIGN
21    (BIND 6)                            ; SIGN
23    (GETVALUE&PUSH 6)                   ; SIGN
25    (JMPIFEQTO 7 L42)                   ; $POS
28    (GETVALUE&PUSH 6)                   ; SIGN
30    (JMPIFEQTO 9 L45)                   ; $NEG
33    (GETVALUE&PUSH 6)                   ; SIGN
35    (JMPIFEQTO 11 L48)                  ; $ZERO
38    (NIL)
39    L39
39    (UNBIND1)
40    (SKIP&RET 3)
42    L42
42    (CONST 8)                           ; 1
43    (JMP L39)
45    L45
45    (CONST 10)                          ; -1
46    (JMP L39)
48    L48
48    (CONST 12)                          ; 0
49    (JMP L39)


Disassembly of function #:|(DEFUN RESTORELIM (EXP) ...)-30|
(CONST 0) = RESTORELIM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RESTORELIM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RESTORELIM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RESTORELIM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RESTORELIM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RESTORELIM
8     (SKIP&RET 1)


Disassembly of function RESTORELIM
(CONST 0) = EXP
(CONST 1) = LIMITSUB
(CONST 2) = MRAT
(CONST 3) = RESTORELIM
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
53 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (JMPIFNOT L38)
7     (GETVALUE 0)                        ; EXP
9     (JMPIFATOM L41)
11    (GETVALUE 0)                        ; EXP
13    (CAR)
14    (JMPIFATOM L23)
16    (GETVALUE 0)                        ; EXP
18    (CAR)
19    (CAR&PUSH)
20    (JMPIFEQTO 2 L59)                   ; MRAT
23    L23
23    (GETVALUE 0)                        ; EXP
25    (CAR&PUSH)
26    (CONST&SYMBOL-FUNCTION&PUSH 3)      ; RESTORELIM
28    (GETVALUE 0)                        ; EXP
30    (CDR&PUSH)
31    (CALLSR 0 22)                       ; MAPCAR
34    (CONS)
35    L35
35    (UNBIND1)
36    (SKIP&RET 2)
38    L38
38    (NIL)
39    (JMP L35)
41    L41
41    (GETVALUE&PUSH 0)                   ; EXP
43    (CALLS2&JMPIFNOT 6 L55)             ; SYMBOLP
46    (GETVALUE&PUSH 0)                   ; EXP
48    (CONST&PUSH 1)                      ; LIMITSUB
49    (PUSH-UNBOUND 1)
51    (CALLS2 132)                        ; GET
53    (JMPIF1 L35)
55    L55
55    (GETVALUE 0)                        ; EXP
57    (JMP L35)
59    L59
59    (GETVALUE 0)                        ; EXP
61    (CAR&PUSH)
62    (GETVALUE 0)                        ; EXP
64    (CDR)
65    (CAR&PUSH)
66    (JSR&PUSH L0)
69    (GETVALUE 0)                        ; EXP
71    (CDR)
72    (CDR&PUSH)
73    (JSR L0)
76    (CONS)
77    (CONS)
78    (JMP L35)


Disassembly of function #:|(DEFUN MABS-SUBST (EXP VAR VAL) ...)-31|
(CONST 0) = MABS-SUBST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MABS-SUBST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MABS-SUBST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MABS-SUBST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MABS-SUBST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MABS-SUBST
8     (SKIP&RET 1)


Disassembly of function MABS-SUBST
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = (MABS)
(CONST 4) = INVOLVE
(CONST 5) = D
(CONST 6) = THINK
(CONST 7) = LIMIT
(CONST 8) = $IMAGPART
(CONST 9) = 0
(CONST 10) = MABS
(CONST 11) = RETN
(CONST 12) = ANS
(CONST 13) = A
(CONST 14) = $ZEROA
(CONST 15) = $ZEROB
(CONST 16) = REAL-INFINITIES
(CONST 17) = MEMQ
(CONST 18) = BOTH
(CONST 19) = ZEROP1
(CONST 20) = BEHAVIOR
(CONST 21) = $INF
(CONST 22) = RATGREATERP
(CONST 23) = (MABS)
(CONST 24) = MAXIMA-SUBSTITUTE
(CONST 25) = $MINF
(CONST 26) = -1
(CONST 27) = MUL*
(CONST 28) = (MABS)
(CONST 29) = $UND
(CONST 30) = (MABS)
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (REAL-INFINITIES A ANS VAL VAR D EXP)
writes special variables : (ANS EXP D A)
141 byte-code instructions:
0     L0
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CONST&PUSH 3)                      ; (MABS)
12    (CALL2 4)                           ; INVOLVE
14    (BIND 5)                            ; D
16    (GETVALUE 5)                        ; D
18    (JMPIFNOT L212)
21    (GETVALUE&PUSH 5)                   ; D
23    (GETVALUE&PUSH 1)                   ; VAR
25    (GETVALUE&PUSH 2)                   ; VAL
27    (CONST&PUSH 6)                      ; THINK
28    (CALL&PUSH 4 7)                     ; LIMIT
31    (CALL1&PUSH 8)                      ; $IMAGPART
33    (JMPIFNOTEQTO 9 L217)               ; 0
37    (GETVALUE&PUSH 1)                   ; VAR
39    (CALL1&PUSH 8)                      ; $IMAGPART
41    (JMPIFNOTEQTO 9 L217)               ; 0
45    (GETVALUE 5)                        ; D
47    (BIND 12)                           ; ANS
49    (NIL)
50    (BIND 13)                           ; A
52    (GETVALUE 12)                       ; ANS
54    (JMPIFNOT L204)
57    L57
57    (GETVALUE&PUSH 12)                  ; ANS
59    (GETVALUE&PUSH 1)                   ; VAR
61    (GETVALUE&PUSH 2)                   ; VAL
63    (JSR L0)
66    (SETVALUE 13)                       ; A
68    (PUSH)
69    (GETVALUE&PUSH 1)                   ; VAR
71    (GETVALUE&PUSH 2)                   ; VAL
73    (T&PUSH)
74    (CALL 4 7)                          ; LIMIT
77    (SETVALUE 5)                        ; D
79    (GETVALUE 13)                       ; A
81    (JMPIFNOT L220)
84    (GETVALUE 5)                        ; D
86    (JMPIFNOT L220)
89    (GETVALUE 13)                       ; A
91    (JMPIFNOT L247)
94    (GETVALUE 5)                        ; D
96    (JMPIFNOT L247)
99    (GETVALUE&PUSH 5)                   ; D
101   (CALL1&JMPIFNOT 19 L120)            ; ZEROP1
104   (GETVALUE&PUSH 13)                  ; A
106   (GETVALUE&PUSH 1)                   ; VAR
108   (GETVALUE&PUSH 2)                   ; VAL
110   (CALL 3 20)                         ; BEHAVIOR
113   (SETVALUE 5)                        ; D
115   (PUSH)
116   (CALL1&JMPIF 19 L240)               ; ZEROP1
120   L120
120   (GETVALUE&PUSH 5)                   ; D
122   (JMPIFEQTO 14 L136)                 ; $ZEROA
125   (GETVALUE&PUSH 5)                   ; D
127   (JMPIFEQTO 21 L136)                 ; $INF
130   (GETVALUE&PUSH 5)                   ; D
132   (CONST&PUSH 9)                      ; 0
133   (CALL2&JMPIFNOT 22 L150)            ; RATGREATERP
136   L136
136   (GETVALUE&PUSH 13)                  ; A
138   (CONST&PUSH 23)                     ; (MABS)
139   (GETVALUE&PUSH 12)                  ; ANS
141   (LIST&PUSH 2)
143   (GETVALUE&PUSH 0)                   ; EXP
145   (CALL 3 24)                         ; MAXIMA-SUBSTITUTE
148   (SETVALUE 0)                        ; EXP
150   L150
150   (GETVALUE&PUSH 5)                   ; D
152   (JMPIFEQTO 15 L166)                 ; $ZEROB
155   (GETVALUE&PUSH 5)                   ; D
157   (JMPIFEQTO 25 L166)                 ; $MINF
160   (CONST&PUSH 9)                      ; 0
161   (GETVALUE&PUSH 5)                   ; D
163   (CALL2&JMPIFNOT 22 L183)            ; RATGREATERP
166   L166
166   (CONST&PUSH 26)                     ; -1
167   (GETVALUE&PUSH 13)                  ; A
169   (CALL2&PUSH 27)                     ; MUL*
171   (CONST&PUSH 28)                     ; (MABS)
172   (GETVALUE&PUSH 12)                  ; ANS
174   (LIST&PUSH 2)
176   (GETVALUE&PUSH 0)                   ; EXP
178   (CALL 3 24)                         ; MAXIMA-SUBSTITUTE
181   (SETVALUE 0)                        ; EXP
183   L183
183   (GETVALUE&PUSH 5)                   ; D
185   (JMPIFEQTO 29 L243)                 ; $UND
188   L188
188   (GETVALUE&PUSH 0)                   ; EXP
190   (CONST&PUSH 30)                     ; (MABS)
192   (CALL2 4)                           ; INVOLVE
194   (SETVALUE 12)                       ; ANS
196   (NIL)
197   (SETVALUE 13)                       ; A
199   (GETVALUE 12)                       ; ANS
201   (JMPIF L57)
204   L204
204   (GETVALUE 0)                        ; EXP
206   (UNBIND 3)
208   L208
208   (UNBIND 3)
210   (SKIP&RET 4)
212   L212
212   (GETVALUE 0)                        ; EXP
214   (UNBIND1)
215   (JMP L208)
217   L217
217   (CONST&PUSH 10)                     ; MABS
218   (CONST 11)                          ; RETN
219   (THROW)
220   L220
220   (GETVALUE&PUSH 2)                   ; VAL
222   (JMPIFEQTO 14 L188)                 ; $ZEROA
225   (GETVALUE&PUSH 2)                   ; VAL
227   (JMPIFEQTO 15 L188)                 ; $ZEROB
230   (GETVALUE&PUSH 2)                   ; VAL
232   (GETVALUE&PUSH 16)                  ; REAL-INFINITIES
234   (CALL2&JMPIF 17 L188)               ; MEMQ
237   (CONST&PUSH 10)                     ; MABS
238   (CONST 18)                          ; BOTH
239   (THROW)
240   L240
240   (CONST&PUSH 10)                     ; MABS
241   (CONST 11)                          ; RETN
242   (THROW)
243   L243
243   (CONST&PUSH 10)                     ; MABS
244   (CONST 29)                          ; $UND
246   (THROW)
247   L247
247   (CONST&PUSH 10)                     ; MABS
248   (CONST 11)                          ; RETN
249   (THROW)


Disassembly of function #:|(DEFUN INFCOUNT (EXP) ...)-32|
(CONST 0) = INFCOUNT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INFCOUNT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFCOUNT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INFCOUNT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INFCOUNT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INFCOUNT
8     (SKIP&RET 1)


Disassembly of function INFCOUNT
(CONST 0) = EXP
(CONST 1) = INFINITIES
(CONST 2) = MEMQ
(CONST 3) = 1
(CONST 4) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES EXP)
24 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (JMPIFATOM L26)
7     (GETVALUE 0)                        ; EXP
9     (CAR&PUSH)
10    (JSR&PUSH L0)
12    (GETVALUE 0)                        ; EXP
14    (CDR&PUSH)
15    (JSR&PUSH L0)
17    (CALLSR 2 53)                       ; +
20    L20
20    (UNBIND1)
21    (SKIP&RET 2)
23    L23
23    (CONST 3)                           ; 1
24    (JMP L20)
26    L26
26    (GETVALUE&PUSH 0)                   ; EXP
28    (GETVALUE&PUSH 1)                   ; INFINITIES
30    (CALL2&JMPIF 2 L23)                 ; MEMQ
33    (CONST 4)                           ; 0
34    (JMP L20)


Disassembly of function #:|(DEFUN SIMPINF (EXP) ...)-33|
(CONST 0) = SIMPINF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPINF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPINF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPINF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPINF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPINF
8     (SKIP&RET 1)


Disassembly of function SIMPINF
(CONST 0) = EXP
(CONST 1) = INFCOUNT
(CONST 2) = 0
(CONST 3) = 1
(CONST 4) = INFINITIES
(CONST 5) = AMONGL
(CONST 6) = VAR
(CONST 7) = $LIMIT
(CONST 8) = SIMPINF
(CONST 9) = $UND
(CONST 10) = AMONG
(CONST 11) = (%LIMIT $IND)
(CONST 12) = MTIMESP
(CONST 13) = ZL-MEMBER
(CONST 14) = $INFINITY
(CONST 15) = MEMQ
(CONST 16) = VAL
(CONST 17) = SIMPLIMIT
(CONST 18) = MEXPTP
(CONST 19) = $INF
(CONST 20) = $%E
(CONST 21) = (%LOG)
(CONST 22) = MUL*
(CONST 23) = POWER*
(CONST 24) = 2
(CONST 25) = MPLUSP
(CONST 26) = ($INFINITY $MINF INF)
(CONST 27) = ZL-DELETE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR INFINITIES EXP)
157 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&PUSH 1)                      ; INFCOUNT
7     (NIL&PUSH)
8     (LOAD&PUSH 1)
9     (CONST&PUSH 2)                      ; 0
10    (CALLSR&JMPIF 1 45 L47)             ; =
14    (LOAD&PUSH 1)
15    (CONST&PUSH 3)                      ; 1
16    (CALLSR&JMPIF 1 45 L54)             ; =
20    (GETVALUE 0)                        ; EXP
22    (CAR&PUSH)
23    (CONST&PUSH 8)                      ; SIMPINF
24    (GETVALUE 0)                        ; EXP
26    (CDR&PUSH)
27    (CALLSR 0 22)                       ; MAPCAR
30    (CONS)
31    (STORE 0)
32    (PUSH)
33    (CALL1 1)                           ; INFCOUNT
35    (STORE 1)
36    (CONST&PUSH 9)                      ; $UND
37    (LOAD&PUSH 1)
38    (CALL2&JMPIF 10 L82)                ; AMONG
41    (CONST&PUSH 11)                     ; (%LIMIT $IND)
42    (LOAD&PUSH 1)
43    (CALL2&JMPIFNOT 5 L173)             ; AMONGL
47    L47
47    (GETVALUE 0)                        ; EXP
49    (SKIP 2)
51    (JMP L242)
54    L54
54    (GETVALUE&PUSH 4)                   ; INFINITIES
56    (GETVALUE&PUSH 0)                   ; EXP
58    (CALL2 5)                           ; AMONGL
60    (CAR)
61    (STORE 1)
62    (GETVALUE&PUSH 6)                   ; VAR
64    (LOAD&PUSH 2)
65    (GETVALUE&PUSH 0)                   ; EXP
67    (PUSH-UNBOUND 3)
69    (CALLS1&PUSH 172)                   ; SUBST
71    (GETVALUE&PUSH 6)                   ; VAR
73    (LOAD&PUSH 3)
74    (CALL 3 7)                          ; $LIMIT
77    (SKIP 2)
79    (JMP L242)
82    L82
82    (CONST 9)                           ; $UND
83    (SKIP 2)
85    (JMP L242)
88    L88
88    (CONST 9)                           ; $UND
89    (SKIP 2)
91    (JMP L242)
94    L94
94    (LOAD&PUSH 1)
95    (CONST&PUSH 2)                      ; 0
96    (CALLSR&JMPIF 1 48 L88)             ; >
100   (CONST 2)                           ; 0
101   (SKIP 2)
103   (JMP L242)
106   L106
106   (CONST 14)                          ; $INFINITY
107   (SKIP 2)
109   (JMP L242)
112   L112
112   (CONST&PUSH 2)                      ; 0
113   (LOAD&PUSH 1)
114   (CALL2&JMPIF 13 L94)                ; ZL-MEMBER
117   (CONST&PUSH 14)                     ; $INFINITY
118   (LOAD&PUSH 1)
119   (CALL2&JMPIF 15 L106)               ; MEMQ
122   (LOAD&PUSH 0)
123   (GETVALUE&PUSH 6)                   ; VAR
125   (GETVALUE&PUSH 16)                  ; VAL
127   (CALL 3 17)                         ; SIMPLIMIT
130   (SKIP 2)
132   (JMP L242)
135   L135
135   (CONST 19)                          ; $INF
136   (SKIP 2)
138   (JMP L242)
141   L141
141   (LOAD 0)
142   (CDR)
143   (CAR&PUSH)
144   (JMPIFNOTEQTO 19 L154)              ; $INF
147   (LOAD 0)
148   (CDR)
149   (CDR)
150   (CAR&PUSH)
151   (JMPIFEQTO 19 L135)                 ; $INF
154   L154
154   (CONST&PUSH 20)                     ; $%E
155   (GETVALUE 0)                        ; EXP
157   (CDR)
158   (CDR)
159   (CAR&PUSH)
160   (CONST&PUSH 21)                     ; (%LOG)
161   (GETVALUE 0)                        ; EXP
163   (CDR)
164   (CAR&PUSH)
165   (LIST&PUSH 2)
167   (CALL2&PUSH 22)                     ; MUL*
169   (CALL2 23)                          ; POWER*
171   (JMP L189)
173   L173
173   (LOAD&PUSH 0)
174   (CALL1&JMPIF 12 L112)               ; MTIMESP
178   (LOAD&PUSH 0)
179   (CALL1&JMPIF 18 L141)               ; MEXPTP
182   (LOAD&PUSH 1)
183   (CONST&PUSH 24)                     ; 2
184   (CALLSR&JMPIFNOT 1 47 L235)         ; <
188   (LOAD 0)
189   L189
189   (PUSH)
190   (JSR L0)
193   (SKIP 2)
195   (JMP L242)
197   L197
197   (CONST 14)                          ; $INFINITY
198   (SKIP 2)
200   (JMP L242)
202   L202
202   (CONST 9)                           ; $UND
203   (SKIP 2)
205   (JMP L242)
207   L207
207   (CONST&PUSH 14)                     ; $INFINITY
208   (LOAD&CDR&PUSH 1)
210   (CALL2&JMPIF 15 L197)               ; MEMQ
213   (GETVALUE&PUSH 4)                   ; INFINITIES
215   (LOAD&PUSH 1)
216   (CALL2 5)                           ; AMONGL
218   (CAR)
219   (STORE 1)
220   (PUSH)
221   (CONST&PUSH 26)                     ; ($INFINITY $MINF INF)
222   (CALLS1&PUSH 158)                   ; COPY-LIST
224   (CALL2&PUSH 27)                     ; ZL-DELETE
226   (LOAD&PUSH 1)
227   (CALL2&JMPIF 5 L202)                ; AMONGL
230   (LOAD 1)
231   (SKIP 2)
233   (JMP L242)
235   L235
235   (LOAD&PUSH 0)
236   (CALL1&JMPIF 25 L207)               ; MPLUSP
239   (POP)
240   (SKIP 1)
242   L242
242   (UNBIND1)
243   (SKIP&RET 2)


Disassembly of function #:|(DEFUN SIMPAB (SMALL) ...)-34|
(CONST 0) = SIMPAB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPAB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPAB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPAB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPAB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPAB
8     (SKIP&RET 1)


Disassembly of function SIMPAB
(CONST 0) = ($ZEROA $ZEROB $INF $MINF $INFINITY)
(CONST 1) = MEMQ
(CONST 2) = $IND
(CONST 3) = FREE
(CONST 4) = $UND
(CONST 5) = MAPATOM
(CONST 6) = INFINITIES
(CONST 7) = $ZEROA
(CONST 8) = $ZEROB
(CONST 9) = LIMIT
(CONST 10) = EPSILON
(CONST 11) = -1
(CONST 12) = MUL*
(CONST 13) = PRESERVE-DIRECTION
(CONST 14) = THINK
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (INFINITIES)
69 byte-code instructions:
0     (LOAD&JMPIFNOT 1 L25)
3     (LOAD&PUSH 1)
4     (CONST&PUSH 0)                      ; ($ZEROA $ZEROB $INF $MINF ...)
5     (CALL2&JMPIF 1 L22)                 ; MEMQ
8     (LOAD&PUSH 1)
9     (CONST&PUSH 2)                      ; $IND
10    (CALL2&JMPIFNOT 3 L28)              ; FREE
13    (LOAD&PUSH 1)
14    (CONST&PUSH 4)                      ; $UND
15    (CALL2&JMPIFNOT 3 L31)              ; FREE
18    (LOAD&PUSH 1)
19    (CALL1&JMPIFNOT 5 L49)              ; MAPATOM
22    L22
22    (LOAD 1)
23    (SKIP&RET 2)
25    L25
25    (NIL)
26    (SKIP&RET 2)
28    L28
28    (CONST 2)                           ; $IND
29    (SKIP&RET 2)
31    L31
31    (CONST 4)                           ; $UND
32    (SKIP&RET 2)
34    L34
34    (SKIP 1)
36    (LOAD&PUSH 1)
37    (CONST&PUSH 7)                      ; $ZEROA
38    (CALL2&JMPIFNOT 3 L46)              ; FREE
41    (LOAD&PUSH 1)
42    (CONST&PUSH 8)                      ; $ZEROB
43    (CALL2&JMPIF 3 L67)                 ; FREE
46    L46
46    (CONST&PUSH 9)                      ; LIMIT
47    (T)
48    (THROW)
49    L49
49    (GETVALUE&PUSH 6)                   ; INFINITIES
51    (LOAD&JMPIFNOT 0 L65)
54    L54
54    (LOAD&CAR&PUSH 0)
56    (LOAD&PUSH 3)
57    (CALL2&JMPIFNOT 3 L34)              ; FREE
60    (LOAD&CDR&STORE 0)
62    (LOAD&JMPIF 0 L54)
65    L65
65    (SKIP 1)
67    L67
67    (T&PUSH)
68    (CONST&PUSH 10)                     ; EPSILON
69    (CONST&PUSH 7)                      ; $ZEROA
70    (CONST&PUSH 11)                     ; -1
71    (CONST&PUSH 10)                     ; EPSILON
72    (CALL2&PUSH 12)                     ; MUL*
74    (CONST&PUSH 8)                      ; $ZEROB
75    (LOAD&PUSH 6)
76    (PUSH-UNBOUND 3)
78    (CALLS1&PUSH 172)                   ; SUBST
80    (PUSH-UNBOUND 3)
82    (CALLS1&PUSH 172)                   ; SUBST
84    (LOAD 1)
85    (BIND 13)                           ; PRESERVE-DIRECTION
87    (LOAD&PUSH 3)
88    (CONST&PUSH 10)                     ; EPSILON
89    (CONST&PUSH 7)                      ; $ZEROA
90    (CONST&PUSH 14)                     ; THINK
91    (CALL 4 9)                          ; LIMIT
94    (UNBIND1)
95    (SKIP&RET 4)


Disassembly of function #:|(DEFMFUN LIMIT (EXP VAR VAL ...) ...)-35|
(CONST 0) = LIMIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT
8     (SKIP&RET 1)


Disassembly of function LIMIT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = *I*
(CONST 4) = $UND
(CONST 5) = AMONG
(CONST 6) = ($INF $MINF $INFINITY $IND)
(CONST 7) = AMONGL
(CONST 8) = SIMPINF
(CONST 9) = GETLIMVAL
(CONST 10) = $TLIMSWITCH
(CONST 11) = TAYLORED
(CONST 12) = TLIMP
(CONST 13) = TAYLIM
(CONST 14) = RATP
(CONST 15) = RATLIM
(CONST 16) = RADICALP
(CONST 17) = LIMIT1
(CONST 18) = THINK
(CONST 19) = MTIMESP
(CONST 20) = MEXPTP
(CONST 21) = SIMPLIMIT
(CONST 22) = PUTLIMVAL
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL *I* TAYLORED $TLIMSWITCH VAR EXP)
90 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; VAL
9     (LOAD 10)
10    (BIND 3)                            ; *I*
12    (CONST&PUSH 4)                      ; $UND
13    (GETVALUE&PUSH 0)                   ; EXP
15    (CALL2&JMPIF 5 L108)                ; AMONG
19    (GETVALUE&PUSH 1)                   ; VAR
21    (GETVALUE 0)                        ; EXP
23    (JMPIFEQ L111)
26    (GETVALUE 0)                        ; EXP
28    (JMPIFATOM L115)
31    (GETVALUE&PUSH 1)                   ; VAR
33    (GETVALUE&PUSH 0)                   ; EXP
35    (CALL2&JMPIFNOT 5 L125)             ; AMONG
39    (GETVALUE&PUSH 0)                   ; EXP
41    (CALL1 9)                           ; GETLIMVAL
43    (JMPIF1 L161)
46    (GETVALUE&PUSH 0)                   ; EXP
48    (GETVALUE 10)                       ; $TLIMSWITCH
50    (JMPIFNOT L62)
52    (GETVALUE 11)                       ; TAYLORED
54    (JMPIF L62)
56    (GETVALUE&PUSH 0)                   ; EXP
58    (CALL1&JMPIF 12 L135)               ; TLIMP
62    L62
62    (GETVALUE&PUSH 0)                   ; EXP
64    (GETVALUE&PUSH 1)                   ; VAR
66    (CALL2&JMPIF 14 L143)               ; RATP
70    (GETVALUE&PUSH 3)                   ; *I*
72    (T)
73    (JMPIFEQ L97)
75    (GETVALUE&PUSH 0)                   ; EXP
77    (GETVALUE&PUSH 1)                   ; VAR
79    (CALL2&JMPIF 16 L97)                ; RADICALP
82    (GETVALUE&PUSH 3)                   ; *I*
84    (JMPIFNOTEQTO 18 L149)              ; THINK
87    (GETVALUE&PUSH 0)                   ; EXP
89    (CALL1&JMPIF 19 L97)                ; MTIMESP
92    (GETVALUE&PUSH 0)                   ; EXP
94    (CALL1&JMPIFNOT 20 L149)            ; MEXPTP
97    L97
97    (GETVALUE&PUSH 0)                   ; EXP
99    (GETVALUE&PUSH 1)                   ; VAR
101   (GETVALUE&PUSH 2)                   ; VAL
103   (CALL 3 17)                         ; LIMIT1
106   (JMP L158)
108   L108
108   (CONST 4)                           ; $UND
109   (JMP L161)
111   L111
111   (GETVALUE 2)                        ; VAL
113   (JMP L161)
115   L115
115   (GETVALUE 0)                        ; EXP
117   (JMP L161)
119   L119
119   (GETVALUE&PUSH 0)                   ; EXP
121   (CALL1 8)                           ; SIMPINF
123   (JMP L161)
125   L125
125   (CONST&PUSH 6)                      ; ($INF $MINF $INFINITY $IND)
126   (GETVALUE&PUSH 0)                   ; EXP
128   (CALL2&JMPIF 7 L119)                ; AMONGL
131   (GETVALUE 0)                        ; EXP
133   (JMP L161)
135   L135
135   (GETVALUE&PUSH 0)                   ; EXP
137   (GETVALUE&PUSH 3)                   ; *I*
139   (CALL2 13)                          ; TAYLIM
141   (JMP L158)
143   L143
143   (GETVALUE&PUSH 0)                   ; EXP
145   (CALL1 15)                          ; RATLIM
147   (JMP L158)
149   L149
149   (GETVALUE&PUSH 0)                   ; EXP
151   (GETVALUE&PUSH 1)                   ; VAR
153   (GETVALUE&PUSH 2)                   ; VAL
155   (CALL 3 21)                         ; SIMPLIMIT
158   L158
158   (PUSH)
159   (CALL2 22)                          ; PUTLIMVAL
161   L161
161   (UNBIND 4)
163   (SKIP&RET 5)


Disassembly of function #:|(DEFUN LIMITSIMP (EXP VAR) ...)-36|
(CONST 0) = LIMITSIMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMITSIMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMITSIMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMITSIMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMITSIMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMITSIMP
8     (SKIP&RET 1)


Disassembly of function LIMITSIMP
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = SIN-SQ-COS-SQ-SUB
(CONST 3) = LIMITSIMP-DISPATCH
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
10 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1&PUSH 2)                      ; SIN-SQ-COS-SQ-SUB
10    (GETVALUE&PUSH 1)                   ; VAR
12    (CALL2 3)                           ; LIMITSIMP-DISPATCH
14    (UNBIND 2)
16    (SKIP&RET 3)


Disassembly of function #:|(DEFUN LIMITSIMP-DISPATCH (EXP VAR) ...)-37|
(CONST 0) = LIMITSIMP-DISPATCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMITSIMP-DISPATCH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMITSIMP-DISPATCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMITSIMP-DISPATCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMITSIMP-DISPATCH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMITSIMP-DISPATCH
8     (SKIP&RET 1)


Disassembly of function LIMITSIMP-DISPATCH
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = MNUMP
(CONST 3) = FREEOF
(CONST 4) = MEXPTP
(CONST 5) = LIMITSIMP-EXPT
(CONST 6) = X
(CONST 7) = SUBST0
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (X VAR EXP)
56 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 0)                        ; EXP
8     (JMPIFATOM L39)
10    (GETVALUE&PUSH 0)                   ; EXP
12    (CALL1&JMPIF 2 L39)                 ; MNUMP
15    (GETVALUE&PUSH 1)                   ; VAR
17    (GETVALUE&PUSH 0)                   ; EXP
19    (CALL2&JMPIF 3 L39)                 ; FREEOF
22    (GETVALUE&PUSH 0)                   ; EXP
24    (CALL1&JMPIF 4 L43)                 ; MEXPTP
27    (GETVALUE 0)                        ; EXP
29    (CAR)
30    (CAR&PUSH)
31    (NIL)
32    (CONS&PUSH)
33    (NIL&PUSH)
34    (GETVALUE 0)                        ; EXP
36    (CDR&PUSH)
37    (JMP L70)
39    L39
39    (GETVALUE 0)                        ; EXP
41    (JMP L86)
43    L43
43    (GETVALUE&PUSH 0)                   ; EXP
45    (GETVALUE&PUSH 1)                   ; VAR
47    (CALL2 5)                           ; LIMITSIMP-EXPT
49    (JMP L86)
51    L51
51    (LOAD&CAR&PUSH 0)
53    (LOAD 0)
54    (BIND 6)                            ; X
56    (GETVALUE&PUSH 6)                   ; X
58    (GETVALUE&PUSH 1)                   ; VAR
60    (JSR L0)
62    (UNBIND1)
63    (PUSH)
64    (LOAD&CONS&STORE 2)
66    (SKIP 1)
68    (LOAD&CDR&STORE 0)
70    L70
70    (LOAD&PUSH 0)
71    (CALLS1&JMPIFNOT 146 L51)           ; ENDP
74    (SKIP 1)
76    (LOAD&PUSH 0)
77    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
79    (SKIP 1)
81    (CONS&PUSH)
82    (GETVALUE&PUSH 0)                   ; EXP
84    (CALL2 7)                           ; SUBST0
86    L86
86    (UNBIND 2)
88    (SKIP&RET 3)


Disassembly of function #:|(DEFUN LIMITSIMP-EXPT (EXP VAR) ...)-38|
(CONST 0) = LIMITSIMP-EXPT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMITSIMP-EXPT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMITSIMP-EXPT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMITSIMP-EXPT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMITSIMP-EXPT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMITSIMP-EXPT
8     (SKIP&RET 1)


Disassembly of function LIMITSIMP-EXPT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = MEXPTP
(CONST 3) = FREEOF
(CONST 4) = $%E
(CONST 5) = (%LOG)
(CONST 6) = SIMPLIFY
(CONST 7) = POWER*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
30 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1&JMPIFNOT 2 L30)              ; MEXPTP
11    (GETVALUE&PUSH 1)                   ; VAR
13    (GETVALUE 0)                        ; EXP
15    (CDR)
16    (CAR&PUSH)
17    (CALL2&JMPIF 3 L30)                 ; FREEOF
20    (GETVALUE&PUSH 1)                   ; VAR
22    (GETVALUE 0)                        ; EXP
24    (CDR)
25    (CDR)
26    (CAR&PUSH)
27    (CALL2&JMPIFNOT 3 L36)              ; FREEOF
30    L30
30    (GETVALUE 0)                        ; EXP
32    L32
32    (UNBIND 2)
34    (SKIP&RET 3)
36    L36
36    (CONST&PUSH 4)                      ; $%E
37    (CONST&PUSH 5)                      ; (%LOG)
38    (GETVALUE&PUSH 0)                   ; EXP
40    (LIST&PUSH 2)
42    (CALL1&PUSH 6)                      ; SIMPLIFY
44    (CALL2 7)                           ; POWER*
46    (JMP L32)


Disassembly of function #:|(DEFUN SIN-SQ-COS-SQ-SUB (EXP) ...)-39|
(CONST 0) = SIN-SQ-COS-SQ-SUB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIN-SQ-COS-SQ-SUB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIN-SQ-COS-SQ-SUB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIN-SQ-COS-SQ-SUB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIN-SQ-COS-SQ-SUB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIN-SQ-COS-SQ-SUB
8     (SKIP&RET 1)


Disassembly of function SIN-SQ-COS-SQ-SUB
(CONST 0) = EXP
(CONST 1) = (%SIN %COS)
(CONST 2) = INVOLVE
(CONST 3) = ARG
(CONST 4) = 1
(CONST 5) = -1
(CONST 6) = (%SIN)
(CONST 7) = 2
(CONST 8) = POWER
(CONST 9) = MUL*
(CONST 10) = ADD
(CONST 11) = (%COS)
(CONST 12) = (%COS)
(CONST 13) = (%SIN)
(CONST 14) = $SUBSTITUTE
(CONST 15) = (%SIN %COS)
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ARG EXP)
56 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CONST&PUSH 1)                      ; (%SIN %COS)
6     (CALL2 2)                           ; INVOLVE
8     (BIND 3)                            ; ARG
10    (GETVALUE 3)                        ; ARG
12    (JMPIFNOT L80)
15    (CONST&PUSH 4)                      ; 1
16    (CONST&PUSH 5)                      ; -1
17    (CONST&PUSH 6)                      ; (%SIN)
18    (GETVALUE&PUSH 3)                   ; ARG
20    (LIST&PUSH 2)
22    (CONST&PUSH 7)                      ; 2
23    (CALL2&PUSH 8)                      ; POWER
25    (CALL2&PUSH 9)                      ; MUL*
27    (CALL2&PUSH 10)                     ; ADD
29    (CONST&PUSH 11)                     ; (%COS)
30    (GETVALUE&PUSH 3)                   ; ARG
32    (LIST&PUSH 2)
34    (CONST&PUSH 7)                      ; 2
35    (CALL2&PUSH 8)                      ; POWER
37    (CONST&PUSH 4)                      ; 1
38    (CONST&PUSH 5)                      ; -1
39    (CONST&PUSH 12)                     ; (%COS)
40    (GETVALUE&PUSH 3)                   ; ARG
42    (LIST&PUSH 2)
44    (CONST&PUSH 7)                      ; 2
45    (CALL2&PUSH 8)                      ; POWER
47    (CALL2&PUSH 9)                      ; MUL*
49    (CALL2&PUSH 10)                     ; ADD
51    (CONST&PUSH 13)                     ; (%SIN)
52    (GETVALUE&PUSH 3)                   ; ARG
54    (LIST&PUSH 2)
56    (CONST&PUSH 7)                      ; 2
57    (CALL2&PUSH 8)                      ; POWER
59    (GETVALUE&PUSH 0)                   ; EXP
61    (CALL&PUSH 3 14)                    ; $SUBSTITUTE
64    (CALL&PUSH 3 14)                    ; $SUBSTITUTE
67    (LOAD&PUSH 0)
68    (CONST&PUSH 15)                     ; (%SIN %COS)
69    (CALL2&JMPIFNOT 2 L85)              ; INVOLVE
72    (GETVALUE 0)                        ; EXP
74    (SKIP 1)
76    (UNBIND1)
77    L77
77    (UNBIND1)
78    (SKIP&RET 2)
80    L80
80    (GETVALUE 0)                        ; EXP
82    (UNBIND1)
83    (JMP L77)
85    L85
85    (POP)
86    (UNBIND1)
87    (JMP L77)


Disassembly of function #:|(DEFUN EXPAND-TRIGS (X VAR) ...)-40|
(CONST 0) = EXPAND-TRIGS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXPAND-TRIGS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXPAND-TRIGS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXPAND-TRIGS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXPAND-TRIGS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXPAND-TRIGS
8     (SKIP&RET 1)


Disassembly of function EXPAND-TRIGS
(CONST 0) = X
(CONST 1) = VAR
(CONST 2) = MNUMP
(CONST 3) = %SIN
(CONST 4) = %COS
(CONST 5) = FREE
(CONST 6) = $TRIGEXPAND
(CONST 7) = SIMPLIFY
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR X)
67 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; X
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE 0)                        ; X
8     (JMPIFATOM L50)
10    (GETVALUE&PUSH 0)                   ; X
12    (CALL1&JMPIF 2 L54)                 ; MNUMP
15    (GETVALUE 0)                        ; X
17    (CAR)
18    (CAR&PUSH)
19    (JMPIFEQTO 3 L29)                   ; %SIN
22    (GETVALUE 0)                        ; X
24    (CAR)
25    (CAR&PUSH)
26    (JMPIFNOTEQTO 4 L38)                ; %COS
29    L29
29    (GETVALUE 0)                        ; X
31    (CDR)
32    (CAR&PUSH)
33    (GETVALUE&PUSH 1)                   ; VAR
35    (CALL2&JMPIFNOT 5 L58)              ; FREE
38    L38
38    (GETVALUE 0)                        ; X
40    (CAR)
41    (CAR&PUSH)
42    (NIL)
43    (CONS&PUSH)
44    (NIL&PUSH)
45    (GETVALUE 0)                        ; X
47    (CDR&PUSH)
48    (JMP L84)
50    L50
50    (GETVALUE 0)                        ; X
52    (JMP L98)
54    L54
54    (GETVALUE 0)                        ; X
56    (JMP L98)
58    L58
58    (GETVALUE&PUSH 0)                   ; X
60    (CALL1 6)                           ; $TRIGEXPAND
62    (JMP L98)
64    L64
64    (LOAD&CAR&PUSH 0)
66    (LOAD 0)
67    (BIND 0)                            ; X
69    (GETVALUE&PUSH 0)                   ; X
71    (GETVALUE&PUSH 1)                   ; VAR
73    (JSR L0)
76    (UNBIND1)
77    (PUSH)
78    (LOAD&CONS&STORE 2)
80    (SKIP 1)
82    (LOAD&CDR&STORE 0)
84    L84
84    (LOAD&PUSH 0)
85    (CALLS1&JMPIFNOT 146 L64)           ; ENDP
88    (SKIP 1)
90    (LOAD&PUSH 0)
91    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
93    (SKIP 1)
95    (CONS&PUSH)
96    (CALL1 7)                           ; SIMPLIFY
98    L98
98    (UNBIND 2)
100   (SKIP&RET 3)


Disassembly of function #:|(DEFUN TANSC (E) ...)-41|
(CONST 0) = TANSC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TANSC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TANSC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TANSC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TANSC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TANSC
8     (SKIP&RET 1)


Disassembly of function TANSC
(CONST 0) = E
(CONST 1) = 
(%COT %CSC %BINOMIAL %SEC %COTH %SECH %CSCH %ACOT %ACSC %ASEC %ACOTH %ASECH
 %ACSCH %JACOBI_NS %JACOBI_NC %JACOBI_CS %JACOBI_DS %JACOBI_DC)
(CONST 2) = INVOLVE
(CONST 3) = TANSC1
(CONST 4) = $RATSIMP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
14 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CONST&PUSH 1)                      ; (%COT %CSC %BINOMIAL %SEC ...)
6     (CALL2&JMPIFNOT 2 L18)              ; INVOLVE
9     (GETVALUE&PUSH 0)                   ; E
11    (CALL1&PUSH 3)                      ; TANSC1
13    (CALL1 4)                           ; $RATSIMP
15    L15
15    (UNBIND1)
16    (SKIP&RET 2)
18    L18
18    (GETVALUE 0)                        ; E
20    (JMP L15)


Disassembly of function #:|(DEFUN TANSC1 (E &AUX TEM) ...)-42|
(CONST 0) = TANSC1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TANSC1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TANSC1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TANSC1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TANSC1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TANSC1
8     (SKIP&RET 1)


Disassembly of function TANSC1
(CONST 0) = E
(CONST 1) = TANSC1
(CONST 2) = 
((%COT . %TAN) (%COTH . %TANH) (%SEC . %COS) (%SECH . %COSH) (%CSC . %SIN)
 (%CSCH . %SINH))
(CONST 3) = ASSQ
(CONST 4) = -1
(CONST 5) = POWER*
(CONST 6) = 
((%JACOBI_NC . %JACOBI_CN) (%JACOBI_NS . %JACOBI_SN) (%JACOBI_CS . %JACOBI_SC)
 (%JACOBI_DS . %JACOBI_SD) (%JACOBI_DC . %JACOBI_CD))
(CONST 7) = (%SINH %COSH %TANH)
(CONST 8) = MEMQ
(CONST 9) = $EXPONENTIALIZE
(CONST 10) = RESIMPLIFY
(CONST 11) = 
((%ACSC . %ASIN) (%ASEC . %ACOS) (%ACOT . %ATAN) (%ACSCH . %ASINH)
 (%ASECH . %ACOSH) (%ACOTH . %ATANH))
(CONST 12) = POWER
(CONST 13) = %BINOMIAL
(CONST 14) = VAR
(CONST 15) = AMONG
(CONST 16) = (MFACTORIAL)
(CONST 17) = (MFACTORIAL)
(CONST 18) = MUL*
(CONST 19) = ADD
(CONST 20) = (MFACTORIAL)
(CONST 21) = DIV*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
writes special variable : (E)
132 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL&PUSH)
4     (GETVALUE 0)                        ; E
6     (JMPIFATOM L65)
8     (GETVALUE 0)                        ; E
10    (CAR&PUSH)
11    (CONST&PUSH 1)                      ; TANSC1
12    (GETVALUE 0)                        ; E
14    (CDR&PUSH)
15    (CALLSR 0 22)                       ; MAPCAR
18    (CONS)
19    (SETVALUE 0)                        ; E
21    (GETVALUE 0)                        ; E
23    (CAR)
24    (CAR&PUSH)
25    (CONST&PUSH 2)                      ; ((%COT . %TAN) (%COTH . %TANH) ...)
26    (CALL2 3)                           ; ASSQ
28    (STORE 0)
29    (JMPIF L70)
31    (GETVALUE 0)                        ; E
33    (CAR)
34    (CAR&PUSH)
35    (CONST&PUSH 6)                      ; (# # # ...)
36    (CALL2 3)                           ; ASSQ
38    (STORE 0)
39    (JMPIFNOT L146)
42    (CDR&PUSH)
43    (NIL)
44    (CONS&PUSH)
45    (GETVALUE 0)                        ; E
47    (CDR)
48    (CAR&PUSH)
49    (GETVALUE 0)                        ; E
51    (CDR)
52    (CDR)
53    (CAR&PUSH)
54    (LIST&PUSH 3)
56    (CONST 4)                           ; -1
57    L57
57    (PUSH)
58    (CALL2&PUSH 5)                      ; POWER*
60    (JSR L0)
62    (JMP L186)
65    L65
65    (GETVALUE 0)                        ; E
67    (JMP L186)
70    L70
70    (CDR&PUSH)
71    (NIL)
72    (CONS&PUSH)
73    (GETVALUE 0)                        ; E
75    (CDR)
76    (CAR&PUSH)
77    (LIST&PUSH 2)
79    (CONST 4)                           ; -1
80    (JMP L57)
82    L82
82    (T)
83    (BIND 9)                            ; $EXPONENTIALIZE
85    (GETVALUE&PUSH 0)                   ; E
87    (CALL1 10)                          ; RESIMPLIFY
89    (UNBIND1)
90    (JMP L186)
93    L93
93    (CDR&PUSH)
94    (NIL)
95    (CONS&PUSH)
96    (GETVALUE 0)                        ; E
98    (CDR)
99    (CAR&PUSH)
100   (CONST&PUSH 4)                      ; -1
101   (CALL2&PUSH 12)                     ; POWER
103   (LIST 2)
105   (JMP L186)
108   L108
108   (CONST&PUSH 16)                     ; (MFACTORIAL)
109   (GETVALUE 0)                        ; E
111   (CDR)
112   (CAR&PUSH)
113   (LIST&PUSH 2)
115   (CONST&PUSH 17)                     ; (MFACTORIAL)
116   (GETVALUE 0)                        ; E
118   (CDR)
119   (CAR&PUSH)
120   (CONST&PUSH 4)                      ; -1
121   (GETVALUE 0)                        ; E
123   (CDR)
124   (CDR)
125   (CAR&PUSH)
126   (CALL2&PUSH 18)                     ; MUL*
128   (CALL2&PUSH 19)                     ; ADD
130   (LIST&PUSH 2)
132   (CONST&PUSH 20)                     ; (MFACTORIAL)
133   (GETVALUE 0)                        ; E
135   (CDR)
136   (CDR)
137   (CAR&PUSH)
138   (LIST&PUSH 2)
140   (CALL2&PUSH 18)                     ; MUL*
142   (CALL2 21)                          ; DIV*
144   (JMP L186)
146   L146
146   (GETVALUE 0)                        ; E
148   (CAR)
149   (CAR&PUSH)
150   (CONST&PUSH 7)                      ; (%SINH %COSH %TANH)
151   (CALL2 8)                           ; MEMQ
153   (STORE 0)
154   (JMPIF L82)
157   (GETVALUE 0)                        ; E
159   (CAR)
160   (CAR&PUSH)
161   (CONST&PUSH 11)                     ; (# # # ...)
162   (CALL2 3)                           ; ASSQ
164   (STORE 0)
165   (JMPIF L93)
168   (GETVALUE 0)                        ; E
170   (CAR)
171   (CAR&PUSH)
172   (JMPIFNOTEQTO 13 L184)              ; %BINOMIAL
175   (GETVALUE&PUSH 14)                  ; VAR
177   (GETVALUE 0)                        ; E
179   (CDR&PUSH)
180   (CALL2&JMPIF 15 L108)               ; AMONG
184   L184
184   (GETVALUE 0)                        ; E
186   L186
186   (SKIP 1)
188   (UNBIND1)
189   (SKIP&RET 2)


Disassembly of function #:|(DEFUN HYPEREX (EX) ...)-43|
(CONST 0) = HYPEREX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HYPEREX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HYPEREX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HYPEREX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HYPEREX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HYPEREX
8     (SKIP&RET 1)


Disassembly of function HYPEREX
(CONST 0) = (%SIN %COS %TAN %ASIN %ACOS %ATAN %SINH %COSH %TANH %ASINH %ACOSH %ATANH)
(CONST 1) = INVOLVE
(CONST 2) = HYPEREX0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
9 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CONST&PUSH 0)                      ; (%SIN %COS %TAN %ASIN %ACOS ...)
2     (CALL2&JMPIFNOT 1 L10)              ; INVOLVE
5     (LOAD&PUSH 1)
6     (CALL1 2)                           ; HYPEREX0
8     (SKIP&RET 2)
10    L10
10    (LOAD 1)
11    (SKIP&RET 2)


Disassembly of function #:|(DEFUN HYPEREX0 (EX) ...)-44|
(CONST 0) = HYPEREX0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HYPEREX0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HYPEREX0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HYPEREX0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HYPEREX0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HYPEREX0
8     (SKIP&RET 1)


Disassembly of function HYPEREX0
(CONST 0) = %SINH
(CONST 1) = $%E
(CONST 2) = POWER*
(CONST 3) = -1
(CONST 4) = MUL*
(CONST 5) = ADD*
(CONST 6) = 2
(CONST 7) = DIV*
(CONST 8) = %COSH
(CONST 9) = (%SIN %COS %TAN %ASIN %ACOS %ATAN %SINH %COSH %TANH %ASINH %ACOSH %ATANH)
(CONST 10) = MEMQ
(CONST 11) = VAR
(CONST 12) = AMONG
(CONST 13) = HYPEREX1
(CONST 14) = HYPEREX0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
69 byte-code instructions:
0     (LOAD 1)
1     (JMPIFATOM L38)
3     (LOAD 1)
4     (CAR)
5     (CAR&PUSH)
6     (JMPIFEQTO 0 L41)                   ; %SINH
9     (LOAD 1)
10    (CAR)
11    (CAR&PUSH)
12    (JMPIFNOTEQTO 8 L69)                ; %COSH
15    (CONST&PUSH 1)                      ; $%E
16    (LOAD 2)
17    (CDR)
18    (CAR&PUSH)
19    (CALL2&PUSH 2)                      ; POWER*
21    (CONST&PUSH 1)                      ; $%E
22    (CONST&PUSH 3)                      ; -1
23    (LOAD 4)
24    (CDR)
25    (CAR&PUSH)
26    (CALL2&PUSH 4)                      ; MUL*
28    (CALL2&PUSH 2)                      ; POWER*
30    (CALL2&PUSH 5)                      ; ADD*
32    (CONST 6)                           ; 2
33    L33
33    (PUSH)
34    (CALL2 7)                           ; DIV*
36    (SKIP&RET 2)
38    L38
38    (LOAD 1)
39    (SKIP&RET 2)
41    L41
41    (CONST&PUSH 1)                      ; $%E
42    (LOAD 2)
43    (CDR)
44    (CAR&PUSH)
45    (CALL2&PUSH 2)                      ; POWER*
47    (CONST&PUSH 3)                      ; -1
48    (CONST&PUSH 1)                      ; $%E
49    (CONST&PUSH 3)                      ; -1
50    (LOAD 5)
51    (CDR)
52    (CAR&PUSH)
53    (CALL2&PUSH 4)                      ; MUL*
55    (CALL2&PUSH 2)                      ; POWER*
57    (CALL2&PUSH 4)                      ; MUL*
59    (CALL2&PUSH 5)                      ; ADD*
61    (CONST 6)                           ; 2
62    (JMP L33)
64    L64
64    (LOAD&PUSH 1)
65    (CALL1 13)                          ; HYPEREX1
67    (SKIP&RET 2)
69    L69
69    (LOAD 1)
70    (CAR)
71    (CAR&PUSH)
72    (CONST&PUSH 9)                      ; (%SIN %COS %TAN %ASIN %ACOS ...)
73    (CALL2&JMPIFNOT 10 L82)             ; MEMQ
76    (GETVALUE&PUSH 11)                  ; VAR
78    (LOAD&PUSH 2)
79    (CALL2&JMPIF 12 L64)                ; AMONG
82    L82
82    (LOAD&CAR&PUSH 1)
84    (CONST&SYMBOL-FUNCTION&PUSH 14)     ; HYPEREX0
86    (LOAD&CDR&PUSH 3)
88    (CALLSR 0 22)                       ; MAPCAR
91    (CONS)
92    (SKIP&RET 2)


Disassembly of function #:|(DEFUN HYPEREX1 (EX) ...)-45|
(CONST 0) = HYPEREX1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HYPEREX1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HYPEREX1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HYPEREX1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HYPEREX1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HYPEREX1
8     (SKIP&RET 1)


Disassembly of function HYPEREX1
(CONST 0) = $LOGARC
(CONST 1) = SSIMPLIFYA
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (T)
1     (BIND 0)                            ; $LOGARC
3     (LOAD&PUSH 4)
4     (CALL1 1)                           ; SSIMPLIFYA
6     (UNBIND1)
7     (SKIP&RET 2)


Disassembly of function #:|(DEFMFUN LIMIT1 (EXP VAR VAL) ...)-46|
(CONST 0) = LIMIT1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT1
8     (SKIP&RET 1)


Disassembly of function LIMIT1
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = LHP?
(CONST 4) = ANS
(CONST 5) = GETLIMVAL
(CONST 6) = INFINITIES
(CONST 7) = MEMQ
(CONST 8) = SIMPLIMSUBST
(CONST 9) = NUMDEN*
(CONST 10) = N
(CONST 11) = AMONG
(CONST 12) = SIMPLIMIT
(CONST 13) = DIV*
(CONST 14) = -1
(CONST 15) = SIMPLIMEXPT
(CONST 16) = MUL*
(CONST 17) = RADICALP
(CONST 18) = POWER*
(CONST 19) = RADLIM
(CONST 20) = /#ALIKE
(CONST 21) = LHOSPITAL
(CONST 22) = LIMIT2
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS N VAR INFINITIES VAL EXP LHP?)
writes special variables : (N ANS)
116 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 3)                   ; LHP?
11    (NIL)
12    (BIND 3)                            ; LHP?
14    (NIL)
15    (BIND 4)                            ; ANS
17    (GETVALUE&PUSH 0)                   ; EXP
19    (CALLS2&JMPIF 4 L103)               ; CONSP
23    (SETVALUE 4)                        ; ANS
25    (JMPIF L195)
28    L28
28    (GETVALUE&PUSH 2)                   ; VAL
30    (GETVALUE&PUSH 6)                   ; INFINITIES
32    (CALL2&JMPIF 7 L46)                 ; MEMQ
35    (GETVALUE&PUSH 2)                   ; VAL
37    (GETVALUE&PUSH 0)                   ; EXP
39    (CALL2 8)                           ; SIMPLIMSUBST
41    (SETVALUE 4)                        ; ANS
43    (JMPIF L115)
46    L46
46    (NIL&PUSH)
47    (GETVALUE&PUSH 0)                   ; EXP
49    (CALL1&PUSH 9)                      ; NUMDEN*
51    (LOAD 1)
52    (BIND 10)                           ; N
54    (LOAD 3)
55    (CAR)
56    (SETVALUE 10)                       ; N
58    (LOAD&CDR&STORE 3)
60    (GETVALUE&PUSH 1)                   ; VAR
62    (LOAD&PUSH 4)
63    (CALL2&JMPIFNOT 11 L120)            ; AMONG
66    (GETVALUE&PUSH 1)                   ; VAR
68    (GETVALUE&PUSH 10)                  ; N
70    (CALL2&JMPIF 11 L153)               ; AMONG
74    (GETVALUE&PUSH 10)                  ; N
76    (LOAD&PUSH 4)
77    (CONST&PUSH 14)                     ; -1
78    (LOAD&PUSH 6)
79    (GETVALUE&PUSH 1)                   ; VAR
81    (GETVALUE&PUSH 2)                   ; VAL
83    (CALL&PUSH 3 12)                    ; SIMPLIMIT
86    (CONST&PUSH 14)                     ; -1
87    (CALL&PUSH 4 15)                    ; SIMPLIMEXPT
90    (CALL2 16)                          ; MUL*
92    L92
92    (PUSH)
93    (GETVALUE&PUSH 1)                   ; VAR
95    (GETVALUE&PUSH 2)                   ; VAL
97    (CALL 3 12)                         ; SIMPLIMIT
100   (JMP L192)
103   L103
103   (GETVALUE&PUSH 0)                   ; EXP
105   (CALL1 5)                           ; GETLIMVAL
107   (SETVALUE 4)                        ; ANS
109   (JMPIFNOT L28)
112   (JMP L195)
115   L115
115   (GETVALUE 4)                        ; ANS
117   (JMP L195)
120   L120
120   (GETVALUE&PUSH 10)                  ; N
122   (GETVALUE&PUSH 1)                   ; VAR
124   (GETVALUE&PUSH 2)                   ; VAL
126   (CALL&PUSH 3 12)                    ; SIMPLIMIT
129   (LOAD&PUSH 4)
130   (CALL2 13)                          ; DIV*
132   (JMP L92)
134   L134
134   (GETVALUE&PUSH 10)                  ; N
136   (LOAD&PUSH 4)
137   (CONST&PUSH 14)                     ; -1
138   (CALL2&PUSH 18)                     ; POWER*
140   (CALL2&PUSH 16)                     ; MUL*
142   (GETVALUE&PUSH 10)                  ; N
144   (LOAD&PUSH 5)
145   (CALL 3 19)                         ; RADLIM
148   (JMP L192)
150   L150
150   (CONST&PUSH 21)                     ; LHOSPITAL
151   (NIL)
152   (THROW)
153   L153
153   (GETVALUE&PUSH 10)                  ; N
155   (GETVALUE&PUSH 1)                   ; VAR
157   (CALL2&JMPIFNOT 17 L166)            ; RADICALP
160   (LOAD&PUSH 3)
161   (GETVALUE&PUSH 1)                   ; VAR
163   (CALL2&JMPIF 17 L134)               ; RADICALP
166   L166
166   (LOAD&JMPIFNOT 11 L182)
169   (GETVALUE&PUSH 10)                  ; N
171   (LOAD&CAR&PUSH 12)
173   (CALL2&JMPIFNOT 20 L182)            ; /#ALIKE
176   (LOAD&PUSH 3)
177   (LOAD&CDR&PUSH 12)
179   (CALL2&JMPIF 20 L150)               ; /#ALIKE
182   L182
182   (GETVALUE&PUSH 10)                  ; N
184   (LOAD&PUSH 4)
185   (GETVALUE&PUSH 1)                   ; VAR
187   (GETVALUE&PUSH 2)                   ; VAL
189   (CALL 4 22)                         ; LIMIT2
192   L192
192   (UNBIND1)
193   (SKIP 2)
195   L195
195   (UNBIND 2)
197   (SKIP 1)
199   (UNBIND 3)
201   (SKIP&RET 4)


Disassembly of function #:|(DEFUN /#ALIKE (E F) ...)-47|
(CONST 0) = /#ALIKE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE /#ALIKE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; /#ALIKE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; /#ALIKE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE /#ALIKE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; /#ALIKE
8     (SKIP&RET 1)


Disassembly of function /#ALIKE
(CONST 0) = E
(CONST 1) = F
(CONST 2) = ALIKE1
(CONST 3) = DIV*
(CONST 4) = VAR
(CONST 5) = SDIFF
(CONST 6) = 0
(CONST 7) = $RATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR F E)
30 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; F
6     (GETVALUE&PUSH 0)                   ; E
8     (GETVALUE&PUSH 1)                   ; F
10    (CALL2&JMPIF 2 L38)                 ; ALIKE1
13    (GETVALUE&PUSH 0)                   ; E
15    (GETVALUE&PUSH 1)                   ; F
17    (CALL2&PUSH 3)                      ; DIV*
19    (GETVALUE&PUSH 4)                   ; VAR
21    (CALL2&PUSH 5)                      ; SDIFF
23    (LOAD&PUSH 0)
24    (JMPIFEQTO 6 L33)                   ; 0
27    (LOAD&PUSH 0)
28    (CALL1&PUSH 7)                      ; $RATSIMP
30    (JMPIFNOTEQTO 6 L41)                ; 0
33    L33
33    (T)
34    (SKIP 1)
36    (JMP L44)
38    L38
38    (T)
39    (JMP L44)
41    L41
41    (NIL)
42    (SKIP 1)
44    L44
44    (UNBIND 2)
46    (SKIP&RET 3)


Disassembly of function #:|(DEFUN LIMIT2 (N DN VAR ...) ...)-48|
(CONST 0) = LIMIT2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMIT2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMIT2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMIT2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMIT2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMIT2
8     (SKIP&RET 1)


Disassembly of function LIMIT2
(CONST 0) = N
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = HYPEREX
(CONST 4) = INFINITIES
(CONST 5) = MEMQ
(CONST 6) = LIMIT
(CONST 7) = SIMPLIMSUBST
(CONST 8) = SRATSIMP
(CONST 9) = (MFACTORIAL)
(CONST 10) = INVOLVE
(CONST 11) = (MFACTORIAL)
(CONST 12) = LIMFACT2
(CONST 13) = ANS
(CONST 14) = ZEROP2
(CONST 15) = GCPOWER
(CONST 16) = 1
(CONST 17) = COLEXPT
(CONST 18) = INFINITESIMALS
(CONST 19) = %LOG
(CONST 20) = FREE
(CONST 21) = DIV*
(CONST 22) = LIMINV
(CONST 23) = TRY-LHOSPITAL-QUIT
(CONST 24) = ($IND $UND)
(CONST 25) = 0
(CONST 26) = RIDOFAB
(CONST 27) = -1
(CONST 28) = SIMPLIMEXPT
(CONST 29) = SIMPLIMTIMES
(CONST 30) = $UND
(CONST 31) = REAL-INFINITIES
(CONST 32) = $IND
(CONST 33) = ($INF $UND $MINF)
(CONST 34) = EXPFACTORP
(CONST 35) = EXPFACTOR
(CONST 36) = $INF
(CONST 37) = (MFACTORIAL %GAMMA)
(CONST 38) = (MFACTORIAL %GAMMA)
(CONST 39) = LIMFACT
(CONST 40) = $MINF
(CONST 41) = POWER*
(CONST 42) = $EXPAND
(CONST 43) = MPLUSP
(CONST 44) = MAXI
(CONST 45) = ADDN
(CONST 46) = ALIKE1
(CONST 47) = THINK
(CONST 48) = SHEUR0
(CONST 49) = ($INF $ZEROA)
(CONST 50) = ($INF $ZEROA)
(CONST 51) = SIMPLIMIT
(CONST 52) = EXPP
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITESIMALS REAL-INFINITIES ANS VAR INFINITIES VAL N)
writes special variable : (N)
464 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (PUSH-NIL 5)
11    (GETVALUE&PUSH 0)                   ; N
13    (CALL1 3)                           ; HYPEREX
15    (SETVALUE 0)                        ; N
17    (LOAD&PUSH 17)
18    (CALL1 3)                           ; HYPEREX
20    (STORE 17)
22    (GETVALUE&PUSH 2)                   ; VAL
24    (GETVALUE&PUSH 4)                   ; INFINITIES
26    (CALL2&JMPIF 5 L216)                ; MEMQ
30    (GETVALUE&PUSH 2)                   ; VAL
32    (GETVALUE&PUSH 0)                   ; N
34    (CALL2 7)                           ; SIMPLIMSUBST
36    (STORE 4)
37    (JMPIF L50)
39    (GETVALUE&PUSH 0)                   ; N
41    (GETVALUE&PUSH 1)                   ; VAR
43    (GETVALUE&PUSH 2)                   ; VAL
45    (NIL&PUSH)
46    (CALL 4 6)                          ; LIMIT
49    (STORE 4)
50    L50
50    (GETVALUE&PUSH 2)                   ; VAL
52    (LOAD&PUSH 18)
53    (CALL2 7)                           ; SIMPLIMSUBST
55    (STORE 3)
56    (JMPIFNOT L243)
59    (LOAD&JMPIFNOT 4 L257)
63    L63
63    (LOAD&JMPIFNOT 3 L257)
67    (LOAD&PUSH 4)
68    (CALL1 8)                           ; SRATSIMP
70    (STORE 4)
71    (LOAD&PUSH 3)
72    (CALL1 8)                           ; SRATSIMP
74    (STORE 3)
75    (GETVALUE&PUSH 0)                   ; N
77    (CONST&PUSH 9)                      ; (MFACTORIAL)
78    (CALL2&JMPIF 10 L86)                ; INVOLVE
81    (LOAD&PUSH 17)
82    (CONST&PUSH 11)                     ; (MFACTORIAL)
83    (CALL2&JMPIFNOT 10 L104)            ; INVOLVE
86    L86
86    (GETVALUE&PUSH 0)                   ; N
88    (LOAD&PUSH 18)
89    (GETVALUE&PUSH 1)                   ; VAR
91    (GETVALUE&PUSH 2)                   ; VAL
93    (CALL 4 12)                         ; LIMFACT2
96    (BIND 13)                           ; ANS
98    (GETVALUE 13)                       ; ANS
100   (JMPIF L263)
103   (UNBIND1)
104   L104
104   (LOAD&PUSH 4)
105   (CALL1&JMPIFNOT 14 L113)            ; ZEROP2
108   (LOAD&PUSH 3)
109   (CALL1&JMPIF 14 L281)               ; ZEROP2
113   L113
113   (LOAD&PUSH 4)
114   (CALL1&JMPIFNOT 14 L123)            ; ZEROP2
117   (LOAD&PUSH 3)
118   (CONST&PUSH 24)                     ; ($IND $UND)
119   (CALL2&JMPIFNOT 5 L326)             ; MEMQ
123   L123
123   (LOAD&PUSH 3)
124   (CALL1&JMPIF 14 L333)               ; ZEROP2
128   L128
128   (LOAD&PUSH 4)
129   (CALL1 26)                          ; RIDOFAB
131   (STORE 4)
132   (LOAD&PUSH 3)
133   (CALL1 26)                          ; RIDOFAB
135   (STORE 3)
136   (PUSH)
137   (JMPIFEQTO 30 L348)                 ; $UND
141   (LOAD&PUSH 4)
142   (JMPIFNOTEQTO 30 L152)              ; $UND
145   (LOAD&PUSH 3)
146   (GETVALUE&PUSH 31)                  ; REAL-INFINITIES
148   (CALL2&JMPIFNOT 5 L348)             ; MEMQ
152   L152
152   (LOAD&PUSH 3)
153   (JMPIFEQTO 32 L355)                 ; $IND
157   (LOAD&PUSH 4)
158   (JMPIFEQTO 32 L376)                 ; $IND
162   (LOAD&PUSH 3)
163   (GETVALUE&PUSH 31)                  ; REAL-INFINITIES
165   (CALL2&JMPIFNOT 5 L558)             ; MEMQ
169   (LOAD&PUSH 4)
170   (CONST&PUSH 33)                     ; ($INF $UND $MINF)
172   (CALL2&JMPIFNOT 5 L558)             ; MEMQ
176   (GETVALUE&PUSH 0)                   ; N
178   (LOAD&PUSH 18)
179   (CALL2&JMPIF 34 L393)               ; EXPFACTORP
183   (LOAD 17)
185   (JMPIFATOM L439)
188   (GETVALUE 0)                        ; N
190   (JMPIFATOM L439)
193   (GETVALUE&PUSH 0)                   ; N
195   (LOAD&PUSH 18)
196   (CALL2 15)                          ; GCPOWER
198   (STORE 1)
199   (PUSH)
200   (JMPIFEQTO 16 L421)                 ; 1
204   L204
204   (GETVALUE&PUSH 0)                   ; N
206   (LOAD&PUSH 18)
207   (LOAD&PUSH 3)
208   (CALL 3 17)                         ; COLEXPT
211   (SKIP 5)
213   (JMP L783)
216   L216
216   (LOAD&PUSH 17)
217   (GETVALUE&PUSH 1)                   ; VAR
219   (GETVALUE&PUSH 2)                   ; VAL
221   (NIL&PUSH)
222   (CALL 4 6)                          ; LIMIT
225   (STORE 3)
226   (GETVALUE&PUSH 0)                   ; N
228   (GETVALUE&PUSH 1)                   ; VAR
230   (GETVALUE&PUSH 2)                   ; VAL
232   (NIL&PUSH)
233   (CALL 4 6)                          ; LIMIT
236   (STORE 4)
237   (LOAD&JMPIFNOT 4 L257)
240   (JMP L63)
243   L243
243   (LOAD&PUSH 17)
244   (GETVALUE&PUSH 1)                   ; VAR
246   (GETVALUE&PUSH 2)                   ; VAL
248   (NIL&PUSH)
249   (CALL 4 6)                          ; LIMIT
252   (STORE 3)
253   (LOAD&JMPIF 4 L63)
257   L257
257   (NIL)
258   (SKIP 5)
260   (JMP L783)
263   L263
263   (UNBIND1)
264   (SKIP 5)
266   (JMP L783)
269   L269
269   (GETVALUE&PUSH 0)                   ; N
271   (LOAD&PUSH 18)
272   (CALL2&PUSH 21)                     ; DIV*
274   (CALL1 22)                          ; LIMINV
276   (SKIP 5)
278   (JMP L783)
281   L281
281   (GETVALUE&PUSH 0)                   ; N
283   (LOAD&PUSH 18)
284   (CALL2 15)                          ; GCPOWER
286   (STORE 1)
287   (PUSH)
288   (JMPIFNOTEQTO 16 L204)              ; 1
292   (GETVALUE&PUSH 2)                   ; VAL
294   (GETVALUE&PUSH 18)                  ; INFINITESIMALS
296   (CALL2&JMPIFNOT 5 L310)             ; MEMQ
299   (GETVALUE&PUSH 0)                   ; N
301   (CONST&PUSH 19)                     ; %LOG
302   (CALL2&JMPIF 20 L310)               ; FREE
305   (LOAD&PUSH 17)
306   (CONST&PUSH 19)                     ; %LOG
307   (CALL2&JMPIFNOT 20 L269)            ; FREE
310   L310
310   (GETVALUE&PUSH 0)                   ; N
312   (LOAD&PUSH 18)
313   (NIL&PUSH)
314   (CALL 3 23)                         ; TRY-LHOSPITAL-QUIT
317   (STORE 4)
318   (JMPIFNOT L128)
321   (SKIP 5)
323   (JMP L783)
326   L326
326   (CONST 25)                          ; 0
328   (SKIP 5)
330   (JMP L783)
333   L333
333   (LOAD&PUSH 4)
334   (CALL1 26)                          ; RIDOFAB
336   (STORE 4)
337   (PUSH)
338   (LOAD&PUSH 18)
339   (CONST&PUSH 27)                     ; -1
340   (LOAD&PUSH 6)
341   (CONST&PUSH 27)                     ; -1
342   (CALL 4 28)                         ; SIMPLIMEXPT
345   (JMP L632)
348   L348
348   (CONST 30)                          ; $UND
350   (SKIP 5)
352   (JMP L783)
355   L355
355   (CONST 30)                          ; $UND
357   (SKIP 5)
359   (JMP L783)
362   L362
362   (CONST 25)                          ; 0
364   (SKIP 5)
366   (JMP L783)
369   L369
369   (CONST 30)                          ; $UND
371   (SKIP 5)
373   (JMP L783)
376   L376
376   (LOAD&PUSH 3)
377   (GETVALUE&PUSH 4)                   ; INFINITIES
379   (CALL2&JMPIF 5 L362)                ; MEMQ
382   (LOAD&PUSH 3)
383   (JMPIFEQTO 25 L369)                 ; 0
386   (CONST 32)                          ; $IND
388   (SKIP 5)
390   (JMP L783)
393   L393
393   (GETVALUE&PUSH 0)                   ; N
395   (LOAD&PUSH 18)
396   (GETVALUE&PUSH 1)                   ; VAR
398   (CALL 3 35)                         ; EXPFACTOR
401   (SKIP 5)
403   (JMP L783)
406   L406
406   (GETVALUE&PUSH 0)                   ; N
408   (LOAD&PUSH 18)
409   (CALL2 39)                          ; LIMFACT
411   (SKIP 5)
413   (JMP L783)
416   L416
416   (CONST 16)                          ; 1
417   (STORE 2)
418   (JMP L584)
421   L421
421   (GETVALUE&PUSH 2)                   ; VAL
423   (JMPIFNOTEQTO 36 L439)              ; $INF
426   (LOAD&PUSH 17)
427   (CONST&PUSH 37)                     ; (MFACTORIAL %GAMMA)
429   (CALL2&JMPIF 10 L406)               ; INVOLVE
432   (GETVALUE&PUSH 0)                   ; N
434   (CONST&PUSH 38)                     ; (MFACTORIAL %GAMMA)
436   (CALL2&JMPIF 10 L406)               ; INVOLVE
439   L439
439   (LOAD&PUSH 4)
440   (LOAD 4)
441   (JMPIFEQ L416)
443   (CONST 27)                          ; -1
445   (STORE 2)
446   (JMP L584)
449   L449
449   (CONST 27)                          ; -1
451   (STORE 2)
452   (JMP L584)
455   L455
455   (LOAD&PUSH 4)
456   (LOAD&PUSH 4)
457   (CONST&PUSH 27)                     ; -1
458   (CALL2 41)                          ; POWER*
460   (JMP L632)
463   L463
463   (LOAD&PUSH 1)
464   (NIL&PUSH)
465   (CALL2 45)                          ; ADDN
467   (JMP L493)
469   L469
469   (LOAD&PUSH 0)
470   (LOAD&PUSH 20)
471   (CALL2&PUSH 21)                     ; DIV*
473   (GETVALUE&PUSH 1)                   ; VAR
475   (CONST&PUSH 36)                     ; $INF
477   (CONST 47)                          ; THINK
479   (JMP L542)
481   L481
481   (GETVALUE 0)                        ; N
483   (CDR&PUSH)
484   (CALL1&PUSH 44)                     ; MAXI
486   (NIL&PUSH)
487   (LOAD 1)
488   (CDR)
489   (JMPIF L463)
491   (LOAD 1)
492   (CAR)
493   L493
493   (STORE 0)
494   (PUSH)
495   (GETVALUE&PUSH 0)                   ; N
497   (CALL2&JMPIFNOT 46 L469)            ; ALIKE1
500   (LOAD&CAR&STORE 1 6)
503   (SKIP 2)
505   (JMP L604)
508   L508
508   (LOAD&PUSH 1)
509   (NIL&PUSH)
510   (CALL2 45)                          ; ADDN
512   (JMP L525)
514   L514
514   (LOAD&CDR&PUSH 17)
516   (CALL1&PUSH 44)                     ; MAXI
518   (NIL&PUSH)
519   (LOAD 1)
520   (CDR)
521   (JMPIF L508)
523   (LOAD 1)
524   (CAR)
525   L525
525   (STORE 0)
526   (PUSH)
527   (LOAD&PUSH 20)
528   (CALL2&JMPIF 46 L551)               ; ALIKE1
531   (GETVALUE&PUSH 0)                   ; N
533   (LOAD&PUSH 1)
534   (CALL2&PUSH 21)                     ; DIV*
536   (GETVALUE&PUSH 1)                   ; VAR
538   (CONST&PUSH 36)                     ; $INF
540   (CONST 47)                          ; THINK
542   L542
542   (PUSH)
543   (CALL 4 6)                          ; LIMIT
546   (SKIP 7)
548   (JMP L783)
551   L551
551   (LOAD&CAR&STORE 1 5)
554   (SKIP 2)
556   (JMP L612)
558   L558
558   (LOAD&PUSH 3)
559   (GETVALUE&PUSH 4)                   ; INFINITIES
561   (CALL2&JMPIFNOT 5 L455)             ; MEMQ
565   (LOAD&PUSH 4)
566   (GETVALUE&PUSH 4)                   ; INFINITIES
568   (CALL2&JMPIFNOT 5 L455)             ; MEMQ
572   (LOAD&PUSH 3)
573   (JMPIFEQTO 40 L449)                 ; $MINF
577   (LOAD&PUSH 4)
578   (JMPIFEQTO 40 L449)                 ; $MINF
582   (CONST 16)                          ; 1
583   (STORE 2)
584   L584
584   (GETVALUE&PUSH 0)                   ; N
586   (CALL1 42)                          ; $EXPAND
588   (SETVALUE 0)                        ; N
590   (LOAD&PUSH 17)
591   (CALL1 42)                          ; $EXPAND
593   (STORE 17)
595   (GETVALUE&PUSH 0)                   ; N
597   (CALL1&JMPIF 43 L481)               ; MPLUSP
601   (GETVALUE 0)                        ; N
603   (STORE 4)
604   L604
604   (LOAD&PUSH 17)
605   (CALL1&JMPIF 43 L514)               ; MPLUSP
609   (LOAD 17)
611   (STORE 3)
612   L612
612   (LOAD&PUSH 4)
613   (LOAD&PUSH 4)
614   (CALL2 48)                          ; SHEUR0
616   (STORE 0)
617   (PUSH)
618   (CONST&PUSH 49)                     ; ($INF $ZEROA)
620   (CALL2&JMPIF 5 L630)                ; MEMQ
623   (LOAD&PUSH 0)
624   (GETVALUE&PUSH 1)                   ; VAR
626   (CALL2&JMPIFNOT 20 L696)            ; FREE
630   L630
630   (LOAD&PUSH 2)
631   (LOAD 1)
632   L632
632   (PUSH)
633   (LIST&PUSH 2)
635   (CALL1 29)                          ; SIMPLIMTIMES
637   (SKIP 5)
639   (JMP L783)
642   L642
642   (LOAD&PUSH 4)
643   (LOAD&PUSH 4)
644   (GETVALUE&PUSH 1)                   ; VAR
646   (CALL 3 35)                         ; EXPFACTOR
649   (JMP L713)
651   L651
651   (GETVALUE&PUSH 0)                   ; N
653   (LOAD&PUSH 18)
654   (GETVALUE&PUSH 1)                   ; VAR
656   (CALL 3 35)                         ; EXPFACTOR
659   (STORE 4)
660   (JMPIFNOT L729)
663   (JMP L780)
666   L666
666   (GETVALUE&PUSH 0)                   ; N
668   (LOAD&PUSH 1)
669   (CALL2&PUSH 21)                     ; DIV*
671   (CALL1&PUSH 42)                     ; $EXPAND
673   (LOAD&PUSH 18)
674   (LOAD&PUSH 2)
675   (CALL2&PUSH 21)                     ; DIV*
677   (CALL1&PUSH 42)                     ; $EXPAND
679   (CALL2&PUSH 21)                     ; DIV*
681   (GETVALUE&PUSH 1)                   ; VAR
683   (GETVALUE&PUSH 2)                   ; VAL
685   (CALL 3 51)                         ; SIMPLIMIT
688   (SKIP 5)
690   (JMP L783)
693   L693
693   (CONST&PUSH 6)                      ; LIMIT
694   (T)
695   (THROW)
696   L696
696   (LOAD&PUSH 0)
697   (LOAD&PUSH 18)
698   (CALL2&JMPIFNOT 46 L706)            ; ALIKE1
701   (GETVALUE&PUSH 0)                   ; N
703   (CALL1&JMPIFNOT 43 L749)            ; MPLUSP
706   L706
706   (LOAD&PUSH 4)
707   (LOAD&PUSH 4)
708   (CALL2&JMPIF 34 L642)               ; EXPFACTORP
712   (NIL)
713   L713
713   (STORE 4)
714   (PUSH)
715   (CONST&PUSH 50)                     ; ($INF $ZEROA)
717   (CALL2&JMPIF 5 L780)                ; MEMQ
720   (GETVALUE&PUSH 0)                   ; N
722   (LOAD&PUSH 18)
723   (CALL2&JMPIF 34 L651)               ; EXPFACTORP
727   (NIL&STORE 4)
729   L729
729   (LOAD&PUSH 0)
730   (LOAD&PUSH 18)
731   (CALL2&JMPIFNOT 46 L739)            ; ALIKE1
734   (GETVALUE&PUSH 0)                   ; N
736   (CALL1&JMPIFNOT 43 L749)            ; MPLUSP
739   L739
739   (LOAD&PUSH 0)
740   (GETVALUE&PUSH 0)                   ; N
742   (LOAD&PUSH 19)
743   (CALL2&PUSH 21)                     ; DIV*
745   (CALL2&JMPIFNOT 46 L666)            ; ALIKE1
749   L749
749   (GETVALUE&PUSH 2)                   ; VAL
751   (JMPIFNOTEQTO 36 L764)              ; $INF
754   (GETVALUE&PUSH 0)                   ; N
756   (CALL1&JMPIFNOT 52 L764)            ; EXPP
759   (LOAD&PUSH 17)
760   (CALL1&JMPIF 52 L693)               ; EXPP
764   L764
764   (GETVALUE&PUSH 0)                   ; N
766   (LOAD&PUSH 18)
767   (NIL&PUSH)
768   (CALL 3 23)                         ; TRY-LHOSPITAL-QUIT
771   (STORE 4)
772   (JMPIFNOT L693)
775   (PUSH)
776   (JMPIFEQTO 30 L693)                 ; $UND
780   L780
780   (LOAD 4)
781   (SKIP 5)
783   L783
783   (UNBIND 3)
785   (SKIP&RET 5)


Disassembly of function #:|(DEFUN EXPFACTORP (N DN) ...)-49|
(CONST 0) = EXPFACTORP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXPFACTORP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXPFACTORP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXPFACTORP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXPFACTORP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXPFACTORP
8     (SKIP&RET 1)


Disassembly of function EXPFACTORP
(CONST 0) = N
(CONST 1) = MTIMESP
(CONST 2) = POLYP
(CONST 3) = MEXPTP
(CONST 4) = VAR
(CONST 5) = RATP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR N)
77 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (GETVALUE&PUSH 0)                   ; N
5     (CALL1&JMPIF 1 L98)                 ; MTIMESP
9     (GETVALUE&PUSH 0)                   ; N
11    (NIL)
12    (CONS)
13    L13
13    (PUSH)
14    (LOAD&PUSH 5)
15    (CALL1&JMPIF 1 L104)                ; MTIMESP
19    (LOAD&PUSH 5)
20    (NIL)
21    (CONS)
22    L22
22    (PUSH)
23    (CALLSR&PUSH 2 34)                  ; APPEND
26    (T&PUSH)
27    (PUSH-NIL 2)
29    (LOAD&JMPIFNOT 3 L90)
32    L32
32    (LOAD&JMPIFNOT 2 L90)
35    (LOAD&CAR&STORE 3 0)
38    (PUSH)
39    (CALL1&JMPIF 2 L60)                 ; POLYP
42    (LOAD&PUSH 0)
43    (CALL1&JMPIFNOT 3 L60)              ; MEXPTP
46    (LOAD 0)
47    (CDR)
48    (CAR&PUSH)
49    (CALL1&JMPIFNOT 2 L60)              ; POLYP
52    (LOAD 0)
53    (CDR)
54    (CDR)
55    (CAR&PUSH)
56    (GETVALUE&PUSH 4)                   ; VAR
58    (CALL2 5)                           ; RATP
60    L60
60    (STORE 2)
61    (LOAD&JMPIF 1 L84)
64    (LOAD&PUSH 0)
65    (CALL1&JMPIFNOT 3 L84)              ; MEXPTP
68    (LOAD 0)
69    (CDR)
70    (CDR)
71    (CAR&PUSH)
72    (GETVALUE&PUSH 4)                   ; VAR
74    (CALL2&JMPIFNOT 5 L84)              ; RATP
77    (LOAD 0)
78    (CDR)
79    (CDR)
80    (CAR&PUSH)
81    (CALL1 2)                           ; POLYP
83    (NOT)
84    L84
84    (STORE 1)
85    (LOAD&CDR&STORE 3)
87    (LOAD&JMPIF 3 L32)
90    L90
90    (LOAD 2)
91    (JMPIFNOT1 L109)
93    (LOAD 1)
94    (SKIP 4)
96    (JMP L111)
98    L98
98    (GETVALUE 0)                        ; N
100   (CDR)
101   (JMP L13)
104   L104
104   (LOAD 5)
105   (CDR)
106   (JMP L22)
109   L109
109   (SKIP 4)
111   L111
111   (UNBIND1)
112   (SKIP&RET 3)


Disassembly of function #:|(DEFUN EXPFACTOR (N DN VAR) ...)-50|
(CONST 0) = EXPFACTOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXPFACTOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXPFACTOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXPFACTOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXPFACTOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXPFACTOR
8     (SKIP&RET 1)


Disassembly of function EXPFACTOR
(CONST 0) = N
(CONST 1) = VAR
(CONST 2) = EXPPOLY
(CONST 3) = 1
(CONST 4) = DEGREE
(CONST 5) = -1
(CONST 6) = GET-NEWEXP&FACTORS
(CONST 7) = DIV*
(CONST 8) = MUL*
(CONST 9) = 0
(CONST 10) = POWER*
(CONST 11) = $INF
(CONST 12) = THINK
(CONST 13) = LIMIT
(CONST 14) = $UND
(CONST 15) = ($INF $MINF 0)
(CONST 16) = ZL-MEMBER
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DEGREE VAR N)
writes special variables : (DEGREE N)
109 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (NIL&PUSH)
7     (GETVALUE&PUSH 0)                   ; N
9     (CALL1&PUSH 2)                      ; EXPPOLY
11    (LOAD 0)
12    (CAR)
13    (SETVALUE 0)                        ; N
15    (LOAD 0)
16    (CDR)
17    (STORE 1)
18    (SKIP 1)
20    (GETVALUE 0)                        ; N
22    (JMPIFNOT L42)
24    (LOAD&PUSH 9)
25    (CALL1&PUSH 2)                      ; EXPPOLY
27    (LOAD&CAR&STORE 0 10)
30    (LOAD&PUSH 1)
31    (LOAD&CDR&PUSH 1)
33    (CALLSR&STORE 1 51 1)               ; MAX
37    (SKIP 1)
39    (LOAD&JMPIF 9 L48)
42    L42
42    (NIL)
43    (SKIP 1)
45    (JMP L174)
48    L48
48    (CONST&PUSH 3)                      ; 1
49    (LOAD 1)
50    (BIND 4)                            ; DEGREE
52    (GETVALUE&PUSH 0)                   ; N
54    (LOAD&PUSH 14)
55    (PUSH-NIL 2)
57    (JMP L147)
60    L60
60    (GETVALUE 1)                        ; VAR
62    (JMP L119)
64    L64
64    (NIL)
65    (JMP L169)
68    L68
68    (LOAD 7)
69    (JMP L169)
72    L72
72    (LOAD&PUSH 3)
73    (GETVALUE&PUSH 4)                   ; DEGREE
75    (GETVALUE&PUSH 1)                   ; VAR
77    (CALL&PUSH 3 6)                     ; GET-NEWEXP&FACTORS
80    (LOAD&CAR&STORE 0 4)
83    (LOAD 0)
84    (CDR)
85    (STORE 2)
86    (SKIP 1)
88    (LOAD&PUSH 2)
89    (GETVALUE&PUSH 4)                   ; DEGREE
91    (GETVALUE&PUSH 1)                   ; VAR
93    (CALL&PUSH 3 6)                     ; GET-NEWEXP&FACTORS
96    (LOAD&CAR&STORE 0 3)
99    (LOAD 0)
100   (CDR)
101   (STORE 1)
102   (SKIP 1)
104   (LOAD&PUSH 7)
105   (LOAD&PUSH 2)
106   (LOAD&PUSH 2)
107   (CALL2&PUSH 7)                      ; DIV*
109   (CALL2&PUSH 8)                      ; MUL*
111   (GETVALUE&PUSH 4)                   ; DEGREE
113   (CONST&PUSH 9)                      ; 0
114   (CALLSR&JMPIF 1 48 L60)             ; >
118   (CONST 3)                           ; 1
119   L119
119   (PUSH)
120   (CALL2&PUSH 10)                     ; POWER*
122   (GETVALUE&PUSH 1)                   ; VAR
124   (CONST&PUSH 11)                     ; $INF
125   (CONST&PUSH 12)                     ; THINK
126   (CALL 4 13)                         ; LIMIT
129   (STORE 7)
130   (PUSH)
131   (JMPIFEQTO 14 L64)                  ; $UND
135   (LOAD&PUSH 7)
136   (CONST&PUSH 15)                     ; ($INF $MINF 0)
137   (CALL2&JMPIF 16 L68)                ; ZL-MEMBER
141   (GETVALUE&PUSH 4)                   ; DEGREE
143   (CALLS2 151)                        ; 1-
145   (SETVALUE 4)                        ; DEGREE
147   L147
147   (GETVALUE&PUSH 4)                   ; DEGREE
149   (CONST&PUSH 5)                      ; -1
150   (CALLSR&JMPIFNOT 1 45 L72)          ; =
155   (LOAD&PUSH 7)
156   (LOAD&PUSH 4)
157   (LOAD&PUSH 4)
158   (CALL2&PUSH 7)                      ; DIV*
160   (GETVALUE&PUSH 1)                   ; VAR
162   (CONST&PUSH 11)                     ; $INF
163   (CONST&PUSH 12)                     ; THINK
164   (CALL&PUSH 4 13)                    ; LIMIT
167   (CALL2 8)                           ; MUL*
169   L169
169   (SKIP 4)
171   (UNBIND1)
172   (SKIP 2)
174   L174
174   (UNBIND 2)
176   (SKIP&RET 4)


Disassembly of function #:|(DEFUN EXPPOLY (EXP) ...)-51|
(CONST 0) = EXPPOLY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXPPOLY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXPPOLY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXPPOLY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXPPOLY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXPPOLY
8     (SKIP&RET 1)


Disassembly of function EXPPOLY
(CONST 0) = EXP
(CONST 1) = 0
(CONST 2) = 1
(CONST 3) = MTIMESP
(CONST 4) = MEXPTP
(CONST 5) = VAR
(CONST 6) = RATP
(CONST 7) = RATDEGREE
(CONST 8) = UNRAT
(CONST 9) = POWER*
(CONST 10) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
67 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (CONST&PUSH 1)                      ; 0
5     (CONST&PUSH 2)                      ; 1
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1&JMPIF 3 L84)                 ; MTIMESP
12    (GETVALUE&PUSH 0)                   ; EXP
14    (NIL)
15    (CONS)
16    L16
16    (BIND 0)                            ; EXP
18    (GETVALUE 0)                        ; EXP
20    (JMPIFNOT L75)
22    L22
22    (GETVALUE 0)                        ; EXP
24    (CAR)
25    (STORE 5)
26    (PUSH)
27    (CALL1&JMPIFNOT 4 L90)              ; MEXPTP
30    (LOAD 5)
31    (CDR)
32    (CDR)
33    (CAR&PUSH)
34    (GETVALUE&PUSH 5)                   ; VAR
36    (CALL2&JMPIFNOT 6 L90)              ; RATP
39    (LOAD&PUSH 4)
40    (LOAD 6)
41    (CDR)
42    (CDR)
43    (CAR&PUSH)
44    (CALL1&PUSH 7)                      ; RATDEGREE
46    (CALLSR&STORE 1 51 4)               ; MAX
50    (LOAD 5)
51    (CDR)
52    (CAR&PUSH)
53    (LOAD 6)
54    (CDR)
55    (CDR)
56    (CAR&PUSH)
57    (CALL1&PUSH 8)                      ; UNRAT
59    (CALL2 9)                           ; POWER*
61    L61
61    (PUSH)
62    (LOAD&PUSH 4)
63    (CALL2 10)                          ; MUL*
65    (STORE 3)
66    (GETVALUE 0)                        ; EXP
68    (CDR)
69    (SETVALUE 0)                        ; EXP
71    (GETVALUE 0)                        ; EXP
73    (JMPIF L22)
75    L75
75    (LOAD&PUSH 3)
76    (LOAD 5)
77    (CONS)
78    (UNBIND1)
79    (SKIP 3)
81    (UNBIND1)
82    (SKIP&RET 2)
84    L84
84    (GETVALUE 0)                        ; EXP
86    (CDR)
87    (JMP L16)
90    L90
90    (LOAD 5)
91    (JMP L61)


Disassembly of function #:|(DEFUN UNRAT (EXP) ...)-52|
(CONST 0) = UNRAT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE UNRAT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; UNRAT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; UNRAT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE UNRAT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; UNRAT
8     (SKIP&RET 1)


Disassembly of function UNRAT
(CONST 0) = EXP
(CONST 1) = NUMDEN*
(CONST 2) = $DIVIDE
(CONST 3) = DIV*
(CONST 4) = ADD*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
20 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&PUSH 1)                      ; NUMDEN*
7     (LOAD&CAR&PUSH 0)
9     (LOAD&CDR&PUSH 1)
11    (CALL2&PUSH 2)                      ; $DIVIDE
13    (LOAD 0)
14    (CDR)
15    (CAR&PUSH)
16    (LOAD 1)
17    (CDR)
18    (CDR)
19    (CAR&PUSH)
20    (LOAD&CDR&PUSH 3)
22    (CALL2&PUSH 3)                      ; DIV*
24    (CALL2 4)                           ; ADD*
26    (SKIP 2)
28    (UNBIND1)
29    (SKIP&RET 2)


Disassembly of function #:|(DEFUN GET-NEWEXP&FACTORS (EXP DEGREE VAR) ...)-53|
(CONST 0) = GET-NEWEXP&FACTORS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GET-NEWEXP&FACTORS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GET-NEWEXP&FACTORS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GET-NEWEXP&FACTORS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GET-NEWEXP&FACTORS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GET-NEWEXP&FACTORS
8     (SKIP&RET 1)


Disassembly of function GET-NEWEXP&FACTORS
(CONST 0) = EXP
(CONST 1) = DEGREE
(CONST 2) = VAR
(CONST 3) = MTIMESP
(CONST 4) = 1
(CONST 5) = FACTORS
(CONST 6) = MEXPTP
(CONST 7) = 0
(CONST 8) = MUL*
(CONST 9) = -1
(CONST 10) = RATDEGREE
(CONST 11) = LEADING-COEF
(CONST 12) = POWER*
(CONST 13) = SUB*
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR FACTORS DEGREE EXP)
writes special variable : (FACTORS)
98 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; DEGREE
6     (LOAD 7)
7     (BIND 2)                            ; VAR
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CALL1&JMPIF 3 L77)                 ; MTIMESP
14    (GETVALUE&PUSH 0)                   ; EXP
16    (NIL)
17    (CONS)
18    L18
18    (PUSH)
19    (CONST 4)                           ; 1
20    (BIND 5)                            ; FACTORS
22    (CONST&PUSH 4)                      ; 1
23    (NIL&PUSH)
24    (LOAD&JMPIFNOT 5 L64)
27    L27
27    (LOAD&CAR&STORE 5 0)
30    (PUSH)
31    (CALL1&JMPIFNOT 6 L91)              ; MEXPTP
34    (GETVALUE&PUSH 1)                   ; DEGREE
36    (CONST&PUSH 9)                      ; -1
37    (CALLSR&JMPIF 1 45 L101)            ; =
41    (LOAD 0)
42    (CDR)
43    (CDR)
44    (CAR&PUSH)
45    (CALL1&PUSH 10)                     ; RATDEGREE
47    (GETVALUE&PUSH 1)                   ; DEGREE
49    (CALLSR&JMPIF 1 45 L101)            ; =
53    (LOAD 0)
54    L54
54    (PUSH)
55    (LOAD&PUSH 2)
56    (CALL2 8)                           ; MUL*
58    (STORE 1)
59    L59
59    (LOAD&CDR&STORE 5)
61    (LOAD&JMPIF 5 L27)
64    L64
64    (LOAD&PUSH 1)
65    (GETVALUE 5)                        ; FACTORS
67    (CONS)
68    (SKIP 2)
70    (UNBIND1)
71    (SKIP 1)
73    (UNBIND 3)
75    (SKIP&RET 4)
77    L77
77    (GETVALUE 0)                        ; EXP
79    (CDR)
80    (JMP L18)
82    L82
82    (LOAD&PUSH 0)
83    (GETVALUE&PUSH 5)                   ; FACTORS
85    (CALL2 8)                           ; MUL*
87    (SETVALUE 5)                        ; FACTORS
89    (JMP L59)
91    L91
91    (GETVALUE&PUSH 1)                   ; DEGREE
93    (CONST&PUSH 7)                      ; 0
94    (CALLSR&JMPIF 1 45 L82)             ; =
98    (LOAD 0)
99    (JMP L54)
101   L101
101   (LOAD 0)
102   (CDR)
103   (CAR&PUSH)
104   (LOAD 1)
105   (CDR)
106   (CDR)
107   (CAR&PUSH)
108   (CALL1&PUSH 11)                     ; LEADING-COEF
110   (CALL2&PUSH 12)                     ; POWER*
112   (GETVALUE&PUSH 5)                   ; FACTORS
114   (CALL2 8)                           ; MUL*
116   (SETVALUE 5)                        ; FACTORS
118   (LOAD 0)
119   (CDR)
120   (CAR&PUSH)
121   (LOAD 1)
122   (CDR)
123   (CDR)
124   (CAR&PUSH)
125   (LOAD 2)
126   (CDR)
127   (CDR)
128   (CAR&PUSH)
129   (CALL1&PUSH 11)                     ; LEADING-COEF
131   (GETVALUE&PUSH 2)                   ; VAR
133   (GETVALUE&PUSH 1)                   ; DEGREE
135   (CALL2&PUSH 12)                     ; POWER*
137   (CALL2&PUSH 8)                      ; MUL*
139   (CALL2&PUSH 13)                     ; SUB*
141   (CALL2 12)                          ; POWER*
143   (JMP L54)


Disassembly of function #:|(DEFUN LEADING-COEF (RAT) ...)-54|
(CONST 0) = LEADING-COEF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LEADING-COEF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LEADING-COEF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LEADING-COEF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LEADING-COEF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LEADING-COEF
8     (SKIP&RET 1)


Disassembly of function LEADING-COEF
(CONST 0) = VAR
(CONST 1) = RATDEGREE
(CONST 2) = POWER*
(CONST 3) = DIV*
(CONST 4) = RATLIM
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
8 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; VAR
3     (LOAD&PUSH 3)
4     (CALL1&PUSH 1)                      ; RATDEGREE
6     (CALL2&PUSH 2)                      ; POWER*
8     (CALL2&PUSH 3)                      ; DIV*
10    (CALL1 4)                           ; RATLIM
12    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RATDEGREE (RAT) ...)-55|
(CONST 0) = RATDEGREE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATDEGREE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATDEGREE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATDEGREE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATDEGREE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATDEGREE
8     (SKIP&RET 1)


Disassembly of function RATDEGREE
(CONST 0) = NUMDEN*
(CONST 1) = DEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; NUMDEN*
3     (LOAD&CAR&PUSH 0)
5     (CALL1&PUSH 1)                      ; DEG
7     (LOAD&CDR&PUSH 1)
9     (CALL1&PUSH 1)                      ; DEG
11    (CALLSR 1 54)                       ; -
14    (SKIP&RET 3)


Disassembly of function #:|(DEFUN LIMFACT2 (N D VAR ...) ...)-56|
(CONST 0) = LIMFACT2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMFACT2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMFACT2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMFACT2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMFACT2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMFACT2
8     (SKIP&RET 1)


Disassembly of function LIMFACT2
(CONST 0) = N
(CONST 1) = D
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = REFLECT0
(CONST 5) = ALIKE1
(CONST 6) = DIV*
(CONST 7) = THINK
(CONST 8) = LIMIT
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (D VAL VAR N)
38 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; N
3     (LOAD 6)
4     (BIND 1)                            ; D
6     (LOAD 8)
7     (BIND 2)                            ; VAR
9     (LOAD 10)
10    (BIND 3)                            ; VAL
12    (GETVALUE&PUSH 0)                   ; N
14    (GETVALUE&PUSH 2)                   ; VAR
16    (GETVALUE&PUSH 3)                   ; VAL
18    (CALL&PUSH 3 4)                     ; REFLECT0
21    (GETVALUE&PUSH 1)                   ; D
23    (GETVALUE&PUSH 2)                   ; VAR
25    (GETVALUE&PUSH 3)                   ; VAL
27    (CALL&PUSH 3 4)                     ; REFLECT0
30    (GETVALUE&PUSH 0)                   ; N
32    (LOAD&PUSH 2)
33    (CALL2&JMPIFNOT 5 L42)              ; ALIKE1
36    (GETVALUE&PUSH 1)                   ; D
38    (LOAD&PUSH 1)
39    (CALL2&JMPIF 5 L60)                 ; ALIKE1
42    L42
42    (LOAD&PUSH 1)
43    (LOAD&PUSH 1)
44    (CALL2&PUSH 6)                      ; DIV*
46    (GETVALUE&PUSH 2)                   ; VAR
48    (GETVALUE&PUSH 3)                   ; VAL
50    (CONST&PUSH 7)                      ; THINK
51    (CALL 4 8)                          ; LIMIT
54    (SKIP 2)
56    L56
56    (UNBIND 4)
58    (SKIP&RET 5)
60    L60
60    (NIL)
61    (SKIP 2)
63    (JMP L56)


Disassembly of function #:|(DEFUN REFLECT0 (EXP VAR VAL) ...)-57|
(CONST 0) = REFLECT0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REFLECT0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REFLECT0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REFLECT0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REFLECT0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REFLECT0
8     (SKIP&RET 1)


Disassembly of function REFLECT0
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = MFACTORIAL
(CONST 4) = THINK
(CONST 5) = LIMIT
(CONST 6) = $MINF
(CONST 7) = 0
(CONST 8) = REFLECT
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR EXP)
74 byte-code instructions:
0     L0
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE 0)                        ; EXP
11    (JMPIFATOM L57)
13    (GETVALUE 0)                        ; EXP
15    (CAR)
16    (CAR&PUSH)
17    (JMPIFNOTEQTO 3 L45)                ; MFACTORIAL
20    (GETVALUE 0)                        ; EXP
22    (CDR)
23    (CAR&PUSH)
24    (GETVALUE&PUSH 1)                   ; VAR
26    (GETVALUE&PUSH 2)                   ; VAL
28    (CONST&PUSH 4)                      ; THINK
29    (CALL&PUSH 4 5)                     ; LIMIT
32    (LOAD&PUSH 0)
33    (CONST 6)                           ; $MINF
34    (EQ)
35    (JMPIF L41)
37    (LOAD&PUSH 0)
38    (CALLS2&JMPIF 8 L61)                ; NUMBERP
41    L41
41    (SKIP 1)
43    (JMPIF L70)
45    L45
45    (GETVALUE 0)                        ; EXP
47    (CAR)
48    (CAR&PUSH)
49    (NIL)
50    (CONS&PUSH)
51    (NIL&PUSH)
52    (GETVALUE 0)                        ; EXP
54    (CDR&PUSH)
55    (JMP L94)
57    L57
57    (GETVALUE 0)                        ; EXP
59    (JMP L106)
61    L61
61    (CONST&PUSH 7)                      ; 0
62    (LOAD&PUSH 1)
63    (CALLSR 1 48)                       ; >
66    (SKIP 1)
68    (JMPIFNOT L45)
70    L70
70    (GETVALUE 0)                        ; EXP
72    (CDR)
73    (CAR&PUSH)
74    (CALL1 8)                           ; REFLECT
76    (JMP L106)
78    L78
78    (LOAD&CAR&PUSH 0)
80    (LOAD&PUSH 0)
81    (GETVALUE&PUSH 1)                   ; VAR
83    (GETVALUE&PUSH 2)                   ; VAL
85    (JSR&PUSH L0)
88    (LOAD&CONS&STORE 2)
90    (SKIP 1)
92    (LOAD&CDR&STORE 0)
94    L94
94    (LOAD&PUSH 0)
95    (CALLS1&JMPIFNOT 146 L78)           ; ENDP
98    (SKIP 1)
100   (LOAD&PUSH 0)
101   (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
103   (SKIP 1)
105   (CONS)
106   L106
106   (UNBIND 3)
108   (SKIP&RET 4)


Disassembly of function #:|(DEFUN REFLECT (ARG) ...)-58|
(CONST 0) = REFLECT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REFLECT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REFLECT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REFLECT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REFLECT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REFLECT
8     (SKIP&RET 1)


Disassembly of function REFLECT
(CONST 0) = ARG
(CONST 1) = -1
(CONST 2) = $%PI
(CONST 3) = MFACTORIAL
(CONST 4) = MUL*
(CONST 5) = ADD*
(CONST 6) = POWER*
(CONST 7) = %SIN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ARG)
27 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (CONST&PUSH 1)                      ; -1
4     (CONST&PUSH 2)                      ; $%PI
5     (CONST&PUSH 3)                      ; MFACTORIAL
6     (NIL)
7     (CONS&PUSH)
8     (CONST&PUSH 1)                      ; -1
9     (CONST&PUSH 1)                      ; -1
10    (GETVALUE&PUSH 0)                   ; ARG
12    (CALL2&PUSH 4)                      ; MUL*
14    (CALL2&PUSH 5)                      ; ADD*
16    (LIST&PUSH 2)
18    (CONST&PUSH 1)                      ; -1
19    (CALL2&PUSH 6)                      ; POWER*
21    (CONST&PUSH 7)                      ; %SIN
22    (NIL)
23    (CONS&PUSH)
24    (CONST&PUSH 2)                      ; $%PI
25    (GETVALUE&PUSH 0)                   ; ARG
27    (CALL2&PUSH 4)                      ; MUL*
29    (LIST&PUSH 2)
31    (CONST&PUSH 1)                      ; -1
32    (CALL2&PUSH 6)                      ; POWER*
34    (CALL 4 4)                          ; MUL*
37    (UNBIND1)
38    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LIMFACT (N D) ...)-59|
(CONST 0) = LIMFACT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMFACT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMFACT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMFACT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMFACT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMFACT
8     (SKIP&RET 1)


Disassembly of function LIMFACT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = ANS
(CONST 3) = STIRLING0
(CONST 4) = DIV*
(CONST 5) = VAR
(CONST 6) = $INF
(CONST 7) = $LIMIT
(CONST 8) = (UND IND)
(CONST 9) = MEMQ
(CONST 10) = %LIMIT
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS VAR D N)
writes special variables : (ANS D N)
38 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (NIL)
7     (BIND 2)                            ; ANS
9     (GETVALUE&PUSH 0)                   ; N
11    (CALL1 3)                           ; STIRLING0
13    (SETVALUE 0)                        ; N
15    (GETVALUE&PUSH 1)                   ; D
17    (CALL1 3)                           ; STIRLING0
19    (SETVALUE 1)                        ; D
21    (GETVALUE&PUSH 0)                   ; N
23    (GETVALUE&PUSH 1)                   ; D
25    (CALL2&PUSH 4)                      ; DIV*
27    (GETVALUE&PUSH 5)                   ; VAR
29    (CONST&PUSH 6)                      ; $INF
30    (CALL 3 7)                          ; $LIMIT
33    (SETVALUE 2)                        ; ANS
35    (JMPIFCONSP L43)
37    (GETVALUE&PUSH 2)                   ; ANS
39    (CONST&PUSH 8)                      ; (UND IND)
40    (CALL2&JMPIFNOT 9 L50)              ; MEMQ
43    L43
43    (GETVALUE 2)                        ; ANS
45    (CAR)
46    (CAR&PUSH)
47    (JMPIFEQTO 10 L57)                  ; %LIMIT
50    L50
50    (GETVALUE 2)                        ; ANS
52    (UNBIND1)
53    L53
53    (UNBIND 2)
55    (SKIP&RET 3)
57    L57
57    (NIL)
58    (UNBIND1)
59    (JMP L53)


Disassembly of function #:|(DEFUN STIRLING0 (E) ...)-60|
(CONST 0) = STIRLING0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE STIRLING0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; STIRLING0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; STIRLING0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE STIRLING0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; STIRLING0
8     (SKIP&RET 1)


Disassembly of function STIRLING0
(CONST 0) = E
(CONST 1) = STIRLING0
(CONST 2) = %GAMMA
(CONST 3) = VAR
(CONST 4) = AMONG
(CONST 5) = STIRLING
(CONST 6) = MFACTORIAL
(CONST 7) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
writes special variable : (E)
55 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L57)
7     (GETVALUE 0)                        ; E
9     (CAR&PUSH)
10    (CONST&PUSH 1)                      ; STIRLING0
11    (GETVALUE 0)                        ; E
13    (CDR&PUSH)
14    (CALLSR 0 22)                       ; MAPCAR
17    (CONS)
18    (SETVALUE 0)                        ; E
20    (GETVALUE 0)                        ; E
22    (CAR)
23    (CAR&PUSH)
24    (JMPIFNOTEQTO 2 L36)                ; %GAMMA
27    (GETVALUE&PUSH 3)                   ; VAR
29    (GETVALUE 0)                        ; E
31    (CDR)
32    (CAR&PUSH)
33    (CALL2&JMPIF 4 L61)                 ; AMONG
36    L36
36    (GETVALUE 0)                        ; E
38    (CAR)
39    (CAR&PUSH)
40    (JMPIFNOTEQTO 6 L52)                ; MFACTORIAL
43    (GETVALUE&PUSH 3)                   ; VAR
45    (GETVALUE 0)                        ; E
47    (CDR)
48    (CAR&PUSH)
49    (CALL2&JMPIF 4 L69)                 ; AMONG
52    L52
52    (GETVALUE 0)                        ; E
54    L54
54    (UNBIND1)
55    (SKIP&RET 2)
57    L57
57    (GETVALUE 0)                        ; E
59    (JMP L54)
61    L61
61    (GETVALUE 0)                        ; E
63    (CDR)
64    (CAR&PUSH)
65    (CALL1 5)                           ; STIRLING
67    (JMP L54)
69    L69
69    (GETVALUE 0)                        ; E
71    (CDR)
72    (CAR&PUSH)
73    (GETVALUE 0)                        ; E
75    (CDR)
76    (CAR&PUSH)
77    (CALL1&PUSH 5)                      ; STIRLING
79    (CALL2 7)                           ; MUL*
81    (JMP L54)


Disassembly of function #:|(DEFUN STIRLING (X) ...)-61|
(CONST 0) = STIRLING
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE STIRLING>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; STIRLING
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; STIRLING
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE STIRLING>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; STIRLING
8     (SKIP&RET 1)


Disassembly of function STIRLING
(CONST 0) = X
(CONST 1) = $Z
(CONST 2) = 
((MTIMES SIMP) ((MEXPT SIMP) 2 ((RAT SIMP) 1 2))
 ((MEXPT SIMP) $%PI ((RAT SIMP) 1 2))
 ((MEXPT SIMP) $Z ((MPLUS SIMP) ((RAT SIMP) -1 2) $Z))
 ((MEXPT SIMP) $%E ((MTIMES SIMP) -1 $Z)))
(CONST 3) = MAXIMA-SUBSTITUTE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
8 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CONST&PUSH 1)                      ; $Z
6     (CONST&PUSH 2)                      ; ((MTIMES SIMP) (# 2 ...) ...)
7     (CALL 3 3)                          ; MAXIMA-SUBSTITUTE
10    (UNBIND1)
11    (SKIP&RET 2)


Disassembly of function #:|(DEFUN NO-ERR-SUB (V E &AUX ...) ...)-62|
(CONST 0) = NO-ERR-SUB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NO-ERR-SUB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NO-ERR-SUB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NO-ERR-SUB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NO-ERR-SUB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NO-ERR-SUB
8     (SKIP&RET 1)


Disassembly of function NO-ERR-SUB
(CONST 0) = V
(CONST 1) = E
(CONST 2) = ANS
(CONST 3) = ERRORSW
(CONST 4) = ERRRJFFLAG
(CONST 5) = *ZEXPTSIMP?
(CONST 6) = RATERR
(CONST 7) = SUBIN
(CONST 8) = SRATSIMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS E V)
writes special variable : (ANS)
36 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; V
3     (LOAD 4)
4     (BIND 1)                            ; E
6     (NIL)
7     (BIND 2)                            ; ANS
9     (T)
10    (BIND 3)                            ; ERRORSW
12    (T)
13    (BIND 4)                            ; ERRRJFFLAG
15    (T)
16    (BIND 5)                            ; *ZEXPTSIMP?
18    (CONST 3)                           ; ERRORSW
19    (CATCH-OPEN L41)
21    (CONST 6)                           ; RATERR
22    (CATCH-OPEN L33)
24    (GETVALUE&PUSH 0)                   ; V
26    (GETVALUE&PUSH 1)                   ; E
28    (CALL2&PUSH 7)                      ; SUBIN
30    (CALL1 8)                           ; SRATSIMP
32    (CATCH-CLOSE)
33    L33
33    (CATCH-CLOSE)
34    (SETVALUE 2)                        ; ANS
36    (JMPIF L45)
38    L38
38    (T)
39    (JMP L47)
41    L41
41    (SETVALUE 2)                        ; ANS
43    (JMPIFNOT L38)
45    L45
45    (GETVALUE 2)                        ; ANS
47    L47
47    (UNBIND 6)
49    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SIMPLIMSUBST (V E) ...)-63|
(CONST 0) = SIMPLIMSUBST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMSUBST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMSUBST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMSUBST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMSUBST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMSUBST
8     (SKIP&RET 1)


Disassembly of function SIMPLIMSUBST
(CONST 0) = V
(CONST 1) = E
(CONST 2) = ANS
(CONST 3) = RIDOFAB
(CONST 4) = NO-ERR-SUB
(CONST 5) = (MFACTORIAL)
(CONST 6) = INVOLVE
(CONST 7) = ($ZEROA $ZEROB)
(CONST 8) = MEMQ
(CONST 9) = 0
(CONST 10) = VAR
(CONST 11) = BEHAVIOR
(CONST 12) = 1
(CONST 13) = $ZEROA
(CONST 14) = -1
(CONST 15) = $ZEROB
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR ANS E V)
writes special variable : (ANS)
50 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; V
3     (LOAD 4)
4     (BIND 1)                            ; E
6     (NIL)
7     (BIND 2)                            ; ANS
9     (GETVALUE&PUSH 0)                   ; V
11    (CALL1&PUSH 3)                      ; RIDOFAB
13    (GETVALUE&PUSH 1)                   ; E
15    (CALL2 4)                           ; NO-ERR-SUB
17    (SETVALUE 2)                        ; ANS
19    (PUSH)
20    (T)
21    (JMPIFEQ L29)
23    (GETVALUE&PUSH 1)                   ; E
25    (CONST&PUSH 5)                      ; (MFACTORIAL)
26    (CALL2&JMPIFNOT 6 L43)              ; INVOLVE
29    L29
29    (NIL)
30    (UNBIND1)
31    L31
31    (UNBIND 2)
33    (SKIP&RET 3)
35    L35
35    (CONST 13)                          ; $ZEROA
36    (UNBIND1)
37    (JMP L31)
39    L39
39    (CONST 15)                          ; $ZEROB
40    (UNBIND1)
41    (JMP L31)
43    L43
43    (GETVALUE&PUSH 0)                   ; V
45    (CONST&PUSH 7)                      ; ($ZEROA $ZEROB)
46    (CALL2&JMPIFNOT 8 L74)              ; MEMQ
49    (GETVALUE&PUSH 2)                   ; ANS
51    (JMPIFNOTEQTO 9 L74)                ; 0
54    (GETVALUE&PUSH 1)                   ; E
56    (GETVALUE&PUSH 10)                  ; VAR
58    (GETVALUE&PUSH 0)                   ; V
60    (CALL 3 11)                         ; BEHAVIOR
63    (SETVALUE 2)                        ; ANS
65    (PUSH)
66    (JMPIFEQTO 12 L35)                  ; 1
69    (GETVALUE&PUSH 2)                   ; ANS
71    (JMPIFEQTO 14 L39)                  ; -1
74    L74
74    (GETVALUE 2)                        ; ANS
76    (UNBIND1)
77    (JMP L31)


Disassembly of function #:|(DEFUN NUMDEN* (E) ...)-64|
(CONST 0) = NUMDEN*
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NUMDEN*>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NUMDEN*
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NUMDEN*
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NUMDEN*>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NUMDEN*
8     (SKIP&RET 1)


Disassembly of function NUMDEN*
(CONST 0) = E
(CONST 1) = SIMPLIFY
(CONST 2) = FACTOR
(CONST 3) = NUMER
(CONST 4) = DENOM
(CONST 5) = MTIMESP
(CONST 6) = FORQ
(CONST 7) = 1
(CONST 8) = MULN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DENOM NUMER E)
writes special variables : (DENOM NUMER)
75 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CALL1&PUSH 1)                      ; SIMPLIFY
7     (CALL1 2)                           ; FACTOR
9     (BIND 0)                            ; E
11    (NIL)
12    (BIND 3)                            ; NUMER
14    (NIL)
15    (BIND 4)                            ; DENOM
17    (GETVALUE 0)                        ; E
19    (JMPIFATOM L78)
21    (GETVALUE&PUSH 0)                   ; E
23    (CALL1&JMPIF 5 L91)                 ; MTIMESP
27    (GETVALUE&PUSH 0)                   ; E
29    (CALL1 6)                           ; FORQ
31    (GETVALUE 3)                        ; NUMER
33    (JMPIFNOT L103)
36    L36
36    (GETVALUE 3)                        ; NUMER
38    (CDR)
39    (JMPIFNOT L106)
42    (GETVALUE&PUSH 3)                   ; NUMER
44    (NIL&PUSH)
45    (CALL2 8)                           ; MULN
47    L47
47    (SETVALUE 3)                        ; NUMER
49    (GETVALUE 4)                        ; DENOM
51    (JMPIFNOT L111)
53    (GETVALUE 4)                        ; DENOM
55    (CDR)
56    (JMPIFNOT L116)
58    (GETVALUE&PUSH 4)                   ; DENOM
60    (NIL&PUSH)
61    (CALL2 8)                           ; MULN
63    (SETVALUE 4)                        ; DENOM
65    L65
65    (GETVALUE&PUSH 3)                   ; NUMER
67    (CALL1&PUSH 2)                      ; FACTOR
69    (GETVALUE&PUSH 4)                   ; DENOM
71    (CALL1 2)                           ; FACTOR
73    (CONS)
74    (UNBIND 4)
76    (SKIP&RET 2)
78    L78
78    (GETVALUE&PUSH 0)                   ; E
80    (GETVALUE 3)                        ; NUMER
82    (CONS)
83    (SETVALUE 3)                        ; NUMER
85    (GETVALUE 3)                        ; NUMER
87    (JMPIFNOT L103)
89    (JMP L36)
91    L91
91    (CONST&PUSH 6)                      ; FORQ
92    (GETVALUE 0)                        ; E
94    (CDR&PUSH)
95    (CALLSR 0 24)                       ; MAPC
98    (GETVALUE 3)                        ; NUMER
100   (JMPIF L36)
103   L103
103   (CONST 7)                           ; 1
104   (JMP L47)
106   L106
106   (GETVALUE 3)                        ; NUMER
108   (CAR)
109   (JMP L47)
111   L111
111   (CONST 7)                           ; 1
112   (SETVALUE 4)                        ; DENOM
114   (JMP L65)
116   L116
116   (GETVALUE 4)                        ; DENOM
118   (CAR)
119   (SETVALUE 4)                        ; DENOM
121   (JMP L65)


Disassembly of function #:|(DEFUN FORQ (E) ...)-65|
(CONST 0) = FORQ
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FORQ>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FORQ
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FORQ
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FORQ>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FORQ
8     (SKIP&RET 1)


Disassembly of function FORQ
(CONST 0) = E
(CONST 1) = MEXPTP
(CONST 2) = POS-NEG-P
(CONST 3) = -1
(CONST 4) = MUL*
(CONST 5) = POWER*
(CONST 6) = DENOM
(CONST 7) = NUMER
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (DENOM NUMER E)
writes special variables : (DENOM NUMER)
32 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CALL1&JMPIFNOT 1 L16)              ; MEXPTP
8     (GETVALUE 0)                        ; E
10    (CDR)
11    (CDR)
12    (CAR&PUSH)
13    (CALL1&JMPIFNOT 2 L26)              ; POS-NEG-P
16    L16
16    (GETVALUE&PUSH 0)                   ; E
18    (GETVALUE 7)                        ; NUMER
20    (CONS)
21    (SETVALUE 7)                        ; NUMER
23    L23
23    (UNBIND1)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE 0)                        ; E
28    (CDR)
29    (CAR&PUSH)
30    (CONST&PUSH 3)                      ; -1
31    (GETVALUE 0)                        ; E
33    (CDR)
34    (CDR)
35    (CAR&PUSH)
36    (CALL2&PUSH 4)                      ; MUL*
38    (CALL2&PUSH 5)                      ; POWER*
40    (GETVALUE 6)                        ; DENOM
42    (CONS)
43    (SETVALUE 6)                        ; DENOM
45    (JMP L23)


Disassembly of function #:|(DEFUN POS-NEG-P (EXP) ...)-66|
(CONST 0) = POS-NEG-P
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POS-NEG-P>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POS-NEG-P
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POS-NEG-P
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POS-NEG-P>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POS-NEG-P
8     (SKIP&RET 1)


Disassembly of function POS-NEG-P
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = THINK
(CONST 4) = LIMIT
(CONST 5) = ANS
(CONST 6) = ($UND $IND $INFINITY)
(CONST 7) = MEMQ
(CONST 8) = $IMAGPART
(CONST 9) = 0
(CONST 10) = GETSIGNL
(CONST 11) = SIGN
(CONST 12) = 1
(CONST 13) = -1
(CONST 14) = UNKNOWN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SIGN ANS VAL VAR EXP)
39 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (GETVALUE&PUSH 1)                   ; VAR
7     (GETVALUE&PUSH 2)                   ; VAL
9     (CONST&PUSH 3)                      ; THINK
10    (CALL 4 4)                          ; LIMIT
13    (BIND 5)                            ; ANS
15    (GETVALUE&PUSH 5)                   ; ANS
17    (CONST&PUSH 6)                      ; ($UND $IND $INFINITY)
18    (CALL2&JMPIF 7 L60)                 ; MEMQ
21    (GETVALUE&PUSH 5)                   ; ANS
23    (CALL1&PUSH 8)                      ; $IMAGPART
25    (JMPIFNOTEQTO 9 L60)                ; 0
28    (GETVALUE&PUSH 5)                   ; ANS
30    (CALL1 10)                          ; GETSIGNL
32    (BIND 11)                           ; SIGN
34    (GETVALUE&PUSH 11)                  ; SIGN
36    (JMPIFEQTO 12 L54)                  ; 1
39    (GETVALUE&PUSH 11)                  ; SIGN
41    (JMPIFEQTO 9 L54)                   ; 0
44    (GETVALUE&PUSH 11)                  ; SIGN
46    (JMPIFEQTO 13 L57)                  ; -1
49    (NIL)
50    L50
50    (UNBIND 2)
52    (JMP L62)
54    L54
54    (T)
55    (JMP L50)
57    L57
57    (NIL)
58    (JMP L50)
60    L60
60    (CONST 14)                          ; UNKNOWN
61    (UNBIND1)
62    L62
62    (UNBIND1)
63    (SKIP&RET 2)


Disassembly of function #:|(DECLARE-TOP (UNSPECIAL N DN))-67|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Disassembly of function #:|(SETQ LIMFUNC '(%LOG %SIN %COS ...))-68|
(CONST 0) = 
(%LOG %SIN %COS %TAN %SINH %COSH %TANH MFACTORIAL %ASIN %ACOS %ATAN %ASINH
 %ACOSH %ATANH)
(CONST 1) = LIMFUNC
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (LIMFUNC)
3 byte-code instructions:
0     (CONST 0)                           ; (%LOG %SIN %COS %TAN %SINH ...)
1     (SETVALUE 1)                        ; LIMFUNC
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN EXPP (E) ...)-69|
(CONST 0) = EXPP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EXPP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EXPP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EXPP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EXPP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EXPP
8     (SKIP&RET 1)


Disassembly of function EXPP
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = RADICALP
(CONST 3) = LIMFUNC
(CONST 4) = MEMQ
(CONST 5) = SIMPLEXP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LIMFUNC VAR E)
writes special variable : (E)
48 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (GETVALUE&PUSH 1)                   ; VAR
7     (CALL2&JMPIF 2 L54)                 ; RADICALP
10    (GETVALUE 0)                        ; E
12    (CAR)
13    (CAR&PUSH)
14    (GETVALUE&PUSH 3)                   ; LIMFUNC
16    (CALL2&JMPIF 4 L57)                 ; MEMQ
19    (GETVALUE&PUSH 0)                   ; E
21    (CALL1&JMPIF 5 L60)                 ; SIMPLEXP
24    (GETVALUE 0)                        ; E
26    (CDR)
27    (BIND 0)                            ; E
29    (GETVALUE 0)                        ; E
31    (JMPIFNOT L49)
33    L33
33    (GETVALUE 0)                        ; E
35    (CAR&PUSH)
36    (JSR L0)
38    (JMPIF L63)
40    (GETVALUE 0)                        ; E
42    (CDR)
43    (SETVALUE 0)                        ; E
45    (GETVALUE 0)                        ; E
47    (JMPIF L33)
49    L49
49    (UNBIND1)
50    (NIL)
51    L51
51    (UNBIND1)
52    (SKIP&RET 2)
54    L54
54    (NIL)
55    (JMP L51)
57    L57
57    (NIL)
58    (JMP L51)
60    L60
60    (T)
61    (JMP L51)
63    L63
63    (T)
64    (UNBIND1)
65    (VALUES1)
66    (JMP L51)


Disassembly of function #:|(DEFUN SIMPLEXP (E) ...)-70|
(CONST 0) = SIMPLEXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLEXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLEXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLEXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLEXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLEXP
8     (SKIP&RET 1)


Disassembly of function SIMPLEXP
(CONST 0) = E
(CONST 1) = MEXPTP
(CONST 2) = VAR
(CONST 3) = RADICALP
(CONST 4) = AMONG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
27 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CALL1 1)                           ; MEXPTP
7     (JMPIFNOT1 L39)
9     (GETVALUE 0)                        ; E
11    (CDR)
12    (CAR&PUSH)
13    (GETVALUE&PUSH 2)                   ; VAR
15    (CALL2 3)                           ; RADICALP
17    (JMPIFNOT1 L39)
19    (GETVALUE&PUSH 2)                   ; VAR
21    (GETVALUE 0)                        ; E
23    (CDR)
24    (CDR)
25    (CAR&PUSH)
26    (CALL2 4)                           ; AMONG
28    (JMPIFNOT1 L39)
30    (GETVALUE 0)                        ; E
32    (CDR)
33    (CDR)
34    (CAR&PUSH)
35    (GETVALUE&PUSH 2)                   ; VAR
37    (CALL2 3)                           ; RADICALP
39    L39
39    (UNBIND1)
40    (SKIP&RET 2)


Disassembly of function #:|(DEFUN GCPOWER (A B) ...)-71|
(CONST 0) = GCPOWER
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GCPOWER>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GCPOWER
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GCPOWER
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GCPOWER>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GCPOWER
8     (SKIP&RET 1)


Disassembly of function GCPOWER
(CONST 0) = A
(CONST 1) = B
(CONST 2) = GETEXP
(CONST 3) = $GCD
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (B A)
11 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; A
3     (LOAD 4)
4     (BIND 1)                            ; B
6     (GETVALUE&PUSH 0)                   ; A
8     (CALL1&PUSH 2)                      ; GETEXP
10    (GETVALUE&PUSH 1)                   ; B
12    (CALL1&PUSH 2)                      ; GETEXP
14    (CALL2 3)                           ; $GCD
16    (UNBIND 2)
18    (SKIP&RET 3)


Disassembly of function #:|(DEFUN GETEXP (EXP) ...)-72|
(CONST 0) = GETEXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GETEXP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GETEXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GETEXP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GETEXP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GETEXP
8     (SKIP&RET 1)


Disassembly of function GETEXP
(CONST 0) = EXP
(CONST 1) = MEXPTP
(CONST 2) = VAR
(CONST 3) = FREE
(CONST 4) = $INTEGER
(CONST 5) = ASK-INTEGER
(CONST 6) = $YES
(CONST 7) = MTIMESP
(CONST 8) = GETEXPLIST
(CONST 9) = 1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
35 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&JMPIFNOT 1 L29)              ; MEXPTP
8     (GETVALUE 0)                        ; EXP
10    (CDR)
11    (CDR)
12    (CAR&PUSH)
13    (GETVALUE&PUSH 2)                   ; VAR
15    (CALL2&JMPIFNOT 3 L29)              ; FREE
18    (GETVALUE 0)                        ; EXP
20    (CDR)
21    (CDR)
22    (CAR&PUSH)
23    (CONST&PUSH 4)                      ; $INTEGER
24    (CALL2&PUSH 5)                      ; ASK-INTEGER
26    (JMPIFEQTO 6 L38)                   ; $YES
29    L29
29    (GETVALUE&PUSH 0)                   ; EXP
31    (CALL1&JMPIF 7 L45)                 ; MTIMESP
34    (CONST 9)                           ; 1
35    L35
35    (UNBIND1)
36    (SKIP&RET 2)
38    L38
38    (GETVALUE 0)                        ; EXP
40    (CDR)
41    (CDR)
42    (CAR)
43    (JMP L35)
45    L45
45    (GETVALUE 0)                        ; EXP
47    (CDR&PUSH)
48    (CALL1 8)                           ; GETEXPLIST
50    (JMP L35)


Disassembly of function #:|(DEFUN GETEXPLIST (LIST) ...)-73|
(CONST 0) = GETEXPLIST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GETEXPLIST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GETEXPLIST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GETEXPLIST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GETEXPLIST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GETEXPLIST
8     (SKIP&RET 1)


Disassembly of function GETEXPLIST
(CONST 0) = GETEXP
(CONST 1) = $GCD
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
14 byte-code instructions:
0     L0
0     (LOAD 1)
1     (CDR)
2     (JMPIFNOT L16)
4     (LOAD&CAR&PUSH 1)
6     (CALL1&PUSH 0)                      ; GETEXP
8     (LOAD&CDR&PUSH 2)
10    (JSR&PUSH L0)
12    (CALL2 1)                           ; $GCD
14    (SKIP&RET 2)
16    L16
16    (LOAD&CAR&PUSH 1)
18    (CALL1 0)                           ; GETEXP
20    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LIMROOT (EXP POWER) ...)-74|
(CONST 0) = LIMROOT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMROOT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMROOT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMROOT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMROOT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMROOT
8     (SKIP&RET 1)


Disassembly of function LIMROOT
(CONST 0) = EXP
(CONST 1) = (MTIMES MEXPT)
(CONST 2) = MEMQ
(CONST 3) = (MEXPT)
(CONST 4) = 1
(CONST 5) = MEXPTP
(CONST 6) = -1
(CONST 7) = POWER*
(CONST 8) = MUL*
(CONST 9) = SRATSIMP
(CONST 10) = X
(CONST 11) = MULN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (X EXP)
62 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (JMPIFATOM L26)
7     (GETVALUE 0)                        ; EXP
9     (CAR)
10    (CAR&PUSH)
11    (CONST&PUSH 1)                      ; (MTIMES MEXPT)
12    (CALL2&JMPIFNOT 2 L26)              ; MEMQ
15    (GETVALUE&PUSH 0)                   ; EXP
17    (CALL1&JMPIF 5 L37)                 ; MEXPTP
20    (NIL&PUSH)
21    (GETVALUE 0)                        ; EXP
23    (CDR&PUSH)
24    (JMP L77)
26    L26
26    (CONST&PUSH 3)                      ; (MEXPT)
27    (GETVALUE&PUSH 0)                   ; EXP
29    (CONST&PUSH 4)                      ; 1
30    (LIST&PUSH 3)
32    (LOAD&PUSH 5)
33    (JSR L0)
35    (JMP L90)
37    L37
37    (GETVALUE 0)                        ; EXP
39    (CDR)
40    (CAR&PUSH)
41    (GETVALUE 0)                        ; EXP
43    (CDR)
44    (CDR)
45    (CAR&PUSH)
46    (LOAD&PUSH 6)
47    (CONST&PUSH 6)                      ; -1
48    (CALL2&PUSH 7)                      ; POWER*
50    (CALL2&PUSH 8)                      ; MUL*
52    (CALL1&PUSH 9)                      ; SRATSIMP
54    (CALL2 7)                           ; POWER*
56    (JMP L90)
58    L58
58    (LOAD&CAR&PUSH 0)
60    (LOAD 0)
61    (BIND 10)                           ; X
63    (GETVALUE&PUSH 10)                  ; X
65    (LOAD&PUSH 11)
66    (JSR L0)
69    (UNBIND1)
70    (PUSH)
71    (LOAD&CONS&STORE 2)
73    (SKIP 1)
75    (LOAD&CDR&STORE 0)
77    L77
77    (LOAD&PUSH 0)
78    (CALLS1&JMPIFNOT 146 L58)           ; ENDP
81    (SKIP 1)
83    (LOAD&PUSH 0)
84    (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
87    (NIL&PUSH)
88    (CALL2 11)                          ; MULN
90    L90
90    (UNBIND1)
91    (SKIP&RET 3)


Disassembly of function #:|(DEFUN COLEXPT (N DN GCP) ...)-75|
(CONST 0) = COLEXPT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE COLEXPT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; COLEXPT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; COLEXPT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE COLEXPT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; COLEXPT
8     (SKIP&RET 1)


Disassembly of function COLEXPT
(CONST 0) = N
(CONST 1) = LIMROOT
(CONST 2) = -1
(CONST 3) = MUL*
(CONST 4) = BAS
(CONST 5) = VAR
(CONST 6) = VAL
(CONST 7) = THINK
(CONST 8) = LIMIT
(CONST 9) = SIMPLIMEXPT
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR BAS N)
33 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (GETVALUE&PUSH 0)                   ; N
5     (LOAD&PUSH 5)
6     (CALL2&PUSH 1)                      ; LIMROOT
8     (LOAD&PUSH 6)
9     (CONST&PUSH 2)                      ; -1
10    (LOAD&PUSH 7)
11    (CALL2&PUSH 3)                      ; MUL*
13    (CALL2&PUSH 1)                      ; LIMROOT
15    (CALL2 3)                           ; MUL*
17    (BIND 4)                            ; BAS
19    (PUSH-NIL 2)
21    (GETVALUE&PUSH 4)                   ; BAS
23    (GETVALUE&PUSH 5)                   ; VAR
25    (GETVALUE&PUSH 6)                   ; VAL
27    (CONST&PUSH 7)                      ; THINK
28    (CALL 4 8)                          ; LIMIT
31    (STORE 1)
32    (LOAD&PUSH 9)
33    (GETVALUE&PUSH 5)                   ; VAR
35    (GETVALUE&PUSH 6)                   ; VAL
37    (CONST&PUSH 7)                      ; THINK
38    (CALL 4 8)                          ; LIMIT
41    (STORE 0)
42    (GETVALUE&PUSH 4)                   ; BAS
44    (LOAD&PUSH 10)
45    (LOAD&PUSH 3)
46    (LOAD&PUSH 3)
47    (CALL 4 9)                          ; SIMPLIMEXPT
50    (SKIP 2)
52    (UNBIND 2)
54    (SKIP&RET 4)


Disassembly of function #:|(DEFUN LOG-RED-CONTRACT (FACS) ...)-76|
(CONST 0) = LOG-RED-CONTRACT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOG-RED-CONTRACT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOG-RED-CONTRACT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOG-RED-CONTRACT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOG-RED-CONTRACT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOG-RED-CONTRACT
8     (SKIP&RET 1)


Disassembly of function LOG-RED-CONTRACT
(CONST 0) = L
(CONST 1) = VAR
(CONST 2) = FREEOF
(CONST 3) = MLOGP
(CONST 4) = MULN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR L)
writes special variable : (L)
47 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (PUSH-NIL 2)
5     (GETVALUE 0)                        ; L
7     (JMPIFNOT L39)
9     L9
9     (GETVALUE&PUSH 1)                   ; VAR
11    (GETVALUE 0)                        ; L
13    (CAR&PUSH)
14    (CALL2&JMPIF 2 L54)                 ; FREEOF
17    (GETVALUE 0)                        ; L
19    (CAR&PUSH)
20    (CALL1&JMPIFNOT 3 L64)              ; MLOGP
23    (LOAD&JMPIF 0 L61)
26    (GETVALUE 0)                        ; L
28    (CAR)
29    (STORE 0)
30    L30
30    (GETVALUE 0)                        ; L
32    (CDR)
33    (SETVALUE 0)                        ; L
35    (GETVALUE 0)                        ; L
37    (JMPIF L9)
39    L39
39    (LOAD 0)
40    (JMPIFNOT1 L49)
42    (CDR)
43    (CAR&PUSH)
44    (LOAD&PUSH 2)
45    (NIL&PUSH)
46    (CALL2 4)                           ; MULN
48    (CONS)
49    L49
49    (SKIP 2)
51    (UNBIND1)
52    (SKIP&RET 2)
54    L54
54    (GETVALUE 0)                        ; L
56    (CAR&PUSH)
57    (LOAD&CONS&STORE 1)
59    (JMP L30)
61    L61
61    (NIL)
62    (JMP L49)
64    L64
64    (NIL)
65    (JMP L49)


Disassembly of function #:|(DEFUN LOG-REDUCE (X) ...)-77|
(CONST 0) = LOG-REDUCE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOG-REDUCE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOG-REDUCE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOG-REDUCE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOG-REDUCE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOG-REDUCE
8     (SKIP&RET 1)


Disassembly of function LOG-REDUCE
(CONST 0) = X
(CONST 1) = VAR
(CONST 2) = FREEOF
(CONST 3) = MPLUSP
(CONST 4) = L
(CONST 5) = TEMP
(CONST 6) = MLOGP
(CONST 7) = VAL
(CONST 8) = THINK
(CONST 9) = LIMIT
(CONST 10) = INFINITIES
(CONST 11) = MEMQ
(CONST 12) = MTIMESP
(CONST 13) = LOG-RED-CONTRACT
(CONST 14) = POWER*
(CONST 15) = (%LOG)
(CONST 16) = MULN
(CONST 17) = (%LOG)
(CONST 18) = ADDN
(CONST 19) = 1
(CONST 20) = ANS
(CONST 21) = MUL*
(CONST 22) = $EXPAND
(CONST 23) = MEXPTP
(CONST 24) = POWER
(CONST 25) = MAXI
(CONST 26) = (%LOG)
(CONST 27) = (%LOG)
(CONST 28) = DIV*
(CONST 29) = ADD*
(CONST 30) = 0
(CONST 31) = (%LOG)
(CONST 32) = SIMPLIFY
(CONST 33) = (%LOG)
(CONST 34) = ALIKE1
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS INFINITIES VAL TEMP L VAR X)
writes special variables : (ANS L TEMP X)
253 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE 0)                        ; X
5     (JMPIFATOM L93)
8     (GETVALUE&PUSH 1)                   ; VAR
10    (GETVALUE&PUSH 0)                   ; X
12    (CALL2&JMPIF 2 L98)                 ; FREEOF
16    (GETVALUE&PUSH 0)                   ; X
18    (CALL1&JMPIFNOT 3 L285)             ; MPLUSP
22    (GETVALUE 0)                        ; X
24    (CDR)
25    (BIND 4)                            ; L
27    (PUSH-NIL 3)
29    (NIL)
30    (BIND 5)                            ; TEMP
32    (GETVALUE 4)                        ; L
34    (JMPIFNOT L159)
37    L37
37    (GETVALUE 4)                        ; L
39    (CAR&PUSH)
40    (JSR L0)
42    (SETVALUE 0)                        ; X
44    (PUSH)
45    (CALL1&JMPIF 6 L109)                ; MLOGP
48    (GETVALUE&PUSH 0)                   ; X
50    (CALL1&JMPIFNOT 12 L145)            ; MTIMESP
54    (GETVALUE 0)                        ; X
56    (CDR&PUSH)
57    (CALL1 13)                          ; LOG-RED-CONTRACT
59    (SETVALUE 5)                        ; TEMP
61    (JMPIFNOT L145)
64    (GETVALUE 5)                        ; TEMP
66    (CAR&PUSH)
67    (GETVALUE&PUSH 1)                   ; VAR
69    (GETVALUE&PUSH 7)                   ; VAL
71    (CONST&PUSH 8)                      ; THINK
72    (CALL&PUSH 4 9)                     ; LIMIT
75    (GETVALUE&PUSH 10)                  ; INFINITIES
77    (CALL2&JMPIFNOT 11 L132)            ; MEMQ
80    (GETVALUE 5)                        ; TEMP
82    (CAR&PUSH)
83    (GETVALUE 5)                        ; TEMP
85    (CDR&PUSH)
86    (CALL2 14)                          ; POWER*
88    L88
88    (PUSH)
89    (LOAD&CONS&STORE 3)
91    (JMP L149)
93    L93
93    (GETVALUE 0)                        ; X
95    (JMP L431)
98    L98
98    (GETVALUE 0)                        ; X
100   (JMP L431)
103   L103
103   (GETVALUE 0)                        ; X
105   (CDR)
106   (CAR)
107   (JMP L88)
109   L109
109   (GETVALUE 0)                        ; X
111   (CDR)
112   (CAR&PUSH)
113   (GETVALUE&PUSH 1)                   ; VAR
115   (GETVALUE&PUSH 7)                   ; VAL
117   (CONST&PUSH 8)                      ; THINK
118   (CALL&PUSH 4 9)                     ; LIMIT
121   (GETVALUE&PUSH 10)                  ; INFINITIES
123   (CALL2&JMPIF 11 L103)               ; MEMQ
126   (GETVALUE 0)                        ; X
128   (CDR)
129   (CAR)
130   (JMP L140)
132   L132
132   (GETVALUE 5)                        ; TEMP
134   (CAR&PUSH)
135   (GETVALUE 5)                        ; TEMP
137   (CDR&PUSH)
138   (CALL2 14)                          ; POWER*
140   L140
140   (PUSH)
141   (LOAD&CONS&STORE 4)
143   (JMP L149)
145   L145
145   (GETVALUE&PUSH 0)                   ; X
147   (LOAD&CONS&STORE 5)
149   L149
149   (GETVALUE 4)                        ; L
151   (CDR)
152   (SETVALUE 4)                        ; L
154   (GETVALUE 4)                        ; L
156   (JMPIF L37)
159   L159
159   (CONST&PUSH 15)                     ; (%LOG)
160   (LOAD&PUSH 4)
161   (NIL&PUSH)
162   (CALL2&PUSH 16)                     ; MULN
164   (LIST&PUSH 2)
166   (CONST&PUSH 17)                     ; (%LOG)
167   (LOAD&PUSH 6)
168   (NIL&PUSH)
169   (CALL2&PUSH 16)                     ; MULN
171   (LIST&PUSH 2)
173   (LOAD 7)
174   (LIST*&PUSH 2)
176   (NIL&PUSH)
177   (CALL2 18)                          ; ADDN
179   (UNBIND1)
180   (SKIP 3)
182   (UNBIND1)
183   (JMP L431)
186   L186
186   (GETVALUE 0)                        ; X
188   (CDR)
189   (BIND 4)                            ; L
191   (CONST 19)                          ; 1
192   (BIND 20)                           ; ANS
194   (GETVALUE 4)                        ; L
196   (JMPIFNOT L390)
199   L199
199   (GETVALUE 4)                        ; L
201   (CAR&PUSH)
202   (JSR&PUSH L0)
205   (GETVALUE&PUSH 20)                  ; ANS
207   (CALL2&PUSH 21)                     ; MUL*
209   (CALL1 22)                          ; $EXPAND
211   (SETVALUE 20)                       ; ANS
213   (GETVALUE 4)                        ; L
215   (CDR)
216   (SETVALUE 4)                        ; L
218   (GETVALUE 4)                        ; L
220   (JMPIFNOT L390)
223   (JMP L199)
225   L225
225   (GETVALUE 0)                        ; X
227   (CDR)
228   (CAR&PUSH)
229   (JSR&PUSH L0)
232   (GETVALUE 0)                        ; X
234   (CDR)
235   (CDR)
236   (CAR&PUSH)
237   (CALL2 24)                          ; POWER
239   (JMP L431)
242   L242
242   (GETVALUE 0)                        ; X
244   (JMP L431)
247   L247
247   (GETVALUE 0)                        ; X
249   (JMP L431)
252   L252
252   (GETVALUE 0)                        ; X
254   (CDR)
255   (CAR)
256   (CDR&PUSH)
257   (CALL1&PUSH 25)                     ; MAXI
259   (CONST&PUSH 26)                     ; (%LOG)
260   (LOAD&CAR&PUSH 1)
262   (LIST&PUSH 2)
264   (JSR&PUSH L0)
267   (CONST&PUSH 27)                     ; (%LOG)
268   (GETVALUE 0)                        ; X
270   (CDR)
271   (CAR&PUSH)
272   (LOAD&CAR&PUSH 3)
274   (CALL2&PUSH 28)                     ; DIV*
276   (LIST&PUSH 2)
278   (CALL2 29)                          ; ADD*
280   (SKIP 1)
282   (JMP L431)
285   L285
285   (GETVALUE&PUSH 0)                   ; X
287   (CALL1&JMPIF 12 L186)               ; MTIMESP
291   (GETVALUE&PUSH 0)                   ; X
293   (CALL1&JMPIF 23 L225)               ; MEXPTP
297   (GETVALUE&PUSH 0)                   ; X
299   (CALL1&JMPIFNOT 6 L429)             ; MLOGP
303   (GETVALUE 0)                        ; X
305   (CDR)
306   (CAR&PUSH)
307   (GETVALUE&PUSH 1)                   ; VAR
309   (GETVALUE&PUSH 7)                   ; VAL
311   (CONST&PUSH 8)                      ; THINK
312   (CALL&PUSH 4 9)                     ; LIMIT
315   (GETVALUE&PUSH 10)                  ; INFINITIES
317   (CALL2&JMPIFNOT 11 L242)            ; MEMQ
321   (GETVALUE 0)                        ; X
323   (CDR)
324   (CAR&PUSH)
325   (GETVALUE 1)                        ; VAR
327   (JMPIFEQ L247)
330   (GETVALUE 0)                        ; X
332   (CDR)
333   (CAR&PUSH)
334   (CALL1&JMPIF 3 L252)                ; MPLUSP
338   (GETVALUE 0)                        ; X
340   (CDR)
341   (CAR&PUSH)
342   (CALL1&JMPIFNOT 12 L402)            ; MTIMESP
345   (GETVALUE 0)                        ; X
347   (CDR)
348   (CAR)
349   (CDR)
350   (BIND 4)                            ; L
352   (CONST 30)                          ; 0
354   (BIND 20)                           ; ANS
356   (GETVALUE 4)                        ; L
358   (JMPIFNOT L390)
360   L360
360   (CONST&PUSH 31)                     ; (%LOG)
362   (GETVALUE 4)                        ; L
364   (CAR&PUSH)
365   (JSR&PUSH L0)
368   (LIST&PUSH 2)
370   (CALL1&PUSH 32)                     ; SIMPLIFY
372   (JSR&PUSH L0)
375   (GETVALUE&PUSH 20)                  ; ANS
377   (CALL2 29)                          ; ADD*
379   (SETVALUE 20)                       ; ANS
381   (GETVALUE 4)                        ; L
383   (CDR)
384   (SETVALUE 4)                        ; L
386   (GETVALUE 4)                        ; L
388   (JMPIF L360)
390   L390
390   (GETVALUE 20)                       ; ANS
392   (UNBIND 2)
394   (JMP L431)
396   L396
396   (GETVALUE 0)                        ; X
398   (SKIP 1)
400   (JMP L431)
402   L402
402   (CONST&PUSH 33)                     ; (%LOG)
404   (GETVALUE 0)                        ; X
406   (CDR)
407   (CAR&PUSH)
408   (JSR&PUSH L0)
411   (LIST&PUSH 2)
413   (CALL1&PUSH 32)                     ; SIMPLIFY
415   (LOAD&PUSH 0)
416   (GETVALUE&PUSH 0)                   ; X
418   (CALL2&JMPIF 34 L396)               ; ALIKE1
421   (LOAD&PUSH 0)
422   (JSR L0)
425   (SKIP 1)
427   (JMP L431)
429   L429
429   (GETVALUE 0)                        ; X
431   L431
431   (UNBIND1)
432   (SKIP&RET 2)


Disassembly of function #:|(DEFUN RATLIM (E) ...)-78|
(CONST 0) = RATLIM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATLIM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATLIM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATLIM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATLIM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATLIM
8     (SKIP&RET 1)


Disassembly of function RATLIM
(CONST 0) = E
(CONST 1) = VAL
(CONST 2) = ($INF $INFINITY)
(CONST 3) = MEMQ
(CONST 4) = X
(CONST 5) = -1
(CONST 6) = POWER
(CONST 7) = VAR
(CONST 8) = MAXIMA-SUBSTITUTE
(CONST 9) = $MINF
(CONST 10) = $ZEROB
(CONST 11) = MUL*
(CONST 12) = $ZEROA
(CONST 13) = ADD
(CONST 14) = $RATFAC
(CONST 15) = SRATSIMP
(CONST 16) = $RAT
(CONST 17) = N
(CONST 18) = D
(CONST 19) = GENFIND
(CONST 20) = LODEG
(CONST 21) = LOCOEF
(CONST 22) = 1
(CONST 23) = $RATDISREP
(CONST 24) = DIV*
(CONST 25) = ($ZEROB $ZEROA $INF $MINF)
(CONST 26) = 0
(CONST 27) = $IMAGPART
(CONST 28) = $REALPART
(CONST 29) = GETSIGNL
(CONST 30) = ($ZEROB $ZEROA $INFINITY $INF $MINF)
(CONST 31) = LIMIT
(CONST 32) = $INFINITY
(CONST 33) = $INF
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N D VAR E VAL)
writes special variables : (N D E)
182 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAL
5     (CONST&PUSH 2)                      ; ($INF $INFINITY)
6     (CALL2&JMPIF 3 L26)                 ; MEMQ
9     (GETVALUE&PUSH 1)                   ; VAL
11    (JMPIFNOTEQTO 9 L135)               ; $MINF
15    (CONST&PUSH 5)                      ; -1
16    (CONST&PUSH 4)                      ; X
17    (CONST&PUSH 5)                      ; -1
18    (CALL2 6)                           ; POWER
20    L20
20    (PUSH)
21    (CALL2 6)                           ; POWER
23    (JMP L152)
26    L26
26    (CONST&PUSH 4)                      ; X
27    (CONST 5)                           ; -1
28    (JMP L20)
30    L30
30    (CONST&PUSH 5)                      ; -1
31    (CONST&PUSH 4)                      ; X
32    (CALL2 11)                          ; MUL*
34    (JMP L152)
37    L37
37    (CONST 4)                           ; X
38    (JMP L152)
41    L41
41    (CONST 26)                          ; 0
43    (JMP L313)
46    L46
46    (CONST 26)                          ; 0
48    (JMP L313)
51    L51
51    (CONST 26)                          ; 0
53    (JMP L313)
56    L56
56    (CONST 12)                          ; $ZEROA
57    (JMP L313)
60    L60
60    (CONST 10)                          ; $ZEROB
61    (JMP L313)
64    L64
64    (GETVALUE&PUSH 1)                   ; VAL
66    (CONST&PUSH 25)                     ; ($ZEROB $ZEROA $INF $MINF)
67    (CALL2&JMPIFNOT 3 L41)              ; MEMQ
70    (GETVALUE&PUSH 0)                   ; E
72    (CALL1&PUSH 27)                     ; $IMAGPART
74    (JMPIFNOTEQTO 26 L46)               ; 0
77    (GETVALUE&PUSH 0)                   ; E
79    (CALL1&PUSH 28)                     ; $REALPART
81    (CALL1 29)                          ; GETSIGNL
83    (SETVALUE 0)                        ; E
85    (JMPIFNOT L51)
87    (GETVALUE&PUSH 0)                   ; E
89    (JMPIFEQTO 22 L56)                  ; 1
92    (GETVALUE&PUSH 0)                   ; E
94    (JMPIFEQTO 5 L60)                   ; -1
97    (CONST 26)                          ; 0
99    (JMP L313)
102   L102
102   (GETVALUE 0)                        ; E
104   (JMP L313)
107   L107
107   (CONST&PUSH 31)                     ; LIMIT
109   (T)
110   (THROW)
111   L111
111   (CONST 32)                          ; $INFINITY
113   (JMP L313)
116   L116
116   (CONST 32)                          ; $INFINITY
118   (JMP L313)
121   L121
121   (CONST 32)                          ; $INFINITY
123   (JMP L313)
126   L126
126   (CONST 33)                          ; $INF
128   (JMP L313)
131   L131
131   (CONST 9)                           ; $MINF
132   (JMP L313)
135   L135
135   (GETVALUE&PUSH 1)                   ; VAL
137   (JMPIFEQTO 10 L30)                  ; $ZEROB
141   (GETVALUE&PUSH 1)                   ; VAL
143   (JMPIFEQTO 12 L37)                  ; $ZEROA
147   (CONST&PUSH 4)                      ; X
148   (GETVALUE&PUSH 1)                   ; VAL
150   (CALL2 13)                          ; ADD
152   L152
152   (PUSH)
153   (GETVALUE&PUSH 7)                   ; VAR
155   (GETVALUE&PUSH 0)                   ; E
157   (CALL 3 8)                          ; MAXIMA-SUBSTITUTE
160   (SETVALUE 0)                        ; E
162   (NIL)
163   (BIND 14)                           ; $RATFAC
165   (GETVALUE&PUSH 0)                   ; E
167   (CALL1&PUSH 15)                     ; SRATSIMP
169   (CONST&PUSH 4)                      ; X
170   (CALL2 16)                          ; $RAT
172   (UNBIND1)
173   (BIND 0)                            ; E
175   (NIL&PUSH)
176   (NIL)
177   (BIND 17)                           ; N
179   (GETVALUE 0)                        ; E
181   (BIND 18)                           ; D
183   (GETVALUE 18)                       ; D
185   (CAR)
186   (STORE 6)
187   (GETVALUE 18)                       ; D
189   (CDR)
190   (SETVALUE 18)                       ; D
192   (CAR)
193   (SETVALUE 17)                       ; N
195   (GETVALUE 18)                       ; D
197   (CDR)
198   (SETVALUE 18)                       ; D
200   (LOAD&PUSH 6)
201   (CONST&PUSH 4)                      ; X
202   (CALL2&PUSH 19)                     ; GENFIND
204   (GETVALUE&PUSH 17)                  ; N
206   (LOAD&PUSH 1)
207   (CALL2&PUSH 20)                     ; LODEG
209   (GETVALUE&PUSH 18)                  ; D
211   (LOAD&PUSH 2)
212   (CALL2&PUSH 20)                     ; LODEG
214   (GETVALUE&PUSH 7)                   ; VAR
216   (CONST&PUSH 4)                      ; X
217   (LOAD&PUSH 11)
218   (GETVALUE&PUSH 17)                  ; N
220   (LOAD&PUSH 6)
221   (CALL2&PUSH 21)                     ; LOCOEF
223   (CONST 22)                          ; 1
225   (LIST*&PUSH 2)
227   (CALL1&PUSH 23)                     ; $RATDISREP
229   (LOAD&PUSH 12)
230   (GETVALUE&PUSH 18)                  ; D
232   (LOAD&PUSH 7)
233   (CALL2&PUSH 21)                     ; LOCOEF
235   (CONST 22)                          ; 1
237   (LIST*&PUSH 2)
239   (CALL1&PUSH 23)                     ; $RATDISREP
241   (CALL2&PUSH 24)                     ; DIV*
243   (CALL1&PUSH 15)                     ; SRATSIMP
245   (PUSH-UNBOUND 3)
247   (CALLS1 172)                        ; SUBST
249   (SETVALUE 0)                        ; E
251   (JMPIFNOT L260)
253   (LOAD&PUSH 1)
254   (LOAD&PUSH 1)
255   (CALLSR&JMPIF 1 48 L64)             ; >
260   L260
260   (LOAD&PUSH 1)
261   (LOAD&PUSH 1)
262   (CALLS2&JMPIF 2 L102)               ; EQUAL
266   (GETVALUE&PUSH 1)                   ; VAL
268   (CONST&PUSH 30)                     ; ($ZEROB $ZEROA $INFINITY $INF ...)
270   (CALL2&JMPIFNOT 3 L107)             ; MEMQ
274   (GETVALUE&PUSH 1)                   ; VAL
276   (JMPIFEQTO 32 L111)                 ; $INFINITY
280   (GETVALUE&PUSH 0)                   ; E
282   (CALL1&PUSH 27)                     ; $IMAGPART
284   (JMPIFNOTEQTO 26 L116)              ; 0
288   (GETVALUE&PUSH 0)                   ; E
290   (CALL1&PUSH 28)                     ; $REALPART
292   (CALL1 29)                          ; GETSIGNL
294   (SETVALUE 0)                        ; E
296   (JMPIFNOT L121)
299   (GETVALUE&PUSH 0)                   ; E
301   (JMPIFEQTO 22 L126)                 ; 1
305   (GETVALUE&PUSH 0)                   ; E
307   (JMPIFEQTO 5 L131)                  ; -1
311   (CONST 26)                          ; 0
313   L313
313   (SKIP 3)
315   (UNBIND 2)
317   (SKIP 1)
319   (UNBIND 2)
321   (SKIP&RET 2)


Disassembly of function #:|(DEFUN LODEG (N X) ...)-79|
(CONST 0) = LODEG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LODEG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LODEG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LODEG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LODEG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LODEG
8     (SKIP&RET 1)


Disassembly of function LODEG
(CONST 0) = N
(CONST 1) = X
(CONST 2) = 0
(CONST 3) = LOWDEG
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (X N)
19 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; X
6     (GETVALUE 0)                        ; N
8     (JMPIFATOM L26)
10    (GETVALUE 0)                        ; N
12    (CAR&PUSH)
13    (GETVALUE 1)                        ; X
15    (JMPIFNOTEQ L26)
17    (GETVALUE 0)                        ; N
19    (CDR&PUSH)
20    (CALL1 3)                           ; LOWDEG
22    L22
22    (UNBIND 2)
24    (SKIP&RET 3)
26    L26
26    (CONST 2)                           ; 0
27    (JMP L22)


Disassembly of function #:|(DEFUN LOCOEF (N X) ...)-80|
(CONST 0) = LOCOEF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOCOEF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOCOEF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOCOEF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOCOEF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOCOEF
8     (SKIP&RET 1)


Disassembly of function LOCOEF
(CONST 0) = N
(CONST 1) = X
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (X N)
20 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; X
6     (GETVALUE 0)                        ; N
8     (JMPIFATOM L28)
10    (GETVALUE 0)                        ; N
12    (CAR&PUSH)
13    (GETVALUE 1)                        ; X
15    (JMPIFNOTEQ L28)
17    (GETVALUE&PUSH 0)                   ; N
19    (PUSH-UNBOUND 1)
21    (CALLS1 156)                        ; LAST
23    (CAR)
24    L24
24    (UNBIND 2)
26    (SKIP&RET 3)
28    L28
28    (GETVALUE 0)                        ; N
30    (JMP L24)


Disassembly of function #:|(DEFUN BEHAVIOR (EXP VAR VAL) ...)-81|
(CONST 0) = BEHAVIOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BEHAVIOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BEHAVIOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BEHAVIOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BEHAVIOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BEHAVIOR
8     (SKIP&RET 1)


Disassembly of function BEHAVIOR
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = BEHAVIOR-COUNT-NOW
(CONST 4) = BEHAVIOR-COUNT
(CONST 5) = 0
(CONST 6) = SIGN
(CONST 7) = REAL-INFINITIES
(CONST 8) = MEMQ
(CONST 9) = $INF
(CONST 10) = $ZEROA
(CONST 11) = $MINF
(CONST 12) = $ZEROB
(CONST 13) = -1
(CONST 14) = POWER*
(CONST 15) = SUBIN
(CONST 16) = SRATSIMP
(CONST 17) = $INFINITY
(CONST 18) = MTIMESP
(CONST 19) = 1
(CONST 20) = PARTITION
(CONST 21) = GETSIGNL
(CONST 22) = FIXNUMP
(CONST 23) = RIDOFAB
(CONST 24) = NO-ERR-SUB
(CONST 25) = MEXPTP
(CONST 26) = FREE
(CONST 27) = BAS
(CONST 28) = BEHAVIOR-EXPT
(CONST 29) = BEHAVIOR-BY-DIFF
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (BAS SIGN EXP VAR REAL-INFINITIES VAL BEHAVIOR-COUNT BEHAVIOR-COUNT-NOW)
writes special variables : (SIGN EXP VAL)
121 byte-code instructions:
0     L0
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 3)                   ; BEHAVIOR-COUNT-NOW
11    (GETVALUE&PUSH 4)                   ; BEHAVIOR-COUNT
13    (CALLSR&JMPIF 1 45 L141)            ; =
18    (GETVALUE&PUSH 3)                   ; BEHAVIOR-COUNT-NOW
20    (CALLS2 150)                        ; 1+
22    (BIND 3)                            ; BEHAVIOR-COUNT-NOW
24    (NIL&PUSH)
25    (NIL)
26    (BIND 6)                            ; SIGN
28    (GETVALUE&PUSH 2)                   ; VAL
30    (GETVALUE&PUSH 7)                   ; REAL-INFINITIES
32    (CALL2&JMPIFNOT 8 L63)              ; MEMQ
35    (GETVALUE&PUSH 2)                   ; VAL
37    (JMPIFEQTO 9 L144)                  ; $INF
41    (GETVALUE&PUSH 2)                   ; VAL
43    (JMPIFEQTO 11 L148)                 ; $MINF
47    (NIL)
48    L48
48    (SETVALUE 2)                        ; VAL
50    (GETVALUE&PUSH 1)                   ; VAR
52    (CONST&PUSH 13)                     ; -1
53    (CALL2&PUSH 14)                     ; POWER*
55    (GETVALUE&PUSH 0)                   ; EXP
57    (CALL2&PUSH 15)                     ; SUBIN
59    (CALL1 16)                          ; SRATSIMP
61    (SETVALUE 0)                        ; EXP
63    L63
63    (GETVALUE&PUSH 2)                   ; VAL
65    (JMPIFEQTO 17 L152)                 ; $INFINITY
69    (GETVALUE&PUSH 0)                   ; EXP
71    (CALL1&JMPIFNOT 18 L88)             ; MTIMESP
74    (GETVALUE&PUSH 0)                   ; EXP
76    (GETVALUE&PUSH 1)                   ; VAR
78    (CONST&PUSH 19)                     ; 1
79    (CALL 3 20)                         ; PARTITION
82    (STORE 3)
83    (CDR&PUSH)
84    (CALL1&JMPIFNOT 18 L158)            ; MTIMESP
88    L88
88    (GETVALUE&PUSH 2)                   ; VAL
90    (CALL1&PUSH 23)                     ; RIDOFAB
92    (GETVALUE&PUSH 0)                   ; EXP
94    (CALL2&PUSH 24)                     ; NO-ERR-SUB
96    (JMPIFNOTEQTO 5 L124)               ; 0
99    (GETVALUE&PUSH 0)                   ; EXP
101   (CALL1&JMPIFNOT 25 L124)            ; MEXPTP
104   (GETVALUE 0)                        ; EXP
106   (CDR)
107   (CDR)
108   (CAR&PUSH)
109   (GETVALUE&PUSH 1)                   ; VAR
111   (CALL2&JMPIFNOT 26 L124)            ; FREE
114   (GETVALUE 0)                        ; EXP
116   (CDR)
117   (CDR)
118   (CAR&PUSH)
119   (CALL1&PUSH 21)                     ; GETSIGNL
121   (JMPIFEQTO 19 L184)                 ; 1
124   L124
124   (GETVALUE&PUSH 0)                   ; EXP
126   (GETVALUE&PUSH 1)                   ; VAR
128   (GETVALUE&PUSH 2)                   ; VAL
130   (CALL 3 29)                         ; BEHAVIOR-BY-DIFF
133   L133
133   (UNBIND1)
134   (SKIP 1)
136   (UNBIND1)
137   L137
137   (UNBIND 3)
139   (SKIP&RET 4)
141   L141
141   (CONST 5)                           ; 0
142   (JMP L137)
144   L144
144   (CONST 10)                          ; $ZEROA
145   (JMP L48)
148   L148
148   (CONST 12)                          ; $ZEROB
149   (JMP L48)
152   L152
152   (CONST 5)                           ; 0
153   (JMP L133)
155   L155
155   (CONST 5)                           ; 0
156   (JMP L133)
158   L158
158   (LOAD&CAR&PUSH 3)
160   (CALL1 21)                          ; GETSIGNL
162   (SETVALUE 6)                        ; SIGN
164   (PUSH)
165   (CALL1&JMPIFNOT 22 L155)            ; FIXNUMP
168   (GETVALUE&PUSH 6)                   ; SIGN
170   (LOAD&CDR&PUSH 4)
172   (GETVALUE&PUSH 1)                   ; VAR
174   (GETVALUE&PUSH 2)                   ; VAL
176   (JSR&PUSH L0)
179   (CALLSR 2 55)                       ; *
182   (JMP L133)
184   L184
184   (GETVALUE 0)                        ; EXP
186   (CDR)
187   (CAR&PUSH)
188   (GETVALUE 0)                        ; EXP
190   (CDR)
191   (CDR)
192   (CAR&PUSH)
193   (LOAD 1)
194   (BIND 27)                           ; BAS
196   (GETVALUE&PUSH 27)                  ; BAS
198   (LOAD&PUSH 4)
199   (CALL2 28)                          ; BEHAVIOR-EXPT
201   (UNBIND1)
202   (SKIP 2)
204   (JMP L133)


Disassembly of function #:|(DEFUN BEHAVIOR-EXPT (BAS EXPO) ...)-82|
(CONST 0) = BEHAVIOR-EXPT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BEHAVIOR-EXPT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BEHAVIOR-EXPT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BEHAVIOR-EXPT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BEHAVIOR-EXPT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BEHAVIOR-EXPT
8     (SKIP&RET 1)


Disassembly of function BEHAVIOR-EXPT
(CONST 0) = BAS
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = BEHAVIOR
(CONST 4) = 1
(CONST 5) = 0
(CONST 6) = $INTEGER
(CONST 7) = ASK-INTEGER
(CONST 8) = $YES
(CONST 9) = $EVEN
(CONST 10) = RATNUMP
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR BAS)
62 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; BAS
3     (GETVALUE&PUSH 0)                   ; BAS
5     (GETVALUE&PUSH 1)                   ; VAR
7     (GETVALUE&PUSH 2)                   ; VAL
9     (CALL&PUSH 3 3)                     ; BEHAVIOR
12    (LOAD&PUSH 0)
13    (CONST&PUSH 4)                      ; 1
14    (CALLSR&JMPIF 1 45 L41)             ; =
18    (LOAD&PUSH 0)
19    (CONST&PUSH 5)                      ; 0
20    (CALLSR&JMPIF 1 45 L46)             ; =
24    (LOAD&PUSH 5)
25    (CONST&PUSH 6)                      ; $INTEGER
26    (CALL2&PUSH 7)                      ; ASK-INTEGER
28    (JMPIFEQTO 8 L56)                   ; $YES
31    (LOAD&PUSH 5)
32    (CALL1&JMPIF 10 L74)                ; RATNUMP
35    (CONST 5)                           ; 0
36    (SKIP 1)
38    L38
38    (UNBIND1)
39    (SKIP&RET 3)
41    L41
41    (CONST 4)                           ; 1
42    (SKIP 1)
44    (JMP L38)
46    L46
46    (CONST 5)                           ; 0
47    (SKIP 1)
49    (JMP L38)
51    L51
51    (CONST 4)                           ; 1
52    (SKIP 1)
54    (JMP L38)
56    L56
56    (LOAD&PUSH 5)
57    (CONST&PUSH 9)                      ; $EVEN
58    (CALL2&PUSH 7)                      ; ASK-INTEGER
60    (JMPIFEQTO 8 L51)                   ; $YES
63    (POP)
64    (JMP L38)
66    L66
66    (CONST 4)                           ; 1
67    (SKIP 1)
69    (JMP L38)
71    L71
71    (POP)
72    (JMP L38)
74    L74
74    (LOAD 5)
75    (CDR)
76    (CAR&PUSH)
77    (CALLS2&JMPIF 149 L66)              ; EVENP
80    (LOAD 5)
81    (CDR)
82    (CDR)
83    (CAR&PUSH)
84    (CALLS2&JMPIF 148 L71)              ; ODDP
87    (CONST 5)                           ; 0
88    (SKIP 1)
90    (JMP L38)


Disassembly of function #:|(DEFUN BEHAVIOR-BY-DIFF (EXP VAR VAL) ...)-83|
(CONST 0) = BEHAVIOR-BY-DIFF
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BEHAVIOR-BY-DIFF>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BEHAVIOR-BY-DIFF
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BEHAVIOR-BY-DIFF
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BEHAVIOR-BY-DIFF>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BEHAVIOR-BY-DIFF
8     (SKIP&RET 1)


Disassembly of function BEHAVIOR-BY-DIFF
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = $ZEROA
(CONST 4) = $ZEROB
(CONST 5) = 0
(CONST 6) = RIDOFAB
(CONST 7) = SDIFF
(CONST 8) = SRATSIMP
(CONST 9) = N
(CONST 10) = ANS
(CONST 11) = 4
(CONST 12) = NO-ERR-SUB
(CONST 13) = BEHAVIOR-NUMDEN
(CONST 14) = GETSIGNL
(CONST 15) = 1
(CONST 16) = -1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (N ANS VAR EXP VAL)
writes special variables : (N EXP ANS VAL)
98 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 2)                   ; VAL
11    (JMPIFEQTO 3 L19)                   ; $ZEROA
14    (GETVALUE&PUSH 2)                   ; VAL
16    (JMPIFNOTEQTO 4 L49)                ; $ZEROB
19    L19
19    (GETVALUE&PUSH 2)                   ; VAL
21    (GETVALUE&PUSH 0)                   ; EXP
23    (GETVALUE&PUSH 2)                   ; VAL
25    (CALL1 6)                           ; RIDOFAB
27    (SETVALUE 2)                        ; VAL
29    (CONST&PUSH 5)                      ; 0
30    (GETVALUE&PUSH 0)                   ; EXP
32    (GETVALUE&PUSH 1)                   ; VAR
34    (CALL2&PUSH 7)                      ; SDIFF
36    (CALL1 8)                           ; SRATSIMP
38    (BIND 0)                            ; EXP
40    (NIL)
41    (BIND 9)                            ; N
43    (NIL)
44    (BIND 10)                           ; ANS
46    (JMP L152)
49    L49
49    (CONST 5)                           ; 0
50    (JMP L163)
53    L53
53    (LOAD&PUSH 10)
54    (GETVALUE&PUSH 1)                   ; VAR
56    (LOAD&PUSH 13)
57    (CALL 3 13)                         ; BEHAVIOR-NUMDEN
60    (JMP L159)
63    L63
63    (GETVALUE 10)                       ; ANS
65    (JMP L159)
68    L68
68    (CONST 15)                          ; 1
69    (JMP L159)
72    L72
72    (LOAD&PUSH 11)
73    (JMPIFEQTO 3 L68)                   ; $ZEROA
76    (CONST 16)                          ; -1
77    (JMP L159)
80    L80
80    (CONST 16)                          ; -1
81    (JMP L159)
84    L84
84    (LOAD&PUSH 11)
85    (JMPIFEQTO 3 L80)                   ; $ZEROA
88    (CONST 15)                          ; 1
89    (JMP L159)
92    L92
92    (GETVALUE&PUSH 10)                  ; ANS
94    (CALL1 14)                          ; GETSIGNL
96    (SETVALUE 10)                       ; ANS
98    (GETVALUE 9)                        ; N
100   (JMPIF L63)
102   (GETVALUE&PUSH 10)                  ; ANS
104   (JMPIFEQTO 15 L72)                  ; 1
107   (GETVALUE&PUSH 10)                  ; ANS
109   (JMPIFEQTO 16 L84)                  ; -1
112   (CONST 5)                           ; 0
113   (JMP L159)
115   L115
115   (GETVALUE&PUSH 2)                   ; VAL
117   (GETVALUE&PUSH 0)                   ; EXP
119   (CALL2 12)                          ; NO-ERR-SUB
121   (SETVALUE 10)                       ; ANS
123   (PUSH)
124   (T)
125   (JMPIFEQ L53)
128   (GETVALUE&PUSH 10)                  ; ANS
130   (JMPIFNOTEQTO 5 L92)                ; 0
133   (LOAD&INC&PUSH 9)
135   (GETVALUE&PUSH 0)                   ; EXP
137   (GETVALUE&PUSH 1)                   ; VAR
139   (CALL2&PUSH 7)                      ; SDIFF
141   (CALL1 8)                           ; SRATSIMP
143   (SETVALUE 0)                        ; EXP
145   (GETVALUE 9)                        ; N
147   (NOT)
148   (SETVALUE 9)                        ; N
150   (POP&STORE 9)
152   L152
152   (LOAD&PUSH 9)
153   (CONST&PUSH 11)                     ; 4
154   (CALLSR&JMPIFNOT 1 48 L115)         ; >
158   (CONST 5)                           ; 0
159   L159
159   (UNBIND 3)
161   (SKIP 3)
163   L163
163   (UNBIND 3)
165   (SKIP&RET 4)


Disassembly of function #:|(DEFUN BEHAVIOR-NUMDEN (EXP VAR VAL) ...)-84|
(CONST 0) = BEHAVIOR-NUMDEN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BEHAVIOR-NUMDEN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BEHAVIOR-NUMDEN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BEHAVIOR-NUMDEN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BEHAVIOR-NUMDEN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BEHAVIOR-NUMDEN
8     (SKIP&RET 1)


Disassembly of function BEHAVIOR-NUMDEN
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = $NUM
(CONST 4) = $DENOM
(CONST 5) = DENOM
(CONST 6) = NUM
(CONST 7) = 1
(CONST 8) = 0
(CONST 9) = BEHAVIOR
(CONST 10) = -1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR NUM DENOM EXP)
50 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CALL1&PUSH 3)                      ; $NUM
13    (GETVALUE&PUSH 0)                   ; EXP
15    (CALL1 4)                           ; $DENOM
17    (BIND 5)                            ; DENOM
19    (LOAD 3)
20    (BIND 6)                            ; NUM
22    (GETVALUE&PUSH 5)                   ; DENOM
24    (JMPIFEQTO 7 L74)                   ; 1
27    (GETVALUE&PUSH 6)                   ; NUM
29    (GETVALUE&PUSH 1)                   ; VAR
31    (GETVALUE&PUSH 2)                   ; VAL
33    (CALL&PUSH 3 9)                     ; BEHAVIOR
36    (GETVALUE&PUSH 5)                   ; DENOM
38    (GETVALUE&PUSH 1)                   ; VAR
40    (GETVALUE&PUSH 2)                   ; VAL
42    (CALL&PUSH 3 9)                     ; BEHAVIOR
45    (LOAD&PUSH 1)
46    (CONST&PUSH 8)                      ; 0
47    (CALLSR&JMPIF 1 45 L77)             ; =
51    (LOAD&PUSH 0)
52    (CONST&PUSH 8)                      ; 0
53    (CALLSR&JMPIF 1 45 L77)             ; =
57    (LOAD&PUSH 1)
58    (LOAD&PUSH 1)
59    (CALLSR&JMPIF 1 45 L82)             ; =
63    (CONST 10)                          ; -1
64    (SKIP 2)
66    L66
66    (UNBIND 2)
68    (SKIP 1)
70    (UNBIND 3)
72    (SKIP&RET 4)
74    L74
74    (CONST 8)                           ; 0
75    (JMP L66)
77    L77
77    (CONST 8)                           ; 0
78    (SKIP 2)
80    (JMP L66)
82    L82
82    (CONST 7)                           ; 1
83    (SKIP 2)
85    (JMP L66)


Disassembly of function #:|(DEFUN TRY-LHOSPITAL (N D IND) ...)-85|
(CONST 0) = TRY-LHOSPITAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRY-LHOSPITAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRY-LHOSPITAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRY-LHOSPITAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRY-LHOSPITAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRY-LHOSPITAL
8     (SKIP&RET 1)


Disassembly of function TRY-LHOSPITAL
(CONST 0) = N
(CONST 1) = D
(CONST 2) = IND
(CONST 3) = LHOSPITAL-CATCH
(CONST 4) = ANS
(CONST 5) = INFINITIES
(CONST 6) = FREE
(CONST 7) = SIMPINF
(CONST 8) = INFINITESIMALS
(CONST 9) = SIMPAB
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITESIMALS INFINITIES ANS IND D N)
54 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; IND
9     (GETVALUE&PUSH 0)                   ; N
11    (GETVALUE&PUSH 1)                   ; D
13    (GETVALUE&PUSH 2)                   ; IND
15    (CALL 3 3)                          ; LHOSPITAL-CATCH
18    (BIND 4)                            ; ANS
20    (GETVALUE 4)                        ; ANS
22    (JMPIFNOT L69)
24    (GETVALUE&PUSH 5)                   ; INFINITIES
26    (LOAD&JMPIFNOT 0 L41)
29    L29
29    (LOAD&CAR&PUSH 0)
31    (GETVALUE&PUSH 4)                   ; ANS
33    (CALL2&JMPIFNOT 6 L73)              ; FREE
36    (LOAD&CDR&STORE 0)
38    (LOAD&JMPIF 0 L29)
41    L41
41    (SKIP 1)
43    (GETVALUE&PUSH 8)                   ; INFINITESIMALS
45    (LOAD&JMPIFNOT 0 L60)
48    L48
48    (LOAD&CAR&PUSH 0)
50    (GETVALUE&PUSH 4)                   ; ANS
52    (CALL2&JMPIFNOT 6 L82)              ; FREE
55    (LOAD&CDR&STORE 0)
57    (LOAD&JMPIF 0 L48)
60    L60
60    (SKIP 1)
62    (GETVALUE 4)                        ; ANS
64    (UNBIND1)
65    L65
65    (UNBIND 3)
67    (SKIP&RET 4)
69    L69
69    (NIL)
70    (UNBIND1)
71    (JMP L65)
73    L73
73    (SKIP 1)
75    (GETVALUE&PUSH 4)                   ; ANS
77    (CALL1 7)                           ; SIMPINF
79    (UNBIND1)
80    (JMP L65)
82    L82
82    (SKIP 1)
84    (GETVALUE&PUSH 4)                   ; ANS
86    (CALL1 9)                           ; SIMPAB
88    (UNBIND1)
89    (JMP L65)


Disassembly of function #:|(DEFUN TRY-LHOSPITAL-QUIT (N D IND) ...)-86|
(CONST 0) = TRY-LHOSPITAL-QUIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRY-LHOSPITAL-QUIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRY-LHOSPITAL-QUIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRY-LHOSPITAL-QUIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRY-LHOSPITAL-QUIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRY-LHOSPITAL-QUIT
8     (SKIP&RET 1)


Disassembly of function TRY-LHOSPITAL-QUIT
(CONST 0) = N
(CONST 1) = D
(CONST 2) = IND
(CONST 3) = LHOSPITAL-CATCH
(CONST 4) = ANS
(CONST 5) = LIMIT
(CONST 6) = INFINITIES
(CONST 7) = FREE
(CONST 8) = SIMPINF
(CONST 9) = INFINITESIMALS
(CONST 10) = SIMPAB
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITESIMALS INFINITIES ANS IND D N)
54 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; IND
9     (GETVALUE&PUSH 0)                   ; N
11    (GETVALUE&PUSH 1)                   ; D
13    (GETVALUE&PUSH 2)                   ; IND
15    (CALL 3 3)                          ; LHOSPITAL-CATCH
18    (BIND 4)                            ; ANS
20    (GETVALUE 4)                        ; ANS
22    (JMPIFNOT L69)
24    (GETVALUE&PUSH 6)                   ; INFINITIES
26    (LOAD&JMPIFNOT 0 L41)
29    L29
29    (LOAD&CAR&PUSH 0)
31    (GETVALUE&PUSH 4)                   ; ANS
33    (CALL2&JMPIFNOT 7 L72)              ; FREE
36    (LOAD&CDR&STORE 0)
38    (LOAD&JMPIF 0 L29)
41    L41
41    (SKIP 1)
43    (GETVALUE&PUSH 9)                   ; INFINITESIMALS
45    (LOAD&JMPIFNOT 0 L60)
48    L48
48    (LOAD&CAR&PUSH 0)
50    (GETVALUE&PUSH 4)                   ; ANS
52    (CALL2&JMPIFNOT 7 L81)              ; FREE
55    (LOAD&CDR&STORE 0)
57    (LOAD&JMPIF 0 L48)
60    L60
60    (SKIP 1)
62    (GETVALUE 4)                        ; ANS
64    (UNBIND1)
65    L65
65    (UNBIND 3)
67    (SKIP&RET 4)
69    L69
69    (CONST&PUSH 5)                      ; LIMIT
70    (T)
71    (THROW)
72    L72
72    (SKIP 1)
74    (GETVALUE&PUSH 4)                   ; ANS
76    (CALL1 8)                           ; SIMPINF
78    (UNBIND1)
79    (JMP L65)
81    L81
81    (SKIP 1)
83    (GETVALUE&PUSH 4)                   ; ANS
85    (CALL1 10)                          ; SIMPAB
87    (UNBIND1)
88    (JMP L65)


Disassembly of function #:|(DEFUN LHOSPITAL-CATCH (N D IND) ...)-87|
(CONST 0) = LHOSPITAL-CATCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LHOSPITAL-CATCH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LHOSPITAL-CATCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LHOSPITAL-CATCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LHOSPITAL-CATCH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LHOSPITAL-CATCH
8     (SKIP&RET 1)


Disassembly of function LHOSPITAL-CATCH
(CONST 0) = N
(CONST 1) = D
(CONST 2) = IND
(CONST 3) = 0
(CONST 4) = LHCOUNT
(CONST 5) = $LHOSPITALLIM
(CONST 6) = LHOSPITAL
(CONST 7) = -1
(CONST 8) = ADD*
(CONST 9) = 1
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (IND D N $LHOSPITALLIM LHCOUNT)
writes special variable : (LHCOUNT)
51 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; IND
9     (CONST&PUSH 3)                      ; 0
10    (GETVALUE&PUSH 4)                   ; LHCOUNT
12    (CALLSR&JMPIF 1 48 L51)             ; >
16    (GETVALUE&PUSH 4)                   ; LHCOUNT
18    (GETVALUE&PUSH 5)                   ; $LHOSPITALLIM
20    (CALLS2&JMPIF 2 L58)                ; EQUAL
23    (GETVALUE&PUSH 4)                   ; LHCOUNT
25    (CONST&PUSH 7)                      ; -1
26    (CALL2 8)                           ; ADD*
28    (SETVALUE 4)                        ; LHCOUNT
30    (GETVALUE&PUSH 0)                   ; N
32    (GETVALUE&PUSH 1)                   ; D
34    (GETVALUE&PUSH 2)                   ; IND
36    (CALL&PUSH 3 6)                     ; LHOSPITAL
39    (GETVALUE&PUSH 4)                   ; LHCOUNT
41    (CONST&PUSH 9)                      ; 1
42    (CALL2 8)                           ; ADD*
44    (SETVALUE 4)                        ; LHCOUNT
46    (POP)
47    L47
47    (UNBIND 3)
49    (SKIP&RET 4)
51    L51
51    (GETVALUE 5)                        ; $LHOSPITALLIM
53    (SETVALUE 4)                        ; LHCOUNT
55    (CONST&PUSH 6)                      ; LHOSPITAL
56    (NIL)
57    (THROW)
58    L58
58    (GETVALUE&PUSH 4)                   ; LHCOUNT
60    (CONST&PUSH 7)                      ; -1
61    (CALL2 8)                           ; ADD*
63    (BIND 4)                            ; LHCOUNT
65    (CONST 6)                           ; LHOSPITAL
66    (CATCH-OPEN L81)
68    (GETVALUE&PUSH 0)                   ; N
70    (GETVALUE&PUSH 1)                   ; D
72    (GETVALUE&PUSH 2)                   ; IND
74    (CALL 3 6)                          ; LHOSPITAL
77    (CATCH-CLOSE)
78    (UNBIND1)
79    (JMP L47)
81    L81
81    (UNBIND1)
82    (JMP L47)


Disassembly of function #:|(DEFUN LHOSPITAL (N D IND) ...)-88|
(CONST 0) = LHOSPITAL
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LHOSPITAL>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LHOSPITAL
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LHOSPITAL
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LHOSPITAL>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LHOSPITAL
8     (SKIP&RET 1)


Disassembly of function LHOSPITAL
(CONST 0) = N
(CONST 1) = D
(CONST 2) = IND
(CONST 3) = MTIMESP
(CONST 4) = VAR
(CONST 5) = VAL
(CONST 6) = LHSIMP
(CONST 7) = MULN
(CONST 8) = LHOP-NUMDEN
(CONST 9) = LHP?
(CONST 10) = VAR-OR-CONST
(CONST 11) = SDIFF
(CONST 12) = %DERIVATIVE
(CONST 13) = FREE
(CONST 14) = LHOSPITAL
(CONST 15) = TANSC
(CONST 16) = EXPAND-TRIGS
(CONST 17) = REMOVE-SINGULARITIES
(CONST 18) = DIV*
(CONST 19) = MUL*
(CONST 20) = LIMIT2
(CONST 21) = ANS
(CONST 22) = MPLUSP
(CONST 23) = X
(CONST 24) = SRATSIMP
(CONST 25) = ADDN
(CONST 26) = $MULTTHRU
(CONST 27) = THINK
(CONST 28) = LIMIT
(CONST 29) = SIMPINF
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (IND X ANS D VAL VAR N)
writes special variables : (LHP? D N)
215 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; N
3     (LOAD 5)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; IND
9     (GETVALUE&PUSH 0)                   ; N
11    (CALL1&JMPIFNOT 3 L51)              ; MTIMESP
14    (NIL&PUSH)
15    (GETVALUE 0)                        ; N
17    (CDR&PUSH)
18    (JMP L36)
20    L20
20    (LOAD&CAR&PUSH 0)
22    (LOAD&PUSH 0)
23    (GETVALUE&PUSH 4)                   ; VAR
25    (GETVALUE&PUSH 5)                   ; VAL
27    (CALL&PUSH 3 6)                     ; LHSIMP
30    (LOAD&CONS&STORE 2)
32    (SKIP 1)
34    (LOAD&CDR&STORE 0)
36    L36
36    (LOAD&PUSH 0)
37    (CALLS1&JMPIFNOT 146 L20)           ; ENDP
40    (SKIP 1)
42    (LOAD&PUSH 0)
43    (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
46    (NIL&PUSH)
47    (CALL2 7)                           ; MULN
49    (SETVALUE 0)                        ; N
51    L51
51    (GETVALUE&PUSH 1)                   ; D
53    (CALL1&JMPIFNOT 3 L163)             ; MTIMESP
57    (NIL&PUSH)
58    (GETVALUE 1)                        ; D
60    (CDR&PUSH)
61    (JMP L148)
64    L64
64    (CONST&PUSH 14)                     ; LHOSPITAL
65    (NIL)
66    (THROW)
67    L67
67    (GETVALUE&PUSH 0)                   ; N
69    (GETVALUE&PUSH 1)                   ; D
71    (GETVALUE&PUSH 4)                   ; VAR
73    (GETVALUE&PUSH 5)                   ; VAL
75    (CALL 4 20)                         ; LIMIT2
78    (BIND 21)                           ; ANS
80    (GETVALUE 21)                       ; ANS
82    (JMPIF L342)
85    (UNBIND1)
86    (JMP L351)
89    L89
89    (NIL&PUSH)
90    (GETVALUE 0)                        ; N
92    (CDR&PUSH)
93    (JMP L116)
95    L95
95    (LOAD&CAR&PUSH 0)
97    (LOAD 0)
98    (BIND 23)                           ; X
100   (GETVALUE&PUSH 23)                  ; X
102   (GETVALUE&PUSH 1)                   ; D
104   (CALL2&PUSH 18)                     ; DIV*
106   (CALL1 24)                          ; SRATSIMP
108   (UNBIND1)
109   (PUSH)
110   (LOAD&CONS&STORE 2)
112   (SKIP 1)
114   (LOAD&CDR&STORE 0)
116   L116
116   (LOAD&PUSH 0)
117   (CALLS1&JMPIFNOT 146 L95)           ; ENDP
120   (SKIP 1)
122   (LOAD&PUSH 0)
123   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
126   (NIL&PUSH)
127   (CALL2 25)                          ; ADDN
129   (JMP L327)
132   L132
132   (LOAD&CAR&PUSH 0)
134   (LOAD&PUSH 0)
135   (GETVALUE&PUSH 4)                   ; VAR
137   (GETVALUE&PUSH 5)                   ; VAL
139   (CALL&PUSH 3 6)                     ; LHSIMP
142   (LOAD&CONS&STORE 2)
144   (SKIP 1)
146   (LOAD&CDR&STORE 0)
148   L148
148   (LOAD&PUSH 0)
149   (CALLS1&JMPIFNOT 146 L132)          ; ENDP
152   (SKIP 1)
154   (LOAD&PUSH 0)
155   (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
158   (NIL&PUSH)
159   (CALL2 7)                           ; MULN
161   (SETVALUE 1)                        ; D
163   L163
163   (NIL&PUSH)
164   (GETVALUE&PUSH 0)                   ; N
166   (GETVALUE&PUSH 1)                   ; D
168   (CALL2 8)                           ; LHOP-NUMDEN
170   (BIND 1)                            ; D
172   (PUSH-NIL 3)
174   (LOAD 6)
175   (BIND 0)                            ; N
177   (GETVALUE 1)                        ; D
179   (CAR)
180   (SETVALUE 0)                        ; N
182   (GETVALUE 1)                        ; D
184   (CDR)
185   (SETVALUE 1)                        ; D
187   (GETVALUE 2)                        ; IND
189   (NOT)
190   (JMPIFNOT L197)
192   (GETVALUE&PUSH 0)                   ; N
194   (GETVALUE 1)                        ; D
196   (CONS)
197   L197
197   (SETVALUE 9)                        ; LHP?
199   (GETVALUE&PUSH 0)                   ; N
201   (CALL1 10)                          ; VAR-OR-CONST
203   (SETVALUE 0)                        ; N
205   (CAR)
206   (STORE 4)
207   (GETVALUE 0)                        ; N
209   (CDR)
210   (SETVALUE 0)                        ; N
212   (GETVALUE&PUSH 1)                   ; D
214   (CALL1 10)                          ; VAR-OR-CONST
216   (SETVALUE 1)                        ; D
218   (CAR)
219   (STORE 3)
220   (GETVALUE 1)                        ; D
222   (CDR)
223   (SETVALUE 1)                        ; D
225   (GETVALUE&PUSH 0)                   ; N
227   (GETVALUE&PUSH 4)                   ; VAR
229   (CALL2 11)                          ; SDIFF
231   (SETVALUE 0)                        ; N
233   (GETVALUE&PUSH 1)                   ; D
235   (GETVALUE&PUSH 4)                   ; VAR
237   (CALL2 11)                          ; SDIFF
239   (SETVALUE 1)                        ; D
241   (GETVALUE&PUSH 0)                   ; N
243   (CONST&PUSH 12)                     ; %DERIVATIVE
244   (CALL2&JMPIFNOT 13 L64)             ; FREE
248   (GETVALUE&PUSH 1)                   ; D
250   (CONST&PUSH 12)                     ; %DERIVATIVE
251   (CALL2&JMPIFNOT 13 L64)             ; FREE
255   (GETVALUE&PUSH 0)                   ; N
257   (CALL1&PUSH 15)                     ; TANSC
259   (GETVALUE&PUSH 4)                   ; VAR
261   (CALL2 16)                          ; EXPAND-TRIGS
263   (SETVALUE 0)                        ; N
265   (GETVALUE&PUSH 1)                   ; D
267   (CALL1&PUSH 15)                     ; TANSC
269   (GETVALUE&PUSH 4)                   ; VAR
271   (CALL2 16)                          ; EXPAND-TRIGS
273   (SETVALUE 1)                        ; D
275   (GETVALUE&PUSH 0)                   ; N
277   (GETVALUE&PUSH 1)                   ; D
279   (CALL2 17)                          ; REMOVE-SINGULARITIES
281   (SETVALUE 1)                        ; D
283   (CAR)
284   (STORE 5)
285   (GETVALUE 1)                        ; D
287   (CDR)
288   (SETVALUE 1)                        ; D
290   (CAR)
291   (SETVALUE 0)                        ; N
293   (GETVALUE 1)                        ; D
295   (CDR)
296   (SETVALUE 1)                        ; D
298   (LOAD&PUSH 5)
299   (LOAD&PUSH 5)
300   (LOAD&PUSH 5)
301   (CALL2&PUSH 18)                     ; DIV*
303   (CALL2 19)                          ; MUL*
305   (STORE 5)
306   (GETVALUE 2)                        ; IND
308   (JMPIF L67)
311   (GETVALUE&PUSH 0)                   ; N
313   (CALL1&JMPIF 22 L89)                ; MPLUSP
317   (GETVALUE&PUSH 0)                   ; N
319   (GETVALUE&PUSH 1)                   ; D
321   (CALL2&PUSH 18)                     ; DIV*
323   (CALL1&PUSH 24)                     ; SRATSIMP
325   (CALL1 26)                          ; $MULTTHRU
327   L327
327   (PUSH)
328   (GETVALUE&PUSH 4)                   ; VAR
330   (GETVALUE&PUSH 5)                   ; VAL
332   (CONST&PUSH 27)                     ; THINK
333   (CALL 4 28)                         ; LIMIT
336   (BIND 21)                           ; ANS
338   (GETVALUE 21)                       ; ANS
340   (JMPIFNOT L350)
342   L342
342   (LOAD&PUSH 8)
343   (GETVALUE&PUSH 21)                  ; ANS
345   (CALL2 19)                          ; MUL*
347   (UNBIND1)
348   (JMP L351)
350   L350
350   (UNBIND1)
351   L351
351   (PUSH)
352   (CALL1 29)                          ; SIMPINF
354   (UNBIND1)
355   (SKIP 3)
357   (UNBIND1)
358   (SKIP 1)
360   (UNBIND 3)
362   (SKIP&RET 4)


Disassembly of function #:|(DEFUN LHOP-NUMDEN (NUM DENOM) ...)-89|
(CONST 0) = LHOP-NUMDEN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LHOP-NUMDEN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LHOP-NUMDEN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LHOP-NUMDEN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LHOP-NUMDEN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LHOP-NUMDEN
8     (SKIP&RET 1)


Disassembly of function LHOP-NUMDEN
(CONST 0) = NUM
(CONST 1) = DENOM
(CONST 2) = (%LOG)
(CONST 3) = INVOLVE
(CONST 4) = -1
(CONST 5) = POWER*
(CONST 6) = VAR
(CONST 7) = SDIFF
(CONST 8) = SRATSIMP
(CONST 9) = FACTOR
(CONST 10) = NUM-OF-LOGS
(CONST 11) = (%LOG)
(CONST 12) = %EINVOLVE
(CONST 13) = %E-RIGHT-PLACEP
(CONST 14) = (%SIN)
(CONST 15) = %SIN
(CONST 16) = TRIG-RIGHT-PLACEP
(CONST 17) = (%SIN)
(CONST 18) = OSCIP
(CONST 19) = POLYINX
(CONST 20) = FRAC
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR DENOM NUM)
writes special variables : (NUM DENOM)
196 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; NUM
3     (LOAD 4)
4     (BIND 1)                            ; DENOM
6     (GETVALUE&PUSH 0)                   ; NUM
8     (CONST&PUSH 2)                      ; (%LOG)
9     (CALL2&PUSH 3)                      ; INVOLVE
11    (LOAD&JMPIF 0 L105)
15    (SKIP 1)
17    (GETVALUE&PUSH 1)                   ; DENOM
19    (CONST&PUSH 11)                     ; (%LOG)
20    (CALL2&PUSH 3)                      ; INVOLVE
22    (LOAD&JMPIF 0 L161)
26    (SKIP 1)
28    (GETVALUE&PUSH 0)                   ; NUM
30    (CALL1&PUSH 12)                     ; %EINVOLVE
32    (LOAD&JMPIF 0 L193)
36    (SKIP 1)
38    (GETVALUE&PUSH 1)                   ; DENOM
40    (CALL1&PUSH 12)                     ; %EINVOLVE
42    (LOAD&JMPIF 0 L213)
46    (SKIP 1)
48    (GETVALUE&PUSH 0)                   ; NUM
50    (CONST&PUSH 14)                     ; (%SIN)
51    (CALL2&PUSH 3)                      ; INVOLVE
53    (LOAD&JMPIF 0 L233)
57    (SKIP 1)
59    (GETVALUE&PUSH 1)                   ; DENOM
61    (CONST&PUSH 17)                     ; (%SIN)
62    (CALL2&PUSH 3)                      ; INVOLVE
64    (LOAD&JMPIFNOT 0 L270)
68    (CONST&PUSH 15)                     ; %SIN
69    (LOAD&PUSH 1)
70    (CALL2&JMPIF 16 L254)               ; TRIG-RIGHT-PLACEP
74    (GETVALUE&PUSH 1)                   ; DENOM
76    (CONST&PUSH 4)                      ; -1
77    (CALL2&PUSH 5)                      ; POWER*
79    (GETVALUE&PUSH 0)                   ; NUM
81    (CONST 4)                           ; -1
82    L82
82    (PUSH)
83    (CALL2 5)                           ; POWER*
85    (SETVALUE 1)                        ; DENOM
87    (POP)
88    (SETVALUE 0)                        ; NUM
90    (SKIP 1)
92    (JMP L352)
95    L95
95    (GETVALUE&PUSH 1)                   ; DENOM
97    (CONST&PUSH 4)                      ; -1
98    (CALL2&PUSH 5)                      ; POWER*
100   (GETVALUE&PUSH 0)                   ; NUM
102   (CONST 4)                           ; -1
103   (JMP L82)
105   L105
105   (GETVALUE&PUSH 0)                   ; NUM
107   (CONST&PUSH 4)                      ; -1
108   (CALL2&PUSH 5)                      ; POWER*
110   (GETVALUE&PUSH 6)                   ; VAR
112   (CALL2&PUSH 7)                      ; SDIFF
114   (CALL1&PUSH 8)                      ; SRATSIMP
116   (CALL1&PUSH 9)                      ; FACTOR
118   (CALL1&PUSH 10)                     ; NUM-OF-LOGS
120   (GETVALUE&PUSH 0)                   ; NUM
122   (GETVALUE&PUSH 6)                   ; VAR
124   (CALL2&PUSH 7)                      ; SDIFF
126   (CALL1&PUSH 8)                      ; SRATSIMP
128   (CALL1&PUSH 9)                      ; FACTOR
130   (CALL1&PUSH 10)                     ; NUM-OF-LOGS
132   (CALLSR&JMPIF 1 47 L95)             ; <
136   (SKIP 1)
138   (JMP L352)
141   L141
141   (GETVALUE&PUSH 0)                   ; NUM
143   (CONST&PUSH 4)                      ; -1
144   (CALL2&PUSH 5)                      ; POWER*
146   (GETVALUE&PUSH 1)                   ; DENOM
148   (CONST&PUSH 4)                      ; -1
149   (CALL2 5)                           ; POWER*
151   (SETVALUE 0)                        ; NUM
153   (POP)
154   (SETVALUE 1)                        ; DENOM
156   (SKIP 1)
158   (JMP L352)
161   L161
161   (GETVALUE&PUSH 1)                   ; DENOM
163   (CONST&PUSH 4)                      ; -1
164   (CALL2&PUSH 5)                      ; POWER*
166   (GETVALUE&PUSH 6)                   ; VAR
168   (CALL2&PUSH 7)                      ; SDIFF
170   (CALL1&PUSH 8)                      ; SRATSIMP
172   (CALL1&PUSH 10)                     ; NUM-OF-LOGS
174   (GETVALUE&PUSH 1)                   ; DENOM
176   (GETVALUE&PUSH 6)                   ; VAR
178   (CALL2&PUSH 7)                      ; SDIFF
180   (CALL1&PUSH 8)                      ; SRATSIMP
182   (CALL1&PUSH 10)                     ; NUM-OF-LOGS
184   (CALLSR&JMPIF 1 47 L141)            ; <
188   (SKIP 1)
190   (JMP L352)
193   L193
193   (PUSH)
194   (CALL1&JMPIFNOT 13 L202)            ; %E-RIGHT-PLACEP
197   (SKIP 1)
199   (JMP L352)
202   L202
202   (GETVALUE&PUSH 1)                   ; DENOM
204   (CONST&PUSH 4)                      ; -1
205   (CALL2&PUSH 5)                      ; POWER*
207   (GETVALUE&PUSH 0)                   ; NUM
209   (CONST 4)                           ; -1
210   (JMP L82)
213   L213
213   (PUSH)
214   (CALL1&JMPIFNOT 13 L222)            ; %E-RIGHT-PLACEP
217   (SKIP 1)
219   (JMP L352)
222   L222
222   (GETVALUE&PUSH 1)                   ; DENOM
224   (CONST&PUSH 4)                      ; -1
225   (CALL2&PUSH 5)                      ; POWER*
227   (GETVALUE&PUSH 0)                   ; NUM
229   (CONST 4)                           ; -1
230   (JMP L82)
233   L233
233   (CONST&PUSH 15)                     ; %SIN
234   (LOAD&PUSH 1)
235   (CALL2&JMPIFNOT 16 L243)            ; TRIG-RIGHT-PLACEP
238   (SKIP 1)
240   (JMP L352)
243   L243
243   (GETVALUE&PUSH 1)                   ; DENOM
245   (CONST&PUSH 4)                      ; -1
246   (CALL2&PUSH 5)                      ; POWER*
248   (GETVALUE&PUSH 0)                   ; NUM
250   (CONST 4)                           ; -1
251   (JMP L82)
254   L254
254   (SKIP 1)
256   (JMP L352)
259   L259
259   (GETVALUE&PUSH 1)                   ; DENOM
261   (CONST&PUSH 4)                      ; -1
262   (CALL2&PUSH 5)                      ; POWER*
264   (GETVALUE&PUSH 0)                   ; NUM
266   (CONST 4)                           ; -1
267   (JMP L344)
270   L270
270   (SKIP 1)
272   (GETVALUE&PUSH 0)                   ; NUM
274   (CALL1&JMPIF 18 L352)               ; OSCIP
278   (GETVALUE&PUSH 1)                   ; DENOM
280   (CALL1&JMPIF 18 L352)               ; OSCIP
284   (GETVALUE&PUSH 0)                   ; NUM
286   (GETVALUE&PUSH 6)                   ; VAR
288   (NIL&PUSH)
289   (CALL 3 19)                         ; POLYINX
292   (JMPIF L352)
294   (GETVALUE&PUSH 1)                   ; DENOM
296   (GETVALUE&PUSH 6)                   ; VAR
298   (NIL&PUSH)
299   (CALL 3 19)                         ; POLYINX
302   (JMPIF L352)
304   (GETVALUE&PUSH 0)                   ; NUM
306   (CONST&PUSH 4)                      ; -1
307   (CALL2&PUSH 5)                      ; POWER*
309   (GETVALUE&PUSH 6)                   ; VAR
311   (NIL&PUSH)
312   (CALL 3 19)                         ; POLYINX
315   (JMPIF L259)
317   (GETVALUE&PUSH 1)                   ; DENOM
319   (CONST&PUSH 4)                      ; -1
320   (CALL2&PUSH 5)                      ; POWER*
322   (GETVALUE&PUSH 6)                   ; VAR
324   (NIL&PUSH)
325   (CALL 3 19)                         ; POLYINX
328   (JMPIF L259)
331   (GETVALUE&PUSH 0)                   ; NUM
333   (CALL1&JMPIFNOT 20 L352)            ; FRAC
336   (GETVALUE&PUSH 1)                   ; DENOM
338   (CONST&PUSH 4)                      ; -1
339   (CALL2&PUSH 5)                      ; POWER*
341   (GETVALUE&PUSH 0)                   ; NUM
343   (CONST 4)                           ; -1
344   L344
344   (PUSH)
345   (CALL2 5)                           ; POWER*
347   (SETVALUE 1)                        ; DENOM
349   (POP)
350   (SETVALUE 0)                        ; NUM
352   L352
352   (GETVALUE&PUSH 0)                   ; NUM
354   (GETVALUE 1)                        ; DENOM
356   (CONS)
357   (UNBIND 2)
359   (SKIP&RET 3)


Disassembly of function #:|(DEFUN NUM-OF-LOGS (EXP) ...)-90|
(CONST 0) = NUM-OF-LOGS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NUM-OF-LOGS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NUM-OF-LOGS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NUM-OF-LOGS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NUM-OF-LOGS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NUM-OF-LOGS
8     (SKIP&RET 1)


Disassembly of function NUM-OF-LOGS
(CONST 0) = EXP
(CONST 1) = MAPATOM
(CONST 2) = 0
(CONST 3) = %LOG
(CONST 4) = 1
(CONST 5) = NUM-OF-LOG-L
(CONST 6) = ADD*
(CONST 7) = MEXPTP
(CONST 8) = MNUMP
(CONST 9) = (MABS)
(CONST 10) = SIMPLIFY
(CONST 11) = MUL*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
47 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1&JMPIF 1 L36)                 ; MAPATOM
8     (GETVALUE 0)                        ; EXP
10    (CAR)
11    (CAR&PUSH)
12    (JMPIFEQTO 3 L39)                   ; %LOG
15    (GETVALUE&PUSH 0)                   ; EXP
17    (CALL1&JMPIFNOT 7 L28)              ; MEXPTP
20    (GETVALUE 0)                        ; EXP
22    (CDR)
23    (CDR)
24    (CAR&PUSH)
25    (CALL1&JMPIF 8 L49)                 ; MNUMP
28    L28
28    (GETVALUE 0)                        ; EXP
30    (CDR&PUSH)
31    (CALL1 5)                           ; NUM-OF-LOG-L
33    L33
33    (UNBIND1)
34    (SKIP&RET 2)
36    L36
36    (CONST 2)                           ; 0
37    (JMP L33)
39    L39
39    (CONST&PUSH 4)                      ; 1
40    (GETVALUE 0)                        ; EXP
42    (CDR&PUSH)
43    (CALL1&PUSH 5)                      ; NUM-OF-LOG-L
45    (CALL2 6)                           ; ADD*
47    (JMP L33)
49    L49
49    (CONST&PUSH 9)                      ; (MABS)
50    (GETVALUE 0)                        ; EXP
52    (CDR)
53    (CDR)
54    (CAR&PUSH)
55    (LIST&PUSH 2)
57    (CALL1&PUSH 10)                     ; SIMPLIFY
59    (GETVALUE 0)                        ; EXP
61    (CDR)
62    (CAR&PUSH)
63    (JSR&PUSH L0)
66    (CALL2 11)                          ; MUL*
68    (JMP L33)


Disassembly of function #:|(DEFUN NUM-OF-LOG-L (LLIST) ...)-91|
(CONST 0) = NUM-OF-LOG-L
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NUM-OF-LOG-L>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NUM-OF-LOG-L
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NUM-OF-LOG-L
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NUM-OF-LOG-L>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NUM-OF-LOG-L
8     (SKIP&RET 1)


Disassembly of function NUM-OF-LOG-L
(CONST 0) = TEMP
(CONST 1) = 0
(CONST 2) = ANS
(CONST 3) = NUM-OF-LOGS
(CONST 4) = ADD*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS TEMP)
writes special variables : (TEMP ANS)
22 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; TEMP
3     (CONST 1)                           ; 0
4     (BIND 2)                            ; ANS
6     (GETVALUE 0)                        ; TEMP
8     (JMPIFNOT L30)
10    L10
10    (GETVALUE&PUSH 2)                   ; ANS
12    (GETVALUE 0)                        ; TEMP
14    (CAR&PUSH)
15    (CALL1&PUSH 3)                      ; NUM-OF-LOGS
17    (CALL2 4)                           ; ADD*
19    (SETVALUE 2)                        ; ANS
21    (GETVALUE 0)                        ; TEMP
23    (CDR)
24    (SETVALUE 0)                        ; TEMP
26    (GETVALUE 0)                        ; TEMP
28    (JMPIF L10)
30    L30
30    (GETVALUE 2)                        ; ANS
32    (UNBIND 2)
34    (SKIP&RET 2)


Disassembly of function #:|(DEFUN %E-RIGHT-PLACEP (%E-ARG) ...)-92|
(CONST 0) = %E-RIGHT-PLACEP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE %E-RIGHT-PLACEP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; %E-RIGHT-PLACEP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; %E-RIGHT-PLACEP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE %E-RIGHT-PLACEP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; %E-RIGHT-PLACEP
8     (SKIP&RET 1)


Disassembly of function %E-RIGHT-PLACEP
(CONST 0) = VAR
(CONST 1) = SDIFF
(CONST 2) = FREE
(CONST 3) = DENOM
(CONST 4) = MEXPTP
(CONST 5) = -1
(CONST 6) = POWER*
(CONST 7) = POLYINX
(CONST 8) = VAL
(CONST 9) = THINK
(CONST 10) = LIMIT
(CONST 11) = RIDOFAB
(CONST 12) = $%E
(CONST 13) = MNUMP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL DENOM VAR)
53 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; VAR
3     (CALL2&PUSH 1)                      ; SDIFF
5     (LOAD&PUSH 0)
6     (GETVALUE&PUSH 0)                   ; VAR
8     (CALL2 2)                           ; FREE
10    (JMPIF1 L85)
13    (GETVALUE&PUSH 3)                   ; DENOM
15    (CALL1&JMPIFNOT 4 L25)              ; MEXPTP
18    (GETVALUE 3)                        ; DENOM
20    (CDR)
21    (CAR&PUSH)
22    (JMPIFEQTO 5 L78)                   ; -1
25    L25
25    (GETVALUE&PUSH 3)                   ; DENOM
27    (CONST&PUSH 5)                      ; -1
28    (CALL2&PUSH 6)                      ; POWER*
30    (GETVALUE&PUSH 0)                   ; VAR
32    (NIL&PUSH)
33    (CALL 3 7)                          ; POLYINX
36    (JMPIF L78)
38    (LOAD&PUSH 0)
39    (GETVALUE&PUSH 0)                   ; VAR
41    (GETVALUE&PUSH 8)                   ; VAL
43    (CONST&PUSH 9)                      ; THINK
44    (CALL&PUSH 4 10)                    ; LIMIT
47    (CALL1&PUSH 11)                     ; RIDOFAB
49    (CONST&PUSH 12)                     ; $%E
50    (LOAD&PUSH 4)
51    (CALL2&PUSH 6)                      ; POWER*
53    (GETVALUE&PUSH 0)                   ; VAR
55    (GETVALUE&PUSH 8)                   ; VAL
57    (CONST&PUSH 9)                      ; THINK
58    (CALL&PUSH 4 10)                    ; LIMIT
61    (CALL1&PUSH 11)                     ; RIDOFAB
63    (LOAD&PUSH 1)
64    (LOAD&PUSH 1)
65    (CALLS2&JMPIF 2 L81)                ; EQUAL
68    (LOAD&PUSH 1)
69    (CALL1&JMPIFNOT 13 L76)             ; MNUMP
72    (LOAD&PUSH 0)
73    (CALL1&JMPIF 13 L81)                ; MNUMP
76    L76
76    (SKIP 2)
78    L78
78    (NIL)
79    (SKIP&RET 3)
81    L81
81    (T)
82    (SKIP 2)
84    (VALUES1)
85    L85
85    (SKIP&RET 3)


Disassembly of function #:|(DEFUN TRIG-RIGHT-PLACEP (TRIG-TYPE ARG) ...)-93|
(CONST 0) = TRIG-RIGHT-PLACEP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE TRIG-RIGHT-PLACEP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; TRIG-RIGHT-PLACEP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; TRIG-RIGHT-PLACEP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE TRIG-RIGHT-PLACEP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; TRIG-RIGHT-PLACEP
8     (SKIP&RET 1)


Disassembly of function TRIG-RIGHT-PLACEP
(CONST 0) = ARG
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = THINK
(CONST 4) = LIMIT
(CONST 5) = RIDOFAB
(CONST 6) = 0
(CONST 7) = INFINITIES
(CONST 8) = MEMQ
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL VAR ARG)
38 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (GETVALUE&PUSH 1)                   ; VAR
7     (GETVALUE&PUSH 2)                   ; VAL
9     (CONST&PUSH 3)                      ; THINK
10    (CALL&PUSH 4 4)                     ; LIMIT
13    (CALL1&PUSH 5)                      ; RIDOFAB
15    (LOAD&PUSH 6)
16    (LIST&PUSH 1)
18    (GETVALUE&PUSH 0)                   ; ARG
20    (LIST&PUSH 2)
22    (GETVALUE&PUSH 1)                   ; VAR
24    (GETVALUE&PUSH 2)                   ; VAL
26    (CONST&PUSH 3)                      ; THINK
27    (CALL&PUSH 4 4)                     ; LIMIT
30    (CALL1&PUSH 5)                      ; RIDOFAB
32    (LOAD&PUSH 1)
33    (JMPIFNOTEQTO 6 L40)                ; 0
36    (LOAD&PUSH 0)
37    (JMPIFEQTO 6 L52)                   ; 0
40    L40
40    (LOAD&PUSH 1)
41    (GETVALUE&PUSH 7)                   ; INFINITIES
43    (CALL2&JMPIFNOT 8 L57)              ; MEMQ
46    (LOAD&PUSH 0)
47    (GETVALUE&PUSH 7)                   ; INFINITIES
49    (CALL2&JMPIFNOT 8 L57)              ; MEMQ
52    L52
52    (T)
53    (SKIP 2)
55    (JMP L60)
57    L57
57    (NIL)
58    (SKIP 2)
60    L60
60    (UNBIND1)
61    (SKIP&RET 3)


Disassembly of function #:|(DEFUN REMOVE-SINGULARITIES (NUMER DENOM) ...)-94|
(CONST 0) = REMOVE-SINGULARITIES
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE REMOVE-SINGULARITIES>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; REMOVE-SINGULARITIES
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REMOVE-SINGULARITIES
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE REMOVE-SINGULARITIES>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; REMOVE-SINGULARITIES
8     (SKIP&RET 1)


Disassembly of function REMOVE-SINGULARITIES
(CONST 0) = NUMER
(CONST 1) = DENOM
(CONST 2) = MTIMESP
(CONST 3) = 1
(CONST 4) = VAR-OR-CONST
(CONST 5) = %EINVOLVE
(CONST 6) = LIMIT
(CONST 7) = DIV*
(CONST 8) = VAR
(CONST 9) = VAL
(CONST 10) = THINK
(CONST 11) = SIMPAB
(CONST 12) = SIMPINF
(CONST 13) = RIDOFAB
(CONST 14) = 0
(CONST 15) = INFINITIES
(CONST 16) = MEMQ
(CONST 17) = $INF
(CONST 18) = FREE
(CONST 19) = $MINF
(CONST 20) = $INFINITY
(CONST 21) = $IND
(CONST 22) = $UND
(CONST 23) = MUL*
(CONST 24) = ZL-DELETE
(CONST 25) = MULN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL VAR DENOM NUMER)
153 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; NUMER
3     (LOAD 4)
4     (BIND 1)                            ; DENOM
6     (GETVALUE 0)                        ; NUMER
8     (JMPIFNOT L211)
11    (GETVALUE 1)                        ; DENOM
13    (JMPIFNOT L211)
16    (GETVALUE 0)                        ; NUMER
18    (JMPIFATOM L211)
21    (GETVALUE 1)                        ; DENOM
23    (JMPIFATOM L211)
26    (GETVALUE&PUSH 0)                   ; NUMER
28    (CALL1&JMPIFNOT 2 L211)             ; MTIMESP
32    (GETVALUE&PUSH 1)                   ; DENOM
34    (CALL1&JMPIFNOT 2 L211)             ; MTIMESP
38    (NIL&PUSH)
39    (GETVALUE&PUSH 0)                   ; NUMER
41    (CALL1&PUSH 4)                      ; VAR-OR-CONST
43    (NIL&PUSH)
44    (GETVALUE&PUSH 1)                   ; DENOM
46    (CALL1&PUSH 4)                      ; VAR-OR-CONST
48    (CONST&PUSH 3)                      ; 1
49    (LOAD&CAR&STORE 1 2)
52    (LOAD&CDR&STORE 1)
54    (LOAD&CAR&STORE 3 4)
57    (LOAD&CDR&STORE 3)
59    (PUSH)
60    (CALL1&JMPIFNOT 2 L220)             ; MTIMESP
64    (LOAD&CDR&STORE 3)
66    L66
66    (LOAD&PUSH 1)
67    (CALL1&JMPIFNOT 2 L227)             ; MTIMESP
71    (LOAD&CDR&STORE 1)
73    L73
73    (LOAD&PUSH 3)
74    (LOAD&PUSH 4)
75    (CALLS1&PUSH 158)                   ; COPY-LIST
77    (LOAD&PUSH 3)
78    (LOAD&PUSH 4)
79    (CALLS1&PUSH 158)                   ; COPY-LIST
81    (LOAD&JMPIFNOT 3 L188)
85    L85
85    (LOAD&PUSH 1)
86    (LOAD&JMPIFNOT 0 L178)
90    L90
90    (LOAD&CAR&PUSH 4)
92    (CALL1&JMPIF 5 L172)                ; %EINVOLVE
96    (LOAD&CAR&PUSH 4)
98    (CALL1&JMPIF 5 L172)                ; %EINVOLVE
102   (CONST 6)                           ; LIMIT
103   (CATCH-OPEN L124)
105   (LOAD&CAR&PUSH 7)
107   (LOAD&CAR&PUSH 4)
109   (CALL2&PUSH 7)                      ; DIV*
111   (GETVALUE&PUSH 8)                   ; VAR
113   (GETVALUE&PUSH 9)                   ; VAL
115   (CONST&PUSH 10)                     ; THINK
116   (CALL&PUSH 4 6)                     ; LIMIT
119   (CALL1&PUSH 11)                     ; SIMPAB
121   (CALL1 12)                          ; SIMPINF
123   (CATCH-CLOSE)
124   L124
124   (PUSH)
125   (LOAD&PUSH 0)
126   (T)
127   (JMPIFEQ L170)
129   (LOAD&JMPIFNOT 0 L170)
132   (LOAD&PUSH 0)
133   (CALL1&PUSH 13)                     ; RIDOFAB
135   (JMPIFEQTO 14 L170)                 ; 0
138   (LOAD&PUSH 0)
139   (GETVALUE&PUSH 15)                  ; INFINITIES
141   (CALL2&JMPIF 16 L170)               ; MEMQ
144   (LOAD&PUSH 0)
145   (CONST&PUSH 17)                     ; $INF
146   (CALL2&JMPIFNOT 18 L170)            ; FREE
149   (LOAD&PUSH 0)
150   (CONST&PUSH 19)                     ; $MINF
151   (CALL2&JMPIFNOT 18 L170)            ; FREE
154   (LOAD&PUSH 0)
155   (CONST&PUSH 20)                     ; $INFINITY
156   (CALL2&JMPIFNOT 18 L170)            ; FREE
159   (LOAD&PUSH 0)
160   (CONST&PUSH 21)                     ; $IND
161   (CALL2&JMPIFNOT 18 L170)            ; FREE
164   (LOAD&PUSH 0)
165   (CONST&PUSH 22)                     ; $UND
166   (CALL2&JMPIF 18 L234)               ; FREE
170   L170
170   (SKIP 1)
172   L172
172   (LOAD&CDR&STORE 0)
174   (LOAD&JMPIF 0 L90)
178   L178
178   (SKIP 1)
180   L180
180   (LOAD&CDR&STORE 3)
182   (LOAD 0)
183   (STORE 1)
184   (LOAD&JMPIF 3 L85)
188   L188
188   (LOAD&PUSH 4)
189   (LOAD&PUSH 9)
190   (LOAD&PUSH 8)
191   (CALL2&PUSH 7)                      ; DIV*
193   (CALL2&PUSH 23)                     ; MUL*
195   (LOAD&PUSH 3)
196   (NIL&PUSH)
197   (CALL2&PUSH 25)                     ; MULN
199   (LOAD&PUSH 2)
200   (NIL&PUSH)
201   (CALL2 25)                          ; MULN
203   (CONS)
204   (CONS)
205   (SKIP 9)
207   L207
207   (UNBIND 2)
209   (SKIP&RET 3)
211   L211
211   (CONST&PUSH 3)                      ; 1
212   (GETVALUE&PUSH 0)                   ; NUMER
214   (GETVALUE 1)                        ; DENOM
216   (CONS)
217   (CONS)
218   (JMP L207)
220   L220
220   (LOAD&PUSH 3)
221   (LIST 1)
223   (STORE 3)
224   (JMP L66)
227   L227
227   (LOAD&PUSH 1)
228   (LIST 1)
230   (STORE 1)
231   (JMP L73)
234   L234
234   (LOAD&PUSH 0)
235   (LOAD&PUSH 7)
236   (CALL2 23)                          ; MUL*
238   (STORE 6)
239   (LOAD&CAR&PUSH 5)
241   (LOAD&PUSH 5)
242   (CONST&PUSH 3)                      ; 1
243   (CALL 3 24)                         ; ZL-DELETE
246   (STORE 4)
247   (LOAD&CAR&PUSH 1)
249   (LOAD&PUSH 3)
250   (CONST&PUSH 3)                      ; 1
251   (CALL 3 24)                         ; ZL-DELETE
254   (STORE 2)
255   (SKIP 2)
257   (JMP L180)


Disassembly of function #:|(DEFUN VAR-OR-CONST (EXPR) ...)-95|
(CONST 0) = VAR-OR-CONST
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE VAR-OR-CONST>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; VAR-OR-CONST
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; VAR-OR-CONST
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE VAR-OR-CONST>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; VAR-OR-CONST
8     (SKIP&RET 1)


Disassembly of function VAR-OR-CONST
(CONST 0) = $FACTOR
(CONST 1) = VAR
(CONST 2) = 1
(CONST 3) = FREE
(CONST 4) = MTIMESP
(CONST 5) = L
(CONST 6) = MUL*
(CONST 7) = VAL
(CONST 8) = THINK
(CONST 9) = LIMIT
(CONST 10) = INFINITIES
(CONST 11) = RIDOFAB
(CONST 12) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL L VAR)
writes special variable : (L)
97 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1 0)                           ; $FACTOR
3     (STORE 1)
4     (JMPIFATOM L25)
6     (LOAD&PUSH 1)
7     (GETVALUE&PUSH 1)                   ; VAR
9     (CALL2&JMPIF 3 L34)                 ; FREE
12    (LOAD&PUSH 1)
13    (CALL1&JMPIF 4 L43)                 ; MTIMESP
16    (CONST 2)                           ; 1
17    L17
17    (PUSH)
18    (LOAD 2)
19    L19
19    (CONS)
20    (SKIP&RET 2)
22    L22
22    (CONST 2)                           ; 1
23    (JMP L17)
25    L25
25    (LOAD&PUSH 1)
26    (GETVALUE 1)                        ; VAR
28    (JMPIFEQ L22)
30    (LOAD&PUSH 1)
31    (CONST 2)                           ; 1
32    (JMP L19)
34    L34
34    (LOAD&PUSH 1)
35    (CONST 2)                           ; 1
36    (JMP L19)
38    L38
38    (GETVALUE 5)                        ; L
40    (CAR)
41    (JMP L102)
43    L43
43    (LOAD 1)
44    (CDR)
45    (BIND 5)                            ; L
47    (CONST&PUSH 2)                      ; 1
48    (CONST&PUSH 2)                      ; 1
49    (NIL&PUSH)
50    (GETVALUE 5)                        ; L
52    (JMPIFNOT L128)
55    L55
55    (GETVALUE 5)                        ; L
57    (CAR&PUSH)
58    (GETVALUE&PUSH 1)                   ; VAR
60    (CALL2&JMPIF 3 L38)                 ; FREE
63    (GETVALUE 5)                        ; L
65    (CAR&PUSH)
66    (GETVALUE&PUSH 1)                   ; VAR
68    (GETVALUE&PUSH 7)                   ; VAL
70    (CONST&PUSH 8)                      ; THINK
71    (CALL 4 9)                          ; LIMIT
74    (STORE 0)
75    (JMPIFNOT L111)
77    (GETVALUE&PUSH 10)                  ; INFINITIES
79    (LOAD&JMPIFNOT 0 L93)
82    L82
82    (LOAD&CAR&PUSH 0)
84    (LOAD&PUSH 2)
85    (CALL2&JMPIFNOT 3 L109)             ; FREE
88    (LOAD&CDR&STORE 0)
90    (LOAD&JMPIF 0 L82)
93    L93
93    (SKIP 1)
95    (LOAD&PUSH 0)
96    (CALL1&PUSH 11)                     ; RIDOFAB
98    (JMPIFEQTO 12 L111)                 ; 0
101   (LOAD 0)
102   L102
102   (PUSH)
103   (LOAD&PUSH 3)
104   (CALL2 6)                           ; MUL*
106   (STORE 2)
107   (JMP L118)
109   L109
109   (SKIP 1)
111   L111
111   (GETVALUE 5)                        ; L
113   (CAR&PUSH)
114   (LOAD&PUSH 2)
115   (CALL2 6)                           ; MUL*
117   (STORE 1)
118   L118
118   (GETVALUE 5)                        ; L
120   (CDR)
121   (SETVALUE 5)                        ; L
123   (GETVALUE 5)                        ; L
125   (JMPIF L55)
128   L128
128   (LOAD&PUSH 2)
129   (LOAD 2)
130   (CONS)
131   (SKIP 3)
133   (UNBIND1)
134   (SKIP&RET 2)


Disassembly of function #:|(DEFUN LHSIMP (TERM VAR VAL) ...)-96|
(CONST 0) = LHSIMP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LHSIMP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LHSIMP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LHSIMP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LHSIMP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LHSIMP
8     (SKIP&RET 1)


Disassembly of function LHSIMP
(CONST 0) = VAR
(CONST 1) = VAL
(CONST 2) = MFACTORIAL
(CONST 3) = THINK
(CONST 4) = LIMIT
(CONST 5) = ($INF $MINF $UND $IND $INFINITY $ZEROA $ZEROB)
(CONST 6) = MEMQ
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR)
32 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; VAR
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (LOAD 9)
7     (JMPIFATOM L36)
9     (LOAD 9)
10    (CAR)
11    (CAR&PUSH)
12    (JMPIFNOTEQTO 2 L39)                ; MFACTORIAL
15    (LOAD&PUSH 9)
16    (GETVALUE&PUSH 0)                   ; VAR
18    (GETVALUE&PUSH 1)                   ; VAL
20    (CONST&PUSH 3)                      ; THINK
21    (CALL&PUSH 4 4)                     ; LIMIT
24    (LOAD&PUSH 0)
25    (CONST&PUSH 5)                      ; ($INF $MINF $UND $IND ...)
26    (CALL2&JMPIFNOT 6 L42)              ; MEMQ
29    (LOAD 10)
30    (SKIP 1)
32    L32
32    (UNBIND 2)
34    (SKIP&RET 4)
36    L36
36    (LOAD 9)
37    (JMP L32)
39    L39
39    (LOAD 9)
40    (JMP L32)
42    L42
42    (POP)
43    (JMP L32)


Disassembly of function #:|(DEFUN BYLOG (EXPO BAS) ...)-97|
(CONST 0) = BYLOG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BYLOG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BYLOG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BYLOG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BYLOG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BYLOG
8     (SKIP&RET 1)


Disassembly of function BYLOG
(CONST 0) = BAS
(CONST 1) = $%E
(CONST 2) = (%LOG)
(CONST 3) = TANSC
(CONST 4) = SIMPLIFY
(CONST 5) = -1
(CONST 6) = POWER*
(CONST 7) = TRY-LHOSPITAL-QUIT
(CONST 8) = SIMPLIMEXPT
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (BAS)
writes special variable : (BAS)
20 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; BAS
3     (CONST&PUSH 1)                      ; $%E
4     (CONST&PUSH 2)                      ; (%LOG)
5     (GETVALUE&PUSH 0)                   ; BAS
7     (CALL1&PUSH 3)                      ; TANSC
9     (LIST&PUSH 2)
11    (CALL1&PUSH 4)                      ; SIMPLIFY
13    (LOAD&PUSH 7)
14    (CONST&PUSH 5)                      ; -1
15    (CALL2&PUSH 6)                      ; POWER*
17    (NIL&PUSH)
18    (CALL 3 7)                          ; TRY-LHOSPITAL-QUIT
21    (SETVALUE 0)                        ; BAS
23    (PUSH)
24    (CONST&PUSH 1)                      ; $%E
25    (GETVALUE&PUSH 0)                   ; BAS
27    (CALL 4 8)                          ; SIMPLIMEXPT
30    (UNBIND1)
31    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SIMPLIMEXPT (BAS EXPO BL ...) ...)-98|
(CONST 0) = SIMPLIMEXPT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMEXPT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMEXPT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMEXPT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMEXPT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMEXPT
8     (SKIP&RET 1)


Disassembly of function SIMPLIMEXPT
(CONST 0) = BAS
(CONST 1) = BL
(CONST 2) = $UND
(CONST 3) = ZEROP2
(CONST 4) = $INF
(CONST 5) = $ZEROA
(CONST 6) = 0
(CONST 7) = $MINF
(CONST 8) = $INFINITY
(CONST 9) = $IND
(CONST 10) = BYLOG
(CONST 11) = MNUMP
(CONST 12) = $ZEROB
(CONST 13) = LIMIT
(CONST 14) = GETSIGNL
(CONST 15) = -1
(CONST 16) = EVEN1
(CONST 17) = $INTEGER
(CONST 18) = ASK-INTEGER
(CONST 19) = $YES
(CONST 20) = $EVEN
(CONST 21) = VAR
(CONST 22) = VAL
(CONST 23) = BEHAVIOR
(CONST 24) = 1
(CONST 25) = ($ZEROA $ZEROB)
(CONST 26) = MEMQ
(CONST 27) = RATNUMP
(CONST 28) = ($INFINITY $IND)
(CONST 29) = ($INFINITY $IND)
(CONST 30) = RATGREATERP
(CONST 31) = MNEGP
(CONST 32) = LOGINPROD?
(CONST 33) = LIP?
(CONST 34) = LIP!
(CONST 35) = RIDOFAB
(CONST 36) = RATDISREP
(CONST 37) = SIMPLIFY
(CONST 38) = INFINITIES
(CONST 39) = ABLESS1
(CONST 40) = TRISPLIT
(CONST 41) = ORIGVAL
(CONST 42) = POWER*
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ORIGVAL LOGINPROD? VAL VAR BAS INFINITIES BL)
writes special variable : (BAS)
439 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; BAS
3     (LOAD 5)
4     (BIND 1)                            ; BL
6     (GETVALUE&PUSH 1)                   ; BL
8     (JMPIFEQTO 2 L66)                   ; $UND
11    (LOAD&PUSH 7)
12    (JMPIFEQTO 2 L66)                   ; $UND
15    (GETVALUE&PUSH 1)                   ; BL
17    (CALL1&JMPIF 3 L155)                ; ZEROP2
21    (GETVALUE&PUSH 1)                   ; BL
23    (JMPIFEQTO 8 L322)                  ; $INFINITY
27    (GETVALUE&PUSH 1)                   ; BL
29    (JMPIFEQTO 4 L380)                  ; $INF
33    (GETVALUE&PUSH 1)                   ; BL
35    (JMPIFEQTO 7 L498)                  ; $MINF
39    (GETVALUE&PUSH 1)                   ; BL
41    (CALL1&PUSH 35)                     ; RIDOFAB
43    (CALL1&PUSH 36)                     ; RATDISREP
45    (CALL1&PUSH 37)                     ; SIMPLIFY
47    (JMPIFNOTEQTO 24 L705)              ; 1
51    (LOAD&PUSH 7)
52    (GETVALUE&PUSH 38)                  ; INFINITIES
54    (CALL2&JMPIFNOT 26 L525)            ; MEMQ
58    L58
58    (LOAD&PUSH 9)
59    (GETVALUE&PUSH 0)                   ; BAS
61    (CALL2 10)                          ; BYLOG
63    (JMP L754)
66    L66
66    (CONST 2)                           ; $UND
67    (JMP L754)
70    L70
70    (GETVALUE 1)                        ; BL
72    (JMP L754)
75    L75
75    (GETVALUE&PUSH 1)                   ; BL
77    (JMPIFEQTO 5 L70)                   ; $ZEROA
80    (CONST 6)                           ; 0
81    (JMP L754)
84    L84
84    (CONST 4)                           ; $INF
85    (JMP L754)
88    L88
88    (GETVALUE&PUSH 1)                   ; BL
90    (JMPIFEQTO 5 L84)                   ; $ZEROA
93    (CONST 8)                           ; $INFINITY
94    (JMP L754)
97    L97
97    (CONST 9)                           ; $IND
98    (JMP L754)
101   L101
101   (CONST 2)                           ; $UND
102   (JMP L754)
105   L105
105   (CONST 13)                          ; LIMIT
106   (JMP L232)
109   L109
109   (CONST 4)                           ; $INF
110   (JMP L754)
113   L113
113   (CONST 4)                           ; $INF
114   (JMP L754)
117   L117
117   (CONST 4)                           ; $INF
118   (JMP L754)
121   L121
121   (LOAD&PUSH 7)
122   (CONST&PUSH 20)                     ; $EVEN
123   (CALL2&PUSH 18)                     ; ASK-INTEGER
125   (JMPIFEQTO 19 L117)                 ; $YES
128   (CONST 7)                           ; $MINF
129   (JMP L754)
132   L132
132   (LOAD&PUSH 7)
133   (CALL1&JMPIF 16 L113)               ; EVEN1
136   (LOAD&PUSH 7)
137   (CONST&PUSH 17)                     ; $INTEGER
138   (CALL2&PUSH 18)                     ; ASK-INTEGER
140   (JMPIFEQTO 19 L121)                 ; $YES
143   (NIL)
144   (JMP L754)
147   L147
147   (CONST 4)                           ; $INF
148   (JMP L754)
151   L151
151   (CONST 7)                           ; $MINF
152   (JMP L754)
155   L155
155   (LOAD&PUSH 7)
156   (JMPIFEQTO 4 L75)                   ; $INF
160   (LOAD&PUSH 7)
161   (JMPIFEQTO 7 L88)                   ; $MINF
165   (LOAD&PUSH 7)
166   (JMPIFEQTO 9 L97)                   ; $IND
170   (LOAD&PUSH 7)
171   (JMPIFEQTO 8 L101)                  ; $INFINITY
175   (LOAD&PUSH 7)
176   (CALL1&JMPIF 3 L58)                 ; ZEROP2
180   (LOAD&PUSH 7)
181   (CALL1&JMPIF 11 L190)               ; MNUMP
184   (GETVALUE&PUSH 1)                   ; BL
186   (JMPIFEQTO 12 L105)                 ; $ZEROB
190   L190
190   (LOAD&PUSH 7)
191   (CALL1&PUSH 14)                     ; GETSIGNL
193   (JMPIFNOTEQTO 15 L273)              ; -1
197   (GETVALUE&PUSH 1)                   ; BL
199   (JMPIFEQTO 5 L109)                  ; $ZEROA
203   (GETVALUE&PUSH 1)                   ; BL
205   (JMPIFEQTO 12 L132)                 ; $ZEROB
209   (GETVALUE&PUSH 0)                   ; BAS
211   (GETVALUE&PUSH 21)                  ; VAR
213   (GETVALUE&PUSH 22)                  ; VAL
215   (CALL 3 23)                         ; BEHAVIOR
218   (SETVALUE 0)                        ; BAS
220   (PUSH)
221   (JMPIFEQTO 24 L147)                 ; 1
225   (GETVALUE&PUSH 0)                   ; BAS
227   (JMPIFEQTO 15 L151)                 ; -1
231   (CONST 13)                          ; LIMIT
232   L232
232   (PUSH)
233   (T)
234   (THROW)
235   L235
235   (CONST 5)                           ; $ZEROA
236   (JMP L754)
239   L239
239   (CONST 6)                           ; 0
240   (JMP L754)
243   L243
243   (LOAD&PUSH 7)
244   (CALL1&JMPIF 16 L235)               ; EVEN1
247   (GETVALUE&PUSH 1)                   ; BL
249   (JMPIFNOTEQTO 12 L263)              ; $ZEROB
252   (LOAD&PUSH 7)
253   (CALL1&JMPIFNOT 27 L263)            ; RATNUMP
256   (LOAD 7)
257   (CDR)
258   (CDR)
259   (CAR&PUSH)
260   (CALLS2&JMPIF 149 L239)             ; EVENP
263   L263
263   (GETVALUE 1)                        ; BL
265   (JMP L754)
268   L268
268   (GETVALUE 1)                        ; BL
270   (JMP L754)
273   L273
273   (LOAD&PUSH 7)
274   (CALL1&JMPIFNOT 11 L283)            ; MNUMP
277   (GETVALUE&PUSH 1)                   ; BL
279   (CONST&PUSH 25)                     ; ($ZEROA $ZEROB)
280   (CALL2&JMPIF 26 L243)               ; MEMQ
283   L283
283   (LOAD&PUSH 7)
284   (CALL1&PUSH 14)                     ; GETSIGNL
286   (JMPIFNOTEQTO 24 L294)              ; 1
289   (GETVALUE&PUSH 1)                   ; BL
291   (JMPIFEQTO 5 L268)                  ; $ZEROA
294   L294
294   (CONST 6)                           ; 0
295   (JMP L754)
298   L298
298   (CONST 6)                           ; 0
299   (JMP L754)
302   L302
302   (CONST 8)                           ; $INFINITY
303   (JMP L754)
306   L306
306   (CONST 2)                           ; $UND
307   (JMP L754)
310   L310
310   (CONST 8)                           ; $INFINITY
311   (JMP L754)
314   L314
314   (CONST 2)                           ; $UND
315   (JMP L754)
318   L318
318   (CONST 6)                           ; 0
319   (JMP L754)
322   L322
322   (LOAD&PUSH 7)
323   (CALL1&JMPIF 3 L58)                 ; ZEROP2
327   (LOAD&PUSH 7)
328   (JMPIFEQTO 7 L298)                  ; $MINF
331   (LOAD&PUSH 7)
332   (JMPIFEQTO 4 L302)                  ; $INF
335   (LOAD&PUSH 7)
336   (CONST&PUSH 28)                     ; ($INFINITY $IND)
337   (CALL2&JMPIF 26 L306)               ; MEMQ
340   (LOAD&PUSH 7)
341   (CALL1 14)                          ; GETSIGNL
343   (STORE 7)
344   (PUSH)
345   (JMPIFEQTO 24 L310)                 ; 1
348   (LOAD&JMPIFNOT 7 L314)
351   (LOAD&PUSH 7)
352   (JMPIFEQTO 15 L318)                 ; -1
355   (NIL)
356   (JMP L754)
359   L359
359   (CONST 4)                           ; $INF
360   (JMP L754)
363   L363
363   (CONST 6)                           ; 0
364   (JMP L754)
367   L367
367   (CONST 2)                           ; $UND
368   (JMP L754)
371   L371
371   (CONST 24)                          ; 1
373   (JMP L754)
376   L376
376   (CONST 5)                           ; $ZEROA
377   (JMP L754)
380   L380
380   (LOAD&PUSH 7)
381   (JMPIFEQTO 4 L359)                  ; $INF
384   (LOAD&PUSH 7)
385   (JMPIFEQTO 7 L363)                  ; $MINF
388   (LOAD&PUSH 7)
389   (CALL1&JMPIF 3 L58)                 ; ZEROP2
393   (LOAD&PUSH 7)
394   (CONST&PUSH 29)                     ; ($INFINITY $IND)
395   (CALL2&JMPIF 26 L367)               ; MEMQ
398   (LOAD&PUSH 7)
399   (CALL1&PUSH 14)                     ; GETSIGNL
401   (CALLS2&JMPIF 145 L371)             ; ZEROP
404   (CONST&PUSH 6)                      ; 0
405   (LOAD&PUSH 8)
406   (CALL2&JMPIF 30 L376)               ; RATGREATERP
409   (CONST 4)                           ; $INF
410   (JMP L754)
413   L413
413   (CONST 2)                           ; $UND
414   (JMP L754)
417   L417
417   (CONST 6)                           ; 0
418   (JMP L754)
421   L421
421   (CONST 5)                           ; $ZEROA
422   (JMP L754)
425   L425
425   (CONST 5)                           ; $ZEROA
426   (JMP L754)
429   L429
429   (LOAD&PUSH 7)
430   (CONST&PUSH 20)                     ; $EVEN
431   (CALL2&PUSH 18)                     ; ASK-INTEGER
433   (JMPIFEQTO 19 L425)                 ; $YES
436   (CONST 12)                          ; $ZEROB
437   (JMP L754)
440   L440
440   (LOAD&PUSH 7)
441   (CALL1&JMPIF 16 L421)               ; EVEN1
444   (LOAD&PUSH 7)
445   (CONST&PUSH 17)                     ; $INTEGER
446   (CALL2&PUSH 18)                     ; ASK-INTEGER
448   (JMPIFEQTO 19 L429)                 ; $YES
451   (CONST 6)                           ; 0
452   (JMP L754)
455   L455
455   (CONST 4)                           ; $INF
456   (JMP L754)
459   L459
459   (CONST 4)                           ; $INF
460   (JMP L754)
463   L463
463   (LOAD&PUSH 7)
464   (CONST&PUSH 20)                     ; $EVEN
465   (CALL2&PUSH 18)                     ; ASK-INTEGER
467   (JMPIFEQTO 19 L459)                 ; $YES
470   (CONST 7)                           ; $MINF
471   (JMP L754)
474   L474
474   (LOAD&PUSH 7)
475   (CALL1&JMPIF 31 L440)               ; MNEGP
478   (LOAD&PUSH 7)
479   (CALL1&JMPIF 16 L455)               ; EVEN1
482   (LOAD&PUSH 7)
483   (CONST&PUSH 17)                     ; $INTEGER
484   (CALL2&PUSH 18)                     ; ASK-INTEGER
486   (JMPIFEQTO 19 L463)                 ; $YES
489   (CONST 8)                           ; $INFINITY
490   (JMP L754)
493   L493
493   (CONST&PUSH 33)                     ; LIP?
495   (CONST 34)                          ; LIP!
497   (THROW)
498   L498
498   (LOAD&PUSH 7)
499   (CALL1&JMPIF 3 L58)                 ; ZEROP2
503   (LOAD&PUSH 7)
504   (JMPIFEQTO 4 L413)                  ; $INF
508   (LOAD&PUSH 7)
509   (JMPIFEQTO 7 L417)                  ; $MINF
513   (LOAD&PUSH 7)
514   (CALL1&JMPIF 11 L474)               ; MNUMP
517   (GETVALUE 32)                       ; LOGINPROD?
519   (JMPIF L493)
521   (CONST 2)                           ; $UND
522   (JMP L754)
525   L525
525   (CONST 24)                          ; 1
527   (JMP L754)
530   L530
530   (CONST 9)                           ; $IND
531   (JMP L754)
534   L534
534   (CONST 2)                           ; $UND
535   (JMP L754)
538   L538
538   (CONST 9)                           ; $IND
539   (JMP L754)
542   L542
542   (LOAD&PUSH 7)
543   (CALL1&JMPIF 3 L534)                ; ZEROP2
546   (LOAD&PUSH 7)
547   (GETVALUE&PUSH 38)                  ; INFINITIES
549   (CALL2&JMPIF 26 L534)               ; MEMQ
552   (LOAD&PUSH 7)
553   (CALL1&PUSH 14)                     ; GETSIGNL
555   (JMPIFNOTEQTO 15 L538)              ; -1
558   (CONST 2)                           ; $UND
559   (JMP L754)
562   L562
562   (CONST 5)                           ; $ZEROA
563   (JMP L754)
566   L566
566   (GETVALUE&PUSH 1)                   ; BL
568   (CALL1&PUSH 14)                     ; GETSIGNL
570   (JMPIFEQTO 24 L562)                 ; 1
573   (CONST 6)                           ; 0
574   (JMP L754)
577   L577
577   (CONST 8)                           ; $INFINITY
578   (JMP L754)
581   L581
581   (GETVALUE&PUSH 1)                   ; BL
583   (CALL1&JMPIF 39 L566)               ; ABLESS1
586   (GETVALUE&PUSH 1)                   ; BL
588   (CALL1&PUSH 14)                     ; GETSIGNL
590   (JMPIFEQTO 15 L577)                 ; -1
593   (CONST 4)                           ; $INF
594   (JMP L754)
597   L597
597   (CONST 5)                           ; $ZEROA
598   (JMP L754)
601   L601
601   (GETVALUE&PUSH 1)                   ; BL
603   (CALL1&PUSH 14)                     ; GETSIGNL
605   (JMPIFEQTO 24 L597)                 ; 1
608   (CONST 6)                           ; 0
609   (JMP L754)
612   L612
612   (CONST 8)                           ; $INFINITY
613   (JMP L754)
616   L616
616   (GETVALUE&PUSH 1)                   ; BL
618   (CALL1&JMPIFNOT 39 L601)            ; ABLESS1
621   (CONST&PUSH 6)                      ; 0
622   (GETVALUE&PUSH 1)                   ; BL
624   (CALL2&JMPIF 30 L612)               ; RATGREATERP
627   (CONST 4)                           ; $INF
628   (JMP L754)
631   L631
631   (CONST 2)                           ; $UND
632   (JMP L754)
635   L635
635   (CONST 6)                           ; 0
636   (SKIP 2)
638   (JMP L754)
641   L641
641   (CONST 8)                           ; $INFINITY
642   (SKIP 2)
644   (JMP L754)
647   L647
647   (GETVALUE&PUSH 22)                  ; VAL
649   (JMPIFEQTO 8 L631)                  ; $INFINITY
652   (NIL&PUSH)
653   (LOAD&PUSH 10)
654   (CALL1&PUSH 40)                     ; TRISPLIT
656   (LOAD&CAR&STORE 0 1)
659   (LOAD&CDR&STORE 0)
661   (LOAD&PUSH 1)
662   (GETVALUE&PUSH 21)                  ; VAR
664   (GETVALUE&PUSH 41)                  ; ORIGVAL
666   (NIL&PUSH)
667   (CALL 4 13)                         ; LIMIT
670   (STORE 1)
671   (PUSH)
672   (JMPIFEQTO 7 L635)                  ; $MINF
675   (LOAD&PUSH 1)
676   (JMPIFNOTEQTO 4 L693)               ; $INF
679   (LOAD&PUSH 0)
680   (GETVALUE&PUSH 21)                  ; VAR
682   (GETVALUE&PUSH 41)                  ; ORIGVAL
684   (NIL&PUSH)
685   (CALL&PUSH 4 13)                    ; LIMIT
688   (CALL1&PUSH 35)                     ; RIDOFAB
690   (JMPIFNOTEQTO 6 L641)               ; 0
693   L693
693   (CONST 9)                           ; $IND
694   (SKIP 2)
696   (JMP L754)
698   L698
698   (CONST 9)                           ; $IND
699   (JMP L754)
701   L701
701   (CONST 24)                          ; 1
703   (JMP L754)
705   L705
705   (GETVALUE&PUSH 1)                   ; BL
707   (CALL1&PUSH 35)                     ; RIDOFAB
709   (JMPIFNOTEQTO 15 L720)              ; -1
713   (LOAD&PUSH 7)
714   (GETVALUE&PUSH 38)                  ; INFINITIES
716   (CALL2&JMPIF 26 L530)               ; MEMQ
720   L720
720   (GETVALUE&PUSH 1)                   ; BL
722   (JMPIFEQTO 9 L542)                  ; $IND
726   (LOAD&PUSH 7)
727   (JMPIFEQTO 4 L581)                  ; $INF
731   (LOAD&PUSH 7)
732   (JMPIFEQTO 7 L616)                  ; $MINF
736   (LOAD&PUSH 7)
737   (JMPIFEQTO 8 L647)                  ; $INFINITY
741   (LOAD&PUSH 7)
742   (JMPIFEQTO 9 L698)                  ; $IND
745   (LOAD&PUSH 7)
746   (CALL1&JMPIF 3 L701)                ; ZEROP2
749   (GETVALUE&PUSH 1)                   ; BL
751   (LOAD&PUSH 8)
752   (CALL2 42)                          ; POWER*
754   L754
754   (UNBIND 2)
756   (SKIP&RET 5)


Disassembly of function #:|(DEFUN EVEN1 (X) ...)-99|
(CONST 0) = EVEN1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE EVEN1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; EVEN1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; EVEN1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE EVEN1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; EVEN1
8     (SKIP&RET 1)


Disassembly of function EVEN1
(CONST 0) = X
(CONST 1) = MNUMP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
23 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE&PUSH 0)                   ; X
5     (CALLS2&JMPIF 8 L25)                ; NUMBERP
8     (GETVALUE&PUSH 0)                   ; X
10    (CALL1&JMPIFNOT 1 L21)              ; MNUMP
13    (GETVALUE 0)                        ; X
15    (CDR)
16    (CAR&PUSH)
17    (CALLS2 149)                        ; EVENP
19    (JMPIF1 L22)
21    L21
21    (NIL)
22    L22
22    (UNBIND1)
23    (SKIP&RET 2)
25    L25
25    (GETVALUE&PUSH 0)                   ; X
27    (CALLS2 12)                         ; INTEGERP
29    (JMPIFNOT1 L22)
31    (GETVALUE&PUSH 0)                   ; X
33    (CALLS2 149)                        ; EVENP
35    (JMP L22)


Disassembly of function #:|(DEFUN ABLESS1 (BL) ...)-100|
(CONST 0) = ABLESS1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ABLESS1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ABLESS1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ABLESS1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ABLESS1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ABLESS1
8     (SKIP&RET 1)


Disassembly of function ABLESS1
(CONST 0) = BL
(CONST 1) = NMR
(CONST 2) = MNUMP
(CONST 3) = 1
(CONST 4) = RATGREATERP
(CONST 5) = -1
(CONST 6) = (MABS)
(CONST 7) = ADD*
(CONST 8) = GETSIGNL
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (BL)
writes special variable : (BL)
27 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; BL
3     (GETVALUE&PUSH 0)                   ; BL
5     (CALL1 1)                           ; NMR
7     (SETVALUE 0)                        ; BL
9     (PUSH)
10    (CALL1&JMPIF 2 L28)                 ; MNUMP
13    (CONST&PUSH 5)                      ; -1
14    (CONST&PUSH 6)                      ; (MABS)
15    (GETVALUE&PUSH 0)                   ; BL
17    (LIST&PUSH 2)
19    (CALL2&PUSH 7)                      ; ADD*
21    (CALL1&PUSH 8)                      ; GETSIGNL
23    (CONST 5)                           ; -1
24    (EQ)
25    L25
25    (UNBIND1)
26    (SKIP&RET 2)
28    L28
28    (CONST&PUSH 3)                      ; 1
29    (GETVALUE&PUSH 0)                   ; BL
31    (CALL2 4)                           ; RATGREATERP
33    (JMPIFNOT1 L25)
35    (GETVALUE&PUSH 0)                   ; BL
37    (CONST&PUSH 5)                      ; -1
38    (CALL2 4)                           ; RATGREATERP
40    (JMP L25)


Disassembly of function #:|(DEFMFUN SIMPLIMIT (EXP VAR VAL) ...)-101|
(CONST 0) = SIMPLIMIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMIT
8     (SKIP&RET 1)


Disassembly of function SIMPLIMIT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = MNUMP
(CONST 4) = INFINITIES
(CONST 5) = MEMQ
(CONST 6) = (%SIN %COS %ATANH %COSH %SINH %TANH MFACTORIAL)
(CONST 7) = AMONGL
(CONST 8) = SIMPLIMSUBST
(CONST 9) = %LIMIT
(CONST 10) = LIMIT
(CONST 11) = MPLUSP
(CONST 12) = SIMPLIMPLUS
(CONST 13) = MTIMESP
(CONST 14) = SIMPLIMTIMES
(CONST 15) = MEXPTP
(CONST 16) = THINK
(CONST 17) = SIMPLIMEXPT
(CONST 18) = MLOGP
(CONST 19) = SIMPLIMLN
(CONST 20) = (%SIN %COS)
(CONST 21) = SIMPLIMSC
(CONST 22) = %TAN
(CONST 23) = SIMPLIM%TAN
(CONST 24) = %ATAN
(CONST 25) = SIMPLIM%ATAN
(CONST 26) = (%SINH %COSH)
(CONST 27) = SIMPLIMSCH
(CONST 28) = MFACTORIAL
(CONST 29) = SIMPLIMFACT
(CONST 30) = (%ERF %TANH)
(CONST 31) = SIMPLIM%ERF-%TANH
(CONST 32) = (%ACOS %ASIN)
(CONST 33) = SIMPLIM%ASIN-%ACOS
(CONST 34) = %ATANH
(CONST 35) = SIMPLIM%ATANH
(CONST 36) = %ACOSH
(CONST 37) = SIMPLIM%ACOSH
(CONST 38) = %ASINH
(CONST 39) = SIMPLIM%ASINH
(CONST 40) = %INVERSE_JACOBI_NS
(CONST 41) = SIMPLIM%INVERSE_JACOBI_NS
(CONST 42) = %INVERSE_JACOBI_NC
(CONST 43) = SIMPLIM%INVERSE_JACOBI_NC
(CONST 44) = %INVERSE_JACOBI_SC
(CONST 45) = SIMPLIM%INVERSE_JACOBI_SC
(CONST 46) = %INVERSE_JACOBI_CS
(CONST 47) = SIMPLIM%INVERSE_JACOBI_CS
(CONST 48) = %INVERSE_JACOBI_DC
(CONST 49) = SIMPLIM%INVERSE_JACOBI_DC
(CONST 50) = %INVERSE_JACOBI_DS
(CONST 51) = SIMPLIM%INVERSE_JACOBI_DS
(CONST 52) = MQAPPLY
(CONST 53) = SUBFUNNAME
(CONST 54) = $LI
(CONST 55) = SUBFUNSUBS
(CONST 56) = SUBFUNARGS
(CONST 57) = SIMPLIM$LI
(CONST 58) = $PSI
(CONST 59) = SIMPLIM$PSI
(CONST 60) = ARRAY
(CONST 61) = #<COMPILED-CLOSURE SIMPLIMIT-1>
(CONST 62) = ANDMAPC
(CONST 63) = $LIMSUBST
(CONST 64) = A
(CONST 65) = SIMPLIFY
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (A $LIMSUBST INFINITIES VAL EXP VAR)
453 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 1)                   ; VAR
11    (GETVALUE 0)                        ; EXP
13    (JMPIFEQ L308)
16    (GETVALUE 0)                        ; EXP
18    (JMPIFATOM L313)
21    (GETVALUE&PUSH 0)                   ; EXP
23    (CALL1&JMPIF 3 L313)                ; MNUMP
27    (GETVALUE&PUSH 2)                   ; VAL
29    (GETVALUE&PUSH 4)                   ; INFINITIES
31    (CALL2&JMPIF 5 L58)                 ; MEMQ
34    (CONST&PUSH 6)                      ; (%SIN %COS %ATANH %COSH %SINH ...)
35    (GETVALUE&PUSH 0)                   ; EXP
37    (CALL2&JMPIF 7 L58)                 ; AMONGL
40    (GETVALUE&PUSH 4)                   ; INFINITIES
42    (GETVALUE&PUSH 0)                   ; EXP
44    (CALL2 7)                           ; AMONGL
46    (CAR)
47    (JMPIF L58)
49    (GETVALUE&PUSH 2)                   ; VAL
51    (GETVALUE&PUSH 0)                   ; EXP
53    (CALL2 8)                           ; SIMPLIMSUBST
55    (JMPIF1 L784)
58    L58
58    (GETVALUE 0)                        ; EXP
60    (CAR)
61    (CAR&PUSH)
62    (JMPIFEQTO 9 L318)                  ; %LIMIT
66    (GETVALUE&PUSH 0)                   ; EXP
68    (CALL1&JMPIF 11 L321)               ; MPLUSP
72    (GETVALUE&PUSH 0)                   ; EXP
74    (CALL1&JMPIF 13 L328)               ; MTIMESP
78    (GETVALUE&PUSH 0)                   ; EXP
80    (CALL1&JMPIF 15 L336)               ; MEXPTP
84    (GETVALUE&PUSH 0)                   ; EXP
86    (CALL1&JMPIF 18 L376)               ; MLOGP
90    (GETVALUE 0)                        ; EXP
92    (CAR)
93    (CAR&PUSH)
94    (CONST&PUSH 20)                     ; (%SIN %COS)
95    (CALL2&JMPIF 5 L385)                ; MEMQ
99    (GETVALUE 0)                        ; EXP
101   (CAR)
102   (CAR&PUSH)
103   (JMPIFEQTO 22 L409)                 ; %TAN
107   (GETVALUE 0)                        ; EXP
109   (CAR)
110   (CAR&PUSH)
111   (JMPIFEQTO 24 L418)                 ; %ATAN
115   (GETVALUE 0)                        ; EXP
117   (CAR)
118   (CAR&PUSH)
119   (CONST&PUSH 26)                     ; (%SINH %COSH)
120   (CALL2&JMPIF 5 L435)                ; MEMQ
124   (GETVALUE 0)                        ; EXP
126   (CAR)
127   (CAR&PUSH)
128   (JMPIFEQTO 28 L456)                 ; MFACTORIAL
132   (GETVALUE 0)                        ; EXP
134   (CAR)
135   (CAR&PUSH)
136   (CONST&PUSH 30)                     ; (%ERF %TANH)
138   (CALL2&JMPIF 5 L482)                ; MEMQ
142   (GETVALUE 0)                        ; EXP
144   (CAR)
145   (CAR&PUSH)
146   (CONST&PUSH 32)                     ; (%ACOS %ASIN)
148   (CALL2&JMPIF 5 L495)                ; MEMQ
152   (GETVALUE 0)                        ; EXP
154   (CAR)
155   (CAR&PUSH)
156   (JMPIFEQTO 34 L516)                 ; %ATANH
160   (GETVALUE 0)                        ; EXP
162   (CAR)
163   (CAR&PUSH)
164   (JMPIFEQTO 36 L533)                 ; %ACOSH
168   (GETVALUE 0)                        ; EXP
170   (CAR)
171   (CAR&PUSH)
172   (JMPIFEQTO 38 L550)                 ; %ASINH
176   (GETVALUE 0)                        ; EXP
178   (CAR)
179   (CAR&PUSH)
180   (JMPIFEQTO 40 L567)                 ; %INVERSE_JACOBI_NS
184   (GETVALUE 0)                        ; EXP
186   (CAR)
187   (CAR&PUSH)
188   (JMPIFEQTO 42 L589)                 ; %INVERSE_JACOBI_NC
192   (GETVALUE 0)                        ; EXP
194   (CAR)
195   (CAR&PUSH)
196   (JMPIFEQTO 44 L611)                 ; %INVERSE_JACOBI_SC
200   (GETVALUE 0)                        ; EXP
202   (CAR)
203   (CAR&PUSH)
204   (JMPIFEQTO 46 L633)                 ; %INVERSE_JACOBI_CS
208   (GETVALUE 0)                        ; EXP
210   (CAR)
211   (CAR&PUSH)
212   (JMPIFEQTO 48 L655)                 ; %INVERSE_JACOBI_DC
216   (GETVALUE 0)                        ; EXP
218   (CAR)
219   (CAR&PUSH)
220   (JMPIFEQTO 50 L677)                 ; %INVERSE_JACOBI_DS
224   (GETVALUE 0)                        ; EXP
226   (CAR)
227   (CAR&PUSH)
228   (JMPIFNOTEQTO 52 L239)              ; MQAPPLY
231   (GETVALUE&PUSH 0)                   ; EXP
233   (CALL1&PUSH 53)                     ; SUBFUNNAME
235   (JMPIFEQTO 54 L699)                 ; $LI
239   L239
239   (GETVALUE 0)                        ; EXP
241   (CAR)
242   (CAR&PUSH)
243   (JMPIFNOTEQTO 52 L254)              ; MQAPPLY
246   (GETVALUE&PUSH 0)                   ; EXP
248   (CALL1&PUSH 53)                     ; SUBFUNNAME
250   (JMPIFEQTO 58 L715)                 ; $PSI
254   L254
254   (GETVALUE 0)                        ; EXP
256   (CAR)
257   (CAR&PUSH)
258   (GETVALUE 1)                        ; VAR
260   (JMPIFNOTEQ L279)
262   (CONST&PUSH 60)                     ; ARRAY
264   (GETVALUE 0)                        ; EXP
266   (CAR&PUSH)
267   (CALL2&JMPIFNOT 5 L279)             ; MEMQ
270   (CONST&PUSH 61)                     ; #<COMPILED-CLOSURE SIMPLIMIT-1>
272   (GETVALUE 0)                        ; EXP
274   (CDR&PUSH)
275   (CALL2&JMPIF 62 L730)               ; ANDMAPC
279   L279
279   (GETVALUE 63)                       ; $LIMSUBST
281   (JMPIFNOT1 L784)
284   (CONST&PUSH 60)                     ; ARRAY
286   (GETVALUE 0)                        ; EXP
288   (CAR&PUSH)
289   (CALL2&JMPIF 5 L734)                ; MEMQ
293   (GETVALUE 0)                        ; EXP
295   (CAR)
296   (CAR&PUSH)
297   (LIST 1)
299   L299
299   (PUSH)
300   (LOAD&PUSH 0)
301   (NIL&PUSH)
302   (GETVALUE 0)                        ; EXP
304   (CDR&PUSH)
305   (JMP L768)
308   L308
308   (GETVALUE 2)                        ; VAL
310   (JMP L784)
313   L313
313   (GETVALUE 0)                        ; EXP
315   (JMP L784)
318   L318
318   (CONST&PUSH 10)                     ; LIMIT
319   (T)
320   (THROW)
321   L321
321   (GETVALUE&PUSH 0)                   ; EXP
323   (CALL1 12)                          ; SIMPLIMPLUS
325   (JMP L784)
328   L328
328   (GETVALUE 0)                        ; EXP
330   (CDR&PUSH)
331   (CALL1 14)                          ; SIMPLIMTIMES
333   (JMP L784)
336   L336
336   (GETVALUE 0)                        ; EXP
338   (CDR)
339   (CAR&PUSH)
340   (GETVALUE 0)                        ; EXP
342   (CDR)
343   (CDR)
344   (CAR&PUSH)
345   (GETVALUE 0)                        ; EXP
347   (CDR)
348   (CAR&PUSH)
349   (GETVALUE&PUSH 1)                   ; VAR
351   (GETVALUE&PUSH 2)                   ; VAL
353   (CONST&PUSH 16)                     ; THINK
354   (CALL&PUSH 4 10)                    ; LIMIT
357   (GETVALUE 0)                        ; EXP
359   (CDR)
360   (CDR)
361   (CAR&PUSH)
362   (GETVALUE&PUSH 1)                   ; VAR
364   (GETVALUE&PUSH 2)                   ; VAL
366   (CONST&PUSH 16)                     ; THINK
367   (CALL&PUSH 4 10)                    ; LIMIT
370   (CALL 4 17)                         ; SIMPLIMEXPT
373   (JMP L784)
376   L376
376   (GETVALUE 0)                        ; EXP
378   (CDR)
379   (CAR&PUSH)
380   (CALL1 19)                          ; SIMPLIMLN
382   (JMP L784)
385   L385
385   (GETVALUE&PUSH 0)                   ; EXP
387   (GETVALUE 0)                        ; EXP
389   (CAR)
390   (CAR&PUSH)
391   (GETVALUE 0)                        ; EXP
393   (CDR)
394   (CAR&PUSH)
395   (GETVALUE&PUSH 1)                   ; VAR
397   (GETVALUE&PUSH 2)                   ; VAL
399   (CONST&PUSH 16)                     ; THINK
400   (CALL&PUSH 4 10)                    ; LIMIT
403   (CALL 3 21)                         ; SIMPLIMSC
406   (JMP L784)
409   L409
409   (GETVALUE 0)                        ; EXP
411   (CDR)
412   (CAR&PUSH)
413   (CALL1 23)                          ; SIMPLIM%TAN
415   (JMP L784)
418   L418
418   (GETVALUE 0)                        ; EXP
420   (CDR)
421   (CAR&PUSH)
422   (GETVALUE&PUSH 1)                   ; VAR
424   (GETVALUE&PUSH 2)                   ; VAL
426   (CONST&PUSH 16)                     ; THINK
427   (CALL&PUSH 4 10)                    ; LIMIT
430   (CALL1 25)                          ; SIMPLIM%ATAN
432   (JMP L784)
435   L435
435   (GETVALUE 0)                        ; EXP
437   (CAR)
438   (CAR&PUSH)
439   (GETVALUE 0)                        ; EXP
441   (CDR)
442   (CAR&PUSH)
443   (GETVALUE&PUSH 1)                   ; VAR
445   (GETVALUE&PUSH 2)                   ; VAL
447   (CONST&PUSH 16)                     ; THINK
448   (CALL&PUSH 4 10)                    ; LIMIT
451   (CALL2 27)                          ; SIMPLIMSCH
453   (JMP L784)
456   L456
456   (GETVALUE 0)                        ; EXP
458   (CDR)
459   (CAR&PUSH)
460   (GETVALUE&PUSH 1)                   ; VAR
462   (GETVALUE&PUSH 2)                   ; VAL
464   (GETVALUE 0)                        ; EXP
466   (CDR)
467   (CAR&PUSH)
468   (GETVALUE&PUSH 1)                   ; VAR
470   (GETVALUE&PUSH 2)                   ; VAL
472   (CONST&PUSH 16)                     ; THINK
473   (CALL&PUSH 4 10)                    ; LIMIT
476   (CALL 4 29)                         ; SIMPLIMFACT
479   (JMP L784)
482   L482
482   (GETVALUE 0)                        ; EXP
484   (CAR)
485   (CAR&PUSH)
486   (GETVALUE 0)                        ; EXP
488   (CDR)
489   (CAR&PUSH)
490   (CALL2 31)                          ; SIMPLIM%ERF-%TANH
492   (JMP L784)
495   L495
495   (GETVALUE 0)                        ; EXP
497   (CAR)
498   (CAR&PUSH)
499   (GETVALUE 0)                        ; EXP
501   (CDR)
502   (CAR&PUSH)
503   (GETVALUE&PUSH 1)                   ; VAR
505   (GETVALUE&PUSH 2)                   ; VAL
507   (CONST&PUSH 16)                     ; THINK
508   (CALL&PUSH 4 10)                    ; LIMIT
511   (CALL2 33)                          ; SIMPLIM%ASIN-%ACOS
513   (JMP L784)
516   L516
516   (GETVALUE 0)                        ; EXP
518   (CDR)
519   (CAR&PUSH)
520   (GETVALUE&PUSH 1)                   ; VAR
522   (GETVALUE&PUSH 2)                   ; VAL
524   (CONST&PUSH 16)                     ; THINK
525   (CALL&PUSH 4 10)                    ; LIMIT
528   (CALL1 35)                          ; SIMPLIM%ATANH
530   (JMP L784)
533   L533
533   (GETVALUE 0)                        ; EXP
535   (CDR)
536   (CAR&PUSH)
537   (GETVALUE&PUSH 1)                   ; VAR
539   (GETVALUE&PUSH 2)                   ; VAL
541   (CONST&PUSH 16)                     ; THINK
542   (CALL&PUSH 4 10)                    ; LIMIT
545   (CALL1 37)                          ; SIMPLIM%ACOSH
547   (JMP L784)
550   L550
550   (GETVALUE 0)                        ; EXP
552   (CDR)
553   (CAR&PUSH)
554   (GETVALUE&PUSH 1)                   ; VAR
556   (GETVALUE&PUSH 2)                   ; VAL
558   (CONST&PUSH 16)                     ; THINK
559   (CALL&PUSH 4 10)                    ; LIMIT
562   (CALL1 39)                          ; SIMPLIM%ASINH
564   (JMP L784)
567   L567
567   (GETVALUE 0)                        ; EXP
569   (CDR)
570   (CAR&PUSH)
571   (GETVALUE&PUSH 1)                   ; VAR
573   (GETVALUE&PUSH 2)                   ; VAL
575   (CONST&PUSH 16)                     ; THINK
576   (CALL&PUSH 4 10)                    ; LIMIT
579   (GETVALUE 0)                        ; EXP
581   (CDR)
582   (CDR)
583   (CAR&PUSH)
584   (CALL2 41)                          ; SIMPLIM%INVERSE_JACOBI_NS
586   (JMP L784)
589   L589
589   (GETVALUE 0)                        ; EXP
591   (CDR)
592   (CAR&PUSH)
593   (GETVALUE&PUSH 1)                   ; VAR
595   (GETVALUE&PUSH 2)                   ; VAL
597   (CONST&PUSH 16)                     ; THINK
598   (CALL&PUSH 4 10)                    ; LIMIT
601   (GETVALUE 0)                        ; EXP
603   (CDR)
604   (CDR)
605   (CAR&PUSH)
606   (CALL2 43)                          ; SIMPLIM%INVERSE_JACOBI_NC
608   (JMP L784)
611   L611
611   (GETVALUE 0)                        ; EXP
613   (CDR)
614   (CAR&PUSH)
615   (GETVALUE&PUSH 1)                   ; VAR
617   (GETVALUE&PUSH 2)                   ; VAL
619   (CONST&PUSH 16)                     ; THINK
620   (CALL&PUSH 4 10)                    ; LIMIT
623   (GETVALUE 0)                        ; EXP
625   (CDR)
626   (CDR)
627   (CAR&PUSH)
628   (CALL2 45)                          ; SIMPLIM%INVERSE_JACOBI_SC
630   (JMP L784)
633   L633
633   (GETVALUE 0)                        ; EXP
635   (CDR)
636   (CAR&PUSH)
637   (GETVALUE&PUSH 1)                   ; VAR
639   (GETVALUE&PUSH 2)                   ; VAL
641   (CONST&PUSH 16)                     ; THINK
642   (CALL&PUSH 4 10)                    ; LIMIT
645   (GETVALUE 0)                        ; EXP
647   (CDR)
648   (CDR)
649   (CAR&PUSH)
650   (CALL2 47)                          ; SIMPLIM%INVERSE_JACOBI_CS
652   (JMP L784)
655   L655
655   (GETVALUE 0)                        ; EXP
657   (CDR)
658   (CAR&PUSH)
659   (GETVALUE&PUSH 1)                   ; VAR
661   (GETVALUE&PUSH 2)                   ; VAL
663   (CONST&PUSH 16)                     ; THINK
664   (CALL&PUSH 4 10)                    ; LIMIT
667   (GETVALUE 0)                        ; EXP
669   (CDR)
670   (CDR)
671   (CAR&PUSH)
672   (CALL2 49)                          ; SIMPLIM%INVERSE_JACOBI_DC
674   (JMP L784)
677   L677
677   (GETVALUE 0)                        ; EXP
679   (CDR)
680   (CAR&PUSH)
681   (GETVALUE&PUSH 1)                   ; VAR
683   (GETVALUE&PUSH 2)                   ; VAL
685   (CONST&PUSH 16)                     ; THINK
686   (CALL&PUSH 4 10)                    ; LIMIT
689   (GETVALUE 0)                        ; EXP
691   (CDR)
692   (CDR)
693   (CAR&PUSH)
694   (CALL2 51)                          ; SIMPLIM%INVERSE_JACOBI_DS
696   (JMP L784)
699   L699
699   (GETVALUE&PUSH 0)                   ; EXP
701   (CALL1&PUSH 55)                     ; SUBFUNSUBS
703   (GETVALUE&PUSH 0)                   ; EXP
705   (CALL1&PUSH 56)                     ; SUBFUNARGS
707   (GETVALUE&PUSH 2)                   ; VAL
709   (CALL 3 57)                         ; SIMPLIM$LI
712   (JMP L784)
715   L715
715   (GETVALUE&PUSH 0)                   ; EXP
717   (CALL1&PUSH 55)                     ; SUBFUNSUBS
719   (GETVALUE&PUSH 0)                   ; EXP
721   (CALL1&PUSH 56)                     ; SUBFUNARGS
723   (GETVALUE&PUSH 2)                   ; VAL
725   (CALL 3 59)                         ; SIMPLIM$PSI
728   (JMP L784)
730   L730
730   (GETVALUE 0)                        ; EXP
732   (JMP L784)
734   L734
734   (GETVALUE 0)                        ; EXP
736   (CAR)
737   (CAR&PUSH)
738   (CONST&PUSH 60)                     ; ARRAY
740   (LIST 2)
742   (JMP L299)
745   L745
745   (LOAD&CAR&PUSH 0)
747   (LOAD 0)
748   (BIND 64)                           ; A
750   (GETVALUE&PUSH 64)                  ; A
752   (GETVALUE&PUSH 1)                   ; VAR
754   (GETVALUE&PUSH 2)                   ; VAL
756   (CONST&PUSH 16)                     ; THINK
757   (CALL 4 10)                         ; LIMIT
760   (UNBIND1)
761   (PUSH)
762   (LOAD&CONS&STORE 2)
764   (SKIP 1)
766   (LOAD&CDR&STORE 0)
768   L768
768   (LOAD&PUSH 0)
769   (CALLS1&JMPIFNOT 146 L745)          ; ENDP
772   (SKIP 1)
774   (LOAD&PUSH 0)
775   (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
777   (SKIP 1)
779   (CONS&PUSH)
780   (CALL1 65)                          ; SIMPLIFY
782   (SKIP 1)
784   L784
784   (UNBIND 3)
786   (SKIP&RET 4)


Disassembly of function SIMPLIMIT-1
(CONST 0) = VAR
(CONST 1) = FREE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (VAR)
4 byte-code instructions:
0     (LOAD&PUSH 1)
1     (GETVALUE&PUSH 0)                   ; VAR
3     (CALL2 1)                           ; FREE
5     (SKIP&RET 2)


Disassembly of function #:|(DEFUN LIMINV (E) ...)-102|
(CONST 0) = LIMINV
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LIMINV>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LIMINV
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LIMINV
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LIMINV>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LIMINV
8     (SKIP&RET 1)


Disassembly of function LIMINV
(CONST 0) = E
(CONST 1) = 1
(CONST 2) = VAR
(CONST 3) = DIV*
(CONST 4) = RESIMPLIFY
(CONST 5) = VAL
(CONST 6) = $ZEROA
(CONST 7) = $INF
(CONST 8) = $ZEROB
(CONST 9) = $MINF
(CONST 10) = PRESERVE-DIRECTION
(CONST 11) = $LIMIT
(CONST 12) = LIMIT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL E VAR)
writes special variable : (E)
39 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (CONST&PUSH 1)                      ; 1
4     (GETVALUE&PUSH 2)                   ; VAR
6     (CALL2&PUSH 3)                      ; DIV*
8     (GETVALUE&PUSH 2)                   ; VAR
10    (GETVALUE&PUSH 0)                   ; E
12    (PUSH-UNBOUND 3)
14    (CALLS1&PUSH 172)                   ; SUBST
16    (CALL1 4)                           ; RESIMPLIFY
18    (SETVALUE 0)                        ; E
20    (GETVALUE&PUSH 5)                   ; VAL
22    (JMPIFEQTO 6 L52)                   ; $ZEROA
25    (GETVALUE&PUSH 5)                   ; VAL
27    (JMPIFEQTO 8 L55)                   ; $ZEROB
30    (NIL)
31    L31
31    (PUSH)
32    (LOAD&JMPIFNOT 0 L58)
35    (T)
36    (BIND 10)                           ; PRESERVE-DIRECTION
38    (GETVALUE&PUSH 0)                   ; E
40    (GETVALUE&PUSH 2)                   ; VAR
42    (LOAD&PUSH 5)
43    (CALL 3 11)                         ; $LIMIT
46    (UNBIND1)
47    (SKIP 1)
49    (UNBIND1)
50    (SKIP&RET 2)
52    L52
52    (CONST 7)                           ; $INF
53    (JMP L31)
55    L55
55    (CONST 9)                           ; $MINF
56    (JMP L31)
58    L58
58    (CONST&PUSH 12)                     ; LIMIT
59    (T)
60    (THROW)


Disassembly of function #:|(DEFUN SIMPLIMTIMES (EXP) ...)-103|
(CONST 0) = SIMPLIMTIMES
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMTIMES>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMTIMES
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMTIMES
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMTIMES>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMTIMES
8     (SKIP&RET 1)


Disassembly of function SIMPLIMTIMES
(CONST 0) = EXP
(CONST 1) = SIGN
(CONST 2) = Y
(CONST 3) = NUM
(CONST 4) = DENOM
(CONST 5) = FLAG
(CONST 6) = EXP1
(CONST 7) = 1
(CONST 8) = (%LOG)
(CONST 9) = INVOLVE
(CONST 10) = LOGINPROD?
(CONST 11) = LIP?
(CONST 12) = VAR
(CONST 13) = VAL
(CONST 14) = THINK
(CONST 15) = LIMIT
(CONST 16) = LIP!
(CONST 17) = (MTIMES SIMP)
(CONST 18) = LIMINV
(CONST 19) = ZEROP2
(CONST 20) = MUL*
(CONST 21) = $ZEROA
(CONST 22) = $ZEROB
(CONST 23) = -1
(CONST 24) = ($INF $MINF $INFINITY $IND $UND)
(CONST 25) = MEMQ
(CONST 26) = $UND
(CONST 27) = $IND
(CONST 28) = $INFINITY
(CONST 29) = $INF
(CONST 30) = $MINF
(CONST 31) = 0
(CONST 32) = GETSIGNL
(CONST 33) = COMPLEX
(CONST 34) = AMONG
(CONST 35) = POWER*
(CONST 36) = LIMIT2
(CONST 37) = ANS
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (SIGN ANS NUM FLAG DENOM Y VAL VAR EXP1 EXP)
writes special variables : (SIGN FLAG Y EXP1 NUM DENOM)
248 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL)
4     (BIND 1)                            ; SIGN
6     (NIL&PUSH)
7     (NIL)
8     (BIND 2)                            ; Y
10    (NIL)
11    (BIND 3)                            ; NUM
13    (NIL)
14    (BIND 4)                            ; DENOM
16    (NIL)
17    (BIND 5)                            ; FLAG
19    (PUSH-NIL 2)
21    (NIL)
22    (BIND 6)                            ; EXP1
24    (CONST 7)                           ; 1
25    (SETVALUE 4)                        ; DENOM
27    (SETVALUE 3)                        ; NUM
29    (STORE 17)
31    (GETVALUE 0)                        ; EXP
33    (SETVALUE 6)                        ; EXP1
35    L35
35    (GETVALUE 6)                        ; EXP1
37    (CAR&PUSH)
38    (CONST&PUSH 8)                      ; (%LOG)
39    (CALL2 9)                           ; INVOLVE
41    (BIND 10)                           ; LOGINPROD?
43    (CONST 11)                          ; LIP?
44    (CATCH-OPEN L58)
46    (GETVALUE 6)                        ; EXP1
48    (CAR&PUSH)
49    (GETVALUE&PUSH 12)                  ; VAR
51    (GETVALUE&PUSH 13)                  ; VAL
53    (CONST&PUSH 14)                     ; THINK
54    (CALL 4 15)                         ; LIMIT
57    (CATCH-CLOSE)
58    L58
58    (UNBIND1)
59    (SETVALUE 2)                        ; Y
61    (PUSH)
62    (JMPIFEQTO 16 L215)                 ; LIP!
66    (GETVALUE&PUSH 2)                   ; Y
68    (CALL1&JMPIF 19 L240)               ; ZEROP2
72    (GETVALUE&PUSH 2)                   ; Y
74    (CONST&PUSH 24)                     ; ($INF $MINF $INFINITY $IND $UND)
75    (CALL2&JMPIFNOT 25 L269)            ; MEMQ
79    (GETVALUE&PUSH 2)                   ; Y
81    (JMPIFEQTO 26 L279)                 ; $UND
85    (GETVALUE&PUSH 2)                   ; Y
87    (JMPIFEQTO 27 L284)                 ; $IND
91    (GETVALUE&PUSH 4)                   ; DENOM
93    (GETVALUE 6)                        ; EXP1
95    (CAR&PUSH)
96    (CALL2 20)                          ; MUL*
98    (SETVALUE 4)                        ; DENOM
100   (GETVALUE&PUSH 2)                   ; Y
102   (JMPIFEQTO 28 L289)                 ; $INFINITY
106   (GETVALUE&PUSH 5)                   ; FLAG
108   (JMPIFEQTO 28 L127)                 ; $INFINITY
111   (GETVALUE 5)                        ; FLAG
113   (JMPIFNOT L289)
116   (GETVALUE&PUSH 2)                   ; Y
118   (GETVALUE 5)                        ; FLAG
120   (JMPIFEQ L296)
123   (CONST 30)                          ; $MINF
125   (SETVALUE 5)                        ; FLAG
127   L127
127   (GETVALUE 6)                        ; EXP1
129   (CDR)
130   (SETVALUE 6)                        ; EXP1
132   (JMPIF L35)
135   (GETVALUE&PUSH 3)                   ; NUM
137   (JMPIFNOTEQTO 7 L146)               ; 1
140   (GETVALUE&PUSH 4)                   ; DENOM
142   (JMPIFEQTO 7 L308)                  ; 1
146   L146
146   (GETVALUE&PUSH 4)                   ; DENOM
148   (JMPIFEQTO 7 L354)                  ; 1
152   (GETVALUE&PUSH 3)                   ; NUM
154   (JMPIFEQTO 7 L416)                  ; 1
158   (GETVALUE&PUSH 12)                  ; VAR
160   (GETVALUE&PUSH 4)                   ; DENOM
162   (CALL2&JMPIFNOT 34 L442)            ; AMONG
166   (GETVALUE&PUSH 12)                  ; VAR
168   (GETVALUE&PUSH 3)                   ; NUM
170   (CALL2&JMPIFNOT 34 L442)            ; AMONG
174   (GETVALUE&PUSH 3)                   ; NUM
176   (GETVALUE&PUSH 4)                   ; DENOM
178   (CONST&PUSH 23)                     ; -1
179   (CALL2&PUSH 35)                     ; POWER*
181   (GETVALUE&PUSH 12)                  ; VAR
183   (GETVALUE&PUSH 13)                  ; VAL
185   (CALL 4 36)                         ; LIMIT2
188   (BIND 37)                           ; ANS
190   (GETVALUE 37)                       ; ANS
192   (JMPIFNOT L445)
195   (LOAD&PUSH 20)
196   (GETVALUE&PUSH 37)                  ; ANS
198   (LIST&PUSH 2)
200   (JSR L0)
203   (UNBIND1)
204   L204
204   (UNBIND1)
205   (SKIP 2)
207   (UNBIND 4)
209   (SKIP 1)
211   (UNBIND1)
212   L212
212   (UNBIND1)
213   (SKIP&RET 2)
215   L215
215   (CONST&PUSH 17)                     ; (MTIMES SIMP)
216   (GETVALUE 0)                        ; EXP
218   (CONS&PUSH)
219   (CALL1 18)                          ; LIMINV
221   (JMP L204)
223   L223
223   (LOAD&JMPIF 4 L127)
227   (CONST 7)                           ; 1
228   (STORE 4)
229   (JMP L127)
232   L232
232   (PUSH)
233   (CALLSR&STORE 0 54 4)               ; -
237   (JMP L127)
240   L240
240   (GETVALUE&PUSH 3)                   ; NUM
242   (GETVALUE 6)                        ; EXP1
244   (CAR&PUSH)
245   (CALL2 20)                          ; MUL*
247   (SETVALUE 3)                        ; NUM
249   (GETVALUE&PUSH 2)                   ; Y
251   (JMPIFEQTO 21 L223)                 ; $ZEROA
254   (GETVALUE&PUSH 2)                   ; Y
256   (JMPIFNOTEQTO 22 L127)              ; $ZEROB
260   (LOAD&JMPIF 4 L232)
263   (CONST 23)                          ; -1
265   (STORE 4)
266   (JMP L127)
269   L269
269   (LOAD&PUSH 17)
270   (GETVALUE&PUSH 2)                   ; Y
272   (CALL2 20)                          ; MUL*
274   (STORE 17)
276   (JMP L127)
279   L279
279   (CONST 26)                          ; $UND
281   (JMP L372)
284   L284
284   (T&STORE 3)
286   (JMP L127)
289   L289
289   (GETVALUE 2)                        ; Y
291   (SETVALUE 5)                        ; FLAG
293   (JMP L127)
296   L296
296   (CONST 29)                          ; $INF
298   (SETVALUE 5)                        ; FLAG
300   (JMP L127)
303   L303
303   (CONST 27)                          ; $IND
305   (JMP L204)
308   L308
308   (LOAD&JMPIF 3 L303)
311   (LOAD 17)
313   (JMP L204)
316   L316
316   (CONST 31)                          ; 0
318   (JMP L372)
320   L320
320   (CONST 31)                          ; 0
322   (JMP L372)
324   L324
324   (CONST 21)                          ; $ZEROA
326   (JMP L204)
329   L329
329   (CONST 22)                          ; $ZEROB
331   (JMP L204)
334   L334
334   (LOAD&PUSH 4)
335   (GETVALUE&PUSH 1)                   ; SIGN
337   (CALLSR&STORE 2 55 4)               ; *
341   (PUSH)
342   (JMPIFEQTO 7 L324)                  ; 1
345   (LOAD&PUSH 4)
346   (JMPIFEQTO 23 L329)                 ; -1
349   (CONST 31)                          ; 0
351   (JMP L204)
354   L354
354   (LOAD&JMPIFNOT 4 L316)
357   (LOAD&PUSH 17)
358   (CALL1 32)                          ; GETSIGNL
360   (SETVALUE 1)                        ; SIGN
362   (PUSH)
363   (JMPIFEQTO 33 L320)                 ; COMPLEX
366   (GETVALUE 1)                        ; SIGN
368   (JMPIF L334)
370   (CONST 31)                          ; 0
372   L372
372   (UNBIND1)
373   (SKIP 2)
375   (UNBIND 4)
377   (SKIP 1)
379   (UNBIND1)
380   (JMP L212)
383   L383
383   (CONST 26)                          ; $UND
385   (JMP L204)
388   L388
388   (CONST 15)                          ; LIMIT
389   (JMP L446)
391   L391
391   (CONST 30)                          ; $MINF
393   (JMP L204)
396   L396
396   (GETVALUE 5)                        ; FLAG
398   (JMP L204)
401   L401
401   (GETVALUE&PUSH 5)                   ; FLAG
403   (JMPIFEQTO 29 L391)                 ; $INF
406   (GETVALUE&PUSH 5)                   ; FLAG
408   (JMPIFEQTO 28 L396)                 ; $INFINITY
411   (CONST 29)                          ; $INF
413   (JMP L204)
416   L416
416   (LOAD&JMPIF 3 L383)
419   (LOAD&PUSH 17)
420   (CALL1 32)                          ; GETSIGNL
422   (SETVALUE 1)                        ; SIGN
424   (PUSH)
425   (JMPIFEQTO 31 L388)                 ; 0
428   (GETVALUE 1)                        ; SIGN
430   (JMPIFNOT L388)
432   (GETVALUE&PUSH 1)                   ; SIGN
434   (JMPIFEQTO 23 L401)                 ; -1
437   (GETVALUE 5)                        ; FLAG
439   (JMP L204)
442   L442
442   (CONST 15)                          ; LIMIT
443   (JMP L446)
445   L445
445   (CONST 15)                          ; LIMIT
446   L446
446   (PUSH)
447   (T)
448   (THROW)


Disassembly of function #:|(DEFUN SIMPLIMPLUS (EXP) ...)-104|
(CONST 0) = SIMPLIMPLUS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMPLUS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMPLUS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMPLUS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMPLUS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMPLUS
8     (SKIP&RET 1)


Disassembly of function SIMPLIMPLUS
(CONST 0) = EXP
(CONST 1) = SIMPLIMPLUS-PROBLEMS
(CONST 2) = MEMALIKE
(CONST 3) = LIMIT
(CONST 4) = SIMPLIMPLUS1
(CONST 5) = ANS
(CONST 6) = %LIMIT
(CONST 7) = AMONG
(CONST 8) = SRATSIMP
(CONST 9) = ALIKE1
(CONST 10) = VAR
(CONST 11) = VAL
(CONST 12) = THINK
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR ANS SIMPLIMPLUS-PROBLEMS EXP)
writes special variables : (ANS SIMPLIMPLUS-PROBLEMS)
72 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (GETVALUE&PUSH 1)                   ; SIMPLIMPLUS-PROBLEMS
7     (CALL2&JMPIF 2 L68)                 ; MEMALIKE
10    (UNWIND-PROTECT-OPEN L98)
13    (GETVALUE&PUSH 0)                   ; EXP
15    (GETVALUE 1)                        ; SIMPLIMPLUS-PROBLEMS
17    (CONS)
18    (SETVALUE 1)                        ; SIMPLIMPLUS-PROBLEMS
20    (CONST 3)                           ; LIMIT
21    (CATCH-OPEN L28)
23    (GETVALUE&PUSH 0)                   ; EXP
25    (CALL1 4)                           ; SIMPLIMPLUS1
27    (CATCH-CLOSE)
28    L28
28    (BIND 5)                            ; ANS
30    (GETVALUE 5)                        ; ANS
32    (JMPIFNOT L45)
34    (GETVALUE&PUSH 5)                   ; ANS
36    (T)
37    (JMPIFEQ L45)
39    (CONST&PUSH 6)                      ; %LIMIT
40    (GETVALUE&PUSH 5)                   ; ANS
42    (CALL2&JMPIFNOT 7 L94)              ; AMONG
45    L45
45    (GETVALUE&PUSH 0)                   ; EXP
47    (CALL1&PUSH 8)                      ; SRATSIMP
49    (GETVALUE&PUSH 0)                   ; EXP
51    (LOAD&PUSH 1)
52    (CALL2&JMPIFNOT 9 L71)              ; ALIKE1
55    (GETVALUE 5)                        ; ANS
57    (JMPIFNOT L64)
59    L59
59    (GETVALUE&PUSH 5)                   ; ANS
61    (T)
62    (JMPIFNOTEQ L88)
64    L64
64    (CONST 3)                           ; LIMIT
65    L65
65    (PUSH)
66    (T)
67    (THROW)
68    L68
68    (CONST 3)                           ; LIMIT
69    (JMP L65)
71    L71
71    (LOAD&PUSH 0)
72    (GETVALUE&PUSH 10)                  ; VAR
74    (GETVALUE&PUSH 11)                  ; VAL
76    (CONST&PUSH 12)                     ; THINK
77    (CALL 4 3)                          ; LIMIT
80    (SETVALUE 5)                        ; ANS
82    (GETVALUE 5)                        ; ANS
84    (JMPIFNOT L64)
86    (JMP L59)
88    L88
88    (GETVALUE 5)                        ; ANS
90    (SKIP 1)
92    (JMP L96)
94    L94
94    (GETVALUE 5)                        ; ANS
96    L96
96    (UNBIND1)
97    (UNWIND-PROTECT-NORMAL-EXIT)
98    L98
98    (GETVALUE 1)                        ; SIMPLIMPLUS-PROBLEMS
100   (CDR)
101   (SETVALUE 1)                        ; SIMPLIMPLUS-PROBLEMS
103   (UNWIND-PROTECT-CLOSE)
104   (UNBIND1)
105   (SKIP&RET 2)


Disassembly of function #:|(DEFUN SIMPLIMPLUS1 (EXP) ...)-105|
(CONST 0) = SIMPLIMPLUS1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMPLUS1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMPLUS1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMPLUS1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMPLUS1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMPLUS1
8     (SKIP&RET 1)


Disassembly of function SIMPLIMPLUS1
(CONST 0) = EXP
(CONST 1) = Y
(CONST 2) = 0
(CONST 3) = F
(CONST 4) = VAR
(CONST 5) = VAL
(CONST 6) = THINK
(CONST 7) = LIMIT
(CONST 8) = $UND
(CONST 9) = ($INF $MINF $INFINITY $IND)
(CONST 10) = MEMQ
(CONST 11) = ADD*
(CONST 12) = $IND
(CONST 13) = $INF
(CONST 14) = $MINF
(CONST 15) = $INFINITY
(CONST 16) = $ZEROA
(CONST 17) = FREE
(CONST 18) = $ZEROB
(CONST 19) = SIMPAB
(CONST 20) = ADDN
(CONST 21) = HYPEREX
(CONST 22) = LOG-REDUCE
(CONST 23) = SRATSIMP
(CONST 24) = ALIKE1
(CONST 25) = INFINITIES
(CONST 26) = CNV
(CONST 27) = #<COMPILED-CLOSURE SIMPLIMPLUS1-1>
(CONST 28) = ANDMAPC
(CONST 29) = RHEUR
(CONST 30) = SHEUR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES F VAL VAR Y EXP)
writes special variables : (EXP Y F)
217 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (NIL&PUSH)
4     (NIL)
5     (BIND 1)                            ; Y
7     (PUSH-NIL 4)
9     (CONST 2)                           ; 0
10    (STORE 7)
11    (GETVALUE 0)                        ; EXP
13    (CDR)
14    (BIND 0)                            ; EXP
16    (NIL)
17    (BIND 3)                            ; F
19    (GETVALUE 1)                        ; Y
21    (JMPIF L183)
24    L24
24    (GETVALUE 0)                        ; EXP
26    (JMPIFNOT L183)
29    (GETVALUE 0)                        ; EXP
31    (CAR&PUSH)
32    (GETVALUE&PUSH 4)                   ; VAR
34    (GETVALUE&PUSH 5)                   ; VAL
36    (CONST&PUSH 6)                      ; THINK
37    (CALL 4 7)                          ; LIMIT
40    (SETVALUE 3)                        ; F
42    (PUSH)
43    (JMPIFEQTO 8 L87)                   ; $UND
46    (GETVALUE&PUSH 3)                   ; F
48    (CONST&PUSH 9)                      ; ($INF $MINF $INFINITY $IND)
49    (CALL2&JMPIFNOT 10 L93)             ; MEMQ
52    (GETVALUE&PUSH 3)                   ; F
54    (JMPIFEQTO 12 L103)                 ; $IND
57    (LOAD&JMPIF 8 L110)
60    (GETVALUE&PUSH 3)                   ; F
62    (JMPIFEQTO 13 L113)                 ; $INF
65    (GETVALUE&PUSH 3)                   ; F
67    (JMPIFEQTO 14 L120)                 ; $MINF
70    (GETVALUE&PUSH 3)                   ; F
72    (JMPIFNOTEQTO 15 L173)              ; $INFINITY
76    (LOAD&JMPIF 9 L83)
79    (LOAD&JMPIFNOT 7 L168)
83    L83
83    (CONST 7)                           ; LIMIT
84    L84
84    (PUSH)
85    (T)
86    (THROW)
87    L87
87    (T)
88    (SETVALUE 1)                        ; Y
90    (JMP L173)
93    L93
93    (LOAD&PUSH 13)
94    (GETVALUE&PUSH 3)                   ; F
96    (CALL2 11)                          ; ADD*
98    (STORE 13)
100   (JMP L173)
103   L103
103   (GETVALUE 0)                        ; EXP
105   (CAR&PUSH)
106   (LOAD&CONS&STORE 6)
108   (JMP L173)
110   L110
110   (CONST 7)                           ; LIMIT
111   (JMP L84)
113   L113
113   (GETVALUE 0)                        ; EXP
115   (CAR&PUSH)
116   (LOAD&CONS&STORE 9)
118   (JMP L173)
120   L120
120   (GETVALUE 0)                        ; EXP
122   (CAR&PUSH)
123   (LOAD&CONS&STORE 7)
125   (JMP L173)
127   L127
127   (CONST 8)                           ; $UND
128   (JMP L212)
131   L131
131   (LOAD 7)
132   (JMP L350)
135   L135
135   (LOAD&PUSH 7)
136   (CALL1 19)                          ; SIMPAB
138   (JMP L350)
141   L141
141   (LOAD 7)
142   (JMPIFATOM L131)
144   (LOAD&PUSH 7)
145   (CONST&PUSH 16)                     ; $ZEROA
146   (CALL2&JMPIFNOT 17 L135)            ; FREE
149   (LOAD&PUSH 7)
150   (CONST&PUSH 18)                     ; $ZEROB
151   (CALL2&JMPIFNOT 17 L135)            ; FREE
154   (LOAD 7)
155   (JMP L350)
158   L158
158   (LOAD&JMPIF 1 L288)
162   (CONST 13)                          ; $INF
163   (JMP L212)
165   L165
165   (CONST 14)                          ; $MINF
166   (JMP L212)
168   L168
168   (GETVALUE 0)                        ; EXP
170   (CAR&PUSH)
171   (LOAD&CONS&STORE 8)
173   L173
173   (GETVALUE 0)                        ; EXP
175   (CDR)
176   (SETVALUE 0)                        ; EXP
178   (GETVALUE 1)                        ; Y
180   (JMPIFNOT L24)
183   L183
183   (UNBIND 2)
185   (GETVALUE 1)                        ; Y
187   (JMPIF L127)
189   (LOAD&JMPIF 3 L201)
192   (LOAD&JMPIF 1 L201)
195   (LOAD&JMPIF 0 L201)
198   (LOAD&JMPIFNOT 2 L141)
201   L201
201   (LOAD&JMPIF 2 L282)
205   (LOAD&JMPIF 3 L158)
208   (LOAD&JMPIF 1 L165)
211   (CONST 12)                          ; $IND
212   L212
212   (SKIP 4)
214   (UNBIND1)
215   (SKIP 1)
217   (JMP L355)
220   L220
220   (LOAD&PUSH 6)
221   (LOAD&PUSH 5)
222   (CALL2 29)                          ; RHEUR
224   (JMP L261)
226   L226
226   (GETVALUE&PUSH 5)                   ; VAL
228   (GETVALUE&PUSH 25)                  ; INFINITIES
230   (CALL2&JMPIF 10 L245)               ; MEMQ
233   (LOAD&PUSH 3)
234   (GETVALUE&PUSH 5)                   ; VAL
236   (CALL2 26)                          ; CNV
238   (STORE 3)
239   (LOAD&PUSH 1)
240   (GETVALUE&PUSH 5)                   ; VAL
242   (CALL2 26)                          ; CNV
244   (STORE 1)
245   L245
245   (CONST 13)                          ; $INF
246   (BIND 5)                            ; VAL
248   (CONST&PUSH 27)                     ; #<COMPILED-CLOSURE SIMPLIMPLUS1-1>
249   (LOAD&PUSH 7)
250   (LOAD&PUSH 6)
251   (CALLSR&PUSH 2 34)                  ; APPEND
254   (CALL2&JMPIF 28 L220)               ; ANDMAPC
257   (LOAD&PUSH 6)
258   (LOAD&PUSH 5)
259   (CALL2 30)                          ; SHEUR
261   L261
261   (SETVALUE 1)                        ; Y
263   (UNBIND1)
264   (GETVALUE 1)                        ; Y
266   (JMPIF L331)
268   L268
268   (NIL)
269   (SKIP 4)
271   (UNBIND1)
272   (SKIP 1)
274   (JMP L355)
277   L277
277   (GETVALUE 1)                        ; Y
279   (JMP L350)
282   L282
282   (LOAD&PUSH 3)
283   (LOAD&PUSH 3)
284   (CALLSR&STORE 2 34 3)               ; APPEND
288   L288
288   (LOAD&PUSH 1)
289   (LOAD&PUSH 4)
290   (CALLSR&PUSH 2 34)                  ; APPEND
293   (NIL&PUSH)
294   (CALL2 20)                          ; ADDN
296   (SETVALUE 1)                        ; Y
298   (GETVALUE&PUSH 0)                   ; EXP
300   (GETVALUE&PUSH 1)                   ; Y
302   (CALL1&PUSH 21)                     ; HYPEREX
304   (CALL1&PUSH 22)                     ; LOG-REDUCE
306   (CALL1 23)                          ; SRATSIMP
308   (SETVALUE 1)                        ; Y
310   (PUSH)
311   (CALL2&JMPIF 24 L226)               ; ALIKE1
315   (GETVALUE&PUSH 1)                   ; Y
317   (GETVALUE&PUSH 4)                   ; VAR
319   (GETVALUE&PUSH 5)                   ; VAL
321   (CONST&PUSH 6)                      ; THINK
322   (CALL 4 7)                          ; LIMIT
325   (SETVALUE 1)                        ; Y
327   (GETVALUE 1)                        ; Y
329   (JMPIFNOT L268)
331   L331
331   (GETVALUE&PUSH 1)                   ; Y
333   (T)
334   (JMPIFEQ L268)
337   (GETVALUE&PUSH 1)                   ; Y
339   (GETVALUE&PUSH 25)                  ; INFINITIES
341   (CALL2&JMPIF 10 L277)               ; MEMQ
345   (LOAD&PUSH 7)
346   (GETVALUE&PUSH 1)                   ; Y
348   (CALL2 11)                          ; ADD*
350   L350
350   (SKIP 4)
352   (UNBIND1)
353   (SKIP 1)
355   L355
355   (UNBIND1)
356   (SKIP&RET 2)


Disassembly of function SIMPLIMPLUS1-1
(CONST 0) = J
(CONST 1) = VAR
(CONST 2) = RADICALP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; VAR
7     (CALL2 2)                           ; RADICALP
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SHEUR0 (N D) ...)-106|
(CONST 0) = SHEUR0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SHEUR0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SHEUR0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SHEUR0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SHEUR0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SHEUR0
8     (SKIP&RET 1)


Disassembly of function SHEUR0
(CONST 0) = N
(CONST 1) = D
(CONST 2) = /#ALIKE
(CONST 3) = 1
(CONST 4) = VAR
(CONST 5) = FREE
(CONST 6) = DIV*
(CONST 7) = CPA
(CONST 8) = OSCIP
(CONST 9) = $UND
(CONST 10) = $INF
(CONST 11) = -1
(CONST 12) = $ZEROA
(CONST 13) = 0
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR D N)
writes special variable : (N)
60 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (GETVALUE&PUSH 0)                   ; N
8     (GETVALUE&PUSH 0)                   ; N
10    (GETVALUE&PUSH 1)                   ; D
12    (CALL2&JMPIF 2 L63)                 ; /#ALIKE
15    (GETVALUE&PUSH 0)                   ; N
17    (GETVALUE&PUSH 4)                   ; VAR
19    (CALL2&JMPIFNOT 5 L29)              ; FREE
22    (GETVALUE&PUSH 1)                   ; D
24    (GETVALUE&PUSH 4)                   ; VAR
26    (CALL2&JMPIF 5 L68)                 ; FREE
29    L29
29    (GETVALUE&PUSH 0)                   ; N
31    (GETVALUE&PUSH 1)                   ; D
33    (NIL&PUSH)
34    (CALL 3 7)                          ; CPA
37    (SETVALUE 0)                        ; N
39    (PUSH)
40    (JMPIFEQTO 3 L77)                   ; 1
43    (GETVALUE&PUSH 0)                   ; N
45    (JMPIFEQTO 11 L86)                  ; -1
48    (GETVALUE&PUSH 0)                   ; N
50    (JMPIFNOTEQTO 13 L91)               ; 0
53    (LOAD 0)
54    L54
54    (PUSH)
55    (GETVALUE&PUSH 1)                   ; D
57    (CALL2 6)                           ; DIV*
59    (SKIP 1)
61    (JMP L94)
63    L63
63    (CONST 3)                           ; 1
64    (SKIP 1)
66    (JMP L94)
68    L68
68    (GETVALUE 0)                        ; N
70    (JMP L54)
72    L72
72    (CONST 9)                           ; $UND
73    (SKIP 1)
75    (JMP L94)
77    L77
77    (LOAD&PUSH 0)
78    (CALL1&JMPIF 8 L72)                 ; OSCIP
81    (CONST 10)                          ; $INF
82    (SKIP 1)
84    (JMP L94)
86    L86
86    (CONST 12)                          ; $ZEROA
87    (SKIP 1)
89    (JMP L94)
91    L91
91    (NIL)
92    (SKIP 1)
94    L94
94    (UNBIND 2)
96    (SKIP&RET 3)


Disassembly of function #:|(DEFUN SHEUR (L1 L2) ...)-107|
(CONST 0) = SHEUR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SHEUR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SHEUR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SHEUR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SHEUR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SHEUR
8     (SKIP&RET 1)


Disassembly of function SHEUR
(CONST 0) = SHEUR1
(CONST 1) = $INF
(CONST 2) = $MINF
(CONST 3) = DIV*
(CONST 4) = ADDN
(CONST 5) = 1
(CONST 6) = VAR
(CONST 7) = VAL
(CONST 8) = LIMIT2
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR)
46 byte-code instructions:
0     (LOAD&PUSH 2)
1     (LOAD&PUSH 2)
2     (CALL2&PUSH 0)                      ; SHEUR1
4     (LOAD&PUSH 0)
5     (JMPIFEQTO 1 L20)                   ; $INF
8     (LOAD&PUSH 0)
9     (JMPIFEQTO 2 L23)                   ; $MINF
12    (NIL&PUSH)
13    (LOAD&PUSH 4)
14    (LOAD&PUSH 4)
15    (CALLSR&PUSH 2 34)                  ; APPEND
18    (JMP L39)
20    L20
20    (CONST 1)                           ; $INF
21    (SKIP&RET 4)
23    L23
23    (CONST 2)                           ; $MINF
24    (SKIP&RET 4)
26    L26
26    (LOAD&CAR&PUSH 0)
28    (LOAD&PUSH 0)
29    (LOAD&CAR&PUSH 7)
31    (CALL2&PUSH 3)                      ; DIV*
33    (LOAD&CONS&STORE 2)
35    (SKIP 1)
37    (LOAD&CDR&STORE 0)
39    L39
39    (LOAD&PUSH 0)
40    (CALLS1&JMPIFNOT 146 L26)           ; ENDP
43    (SKIP 1)
45    (LOAD&PUSH 0)
46    (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
49    (NIL&PUSH)
50    (CALL2&PUSH 4)                      ; ADDN
52    (LOAD&PUSH 0)
53    (CONST&PUSH 5)                      ; 1
54    (LOAD&CAR&PUSH 6)
56    (CALL2&PUSH 3)                      ; DIV*
58    (GETVALUE&PUSH 6)                   ; VAR
60    (GETVALUE&PUSH 7)                   ; VAL
62    (CALL 4 8)                          ; LIMIT2
65    (JMPIF1 L70)
67    (NIL)
68    (SKIP&RET 5)
70    L70
70    (SKIP&RET 5)


Disassembly of function #:|(COMMENT (# #) (T #))-108|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN FRAC (EXP) ...)-109|
(CONST 0) = FRAC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE FRAC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; FRAC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; FRAC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE FRAC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; FRAC
8     (SKIP&RET 1)


Disassembly of function FRAC
(CONST 0) = EXP
(CONST 1) = NFORMAT
(CONST 2) = MQUOTIENT
(CONST 3) = VAR
(CONST 4) = AMONG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
writes special variable : (EXP)
27 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (JMPIFATOM L32)
7     (GETVALUE&PUSH 0)                   ; EXP
9     (CALL1 1)                           ; NFORMAT
11    (SETVALUE 0)                        ; EXP
13    (CAR)
14    (CAR&PUSH)
15    (JMPIFNOTEQTO 2 L28)                ; MQUOTIENT
18    (GETVALUE&PUSH 3)                   ; VAR
20    (GETVALUE 0)                        ; EXP
22    (CDR)
23    (CDR)
24    (CAR&PUSH)
25    (CALL2&JMPIF 4 L35)                 ; AMONG
28    L28
28    (NIL)
29    L29
29    (UNBIND1)
30    (SKIP&RET 2)
32    L32
32    (NIL)
33    (JMP L29)
35    L35
35    (T)
36    (JMP L29)


Disassembly of function #:|(DEFUN ZEROP2 (Z) ...)-110|
(CONST 0) = ZEROP2
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZEROP2>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZEROP2
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZEROP2
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZEROP2>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZEROP2
8     (SKIP&RET 1)


Disassembly of function ZEROP2
(CONST 0) = RIDOFAB
(CONST 1) = 0
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (LOAD&PUSH 1)
1     (CALL1&PUSH 0)                      ; RIDOFAB
3     (CONST 1)                           ; 0
4     (EQ)
5     (SKIP&RET 2)


Disassembly of function #:|(DEFUN RAISE (A) ...)-111|
(CONST 0) = RAISE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RAISE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RAISE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RAISE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RAISE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RAISE
8     (SKIP&RET 1)


Disassembly of function RAISE
(CONST 0) = A
(CONST 1) = $ZEROA
(CONST 2) = ADD*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (A)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (GETVALUE&PUSH 0)                   ; A
5     (CONST&PUSH 1)                      ; $ZEROA
6     (CALL2 2)                           ; ADD*
8     (UNBIND1)
9     (SKIP&RET 2)


Disassembly of function #:|(DEFUN LOWER (A) ...)-112|
(CONST 0) = LOWER
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOWER>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOWER
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOWER
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOWER>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOWER
8     (SKIP&RET 1)


Disassembly of function LOWER
(CONST 0) = A
(CONST 1) = $ZEROB
(CONST 2) = ADD*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (A)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; A
3     (GETVALUE&PUSH 0)                   ; A
5     (CONST&PUSH 1)                      ; $ZEROB
6     (CALL2 2)                           ; ADD*
8     (UNBIND1)
9     (SKIP&RET 2)


Disassembly of function #:|(DEFUN SINCOSHK (EXP1 L SC) ...)-113|
(CONST 0) = SINCOSHK
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SINCOSHK>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SINCOSHK
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SINCOSHK
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SINCOSHK>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SINCOSHK
8     (SKIP&RET 1)


Disassembly of function SINCOSHK
(CONST 0) = EXP1
(CONST 1) = L
(CONST 2) = 1
(CONST 3) = LOWER
(CONST 4) = -1
(CONST 5) = RAISE
(CONST 6) = AMONG
(CONST 7) = VAL
(CONST 8) = ($ZEROA $ZEROB)
(CONST 9) = MEMQ
(CONST 10) = SPANGSIDE
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (EXP1 VAL L)
34 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP1
3     (LOAD 5)
4     (BIND 1)                            ; L
6     (GETVALUE&PUSH 1)                   ; L
8     (JMPIFEQTO 2 L34)                   ; 1
11    (GETVALUE&PUSH 1)                   ; L
13    (JMPIFEQTO 4 L40)                   ; -1
16    (LOAD&PUSH 7)
17    (GETVALUE&PUSH 1)                   ; L
19    (CALL2&JMPIF 6 L46)                 ; AMONG
22    (GETVALUE&PUSH 7)                   ; VAL
24    (CONST&PUSH 8)                      ; ($ZEROA $ZEROB)
25    (CALL2&JMPIF 9 L50)                 ; MEMQ
28    (GETVALUE 1)                        ; L
30    L30
30    (UNBIND 2)
32    (SKIP&RET 4)
34    L34
34    (GETVALUE&PUSH 1)                   ; L
36    (CALL1 3)                           ; LOWER
38    (JMP L30)
40    L40
40    (GETVALUE&PUSH 1)                   ; L
42    (CALL1 5)                           ; RAISE
44    (JMP L30)
46    L46
46    (GETVALUE 1)                        ; L
48    (JMP L30)
50    L50
50    (GETVALUE&PUSH 0)                   ; EXP1
52    (GETVALUE&PUSH 1)                   ; L
54    (CALL2 10)                          ; SPANGSIDE
56    (JMP L30)


Disassembly of function #:|(DEFUN SPANGSIDE (E L) ...)-114|
(CONST 0) = SPANGSIDE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SPANGSIDE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SPANGSIDE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SPANGSIDE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SPANGSIDE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SPANGSIDE
8     (SKIP&RET 1)


Disassembly of function SPANGSIDE
(CONST 0) = E
(CONST 1) = L
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = BEHAVIOR
(CONST 5) = 1
(CONST 6) = RAISE
(CONST 7) = -1
(CONST 8) = LOWER
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (L VAL VAR E)
writes special variable : (E)
25 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; L
6     (GETVALUE&PUSH 0)                   ; E
8     (GETVALUE&PUSH 2)                   ; VAR
10    (GETVALUE&PUSH 3)                   ; VAL
12    (CALL 3 4)                          ; BEHAVIOR
15    (SETVALUE 0)                        ; E
17    (PUSH)
18    (JMPIFEQTO 5 L32)                   ; 1
21    (GETVALUE&PUSH 0)                   ; E
23    (JMPIFEQTO 7 L38)                   ; -1
26    (GETVALUE 1)                        ; L
28    L28
28    (UNBIND 2)
30    (SKIP&RET 3)
32    L32
32    (GETVALUE&PUSH 1)                   ; L
34    (CALL1 6)                           ; RAISE
36    (JMP L28)
38    L38
38    (GETVALUE&PUSH 1)                   ; L
40    (CALL1 8)                           ; LOWER
42    (JMP L28)


Disassembly of function #:|(DEFMFUN RIDOFAB (E) ...)-115|
(CONST 0) = RIDOFAB
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RIDOFAB>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RIDOFAB
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RIDOFAB
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RIDOFAB>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RIDOFAB
8     (SKIP&RET 1)


Disassembly of function RIDOFAB
(CONST 0) = E
(CONST 1) = $ZEROA
(CONST 2) = AMONG
(CONST 3) = 0
(CONST 4) = MAXIMA-SUBSTITUTE
(CONST 5) = $ZEROB
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
writes special variable : (E)
26 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (CONST&PUSH 1)                      ; $ZEROA
4     (GETVALUE&PUSH 0)                   ; E
6     (CALL2&JMPIFNOT 2 L18)              ; AMONG
9     (CONST&PUSH 3)                      ; 0
10    (CONST&PUSH 1)                      ; $ZEROA
11    (GETVALUE&PUSH 0)                   ; E
13    (CALL 3 4)                          ; MAXIMA-SUBSTITUTE
16    (SETVALUE 0)                        ; E
18    L18
18    (CONST&PUSH 5)                      ; $ZEROB
19    (GETVALUE&PUSH 0)                   ; E
21    (CALL2&JMPIF 2 L29)                 ; AMONG
24    (GETVALUE 0)                        ; E
26    L26
26    (UNBIND1)
27    (SKIP&RET 2)
29    L29
29    (CONST&PUSH 3)                      ; 0
30    (CONST&PUSH 5)                      ; $ZEROB
31    (GETVALUE&PUSH 0)                   ; E
33    (CALL 3 4)                          ; MAXIMA-SUBSTITUTE
36    (SETVALUE 0)                        ; E
38    (GETVALUE 0)                        ; E
40    (JMP L26)


Disassembly of function #:|(DEFUN SIMPLERD (EXP) ...)-116|
(CONST 0) = SIMPLERD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLERD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLERD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLERD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLERD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLERD
8     (SKIP&RET 1)


Disassembly of function SIMPLERD
(CONST 0) = EXP
(CONST 1) = MEXPTP
(CONST 2) = RD*
(CONST 3) = VAR
(CONST 4) = AMONG
(CONST 5) = MNUMP
(CONST 6) = POLYP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR RD* EXP)
28 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE&PUSH 0)                   ; EXP
5     (CALL1 1)                           ; MEXPTP
7     (JMPIFNOT1 L38)
9     (GETVALUE 2)                        ; RD*
11    (JMPIFNOT L23)
13    (GETVALUE&PUSH 3)                   ; VAR
15    (GETVALUE 0)                        ; EXP
17    (CDR)
18    (CDR)
19    (CAR&PUSH)
20    (CALL2&JMPIFNOT 4 L32)              ; AMONG
23    L23
23    (GETVALUE 0)                        ; EXP
25    (CDR)
26    (CDR)
27    (CAR&PUSH)
28    (CALL1 5)                           ; MNUMP
30    (JMPIFNOT1 L38)
32    L32
32    (GETVALUE 0)                        ; EXP
34    (CDR)
35    (CAR&PUSH)
36    (CALL1 6)                           ; POLYP
38    L38
38    (UNBIND1)
39    (SKIP&RET 2)


Disassembly of function #:|(DEFUN BRANCH1 (EXP VAL) ...)-117|
(CONST 0) = BRANCH1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BRANCH1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BRANCH1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BRANCH1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BRANCH1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BRANCH1
8     (SKIP&RET 1)


Disassembly of function BRANCH1
(CONST 0) = EXP
(CONST 1) = VAL
(CONST 2) = POLYP
(CONST 3) = SIMPLERD
(CONST 4) = SUBIN
(CONST 5) = ZEROP2
(CONST 6) = V
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL V EXP)
writes special variable : (V)
46 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1&JMPIF 2 L49)                 ; POLYP
11    (GETVALUE&PUSH 0)                   ; EXP
13    (CALL1&JMPIF 3 L52)                 ; SIMPLERD
16    (GETVALUE 0)                        ; EXP
18    (CDR)
19    (BIND 6)                            ; V
21    (GETVALUE 6)                        ; V
23    (JMPIFNOT L43)
25    L25
25    (GETVALUE 6)                        ; V
27    (CAR&PUSH)
28    (GETVALUE&PUSH 1)                   ; VAL
30    (JSR L0)
32    (JMPIF L64)
34    (GETVALUE 6)                        ; V
36    (CDR)
37    (SETVALUE 6)                        ; V
39    (GETVALUE 6)                        ; V
41    (JMPIF L25)
43    L43
43    (NIL)
44    (UNBIND1)
45    L45
45    (UNBIND 2)
47    (SKIP&RET 3)
49    L49
49    (NIL)
50    (JMP L45)
52    L52
52    (GETVALUE&PUSH 1)                   ; VAL
54    (GETVALUE 0)                        ; EXP
56    (CDR)
57    (CAR&PUSH)
58    (CALL2&PUSH 4)                      ; SUBIN
60    (CALL1 5)                           ; ZEROP2
62    (JMP L45)
64    L64
64    (GETVALUE 6)                        ; V
66    (UNBIND1)
67    (JMP L45)


Disassembly of function #:|(DEFUN BRANCH (EXP VAL) ...)-118|
(CONST 0) = BRANCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE BRANCH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; BRANCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; BRANCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE BRANCH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; BRANCH
8     (SKIP&RET 1)


Disassembly of function BRANCH
(CONST 0) = EXP
(CONST 1) = VAL
(CONST 2) = POLYP
(CONST 3) = SIMPLERD
(CONST 4) = MTIMESP
(CONST 5) = BRANCH1
(CONST 6) = MPLUSP
(CONST 7) = #<COMPILED-CLOSURE BRANCH-1>
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL EXP)
30 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (GETVALUE&PUSH 0)                   ; EXP
8     (CALL1&JMPIF 2 L31)                 ; POLYP
11    (GETVALUE&PUSH 0)                   ; EXP
13    (CALL1&JMPIF 3 L34)                 ; SIMPLERD
16    (GETVALUE&PUSH 0)                   ; EXP
18    (CALL1&JMPIF 4 L34)                 ; MTIMESP
21    (GETVALUE&PUSH 0)                   ; EXP
23    (CALL1&JMPIF 6 L42)                 ; MPLUSP
26    (NIL)
27    L27
27    (UNBIND 2)
29    (SKIP&RET 3)
31    L31
31    (NIL)
32    (JMP L27)
34    L34
34    (GETVALUE&PUSH 0)                   ; EXP
36    (GETVALUE&PUSH 1)                   ; VAL
38    (CALL2 5)                           ; BRANCH1
40    (JMP L27)
42    L42
42    (CONST&PUSH 7)                      ; #<COMPILED-CLOSURE BRANCH-1>
43    (GETVALUE 0)                        ; EXP
45    (CDR&PUSH)
46    (CALLSR 0 40)                       ; EVERY
49    (JMP L27)


Disassembly of function BRANCH-1
(CONST 0) = J
(CONST 1) = VAL
(CONST 2) = BRANCH
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; VAL
7     (CALL2 2)                           ; BRANCH
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SER0 (E N D ...) ...)-119|
(CONST 0) = SER0
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SER0>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SER0
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SER0
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SER0>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SER0
8     (SKIP&RET 1)


Disassembly of function SER0
(CONST 0) = E
(CONST 1) = N
(CONST 2) = D
(CONST 3) = VAL
(CONST 4) = BRANCH
(CONST 5) = NN*
(CONST 6) = SER1
(CONST 7) = RATMIN
(CONST 8) = VAR
(CONST 9) = POWER*
(CONST 10) = SRATSIMP
(CONST 11) = ($ZEROA $ZEROB)
(CONST 12) = MEMQ
(CONST 13) = 0
(CONST 14) = RADLIM
(CONST 15) = TRY-LHOSPITAL-QUIT
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR NN* D VAL N)
writes special variables : (VAL D N NN*)
59 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; E
3     (LOAD 6)
4     (BIND 1)                            ; N
6     (LOAD 8)
7     (BIND 2)                            ; D
9     (LOAD 10)
10    (BIND 3)                            ; VAL
12    (GETVALUE&PUSH 1)                   ; N
14    (GETVALUE&PUSH 3)                   ; VAL
16    (CALL2&JMPIFNOT 4 L26)              ; BRANCH
19    (GETVALUE&PUSH 2)                   ; D
21    (GETVALUE&PUSH 3)                   ; VAL
23    (CALL2&JMPIF 4 L38)                 ; BRANCH
26    L26
26    (GETVALUE&PUSH 1)                   ; N
28    (GETVALUE&PUSH 2)                   ; D
30    (NIL&PUSH)
31    (CALL 3 15)                         ; TRY-LHOSPITAL-QUIT
34    L34
34    (UNBIND 4)
36    (SKIP&RET 5)
38    L38
38    (NIL)
39    (SETVALUE 5)                        ; NN*
41    (GETVALUE&PUSH 1)                   ; N
43    (CALL1 6)                           ; SER1
45    (SETVALUE 1)                        ; N
47    (GETVALUE&PUSH 2)                   ; D
49    (CALL1 6)                           ; SER1
51    (SETVALUE 2)                        ; D
53    (GETVALUE&PUSH 5)                   ; NN*
55    (CALL1 7)                           ; RATMIN
57    (SETVALUE 5)                        ; NN*
59    (GETVALUE&PUSH 1)                   ; N
61    (GETVALUE&PUSH 8)                   ; VAR
63    (GETVALUE&PUSH 5)                   ; NN*
65    (CALL2&PUSH 9)                      ; POWER*
67    (CALL2&PUSH 9)                      ; POWER*
69    (CALL1 10)                          ; SRATSIMP
71    (SETVALUE 1)                        ; N
73    (GETVALUE&PUSH 2)                   ; D
75    (GETVALUE&PUSH 8)                   ; VAR
77    (GETVALUE&PUSH 5)                   ; NN*
79    (CALL2&PUSH 9)                      ; POWER*
81    (CALL2&PUSH 9)                      ; POWER*
83    (CALL1 10)                          ; SRATSIMP
85    (SETVALUE 2)                        ; D
87    (GETVALUE&PUSH 3)                   ; VAL
89    (CONST&PUSH 11)                     ; ($ZEROA $ZEROB)
90    (CALL2&JMPIF 12 L96)                ; MEMQ
93    (CONST 13)                          ; 0
94    (SETVALUE 3)                        ; VAL
96    L96
96    (GETVALUE&PUSH 0)                   ; E
98    (GETVALUE&PUSH 1)                   ; N
100   (GETVALUE&PUSH 2)                   ; D
102   (CALL 3 14)                         ; RADLIM
105   (JMP L34)


Disassembly of function #:|(DEFUN RHEUR (L1 L2) ...)-120|
(CONST 0) = RHEUR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RHEUR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RHEUR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RHEUR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RHEUR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RHEUR
8     (SKIP&RET 1)


Disassembly of function RHEUR
(CONST 0) = ANS
(CONST 1) = ASYMREDU
(CONST 2) = ADDN
(CONST 3) = RPTROUBLE
(CONST 4) = RDSGET
(CONST 5) = SIMPLIFY
(CONST 6) = VAR
(CONST 7) = VAL
(CONST 8) = LIMIT
(CONST 9) = MPLUSP
(CONST 10) = SHEUR
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR ANS)
writes special variable : (ANS)
51 byte-code instructions:
0     (NIL)
1     (BIND 0)                            ; ANS
3     (PUSH-NIL 2)
5     (CONST&SYMBOL-FUNCTION&PUSH 1)      ; ASYMREDU
7     (LOAD&PUSH 8)
8     (CALLSR&STORE 0 22 1)               ; MAPCAR
12    (CONST&SYMBOL-FUNCTION&PUSH 1)      ; ASYMREDU
14    (LOAD&PUSH 7)
15    (CALLSR&STORE 0 22 0)               ; MAPCAR
19    (LOAD&PUSH 1)
20    (LOAD&PUSH 1)
21    (CALLSR&PUSH 2 34)                  ; APPEND
24    (NIL&PUSH)
25    (CALL2 2)                           ; ADDN
27    (SETVALUE 0)                        ; ANS
29    (LOAD&PUSH 7)
30    (LOAD&PUSH 7)
31    (CALLSR&PUSH 2 34)                  ; APPEND
34    (NIL&PUSH)
35    (CALL2&PUSH 2)                      ; ADDN
37    (CALL1&JMPIF 3 L61)                 ; RPTROUBLE
40    (GETVALUE&PUSH 0)                   ; ANS
42    (CALL1&JMPIF 9 L80)                 ; MPLUSP
45    (GETVALUE&PUSH 0)                   ; ANS
47    (GETVALUE&PUSH 6)                   ; VAR
49    (GETVALUE&PUSH 7)                   ; VAL
51    (T)
52    L52
52    (PUSH)
53    (CALL 4 8)                          ; LIMIT
56    L56
56    (SKIP 2)
58    (UNBIND1)
59    (SKIP&RET 3)
61    L61
61    (LOAD&PUSH 7)
62    (LOAD&PUSH 7)
63    (CALLSR&PUSH 2 34)                  ; APPEND
66    (NIL&PUSH)
67    (CALL2&PUSH 2)                      ; ADDN
69    (CALL1&PUSH 4)                      ; RDSGET
71    (CALL1&PUSH 5)                      ; SIMPLIFY
73    (GETVALUE&PUSH 6)                   ; VAR
75    (GETVALUE&PUSH 7)                   ; VAL
77    (NIL)
78    (JMP L52)
80    L80
80    (LOAD&PUSH 1)
81    (LOAD&PUSH 1)
82    (CALL2 10)                          ; SHEUR
84    (JMP L56)


Disassembly of function #:|(DEFUN RPTROUBLE (RP) ...)-121|
(CONST 0) = RPTROUBLE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RPTROUBLE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RPTROUBLE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RPTROUBLE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RPTROUBLE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RPTROUBLE
8     (SKIP&RET 1)


Disassembly of function RPTROUBLE
(CONST 0) = RDDEG
(CONST 1) = ASYMREDU
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (LOAD&PUSH 1)
1     (NIL&PUSH)
2     (CALL2&PUSH 0)                      ; RDDEG
4     (LOAD&PUSH 2)
5     (CALL1&PUSH 1)                      ; ASYMREDU
7     (NIL&PUSH)
8     (CALL2&PUSH 0)                      ; RDDEG
10    (CALLS2 2)                          ; EQUAL
12    (NOT)
13    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RADICALP (EXP VAR) ...)-122|
(CONST 0) = RADICALP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RADICALP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RADICALP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RADICALP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RADICALP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RADICALP
8     (SKIP&RET 1)


Disassembly of function RADICALP
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = POLYINX
(CONST 3) = MEXPTP
(CONST 4) = -1
(CONST 5) = SIMPLERD
(CONST 6) = (MPLUS MTIMES)
(CONST 7) = MEMQ
(CONST 8) = #<COMPILED-CLOSURE RADICALP-1>
(CONST 9) = ANDMAPC
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR EXP)
45 byte-code instructions:
0     L0
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 0)                   ; EXP
8     (GETVALUE&PUSH 1)                   ; VAR
10    (NIL&PUSH)
11    (CALL 3 2)                          ; POLYINX
14    (JMPIF1 L30)
16    (GETVALUE&PUSH 0)                   ; EXP
18    (CALL1&JMPIF 3 L44)                 ; MEXPTP
21    (GETVALUE 0)                        ; EXP
23    (CAR)
24    (CAR&PUSH)
25    (CONST&PUSH 6)                      ; (MPLUS MTIMES)
26    (CALL2&JMPIF 7 L61)                 ; MEMQ
29    (NIL)
30    L30
30    (UNBIND 2)
32    (SKIP&RET 3)
34    L34
34    (GETVALUE 0)                        ; EXP
36    (CDR)
37    (CAR&PUSH)
38    (GETVALUE&PUSH 1)                   ; VAR
40    (JSR L0)
42    (JMP L30)
44    L44
44    (GETVALUE 0)                        ; EXP
46    (CDR)
47    (CDR)
48    (CAR&PUSH)
49    (JMPIFEQTO 4 L34)                   ; -1
52    (GETVALUE&PUSH 0)                   ; EXP
54    (CALL1 5)                           ; SIMPLERD
56    (JMPIF1 L30)
58    (NIL)
59    (JMP L30)
61    L61
61    (CONST&PUSH 8)                      ; #<COMPILED-CLOSURE RADICALP-1>
62    (GETVALUE 0)                        ; EXP
64    (CDR&PUSH)
65    (CALL2 9)                           ; ANDMAPC
67    (JMP L30)


Disassembly of function RADICALP-1
(CONST 0) = J
(CONST 1) = VAR
(CONST 2) = RADICALP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; VAR
7     (CALL2 2)                           ; RADICALP
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN INVOLVE (E NN*) ...)-123|
(CONST 0) = INVOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INVOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; INVOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INVOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INVOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; INVOLVE
8     (SKIP&RET 1)


Disassembly of function INVOLVE
(CONST 0) = E
(CONST 1) = NN*
(CONST 2) = MNUMP
(CONST 3) = MEMQ
(CONST 4) = VAR
(CONST 5) = AMONG
(CONST 6) = #<COMPILED-CLOSURE INVOLVE-1>
(CONST 7) = ORMAPC
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR NN* E)
37 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; NN*
6     (GETVALUE 0)                        ; E
8     (JMPIFATOM L43)
10    (GETVALUE&PUSH 0)                   ; E
12    (CALL1&JMPIF 2 L46)                 ; MNUMP
15    (GETVALUE 0)                        ; E
17    (CAR)
18    (CAR&PUSH)
19    (GETVALUE&PUSH 1)                   ; NN*
21    (CALL2&JMPIFNOT 3 L33)              ; MEMQ
24    (GETVALUE&PUSH 4)                   ; VAR
26    (GETVALUE 0)                        ; E
28    (CDR)
29    (CAR&PUSH)
30    (CALL2&JMPIF 5 L49)                 ; AMONG
33    L33
33    (CONST&PUSH 6)                      ; #<COMPILED-CLOSURE INVOLVE-1>
34    (GETVALUE 0)                        ; E
36    (CDR&PUSH)
37    (CALL2 7)                           ; ORMAPC
39    L39
39    (UNBIND 2)
41    (SKIP&RET 3)
43    L43
43    (NIL)
44    (JMP L39)
46    L46
46    (NIL)
47    (JMP L39)
49    L49
49    (GETVALUE 0)                        ; E
51    (CDR)
52    (CAR)
53    (JMP L39)


Disassembly of function INVOLVE-1
(CONST 0) = J
(CONST 1) = NN*
(CONST 2) = INVOLVE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (NN* J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; NN*
7     (CALL2 2)                           ; INVOLVE
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN NOTINVOLVE (EXP NN*) ...)-124|
(CONST 0) = NOTINVOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NOTINVOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NOTINVOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NOTINVOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NOTINVOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NOTINVOLVE
8     (SKIP&RET 1)


Disassembly of function NOTINVOLVE
(CONST 0) = EXP
(CONST 1) = NN*
(CONST 2) = MNUMP
(CONST 3) = MEMQ
(CONST 4) = VAR
(CONST 5) = AMONG
(CONST 6) = #<COMPILED-CLOSURE NOTINVOLVE-1>
(CONST 7) = ANDMAPC
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR NN* EXP)
36 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD 4)
4     (BIND 1)                            ; NN*
6     (GETVALUE 0)                        ; EXP
8     (JMPIFATOM L37)
10    (GETVALUE&PUSH 0)                   ; EXP
12    (CALL1&JMPIF 2 L40)                 ; MNUMP
15    (GETVALUE 0)                        ; EXP
17    (CAR)
18    (CAR&PUSH)
19    (GETVALUE&PUSH 1)                   ; NN*
21    (CALL2&JMPIF 3 L43)                 ; MEMQ
24    (CONST&PUSH 6)                      ; #<COMPILED-CLOSURE NOTINVOLVE-1>
25    (GETVALUE 0)                        ; EXP
27    (CDR&PUSH)
28    (CALL2 7)                           ; ANDMAPC
30    (JMPIF1 L33)
32    (NIL)
33    L33
33    (UNBIND 2)
35    (SKIP&RET 3)
37    L37
37    (T)
38    (JMP L33)
40    L40
40    (T)
41    (JMP L33)
43    L43
43    (GETVALUE&PUSH 4)                   ; VAR
45    (GETVALUE 0)                        ; EXP
47    (CDR)
48    (CAR&PUSH)
49    (CALL2 5)                           ; AMONG
51    (NOT)
52    (JMP L33)


Disassembly of function NOTINVOLVE-1
(CONST 0) = J
(CONST 1) = NN*
(CONST 2) = NOTINVOLVE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (NN* J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; NN*
7     (CALL2 2)                           ; NOTINVOLVE
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SHEUR1 (L1 L2) ...)-125|
(CONST 0) = SHEUR1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SHEUR1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SHEUR1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SHEUR1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SHEUR1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SHEUR1
8     (SKIP&RET 1)


Disassembly of function SHEUR1
(CONST 0) = ANS
(CONST 1) = MAXI
(CONST 2) = CPA
(CONST 3) = 0
(CONST 4) = ADD*
(CONST 5) = 1
(CONST 6) = $INF
(CONST 7) = $MINF
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ANS)
writes special variable : (ANS)
31 byte-code instructions:
0     (NIL)
1     (BIND 0)                            ; ANS
3     (LOAD&PUSH 5)
4     (CALL1 1)                           ; MAXI
6     (CAR)
7     (STORE 5)
8     (LOAD&PUSH 4)
9     (CALL1 1)                           ; MAXI
11    (CAR)
12    (STORE 4)
13    (LOAD&PUSH 5)
14    (LOAD&PUSH 5)
15    (T&PUSH)
16    (CALL 3 2)                          ; CPA
19    (SETVALUE 0)                        ; ANS
21    (PUSH)
22    (JMPIFEQTO 3 L34)                   ; 0
25    (GETVALUE&PUSH 0)                   ; ANS
27    (JMPIFEQTO 5 L40)                   ; 1
30    (CONST 7)                           ; $MINF
31    L31
31    (UNBIND1)
32    (SKIP&RET 3)
34    L34
34    (LOAD&PUSH 5)
35    (LOAD&PUSH 5)
36    (CALL2 4)                           ; ADD*
38    (JMP L31)
40    L40
40    (CONST 6)                           ; $INF
41    (JMP L31)


Disassembly of function #:|(DEFUN ZERO-LIM (CPA-LIST) ...)-126|
(CONST 0) = ZERO-LIM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ZERO-LIM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ZERO-LIM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ZERO-LIM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ZERO-LIM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ZERO-LIM
8     (SKIP&RET 1)


Disassembly of function ZERO-LIM
(CONST 0) = L
(CONST 1) = GEN
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = THINK
(CONST 5) = LIMIT
(CONST 6) = ZEROP2
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR L)
writes special variable : (L)
32 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (JMPIFNOT L39)
7     L7
7     (GETVALUE 0)                        ; L
9     (CAR)
10    (CAR&PUSH)
11    (JMPIFNOTEQTO 1 L30)                ; GEN
14    (GETVALUE 0)                        ; L
16    (CAR)
17    (CDR)
18    (CAR&PUSH)
19    (GETVALUE&PUSH 2)                   ; VAR
21    (GETVALUE&PUSH 3)                   ; VAL
23    (CONST&PUSH 4)                      ; THINK
24    (CALL&PUSH 4 5)                     ; LIMIT
27    (CALL1&JMPIF 6 L43)                 ; ZEROP2
30    L30
30    (GETVALUE 0)                        ; L
32    (CDR)
33    (SETVALUE 0)                        ; L
35    (GETVALUE 0)                        ; L
37    (JMPIF L7)
39    L39
39    (NIL)
40    L40
40    (UNBIND1)
41    (SKIP&RET 2)
43    L43
43    (T)
44    (JMP L40)


Disassembly of function #:|(DEFUN CPA (R1 R2 FLAG) ...)-127|
(CONST 0) = CPA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CPA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CPA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CPA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CPA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CPA
8     (SKIP&RET 1)


Disassembly of function CPA
(CONST 0) = FLAG
(CONST 1) = ALIKE1
(CONST 2) = 0
(CONST 3) = VAR
(CONST 4) = FREE
(CONST 5) = VAL
(CONST 6) = LIMIT1
(CONST 7) = ($INF $MINF $UND $IND)
(CONST 8) = MEMQ
(CONST 9) = -1
(CONST 10) = ($INF $MINF $UND $IND)
(CONST 11) = 1
(CONST 12) = MTIMESP
(CONST 13) = ISTRENGTH
(CONST 14) = ISMAX
(CONST 15) = D
(CONST 16) = ANS
(CONST 17) = ADD-UP-DEG
(CONST 18) = ZERO-LIM
(CONST 19) = CPA-INDETERM
(CONST 20) = ISGREATERP
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FLAG VAL D ANS VAR)
writes special variables : (D ANS)
130 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; FLAG
3     (LOAD&PUSH 6)
4     (LOAD&PUSH 6)
5     (LOAD&PUSH 1)
6     (LOAD&PUSH 1)
7     (CALL2&JMPIF 1 L124)                ; ALIKE1
11    (LOAD&PUSH 1)
12    (GETVALUE&PUSH 3)                   ; VAR
14    (CALL2&JMPIF 4 L139)                ; FREE
18    (LOAD&PUSH 0)
19    (GETVALUE&PUSH 3)                   ; VAR
21    (CALL2&JMPIF 4 L168)                ; FREE
25    (LOAD&PUSH 1)
26    (CALL1&JMPIF 12 L187)               ; MTIMESP
30    (LOAD&PUSH 1)
31    (LIST 1)
33    (STORE 1)
34    L34
34    (LOAD&PUSH 0)
35    (CALL1&JMPIF 12 L192)               ; MTIMESP
39    (LOAD&PUSH 0)
40    (LIST 1)
42    (STORE 0)
43    L43
43    (CONST&SYMBOL-FUNCTION&PUSH 13)     ; ISTRENGTH
45    (LOAD&PUSH 2)
46    (CALLSR&STORE 0 22 1)               ; MAPCAR
50    (CONST&SYMBOL-FUNCTION&PUSH 13)     ; ISTRENGTH
52    (LOAD&PUSH 1)
53    (CALLSR&STORE 0 22 0)               ; MAPCAR
57    (LOAD&PUSH 1)
58    (CALL1&PUSH 14)                     ; ISMAX
60    (LOAD&PUSH 1)
61    (CALL1 14)                          ; ISMAX
63    (BIND 15)                           ; D
65    (LOAD 3)
66    (BIND 16)                           ; ANS
68    (GETVALUE 16)                       ; ANS
70    (CAR&PUSH)
71    (JMPIFNOTEQTO 3 L79)                ; VAR
74    (LOAD&PUSH 8)
75    (CALL1 17)                          ; ADD-UP-DEG
77    (SETVALUE 16)                       ; ANS
79    L79
79    (GETVALUE 15)                       ; D
81    (CAR&PUSH)
82    (JMPIFNOTEQTO 3 L90)                ; VAR
85    (LOAD&PUSH 7)
86    (CALL1 17)                          ; ADD-UP-DEG
88    (SETVALUE 15)                       ; D
90    L90
90    (LOAD&PUSH 8)
91    (CALL1&JMPIF 18 L197)               ; ZERO-LIM
95    (LOAD&PUSH 7)
96    (CALL1&JMPIF 18 L197)               ; ZERO-LIM
100   (GETVALUE&PUSH 16)                  ; ANS
102   (GETVALUE&PUSH 15)                  ; D
104   (CALL2&JMPIF 20 L211)               ; ISGREATERP
108   (GETVALUE&PUSH 15)                  ; D
110   (GETVALUE&PUSH 16)                  ; ANS
112   (CALL2&JMPIF 20 L215)               ; ISGREATERP
116   (CONST 2)                           ; 0
117   L117
117   (UNBIND 2)
119   (SKIP 3)
121   L121
121   (UNBIND1)
122   (SKIP&RET 4)
124   L124
124   (CONST 2)                           ; 0
125   (SKIP 2)
127   (JMP L121)
129   L129
129   (CONST 2)                           ; 0
130   (SKIP 2)
132   (JMP L121)
134   L134
134   (CONST 2)                           ; 0
135   (SKIP 3)
137   (JMP L121)
139   L139
139   (LOAD&PUSH 0)
140   (GETVALUE&PUSH 3)                   ; VAR
142   (CALL2&JMPIF 4 L129)                ; FREE
145   (LOAD&PUSH 0)
146   (GETVALUE&PUSH 3)                   ; VAR
148   (GETVALUE&PUSH 5)                   ; VAL
150   (CALL&PUSH 3 6)                     ; LIMIT1
153   (LOAD&PUSH 0)
154   (CONST&PUSH 7)                      ; ($INF $MINF $UND $IND)
155   (CALL2&JMPIFNOT 8 L134)             ; MEMQ
158   (CONST 9)                           ; -1
159   (SKIP 3)
161   (JMP L121)
163   L163
163   (CONST 2)                           ; 0
164   (SKIP 3)
166   (JMP L121)
168   L168
168   (LOAD&PUSH 1)
169   (GETVALUE&PUSH 3)                   ; VAR
171   (GETVALUE&PUSH 5)                   ; VAL
173   (CALL&PUSH 3 6)                     ; LIMIT1
176   (LOAD&PUSH 0)
177   (CONST&PUSH 10)                     ; ($INF $MINF $UND $IND)
178   (CALL2&JMPIFNOT 8 L163)             ; MEMQ
181   (CONST 11)                          ; 1
182   (SKIP 3)
184   (JMP L121)
187   L187
187   (LOAD&CDR&STORE 1)
189   (JMP L34)
192   L192
192   (LOAD&CDR&STORE 0)
194   (JMP L43)
197   L197
197   (GETVALUE&PUSH 16)                  ; ANS
199   (GETVALUE&PUSH 15)                  ; D
201   (LOAD&PUSH 10)
202   (LOAD&PUSH 10)
203   (GETVALUE&PUSH 0)                   ; FLAG
205   (CALL 5 19)                         ; CPA-INDETERM
208   (JMP L117)
211   L211
211   (CONST 11)                          ; 1
212   (JMP L117)
215   L215
215   (CONST 9)                           ; -1
216   (JMP L117)


Disassembly of function #:|(DEFUN CPA-INDETERM (ANS D T1 ...) ...)-128|
(CONST 0) = CPA-INDETERM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CPA-INDETERM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CPA-INDETERM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CPA-INDETERM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CPA-INDETERM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CPA-INDETERM
8     (SKIP&RET 1)


Disassembly of function CPA-INDETERM
(CONST 0) = ANS
(CONST 1) = D
(CONST 2) = FLAG
(CONST 3) = VAR
(CONST 4) = GATHER
(CONST 5) = EXP
(CONST 6) = *INDICATOR
(CONST 7) = CPA1
(CONST 8) = ZEROP1
(CONST 9) = DIV*
(CONST 10) = $RADCAN
(CONST 11) = 1
(CONST 12) = POLYP
(CONST 13) = $INF
(CONST 14) = THINK
(CONST 15) = LIMIT
(CONST 16) = CPA
(CONST 17) = 0
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR FLAG D ANS)
writes special variables : (D ANS)
85 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; ANS
3     (LOAD 7)
4     (BIND 1)                            ; D
6     (LOAD 7)
7     (BIND 2)                            ; FLAG
9     (GETVALUE 0)                        ; ANS
11    (CAR&PUSH)
12    (JMPIFEQTO 3 L29)                   ; VAR
15    (GETVALUE&PUSH 0)                   ; ANS
17    (LOAD&PUSH 13)
18    (CALL2 4)                           ; GATHER
20    (SETVALUE 0)                        ; ANS
22    (GETVALUE&PUSH 1)                   ; D
24    (LOAD&PUSH 12)
25    (CALL2 4)                           ; GATHER
27    (SETVALUE 1)                        ; D
29    L29
29    (GETVALUE 0)                        ; ANS
31    (CAR&PUSH)
32    (CONST 5)                           ; EXP
33    (EQ)
34    (JMPIFNOT L38)
36    (GETVALUE 2)                        ; FLAG
38    L38
38    (BIND 6)                            ; *INDICATOR
40    (NIL&PUSH)
41    (GETVALUE&PUSH 0)                   ; ANS
43    (GETVALUE&PUSH 1)                   ; D
45    (CALL2 7)                           ; CPA1
47    (STORE 0)
48    (PUSH)
49    (CALL1&JMPIFNOT 8 L101)             ; ZEROP1
52    (GETVALUE 0)                        ; ANS
54    (CDR)
55    (CAR&PUSH)
56    (GETVALUE 1)                        ; D
58    (CDR)
59    (CAR&PUSH)
60    (CALL2&PUSH 9)                      ; DIV*
62    (CALL1&PUSH 10)                     ; $RADCAN
64    (JMPIFEQTO 11 L108)                 ; 1
67    (GETVALUE 0)                        ; ANS
69    (CDR)
70    (CAR&PUSH)
71    (CALL1&JMPIFNOT 12 L101)            ; POLYP
74    (GETVALUE 1)                        ; D
76    (CDR)
77    (CAR&PUSH)
78    (CALL1&JMPIFNOT 12 L101)            ; POLYP
81    (GETVALUE 0)                        ; ANS
83    (CDR)
84    (CAR&PUSH)
85    (GETVALUE 1)                        ; D
87    (CDR)
88    (CAR&PUSH)
89    (CALL2&PUSH 9)                      ; DIV*
91    (GETVALUE&PUSH 3)                   ; VAR
93    (CONST&PUSH 13)                     ; $INF
94    (CONST&PUSH 14)                     ; THINK
95    (CALL&PUSH 4 15)                    ; LIMIT
98    (JMPIFEQTO 11 L108)                 ; 1
101   L101
101   (CONST 17)                          ; 0
102   L102
102   (SKIP 1)
104   (UNBIND 4)
106   (SKIP&RET 6)
108   L108
108   (LOAD&PUSH 16)
109   (GETVALUE 0)                        ; ANS
111   (CDR)
112   (CAR&PUSH)
113   (CALL2&PUSH 9)                      ; DIV*
115   (LOAD&PUSH 16)
116   (GETVALUE 1)                        ; D
118   (CDR)
119   (CAR&PUSH)
120   (CALL2&PUSH 9)                      ; DIV*
122   (LOAD&PUSH 1)
123   (LOAD&PUSH 1)
124   (GETVALUE&PUSH 2)                   ; FLAG
126   (CALL 3 16)                         ; CPA
129   (SKIP 2)
131   (JMP L102)


Disassembly of function #:|(DEFUN ADD-UP-DEG (STRENGTHL) ...)-129|
(CONST 0) = ADD-UP-DEG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ADD-UP-DEG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ADD-UP-DEG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ADD-UP-DEG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ADD-UP-DEG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ADD-UP-DEG
8     (SKIP&RET 1)


Disassembly of function ADD-UP-DEG
(CONST 0) = VAR
(CONST 1) = MULN
(CONST 2) = ADDN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
32 byte-code instructions:
0     (LOAD&PUSH 1)
1     (PUSH-NIL 2)
3     (LOAD&JMPIFNOT 2 L30)
6     L6
6     (LOAD 2)
7     (CAR)
8     (CAR&PUSH)
9     (JMPIFNOTEQTO 0 L25)                ; VAR
12    (LOAD 2)
13    (CAR)
14    (CDR)
15    (CAR&PUSH)
16    (LOAD&CONS&STORE 1)
18    (LOAD 2)
19    (CAR)
20    (CDR)
21    (CDR)
22    (CAR&PUSH)
23    (LOAD&CONS&STORE 0)
25    L25
25    (LOAD&CDR&STORE 2)
27    (LOAD&JMPIF 2 L6)
30    L30
30    (CONST&PUSH 0)                      ; VAR
31    (LOAD&PUSH 2)
32    (NIL&PUSH)
33    (CALL2&PUSH 1)                      ; MULN
35    (LOAD&PUSH 2)
36    (NIL&PUSH)
37    (CALL2&PUSH 2)                      ; ADDN
39    (LIST 3)
41    (SKIP&RET 5)


Disassembly of function #:|(DEFUN CPA1 (P1 P2) ...)-130|
(CONST 0) = CPA1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CPA1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CPA1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CPA1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CPA1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CPA1
8     (SKIP&RET 1)


Disassembly of function CPA1
(CONST 0) = FLAG
(CONST 1) = GEN
(CONST 2) = 0
(CONST 3) = VAR
(CONST 4) = ISTRENGTH
(CONST 5) = ISGREATERP
(CONST 6) = 1
(CONST 7) = -1
(CONST 8) = *INDICATOR
(CONST 9) = POLY?
(CONST 10) = SUB*
(CONST 11) = ZEROP1
(CONST 12) = RAT-NO-RATFAC
(CONST 13) = PDIS
(CONST 14) = GETSIGNL
(CONST 15) = MUL
(CONST 16) = RHEUR
(CONST 17) = ZEROP2
(CONST 18) = RATGREATERP
(CONST 19) = EXP
(CONST 20) = AMONG
(CONST 21) = RADICALP
(CONST 22) = $INF
(CONST 23) = $MINF
(CONST 24) = MNUMP
(CONST 25) = CPA
(CONST 26) = LOG
(CONST 27) = ASYMREDU
(CONST 28) = TRY-LHOSPITAL
(CONST 29) = REAL-INFINITIES
(CONST 30) = MEMQ
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (REAL-INFINITIES *INDICATOR VAR FLAG)
writes special variables : (*INDICATOR FLAG)
205 byte-code instructions:
0     (NIL)
1     (BIND 0)                            ; FLAG
3     (PUSH-NIL 2)
5     (LOAD&CAR&PUSH 7)
7     (JMPIFEQTO 1 L91)                   ; GEN
11    (LOAD 7)
12    (CAR)
13    (SETVALUE 0)                        ; FLAG
15    (LOAD 7)
16    (CDR)
17    (CAR)
18    (STORE 7)
19    (LOAD 6)
20    (CDR)
21    (CAR)
22    (STORE 6)
23    (GETVALUE&PUSH 0)                   ; FLAG
25    (JMPIFEQTO 3 L164)                  ; VAR
29    (GETVALUE&PUSH 0)                   ; FLAG
31    (JMPIFNOTEQTO 19 L303)              ; EXP
35    (LOAD 7)
36    (CDR)
37    (CDR)
38    (CAR)
39    (STORE 7)
40    (LOAD 6)
41    (CDR)
42    (CDR)
43    (CAR)
44    (STORE 6)
45    (LOAD&PUSH 7)
46    (GETVALUE&PUSH 3)                   ; VAR
48    (CALL2&JMPIFNOT 9 L253)             ; POLY?
52    (LOAD&PUSH 6)
53    (GETVALUE&PUSH 3)                   ; VAR
55    (CALL2&JMPIFNOT 9 L253)             ; POLY?
59    (LOAD&PUSH 7)
60    (LOAD&PUSH 7)
61    (CALL2 10)                          ; SUB*
63    (STORE 7)
64    (PUSH)
65    (CALL1&JMPIF 11 L192)               ; ZEROP1
69    (GETVALUE&PUSH 3)                   ; VAR
71    (LOAD&PUSH 8)
72    (CALL2&JMPIFNOT 20 L192)            ; AMONG
76    L76
76    (LOAD&PUSH 7)
77    (CALL1 12)                          ; RAT-NO-RATFAC
79    (CDR)
80    (CAR)
81    (CDR)
82    (CDR)
83    (CAR&PUSH)
84    (CALL1&PUSH 13)                     ; PDIS
86    (CALL1 14)                          ; GETSIGNL
88    (JMP L309)
91    L91
91    (CONST 2)                           ; 0
92    (JMP L309)
95    L95
95    (CONST 6)                           ; 1
96    (JMP L309)
99    L99
99    (CONST 7)                           ; -1
100   (JMP L309)
103   L103
103   (LOAD&PUSH 7)
104   (LOAD&PUSH 7)
105   (CALL2 10)                          ; SUB*
107   (STORE 7)
108   (PUSH)
109   (CALL1&JMPIFNOT 11 L76)             ; ZEROP1
112   (CONST 2)                           ; 0
113   (JMP L309)
116   L116
116   (CONST 2)                           ; 0
117   (JMP L309)
120   L120
120   (CONST 6)                           ; 1
121   (JMP L309)
124   L124
124   (NIL)
125   (SETVALUE 8)                        ; *INDICATOR
127   (LOAD&PUSH 7)
128   (GETVALUE&PUSH 3)                   ; VAR
130   (CALL2&JMPIFNOT 9 L139)             ; POLY?
133   (LOAD&PUSH 6)
134   (GETVALUE&PUSH 3)                   ; VAR
136   (CALL2&JMPIF 9 L103)                ; POLY?
139   L139
139   (LOAD&PUSH 7)
140   (LIST&PUSH 1)
142   (CONST&PUSH 7)                      ; -1
143   (LOAD&PUSH 8)
144   (CALL2&PUSH 15)                     ; MUL
146   (LIST&PUSH 1)
148   (CALL2 16)                          ; RHEUR
150   (STORE 1)
151   (PUSH)
152   (CALL1&JMPIF 17 L116)               ; ZEROP2
155   (LOAD&PUSH 1)
156   (CONST&PUSH 2)                      ; 0
157   (CALL2&JMPIF 18 L120)               ; RATGREATERP
160   (CONST 7)                           ; -1
161   (JMP L309)
164   L164
164   (LOAD&PUSH 7)
165   (CALL1 4)                           ; ISTRENGTH
167   (STORE 1)
168   (LOAD&PUSH 6)
169   (CALL1 4)                           ; ISTRENGTH
171   (STORE 0)
172   (LOAD&PUSH 1)
173   (LOAD&PUSH 1)
174   (CALL2&JMPIF 5 L95)                 ; ISGREATERP
178   (LOAD&PUSH 0)
179   (LOAD&PUSH 2)
180   (CALL2&JMPIF 5 L99)                 ; ISGREATERP
184   (GETVALUE 8)                        ; *INDICATOR
186   (JMPIF L124)
188   (CONST 2)                           ; 0
189   (JMP L309)
192   L192
192   (CONST 2)                           ; 0
193   (JMP L309)
196   L196
196   (CONST 6)                           ; 1
197   (JMP L309)
200   L200
200   (CONST 7)                           ; -1
201   (JMP L309)
204   L204
204   (CONST 6)                           ; 1
205   (JMP L309)
208   L208
208   (CONST 7)                           ; -1
209   (JMP L309)
212   L212
212   (LOAD&PUSH 1)
213   (CONST&PUSH 2)                      ; 0
214   (CALL2&JMPIF 18 L204)               ; RATGREATERP
217   (CONST&PUSH 2)                      ; 0
218   (LOAD&PUSH 2)
219   (CALL2&JMPIF 18 L208)               ; RATGREATERP
222   (CONST 2)                           ; 0
223   (JMP L309)
226   L226
226   (LOAD&PUSH 7)
227   (LIST&PUSH 1)
229   (CONST&PUSH 7)                      ; -1
230   (LOAD&PUSH 8)
231   (CALL2&PUSH 15)                     ; MUL
233   (LIST&PUSH 1)
235   (CALL2 16)                          ; RHEUR
237   (STORE 1)
238   (PUSH)
239   (JMPIFEQTO 22 L196)                 ; $INF
242   (LOAD&PUSH 1)
243   (JMPIFEQTO 23 L200)                 ; $MINF
246   (LOAD&PUSH 1)
247   (CALL1&JMPIF 24 L212)               ; MNUMP
250   (CONST 2)                           ; 0
251   (JMP L309)
253   L253
253   (LOAD&PUSH 7)
254   (GETVALUE&PUSH 3)                   ; VAR
256   (CALL2&JMPIFNOT 21 L265)            ; RADICALP
259   (LOAD&PUSH 6)
260   (GETVALUE&PUSH 3)                   ; VAR
262   (CALL2&JMPIF 21 L226)               ; RADICALP
265   L265
265   (LOAD&PUSH 7)
266   (LOAD&PUSH 7)
267   (T&PUSH)
268   (CALL 3 25)                         ; CPA
271   (JMP L309)
273   L273
273   (CONST 7)                           ; -1
274   (JMP L309)
276   L276
276   (CONST 6)                           ; 1
277   (JMP L309)
279   L279
279   (LOAD&PUSH 7)
280   (CALL1&PUSH 27)                     ; ASYMREDU
282   (LOAD&PUSH 7)
283   (CALL1&PUSH 27)                     ; ASYMREDU
285   (NIL&PUSH)
286   (CALL 3 28)                         ; TRY-LHOSPITAL
289   (STORE 7)
290   (PUSH)
291   (CALL1&JMPIF 17 L273)               ; ZEROP2
294   (LOAD&PUSH 7)
295   (GETVALUE&PUSH 29)                  ; REAL-INFINITIES
297   (CALL2&JMPIF 30 L276)               ; MEMQ
300   (CONST 2)                           ; 0
301   (JMP L309)
303   L303
303   (GETVALUE&PUSH 0)                   ; FLAG
305   (JMPIFEQTO 26 L279)                 ; LOG
308   (NIL)
309   L309
309   (SKIP 2)
311   (UNBIND1)
312   (SKIP&RET 3)


Disassembly of function #:|(SETQ *LIMORDER '(NUM LOG VAR ...))-131|
(CONST 0) = (NUM LOG VAR EXP FACT GEN)
(CONST 1) = *LIMORDER
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*LIMORDER)
3 byte-code instructions:
0     (CONST 0)                           ; (NUM LOG VAR EXP FACT GEN)
1     (SETVALUE 1)                        ; *LIMORDER
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN ISGREATERP (A B) ...)-132|
(CONST 0) = ISGREATERP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ISGREATERP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ISGREATERP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ISGREATERP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ISGREATERP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ISGREATERP
8     (SKIP&RET 1)


Disassembly of function ISGREATERP
(CONST 0) = A
(CONST 1) = B
(CONST 2) = GEN
(CONST 3) = VAR
(CONST 4) = RATGREATERP
(CONST 5) = *LIMORDER
(CONST 6) = MEMQ
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*LIMORDER B A)
46 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; A
3     (LOAD 4)
4     (BIND 1)                            ; B
6     (GETVALUE 0)                        ; A
8     (CAR&PUSH)
9     (GETVALUE 1)                        ; B
11    (CAR&PUSH)
12    (LOAD&PUSH 1)
13    (JMPIFEQTO 2 L39)                   ; GEN
16    (LOAD&PUSH 0)
17    (JMPIFEQTO 2 L39)                   ; GEN
20    (LOAD&PUSH 1)
21    (LOAD 1)
22    (JMPIFNOTEQ L28)
24    (LOAD&PUSH 1)
25    (JMPIFEQTO 3 L44)                   ; VAR
28    L28
28    (LOAD&PUSH 1)
29    (LOAD&PUSH 1)
30    (GETVALUE&PUSH 5)                   ; *LIMORDER
32    (CALL2 6)                           ; MEMQ
34    (CDR&PUSH)
35    (CALL2 6)                           ; MEMQ
37    (JMPIF1 L60)
39    L39
39    (NIL)
40    (SKIP 2)
42    (JMP L62)
44    L44
44    (GETVALUE 0)                        ; A
46    (CDR)
47    (CDR)
48    (CAR&PUSH)
49    (GETVALUE 1)                        ; B
51    (CDR)
52    (CDR)
53    (CAR&PUSH)
54    (CALL2 4)                           ; RATGREATERP
56    (SKIP 2)
58    (JMP L62)
60    L60
60    (SKIP 2)
62    L62
62    (UNBIND 2)
64    (SKIP&RET 3)


Disassembly of function #:|(DEFUN ISMAX (L) ...)-133|
(CONST 0) = ISMAX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ISMAX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ISMAX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ISMAX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ISMAX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ISMAX
8     (SKIP&RET 1)


Disassembly of function ISMAX
(CONST 0) = L
(CONST 1) = 1
(CONST 2) = #<COMPILED-CLOSURE ISMAX-1>
(CONST 3) = ANDMAPC
(CONST 4) = ANS
(CONST 5) = ISGREATERP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS L)
writes special variable : (ANS)
60 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (JMPIFNOT L30)
7     (GETVALUE 0)                        ; L
9     (JMPIFATOM L33)
11    (GETVALUE&PUSH 0)                   ; L
13    (CALLS2&PUSH 71)                    ; LENGTH
15    (CONST&PUSH 1)                      ; 1
16    (CALLSR&JMPIF 1 45 L36)             ; =
20    (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ISMAX-1>
21    (GETVALUE&PUSH 0)                   ; L
23    (CALL2&JMPIF 3 L53)                 ; ANDMAPC
26    (NIL)
27    L27
27    (UNBIND1)
28    (SKIP&RET 2)
30    L30
30    (NIL)
31    (JMP L27)
33    L33
33    (NIL)
34    (JMP L27)
36    L36
36    (GETVALUE 0)                        ; L
38    (CAR)
39    (JMP L27)
41    L41
41    (LOAD 3)
42    (SETVALUE 4)                        ; ANS
44    (JMP L80)
46    L46
46    (LOAD&CAR&STORE 4 3)
49    (SETVALUE 4)                        ; ANS
51    (JMP L80)
53    L53
53    (GETVALUE 0)                        ; L
55    (CDR&PUSH)
56    (GETVALUE 0)                        ; L
58    (CAR&PUSH)
59    (NIL)
60    (BIND 4)                            ; ANS
62    (LOAD&JMPIFNOT 4 L85)
65    L65
65    (LOAD&PUSH 3)
66    (LOAD&CAR&PUSH 5)
68    (CALL2&JMPIF 5 L41)                 ; ISGREATERP
71    (LOAD&CAR&PUSH 4)
73    (LOAD&PUSH 4)
74    (CALL2&JMPIF 5 L46)                 ; ISGREATERP
77    (NIL)
78    (SETVALUE 4)                        ; ANS
80    L80
80    (LOAD&CDR&STORE 4)
82    (LOAD&JMPIF 4 L65)
85    L85
85    (GETVALUE 4)                        ; ANS
87    (UNBIND1)
88    (SKIP 2)
90    (JMP L27)


Disassembly of function ISMAX-1
(CONST 0) = X
(CONST 1) = GEN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (X)
9 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; X
3     (GETVALUE 0)                        ; X
5     (CAR&PUSH)
6     (CONST 1)                           ; GEN
7     (EQ)
8     (NOT)
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN MAXI (L) ...)-134|
(CONST 0) = MAXI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE MAXI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; MAXI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; MAXI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE MAXI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; MAXI
8     (SKIP&RET 1)


Disassembly of function MAXI
(CONST 0) = L
(CONST 1) = DIV*
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = THINK
(CONST 5) = LIMIT
(CONST 6) = INFINITIES
(CONST 7) = MEMQ
(CONST 8) = $UND
(CONST 9) = ZEROP2
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (INFINITIES VAL VAR L)
writes special variable : (L)
88 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (GETVALUE 0)                        ; L
5     (JMPIFATOM L82)
8     (GETVALUE 0)                        ; L
10    (CDR&PUSH)
11    (GETVALUE 0)                        ; L
13    (CAR&PUSH)
14    (GETVALUE 0)                        ; L
16    (CAR&PUSH)
17    (NIL)
18    (CONS&PUSH)
19    (NIL&PUSH)
20    (LOAD 3)
21    (BIND 0)                            ; L
23    (GETVALUE 0)                        ; L
25    (JMPIFNOT L75)
27    L27
27    (GETVALUE 0)                        ; L
29    (CAR&PUSH)
30    (LOAD&PUSH 6)
31    (CALL2&PUSH 1)                      ; DIV*
33    (GETVALUE&PUSH 2)                   ; VAR
35    (GETVALUE&PUSH 3)                   ; VAL
37    (CONST&PUSH 4)                      ; THINK
38    (CALL 4 5)                          ; LIMIT
41    (STORE 3)
42    (PUSH)
43    (GETVALUE&PUSH 6)                   ; INFINITIES
45    (CALL2&JMPIF 7 L85)                 ; MEMQ
48    (LOAD&PUSH 3)
49    (JMPIFEQTO 8 L107)                  ; $UND
52    (LOAD&PUSH 3)
53    (CALL1&JMPIF 9 L66)                 ; ZEROP2
56    (LOAD&PUSH 4)
57    (GETVALUE 0)                        ; L
59    (CAR&PUSH)
60    (NIL)
61    (CONS&PUSH)
62    (CALLSR&STORE 2 34 4)               ; APPEND
66    L66
66    (GETVALUE 0)                        ; L
68    (CDR)
69    (SETVALUE 0)                        ; L
71    (GETVALUE 0)                        ; L
73    (JMPIF L27)
75    L75
75    (LOAD 4)
76    (UNBIND1)
77    (SKIP 4)
79    L79
79    (UNBIND1)
80    (SKIP&RET 2)
82    L82
82    (NIL)
83    (JMP L79)
85    L85
85    (GETVALUE 0)                        ; L
87    (CAR)
88    (STORE 5)
89    (PUSH)
90    (NIL)
91    (CONS)
92    (STORE 4)
93    (JMP L66)
95    L95
95    (GETVALUE 0)                        ; L
97    (CAR)
98    (STORE 6)
99    (PUSH)
100   (NIL)
101   (CONS)
102   (STORE 5)
103   (SKIP 1)
105   (JMP L66)
107   L107
107   (LOAD&PUSH 5)
108   (GETVALUE 0)                        ; L
110   (CAR&PUSH)
111   (CALL2&PUSH 1)                      ; DIV*
113   (GETVALUE&PUSH 2)                   ; VAR
115   (GETVALUE&PUSH 3)                   ; VAL
117   (CONST&PUSH 4)                      ; THINK
118   (CALL&PUSH 4 5)                     ; LIMIT
121   (LOAD&PUSH 0)
122   (CALL1&JMPIF 9 L95)                 ; ZEROP2
125   (SKIP 1)
127   (JMP L66)


Disassembly of function #:|(DEFUN RATMAX (L) ...)-135|
(CONST 0) = RATMAX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATMAX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATMAX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATMAX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATMAX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATMAX
8     (SKIP&RET 1)


Disassembly of function RATMAX
(CONST 0) = L
(CONST 1) = ANS
(CONST 2) = RATGREATERP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS L)
writes special variables : (L ANS)
28 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (NIL)
4     (BIND 1)                            ; ANS
6     (GETVALUE 0)                        ; L
8     (JMPIFCONSP L22)
10    (NIL)
11    (UNBIND1)
12    (JMP L37)
14    L14
14    (GETVALUE&PUSH 1)                   ; ANS
16    (GETVALUE 0)                        ; L
18    (CAR&PUSH)
19    (CALL2&JMPIF 2 L27)                 ; RATGREATERP
22    L22
22    (GETVALUE 0)                        ; L
24    (CAR)
25    (SETVALUE 1)                        ; ANS
27    L27
27    (GETVALUE 0)                        ; L
29    (CDR)
30    (SETVALUE 0)                        ; L
32    (JMPIF L14)
34    (GETVALUE 1)                        ; ANS
36    (UNBIND1)
37    L37
37    (UNBIND1)
38    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RATMIN (L) ...)-136|
(CONST 0) = RATMIN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATMIN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATMIN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATMIN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATMIN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATMIN
8     (SKIP&RET 1)


Disassembly of function RATMIN
(CONST 0) = L
(CONST 1) = ANS
(CONST 2) = RATGREATERP
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS L)
writes special variables : (L ANS)
28 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; L
3     (NIL)
4     (BIND 1)                            ; ANS
6     (GETVALUE 0)                        ; L
8     (JMPIFCONSP L22)
10    (NIL)
11    (UNBIND1)
12    (JMP L37)
14    L14
14    (GETVALUE 0)                        ; L
16    (CAR&PUSH)
17    (GETVALUE&PUSH 1)                   ; ANS
19    (CALL2&JMPIF 2 L27)                 ; RATGREATERP
22    L22
22    (GETVALUE 0)                        ; L
24    (CAR)
25    (SETVALUE 1)                        ; ANS
27    L27
27    (GETVALUE 0)                        ; L
29    (CDR)
30    (SETVALUE 0)                        ; L
32    (JMPIF L14)
34    (GETVALUE 1)                        ; ANS
36    (UNBIND1)
37    L37
37    (UNBIND1)
38    (SKIP&RET 2)


Disassembly of function #:|(DEFUN POFX (E) ...)-137|
(CONST 0) = POFX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE POFX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; POFX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; POFX
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE POFX>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; POFX
8     (SKIP&RET 1)


Disassembly of function POFX
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = 1
(CONST 3) = NN*
(CONST 4) = MNUMP
(CONST 5) = AMONG
(CONST 6) = MEXPTP
(CONST 7) = SIMPLERD
(CONST 8) = POFX
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (NN* VAR E)
writes special variable : (NN*)
51 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L48)
7     (GETVALUE&PUSH 0)                   ; E
9     (CALL1&JMPIF 4 L57)                 ; MNUMP
12    (GETVALUE&PUSH 1)                   ; VAR
14    (GETVALUE&PUSH 0)                   ; E
16    (CALL2&JMPIFNOT 5 L57)              ; AMONG
19    (GETVALUE&PUSH 0)                   ; E
21    (CALL1&JMPIFNOT 6 L63)              ; MEXPTP
24    (GETVALUE 0)                        ; E
26    (CDR)
27    (CAR&PUSH)
28    (GETVALUE 1)                        ; VAR
30    (JMPIFNOTEQ L63)
32    (GETVALUE 0)                        ; E
34    (CDR)
35    (CDR)
36    (CAR)
37    L37
37    (PUSH)
38    (GETVALUE 3)                        ; NN*
40    (CONS)
41    (SETVALUE 3)                        ; NN*
43    (JMP L76)
45    L45
45    (CONST 2)                           ; 1
46    (JMP L37)
48    L48
48    (GETVALUE&PUSH 0)                   ; E
50    (GETVALUE 1)                        ; VAR
52    (JMPIFEQ L45)
54    (NIL)
55    (JMP L76)
57    L57
57    (NIL)
58    (JMP L76)
60    L60
60    (NIL)
61    (JMP L76)
63    L63
63    (GETVALUE&PUSH 0)                   ; E
65    (CALL1&JMPIF 7 L60)                 ; SIMPLERD
68    (CONST&SYMBOL-FUNCTION&PUSH 8)      ; POFX
70    (GETVALUE 0)                        ; E
72    (CDR&PUSH)
73    (CALLSR 0 24)                       ; MAPC
76    L76
76    (UNBIND1)
77    (SKIP&RET 2)


Disassembly of function #:|(DEFUN SER1 (E) ...)-138|
(CONST 0) = SER1
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SER1>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SER1
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SER1
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SER1>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SER1
8     (SKIP&RET 1)


Disassembly of function SER1
(CONST 0) = E
(CONST 1) = VAL
(CONST 2) = ($ZEROA $ZEROB)
(CONST 3) = MEMQ
(CONST 4) = VAR
(CONST 5) = ADD*
(CONST 6) = SUBIN
(CONST 7) = RDFACT
(CONST 8) = POFX
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR VAL)
writes special variable : (E)
24 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAL
5     (CONST&PUSH 2)                      ; ($ZEROA $ZEROB)
6     (CALL2&JMPIF 3 L21)                 ; MEMQ
9     (GETVALUE&PUSH 4)                   ; VAR
11    (GETVALUE&PUSH 1)                   ; VAL
13    (CALL2&PUSH 5)                      ; ADD*
15    (GETVALUE&PUSH 0)                   ; E
17    (CALL2 6)                           ; SUBIN
19    (SETVALUE 0)                        ; E
21    L21
21    (GETVALUE&PUSH 0)                   ; E
23    (CALL1 7)                           ; RDFACT
25    (SETVALUE 0)                        ; E
27    (PUSH)
28    (CALL1&JMPIF 8 L35)                 ; POFX
31    (NIL)
32    L32
32    (UNBIND1)
33    (SKIP&RET 2)
35    L35
35    (GETVALUE 0)                        ; E
37    (JMP L32)


Disassembly of function #:|(DEFUN GATHER (IND L) ...)-139|
(CONST 0) = GATHER
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE GATHER>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; GATHER
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; GATHER
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE GATHER>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; GATHER
8     (SKIP&RET 1)


Disassembly of function GATHER
(CONST 0) = IND
(CONST 1) = L
(CONST 2) = ANS
(CONST 3) = MULN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS L IND)
writes special variables : (L ANS IND)
38 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; IND
3     (LOAD 4)
4     (BIND 1)                            ; L
6     (NIL)
7     (BIND 2)                            ; ANS
9     (GETVALUE 0)                        ; IND
11    (CAR)
12    (SETVALUE 0)                        ; IND
14    (GETVALUE 1)                        ; L
16    (JMPIFNOT L46)
18    L18
18    (GETVALUE 1)                        ; L
20    (CAR)
21    (CAR&PUSH)
22    (GETVALUE&PUSH 0)                   ; IND
24    (CALLS2&JMPIFNOT 2 L37)             ; EQUAL
27    (GETVALUE 1)                        ; L
29    (CAR)
30    (CDR)
31    (CAR&PUSH)
32    (GETVALUE 2)                        ; ANS
34    (CONS)
35    (SETVALUE 2)                        ; ANS
37    L37
37    (GETVALUE 1)                        ; L
39    (CDR)
40    (SETVALUE 1)                        ; L
42    (GETVALUE 1)                        ; L
44    (JMPIF L18)
46    L46
46    (GETVALUE&PUSH 0)                   ; IND
48    (GETVALUE&PUSH 2)                   ; ANS
50    (NIL&PUSH)
51    (CALL2&PUSH 3)                      ; MULN
53    (LIST 2)
55    (UNBIND 3)
57    (SKIP&RET 3)


Disassembly of function #:|(DEFUN ISTRENGTH (TERM) ...)-140|
(CONST 0) = ISTRENGTH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ISTRENGTH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ISTRENGTH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ISTRENGTH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ISTRENGTH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ISTRENGTH
8     (SKIP&RET 1)


Disassembly of function ISTRENGTH
(CONST 0) = MNUMP
(CONST 1) = NUM
(CONST 2) = VAR
(CONST 3) = 1
(CONST 4) = AMONG
(CONST 5) = RADICALP
(CONST 6) = RDDEG
(CONST 7) = MPLUSP
(CONST 8) = ISTRENGTH
(CONST 9) = ISMAX
(CONST 10) = TEMP
(CONST 11) = GEN
(CONST 12) = MTIMESP
(CONST 13) = LOG
(CONST 14) = ADD-UP-DEG
(CONST 15) = MEXPTP
(CONST 16) = VAL
(CONST 17) = LIMIT
(CONST 18) = REAL-INFINITIES
(CONST 19) = MEMQ
(CONST 20) = LOGRED
(CONST 21) = (VAR EXP FACT)
(CONST 22) = EXP
(CONST 23) = $%E
(CONST 24) = POWER*
(CONST 25) = ALIKE1
(CONST 26) = MUL*
(CONST 27) = %LOG
(CONST 28) = (LOG VAR)
(CONST 29) = MFACTORIAL
(CONST 30) = FACT
(CONST 31) = HYPEREX
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (TEMP REAL-INFINITIES VAL VAR)
256 byte-code instructions:
0     L0
0     (LOAD&PUSH 1)
1     (CALL1&JMPIF 0 L106)                ; MNUMP
5     (LOAD 1)
6     (JMPIFATOM L115)
9     (GETVALUE&PUSH 2)                   ; VAR
11    (LOAD&PUSH 2)
12    (CALL2&JMPIFNOT 4 L123)             ; AMONG
16    (LOAD&PUSH 1)
17    (GETVALUE&PUSH 2)                   ; VAR
19    (CALL2&JMPIF 5 L126)                ; RADICALP
23    (LOAD&PUSH 1)
24    (CALL1&JMPIF 7 L142)                ; MPLUSP
28    (LOAD&PUSH 1)
29    (CALL1&JMPIF 12 L177)               ; MTIMESP
33    (LOAD&PUSH 1)
34    (CALL1&JMPIFNOT 15 L52)             ; MEXPTP
37    (LOAD&PUSH 1)
38    (GETVALUE&PUSH 2)                   ; VAR
40    (GETVALUE&PUSH 16)                  ; VAL
42    (T&PUSH)
43    (CALL&PUSH 4 17)                    ; LIMIT
46    (GETVALUE&PUSH 18)                  ; REAL-INFINITIES
48    (CALL2&JMPIF 19 L280)               ; MEMQ
52    L52
52    (LOAD 1)
53    (CAR)
54    (CAR&PUSH)
55    (JMPIFNOTEQTO 27 L73)               ; %LOG
58    (LOAD&PUSH 1)
59    (GETVALUE&PUSH 2)                   ; VAR
61    (GETVALUE&PUSH 16)                  ; VAL
63    (T&PUSH)
64    (CALL&PUSH 4 17)                    ; LIMIT
67    (GETVALUE&PUSH 18)                  ; REAL-INFINITIES
69    (CALL2&JMPIF 19 L351)               ; MEMQ
73    L73
73    (LOAD 1)
74    (CAR)
75    (CAR&PUSH)
76    (JMPIFEQTO 29 L375)                 ; MFACTORIAL
80    (LOAD&PUSH 1)
81    (CALL1 31)                          ; HYPEREX
83    (BIND 10)                           ; TEMP
85    (LOAD&PUSH 4)
86    (GETVALUE&PUSH 10)                  ; TEMP
88    (CALL2 25)                          ; ALIKE1
90    (NOT)
91    (JMPIF L380)
94    (UNBIND1)
95    (JMPIF1 L391)
98    L98
98    (CONST 11)                          ; GEN
99    L99
99    (PUSH)
100   (LOAD 2)
101   L101
101   (PUSH)
102   (LIST 2)
104   (SKIP&RET 2)
106   L106
106   (CONST 1)                           ; NUM
107   (JMP L99)
109   L109
109   (CONST&PUSH 2)                      ; VAR
110   (GETVALUE&PUSH 2)                   ; VAR
112   (CONST 3)                           ; 1
113   (JMP L132)
115   L115
115   (LOAD&PUSH 1)
116   (GETVALUE 2)                        ; VAR
118   (JMPIFEQ L109)
120   (CONST 1)                           ; NUM
121   (JMP L99)
123   L123
123   (CONST 1)                           ; NUM
124   (JMP L99)
126   L126
126   (CONST&PUSH 2)                      ; VAR
127   (LOAD&PUSH 2)
128   (LOAD&PUSH 3)
129   (NIL&PUSH)
130   (CALL2 6)                           ; RDDEG
132   L132
132   (PUSH)
133   (LIST 3)
135   (SKIP&RET 2)
137   L137
137   (GETVALUE 10)                       ; TEMP
139   (JMP L277)
142   L142
142   (CONST&SYMBOL-FUNCTION&PUSH 8)      ; ISTRENGTH
144   (LOAD&CDR&PUSH 2)
146   (CALLSR&PUSH 0 22)                  ; MAPCAR
149   (CALL1 9)                           ; ISMAX
151   (BIND 10)                           ; TEMP
153   (GETVALUE 10)                       ; TEMP
155   (JMPIF L137)
157   (CONST 11)                          ; GEN
158   (JMP L273)
161   L161
161   (CONST&PUSH 11)                     ; GEN
162   (LOAD 6)
163   (JMP L208)
165   L165
165   (CONST 13)                          ; LOG
166   (JMP L205)
168   L168
168   (GETVALUE&PUSH 10)                  ; TEMP
170   (CALL1 14)                          ; ADD-UP-DEG
172   (SKIP 1)
174   (JMP L277)
177   L177
177   (CONST&SYMBOL-FUNCTION&PUSH 8)      ; ISTRENGTH
179   (LOAD&CDR&PUSH 2)
181   (CALLSR 0 22)                       ; MAPCAR
184   (BIND 10)                           ; TEMP
186   (NIL&PUSH)
187   (GETVALUE&PUSH 10)                  ; TEMP
189   (CALL1 9)                           ; ISMAX
191   (STORE 0)
192   (JMPIFNOT L161)
194   (LOAD&CAR&PUSH 0)
196   (JMPIFEQTO 13 L165)                 ; LOG
199   (LOAD&CAR&PUSH 0)
201   (JMPIFEQTO 2 L168)                  ; VAR
204   (CONST 11)                          ; GEN
205   L205
205   (PUSH)
206   (GETVALUE 10)                       ; TEMP
208   L208
208   (PUSH)
209   (LIST 2)
211   (SKIP 1)
213   (JMP L277)
215   L215
215   (CONST&PUSH 22)                     ; EXP
216   (CONST 23)                          ; $%E
218   (JMP L330)
221   L221
221   (GETVALUE 10)                       ; TEMP
223   (CDR)
224   (CDR&PUSH)
225   (GETVALUE 10)                       ; TEMP
227   (CDR)
228   (CDR)
229   (CAR&PUSH)
230   (LOAD 6)
231   (CDR)
232   (CDR)
233   (CAR&PUSH)
234   (CALL2&PUSH 26)                     ; MUL*
236   (CALLS1 168)                        ; RPLACA
238   (GETVALUE 10)                       ; TEMP
240   (JMP L277)
242   L242
242   (GETVALUE 10)                       ; TEMP
244   (CDR&PUSH)
245   (LOAD&PUSH 5)
246   (CALLS1 168)                        ; RPLACA
248   (GETVALUE 10)                       ; TEMP
250   (CAR&PUSH)
251   (JMPIFEQTO 2 L221)                  ; VAR
254   (GETVALUE 10)                       ; TEMP
256   (JMP L277)
258   L258
258   (LOAD 1)
259   (CDR)
260   (CAR&PUSH)
261   (JSR L0)
264   (BIND 10)                           ; TEMP
266   (GETVALUE&PUSH 10)                  ; TEMP
268   (LOAD&PUSH 5)
269   (CALL2&JMPIFNOT 25 L242)            ; ALIKE1
272   (CONST 11)                          ; GEN
273   L273
273   (PUSH)
274   (LOAD&PUSH 5)
275   (LIST 2)
277   L277
277   (UNBIND1)
278   (SKIP&RET 2)
280   L280
280   (GETVALUE&PUSH 2)                   ; VAR
282   (LOAD 2)
283   (CDR)
284   (CDR)
285   (CAR&PUSH)
286   (CALL2&JMPIFNOT 4 L317)             ; AMONG
289   (LOAD&PUSH 1)
290   (CALL1 20)                          ; LOGRED
292   (STORE 1)
293   (PUSH)
294   (JSR L0)
297   (CAR&PUSH)
298   (CONST&PUSH 21)                     ; (VAR EXP FACT)
299   (CALL2&JMPIFNOT 19 L317)            ; MEMQ
302   (LOAD&PUSH 1)
303   (GETVALUE&PUSH 2)                   ; VAR
305   (GETVALUE&PUSH 16)                  ; VAL
307   (T&PUSH)
308   (CALL&PUSH 4 17)                    ; LIMIT
311   (GETVALUE&PUSH 18)                  ; REAL-INFINITIES
313   (CALL2&JMPIF 19 L215)               ; MEMQ
317   L317
317   (GETVALUE&PUSH 2)                   ; VAR
319   (LOAD 2)
320   (CDR)
321   (CDR)
322   (CAR&PUSH)
323   (CALL2&JMPIFNOT 4 L258)             ; AMONG
327   (CONST&PUSH 11)                     ; GEN
328   (CONST 23)                          ; $%E
330   L330
330   (PUSH)
331   (LOAD&PUSH 3)
332   (CALL2 24)                          ; POWER*
334   (JMP L101)
337   L337
337   (CONST 13)                          ; LOG
338   (JMP L369)
340   L340
340   (LOAD 0)
341   (CDR)
342   (CAR)
343   (CDR)
344   (CDR)
345   (CAR&PUSH)
346   (JMPTAIL 1 4 L0)
351   L351
351   (LOAD 1)
352   (CDR)
353   (CAR&PUSH)
354   (JSR&PUSH L0)
357   (LOAD&CAR&PUSH 0)
359   (CONST&PUSH 28)                     ; (LOG VAR)
360   (CALL2&JMPIF 19 L337)               ; MEMQ
363   (LOAD&CAR&PUSH 0)
365   (JMPIFEQTO 22 L340)                 ; EXP
368   (CONST 11)                          ; GEN
369   L369
369   (PUSH)
370   (LOAD&PUSH 3)
371   (LIST 2)
373   (SKIP&RET 3)
375   L375
375   (CONST 30)                          ; FACT
377   (JMP L99)
380   L380
380   (GETVALUE&PUSH 10)                  ; TEMP
382   (JSR L0)
385   (UNBIND1)
386   (JMPIF1 L391)
388   (JMP L98)
391   L391
391   (SKIP&RET 2)


Disassembly of function #:|(DEFUN LOGRED (S1) ...)-141|
(CONST 0) = LOGRED
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LOGRED>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LOGRED
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LOGRED
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LOGRED>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LOGRED
8     (SKIP&RET 1)


Disassembly of function LOGRED
(CONST 0) = $%E
(CONST 1) = (%LOG)
(CONST 2) = MUL
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
23 byte-code instructions:
0     (LOAD 1)
1     (CDR)
2     (CAR&PUSH)
3     (JMPIFNOTEQTO 0 L12)                ; $%E
6     (LOAD 1)
7     (CDR)
8     (CDR)
9     (CAR)
10    (JMPIF1 L26)
12    L12
12    (LOAD 1)
13    (CDR)
14    (CDR)
15    (CAR&PUSH)
16    (CONST&PUSH 1)                      ; (%LOG)
17    (LOAD 3)
18    (CDR)
19    (CAR&PUSH)
20    (LIST&PUSH 2)
22    (CALL2 2)                           ; MUL
24    (SKIP&RET 2)
26    L26
26    (SKIP&RET 2)


Disassembly of function #:|(DEFUN ASYMREDU (RD) ...)-142|
(CONST 0) = ASYMREDU
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ASYMREDU>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ASYMREDU
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ASYMREDU
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ASYMREDU>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ASYMREDU
8     (SKIP&RET 1)


Disassembly of function ASYMREDU
(CONST 0) = MNUMP
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = POLYINX
(CONST 4) = SIMPLERD
(CONST 5) = POWER*
(CONST 6) = $EXPAND
(CONST 7) = FACTOR
(CONST 8) = VAL
(CONST 9) = MABS-SUBST
(CONST 10) = ASYMREDU
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR)
53 byte-code instructions:
0     (LOAD 1)
1     (JMPIFATOM L33)
3     (LOAD&PUSH 1)
4     (CALL1&JMPIF 0 L33)                 ; MNUMP
7     (GETVALUE&PUSH 1)                   ; VAR
9     (LOAD&PUSH 2)
10    (CALL2&JMPIFNOT 2 L33)              ; AMONG
13    (LOAD&PUSH 1)
14    (GETVALUE&PUSH 1)                   ; VAR
16    (T&PUSH)
17    (CALL 3 3)                          ; POLYINX
20    (JMPIF1 L81)
22    (LOAD&PUSH 1)
23    (CALL1&JMPIFNOT 4 L64)              ; SIMPLERD
26    (LOAD 1)
27    (CDR)
28    (CAR&PUSH)
29    (GETVALUE 1)                        ; VAR
31    (JMPIFNOTEQ L36)
33    L33
33    (LOAD 1)
34    (SKIP&RET 2)
36    L36
36    (LOAD 1)
37    (CDR)
38    (CAR&PUSH)
39    (GETVALUE&PUSH 1)                   ; VAR
41    (T&PUSH)
42    (CALL&PUSH 3 3)                     ; POLYINX
45    (LOAD 2)
46    (CDR)
47    (CDR)
48    (CAR&PUSH)
49    (CALL2&PUSH 5)                      ; POWER*
51    (CALL1&PUSH 6)                      ; $EXPAND
53    (CALL1&PUSH 7)                      ; FACTOR
55    (GETVALUE&PUSH 1)                   ; VAR
57    (GETVALUE&PUSH 8)                   ; VAL
59    (CALL 3 9)                          ; MABS-SUBST
62    (SKIP&RET 2)
64    L64
64    (LOAD 1)
65    (CAR)
66    (CAR&PUSH)
67    (LIST&PUSH 1)
69    (CONST&SYMBOL-FUNCTION&PUSH 10)     ; ASYMREDU
71    (LOAD&CDR&PUSH 3)
73    (CALLSR 0 22)                       ; MAPCAR
76    (CONS&PUSH)
77    (CALL1 11)                          ; SIMPLIFY
79    (SKIP&RET 2)
81    L81
81    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RDFACT (RD) ...)-143|
(CONST 0) = RDFACT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RDFACT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RDFACT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RDFACT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RDFACT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RDFACT
8     (SKIP&RET 1)


Disassembly of function RDFACT
(CONST 0) = MNUMP
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = POLYP
(CONST 4) = FACTOR
(CONST 5) = SIMPLERD
(CONST 6) = MTIMESP
(CONST 7) = J
(CONST 8) = POWER*
(CONST 9) = MULN
(CONST 10) = RDFACT
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (J VAR)
73 byte-code instructions:
0     (PUSH-NIL 2)
2     (LOAD 3)
3     (JMPIFATOM L46)
5     (LOAD&PUSH 3)
6     (CALL1&JMPIF 0 L46)                 ; MNUMP
9     (GETVALUE&PUSH 1)                   ; VAR
11    (LOAD&PUSH 4)
12    (CALL2&JMPIFNOT 2 L46)              ; AMONG
15    (LOAD&PUSH 3)
16    (CALL1&JMPIF 3 L49)                 ; POLYP
19    (LOAD&PUSH 3)
20    (CALL1&JMPIFNOT 5 L92)              ; SIMPLERD
24    (LOAD 3)
25    (CDR)
26    (CAR&PUSH)
27    (GETVALUE 1)                        ; VAR
29    (JMPIFEQ L46)
31    (LOAD 3)
32    (CDR)
33    (CDR)
34    (CAR)
35    (STORE 1)
36    (LOAD 3)
37    (CDR)
38    (CAR&PUSH)
39    (CALL1 4)                           ; FACTOR
41    (STORE 0)
42    (PUSH)
43    (CALL1&JMPIF 6 L54)                 ; MTIMESP
46    L46
46    (LOAD 3)
47    (SKIP&RET 4)
49    L49
49    (LOAD&PUSH 3)
50    (CALL1 4)                           ; FACTOR
52    (SKIP&RET 4)
54    L54
54    (NIL&PUSH)
55    (LOAD&CDR&PUSH 1)
57    (JMP L77)
59    L59
59    (LOAD&CAR&PUSH 0)
61    (LOAD 0)
62    (BIND 7)                            ; J
64    (GETVALUE&PUSH 7)                   ; J
66    (LOAD&PUSH 8)
67    (CALL2 8)                           ; POWER*
69    (UNBIND1)
70    (PUSH)
71    (LOAD&CONS&STORE 2)
73    (SKIP 1)
75    (LOAD&CDR&STORE 0)
77    L77
77    (LOAD&PUSH 0)
78    (CALLS1&JMPIFNOT 146 L59)           ; ENDP
81    (SKIP 1)
83    (LOAD&PUSH 0)
84    (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
87    (NIL&PUSH)
88    (CALL2 9)                           ; MULN
90    (SKIP&RET 4)
92    L92
92    (LOAD 3)
93    (CAR)
94    (CAR&PUSH)
95    (NIL)
96    (CONS&PUSH)
97    (CONST&SYMBOL-FUNCTION&PUSH 10)     ; RDFACT
99    (LOAD&CDR&PUSH 5)
101   (CALLSR 0 22)                       ; MAPCAR
104   (CONS&PUSH)
105   (CALL1 11)                          ; SIMPLIFY
107   (SKIP&RET 4)


Disassembly of function #:|(DEFUN CNV (EXPL VAL) ...)-144|
(CONST 0) = CNV
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE CNV>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; CNV
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; CNV
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE CNV>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; CNV
8     (SKIP&RET 1)


Disassembly of function CNV
(CONST 0) = VAL
(CONST 1) = E
(CONST 2) = $ZEROB
(CONST 3) = -1
(CONST 4) = VAR
(CONST 5) = POWER*
(CONST 6) = MUL*
(CONST 7) = $ZEROA
(CONST 8) = $MINF
(CONST 9) = ADD*
(CONST 10) = MAXIMA-SUBSTITUTE
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR VAL)
60 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; VAL
3     (NIL&PUSH)
4     (LOAD&PUSH 6)
5     L5
5     (LOAD&PUSH 0)
6     (CALLS1&JMPIF 146 L83)              ; ENDP
10    (LOAD&CAR&PUSH 0)
12    (LOAD 0)
13    (BIND 1)                            ; E
15    (GETVALUE&PUSH 0)                   ; VAL
17    (JMPIFEQTO 2 L38)                   ; $ZEROB
20    (GETVALUE&PUSH 0)                   ; VAL
22    (JMPIFEQTO 7 L46)                   ; $ZEROA
25    (GETVALUE&PUSH 0)                   ; VAL
27    (JMPIFNOTEQTO 8 L51)                ; $MINF
30    (CONST&PUSH 3)                      ; -1
31    (GETVALUE 4)                        ; VAR
33    L33
33    (PUSH)
34    (CALL2 6)                           ; MUL*
36    (JMP L64)
38    L38
38    (CONST&PUSH 3)                      ; -1
39    (GETVALUE&PUSH 4)                   ; VAR
41    (CONST&PUSH 3)                      ; -1
42    (CALL2 5)                           ; POWER*
44    (JMP L33)
46    L46
46    (GETVALUE&PUSH 4)                   ; VAR
48    (CONST 3)                           ; -1
49    (JMP L61)
51    L51
51    (GETVALUE&PUSH 4)                   ; VAR
53    (CONST&PUSH 3)                      ; -1
54    (GETVALUE&PUSH 0)                   ; VAL
56    (CALL2&PUSH 6)                      ; MUL*
58    (CALL2&PUSH 9)                      ; ADD*
60    (CONST 3)                           ; -1
61    L61
61    (PUSH)
62    (CALL2 5)                           ; POWER*
64    L64
64    (PUSH)
65    (GETVALUE&PUSH 4)                   ; VAR
67    (GETVALUE&PUSH 1)                   ; E
69    (CALL 3 10)                         ; MAXIMA-SUBSTITUTE
72    (UNBIND1)
73    (PUSH)
74    (LOAD&CONS&STORE 2)
76    (SKIP 1)
78    (LOAD&CDR&STORE 0)
80    (JMP L5)
83    L83
83    (SKIP 1)
85    (LOAD&PUSH 0)
86    (CALLS1 164)                        ; SYSTEM::LIST-NREVERSE
88    (SKIP 1)
90    (UNBIND1)
91    (SKIP&RET 3)


Disassembly of function #:|(DEFUN PWTAYLOR (EXP VAR L ...) ...)-145|
(CONST 0) = PWTAYLOR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PWTAYLOR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PWTAYLOR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PWTAYLOR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PWTAYLOR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PWTAYLOR
8     (SKIP&RET 1)


Disassembly of function PWTAYLOR
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = L
(CONST 3) = COEF
(CONST 4) = ANS
(CONST 5) = C
(CONST 6) = 0
(CONST 7) = 10
(CONST 8) = ADDN
(CONST 9) = SDIFF
(CONST 10) = SUBIN
(CONST 11) = $RADCAN
(CONST 12) = (MFACTORIAL)
(CONST 13) = -1
(CONST 14) = POWER*
(CONST 15) = MUL
(CONST 16) = ADD
(CONST 17) = MUL*
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C COEF ANS EXP VAR L)
writes special variables : (ANS COEF EXP C)
86 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; L
9     (NIL)
10    (BIND 3)                            ; COEF
12    (NIL)
13    (BIND 4)                            ; ANS
15    (NIL)
16    (BIND 5)                            ; C
18    (NIL&PUSH)
19    (LOAD&PUSH 20)
20    (JMPIFEQTO 6 L35)                   ; 0
23    (GETVALUE&PUSH 2)                   ; L
25    (JMPIFNOTEQTO 6 L30)                ; 0
28    (T&STORE 0)
30    L30
30    (CONST 6)                           ; 0
31    (SETVALUE 5)                        ; C
33    (JMP L60)
35    L35
35    (NIL)
36    (SKIP 1)
38    (UNBIND 3)
40    (JMP L141)
43    L43
43    (LOAD&INC&STORE 20)
45    (JMP L113)
48    L48
48    (GETVALUE 1)                        ; VAR
50    (JMP L98)
52    L52
52    (GETVALUE&PUSH 0)                   ; EXP
54    (GETVALUE&PUSH 1)                   ; VAR
56    (CALL2 9)                           ; SDIFF
58    (SETVALUE 0)                        ; EXP
60    L60
60    (GETVALUE&PUSH 2)                   ; L
62    (GETVALUE&PUSH 0)                   ; EXP
64    (CALL2&PUSH 10)                     ; SUBIN
66    (CALL1 11)                          ; $RADCAN
68    (SETVALUE 3)                        ; COEF
70    (PUSH)
71    (JMPIFEQTO 6 L43)                   ; 0
74    (GETVALUE&PUSH 4)                   ; ANS
76    (GETVALUE&PUSH 3)                   ; COEF
78    (CONST&PUSH 12)                     ; (MFACTORIAL)
79    (GETVALUE&PUSH 5)                   ; C
81    (LIST&PUSH 2)
83    (CONST&PUSH 13)                     ; -1
84    (CALL2&PUSH 14)                     ; POWER*
86    (LOAD&JMPIF 3 L48)
89    (CONST&PUSH 13)                     ; -1
90    (GETVALUE&PUSH 2)                   ; L
92    (CALL2&PUSH 15)                     ; MUL
94    (GETVALUE&PUSH 1)                   ; VAR
96    (CALL2 16)                          ; ADD
98    L98
98    (PUSH)
99    (GETVALUE&PUSH 5)                   ; C
101   (CALL2&PUSH 14)                     ; POWER*
103   (CALL&PUSH 3 17)                    ; MUL*
106   (LIST&PUSH 1)
108   (CALLSR 2 34)                       ; APPEND
111   (SETVALUE 4)                        ; ANS
113   L113
113   (GETVALUE&PUSH 5)                   ; C
115   (CALLS2 150)                        ; 1+
117   (SETVALUE 5)                        ; C
119   (PUSH)
120   (CONST&PUSH 7)                      ; 10
121   (CALLSR&JMPIF 1 48 L132)            ; >
125   (GETVALUE&PUSH 5)                   ; C
127   (LOAD&PUSH 21)
128   (CALLS2&JMPIFNOT 2 L52)             ; EQUAL
132   L132
132   (GETVALUE&PUSH 4)                   ; ANS
134   (NIL&PUSH)
135   (CALL2 8)                           ; ADDN
137   (SKIP 1)
139   (UNBIND 3)
141   L141
141   (UNBIND 3)
143   (SKIP&RET 5)


Disassembly of function #:|(DEFUN RDSGET (E) ...)-146|
(CONST 0) = RDSGET
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RDSGET>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RDSGET
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RDSGET
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RDSGET>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RDSGET
8     (SKIP&RET 1)


Disassembly of function RDSGET
(CONST 0) = E
(CONST 1) = POLYP
(CONST 2) = SIMPLERD
(CONST 3) = RDTAY
(CONST 4) = RDSGET
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
25 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CALL1&JMPIF 1 L31)                 ; POLYP
8     (GETVALUE&PUSH 0)                   ; E
10    (CALL1&JMPIF 2 L35)                 ; SIMPLERD
13    (GETVALUE 0)                        ; E
15    (CAR)
16    (CAR&PUSH)
17    (LIST&PUSH 1)
19    (CONST&SYMBOL-FUNCTION&PUSH 4)      ; RDSGET
21    (GETVALUE 0)                        ; E
23    (CDR&PUSH)
24    (CALLSR 0 22)                       ; MAPCAR
27    (CONS)
28    L28
28    (UNBIND1)
29    (SKIP&RET 2)
31    L31
31    (GETVALUE 0)                        ; E
33    (JMP L28)
35    L35
35    (GETVALUE&PUSH 0)                   ; E
37    (CALL1 3)                           ; RDTAY
39    (JMP L28)


Disassembly of function #:|(DEFUN RDTAY (RD) ...)-147|
(CONST 0) = RDTAY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RDTAY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RDTAY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RDTAY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RDTAY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RDTAY
8     (SKIP&RET 1)


Disassembly of function RDTAY
(CONST 0) = $TLIMSWITCH
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = 1
(CONST 4) = $TAYLOR
(CONST 5) = $RATDISREP
(CONST 6) = LRDTAY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR $TLIMSWITCH)
13 byte-code instructions:
0     (GETVALUE 0)                        ; $TLIMSWITCH
2     (JMPIF L9)
4     (LOAD&PUSH 1)
5     (CALL1 6)                           ; LRDTAY
7     (SKIP&RET 2)
9     L9
9     (LOAD&PUSH 1)
10    (GETVALUE&PUSH 1)                   ; VAR
12    (GETVALUE&PUSH 2)                   ; VAL
14    (CONST&PUSH 3)                      ; 1
15    (CALL&PUSH 4 4)                     ; $TAYLOR
18    (CALL1 5)                           ; $RATDISREP
20    (SKIP&RET 2)


Disassembly of function #:|(DEFUN LRDTAY (RD) ...)-148|
(CONST 0) = LRDTAY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LRDTAY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LRDTAY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LRDTAY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LRDTAY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LRDTAY
8     (SKIP&RET 1)


Disassembly of function LRDTAY
(CONST 0) = VARLIST
(CONST 1) = P
(CONST 2) = C
(CONST 3) = E
(CONST 4) = D
(CONST 5) = $RATFAC
(CONST 6) = VAR
(CONST 7) = RATREP*
(CONST 8) = RATNUMERATOR
(CONST 9) = 3
(CONST 10) = PDEGR
(CONST 11) = MUL*
(CONST 12) = POWER*
(CONST 13) = PDIS
(CONST 14) = -1
(CONST 15) = VARINVERT
(CONST 16) = $RATSIMP
(CONST 17) = 0
(CONST 18) = PWTAYLOR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C E D P VAR)
writes special variables : (C D E P VARLIST)
72 byte-code instructions:
0     (NIL)
1     (BIND 0)                            ; VARLIST
3     (NIL)
4     (BIND 1)                            ; P
6     (NIL)
7     (BIND 2)                            ; C
9     (NIL)
10    (BIND 3)                            ; E
12    (NIL)
13    (BIND 4)                            ; D
15    (NIL)
16    (BIND 5)                            ; $RATFAC
18    (GETVALUE&PUSH 6)                   ; VAR
20    (NIL)
21    (CONS)
22    (SETVALUE 0)                        ; VARLIST
24    (LOAD 19)
26    (CDR)
27    (CAR&PUSH)
28    (CALL1 7)                           ; RATREP*
30    (CDR&PUSH)
31    (CALL1 8)                           ; RATNUMERATOR
33    (SETVALUE 1)                        ; P
35    (PUSH)
36    (CALLS2&PUSH 71)                    ; LENGTH
38    (CONST&PUSH 9)                      ; 3
39    (CALLSR&JMPIF 1 47 L120)            ; <
44    (LOAD 19)
46    (CDR)
47    (CDR)
48    (CAR)
49    (SETVALUE 3)                        ; E
51    (GETVALUE&PUSH 1)                   ; P
53    (CALL1 10)                          ; PDEGR
55    (SETVALUE 4)                        ; D
57    (GETVALUE&PUSH 6)                   ; VAR
59    (GETVALUE&PUSH 4)                   ; D
61    (GETVALUE&PUSH 3)                   ; E
63    (CALL2&PUSH 11)                     ; MUL*
65    (CALL2 12)                          ; POWER*
67    (SETVALUE 2)                        ; C
69    (GETVALUE&PUSH 1)                   ; P
71    (CALL1&PUSH 13)                     ; PDIS
73    (GETVALUE&PUSH 6)                   ; VAR
75    (CONST&PUSH 14)                     ; -1
76    (GETVALUE&PUSH 4)                   ; D
78    (CALL2&PUSH 11)                     ; MUL*
80    (CALL2&PUSH 12)                     ; POWER*
82    (CALL2&PUSH 11)                     ; MUL*
84    (GETVALUE&PUSH 6)                   ; VAR
86    (CALL2&PUSH 15)                     ; VARINVERT
88    (CALL1 16)                          ; $RATSIMP
90    (SETVALUE 4)                        ; D
92    (PUSH)
93    (GETVALUE&PUSH 3)                   ; E
95    (CALL2&PUSH 12)                     ; POWER*
97    (GETVALUE&PUSH 6)                   ; VAR
99    (CONST&PUSH 17)                     ; 0
100   (CONST&PUSH 9)                      ; 3
101   (CALL 4 18)                         ; PWTAYLOR
104   (SETVALUE 4)                        ; D
106   (GETVALUE&PUSH 2)                   ; C
108   (GETVALUE&PUSH 4)                   ; D
110   (GETVALUE&PUSH 6)                   ; VAR
112   (CALL2&PUSH 15)                     ; VARINVERT
114   (CALL2 11)                          ; MUL*
116   L116
116   (UNBIND 6)
118   (SKIP&RET 2)
120   L120
120   (LOAD 19)
122   (JMP L116)


Disassembly of function #:|(DEFUN VARINVERT (E VAR) ...)-149|
(CONST 0) = VARINVERT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE VARINVERT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; VARINVERT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; VARINVERT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE VARINVERT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; VARINVERT
8     (SKIP&RET 1)


Disassembly of function VARINVERT
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = -1
(CONST 3) = POWER
(CONST 4) = SUBIN
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E VAR)
11 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; E
3     (LOAD 4)
4     (BIND 1)                            ; VAR
6     (GETVALUE&PUSH 1)                   ; VAR
8     (CONST&PUSH 2)                      ; -1
9     (CALL2&PUSH 3)                      ; POWER
11    (GETVALUE&PUSH 0)                   ; E
13    (CALL2 4)                           ; SUBIN
15    (UNBIND 2)
17    (SKIP&RET 3)


Disassembly of function #:|(DEFUN DEG (P) ...)-150|
(CONST 0) = DEG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE DEG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; DEG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; DEG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE DEG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; DEG
8     (SKIP&RET 1)


Disassembly of function DEG
(CONST 0) = P
(CONST 1) = VARLIST
(CONST 2) = VAR
(CONST 3) = $RATFAC
(CONST 4) = NEWVAR
(CONST 5) = RATREP*
(CONST 6) = PDEGR
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (P VAR)
writes special variable : (VARLIST)
18 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; P
3     (NIL)
4     (BIND 1)                            ; VARLIST
6     (GETVALUE&PUSH 2)                   ; VAR
8     (LIST 1)
10    (SETVALUE 1)                        ; VARLIST
12    (NIL)
13    (BIND 3)                            ; $RATFAC
15    (GETVALUE&PUSH 0)                   ; P
17    (CALL1 4)                           ; NEWVAR
19    (GETVALUE&PUSH 0)                   ; P
21    (CALL1 5)                           ; RATREP*
23    (CDR)
24    (CAR&PUSH)
25    (CALL1 6)                           ; PDEGR
27    (UNBIND 3)
29    (SKIP&RET 2)


Disassembly of function #:|(DEFUN RAT-NO-RATFAC (E) ...)-151|
(CONST 0) = RAT-NO-RATFAC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RAT-NO-RATFAC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RAT-NO-RATFAC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RAT-NO-RATFAC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RAT-NO-RATFAC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RAT-NO-RATFAC
8     (SKIP&RET 1)


Disassembly of function RAT-NO-RATFAC
(CONST 0) = E
(CONST 1) = $RATFAC
(CONST 2) = NEWVAR
(CONST 3) = RATREP*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
10 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (NIL)
4     (BIND 1)                            ; $RATFAC
6     (GETVALUE&PUSH 0)                   ; E
8     (CALL1 2)                           ; NEWVAR
10    (GETVALUE&PUSH 0)                   ; E
12    (CALL1 3)                           ; RATREP*
14    (UNBIND 2)
16    (SKIP&RET 2)


Disassembly of function #:|(SETQ LOW* NIL)-152|
(CONST 0) = LOW*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (LOW*)
3 byte-code instructions:
0     (NIL)
1     (SETVALUE 0)                        ; LOW*
3     (SKIP&RET 1)


Disassembly of function #:|(DEFUN RDDEG (RD LOW*) ...)-153|
(CONST 0) = RDDEG
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RDDEG>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RDDEG
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RDDEG
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RDDEG>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RDDEG
8     (SKIP&RET 1)


Disassembly of function RDDEG
(CONST 0) = LOW*
(CONST 1) = MNUMP
(CONST 2) = VAR
(CONST 3) = AMONG
(CONST 4) = 0
(CONST 5) = POLYP
(CONST 6) = DEG
(CONST 7) = SIMPLERD
(CONST 8) = MUL*
(CONST 9) = MTIMESP
(CONST 10) = J
(CONST 11) = ADDN
(CONST 12) = MPLUSP
(CONST 13) = #<COMPILED-CLOSURE RDDEG-1>
(CONST 14) = ANDMAPCAR
(CONST 15) = RATMIN
(CONST 16) = RATMAX
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LOW* J VAR)
79 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; LOW*
3     (LOAD&PUSH 5)
4     (CALL1&JMPIF 1 L42)                 ; MNUMP
7     (GETVALUE&PUSH 2)                   ; VAR
9     (LOAD&PUSH 6)
10    (CALL2&JMPIFNOT 3 L42)              ; AMONG
13    (LOAD&PUSH 5)
14    (CALL1&JMPIF 5 L45)                 ; POLYP
17    (LOAD&PUSH 5)
18    (CALL1&JMPIF 7 L50)                 ; SIMPLERD
21    (LOAD&PUSH 5)
22    (CALL1&JMPIF 9 L63)                 ; MTIMESP
25    (LOAD&PUSH 5)
26    (CALL1&JMPIFNOT 12 L38)             ; MPLUSP
29    (CONST&PUSH 13)                     ; #<COMPILED-CLOSURE RDDEG-1>
30    (LOAD&CDR&PUSH 6)
32    (CALL2 14)                          ; ANDMAPCAR
34    (STORE 5)
35    (JMPIF L109)
38    L38
38    (NIL)
39    L39
39    (UNBIND1)
40    (SKIP&RET 3)
42    L42
42    (CONST 4)                           ; 0
43    (JMP L39)
45    L45
45    (LOAD&PUSH 5)
46    (CALL1 6)                           ; DEG
48    (JMP L39)
50    L50
50    (LOAD 5)
51    (CDR)
52    (CAR&PUSH)
53    (CALL1&PUSH 6)                      ; DEG
55    (LOAD 6)
56    (CDR)
57    (CDR)
58    (CAR&PUSH)
59    (CALL2 8)                           ; MUL*
61    (JMP L39)
63    L63
63    (NIL&PUSH)
64    (LOAD&CDR&PUSH 6)
66    (JMP L88)
68    L68
68    (LOAD&CAR&PUSH 0)
70    (LOAD 0)
71    (BIND 10)                           ; J
73    (GETVALUE&PUSH 10)                  ; J
75    (GETVALUE&PUSH 0)                   ; LOW*
77    (JSR L0)
80    (UNBIND1)
81    (PUSH)
82    (LOAD&CONS&STORE 2)
84    (SKIP 1)
86    (LOAD&CDR&STORE 0)
88    L88
88    (LOAD&PUSH 0)
89    (CALLS1&JMPIFNOT 146 L68)           ; ENDP
92    (SKIP 1)
94    (LOAD&PUSH 0)
95    (CALLS1&STORE 164 0)                ; SYSTEM::LIST-NREVERSE
98    (NIL&PUSH)
99    (CALL2 11)                          ; ADDN
101   (JMP L39)
103   L103
103   (LOAD&PUSH 5)
104   (CALL1 15)                          ; RATMIN
106   (JMP L39)
109   L109
109   (GETVALUE 0)                        ; LOW*
111   (JMPIF L103)
113   (LOAD&PUSH 5)
114   (CALL1 16)                          ; RATMAX
116   (JMP L39)


Disassembly of function RDDEG-1
(CONST 0) = J
(CONST 1) = LOW*
(CONST 2) = RDDEG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LOW* J)
7 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; J
3     (GETVALUE&PUSH 0)                   ; J
5     (GETVALUE&PUSH 1)                   ; LOW*
7     (CALL2 2)                           ; RDDEG
9     (UNBIND1)
10    (SKIP&RET 2)


Disassembly of function #:|(DEFUN PDEGR (PF) ...)-154|
(CONST 0) = PDEGR
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE PDEGR>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; PDEGR
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; PDEGR
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE PDEGR>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; PDEGR
8     (SKIP&RET 1)


Disassembly of function PDEGR
(CONST 0) = VAR
(CONST 1) = RATF
(CONST 2) = 0
(CONST 3) = LOW*
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LOW* VAR)
24 byte-code instructions:
0     (LOAD 1)
1     (JMPIFATOM L23)
3     (GETVALUE&PUSH 0)                   ; VAR
5     (CALL1 1)                           ; RATF
7     (CDR)
8     (CAR)
9     (CAR&PUSH)
10    (LOAD 2)
11    (CAR)
12    (JMPIFNOTEQ L23)
14    (GETVALUE 3)                        ; LOW*
16    (JMPIF L26)
18    (LOAD 1)
19    L19
19    (CDR)
20    (CAR)
21    (SKIP&RET 2)
23    L23
23    (CONST 2)                           ; 0
24    (SKIP&RET 2)
26    L26
26    (LOAD&PUSH 1)
27    (CALLS2 72)                         ; REVERSE
29    (JMP L19)


Disassembly of function #:|(DEFUN ASY (N D) ...)-155|
(CONST 0) = ASY
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE ASY>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; ASY
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ASY
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE ASY>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; ASY
8     (SKIP&RET 1)


Disassembly of function ASY
(CONST 0) = N
(CONST 1) = D
(CONST 2) = RDDEG
(CONST 3) = COEF
(CONST 4) = VAR
(CONST 5) = $RATCOEF
(CONST 6) = DIV*
(CONST 7) = GETSIGNL
(CONST 8) = $INTEGER
(CONST 9) = ASK-INTEGER
(CONST 10) = $EVEN
(CONST 11) = VAL
(CONST 12) = $MINF
(CONST 13) = $ZEROB
(CONST 14) = $ZEROA
(CONST 15) = 0
(CONST 16) = RATGREATERP
(CONST 17) = 1
(CONST 18) = -1
(CONST 19) = $INF
(CONST 20) = $INFINITY
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (COEF VAL VAR D N)
writes special variable : (COEF)
102 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; N
3     (LOAD 4)
4     (BIND 1)                            ; D
6     (GETVALUE&PUSH 0)                   ; N
8     (NIL&PUSH)
9     (CALL2&PUSH 2)                      ; RDDEG
11    (GETVALUE&PUSH 1)                   ; D
13    (NIL&PUSH)
14    (CALL2&PUSH 2)                      ; RDDEG
16    (NIL)
17    (BIND 3)                            ; COEF
19    (PUSH-NIL 2)
21    (GETVALUE&PUSH 0)                   ; N
23    (GETVALUE&PUSH 4)                   ; VAR
25    (LOAD&PUSH 8)
26    (CALL&PUSH 3 5)                     ; $RATCOEF
29    (GETVALUE&PUSH 1)                   ; D
31    (GETVALUE&PUSH 4)                   ; VAR
33    (LOAD&PUSH 8)
34    (CALL&PUSH 3 5)                     ; $RATCOEF
37    (CALL2 6)                           ; DIV*
39    (SETVALUE 3)                        ; COEF
41    (PUSH)
42    (CALL1 7)                           ; GETSIGNL
44    (STORE 1)
45    (LOAD&PUSH 6)
46    (LOAD&PUSH 6)
47    (CALL2 6)                           ; DIV*
49    (STORE 0)
50    (PUSH)
51    (CONST&PUSH 8)                      ; $INTEGER
52    (CALL2&PUSH 9)                      ; ASK-INTEGER
54    (JMPIFNOTEQTO 8 L61)                ; $INTEGER
57    (LOAD&PUSH 0)
58    (CONST&PUSH 10)                     ; $EVEN
59    (CALL2 9)                           ; ASK-INTEGER
61    L61
61    (GETVALUE&PUSH 11)                  ; VAL
63    (JMPIFEQTO 12 L102)                 ; $MINF
66    (GETVALUE&PUSH 11)                  ; VAL
68    (JMPIFEQTO 13 L102)                 ; $ZEROB
71    (GETVALUE&PUSH 11)                  ; VAL
73    (JMPIFEQTO 14 L102)                 ; $ZEROA
76    (GETVALUE&PUSH 11)                  ; VAL
78    (JMPIFEQTO 15 L102)                 ; 0
81    (LOAD&PUSH 5)
82    (LOAD&PUSH 7)
83    (CALL2&JMPIF 16 L114)               ; RATGREATERP
86    (LOAD&PUSH 6)
87    (LOAD&PUSH 6)
88    (CALL2&JMPIF 16 L141)               ; RATGREATERP
91    (GETVALUE 3)                        ; COEF
93    L93
93    (SKIP 2)
95    (UNBIND1)
96    (SKIP 2)
98    (UNBIND 2)
100   (SKIP&RET 3)
102   L102
102   (NIL)
103   (JMP L93)
105   L105
105   (CONST 14)                          ; $ZEROA
106   (JMP L93)
108   L108
108   (CONST 13)                          ; $ZEROB
109   (JMP L93)
111   L111
111   (CONST 15)                          ; 0
112   (JMP L93)
114   L114
114   (LOAD&PUSH 1)
115   (JMPIFEQTO 17 L105)                 ; 1
118   (LOAD&PUSH 1)
119   (JMPIFEQTO 18 L108)                 ; -1
122   (LOAD&PUSH 1)
123   (JMPIFEQTO 15 L111)                 ; 0
126   (CONST 15)                          ; 0
127   (JMP L93)
129   L129
129   (CONST 19)                          ; $INF
130   (JMP L93)
132   L132
132   (CONST 12)                          ; $MINF
133   (JMP L93)
135   L135
135   (CONST 15)                          ; 0
136   (JMP L93)
138   L138
138   (CONST 20)                          ; $INFINITY
139   (JMP L93)
141   L141
141   (LOAD&PUSH 1)
142   (JMPIFEQTO 17 L129)                 ; 1
145   (LOAD&PUSH 1)
146   (JMPIFEQTO 18 L132)                 ; -1
149   (LOAD&PUSH 1)
150   (JMPIFEQTO 15 L135)                 ; 0
153   (LOAD&JMPIFNOT 1 L138)
156   (NIL)
157   (JMP L93)


Disassembly of function #:|(DEFUN RADLIM (E N D) ...)-156|
(CONST 0) = RADLIM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RADLIM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RADLIM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RADLIM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RADLIM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RADLIM
8     (SKIP&RET 1)


Disassembly of function RADLIM
(CONST 0) = E
(CONST 1) = N
(CONST 2) = D
(CONST 3) = VAL
(CONST 4) = $INFINITY
(CONST 5) = LIMIT
(CONST 6) = $MINF
(CONST 7) = VAR
(CONST 8) = -1
(CONST 9) = MUL*
(CONST 10) = SUBIN
(CONST 11) = $INF
(CONST 12) = ASYMREDU
(CONST 13) = RPTROUBLE
(CONST 14) = RDSGET
(CONST 15) = POWER*
(CONST 16) = ASY
(CONST 17) = ZEROP2
(CONST 18) = POLYP
(CONST 19) = TRY-LHOSPITAL-QUIT
(CONST 20) = SER0
(CONST 21) = DIV*
(CONST 22) = RATRAD
(CONST 23) = $RADCAN
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E D N VAR VAL)
writes special variables : (VAL D N)
111 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; E
3     (LOAD 5)
4     (BIND 1)                            ; N
6     (LOAD 7)
7     (BIND 2)                            ; D
9     (PUSH-NIL 2)
11    (GETVALUE&PUSH 3)                   ; VAL
13    (JMPIFEQTO 4 L105)                  ; $INFINITY
17    (GETVALUE&PUSH 3)                   ; VAL
19    (JMPIFNOTEQTO 6 L45)                ; $MINF
22    (GETVALUE&PUSH 7)                   ; VAR
24    (CONST&PUSH 8)                      ; -1
25    (CALL2 9)                           ; MUL*
27    (STORE 1)
28    (PUSH)
29    (GETVALUE&PUSH 1)                   ; N
31    (CALL2 10)                          ; SUBIN
33    (SETVALUE 1)                        ; N
35    (LOAD&PUSH 1)
36    (GETVALUE&PUSH 2)                   ; D
38    (CALL2 10)                          ; SUBIN
40    (SETVALUE 2)                        ; D
42    (CONST 11)                          ; $INF
43    (SETVALUE 3)                        ; VAL
45    L45
45    (GETVALUE&PUSH 3)                   ; VAL
47    (JMPIFEQTO 11 L133)                 ; $INF
51    (GETVALUE&PUSH 1)                   ; N
53    (GETVALUE&PUSH 7)                   ; VAR
55    (GETVALUE&PUSH 3)                   ; VAL
57    (T&PUSH)
58    (CALL 4 5)                          ; LIMIT
61    (STORE 1)
62    (GETVALUE&PUSH 2)                   ; D
64    (GETVALUE&PUSH 7)                   ; VAR
66    (GETVALUE&PUSH 3)                   ; VAL
68    (T&PUSH)
69    (CALL 4 5)                          ; LIMIT
72    (STORE 0)
73    (LOAD&PUSH 1)
74    (CALL1&JMPIFNOT 17 L82)             ; ZEROP2
77    (LOAD&PUSH 0)
78    (CALL1&JMPIF 17 L174)               ; ZEROP2
82    L82
82    (GETVALUE&PUSH 1)                   ; N
84    (GETVALUE&PUSH 2)                   ; D
86    (CALL2&PUSH 21)                     ; DIV*
88    (GETVALUE&PUSH 1)                   ; N
90    (GETVALUE&PUSH 2)                   ; D
92    (LOAD&PUSH 4)
93    (LOAD&PUSH 4)
94    (CALL&PUSH 5 22)                    ; RATRAD
97    (CALL1 23)                          ; $RADCAN
99    (SKIP 2)
101   L101
101   (UNBIND 3)
103   (SKIP&RET 4)
105   L105
105   (CONST&PUSH 5)                      ; LIMIT
106   (NIL)
107   (THROW)
108   L108
108   (GETVALUE&PUSH 1)                   ; N
110   (CALL1&PUSH 14)                     ; RDSGET
112   (GETVALUE&PUSH 2)                   ; D
114   (CALL1&PUSH 14)                     ; RDSGET
116   (CONST&PUSH 8)                      ; -1
117   (CALL2&PUSH 15)                     ; POWER*
119   (CALL2&PUSH 9)                      ; MUL*
121   (GETVALUE&PUSH 7)                   ; VAR
123   (GETVALUE&PUSH 3)                   ; VAL
125   (T&PUSH)
126   (CALL 4 5)                          ; LIMIT
129   (SKIP 2)
131   (JMP L101)
133   L133
133   (GETVALUE&PUSH 1)                   ; N
135   (CALL1 12)                          ; ASYMREDU
137   (STORE 1)
138   (GETVALUE&PUSH 2)                   ; D
140   (CALL1 12)                          ; ASYMREDU
142   (STORE 0)
143   (GETVALUE&PUSH 1)                   ; N
145   (CALL1&JMPIF 13 L108)               ; RPTROUBLE
148   (GETVALUE&PUSH 2)                   ; D
150   (CALL1&JMPIF 13 L108)               ; RPTROUBLE
153   (LOAD&PUSH 1)
154   (LOAD&PUSH 1)
155   (CALL2 16)                          ; ASY
157   (SKIP 2)
159   (JMP L101)
161   L161
161   (GETVALUE&PUSH 1)                   ; N
163   (GETVALUE&PUSH 2)                   ; D
165   (T&PUSH)
166   (CALL 3 19)                         ; TRY-LHOSPITAL-QUIT
169   (SKIP 2)
171   (JMP L101)
174   L174
174   (GETVALUE&PUSH 1)                   ; N
176   (CALL1&JMPIF 18 L161)               ; POLYP
179   (GETVALUE&PUSH 2)                   ; D
181   (CALL1&JMPIF 18 L161)               ; POLYP
184   (GETVALUE&PUSH 0)                   ; E
186   (GETVALUE&PUSH 1)                   ; N
188   (GETVALUE&PUSH 2)                   ; D
190   (GETVALUE&PUSH 3)                   ; VAL
192   (CALL 4 20)                         ; SER0
195   (SKIP 2)
197   (JMP L101)


Disassembly of function #:|(DEFUN RATRAD (E N D ...) ...)-157|
(CONST 0) = RATRAD
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE RATRAD>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; RATRAD
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; RATRAD
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE RATRAD>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; RATRAD
8     (SKIP&RET 1)


Disassembly of function RATRAD
(CONST 0) = E
(CONST 1) = N
(CONST 2) = D
(CONST 3) = 0
(CONST 4) = ZEROP2
(CONST 5) = $INFINITY
(CONST 6) = $ZEROA
(CONST 7) = $INF
(CONST 8) = VAR
(CONST 9) = VAL
(CONST 10) = BEHAVIOR
(CONST 11) = 1
(CONST 12) = -1
(CONST 13) = $MINF
(CONST 14) = LIMIT
(CONST 15) = $ZEROB
(CONST 16) = SUBIN
(CONST 17) = RIDOFAB
(CONST 18) = $RADCAN
(CONST 19) = SIMPLIMTIMES
5 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (E D VAL VAR N)
writes special variables : (D N)
90 byte-code instructions:
0     (LOAD 5)
1     (BIND 0)                            ; E
3     (LOAD 7)
4     (BIND 1)                            ; N
6     (LOAD 9)
7     (BIND 2)                            ; D
9     (PUSH-NIL 2)
11    (LOAD&PUSH 13)
12    (JMPIFEQTO 3 L63)                   ; 0
15    (LOAD&PUSH 12)
16    (CALL1&JMPIF 4 L84)                 ; ZEROP2
20    (LOAD&PUSH 13)
21    (CALL1&JMPIFNOT 4 L127)             ; ZEROP2
25    (LOAD 12)
26    (STORE 0)
27    (GETVALUE&PUSH 1)                   ; N
29    (GETVALUE&PUSH 8)                   ; VAR
31    (GETVALUE&PUSH 9)                   ; VAL
33    (CALL 3 10)                         ; BEHAVIOR
36    (SETVALUE 1)                        ; N
38    (PUSH)
39    (JMPIFEQTO 11 L117)                 ; 1
43    (GETVALUE&PUSH 1)                   ; N
45    (JMPIFEQTO 12 L122)                 ; -1
49    (CONST 3)                           ; 0
50    (STORE 1)
51    L51
51    (LOAD&PUSH 1)
52    (LOAD&PUSH 1)
53    (LIST&PUSH 2)
55    (CALL1 19)                          ; SIMPLIMTIMES
57    (SKIP 2)
59    L59
59    (UNBIND 3)
61    (SKIP&RET 6)
63    L63
63    (CONST 3)                           ; 0
64    (SKIP 2)
66    (JMP L59)
68    L68
68    (CONST 5)                           ; $INFINITY
69    (STORE 0)
70    (JMP L51)
72    L72
72    (CONST 7)                           ; $INF
73    (STORE 0)
74    (JMP L51)
76    L76
76    (CONST 7)                           ; $INF
77    (STORE 0)
78    (JMP L51)
80    L80
80    (CONST 13)                          ; $MINF
81    (STORE 0)
82    (JMP L51)
84    L84
84    (LOAD 13)
85    (STORE 1)
86    (LOAD&PUSH 12)
87    (JMPIFEQTO 3 L68)                   ; 0
90    (LOAD&PUSH 12)
91    (JMPIFEQTO 6 L72)                   ; $ZEROA
94    (GETVALUE&PUSH 2)                   ; D
96    (GETVALUE&PUSH 8)                   ; VAR
98    (GETVALUE&PUSH 9)                   ; VAL
100   (CALL 3 10)                         ; BEHAVIOR
103   (SETVALUE 2)                        ; D
105   (PUSH)
106   (JMPIFEQTO 11 L76)                  ; 1
109   (GETVALUE&PUSH 2)                   ; D
111   (JMPIFEQTO 12 L80)                  ; -1
114   (CONST&PUSH 14)                     ; LIMIT
115   (NIL)
116   (THROW)
117   L117
117   (CONST 6)                           ; $ZEROA
118   (STORE 1)
119   (JMP L51)
122   L122
122   (CONST 15)                          ; $ZEROB
123   (STORE 1)
124   (JMP L51)
127   L127
127   (GETVALUE&PUSH 9)                   ; VAL
129   (GETVALUE&PUSH 0)                   ; E
131   (CALL2&PUSH 16)                     ; SUBIN
133   (CALL1&PUSH 17)                     ; RIDOFAB
135   (CALL1 18)                          ; $RADCAN
137   (SKIP 2)
139   (JMP L59)


Disassembly of function #:|(DEFUN SIMPLIMLN (ARG) ...)-158|
(CONST 0) = SIMPLIMLN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMLN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMLN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMLN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMLN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMLN
8     (SKIP&RET 1)


Disassembly of function SIMPLIMLN
(CONST 0) = ARG
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = THINK
(CONST 4) = LIMIT
(CONST 5) = RIDOFAB
(CONST 6) = 0
(CONST 7) = $ZEROA
(CONST 8) = $MINF
(CONST 9) = $ZEROB
(CONST 10) = $INFINITY
(CONST 11) = BEHAVIOR
(CONST 12) = 1
(CONST 13) = -1
(CONST 14) = $INF
(CONST 15) = ($MINF $INFINITY)
(CONST 16) = MEMQ
(CONST 17) = ($IND $UND)
(CONST 18) = $UND
(CONST 19) = (%LOG)
(CONST 20) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR ARG)
87 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (GETVALUE&PUSH 1)                   ; VAR
7     (GETVALUE&PUSH 2)                   ; VAL
9     (CONST&PUSH 3)                      ; THINK
10    (CALL&PUSH 4 4)                     ; LIMIT
13    (LOAD&PUSH 0)
14    (CALL1&PUSH 5)                      ; RIDOFAB
16    (LOAD&PUSH 0)
17    (JMPIFEQTO 6 L73)                   ; 0
20    (LOAD&PUSH 1)
21    (JMPIFEQTO 14 L101)                 ; $INF
25    (LOAD&PUSH 1)
26    (CONST&PUSH 15)                     ; ($MINF $INFINITY)
27    (CALL2&JMPIF 16 L106)               ; MEMQ
31    (LOAD&PUSH 1)
32    (CONST&PUSH 17)                     ; ($IND $UND)
33    (CALL2&JMPIF 16 L111)               ; MEMQ
37    (LOAD&PUSH 1)
38    (JMPIFEQTO 12 L123)                 ; 1
42    (CONST&PUSH 19)                     ; (%LOG)
43    (LOAD&PUSH 1)
44    (LIST&PUSH 2)
46    (CALL1 20)                          ; SIMPLIFY
48    (SKIP 2)
50    L50
50    (UNBIND1)
51    (SKIP&RET 2)
53    L53
53    (CONST 8)                           ; $MINF
54    (SKIP 2)
56    (JMP L50)
58    L58
58    (CONST 10)                          ; $INFINITY
59    (SKIP 2)
61    (JMP L50)
63    L63
63    (CONST 8)                           ; $MINF
64    (SKIP 3)
66    (JMP L50)
68    L68
68    (CONST 10)                          ; $INFINITY
69    (SKIP 3)
71    (JMP L50)
73    L73
73    (LOAD&PUSH 1)
74    (JMPIFEQTO 7 L53)                   ; $ZEROA
77    (LOAD&PUSH 1)
78    (JMPIFEQTO 9 L58)                   ; $ZEROB
81    (GETVALUE&PUSH 0)                   ; ARG
83    (GETVALUE&PUSH 1)                   ; VAR
85    (GETVALUE&PUSH 2)                   ; VAL
87    (CALL&PUSH 3 11)                    ; BEHAVIOR
90    (LOAD&PUSH 0)
91    (JMPIFEQTO 12 L63)                  ; 1
94    (LOAD&PUSH 0)
95    (JMPIFEQTO 13 L68)                  ; -1
98    (CONST&PUSH 4)                      ; LIMIT
99    (T)
100   (THROW)
101   L101
101   (CONST 14)                          ; $INF
102   (SKIP 2)
104   (JMP L50)
106   L106
106   (CONST 10)                          ; $INFINITY
107   (SKIP 2)
109   (JMP L50)
111   L111
111   (CONST 18)                          ; $UND
112   (SKIP 2)
114   (JMP L50)
117   L117
117   (CONST 7)                           ; $ZEROA
118   (SKIP 3)
120   (JMP L50)
123   L123
123   (GETVALUE&PUSH 0)                   ; ARG
125   (GETVALUE&PUSH 1)                   ; VAR
127   (GETVALUE&PUSH 2)                   ; VAL
129   (CALL&PUSH 3 11)                    ; BEHAVIOR
132   (LOAD&PUSH 0)
133   (JMPIFEQTO 12 L117)                 ; 1
136   (CONST 6)                           ; 0
137   (SKIP 3)
139   (JMP L50)


Disassembly of function #:|(DEFUN SIMPLIMFACT (EXP VAR VAL ...) ...)-159|
(CONST 0) = SIMPLIMFACT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMFACT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMFACT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMFACT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMFACT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMFACT
8     (SKIP&RET 1)


Disassembly of function SIMPLIMFACT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = ARG
(CONST 4) = $INF
(CONST 5) = ($MINF $INFINITY $UND $IND)
(CONST 6) = MEMQ
(CONST 7) = $UND
(CONST 8) = MAXIMA-INTEGERP
(CONST 9) = 0
(CONST 10) = -1
(CONST 11) = MUL*
(CONST 12) = ADD*
(CONST 13) = THINK
(CONST 14) = LIMIT
(CONST 15) = 2.0
(CONST 16) = QUOT
(CONST 17) = $ZEROA
(CONST 18) = $ZEROB
(CONST 19) = $MINF
(CONST 20) = (MFACTORIAL)
(CONST 21) = RIDOFAB
(CONST 22) = 1
(CONST 23) = SIMPFACT
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR EXP ARG)
76 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; VAL
9     (LOAD 10)
10    (BIND 3)                            ; ARG
12    (GETVALUE&PUSH 3)                   ; ARG
14    (JMPIFEQTO 4 L51)                   ; $INF
17    (GETVALUE&PUSH 3)                   ; ARG
19    (CONST&PUSH 5)                      ; ($MINF $INFINITY $UND $IND)
20    (CALL2&JMPIF 6 L54)                 ; MEMQ
23    (GETVALUE&PUSH 3)                   ; ARG
25    (CALL1&JMPIFNOT 8 L35)              ; MAXIMA-INTEGERP
28    (CONST&PUSH 9)                      ; 0
29    (GETVALUE&PUSH 3)                   ; ARG
31    (CALLSR&JMPIF 1 48 L67)             ; >
35    L35
35    (CONST&PUSH 20)                     ; (MFACTORIAL)
36    (GETVALUE&PUSH 3)                   ; ARG
38    (CALL1&PUSH 21)                     ; RIDOFAB
40    (LIST&PUSH 2)
42    (CONST&PUSH 22)                     ; 1
43    (NIL&PUSH)
44    (CALL 3 23)                         ; SIMPFACT
47    L47
47    (UNBIND 4)
49    (SKIP&RET 5)
51    L51
51    (CONST 4)                           ; $INF
52    (JMP L47)
54    L54
54    (CONST 7)                           ; $UND
55    (JMP L47)
57    L57
57    (CONST 19)                          ; $MINF
58    (SKIP 2)
60    (JMP L47)
62    L62
62    (CONST 4)                           ; $INF
63    (SKIP 2)
65    (JMP L47)
67    L67
67    (GETVALUE&PUSH 0)                   ; EXP
69    (GETVALUE&PUSH 3)                   ; ARG
71    (CONST&PUSH 10)                     ; -1
72    (CALL2&PUSH 11)                     ; MUL*
74    (CALL2&PUSH 12)                     ; ADD*
76    (GETVALUE&PUSH 1)                   ; VAR
78    (GETVALUE&PUSH 2)                   ; VAL
80    (CONST&PUSH 13)                     ; THINK
81    (CALL&PUSH 4 14)                    ; LIMIT
84    (GETVALUE&PUSH 3)                   ; ARG
86    (CONST&PUSH 15)                     ; 2.0
87    (CALL2&PUSH 16)                     ; QUOT
89    (CALL1&PUSH 8)                      ; MAXIMA-INTEGERP
91    (LOAD&JMPIFNOT 0 L98)
94    (LOAD&PUSH 1)
95    (JMPIFEQTO 17 L57)                  ; $ZEROA
98    L98
98    (LOAD&JMPIF 0 L105)
101   (LOAD&PUSH 1)
102   (JMPIFEQTO 18 L57)                  ; $ZEROB
105   L105
105   (LOAD&JMPIFNOT 0 L112)
108   (LOAD&PUSH 1)
109   (JMPIFEQTO 18 L62)                  ; $ZEROB
112   L112
112   (LOAD&JMPIF 0 L119)
115   (LOAD&PUSH 1)
116   (JMPIFEQTO 17 L62)                  ; $ZEROA
119   L119
119   (CONST&PUSH 14)                     ; LIMIT
120   (NIL)
121   (THROW)


Disassembly of function #:|(DEFUN SIMPLIM%ERF-%TANH (FN ARG) ...)-160|
(CONST 0) = SIMPLIM%ERF-%TANH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ERF-%TANH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ERF-%TANH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ERF-%TANH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ERF-%TANH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ERF-%TANH
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ERF-%TANH
(CONST 0) = FN
(CONST 1) = ARG
(CONST 2) = VAR
(CONST 3) = VAL
(CONST 4) = THINK
(CONST 5) = LIMIT
(CONST 6) = $INF
(CONST 7) = 1
(CONST 8) = $MINF
(CONST 9) = -1
(CONST 10) = $INFINITY
(CONST 11) = TRISPLIT
(CONST 12) = ANS
(CONST 13) = ORIGVAL
(CONST 14) = %TANH
(CONST 15) = %ERF
(CONST 16) = POWER
(CONST 17) = MUL*
(CONST 18) = (MABS)
(CONST 19) = ADD*
(CONST 20) = $ASKSIGN
(CONST 21) = $POS
(CONST 22) = $ZERO
(CONST 23) = $UND
(CONST 24) = ($ZEROA $ZEROB $IND)
(CONST 25) = MEMQ
(CONST 26) = SIMPLIFY
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (ANS ORIGVAL FN VAL VAR ARG)
writes special variable : (ANS)
121 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; FN
3     (LOAD 4)
4     (BIND 1)                            ; ARG
6     (GETVALUE&PUSH 1)                   ; ARG
8     (GETVALUE&PUSH 2)                   ; VAR
10    (GETVALUE&PUSH 3)                   ; VAL
12    (CONST&PUSH 4)                      ; THINK
13    (CALL&PUSH 4 5)                     ; LIMIT
16    (LOAD&PUSH 0)
17    (JMPIFEQTO 6 L56)                   ; $INF
20    (LOAD&PUSH 0)
21    (JMPIFEQTO 8 L61)                   ; $MINF
24    (LOAD&PUSH 0)
25    (JMPIFEQTO 10 L149)                 ; $INFINITY
29    (LOAD&PUSH 0)
30    (JMPIFEQTO 23 L194)                 ; $UND
34    (LOAD&PUSH 0)
35    (CONST&PUSH 24)                     ; ($ZEROA $ZEROB $IND)
36    (CALL2&JMPIF 25 L201)               ; MEMQ
40    (GETVALUE&PUSH 0)                   ; FN
42    (NIL)
43    (CONS&PUSH)
44    (GETVALUE&PUSH 1)                   ; ARG
46    (LIST&PUSH 2)
48    (CALL1 26)                          ; SIMPLIFY
50    (SKIP 1)
52    L52
52    (UNBIND 2)
54    (SKIP&RET 3)
56    L56
56    (CONST 7)                           ; 1
57    (SKIP 1)
59    (JMP L52)
61    L61
61    (CONST 9)                           ; -1
62    (SKIP 1)
64    (JMP L52)
66    L66
66    (CONST 7)                           ; 1
67    (JMP L186)
70    L70
70    (CONST 9)                           ; -1
71    (JMP L186)
74    L74
74    (LOAD&PUSH 0)
75    (JMPIFEQTO 6 L66)                   ; $INF
78    (LOAD&PUSH 0)
79    (JMPIFEQTO 8 L70)                   ; $MINF
82    (NIL)
83    (JMP L186)
86    L86
86    (CONST 7)                           ; 1
87    (JMP L186)
90    L90
90    (CONST 9)                           ; -1
91    (JMP L186)
94    L94
94    (LOAD&PUSH 0)
95    (JMPIFEQTO 6 L86)                   ; $INF
98    (LOAD&PUSH 0)
99    (JMPIFEQTO 8 L90)                   ; $MINF
102   (CONST 23)                          ; $UND
104   (JMP L186)
107   L107
107   (LOAD&PUSH 5)
108   (LOAD&PUSH 5)
109   (CONST&PUSH 9)                      ; -1
110   (CALL2&PUSH 16)                     ; POWER
112   (CALL2&PUSH 17)                     ; MUL*
114   (GETVALUE&PUSH 2)                   ; VAR
116   (GETVALUE&PUSH 13)                  ; ORIGVAL
118   (CONST&PUSH 4)                      ; THINK
119   (CALL 4 5)                          ; LIMIT
122   (SETVALUE 12)                       ; ANS
124   (CONST&PUSH 18)                     ; (MABS)
125   (GETVALUE&PUSH 12)                  ; ANS
127   (LIST&PUSH 2)
129   (CONST&PUSH 9)                      ; -1
130   (CALL2&PUSH 19)                     ; ADD*
132   (CALL1 20)                          ; $ASKSIGN
134   (SETVALUE 12)                       ; ANS
136   (PUSH)
137   (JMPIFEQTO 21 L94)                  ; $POS
140   (GETVALUE&PUSH 12)                  ; ANS
142   (JMPIFEQTO 22 L94)                  ; $ZERO
145   (CONST 23)                          ; $UND
147   (JMP L186)
149   L149
149   (NIL&PUSH)
150   (GETVALUE&PUSH 1)                   ; ARG
152   (CALL1&PUSH 11)                     ; TRISPLIT
154   (NIL)
155   (BIND 12)                           ; ANS
157   (NIL&PUSH)
158   (LOAD&CAR&STORE 4 5)
161   (LOAD&CDR&STORE 4)
163   (LOAD&PUSH 5)
164   (GETVALUE&PUSH 2)                   ; VAR
166   (GETVALUE&PUSH 13)                  ; ORIGVAL
168   (CONST&PUSH 4)                      ; THINK
169   (CALL 4 5)                          ; LIMIT
172   (STORE 0)
173   (GETVALUE&PUSH 0)                   ; FN
175   (JMPIFEQTO 14 L74)                  ; %TANH
179   (GETVALUE&PUSH 0)                   ; FN
181   (JMPIFEQTO 15 L107)                 ; %ERF
185   (NIL)
186   L186
186   (SKIP 1)
188   (UNBIND1)
189   (SKIP 3)
191   (JMP L52)
194   L194
194   (CONST 23)                          ; $UND
196   (SKIP 1)
198   (JMP L52)
201   L201
201   (GETVALUE 1)                        ; ARG
203   (SKIP 1)
205   (JMP L52)


Disassembly of function #:|(DEFUN SIMPLIM%ATAN (EXP1) ...)-161|
(CONST 0) = SIMPLIM%ATAN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ATAN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ATAN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ATAN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ATAN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ATAN
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ATAN
(CONST 0) = EXP1
(CONST 1) = ZEROP2
(CONST 2) = $INF
(CONST 3) = HALF%PI
(CONST 4) = $MINF
(CONST 5) = -1
(CONST 6) = MUL
(CONST 7) = (%ATAN)
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (HALF%PI EXP1)
25 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP1
3     (GETVALUE&PUSH 0)                   ; EXP1
5     (CALL1&JMPIF 1 L26)                 ; ZEROP2
8     (GETVALUE&PUSH 0)                   ; EXP1
10    (JMPIFEQTO 2 L30)                   ; $INF
13    (GETVALUE&PUSH 0)                   ; EXP1
15    (JMPIFEQTO 4 L34)                   ; $MINF
18    (CONST&PUSH 7)                      ; (%ATAN)
19    (GETVALUE&PUSH 0)                   ; EXP1
21    (LIST 2)
23    L23
23    (UNBIND1)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE 0)                        ; EXP1
28    (JMP L23)
30    L30
30    (GETVALUE 3)                        ; HALF%PI
32    (JMP L23)
34    L34
34    (CONST&PUSH 5)                      ; -1
35    (GETVALUE&PUSH 3)                   ; HALF%PI
37    (CALL2 6)                           ; MUL
39    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIMSCH (SCH ARG) ...)-162|
(CONST 0) = SIMPLIMSCH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMSCH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMSCH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMSCH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMSCH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMSCH
8     (SKIP&RET 1)


Disassembly of function SIMPLIMSCH
(CONST 0) = ARG
(CONST 1) = REAL-INFINITIES
(CONST 2) = MEMQ
(CONST 3) = %SINH
(CONST 4) = $INF
(CONST 5) = $INFINITY
(CONST 6) = $UND
(CONST 7) = $EXPONENTIALIZE
(CONST 8) = RIDOFAB
(CONST 9) = RESIMPLIFY
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (REAL-INFINITIES ARG)
36 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (GETVALUE&PUSH 1)                   ; REAL-INFINITIES
7     (CALL2&JMPIF 2 L42)                 ; MEMQ
10    (GETVALUE&PUSH 0)                   ; ARG
12    (JMPIFEQTO 5 L49)                   ; $INFINITY
15    (GETVALUE&PUSH 0)                   ; ARG
17    (JMPIFEQTO 6 L52)                   ; $UND
20    (T)
21    (BIND 7)                            ; $EXPONENTIALIZE
23    (LOAD&PUSH 8)
24    (NIL)
25    (CONS&PUSH)
26    (GETVALUE&PUSH 0)                   ; ARG
28    (CALL1&PUSH 8)                      ; RIDOFAB
30    (LIST&PUSH 2)
32    (CALL1 9)                           ; RESIMPLIFY
34    (UNBIND1)
35    L35
35    (UNBIND1)
36    (SKIP&RET 3)
38    L38
38    (GETVALUE 0)                        ; ARG
40    (JMP L35)
42    L42
42    (LOAD&PUSH 5)
43    (JMPIFEQTO 3 L38)                   ; %SINH
46    (CONST 4)                           ; $INF
47    (JMP L35)
49    L49
49    (CONST 5)                           ; $INFINITY
50    (JMP L35)
52    L52
52    (CONST 6)                           ; $UND
53    (JMP L35)


Disassembly of function #:|(DEFUN SIMPLIMSC (EXP FN ARG) ...)-163|
(CONST 0) = SIMPLIMSC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIMSC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIMSC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIMSC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIMSC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIMSC
8     (SKIP&RET 1)


Disassembly of function SIMPLIMSC
(CONST 0) = EXP
(CONST 1) = FN
(CONST 2) = ARG
(CONST 3) = ($INF $MINF $IND)
(CONST 4) = MEMQ
(CONST 5) = $IND
(CONST 6) = ($UND $INFINITY)
(CONST 7) = $UND
(CONST 8) = ($ZEROA $ZEROB)
(CONST 9) = %SIN
(CONST 10) = 1
(CONST 11) = $ZEROB
(CONST 12) = ADD*
(CONST 13) = RIDOFAB
(CONST 14) = SIMPLIFY
(CONST 15) = SINCOSHK
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FN EXP ARG)
46 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; FN
6     (LOAD 7)
7     (BIND 2)                            ; ARG
9     (GETVALUE&PUSH 2)                   ; ARG
11    (CONST&PUSH 3)                      ; ($INF $MINF $IND)
12    (CALL2&JMPIF 4 L53)                 ; MEMQ
15    (GETVALUE&PUSH 2)                   ; ARG
17    (CONST&PUSH 6)                      ; ($UND $INFINITY)
18    (CALL2&JMPIF 4 L56)                 ; MEMQ
21    (GETVALUE&PUSH 2)                   ; ARG
23    (CONST&PUSH 8)                      ; ($ZEROA $ZEROB)
24    (CALL2&JMPIF 4 L63)                 ; MEMQ
27    (GETVALUE&PUSH 0)                   ; EXP
29    (GETVALUE&PUSH 1)                   ; FN
31    (NIL)
32    (CONS&PUSH)
33    (GETVALUE&PUSH 2)                   ; ARG
35    (CALL1&PUSH 13)                     ; RIDOFAB
37    (LIST&PUSH 2)
39    (CALL1&PUSH 14)                     ; SIMPLIFY
41    (GETVALUE&PUSH 1)                   ; FN
43    (CALL 3 15)                         ; SINCOSHK
46    (JMPIF1 L49)
48    (NIL)
49    L49
49    (UNBIND 3)
51    (SKIP&RET 4)
53    L53
53    (CONST 5)                           ; $IND
54    (JMP L49)
56    L56
56    (CONST 7)                           ; $UND
57    (JMP L49)
59    L59
59    (GETVALUE 2)                        ; ARG
61    (JMP L49)
63    L63
63    (GETVALUE&PUSH 1)                   ; FN
65    (JMPIFEQTO 9 L59)                   ; %SIN
68    (CONST&PUSH 10)                     ; 1
69    (CONST&PUSH 11)                     ; $ZEROB
70    (CALL2 12)                          ; ADD*
72    (JMP L49)


Disassembly of function #:|(DEFUN SIMPLIM%TAN (ARG) ...)-164|
(CONST 0) = SIMPLIM%TAN
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%TAN>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%TAN
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%TAN
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%TAN>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%TAN
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%TAN
(CONST 0) = ARG
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = THINK
(CONST 4) = LIMIT
(CONST 5) = RIDOFAB
(CONST 6) = ($INF $MINF $INFINITY $IND $UND)
(CONST 7) = MEMQ
(CONST 8) = $UND
(CONST 9) = PIP
(CONST 10) = TRIGRED
(CONST 11) = C
(CONST 12) = $IMAGPART
(CONST 13) = 0
(CONST 14) = $INFINITY
(CONST 15) = RAT
(CONST 16) = 2
(CONST 17) = BEHAVIOR
(CONST 18) = 1
(CONST 19) = $INF
(CONST 20) = -1
(CONST 21) = $MINF
(CONST 22) = $ZEROA
(CONST 23) = $ZEROB
(CONST 24) = (%TAN)
(CONST 25) = SIMP-%TAN
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (C VAL VAR ARG)
136 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (GETVALUE&PUSH 1)                   ; VAR
7     (GETVALUE&PUSH 2)                   ; VAL
9     (CONST&PUSH 3)                      ; THINK
10    (CALL&PUSH 4 4)                     ; LIMIT
13    (CALL1&PUSH 5)                      ; RIDOFAB
15    (LOAD&PUSH 0)
16    (CONST&PUSH 6)                      ; ($INF $MINF $INFINITY $IND $UND)
17    (CALL2&JMPIF 7 L121)                ; MEMQ
21    (LOAD&PUSH 0)
22    (CALL1&JMPIFNOT 9 L207)             ; PIP
26    (LOAD&PUSH 0)
27    (CALL1&PUSH 9)                      ; PIP
29    (CALL1 10)                          ; TRIGRED
31    (BIND 11)                           ; C
33    (LOAD&PUSH 3)
34    (CALL1&PUSH 12)                     ; $IMAGPART
36    (JMPIFNOTEQTO 13 L127)              ; 0
40    (GETVALUE 11)                       ; C
42    (CAR)
43    (CAR&PUSH)
44    (JMPIFNOTEQTO 15 L65)               ; RAT
47    (GETVALUE 11)                       ; C
49    (CDR)
50    (CDR)
51    (CAR&PUSH)
52    (JMPIFNOTEQTO 16 L65)               ; 2
55    (GETVALUE 11)                       ; C
57    (CDR)
58    (CAR&PUSH)
59    (CONST&PUSH 13)                     ; 0
60    (CALLSR&JMPIF 1 48 L137)            ; >
65    L65
65    (GETVALUE 11)                       ; C
67    (CAR)
68    (CAR&PUSH)
69    (JMPIFNOTEQTO 15 L169)              ; RAT
73    (GETVALUE 11)                       ; C
75    (CDR)
76    (CDR)
77    (CAR&PUSH)
78    (JMPIFNOTEQTO 16 L169)              ; 2
82    (GETVALUE 11)                       ; C
84    (CDR)
85    (CAR&PUSH)
86    (CONST&PUSH 13)                     ; 0
87    (CALLSR&JMPIFNOT 1 47 L169)         ; <
92    (GETVALUE&PUSH 0)                   ; ARG
94    (GETVALUE&PUSH 1)                   ; VAR
96    (GETVALUE&PUSH 2)                   ; VAL
98    (CALL 3 17)                         ; BEHAVIOR
101   (STORE 3)
102   (PUSH)
103   (CONST&PUSH 18)                     ; 1
104   (CALLSR&JMPIF 1 45 L162)            ; =
108   (LOAD&PUSH 3)
109   (CONST&PUSH 20)                     ; -1
110   (CALLSR&JMPIF 1 45 L166)            ; =
114   (CONST 8)                           ; $UND
115   L115
115   (UNBIND1)
116   (SKIP 1)
118   (JMP L222)
121   L121
121   (CONST 8)                           ; $UND
122   (SKIP 1)
124   (JMP L222)
127   L127
127   (CONST 14)                          ; $INFINITY
128   (JMP L115)
130   L130
130   (CONST 19)                          ; $INF
131   (JMP L115)
133   L133
133   (CONST 21)                          ; $MINF
135   (JMP L115)
137   L137
137   (GETVALUE&PUSH 0)                   ; ARG
139   (GETVALUE&PUSH 1)                   ; VAR
141   (GETVALUE&PUSH 2)                   ; VAL
143   (CALL 3 17)                         ; BEHAVIOR
146   (STORE 3)
147   (PUSH)
148   (CONST&PUSH 18)                     ; 1
149   (CALLSR&JMPIF 1 45 L130)            ; =
153   (LOAD&PUSH 3)
154   (CONST&PUSH 20)                     ; -1
155   (CALLSR&JMPIF 1 45 L133)            ; =
159   (CONST 8)                           ; $UND
160   (JMP L115)
162   L162
162   (CONST 21)                          ; $MINF
164   (JMP L115)
166   L166
166   (CONST 19)                          ; $INF
167   (JMP L115)
169   L169
169   (CONST&PUSH 4)                      ; LIMIT
170   (NIL)
171   (THROW)
172   L172
172   (CONST 22)                          ; $ZEROA
174   (SKIP 1)
176   (JMP L222)
178   L178
178   (CONST 23)                          ; $ZEROB
180   (SKIP 1)
182   (JMP L222)
184   L184
184   (GETVALUE&PUSH 0)                   ; ARG
186   (GETVALUE&PUSH 1)                   ; VAR
188   (GETVALUE&PUSH 2)                   ; VAL
190   (CALL 3 17)                         ; BEHAVIOR
193   (STORE 0)
194   (PUSH)
195   (JMPIFEQTO 18 L172)                 ; 1
198   (LOAD&PUSH 0)
199   (JMPIFEQTO 20 L178)                 ; -1
202   (CONST 13)                          ; 0
203   (SKIP 1)
205   (JMP L222)
207   L207
207   (LOAD&PUSH 0)
208   (JMPIFEQTO 13 L184)                 ; 0
211   (CONST&PUSH 24)                     ; (%TAN)
212   (LOAD&PUSH 1)
213   (LIST&PUSH 2)
215   (CONST&PUSH 18)                     ; 1
216   (NIL&PUSH)
217   (CALL 3 25)                         ; SIMP-%TAN
220   (SKIP 1)
222   L222
222   (UNBIND1)
223   (SKIP&RET 2)


Disassembly of function #:|(DEFUN SIMPLIM%ASINH (ARG) ...)-165|
(CONST 0) = SIMPLIM%ASINH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ASINH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ASINH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ASINH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ASINH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ASINH
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ASINH
(CONST 0) = ARG
(CONST 1) = ($INF $MINF $ZEROA $ZEROB $IND $UND)
(CONST 2) = MEMQ
(CONST 3) = $INFINITY
(CONST 4) = $UND
(CONST 5) = (%ASINH)
(CONST 6) = RIDOFAB
(CONST 7) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ARG)
21 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (CONST&PUSH 1)                      ; ($INF $MINF $ZEROA $ZEROB $IND ...)
6     (CALL2&JMPIF 2 L26)                 ; MEMQ
9     (GETVALUE&PUSH 0)                   ; ARG
11    (JMPIFEQTO 3 L30)                   ; $INFINITY
14    (CONST&PUSH 5)                      ; (%ASINH)
15    (GETVALUE&PUSH 0)                   ; ARG
17    (CALL1&PUSH 6)                      ; RIDOFAB
19    (LIST&PUSH 2)
21    (CALL1 7)                           ; SIMPLIFY
23    L23
23    (UNBIND1)
24    (SKIP&RET 2)
26    L26
26    (GETVALUE 0)                        ; ARG
28    (JMP L23)
30    L30
30    (CONST 4)                           ; $UND
31    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%ACOSH (ARG) ...)-166|
(CONST 0) = SIMPLIM%ACOSH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ACOSH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ACOSH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ACOSH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ACOSH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ACOSH
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ACOSH
(CONST 0) = ARG
(CONST 1) = RIDOFAB
(CONST 2) = 1
(CONST 3) = $ZEROA
(CONST 4) = $INF
(CONST 5) = $MINF
(CONST 6) = $INFINITY
(CONST 7) = ($UND $IND $INFINITY)
(CONST 8) = MEMQ
(CONST 9) = $UND
(CONST 10) = (%ACOSH)
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ARG)
32 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (CALL1&PUSH 1)                      ; RIDOFAB
7     (JMPIFEQTO 2 L38)                   ; 1
10    (GETVALUE&PUSH 0)                   ; ARG
12    (JMPIFEQTO 4 L41)                   ; $INF
15    (GETVALUE&PUSH 0)                   ; ARG
17    (JMPIFEQTO 5 L45)                   ; $MINF
20    (GETVALUE&PUSH 0)                   ; ARG
22    (CONST&PUSH 7)                      ; ($UND $IND $INFINITY)
23    (CALL2&JMPIF 8 L48)                 ; MEMQ
26    (CONST&PUSH 10)                     ; (%ACOSH)
27    (GETVALUE&PUSH 0)                   ; ARG
29    (CALL1&PUSH 1)                      ; RIDOFAB
31    (LIST&PUSH 2)
33    (CALL1 11)                          ; SIMPLIFY
35    L35
35    (UNBIND1)
36    (SKIP&RET 2)
38    L38
38    (CONST 3)                           ; $ZEROA
39    (JMP L35)
41    L41
41    (GETVALUE 0)                        ; ARG
43    (JMP L35)
45    L45
45    (CONST 6)                           ; $INFINITY
46    (JMP L35)
48    L48
48    (CONST 9)                           ; $UND
49    (JMP L35)


Disassembly of function #:|(DEFUN SIMPLIM%ATANH (ARG) ...)-167|
(CONST 0) = SIMPLIM%ATANH
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ATANH>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ATANH
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ATANH
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ATANH>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ATANH
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ATANH
(CONST 0) = ARG
(CONST 1) = ZEROP2
(CONST 2) = ($IND $UND $INFINITY $MINF $INF)
(CONST 3) = MEMQ
(CONST 4) = $UND
(CONST 5) = RIDOFAB
(CONST 6) = 1
(CONST 7) = $INF
(CONST 8) = -1
(CONST 9) = $MINF
(CONST 10) = (%ATANH)
(CONST 11) = SIMPLIFY
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (ARG)
writes special variable : (ARG)
33 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; ARG
3     (GETVALUE&PUSH 0)                   ; ARG
5     (CALL1&JMPIF 1 L39)                 ; ZEROP2
8     (GETVALUE&PUSH 0)                   ; ARG
10    (CONST&PUSH 2)                      ; ($IND $UND $INFINITY $MINF $INF)
11    (CALL2&JMPIF 3 L43)                 ; MEMQ
14    (GETVALUE&PUSH 0)                   ; ARG
16    (CALL1 5)                           ; RIDOFAB
18    (SETVALUE 0)                        ; ARG
20    (PUSH)
21    (JMPIFEQTO 6 L46)                   ; 1
24    (GETVALUE&PUSH 0)                   ; ARG
26    (JMPIFEQTO 8 L49)                   ; -1
29    (CONST&PUSH 10)                     ; (%ATANH)
30    (GETVALUE&PUSH 0)                   ; ARG
32    (LIST&PUSH 2)
34    (CALL1 11)                          ; SIMPLIFY
36    L36
36    (UNBIND1)
37    (SKIP&RET 2)
39    L39
39    (GETVALUE 0)                        ; ARG
41    (JMP L36)
43    L43
43    (CONST 4)                           ; $UND
44    (JMP L36)
46    L46
46    (CONST 7)                           ; $INF
47    (JMP L36)
49    L49
49    (CONST 9)                           ; $MINF
50    (JMP L36)


Disassembly of function #:|(DEFUN SIMPLIM%ASIN-%ACOS (FN ARG) ...)-168|
(CONST 0) = SIMPLIM%ASIN-%ACOS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%ASIN-%ACOS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%ASIN-%ACOS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%ASIN-%ACOS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%ASIN-%ACOS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%ASIN-%ACOS
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%ASIN-%ACOS
(CONST 0) = FN
(CONST 1) = ARG
(CONST 2) = ($UND $IND $INF $MINF $INFINITY)
(CONST 3) = MEMQ
(CONST 4) = $UND
(CONST 5) = %ASIN
(CONST 6) = ($ZEROA $ZEROB)
(CONST 7) = RIDOFAB
(CONST 8) = SIMPLIFY
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (FN ARG)
29 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; FN
3     (LOAD 4)
4     (BIND 1)                            ; ARG
6     (GETVALUE&PUSH 1)                   ; ARG
8     (CONST&PUSH 2)                      ; ($UND $IND $INF $MINF $INFINITY)
9     (CALL2&JMPIF 3 L39)                 ; MEMQ
12    (GETVALUE&PUSH 0)                   ; FN
14    (JMPIFNOTEQTO 5 L23)                ; %ASIN
17    (GETVALUE&PUSH 1)                   ; ARG
19    (CONST&PUSH 6)                      ; ($ZEROA $ZEROB)
20    (CALL2&JMPIF 3 L42)                 ; MEMQ
23    L23
23    (GETVALUE&PUSH 0)                   ; FN
25    (NIL)
26    (CONS&PUSH)
27    (GETVALUE&PUSH 1)                   ; ARG
29    (CALL1&PUSH 7)                      ; RIDOFAB
31    (LIST&PUSH 2)
33    (CALL1 8)                           ; SIMPLIFY
35    L35
35    (UNBIND 2)
37    (SKIP&RET 3)
39    L39
39    (CONST 4)                           ; $UND
40    (JMP L35)
42    L42
42    (GETVALUE 1)                        ; ARG
44    (JMP L35)


Disassembly of function #:|(DEFUN SIMPLIM$LI (ORDER ARG VAL) ...)-169|
(CONST 0) = SIMPLIM$LI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM$LI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM$LI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM$LI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM$LI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM$LI
8     (SKIP&RET 1)


Disassembly of function SIMPLIM$LI
(CONST 0) = ARG
(CONST 1) = VAL
(CONST 2) = 1
(CONST 3) = LIMIT
(CONST 4) = 2
(CONST 5) = TRISPLIT
(CONST 6) = 0
(CONST 7) = VAR
(CONST 8) = THINK
(CONST 9) = $ZEROA
(CONST 10) = $ZEROB
(CONST 11) = $MINF
(CONST 12) = $INF
(CONST 13) = $INFINITY
(CONST 14) = $LI
(CONST 15) = SUBFUNMAKE
(CONST 16) = SIMPLIFY
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR ARG)
writes special variable : (ARG)
77 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (LOAD&PUSH 9)
7     (CALLS2&PUSH 71)                    ; LENGTH
9     (JMPIFEQTO 2 L19)                   ; 1
12    (GETVALUE&PUSH 0)                   ; ARG
14    (CALLS2&PUSH 71)                    ; LENGTH
16    (JMPIFNOTEQTO 2 L49)                ; 1
19    L19
19    (LOAD&CAR&STORE 9 9)
22    (GETVALUE 0)                        ; ARG
24    (CAR)
25    (SETVALUE 0)                        ; ARG
27    (LOAD&PUSH 9)
28    (JMPIFNOTEQTO 4 L52)                ; 2
31    (NIL&PUSH)
32    (GETVALUE&PUSH 0)                   ; ARG
34    (CALL1&PUSH 5)                      ; TRISPLIT
36    (LOAD&CAR&STORE 0 1)
39    (LOAD&CDR&STORE 0)
41    (PUSH)
42    (JMPIFEQTO 6 L75)                   ; 0
45    (CONST 3)                           ; LIMIT
46    L46
46    (PUSH)
47    (NIL)
48    (THROW)
49    L49
49    (CONST 3)                           ; LIMIT
50    (JMP L46)
52    L52
52    (CONST 3)                           ; LIMIT
53    (JMP L46)
55    L55
55    (CONST 9)                           ; $ZEROA
56    (SKIP 2)
58    (JMP L115)
60    L60
60    (CONST 10)                          ; $ZEROB
61    (SKIP 2)
63    (JMP L115)
65    L65
65    (CONST 11)                          ; $MINF
66    (SKIP 2)
68    (JMP L115)
70    L70
70    (CONST 13)                          ; $INFINITY
71    (SKIP 2)
73    (JMP L115)
75    L75
75    (LOAD&PUSH 1)
76    (GETVALUE&PUSH 7)                   ; VAR
78    (GETVALUE&PUSH 1)                   ; VAL
80    (CONST&PUSH 8)                      ; THINK
81    (CALL 4 3)                          ; LIMIT
84    (STORE 1)
85    (PUSH)
86    (JMPIFEQTO 9 L55)                   ; $ZEROA
89    (LOAD&PUSH 1)
90    (JMPIFEQTO 10 L60)                  ; $ZEROB
93    (LOAD&PUSH 1)
94    (JMPIFEQTO 11 L65)                  ; $MINF
97    (LOAD&PUSH 1)
98    (JMPIFEQTO 12 L70)                  ; $INF
101   (CONST&PUSH 14)                     ; $LI
102   (LOAD&PUSH 12)
103   (LIST&PUSH 1)
105   (LOAD&PUSH 3)
106   (LIST&PUSH 1)
108   (CALL&PUSH 3 15)                    ; SUBFUNMAKE
111   (CALL1 16)                          ; SIMPLIFY
113   (SKIP 2)
115   L115
115   (UNBIND 2)
117   (SKIP&RET 4)


Disassembly of function #:|(DEFUN SIMPLIM$PSI (ORDER ARG VAL) ...)-170|
(CONST 0) = SIMPLIM$PSI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM$PSI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM$PSI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM$PSI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM$PSI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM$PSI
8     (SKIP&RET 1)


Disassembly of function SIMPLIM$PSI
(CONST 0) = ARG
(CONST 1) = VAL
(CONST 2) = 1
(CONST 3) = LIMIT
(CONST 4) = 0
(CONST 5) = TRISPLIT
(CONST 6) = VAR
(CONST 7) = THINK
(CONST 8) = $ZEROA
(CONST 9) = $MINF
(CONST 10) = $ZEROB
(CONST 11) = $INF
(CONST 12) = $UND
(CONST 13) = GETSIGNL
(CONST 14) = -1
(CONST 15) = $PSI
(CONST 16) = SUBFUNMAKE
(CONST 17) = SIMPLIFY
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR ARG)
writes special variable : (ARG)
83 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; VAL
6     (LOAD&PUSH 9)
7     (CALLS2&PUSH 71)                    ; LENGTH
9     (JMPIFEQTO 2 L19)                   ; 1
12    (GETVALUE&PUSH 0)                   ; ARG
14    (CALLS2&PUSH 71)                    ; LENGTH
16    (JMPIFNOTEQTO 2 L81)                ; 1
19    L19
19    (LOAD&CAR&STORE 9 9)
22    (GETVALUE 0)                        ; ARG
24    (CAR)
25    (SETVALUE 0)                        ; ARG
27    (LOAD&PUSH 9)
28    (JMPIFNOTEQTO 4 L84)                ; 0
31    (NIL&PUSH)
32    (GETVALUE&PUSH 0)                   ; ARG
34    (CALL1&PUSH 5)                      ; TRISPLIT
36    (LOAD&CAR&STORE 0 1)
39    (LOAD&CDR&STORE 0)
41    (PUSH)
42    (JMPIFNOTEQTO 4 L87)                ; 0
45    (LOAD&PUSH 1)
46    (GETVALUE&PUSH 6)                   ; VAR
48    (GETVALUE&PUSH 1)                   ; VAL
50    (CONST&PUSH 7)                      ; THINK
51    (CALL 4 3)                          ; LIMIT
54    (STORE 1)
55    (PUSH)
56    (JMPIFEQTO 8 L90)                   ; $ZEROA
59    (LOAD&PUSH 1)
60    (JMPIFEQTO 10 L95)                  ; $ZEROB
63    (LOAD&PUSH 1)
64    (JMPIFEQTO 11 L100)                 ; $INF
67    (LOAD&PUSH 1)
68    (JMPIFEQTO 9 L105)                  ; $MINF
71    (LOAD&PUSH 1)
72    (CALL1&PUSH 13)                     ; GETSIGNL
74    (JMPIFNOTEQTO 14 L110)              ; -1
77    (CONST 3)                           ; LIMIT
78    L78
78    (PUSH)
79    (NIL)
80    (THROW)
81    L81
81    (CONST 3)                           ; LIMIT
82    (JMP L78)
84    L84
84    (CONST 3)                           ; LIMIT
85    (JMP L78)
87    L87
87    (CONST 3)                           ; LIMIT
88    (JMP L78)
90    L90
90    (CONST 9)                           ; $MINF
91    (SKIP 2)
93    (JMP L124)
95    L95
95    (CONST 11)                          ; $INF
96    (SKIP 2)
98    (JMP L124)
100   L100
100   (CONST 11)                          ; $INF
101   (SKIP 2)
103   (JMP L124)
105   L105
105   (CONST 12)                          ; $UND
106   (SKIP 2)
108   (JMP L124)
110   L110
110   (CONST&PUSH 15)                     ; $PSI
111   (LOAD&PUSH 12)
112   (LIST&PUSH 1)
114   (LOAD&PUSH 3)
115   (LIST&PUSH 1)
117   (CALL&PUSH 3 16)                    ; SUBFUNMAKE
120   (CALL1 17)                          ; SIMPLIFY
122   (SKIP 2)
124   L124
124   (UNBIND 2)
126   (SKIP&RET 4)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_NS (ARG M) ...)-171|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_NS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_NS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_NS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_NS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_NS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_NS
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_NS
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = 0
(CONST 5) = (%INVERSE_JACOBI_NS)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
18 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_NS)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST 4)                           ; 0
28    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_NC (ARG M) ...)-172|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_NC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_NC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_NC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_NC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_NC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_NC
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_NC
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = (%ELLIPTIC_KC)
(CONST 5) = (%INVERSE_JACOBI_NC)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
20 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_NC)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST&PUSH 4)                      ; (%ELLIPTIC_KC)
28    (GETVALUE&PUSH 1)                   ; M
30    (LIST 2)
32    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_SC (ARG M) ...)-173|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_SC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_SC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_SC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_SC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_SC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_SC
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_SC
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = (%ELLIPTIC_KC)
(CONST 5) = (%INVERSE_JACOBI_SC)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
20 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_SC)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST&PUSH 4)                      ; (%ELLIPTIC_KC)
28    (GETVALUE&PUSH 1)                   ; M
30    (LIST 2)
32    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_DC (ARG M) ...)-174|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_DC
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_DC>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_DC
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_DC
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_DC>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_DC
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_DC
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = (%ELLIPTIC_KC)
(CONST 5) = (%INVERSE_JACOBI_DC)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
20 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_DC)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST&PUSH 4)                      ; (%ELLIPTIC_KC)
28    (GETVALUE&PUSH 1)                   ; M
30    (LIST 2)
32    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_CS (ARG M) ...)-175|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_CS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_CS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_CS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_CS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_CS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_CS
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_CS
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = 0
(CONST 5) = (%INVERSE_JACOBI_CS)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
18 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_CS)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST 4)                           ; 0
28    (JMP L23)


Disassembly of function #:|(DEFUN SIMPLIM%INVERSE_JACOBI_DS (ARG M) ...)-176|
(CONST 0) = SIMPLIM%INVERSE_JACOBI_DS
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_DS>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_DS
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; SIMPLIM%INVERSE_JACOBI_DS
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE SIMPLIM%INVERSE_JACOBI_DS>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; SIMPLIM%INVERSE_JACOBI_DS
8     (SKIP&RET 1)


Disassembly of function SIMPLIM%INVERSE_JACOBI_DS
(CONST 0) = ARG
(CONST 1) = M
(CONST 2) = $INF
(CONST 3) = $MINF
(CONST 4) = 0
(CONST 5) = (%INVERSE_JACOBI_DS)
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (M ARG)
18 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; ARG
3     (LOAD 4)
4     (BIND 1)                            ; M
6     (GETVALUE&PUSH 0)                   ; ARG
8     (JMPIFEQTO 2 L27)                   ; $INF
11    (GETVALUE&PUSH 0)                   ; ARG
13    (JMPIFEQTO 3 L27)                   ; $MINF
16    (CONST&PUSH 5)                      ; (%INVERSE_JACOBI_DS)
17    (GETVALUE&PUSH 0)                   ; ARG
19    (GETVALUE&PUSH 1)                   ; M
21    (LIST 3)
23    L23
23    (UNBIND 2)
25    (SKIP&RET 3)
27    L27
27    (CONST 4)                           ; 0
28    (JMP L23)


Disassembly of function #:|(COMMENT MORE FUNCTIONS ...)-177|
(CONST 0) = COMMENT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (CONST 0)                           ; COMMENT
1     (SKIP&RET 1)


Disassembly of function #:|(DEFUN LFIBTOPHI (E) ...)-178|
(CONST 0) = LFIBTOPHI
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE LFIBTOPHI>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; LFIBTOPHI
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; LFIBTOPHI
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE LFIBTOPHI>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; LFIBTOPHI
8     (SKIP&RET 1)


Disassembly of function LFIBTOPHI
(CONST 0) = E
(CONST 1) = ($FIB)
(CONST 2) = INVOLVE
(CONST 3) = $FIB
(CONST 4) = LNORECURSE
(CONST 5) = ($FIB)
(CONST 6) = $FIBTOPHI
(CONST 7) = LFIBTOPHI
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
35 byte-code instructions:
0     L0
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CONST&PUSH 1)                      ; ($FIB)
6     (CALL2&JMPIFNOT 2 L31)              ; INVOLVE
9     (GETVALUE 0)                        ; E
11    (CAR)
12    (CAR&PUSH)
13    (JMPIFEQTO 3 L35)                   ; $FIB
16    (GETVALUE 0)                        ; E
18    (CAR&PUSH)
19    (CONST&SYMBOL-FUNCTION&PUSH 7)      ; LFIBTOPHI
21    (GETVALUE 0)                        ; E
23    (CDR&PUSH)
24    (CALLSR 0 22)                       ; MAPCAR
27    (CONS)
28    L28
28    (UNBIND1)
29    (SKIP&RET 2)
31    L31
31    (GETVALUE 0)                        ; E
33    (JMP L28)
35    L35
35    (T)
36    (BIND 4)                            ; LNORECURSE
38    (CONST&PUSH 5)                      ; ($FIB)
39    (GETVALUE 0)                        ; E
41    (CDR)
42    (CAR&PUSH)
43    (JSR&PUSH L0)
45    (LIST&PUSH 2)
47    (CALL1 6)                           ; $FIBTOPHI
49    (UNBIND1)
50    (JMP L28)


Disassembly of function #:|(DEFMFUN $LDEFINT (EXP VAR LL ...) ...)-179|
(CONST 0) = $LDEFINT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE $LDEFINT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; $LDEFINT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; $LDEFINT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE $LDEFINT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; $LDEFINT
8     (SKIP&RET 1)


Disassembly of function $LDEFINT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = LL
(CONST 3) = UL
(CONST 4) = $LOGABS
(CONST 5) = ANS
(CONST 6) = SININT
(CONST 7) = $MINUS
(CONST 8) = $LIMIT
(CONST 9) = $PLUS
(CONST 10) = ($INF $MINF $INFINITY $UND $IND)
(CONST 11) = MEMQ
(CONST 12) = NOUNLIMIT
(CONST 13) = ($INF $MINF $INFINITY $UND $IND)
(CONST 14) = SUB*
(CONST 15) = $EXPAND
4 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (LL ANS UL VAR EXP)
writes special variables : (ANS $LOGABS)
56 byte-code instructions:
0     (LOAD 4)
1     (BIND 0)                            ; EXP
3     (LOAD 6)
4     (BIND 1)                            ; VAR
6     (LOAD 8)
7     (BIND 2)                            ; LL
9     (LOAD 10)
10    (BIND 3)                            ; UL
12    (NIL)
13    (BIND 4)                            ; $LOGABS
15    (NIL)
16    (BIND 5)                            ; ANS
18    (PUSH-NIL 2)
20    (T)
21    (SETVALUE 4)                        ; $LOGABS
23    (GETVALUE&PUSH 0)                   ; EXP
25    (GETVALUE&PUSH 1)                   ; VAR
27    (CALL2 6)                           ; SININT
29    (SETVALUE 5)                        ; ANS
31    (PUSH)
32    (GETVALUE&PUSH 1)                   ; VAR
34    (GETVALUE&PUSH 3)                   ; UL
36    (CONST&PUSH 7)                      ; $MINUS
37    (CALL 4 8)                          ; $LIMIT
40    (STORE 1)
41    (GETVALUE&PUSH 5)                   ; ANS
43    (GETVALUE&PUSH 1)                   ; VAR
45    (GETVALUE&PUSH 2)                   ; LL
47    (CONST&PUSH 9)                      ; $PLUS
48    (CALL 4 8)                          ; $LIMIT
51    (STORE 0)
52    (LOAD&PUSH 1)
53    (CONST&PUSH 10)                     ; ($INF $MINF $INFINITY $UND $IND)
54    (CALL2&JMPIFNOT 11 L67)             ; MEMQ
57    (GETVALUE&PUSH 5)                   ; ANS
59    (GETVALUE&PUSH 1)                   ; VAR
61    (GETVALUE&PUSH 3)                   ; UL
63    (CALL 3 12)                         ; NOUNLIMIT
66    (STORE 1)
67    L67
67    (LOAD&PUSH 0)
68    (CONST&PUSH 13)                     ; ($INF $MINF $INFINITY $UND $IND)
69    (CALL2&JMPIFNOT 11 L82)             ; MEMQ
72    (GETVALUE&PUSH 5)                   ; ANS
74    (GETVALUE&PUSH 1)                   ; VAR
76    (GETVALUE&PUSH 2)                   ; LL
78    (CALL 3 12)                         ; NOUNLIMIT
81    (STORE 0)
82    L82
82    (LOAD&PUSH 1)
83    (LOAD&PUSH 1)
84    (CALL2&PUSH 14)                     ; SUB*
86    (CALL1 15)                          ; $EXPAND
88    (SKIP 2)
90    (UNBIND 6)
92    (SKIP&RET 5)


Disassembly of function #:|(DEFUN NOUNLIMIT (EXP VAR VAL) ...)-180|
(CONST 0) = NOUNLIMIT
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE NOUNLIMIT>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; NOUNLIMIT
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; NOUNLIMIT
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE NOUNLIMIT>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; NOUNLIMIT
8     (SKIP&RET 1)


Disassembly of function NOUNLIMIT
(CONST 0) = EXP
(CONST 1) = VAR
(CONST 2) = VAL
(CONST 3) = RESTORELIM
(CONST 4) = (%LIMIT)
(CONST 5) = RIDOFAB
(CONST 6) = $ZEROA
(CONST 7) = ($PLUS)
(CONST 8) = $ZEROB
(CONST 9) = ($MINUS)
3 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR EXP)
writes special variable : (EXP)
31 byte-code instructions:
0     (LOAD 3)
1     (BIND 0)                            ; EXP
3     (LOAD 5)
4     (BIND 1)                            ; VAR
6     (LOAD 7)
7     (BIND 2)                            ; VAL
9     (GETVALUE&PUSH 0)                   ; EXP
11    (CALL1 3)                           ; RESTORELIM
13    (SETVALUE 0)                        ; EXP
15    (CONST&PUSH 4)                      ; (%LIMIT)
16    (GETVALUE&PUSH 0)                   ; EXP
18    (GETVALUE&PUSH 1)                   ; VAR
20    (GETVALUE&PUSH 2)                   ; VAL
22    (CALL1&PUSH 5)                      ; RIDOFAB
24    (LIST&PUSH 4)
26    (GETVALUE&PUSH 2)                   ; VAL
28    (JMPIFEQTO 6 L45)                   ; $ZEROA
31    (GETVALUE&PUSH 2)                   ; VAL
33    (JMPIFEQTO 8 L48)                   ; $ZEROB
36    (NIL)
37    L37
37    (PUSH)
38    (CALLSR 2 35)                       ; NCONC
41    (UNBIND 3)
43    (SKIP&RET 4)
45    L45
45    (CONST 7)                           ; ($PLUS)
46    (JMP L37)
48    L48
48    (CONST 9)                           ; ($MINUS)
49    (JMP L37)


Disassembly of function #:|(DEFUN HIDE (EXP) ...)-181|
(CONST 0) = HIDE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HIDE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HIDE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HIDE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HIDE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HIDE
8     (SKIP&RET 1)


Disassembly of function HIDE
(CONST 0) = EXP
(CONST 1) = (%INTEGRATE %LIMIT %DERIVATIVE %SUM)
(CONST 2) = MEMQ
(CONST 3) = HIDELIM
(CONST 4) = HIDE
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (EXP)
34 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; EXP
3     (GETVALUE 0)                        ; EXP
5     (JMPIFATOM L36)
7     (GETVALUE 0)                        ; EXP
9     (CAR)
10    (CAR&PUSH)
11    (CONST&PUSH 1)                      ; (%INTEGRATE %LIMIT %DERIVATIVE ...)
12    (CALL2&PUSH 2)                      ; MEMQ
14    (LOAD&JMPIF 0 L40)
17    (NIL)
18    (SKIP 1)
20    (JMPIF1 L33)
22    L22
22    (GETVALUE 0)                        ; EXP
24    (CAR&PUSH)
25    (CONST&PUSH 4)                      ; HIDE
26    (GETVALUE 0)                        ; EXP
28    (CDR&PUSH)
29    (CALLSR 0 22)                       ; MAPCAR
32    (CONS)
33    L33
33    (UNBIND1)
34    (SKIP&RET 2)
36    L36
36    (GETVALUE 0)                        ; EXP
38    (JMP L33)
40    L40
40    (GETVALUE&PUSH 0)                   ; EXP
42    (LOAD&CAR&PUSH 1)
44    (CALL2 3)                           ; HIDELIM
46    (SKIP 1)
48    (JMPIF1 L33)
50    (JMP L22)


Disassembly of function #:|(DEFUN HIDELIM (EXP FUNC) ...)-182|
(CONST 0) = HIDELIM
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HIDELIM>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HIDELIM
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HIDELIM
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HIDELIM>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HIDELIM
8     (SKIP&RET 1)


Disassembly of function HIDELIM
(CONST 0) = EXP
(CONST 1) = %INTEGRATE
(CONST 2) = %SUM
(CONST 3) = VAR
(CONST 4) = HIDELIMA
(CONST 5) = AMONG
(CONST 6) = VAL
(CONST 7) = NOUNLIMIT
(CONST 8) = LIMITSUB
(CONST 9) = PUTPROP
(CONST 10) = %LIMIT
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL VAR EXP)
109 byte-code instructions:
0     (LOAD 2)
1     (BIND 0)                            ; EXP
3     (LOAD&PUSH 4)
4     (JMPIFEQTO 1 L45)                   ; %INTEGRATE
7     (LOAD&PUSH 4)
8     (JMPIFEQTO 2 L45)                   ; %SUM
11    (LOAD&PUSH 4)
12    (JMPIFEQTO 10 L137)                 ; %LIMIT
16    (PUSH-UNBOUND 1)
18    (CALLS2&STORE 143 4)                ; GENSYM
21    (PUSH)
22    (GETVALUE&PUSH 0)                   ; EXP
24    (CALL1&PUSH 4)                      ; HIDELIMA
26    (CONST 8)                           ; LIMITSUB
27    L27
27    (PUSH)
28    (CALL 3 9)                          ; PUTPROP
31    (LOAD 4)
32    (UNBIND1)
33    (SKIP&RET 3)
35    L35
35    (GETVALUE&PUSH 0)                   ; EXP
37    (CALL1 4)                           ; HIDELIMA
39    (JMP L96)
41    L41
41    (GETVALUE 0)                        ; EXP
43    (JMP L96)
45    L45
45    (PUSH-UNBOUND 1)
47    (CALLS2&STORE 143 4)                ; GENSYM
50    (PUSH)
51    (GETVALUE 0)                        ; EXP
53    (CDR)
54    (CDR)
55    (CDR)
56    (JMPIFNOT L35)
58    (GETVALUE&PUSH 3)                   ; VAR
60    (GETVALUE 0)                        ; EXP
62    (CDR)
63    (CDR)
64    (CAR)
65    (JMPIFNOTEQ L35)
67    (GETVALUE&PUSH 3)                   ; VAR
69    (GETVALUE 0)                        ; EXP
71    (CDR)
72    (CDR)
73    (CDR)
74    (CAR&PUSH)
75    (CALL2&JMPIF 5 L87)                 ; AMONG
78    (GETVALUE&PUSH 3)                   ; VAR
80    (GETVALUE&PUSH 0)                   ; EXP
82    (CALLS1&PUSH 149)                   ; FIFTH
84    (CALL2&JMPIFNOT 5 L41)              ; AMONG
87    L87
87    (GETVALUE&PUSH 0)                   ; EXP
89    (GETVALUE&PUSH 3)                   ; VAR
91    (GETVALUE&PUSH 6)                   ; VAL
93    (CALL 3 7)                          ; NOUNLIMIT
96    L96
96    (PUSH)
97    (CONST 8)                           ; LIMITSUB
98    (JMP L27)
101   L101
101   (GETVALUE 0)                        ; EXP
103   (CAR&PUSH)
104   (GETVALUE 0)                        ; EXP
106   (CDR)
107   (CAR&PUSH)
108   (GETVALUE 0)                        ; EXP
110   (CDR)
111   (CDR)
112   (CAR&PUSH)
113   (LIST&PUSH 3)
115   (GETVALUE&PUSH 6)                   ; VAL
117   (GETVALUE&PUSH 3)                   ; VAR
119   (GETVALUE 0)                        ; EXP
121   (CDR)
122   (CDR)
123   (CDR&PUSH)
124   (PUSH-UNBOUND 3)
126   (CALLS1&PUSH 172)                   ; SUBST
128   (CALLSR 2 35)                       ; NCONC
131   (JMP L166)
133   L133
133   (GETVALUE 0)                        ; EXP
135   (JMP L166)
137   L137
137   (PUSH-UNBOUND 1)
139   (CALLS2&STORE 143 4)                ; GENSYM
142   (PUSH)
143   (GETVALUE&PUSH 3)                   ; VAR
145   (GETVALUE 0)                        ; EXP
147   (CDR)
148   (CDR)
149   (CDR)
150   (CAR)
151   (JMPIFEQ L101)
153   (GETVALUE&PUSH 3)                   ; VAR
155   (GETVALUE 0)                        ; EXP
157   (CDR)
158   (CDR)
159   (CAR)
160   (JMPIFEQ L133)
162   (GETVALUE&PUSH 0)                   ; EXP
164   (CALL1 4)                           ; HIDELIMA
166   L166
166   (PUSH)
167   (CONST 8)                           ; LIMITSUB
168   (JMP L27)


Disassembly of function #:|(DEFUN HIDELIMA (E) ...)-183|
(CONST 0) = HIDELIMA
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE HIDELIMA>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; HIDELIMA
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; HIDELIMA
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE HIDELIMA>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; HIDELIMA
8     (SKIP&RET 1)


Disassembly of function HIDELIMA
(CONST 0) = E
(CONST 1) = VAR
(CONST 2) = AMONG
(CONST 3) = VAL
(CONST 4) = NOUNLIMIT
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAL E VAR)
15 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 1)                   ; VAR
5     (GETVALUE&PUSH 0)                   ; E
7     (CALL2&JMPIF 2 L15)                 ; AMONG
10    (GETVALUE 0)                        ; E
12    L12
12    (UNBIND1)
13    (SKIP&RET 2)
15    L15
15    (GETVALUE&PUSH 0)                   ; E
17    (GETVALUE&PUSH 1)                   ; VAR
19    (GETVALUE&PUSH 3)                   ; VAL
21    (CALL 3 4)                          ; NOUNLIMIT
24    (JMP L12)


Disassembly of function #:|(DEFUN OSCIP (E) ...)-184|
(CONST 0) = OSCIP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE OSCIP>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; OSCIP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; OSCIP
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE OSCIP>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; OSCIP
8     (SKIP&RET 1)


Disassembly of function OSCIP
(CONST 0) = E
(CONST 1) = (%SIN %COS %TAN)
(CONST 2) = INVOLVE
(CONST 3) = $%I
(CONST 4) = %EINVOLVE
(CONST 5) = AMONG
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
13 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE&PUSH 0)                   ; E
5     (CONST&PUSH 1)                      ; (%SIN %COS %TAN)
6     (CALL2 2)                           ; INVOLVE
8     (JMPIF1 L17)
10    (CONST&PUSH 3)                      ; $%I
11    (GETVALUE&PUSH 0)                   ; E
13    (CALL1&PUSH 4)                      ; %EINVOLVE
15    (CALL2 5)                           ; AMONG
17    L17
17    (UNBIND1)
18    (SKIP&RET 2)


Disassembly of function #:|(DEFUN %EINVOLVE (E) ...)-185|
(CONST 0) = %EINVOLVE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE %EINVOLVE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; %EINVOLVE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; %EINVOLVE
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE %EINVOLVE>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; %EINVOLVE
8     (SKIP&RET 1)


Disassembly of function %EINVOLVE
(CONST 0) = E
(CONST 1) = $%E
(CONST 2) = AMONG
(CONST 3) = %EINVOLVE01
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variable: (E)
13 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (CONST&PUSH 1)                      ; $%E
4     (GETVALUE&PUSH 0)                   ; E
6     (CALL2&JMPIF 2 L13)                 ; AMONG
9     (NIL)
10    L10
10    (UNBIND1)
11    (SKIP&RET 2)
13    L13
13    (GETVALUE&PUSH 0)                   ; E
15    (CALL1 3)                           ; %EINVOLVE01
17    (JMP L10)


Disassembly of function #:|(DEFUN %EINVOLVE01 (E) ...)-186|
(CONST 0) = %EINVOLVE01
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE %EINVOLVE01>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
7 byte-code instructions:
0     (CONST&PUSH 0)                      ; %EINVOLVE01
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; %EINVOLVE01
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE %EINVOLVE01>
5     (CALLS2 130)                        ; SYSTEM::%PUTD
7     (CONST 0)                           ; %EINVOLVE01
8     (SKIP&RET 1)


Disassembly of function %EINVOLVE01
(CONST 0) = E
(CONST 1) = MNUMP
(CONST 2) = MEXPTP
(CONST 3) = $%E
(CONST 4) = VAR
(CONST 5) = AMONG
(CONST 6) = %EINVOLVE
(CONST 7) = ORMAPC
1 required argument
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (VAR E)
38 byte-code instructions:
0     (LOAD 1)
1     (BIND 0)                            ; E
3     (GETVALUE 0)                        ; E
5     (JMPIFATOM L44)
7     (GETVALUE&PUSH 0)                   ; E
9     (CALL1&JMPIF 1 L47)                 ; MNUMP
12    (GETVALUE&PUSH 0)                   ; E
14    (CALL1&JMPIFNOT 2 L34)              ; MEXPTP
17    (GETVALUE 0)                        ; E
19    (CDR)
20    (CAR&PUSH)
21    (JMPIFNOTEQTO 3 L34)                ; $%E
24    (GETVALUE&PUSH 4)                   ; VAR
26    (GETVALUE 0)                        ; E
28    (CDR)
29    (CDR)
30    (CAR&PUSH)
31    (CALL2&JMPIF 5 L50)                 ; AMONG
34    L34
34    (CONST&SYMBOL-FUNCTION&PUSH 6)      ; %EINVOLVE
36    (GETVALUE 0)                        ; E
38    (CDR&PUSH)
39    (CALL2 7)                           ; ORMAPC
41    L41
41    (UNBIND1)
42    (SKIP&RET 2)
44    L44
44    (NIL)
45    (JMP L41)
47    L47
47    (NIL)
48    (JMP L41)
50    L50
50    (GETVALUE 0)                        ; E
52    (CDR)
53    (CDR)
54    (CAR)
55    (JMP L41)


Disassembly of function #:|(DECLARE-TOP (UNSPECIAL *INDICATOR NN* ...))-187|
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
2 byte-code instructions:
0     (NIL)
1     (SKIP&RET 1)


Wrote file binary-clisp/limit.fas
Wrote file /cygdrive/e/temp/maxima/src/limit.lis