Listing of compilation of file /cygdrive/e/temp/maxima/src/nregex.lisp
on 2002-12-17 13:31:48 by CLISP, version 2.30 (released 2002-09-15) (built 3249143430) (memory 3249145291)
Compiling file /cygdrive/e/temp/maxima/src/nregex.lisp ...

Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFPACKAGE "NREGEX" # ...))-1-1|
(CONST 0) = "NREGEX"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; "NREGEX"
1     (PUSH-NIL 2)
3     (PUSH-UNBOUND 1)
5     (CALLS1 223)                        ; SYSTEM::%IN-PACKAGE
7     (VALUES0)
8     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFPACKAGE "NREGEX" # ...))-1-2|
(CONST 0) = ("COMMON-LISP")
(CONST 1) = "NREGEX"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; ("COMMON-LISP")
1     (CONST&PUSH 1)                      ; "NREGEX"
2     (CALLS1 220)                        ; USE-PACKAGE
4     (VALUES0)
5     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFPACKAGE "NREGEX" # ...))-1-3|
(CONST 0) = ("*REGEX-DEBUG*" "*REGEX-GROUPS*" "*REGEX-GROUPINGS*" "REGEX-COMPILE")
(CONST 1) = "NREGEX"
(CONST 2) = SYSTEM::INTERN-EXPORT
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
5 byte-code instructions:
0     (CONST&PUSH 0)                      ; ("*REGEX-DEBUG*" ...)
1     (CONST&PUSH 1)                      ; "NREGEX"
2     (CALL2 2)                           ; SYSTEM::INTERN-EXPORT
4     (VALUES0)
5     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFPACKAGE "NREGEX" # ...))-1-4|
(CONST 0) = "NREGEX"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
3 byte-code instructions:
0     (CONST&PUSH 0)                      ; "NREGEX"
1     (CALLS1 204)                        ; FIND-PACKAGE
3     (SKIP&RET 1)


Disassembly of function #:|(IN-PACKAGE "NREGEX")-2|
(CONST 0) = "NREGEX"
(CONST 1) = *PACKAGE*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
writes special variable : (*PACKAGE*)
4 byte-code instructions:
0     (CONST&PUSH 0)                      ; "NREGEX"
1     (CALLS1 228)                        ; SYSTEM::%FIND-PACKAGE
3     (SETVALUE 1)                        ; *PACKAGE*
5     (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFVAR *REGEX-DEBUG* NIL) ...)-3-1|
(CONST 0) = (SPECIAL *REGEX-DEBUG*)
(CONST 1) = *REGEX-DEBUG*
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *REGEX-DEBUG*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *REGEX-DEBUG*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *REGEX-DEBUG*
8     (NIL&PUSH)
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (VALUES0)
12    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFVAR *REGEX-DEBUG* NIL) ...)-3-2|
(CONST 0) = INFO
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = #<COMPILED-CLOSURE INFO>
(CONST 3) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
8 byte-code instructions:
0     (CONST&PUSH 0)                      ; INFO
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; INFO
4     (CONST&PUSH 2)                      ; #<COMPILED-CLOSURE INFO>
5     (CALL1&PUSH 3)                      ; SYSTEM::MAKE-MACRO
7     (CALLS2 130)                        ; SYSTEM::%PUTD
9     (VALUES0)
10    (SKIP&RET 1)


Disassembly of function INFO
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = *REGEX-DEBUG*
(CONST 3) = FORMAT
(CONST 4) = *TRACE-OUTPUT*
1 required argument
1 optional argument
No rest parameter
No keyword parameters
reads special variable: (*REGEX-DEBUG*)
24 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 47 L26)             ; <
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (LOAD 3)
12    (CDR)
13    (CDR&PUSH)
14    (GETVALUE 2)                        ; *REGEX-DEBUG*
16    (JMPIFNOT1 L31)
18    (CONST&PUSH 3)                      ; FORMAT
19    (CONST&PUSH 4)                      ; *TRACE-OUTPUT*
20    (LOAD&PUSH 3)
21    (LOAD 3)
22    (LIST* 3)
24    (SKIP&RET 5)
26    L26
26    (LOAD&PUSH 2)
27    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
29    (SKIP&RET 3)
31    L31
31    (SKIP&RET 5)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFVAR *REGEX-DEBUG* NIL) ...)-3-3|
(CONST 0) = (SPECIAL *REGEX-GROUPS*)
(CONST 1) = *REGEX-GROUPS*
(CONST 2) = 10
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
12 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *REGEX-GROUPS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *REGEX-GROUPS*
4     (CALLS1&JMPIF 79 L15)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *REGEX-GROUPS*
8     (CONST&PUSH 2)                      ; 10
9     (PUSH-UNBOUND 7)
11    (CALLS1&PUSH 29)                    ; MAKE-ARRAY
13    (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
15    L15
15    (VALUES0)
16    (SKIP&RET 1)


Disassembly of function #:|(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (DEFVAR *REGEX-DEBUG* NIL) ...)-3-4|
(CONST 0) = (SPECIAL *REGEX-GROUPINGS*)
(CONST 1) = *REGEX-GROUPINGS*
(CONST 2) = 0
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *REGEX-GROUPINGS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *REGEX-GROUPINGS*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *REGEX-GROUPINGS*
8     (CONST&PUSH 2)                      ; 0
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST 1)                           ; *REGEX-GROUPINGS*
12    (SKIP&RET 1)


Disassembly of function #:|(DEFUN REGEX (EXPRESSION STRING) ...)-4|
(CONST 0) = REGEX
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = 
"Usage: (regex <expression> <string)
   This function will call regex-compile on the expression and then apply
   the string to the returned lambda list."
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE REGEX>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; REGEX
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REGEX
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Usage: (regex <expression> <string)
   This function will call regex-compile on the expression and then apply
   the string to the returned lambda list."
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; REGEX
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE REGEX>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (CONST 0)                           ; REGEX
14    (SKIP&RET 1)


Disassembly of function REGEX
(CONST 0) = REGEX-COMPILE
(CONST 1) = FUNCTION
(CONST 2) = *REGEX-GROUPINGS*
(CONST 3) = 0
(CONST 4) = SUBSEQ
(CONST 5) = *REGEX-GROUPS*
2 required arguments
0 optional arguments
No rest parameter
No keyword parameters
reads special variables: (*REGEX-GROUPS* *REGEX-GROUPINGS*)
64 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&JMPIF 7 L39)                ; STRINGP
4     (LOAD&PUSH 2)
5     (CALLS2&JMPIF 11 L44)               ; LISTP
8     (NIL)
9     L9
9     (PUSH)
10    (NIL&PUSH)
11    (LOAD&PUSH 1)
12    (CALLS2&JMPIF 29 L47)               ; FUNCTIONP
15    (CONST&PUSH 1)                      ; FUNCTION
16    (LOAD&PUSH 2)
17    (LIST&PUSH 2)
19    (CALLS1 91)                         ; EVAL
21    L21
21    (PUSH)
22    (LOAD&PUSH 4)
23    (FUNCALL 1)
25    (JMPIFNOT L50)
27    (GETVALUE&PUSH 2)                   ; *REGEX-GROUPINGS*
29    (CONST&PUSH 3)                      ; 0
30    (CALLSR&JMPIF 1 45 L53)             ; =
34    (CONST&PUSH 3)                      ; 0
35    (GETVALUE&PUSH 2)                   ; *REGEX-GROUPINGS*
37    (JMP L79)
39    L39
39    (LOAD&PUSH 2)
40    (CALL1 0)                           ; REGEX-COMPILE
42    (JMP L9)
44    L44
44    (LOAD 2)
45    (JMP L9)
47    L47
47    (LOAD 1)
48    (JMP L21)
50    L50
50    (NIL)
51    (SKIP&RET 5)
53    L53
53    (T)
54    (SKIP&RET 5)
56    L56
56    (CONST&PUSH 4)                      ; SUBSEQ
57    (LOAD&PUSH 6)
58    (GETVALUE&PUSH 5)                   ; *REGEX-GROUPS*
60    (LOAD&PUSH 4)
61    (CALLSR 1 1)                        ; AREF
64    (CAR&PUSH)
65    (GETVALUE&PUSH 5)                   ; *REGEX-GROUPS*
67    (LOAD&PUSH 5)
68    (CALLSR 1 1)                        ; AREF
71    (CDR)
72    (CAR&PUSH)
73    (FUNCALL&PUSH 3)
75    (LOAD&CONS&STORE 2)
77    (LOAD&INC&STORE 1)
79    L79
79    (LOAD&PUSH 1)
80    (LOAD&PUSH 1)
81    (CALLSR&JMPIFNOT 1 50 L56)          ; >=
85    (SKIP 2)
87    (LOAD&PUSH 0)
88    (CALLS2 72)                         ; REVERSE
90    (SKIP&RET 5)


Disassembly of function #:|(DEFVAR *REGEX-SPECIAL-CHARS* "?*+.()[]\\\\${}")-5|
(CONST 0) = (SPECIAL *REGEX-SPECIAL-CHARS*)
(CONST 1) = *REGEX-SPECIAL-CHARS*
(CONST 2) = "?*+.()[]\\${}"
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
10 byte-code instructions:
0     (CONST&PUSH 0)                      ; (SPECIAL *REGEX-SPECIAL-CHARS*)
1     (CALLS1 90)                         ; PROCLAIM
3     (CONST&PUSH 1)                      ; *REGEX-SPECIAL-CHARS*
4     (CALLS1&JMPIF 79 L11)               ; BOUNDP
7     (CONST&PUSH 1)                      ; *REGEX-SPECIAL-CHARS*
8     (CONST&PUSH 2)                      ; "?*+.()[]\\${}"
9     (CALLS1 82)                         ; SYSTEM::SET-SYMBOL-VALUE
11    L11
11    (CONST 1)                           ; *REGEX-SPECIAL-CHARS*
12    (SKIP&RET 1)


Disassembly of function #:|(DEFMACRO ADD-EXP (LIST) ...)-6|
(CONST 0) = ADD-EXP
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = "Add an item to the end of expression"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE ADD-EXP>
(CONST 6) = SYSTEM::MAKE-MACRO
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
12 byte-code instructions:
0     (CONST&PUSH 0)                      ; ADD-EXP
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; ADD-EXP
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Add an item to the end of expression"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; ADD-EXP
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE ADD-EXP>
11    (CALL1&PUSH 6)                      ; SYSTEM::MAKE-MACRO
13    (CALLS2 130)                        ; SYSTEM::%PUTD
15    (CONST 0)                           ; ADD-EXP
16    (SKIP&RET 1)


Disassembly of function ADD-EXP
(CONST 0) = 2
(CONST 1) = SYSTEM::MACRO-CALL-ERROR
(CONST 2) = SETF
(CONST 3) = EXPRESSION
(CONST 4) = APPEND
1 required argument
1 optional argument
No rest parameter
No keyword parameters
19 byte-code instructions:
0     (LOAD&PUSH 2)
1     (CALLS2&PUSH 71)                    ; LENGTH
3     (CONST&PUSH 0)                      ; 2
4     (CALLSR&JMPIF 1 46 L22)             ; /=
8     (LOAD 2)
9     (CDR)
10    (CAR&PUSH)
11    (CONST&PUSH 2)                      ; SETF
12    (CONST&PUSH 3)                      ; EXPRESSION
13    (CONST&PUSH 4)                      ; APPEND
14    (CONST&PUSH 3)                      ; EXPRESSION
15    (LOAD&PUSH 4)
16    (LIST&PUSH 3)
18    (LIST 3)
20    (SKIP&RET 4)
22    L22
22    (LOAD&PUSH 2)
23    (CALL1 1)                           ; SYSTEM::MACRO-CALL-ERROR
25    (SKIP&RET 3)


Disassembly of function #:|(DEFUN REGEX-COMPILE (SOURCE &KEY # ...) ...)-7|
(CONST 0) = REGEX-COMPILE
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = 
"Usage: (regex-compile <expression> [ :anchored (t/nil) ] [ :case-sensitive (t/nil) ])
       This function take a regular expression (supplied as source) and
       compiles this into a lambda list that a string argument can then
       be applied to.  It is also possible to compile this lambda list
       for better performance or to save it as a named function for later
       use"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE REGEX-COMPILE>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; REGEX-COMPILE
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REGEX-COMPILE
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Usage: (regex-compile <expression> [ :anchored (t/nil) ] [ :case-sensitive (t/nil) ])
       This function take a regular expression (supplied as source) and
       compiles this into a lambda list that a string argument can then
       be applied to.  It is also possible to compile this lambda list
       for better performance or to save it as a named function for later
       use"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; REGEX-COMPILE
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE REGEX-COMPILE>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (CONST 0)                           ; REGEX-COMPILE
14    (SKIP&RET 1)


Disassembly of function REGEX-COMPILE
(CONST 0) = :ANCHORED
(CONST 1) = :CASE-SENSITIVE
(CONST 2) = 1
(CONST 3) = 0
(CONST 4) = (LAMBDA (&REST ARGS) (DECLARE (IGNORE ARGS)) T)
(CONST 5) = #\^
(CONST 6) = 2
(CONST 7) = ".*"
(CONST 8) = *REGEX-SPECIAL-CHARS*
(CONST 9) = IF
(CONST 10) = NOT
(CONST 11) = DO
(CONST 12) = ((I START (+ I 1)))
(CONST 13) = ((>= I LENGTH))
(CONST 14) = EQL
(CONST 15) = CHAR-EQUAL
(CONST 16) = (CHAR STRING I)
(CONST 17) = ((RETURN (SETF START I)))
(CONST 18) = ((RETURN-FROM FINAL-RETURN NIL))
(CONST 19) = ((SETF (AREF *REGEX-GROUPS* 0) (LIST INDEX NIL)))
(CONST 20) = 
#S(HASH-TABLE EQ (#\\ . 396) (#\[ . 125) (#\) . 77) (#\( . 42) (#\? . 37)
   (#\+ . 32) (#\* . 27) (#\$ . 12) (#\. . 2))
(CONST 21) = ((IF (>= INDEX LENGTH) (RETURN-FROM COMPARE NIL) (INCF INDEX)))
(CONST 22) = ((IF (NOT (= INDEX LENGTH)) (RETURN-FROM COMPARE NIL)))
(CONST 23) = 
((IF (NOT (AND (< INDEX LENGTH) (EQL (CHAR STRING INDEX) #\$)))
  (RETURN-FROM COMPARE NIL) (INCF INDEX)))
(CONST 24) = (ASTRISK)
(CONST 25) = (PLUS)
(CONST 26) = (QUESTION)
(CONST 27) = SETF
(CONST 28) = AREF
(CONST 29) = *REGEX-GROUPS*
(CONST 30) = ((LIST INDEX NIL))
(CONST 31) = CADR
(CONST 32) = (INDEX)
(CONST 33) = 256
(CONST 34) = BIT
(CONST 35) = #\]
(CONST 36) = #\-
(CONST 37) = "Invalid range \"~A-~A\".  Ranges must be in acending order"
(CONST 38) = #\\
(CONST 39) = REGEX-QUOTED
(CONST 40) = LET
(CONST 41) = RANGE
(CONST 42) = 
((IF (>= INDEX LENGTH) (RETURN-FROM COMPARE NIL))
 (IF (= 1 (SBIT RANGE (CHAR-CODE (CHAR STRING INDEX)))) (INCF INDEX)
  (RETURN-FROM COMPARE NIL)))
(CONST 43) = AND
(CONST 44) = (< INDEX LENGTH)
(CONST 45) = (CHAR STRING INDEX)
(CONST 46) = ((RETURN-FROM COMPARE NIL) (INCF INDEX))
(CONST 47) = 
((IF (>= INDEX LENGTH) (RETURN-FROM COMPARE NIL))
 (IF (= 1 (SBIT RANGE (CHAR-CODE (CHAR STRING INDEX)))) (INCF INDEX)
  (RETURN-FROM COMPARE NIL)))
(CONST 48) = ""
(CONST 49) = STRING
(CONST 50) = (< INDEX LENGTH)
(CONST 51) = (CHAR STRING INDEX)
(CONST 52) = ((RETURN-FROM COMPARE NIL) (INCF INDEX))
(CONST 53) = #\*
(CONST 54) = #\+
(CONST 55) = <
(CONST 56) = LENGTH
(CONST 57) = +
(CONST 58) = INDEX
(CONST 59) = ((RETURN-FROM COMPARE NIL))
(CONST 60) = STRING=
(CONST 61) = STRING-EQUAL
(CONST 62) = :START1
(CONST 63) = :END1
(CONST 64) = (RETURN-FROM COMPARE NIL)
(CONST 65) = INCF
(CONST 66) = ((SETF (CADR (AREF *REGEX-GROUPS* 0)) INDEX))
(CONST 67) = ((RETURN-FROM FINAL-RETURN T))
(CONST 68) = PLUS
(CONST 69) = *STANDARD-OUTPUT*
(CONST 70) = #<COMPILED-CLOSURE REGEX-COMPILE-1>
(CONST 71) = FORMAT
(CONST 72) = QUESTION
(CONST 73) = PROGN
(CONST 74) = BLOCK
(CONST 75) = COMPARE
(CONST 76) = (T)
(CONST 77) = #<COMPILED-CLOSURE REGEX-COMPILE-2>
(CONST 78) = ASTRISK
(CONST 79) = ((OINDEX INDEX))
(CONST 80) = (DECLARE (FIXNUM OINDEX))
(CONST 81) = (NIL)
(CONST 82) = ((START INDEX (1- START)))
(CONST 83) = ((< START OINDEX) NIL)
(CONST 84) = (DECLARE (FIXNUM START))
(CONST 85) = ((INDEX START))
(CONST 86) = (DECLARE (FIXNUM INDEX))
(CONST 87) = LAMBDA
(CONST 88) = (STRING &KEY (START 0) (END (LENGTH STRING)))
(CONST 89) = 
(DECLARE (STRING STRING) (FIXNUM START END)
 (OPTIMIZE (SPEED 0) (COMPILATION-SPEED 3)))
(CONST 90) = *REGEX-GROUPINGS*
(CONST 91) = FINAL-RETURN
(CONST 92) = ((INDEX START) (LENGTH END))
(CONST 93) = (DECLARE (FIXNUM INDEX LENGTH))
(CONST 94) = (STRING &KEY (START 0) (END (LENGTH STRING)))
(CONST 95) = 
(DECLARE (STRING STRING) (FIXNUM START END)
 (OPTIMIZE (SPEED 0) (COMPILATION-SPEED 3)))
(CONST 96) = ((LENGTH END))
(CONST 97) = (DECLARE (FIXNUM LENGTH))
(CONST 98) = ((MARKER START (1+ MARKER)))
(CONST 99) = ((> MARKER END) NIL)
(CONST 100) = (DECLARE (FIXNUM MARKER))
(CONST 101) = ((INDEX MARKER))
(CONST 102) = (DECLARE (FIXNUM INDEX))
(CONST 103) = ((RETURN T))
1 required argument
0 optional arguments
No rest parameter
2 keyword parameters: :ANCHORED, :CASE-SENSITIVE.
reads special variables: (*STANDARD-OUTPUT* *REGEX-SPECIAL-CHARS*)
685 byte-code instructions:
0     (UNBOUND->NIL 2)
2     (JMPIFBOUNDP 1 L7)
5     (T&STORE 1)
7     L7
7     (NIL&PUSH)
8     (CONST&PUSH 2)                      ; 1
9     (PUSH-NIL 3)
11    (LOAD&PUSH 8)
12    (CALLS2&PUSH 71)                    ; LENGTH
14    (CONST&PUSH 3)                      ; 0
15    (CALLSR&JMPIF 1 45 L128)            ; =
20    (LOAD&PUSH 8)
21    (CONST&PUSH 3)                      ; 0
22    (CALLS1&PUSH 49)                    ; CHAR
24    (JMPIFNOTEQTO 5 L36)                ; #\^
27    (LOAD&PUSH 8)
28    (CONST&PUSH 2)                      ; 1
29    (PUSH-UNBOUND 1)
31    (CALLS2&STORE 69 8)                 ; SUBSEQ
34    (T&STORE 7)
36    L36
36    (LOAD&PUSH 8)
37    (CALLS2&PUSH 71)                    ; LENGTH
39    (CONST&PUSH 6)                      ; 2
40    (CALLSR&JMPIFNOT 1 50 L54)          ; >=
44    (LOAD&PUSH 8)
45    (CONST&PUSH 7)                      ; ".*"
46    (CONST&PUSH 3)                      ; 0
47    (CONST&PUSH 6)                      ; 2
48    (PUSH-UNBOUND 2)
50    (CALLS1&JMPIF 53 L131)              ; STRING=
54    L54
54    (LOAD&JMPIF 7 L118)
57    L57
57    (LOAD&PUSH 8)
58    (CONST&PUSH 3)                      ; 0
59    (CALLS1&PUSH 49)                    ; CHAR
61    (GETVALUE&PUSH 8)                   ; *REGEX-SPECIAL-CHARS*
63    (PUSH-UNBOUND 6)
65    (CALLS2&JMPIF 95 L118)              ; POSITION
68    (LOAD&PUSH 8)
69    (CALLS2&PUSH 71)                    ; LENGTH
71    (CONST&PUSH 2)                      ; 1
72    (CALLSR&JMPIFNOT 1 48 L87)          ; >
76    (LOAD&PUSH 8)
77    (CONST&PUSH 2)                      ; 1
78    (CALLS1&PUSH 49)                    ; CHAR
80    (GETVALUE&PUSH 8)                   ; *REGEX-SPECIAL-CHARS*
82    (PUSH-UNBOUND 6)
84    (CALLS2&JMPIF 95 L118)              ; POSITION
87    L87
87    (CONST&PUSH 9)                      ; IF
88    (CONST&PUSH 10)                     ; NOT
89    (CONST&PUSH 11)                     ; DO
90    (CONST&PUSH 12)                     ; ((I START (+ I 1)))
91    (CONST&PUSH 13)                     ; ((>= I LENGTH))
92    (CONST&PUSH 9)                      ; IF
93    (LOAD&JMPIF 12 L139)
96    (CONST 15)                          ; CHAR-EQUAL
97    L97
97    (PUSH)
98    (CONST&PUSH 16)                     ; (CHAR STRING I)
99    (LOAD&PUSH 16)
100   (CONST&PUSH 3)                      ; 0
101   (CALLS1&PUSH 49)                    ; CHAR
103   (LIST&PUSH 3)
105   (CONST 17)                          ; ((RETURN (SETF START I)))
106   (LIST*&PUSH 2)
108   (LIST&PUSH 4)
110   (LIST&PUSH 2)
112   (CONST 18)                          ; ((RETURN-FROM FINAL-RETURN NIL))
113   (LIST*&PUSH 2)
115   (LIST 1)
117   (STORE 0)
118   L118
118   (LOAD&PUSH 4)
119   (CONST&PUSH 19)                     ; ((SETF # #))
120   (CALLSR&STORE 2 34 4)               ; APPEND
124   (CONST&PUSH 3)                      ; 0
125   (JMP L884)
128   L128
128   (CONST 4)                           ; (LAMBDA (&REST ARGS) (DECLARE #) T)
129   (SKIP&RET 9)
131   L131
131   (T&STORE 7)
133   (LOAD&JMPIFNOT 7 L57)
137   (JMP L118)
139   L139
139   (CONST 14)                          ; EQL
140   (JMP L97)
142   L142
142   (LOAD&PUSH 9)
143   (LOAD&PUSH 1)
144   (CALLS1&PUSH 49)                    ; CHAR
146   (LOAD 0)
147   (JMPHASH 20 L601 L151 L161 L176 L181 L186 L191 L226 L274 L545)
151   L151
151   (LOAD&PUSH 6)
152   (CONST 21)                          ; ((IF # # #))
154   (JMP L218)
156   L156
156   (LOAD&PUSH 6)
157   (CONST 22)                          ; ((IF # #))
159   (JMP L218)
161   L161
161   (LOAD&PUSH 1)
162   (LOAD&PUSH 11)
163   (CALLS2&PUSH 71)                    ; LENGTH
165   (CALLS2&PUSH 151)                   ; 1-
167   (CALLSR&JMPIF 1 45 L156)            ; =
171   (LOAD&PUSH 6)
172   (CONST 23)                          ; ((IF # # #))
174   (JMP L218)
176   L176
176   (LOAD&PUSH 6)
177   (CONST 24)                          ; (ASTRISK)
179   (JMP L218)
181   L181
181   (LOAD&PUSH 6)
182   (CONST 25)                          ; (PLUS)
184   (JMP L218)
186   L186
186   (LOAD&PUSH 6)
187   (CONST 26)                          ; (QUESTION)
189   (JMP L218)
191   L191
191   (LOAD&INC&STORE 5)
193   (PUSH)
194   (LOAD&CONS&STORE 4)
196   (LOAD&PUSH 6)
197   (CONST&PUSH 27)                     ; SETF
198   (CONST&PUSH 28)                     ; AREF
199   (CONST&PUSH 29)                     ; *REGEX-GROUPS*
200   (LOAD&DEC&PUSH 9)
202   (LIST&PUSH 3)
204   (CONST 30)                          ; ((LIST INDEX NIL))
206   (LIST*&PUSH 2)
208   (LIST&PUSH 1)
210   (CALLSR&STORE 2 34 6)               ; APPEND
214   (PUSH)
215   (LOAD&PUSH 6)
216   (LIST 1)
218   L218
218   (PUSH)
219   (CALLSR&STORE 2 34 6)               ; APPEND
223   (JMP L880)
226   L226
226   (LOAD&CAR&PUSH 4)
228   (LOAD&CDR&STORE 5)
230   (LOAD&PUSH 7)
231   (CONST&PUSH 27)                     ; SETF
232   (CONST&PUSH 31)                     ; CADR
234   (CONST&PUSH 28)                     ; AREF
235   (CONST&PUSH 29)                     ; *REGEX-GROUPS*
236   (LOAD&DEC&PUSH 5)
238   (LIST&PUSH 3)
240   (LIST&PUSH 2)
242   (CONST 32)                          ; (INDEX)
244   (LIST*&PUSH 2)
246   (LIST&PUSH 1)
248   (CALLSR&STORE 2 34 7)               ; APPEND
252   (PUSH)
253   (LOAD&PUSH 1)
254   (CALLSR&PUSH 0 54)                  ; -
257   (LIST&PUSH 1)
259   (CALLSR&STORE 2 34 7)               ; APPEND
263   (SKIP 1)
265   (JMP L880)
268   L268
268   (CONST 2)                           ; 1
269   (JMP L293)
271   L271
271   (CONST 3)                           ; 0
272   (JMP L300)
274   L274
274   (LOAD&PUSH 10)
275   (LOAD&INC&PUSH 2)
277   (CALLS1&PUSH 49)                    ; CHAR
279   (CONST 5)                           ; #\^
280   (EQ)
281   (PUSH)
282   (CONST&PUSH 33)                     ; 256
284   (PUSH-UNBOUND 7)
286   (CONST 34)                          ; BIT
288   (STORE 5)
289   (LOAD&JMPIF 8 L268)
292   (CONST 3)                           ; 0
293   L293
293   (STORE 4)
294   (CALLS1&PUSH 29)                    ; MAKE-ARRAY
296   (LOAD&JMPIF 1 L271)
299   (CONST 2)                           ; 1
300   L300
300   (PUSH)
301   (LOAD&JMPIFNOT 2 L306)
304   (LOAD&INC&STORE 4)
306   L306
306   (LOAD&INC&PUSH 4)
308   (JMP L482)
311   L311
311   (CONST&PUSH 37)                     ; "Invalid range \"~A-~A\".  Ranges must be in acending order"
313   (LOAD&PUSH 15)
314   (LOAD&PUSH 2)
315   (CALLS1&PUSH 49)                    ; CHAR
317   (LOAD&PUSH 16)
318   (CONST&PUSH 6)                      ; 2
319   (LOAD&PUSH 4)
320   (CALLSR&PUSH 2 53)                  ; +
323   (CALLS1&PUSH 49)                    ; CHAR
325   (CALLSR 2 29)                       ; ERROR
328   L328
328   (LOAD&PUSH 14)
329   (LOAD&PUSH 1)
330   (CALLS1&PUSH 49)                    ; CHAR
332   (CALLS1&PUSH 40)                    ; CHAR-CODE
334   (LOAD&PUSH 15)
335   (CONST&PUSH 6)                      ; 2
336   (LOAD&PUSH 3)
337   (CALLSR&PUSH 2 53)                  ; +
340   (CALLS1&PUSH 49)                    ; CHAR
342   (CALLS1&PUSH 40)                    ; CHAR-CODE
344   (CALLSR&JMPIF 1 50 L311)            ; >=
348   (LOAD&PUSH 14)
349   (LOAD&PUSH 1)
350   (CALLS1&PUSH 49)                    ; CHAR
352   (CALLS1&PUSH 40)                    ; CHAR-CODE
354   (JMP L364)
356   L356
356   (LOAD&PUSH 3)
357   (LOAD&PUSH 1)
358   (LOAD&PUSH 4)
359   (CALLSR 1 2)                        ; SYSTEM::STORE
362   (LOAD&INC&STORE 0)
364   L364
364   (LOAD&PUSH 0)
365   (LOAD&PUSH 16)
366   (CONST&PUSH 6)                      ; 2
367   (LOAD&PUSH 4)
368   (CALLSR&PUSH 2 53)                  ; +
371   (CALLS1&PUSH 49)                    ; CHAR
373   (CALLS1&PUSH 40)                    ; CHAR-CODE
375   (CALLSR&JMPIFNOT 1 48 L356)         ; >
379   (CONST&PUSH 6)                      ; 2
380   (LOAD&PUSH 2)
381   (CALLSR&STORE 2 53 1)               ; +
385   (SKIP 1)
387   (JMP L480)
390   L390
390   (LOAD&PUSH 3)
391   (LOAD&PUSH 16)
392   (LOAD&PUSH 3)
393   (CALLS1&PUSH 49)                    ; CHAR
395   (CALLS1&PUSH 40)                    ; CHAR-CODE
397   (LOAD&PUSH 4)
398   (CALLSR 1 2)                        ; SYSTEM::STORE
401   (SKIP 1)
403   (JMP L480)
406   L406
406   (LOAD&PUSH 14)
407   (LOAD&INC&PUSH 1)
409   (CALLS1&PUSH 49)                    ; CHAR
411   (JMPIFNOTEQTO 36 L426)              ; #\-
414   (LOAD&PUSH 14)
415   (CONST&PUSH 6)                      ; 2
416   (LOAD&PUSH 2)
417   (CALLSR&PUSH 2 53)                  ; +
420   (CALLS1&PUSH 49)                    ; CHAR
422   (JMPIFNOTEQTO 35 L328)              ; #\]
426   L426
426   (LOAD&PUSH 14)
427   (LOAD&PUSH 1)
428   (CALLS1&PUSH 49)                    ; CHAR
430   (JMPIFEQTO 35 L480)                 ; #\]
433   (LOAD&PUSH 14)
434   (LOAD&PUSH 1)
435   (CALLS1&PUSH 49)                    ; CHAR
437   (LOAD&PUSH 15)
438   (LOAD&PUSH 2)
439   (CALLS1&PUSH 49)                    ; CHAR
441   (JMPIFNOTEQTO 38 L468)              ; #\\
444   (NIL&PUSH)
445   (LOAD&PUSH 16)
446   (LOAD&PUSH 3)
447   (PUSH-UNBOUND 1)
449   (CALLS2&PUSH 69)                    ; SUBSEQ
451   (LOAD&PUSH 6)
452   (CALL2 39)                          ; REGEX-QUOTED
454   (NV-TO-STACK 2)
456   (POP&STORE 1)
458   (POP&STORE 1)
460   (LOAD&PUSH 2)
461   (LOAD&PUSH 1)
462   (CALLSR&STORE 2 53 2)               ; +
466   (SKIP 1)
468   L468
468   (LOAD&PUSH 0)
469   (CALLS2&JMPIFNOT 35 L390)           ; VECTORP
473   (LOAD&PUSH 3)
474   (LOAD&PUSH 1)
475   (T&PUSH)
476   (CALLS1 13)                         ; BIT-IOR
478   (SKIP 1)
480   L480
480   (LOAD&INC&STORE 0)
482   L482
482   (LOAD&PUSH 14)
483   (LOAD&PUSH 1)
484   (CALLS1&PUSH 49)                    ; CHAR
486   (JMPIFNOTEQTO 35 L406)              ; #\]
490   (LOAD 0)
491   (STORE 5)
492   (SKIP 1)
494   (LOAD&PUSH 9)
495   (CONST&PUSH 40)                     ; LET
497   (CONST&PUSH 41)                     ; RANGE
499   (LOAD&PUSH 4)
500   (LIST&PUSH 2)
502   (LIST&PUSH 1)
504   (CONST 42)                          ; ((IF # #) (IF # # #))
506   (LIST*&PUSH 2)
508   (LIST&PUSH 1)
510   (CALLSR&STORE 2 34 9)               ; APPEND
514   (SKIP 3)
516   (JMP L880)
519   L519
519   (LOAD&PUSH 8)
520   (LOAD 1)
521   (JMP L591)
524   L524
524   (LOAD&PUSH 8)
525   (CONST&PUSH 9)                      ; IF
526   (CONST&PUSH 10)                     ; NOT
527   (CONST&PUSH 43)                     ; AND
529   (CONST&PUSH 44)                     ; (< INDEX LENGTH)
531   (CONST&PUSH 14)                     ; EQL
532   (CONST&PUSH 45)                     ; (CHAR STRING INDEX)
534   (LOAD&PUSH 7)
535   (LIST&PUSH 3)
537   (LIST&PUSH 3)
539   (LIST&PUSH 2)
541   (CONST 46)                          ; (# #)
543   (JMP L587)
545   L545
545   (PUSH-NIL 2)
547   (LOAD&PUSH 12)
548   (LOAD&INC&PUSH 4)
550   (PUSH-UNBOUND 1)
552   (CALLS2&PUSH 69)                    ; SUBSEQ
554   (NIL&PUSH)
555   (CALL2 39)                          ; REGEX-QUOTED
557   (NV-TO-STACK 2)
559   (POP&STORE 2)
561   (POP&STORE 0)
563   (PUSH)
564   (CALLS2&JMPIF 11 L519)              ; LISTP
567   (LOAD&PUSH 0)
568   (CALLS2&JMPIF 28 L524)              ; CHARACTERP
571   (LOAD&PUSH 0)
572   (CALLS2&JMPIFNOT 35 L596)           ; VECTORP
575   (LOAD&PUSH 8)
576   (CONST&PUSH 40)                     ; LET
578   (CONST&PUSH 41)                     ; RANGE
580   (LOAD&PUSH 3)
581   (LIST&PUSH 2)
583   (LIST&PUSH 1)
585   (CONST 47)                          ; ((IF # #) (IF # # #))
587   L587
587   (LIST*&PUSH 2)
589   (LIST 1)
591   L591
591   (PUSH)
592   (CALLSR&STORE 2 34 8)               ; APPEND
596   L596
596   (LOAD&PUSH 3)
597   (LOAD 2)
598   (JMP L873)
601   L601
601   (CONST&PUSH 48)                     ; ""
603   (CONST&PUSH 3)                      ; 0
604   (LOAD&PUSH 12)
605   (CALLS2&PUSH 71)                    ; LENGTH
607   (LOAD&PUSH 4)
608   (CALLSR&PUSH 1 54)                  ; -
611   (JMP L758)
614   L614
614   (POP)
615   (SKIP 2)
617   (JMP L767)
620   L620
620   (CONST 14)                          ; EQL
621   (JMP L634)
623   L623
623   (LOAD&PUSH 8)
624   (CONST&PUSH 9)                      ; IF
625   (CONST&PUSH 10)                     ; NOT
626   (CONST&PUSH 43)                     ; AND
628   (CONST&PUSH 50)                     ; (< INDEX LENGTH)
630   (LOAD&JMPIF 15 L620)
633   (CONST 15)                          ; CHAR-EQUAL
634   L634
634   (PUSH)
635   (CONST&PUSH 51)                     ; (CHAR STRING INDEX)
637   (LOAD&PUSH 9)
638   (LIST&PUSH 3)
640   (LIST&PUSH 3)
642   (LIST&PUSH 2)
644   (CONST 52)                          ; (# #)
646   (LIST*&PUSH 2)
648   (LIST 1)
650   (JMP L862)
653   L653
653   (CONST 60)                          ; STRING=
655   (JMP L824)
658   L658
658   (LOAD&INC&PUSH 1)
660   (LOAD&PUSH 7)
661   (CALLS1&PUSH 148)                   ; NTH
663   (LIST&PUSH 1)
665   (LOAD&PUSH 4)
666   (CALLSR&STORE 2 34 3)               ; APPEND
670   (JMP L950)
673   L673
673   (LOAD&PUSH 0)
674   (LIST&PUSH 1)
676   (LOAD&PUSH 4)
677   (CALLSR&STORE 2 34 3)               ; APPEND
681   (JMP L1031)
684   L684
684   (CONST&PUSH 73)                     ; PROGN
686   (CONST&PUSH 74)                     ; BLOCK
688   (CONST&PUSH 75)                     ; COMPARE
690   (LOAD&INC&PUSH 4)
692   (LOAD&PUSH 10)
693   (CALLS1&PUSH 148)                   ; NTH
695   (LIST&PUSH 3)
697   (CONST 76)                          ; (T)
699   (LIST*&PUSH 2)
701   (LIST&PUSH 1)
703   (LOAD&PUSH 4)
704   (CALLSR 2 34)                       ; APPEND
707   (JMP L1028)
710   L710
710   (LOAD&INC&PUSH 1)
712   (LOAD&PUSH 7)
713   (CALLS1&PUSH 148)                   ; NTH
715   (CALLS2&JMPIF 11 L684)              ; LISTP
718   (GETVALUE&PUSH 69)                  ; *STANDARD-OUTPUT*
720   (CONST&PUSH 77)                     ; #<COMPILED-CLOSURE REGEX-COMPILE-2>
722   (CALL2 71)                          ; FORMAT
724   (JMP L1031)
727   L727
727   (LOAD&PUSH 13)
728   (LOAD&PUSH 5)
729   (LOAD&PUSH 3)
730   (CALLSR&PUSH 2 53)                  ; +
733   (CALLS1&PUSH 49)                    ; CHAR
735   (LOAD&PUSH 0)
736   (GETVALUE&PUSH 8)                   ; *REGEX-SPECIAL-CHARS*
738   (PUSH-UNBOUND 6)
740   (CALLS2&JMPIF 95 L614)              ; POSITION
744   (CONST&PUSH 49)                     ; STRING
746   (LOAD&PUSH 4)
747   (LOAD&PUSH 2)
748   (CALLS1&PUSH 75)                    ; STRING
750   (CALLSR&STORE 2 37 3)               ; CONCATENATE
754   (SKIP 1)
756   (LOAD&INC&STORE 1)
758   L758
758   (LOAD&PUSH 1)
759   (LOAD&PUSH 1)
760   (CALLSR&JMPIFNOT 1 50 L727)         ; >=
764   (NIL)
765   (SKIP 2)
767   L767
767   (PUSH)
768   (LOAD&PUSH 1)
769   (CALLS2&PUSH 71)                    ; LENGTH
771   (CONST&PUSH 2)                      ; 1
772   (CALLSR&JMPIF 1 45 L623)            ; =
777   (LOAD&PUSH 0)
778   (JMPIFEQTO 53 L785)                 ; #\*
781   (LOAD&PUSH 0)
782   (JMPIFNOTEQTO 54 L795)              ; #\+
785   L785
785   (LOAD&PUSH 1)
786   (CONST&PUSH 3)                      ; 0
787   (LOAD&PUSH 3)
788   (CALLS2&PUSH 71)                    ; LENGTH
790   (CALLS2&PUSH 151)                   ; 1-
792   (CALLS2&STORE 69 1)                 ; SUBSEQ
795   L795
795   (LOAD&PUSH 8)
796   (CONST&PUSH 9)                      ; IF
797   (CONST&PUSH 55)                     ; <
799   (CONST&PUSH 56)                     ; LENGTH
801   (CONST&PUSH 57)                     ; +
803   (CONST&PUSH 58)                     ; INDEX
805   (LOAD&PUSH 7)
806   (CALLS2&PUSH 71)                    ; LENGTH
808   (LIST&PUSH 3)
810   (LIST&PUSH 3)
812   (CONST 59)                          ; ((RETURN-FROM COMPARE NIL))
814   (LIST*&PUSH 2)
816   (CONST&PUSH 9)                      ; IF
817   (CONST&PUSH 10)                     ; NOT
818   (LOAD&JMPIF 14 L653)
822   (CONST 61)                          ; STRING-EQUAL
824   L824
824   (PUSH)
825   (CONST&PUSH 49)                     ; STRING
827   (LOAD&PUSH 7)
828   (CONST&PUSH 62)                     ; :START1
830   (CONST&PUSH 58)                     ; INDEX
832   (CONST&PUSH 63)                     ; :END1
834   (CONST&PUSH 57)                     ; +
836   (CONST&PUSH 58)                     ; INDEX
838   (LOAD&PUSH 13)
839   (CALLS2&PUSH 71)                    ; LENGTH
841   (LIST&PUSH 3)
843   (LIST&PUSH 7)
845   (LIST&PUSH 2)
847   (CONST&PUSH 64)                     ; (RETURN-FROM COMPARE NIL)
849   (CONST&PUSH 65)                     ; INCF
851   (CONST&PUSH 58)                     ; INDEX
853   (LOAD&PUSH 8)
854   (CALLS2&PUSH 71)                    ; LENGTH
856   (LIST&PUSH 3)
858   (LIST&PUSH 4)
860   (LIST 2)
862   L862
862   (PUSH)
863   (CALLSR&STORE 2 34 8)               ; APPEND
867   (LOAD&PUSH 3)
868   (LOAD&PUSH 2)
869   (CALLS2&PUSH 71)                    ; LENGTH
871   (CALLS2 151)                        ; 1-
873   L873
873   (PUSH)
874   (CALLSR&STORE 2 53 3)               ; +
878   (SKIP 2)
880   L880
880   (SKIP 1)
882   (LOAD&INC&STORE 0)
884   L884
884   (LOAD&PUSH 0)
885   (LOAD&PUSH 10)
886   (CALLS2&PUSH 71)                    ; LENGTH
888   (CALLSR&JMPIFNOT 1 45 L142)         ; =
893   (SKIP 1)
895   (LOAD&PUSH 4)
896   (CONST&PUSH 66)                     ; ((SETF (CADR #) INDEX))
898   (CALLSR&STORE 2 34 4)               ; APPEND
902   (PUSH)
903   (CONST&PUSH 67)                     ; ((RETURN-FROM FINAL-RETURN T))
905   (CALLSR&STORE 2 34 4)               ; APPEND
909   (NIL&PUSH)
910   (CALLS1&STORE 161 1)                ; COPY-TREE
913   (LOAD&PUSH 4)
914   (CALLS2&STORE 72 4)                 ; REVERSE
917   (CONST&PUSH 3)                      ; 0
918   L918
918   (LOAD&PUSH 0)
919   (LOAD&PUSH 6)
920   (CALLS2&PUSH 71)                    ; LENGTH
922   (CALLSR&JMPIF 1 50 L1072)           ; >=
927   (LOAD&PUSH 0)
928   (LOAD&PUSH 6)
929   (CALLS1&PUSH 148)                   ; NTH
931   (LOAD&PUSH 0)
932   (JMPIFNOTEQTO 68 L950)              ; PLUS
935   (LOAD&INC&PUSH 1)
937   (LOAD&PUSH 7)
938   (CALLS1&PUSH 148)                   ; NTH
940   (CALLS2&JMPIF 11 L658)              ; LISTP
944   (GETVALUE&PUSH 69)                  ; *STANDARD-OUTPUT*
946   (CONST&PUSH 70)                     ; #<COMPILED-CLOSURE REGEX-COMPILE-1>
948   (CALL2 71)                          ; FORMAT
950   L950
950   (LOAD&PUSH 0)
951   (CALLS2&JMPIF 11 L673)              ; LISTP
955   (LOAD&PUSH 0)
956   (JMPIFEQTO 72 L710)                 ; QUESTION
960   (LOAD&PUSH 0)
961   (JMPIFEQTO 78 L968)                 ; ASTRISK
964   (LOAD&PUSH 0)
965   (JMPIFNOTEQTO 68 L1031)             ; PLUS
968   L968
968   (LOAD&INC&PUSH 1)
970   (LOAD&PUSH 7)
971   (CALLS1&PUSH 148)                   ; NTH
973   (CALLS2&JMPIFNOT 11 L1031)          ; LISTP
976   (CONST&PUSH 40)                     ; LET
978   (CONST&PUSH 79)                     ; ((OINDEX INDEX))
980   (CONST&PUSH 80)                     ; (DECLARE (FIXNUM OINDEX))
982   (CONST&PUSH 74)                     ; BLOCK
984   (CONST&PUSH 75)                     ; COMPARE
986   (CONST&PUSH 11)                     ; DO
987   (NIL&PUSH)
988   (CONST&PUSH 81)                     ; (NIL)
990   (LOAD&INC&PUSH 9)
992   (LOAD&PUSH 15)
993   (CALLS1&PUSH 148)                   ; NTH
995   (LIST&PUSH 4)
997   (LIST&PUSH 3)
999   (CONST&PUSH 11)                     ; DO
1000  (CONST&PUSH 82)                     ; ((START INDEX (1- START)))
1002  (CONST&PUSH 83)                     ; ((< START OINDEX) NIL)
1004  (CONST&PUSH 84)                     ; (DECLARE (FIXNUM START))
1006  (CONST&PUSH 40)                     ; LET
1008  (CONST&PUSH 85)                     ; ((INDEX START))
1010  (CONST&PUSH 86)                     ; (DECLARE (FIXNUM INDEX))
1012  (CONST&PUSH 74)                     ; BLOCK
1014  (CONST&PUSH 75)                     ; COMPARE
1016  (LOAD 16)
1018  (LIST*&PUSH 2)
1020  (LIST&PUSH 4)
1022  (LIST&PUSH 5)
1024  (LIST&PUSH 5)
1026  (LIST 1)
1028  L1028
1028  (STORE 3)
1029  (LOAD&INC&STORE 1)
1031  L1031
1031  (SKIP 1)
1033  (LOAD&INC&STORE 0)
1035  (JMP L918)
1038  L1038
1038  (CONST&PUSH 87)                     ; LAMBDA
1040  (CONST&PUSH 88)                     ; (STRING &KEY (START 0) ...)
1042  (CONST&PUSH 89)                     ; (DECLARE (STRING STRING) ...)
1044  (CONST&PUSH 27)                     ; SETF
1045  (CONST&PUSH 90)                     ; *REGEX-GROUPINGS*
1047  (LOAD&PUSH 8)
1048  (LIST&PUSH 3)
1050  (CONST&PUSH 74)                     ; BLOCK
1052  (CONST&PUSH 91)                     ; FINAL-RETURN
1054  (CONST&PUSH 74)                     ; BLOCK
1056  (CONST&PUSH 75)                     ; COMPARE
1058  (CONST&PUSH 40)                     ; LET
1060  (CONST&PUSH 92)                     ; ((INDEX START) (LENGTH END))
1062  (CONST&PUSH 93)                     ; (DECLARE (FIXNUM INDEX LENGTH))
1064  (LOAD 12)
1065  (LIST*&PUSH 3)
1067  (LIST 3)
1069  (JMP L1137)
1072  L1072
1072  (SKIP 1)
1074  (LOAD&JMPIF 7 L1038)
1077  (CONST&PUSH 87)                     ; LAMBDA
1079  (CONST&PUSH 94)                     ; (STRING &KEY (START 0) ...)
1081  (CONST&PUSH 95)                     ; (DECLARE (STRING STRING) ...)
1083  (CONST&PUSH 27)                     ; SETF
1084  (CONST&PUSH 90)                     ; *REGEX-GROUPINGS*
1086  (LOAD&PUSH 8)
1087  (LIST&PUSH 3)
1089  (CONST&PUSH 74)                     ; BLOCK
1091  (CONST&PUSH 91)                     ; FINAL-RETURN
1093  (CONST&PUSH 40)                     ; LET
1095  (CONST&PUSH 96)                     ; ((LENGTH END))
1097  (CONST&PUSH 97)                     ; (DECLARE (FIXNUM LENGTH))
1099  (LOAD&PUSH 9)
1100  (CONST&PUSH 11)                     ; DO
1101  (CONST&PUSH 98)                     ; ((MARKER START (1+ MARKER)))
1103  (CONST&PUSH 99)                     ; ((> MARKER END) NIL)
1105  (CONST&PUSH 100)                    ; (DECLARE (FIXNUM MARKER))
1107  (CONST&PUSH 40)                     ; LET
1109  (CONST&PUSH 101)                    ; ((INDEX MARKER))
1111  (CONST&PUSH 102)                    ; (DECLARE (FIXNUM INDEX))
1113  (CONST&PUSH 9)                      ; IF
1114  (CONST&PUSH 74)                     ; BLOCK
1116  (CONST&PUSH 75)                     ; COMPARE
1118  (LOAD 21)
1120  (LIST*&PUSH 2)
1122  (CONST 103)                         ; ((RETURN T))
1124  (LIST*&PUSH 2)
1126  (LIST&PUSH 4)
1128  (LIST&PUSH 5)
1130  (LIST&PUSH 1)
1132  (CALLSR 2 34)                       ; APPEND
1135  (LIST* 3)
1137  L1137
1137  (PUSH)
1138  (LIST&PUSH 3)
1140  (LIST 5)
1142  (SKIP&RET 9)


Disassembly of function REGEX-COMPILE-1
(CONST 0) = 
"GROUP repeat hasn't been implemented yet
"
1 required argument
0 optional arguments
Rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; "GROUP repeat hasn't been implemented yet
"
1     (LOAD&PUSH 3)
2     (PUSH-UNBOUND 2)
4     (CALLS1 137)                        ; WRITE-STRING
6     (LOAD 1)
7     (SKIP&RET 3)


Disassembly of function REGEX-COMPILE-2
(CONST 0) = 
"Optional groups not implemented yet
"
1 required argument
0 optional arguments
Rest parameter
No keyword parameters
6 byte-code instructions:
0     (CONST&PUSH 0)                      ; "Optional groups not implemented yet
"
1     (LOAD&PUSH 3)
2     (PUSH-UNBOUND 2)
4     (CALLS1 137)                        ; WRITE-STRING
6     (LOAD 1)
7     (SKIP&RET 3)


Disassembly of function #:|(DEFUN REGEX-QUOTED (CHAR-STRING &OPTIONAL #) ...)-8|
(CONST 0) = REGEX-QUOTED
(CONST 1) = SYSTEM::REMOVE-OLD-DEFINITIONS
(CONST 2) = FUNCTION
(CONST 3) = 
"Usage: (regex-quoted <char-string> &optional invert)
       Returns either the quoted character or a simple bit vector of bits set for
       the matching values"
(CONST 4) = SYSTEM::%SET-DOCUMENTATION
(CONST 5) = #<COMPILED-CLOSURE REGEX-QUOTED>
0 required arguments
0 optional arguments
No rest parameter
No keyword parameters
11 byte-code instructions:
0     (CONST&PUSH 0)                      ; REGEX-QUOTED
1     (CALL1 1)                           ; SYSTEM::REMOVE-OLD-DEFINITIONS
3     (CONST&PUSH 0)                      ; REGEX-QUOTED
4     (CONST&PUSH 2)                      ; FUNCTION
5     (CONST&PUSH 3)                      ; "Usage: (regex-quoted <char-string> &optional invert)
       Returns either the quoted character or a simple bit vector of bits set for
       the matching values"
6     (CALL 3 4)                          ; SYSTEM::%SET-DOCUMENTATION
9     (CONST&PUSH 0)                      ; REGEX-QUOTED
10    (CONST&PUSH 5)                      ; #<COMPILED-CLOSURE REGEX-QUOTED>
11    (CALLS2 130)                        ; SYSTEM::%PUTD
13    (CONST 0)                           ; REGEX-QUOTED
14    (SKIP&RET 1)


Disassembly of function REGEX-QUOTED
(CONST 0) = 0
(CONST 1) = 1
(CONST 2) = #\n
(CONST 3) = #\Newline
(CONST 4) = #\c
(CONST 5) = #\Return
(CONST 6) = #\t
(CONST 7) = #\Tab
(CONST 8) = #\d
(CONST 9) = #*0000000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
(CONST 10) = #\D
(CONST 11) = #*1111111111111111111111111111111111111111111111110000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
(CONST 12) = #\w
(CONST 13) = #*0000000000000000000000000000000000000000000000001111111111000000011111111111111111111111111000010111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
(CONST 14) = #\W
(CONST 15) = #*1111111111111111111111111111111111111111111111110000000000111111100000000000000000000000000111101000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
(CONST 16) = #\b
(CONST 17) = #*0000000001000000000000000000000011000000000010100000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
(CONST 18) = #\B
(CONST 19) = #*1111111110111111111111111111111100111111111101011111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
(CONST 20) = #\s
(CONST 21) = #*0000000001100000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
(CONST 22) = #\S
(CONST 23) = #*1111111110011111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
(CONST 24) = 48
(CONST 25) = 57
(CONST 26) = 2
(CONST 27) = 8
(CONST 28) = 3
(CONST 29) = LET
(CONST 30) = NSTRING
(CONST 31) = SUBSEQ
(CONST 32) = STRING
(CONST 33) = CAR
(CONST 34) = AREF
(CONST 35) = *REGEX-GROUPS*
(CONST 36) = CADR
(CONST 37) = 
((IF (< LENGTH (+ INDEX (LENGTH NSTRING))) (RETURN-FROM COMPARE NIL))
 (IF
  (NOT (STRING= STRING NSTRING :START1 INDEX :END1 (+ INDEX (LENGTH NSTRING))))
  (RETURN-FROM COMPARE NIL) (INCF INDEX (LENGTH NSTRING))))
(CONST 38) = #*1111111110011111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1 required argument
1 optional argument
No rest parameter
No keyword parameters
183 byte-code instructions:
0     (UNBOUND->NIL 1)
2     (LOAD&PUSH 2)
3     (CONST&PUSH 0)                      ; 0
4     (CALLS1&PUSH 49)                    ; CHAR
6     (LOAD&PUSH 3)
7     (CONST&PUSH 0)                      ; 0
8     (CALLS1&PUSH 49)                    ; CHAR
10    (CONST&PUSH 1)                      ; 1
11    (LOAD&PUSH 2)
12    (JMPIFEQTO 2 L104)                  ; #\n
16    (LOAD&PUSH 2)
17    (JMPIFEQTO 4 L108)                  ; #\c
21    (LOAD&PUSH 2)
22    (JMPIFEQTO 6 L112)                  ; #\t
26    (LOAD&PUSH 2)
27    (JMPIFEQTO 8 L116)                  ; #\d
31    (LOAD&PUSH 2)
32    (JMPIFEQTO 10 L120)                 ; #\D
36    (LOAD&PUSH 2)
37    (JMPIFEQTO 12 L124)                 ; #\w
41    (LOAD&PUSH 2)
42    (JMPIFEQTO 14 L128)                 ; #\W
46    (LOAD&PUSH 2)
47    (JMPIFEQTO 16 L132)                 ; #\b
51    (LOAD&PUSH 2)
52    (JMPIFEQTO 18 L136)                 ; #\B
56    (LOAD&PUSH 2)
57    (JMPIFEQTO 20 L140)                 ; #\s
61    (LOAD&PUSH 2)
62    (JMPIFEQTO 22 L145)                 ; #\S
66    (LOAD&PUSH 2)
67    (CALLS1&PUSH 40)                    ; CHAR-CODE
69    (CONST&PUSH 24)                     ; 48
70    (CALLSR&JMPIFNOT 1 50 L83)          ; >=
74    (LOAD&PUSH 2)
75    (CALLS1&PUSH 40)                    ; CHAR-CODE
77    (CONST&PUSH 25)                     ; 57
78    (CALLSR&JMPIF 1 49 L192)            ; <=
83    L83
83    (LOAD 2)
84    (STORE 1)
85    L85
85    (LOAD&PUSH 1)
86    (CALLS2&JMPIFNOT 35 L98)            ; VECTORP
89    (LOAD&JMPIFNOT 4 L98)
92    (LOAD&PUSH 1)
93    (CONST&PUSH 38)                     ; #*1111111110011111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
95    (T&PUSH)
96    (CALLS1 14)                         ; BIT-XOR
98    L98
98    (LOAD&PUSH 1)
99    (LOAD&PUSH 1)
100   (STACK-TO-MV 2)
102   (SKIP&RET 6)
104   L104
104   (CONST 3)                           ; #\Newline
105   (STORE 1)
106   (JMP L85)
108   L108
108   (CONST 5)                           ; #\Return
109   (STORE 1)
110   (JMP L85)
112   L112
112   (CONST 7)                           ; #\Tab
113   (STORE 1)
114   (JMP L85)
116   L116
116   (CONST 9)                           ; #*0000000000000000000000000000000000000000000000001111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
117   (STORE 1)
118   (JMP L85)
120   L120
120   (CONST 11)                          ; #*1111111111111111111111111111111111111111111111110000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
121   (STORE 1)
122   (JMP L85)
124   L124
124   (CONST 13)                          ; #*0000000000000000000000000000000000000000000000001111111111000000011111111111111111111111111000010111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
125   (STORE 1)
126   (JMP L85)
128   L128
128   (CONST 15)                          ; #*1111111111111111111111111111111111111111111111110000000000111111100000000000000000000000000111101000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
129   (STORE 1)
130   (JMP L85)
132   L132
132   (CONST 17)                          ; #*0000000001000000000000000000000011000000000010100000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
133   (STORE 1)
134   (JMP L85)
136   L136
136   (CONST 19)                          ; #*1111111110111111111111111111111100111111111101011111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
137   (STORE 1)
138   (JMP L85)
140   L140
140   (CONST 21)                          ; #*0000000001100000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
142   (STORE 1)
143   (JMP L85)
145   L145
145   (CONST 23)                          ; #*1111111110011111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
147   (STORE 1)
148   (JMP L85)
151   L151
151   (CONST&PUSH 0)                      ; 0
152   (CONST&PUSH 0)                      ; 0
153   (JMP L176)
155   L155
155   (CONST&PUSH 27)                     ; 8
156   (LOAD&PUSH 1)
157   (CALLSR&PUSH 2 55)                  ; *
160   (LOAD&PUSH 8)
161   (LOAD&PUSH 3)
162   (CALLS1&PUSH 49)                    ; CHAR
164   (CALLS1&PUSH 40)                    ; CHAR-CODE
166   (CONST&PUSH 24)                     ; 48
167   (CALLSR&PUSH 1 54)                  ; -
170   (CALLSR&STORE 2 53 0)               ; +
174   (LOAD&INC&STORE 1)
176   L176
176   (LOAD&PUSH 1)
177   (CONST&PUSH 26)                     ; 2
178   (CALLSR&JMPIFNOT 1 45 L155)         ; =
182   (POP)
183   (SKIP 1)
185   (STORE 1)
186   (CONST 28)                          ; 3
188   (STORE 0)
189   (JMP L85)
192   L192
192   (LOAD&PUSH 5)
193   (CALLS2&PUSH 71)                    ; LENGTH
195   (CONST&PUSH 26)                     ; 2
196   (CALLSR&JMPIFNOT 1 48 L245)         ; >
200   (LOAD&PUSH 5)
201   (CONST&PUSH 1)                      ; 1
202   (CALLS1&PUSH 49)                    ; CHAR
204   (CALLS1&PUSH 40)                    ; CHAR-CODE
206   (CONST&PUSH 24)                     ; 48
207   (CALLSR&JMPIFNOT 1 50 L245)         ; >=
211   (LOAD&PUSH 5)
212   (CONST&PUSH 1)                      ; 1
213   (CALLS1&PUSH 49)                    ; CHAR
215   (CALLS1&PUSH 40)                    ; CHAR-CODE
217   (CONST&PUSH 25)                     ; 57
218   (CALLSR&JMPIFNOT 1 49 L245)         ; <=
222   (LOAD&PUSH 5)
223   (CONST&PUSH 26)                     ; 2
224   (CALLS1&PUSH 49)                    ; CHAR
226   (CALLS1&PUSH 40)                    ; CHAR-CODE
228   (CONST&PUSH 24)                     ; 48
229   (CALLSR&JMPIFNOT 1 50 L245)         ; >=
233   (LOAD&PUSH 5)
234   (CONST&PUSH 26)                     ; 2
235   (CALLS1&PUSH 49)                    ; CHAR
237   (CALLS1&PUSH 40)                    ; CHAR-CODE
239   (CONST&PUSH 25)                     ; 57
240   (CALLSR&JMPIF 1 49 L151)            ; <=
245   L245
245   (LOAD&PUSH 2)
246   (CALLS1&PUSH 40)                    ; CHAR-CODE
248   (CONST&PUSH 24)                     ; 48
249   (CALLSR&PUSH 1 54)                  ; -
252   (CONST&PUSH 29)                     ; LET
253   (CONST&PUSH 30)                     ; NSTRING
255   (CONST&PUSH 31)                     ; SUBSEQ
257   (CONST&PUSH 32)                     ; STRING
259   (CONST&PUSH 33)                     ; CAR
261   (CONST&PUSH 34)                     ; AREF
263   (CONST&PUSH 35)                     ; *REGEX-GROUPS*
265   (LOAD&PUSH 7)
266   (LIST&PUSH 3)
268   (LIST&PUSH 2)
270   (CONST&PUSH 36)                     ; CADR
272   (CONST&PUSH 34)                     ; AREF
274   (CONST&PUSH 35)                     ; *REGEX-GROUPS*
276   (LOAD&PUSH 8)
277   (LIST&PUSH 3)
279   (LIST&PUSH 2)
281   (LIST&PUSH 4)
283   (LIST&PUSH 2)
285   (LIST&PUSH 1)
287   (CONST 37)                          ; ((IF # #) (IF # # #))
289   (LIST*&PUSH 2)
291   (LIST 1)
293   (STORE 2)
294   (SKIP 1)
296   (JMP L85)


Wrote file binary-clisp/nregex.fas
Wrote file /cygdrive/e/temp/maxima/src/nregex.lis