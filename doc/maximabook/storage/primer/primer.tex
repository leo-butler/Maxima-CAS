\label{primer}
\section{Introduction}

\Max\ (pronounced \maxp\footnote{The acronym was adopted for the open-source version of \Max\ is the corruption of the main project name MACSYMA, which  stands for Project MAC's 
SYmbolic MAnipulation System. {\it MAC} itself is an acronym, usually 
cited as meaning Man and Computer or Machine Aided Cognition. The
Laboratory for Computer Science at the Massachusetts Institute of Technology
was known as Project MAC during the initial development of MACSYMA.})
is a large computer program designed for the manipulation
of algebraic expressions. You can use \Max\
for manipulation of algebraic expressions involving
constants, variables, and functions. It can
differentiate, integrate, take limits, solve equations,
factor polynomials, expand functions in power series, solve differential 
equations in closed form, generate fortran programs and perform many other
operations.  It also has a programming language that you can use to 
extend \Max's capabilities to new domains.

If you are new to computer-aided algebraic manipulation, you will be surprised 
at how easy it is to start using maxima.  The explanations and examples in this
book will help you take full advantage of Maxima's features. 

A few of the system's most-used capabilities are described in
this chapter.  A more complete discussion of these features and others
for more specialized interests may be found in the Macsyma Reference 
Manual~\cite{macsyma-ref}.
Additionally, information about each command is 
available through an on-line documentation retrieval command, {\tt describe}.
To see a blurb on, for example, {\tt expand}, type {\tt describe(expand)};
to the system. For some commands, an {\tt example} is also available, 
and can be viewed by typing, for instance, {\tt example(expand);}

\section{Starting Up}

On any UNIX systems, the system may be loaded by typing {\tt maxima}
to the shell prompt. It may be necessary to type 
\hbox{\verb|/usr/local/bin/maxima|}
or some similar pathname on your system.
Your computer system manager should know where the program is
installed.
If you expect to be using \Max\ frequently, you should
include in your {\tt .login} script, a line setting the system variable \Max\
to the home directory for \Max\ documentation and programs.  For example,
\begin{verbatim}
setenv MACSYMA /usr/local/maxima
\end{verbatim}
If you are just starting to use \Max\
now, you could just type this in now. (This assume you are using the
usual {\it C-shell} command-line interpreter.)
A few seconds after typing {\tt maxima}, the system will return with a 
heading and prompt resembling the text below.
{\footnotesize \begin{verbatim}
% maxima
GCL (GNU Common Lisp)  Version(2.3) Wed Mar 29 19:06:31 PST 2000
Licensed under GNU Library General Public License
Contains Enhancements by W. Schelter
Maxima 5.4 Wed Mar 29 12:48:45 PST 2000 (with enhancements by W. Schelter).
Licensed under the GNU Public License (see file COPYING)
(C1)              
\end{verbatim}}
The number 5.4 is a version identification number which will change
from time to time, as will the day and date of the system construction.
The label (C1) is a name being assigned
automatically to your first command. (C labels are used for user-input
commands, D-labels for
\Max\
output expressions.)

\section{Typing Expressions}

Suppose you wanted to work with the expression $(x + 1)^3$. You
could type it in by using Fortran-style syntax as follows:
\begin{verbatim}
(c1) (x+1)**3;
\end{verbatim}
The {\tt ;} and the (invisible) {\tt carriage return} terminates your command, 
and prompts \Max\
to evaluate your expression, simplify it, and display the result.
The character {\tt \$} may also be used to end a command line, in which
case the result will be computed but not displayed.

In this case of command {\tt c1} above, the evaluation and simplification 
processes leave the expression unchanged, and \Max\ responds with the display 
below.
\begin{verbatim}
                                          3
(d1)                               (x + 1)

(c2)
\end{verbatim}

Note that the expression is normally printed in a two-dimensional
format with raised superscripts.  This usually makes the expression
easier to understand than a linear format, although as you will see in later displays,
it sometimes requires some effort.
There is a more readable (but slower) typesetting display facility which
requires more a elaborate computer terminal than the usual character-display
type.

The result is assigned a label {\tt d1} which may be used
in subsequent commands. An important observation: the system is assigning
values to the names {\tt c1}, {\tt d1}, etc.  You should avoid using these same names
for other purposes in your computations.

If you choose to leave \Max\ at this point, or any time a {\tt c-line}
prompt appears, type {\tt  quit();}.
If you wish to stop in the midst of a computation and quit in a less orderly fashion, type
Ctrl--z (that's one character), to get back to the UNIX shell, and {\tt  kill \%}.

After the display, \Max\ prompts you with the next line label, {\tt c2}.

\section{Your Next Command}

One of the many commands available in \Max\ is the {\tt expand}
command, which converts an expression to
an mathematically equivalent one, but with certain changes in the form.
Most commands have the form of a {\it function} being applied to
some arguments.  In this case, the expression labelled {\tt d1}
above is the single argument to {\tt expand}.
\begin{verbatim}
(c2) expand(d1);
                               3      2
(d2)                          x  + 3 x  + 3 x + 1
\end{verbatim}

\section{Typing Errors}

Before getting too involved, you should realize
that if you make a mistake in typing, you can delete erroneous
characters by using your standard UNIX erase, kill, word-kill, etc. characters.
(Typically these are backspace, Ctrl--U, Ctrl--W, respectively)
If you wish to delete all lines of a multi-line command, typing {\tt ??}
will give you a freshly re-typed line label.

If you make a mistake but type the semi-colon and return before you notice,
the system will provide a message:
\begin{verbatim}
(c2) expand((d1);

expand (( d1) ***\$***
syntax error
please rephrase or edit.
(c2)
\end{verbatim}
If you are a novice at using the computer, you should probably
retype the expression.  Editing involves the use of one of the system
text editors, and is described in the manual.

\section{More Commands}

Let us consider a few additional commands and facilities.  To differentiate 
an expression, use the {\tt diff} command.  {\tt diff(expr,var)} 
differentiates an expression with respect to the variable {\tt var}. 
\begin{verbatim}
(c3) sin(x)*cos(x);
(d3)                             cos(x) sin(x)

(c4) diff(%,x);
                                  2         2
(d4)                           cos (x) - sin (x)
\end{verbatim}

Note the use of the symbol {\tt \%} in line {\tt c4}.  This symbol is a 
shorthand for the previous expression computed, which in this case is {\tt d3}.

To differentiate an expression twice, use {\tt diff(expr,var,2)}.
\begin{verbatim}
(c5) diff(d3,x,2);
(d5)                           - 4 cos(x) sin(x)
\end{verbatim}
The concept of differentiation is actually a good deal more general than is
illustrated by this example.  Application of the chain rule is generally supported, and
a large repertoire of built-in functions and operations are provided.

\section{Substitution}

There are a number of ways of producing a new expression from an
old one by substitution.
For example, to substitute $x^2 $ for every occurrence of $z$ in
the expression $ z e^z $ you could type
\begin{verbatim}
(c6) z*%e**z;
                                         z
(d6)                                 z %e

(c7) d6,z=x**2;
                                          2
                                     2   x
(d7)                                x  %e
\end{verbatim}
In \Max\, the base of the natural logarithms is written {\tt \%e}, to 
distinguish it from a simple variable named {\tt e}. $ \sqrt{-1}$ is written 
as {\tt \%i} and $\pi $ is written {\tt \%pi.}

An alternative syntax for exactly the same command as that on line {\tt c7}
is to explicitly invoke the {\tt ev} command (for evaluation in a context
where $ z = x^2 $ ).
\begin{verbatim}
(c8) ev(d6,z=x**2);
                                          2
                                     2   x
(d8)                                x  %e
\end{verbatim}

The {\tt ev} command has more elaborate options and uses. {\tt Ev} 
{\it evaluates} the first expression (leftmost argument) in an environment 
specified by the additional expressions which are either equations as shown 
above, or built-in {\it switches} which control \Max\ .

An equivalent command in this particular case, is {\tt substitute},
which is limited to the simpler semantics we use.  You can abbreviate
the command as {\tt subst}: 
\begin{verbatim}
(c9) subst(x**2,z,d6);
                                          2
                                     2   x
(d9)                                x  %e
\end{verbatim}
Note the order of arguments to {\tt substitute}: substitute {\tt a} for 
{\tt b} in {\tt c} is written {\tt subst(a,b,c);} .

\section{Assignments}

Although some very sophisticated linguistic facilities are available in \Max\,
we will describe only a few of the basic features in this chapter.
Assignment is very familiar to programmers, and associates a {\it value}
with a name.

To assign a value to a variable, used a colon (:) as follows:
\begin{verbatim}
(c10) a:%;
                                          2
                                     2   x
(d10)                               x  %e

(c11) a+1;
                                        2
                                   2   x
(d11)                             x  %e   + 1
\end{verbatim}

Many users are surprised when such values are
used when they themselves have forgotten the existence of such
assignments and reuse the same name as an {\it indeterminate}.
To {\it unassign} a value from {\tt a}, say:
\begin{verbatim}
(c12) kill(a);
(d12)                                done
\end{verbatim}
Now if you ask for the value of {\tt a}, you get:
\begin{verbatim}
(c13) a;
(d13)                                  a
\end{verbatim}

\section{Defining Functions}
Function definition in Macsyma  is a way of storing computational routines to b
e used repeatedly.
Functions in Macsyma always return values and can therefore be used in expressio
ns.
Sometimes it is convenient to think of functions in Macsyma  or other programmin
g languages as similar to mathematical functions.
Although we can also ask Macsyma to compute a number approximating sin(0.5), tha
t is not where it ends.
When you use Macsyma there is a real possibility that you might really mean a ma
thematical function rather than merely  the ``computing rule associating a numbe
r with some input.'' For example, in Macsyma you can find solutions to equations
 involving the sine  function (named sin), or you might expect  sin in the answe
r to a differentiation problem, etc.
Nevertheless, we will abuse the term function to describe these computational ro
utines.

The process of function definition is similar to assignment, but associates
{\it parameters} or {\it arguments} with the name, and associates
a computation with the use of the name: the value which is produced is
basically the result of substituting values with names in
the associated expression.
For example,
to define a function $f ( z )$ which will be, essentially, a short-hand for
$\sin^2 z + 1 $ you use {\it :=} as follows:
\begin{verbatim}
(c14) f(z) := sin(z)**2+1;
                                         2
(d14)                         f(z) := sin (z) + 1

(c15) f(x+1);
                                   2
(d15)                           sin (x + 1) + 1
\end{verbatim}
It is possible to define functions which use any of
the built-in
\Max\
commands, or use user-defined functions.
Although we have illustrated only a few simple built-in commands,
\Max\
provides you with a
complete programming language. 
This may not be a comfort to you if you are totally unfamiliar with
programming, but if you want to use 
\Max\
for elaborate processing of mathematical equations or data,
you may have to learn some of this.  
If you have some familiarity with some conventional programming
languages, you may be pleasantly surprised by the additional
generality afforded by {\it symbolic} computation.
Further on Chapter~\ref{prog-lang}
we give some examples of the language of \Max.

If you type a command such as {\tt g(z)}, where {\tt g}  is otherwise
undefined, \Max\ will treat it as an {\it unknown} function, similar to 
an indeterminate.

\section{Equations, Parts, and Solve}

Sometimes it is convenient to compute with equations in
\Max.
An equation is not the same as an assignment, a function definition, or
a test for equality.  Some programming languages overuse the symbol
{\it =} for some of these, but
\Max\
does not.
In
\Max\, 
an equation is just an expression containing two subexpressions separated
by an {\it =}.
Certain simplification and evaluation operations are defined
to work in (usually) conventional ways on equations,
as illustrated below.  Line {\tt c16}
shows how to type in an equation.
\begin{verbatim}
(c16) x**2+2*x=y**2;
                                  2          2
(d16)                            x  + 2 x = y
(c17) d16+1;
                              2              2
(d17)                        x  + 2 x + 1 = y  + 1
\end{verbatim}
The left-hand-side of an equation can be selected with the {\tt lhs}
command,
or by the more general {\tt part}
command which can be used to pick apart
expressions such as sums, products, etc.
\begin{verbatim}
(c18) lhs(%);
                                  2
(d18)                            x  + 2 x + 1

(c19) part(d17,2);
                                     2
(d19)                               y  + 1

(c20) part(%,1);
                                       2
(d20)                                 y

\end{verbatim}
To save typing, the same result as {\tt d20}
could have been obtained from 
{\tt part(part(d17,2),1)}
or even more simply, {\tt part(d17,2,1)}.

Equations are used by some commands, and are, for example,
used by the {\tt solve}
command. They are returned in a {\tt list}, that
is, a sequence separated by commas and enclosed in square brackets:
\begin{verbatim}
(c21) x**2-1;
                                     2
(d21)                               x  - 1

(c22) solve(%,x);
(d22)                          [x = - 1, x = 1]
\end{verbatim}
Notice the way the list of the two solutions is displayed.  We can substitute
the first of the two answers in {\tt d21}, and evaluate:
\begin{verbatim}
(c23) d21,part(%,1);
(d23)                                  0
\end{verbatim}

\section{Sums, Programs, Ev revisited}

The sum of the first five positive integers, squared, can be computed by:
\begin{verbatim}
(c24) sum(i**2,i,1,5);
(d24)                                 55
\end{verbatim}
Another way of providing a similar result by writing a small program,
is to use a {\tt for}
statement.
\begin{verbatim}
(c25) for i:1 step 1 thru 5 do s:s+i**2 ;
(d25)                                done
\end{verbatim}
The result is stored as the value of the variable {\tt s}.
If {\tt s} had been 0 previously, the current value of {\tt s}
would be 55.  Actually,
\begin{verbatim}
(c26) s;
(d26)                               s + 55
\end{verbatim}
This reflects the fact that the value of {\tt s}
initially was just {\tt s}.
We can, of course, substitute 0 for the original value:
\begin{verbatim}
(c27) %,s=0;
(d27)                                 55
\end{verbatim}
Note that this substitution does not affect the value of {\tt s}. 
It just sets {\tt d27} to 55.
A more mysterious case is to see what happens
if we type
\begin{verbatim}
(c28) ev(s+55);
(d28)                               s + 165
\end{verbatim}
[explanation: if we had typed merely $s+55$, it would evaluate to $(s+55)+55$, 
or $s+110$.  But {\tt ev} evaluates {\it once more} to get $(s+55)+110$.  
{\tt Ev} is a puzzle and an addiction.]

In spite of the previous example, summations are not {\it really}
the same as the programming languages' {\it for loops}. Sometimes summations
are merely placeholders for computations which for one reason or another
cannot be done.
This is an example:
\begin{verbatim}
(c29) 'sum(g(i),i,0,n);
                                   n
                                  ====
                                  \
(d29)                              >    g(i)
                                  /
                                  ====
                                  i = 0
\end{verbatim}
There are three reasons for this summation to be returned {\it unsummed}. 
We have not provided a {\it function definition} for {\tt g}; the variable
{\tt n} is not some fixed integer value; and finally the {\it quote} 
symbol or apostrophe (') to the left of the {\tt sum} on line {\tt c29}
inhibits evaluation. The effect of the quote is, in most circumstances the 
prevention of evaluation.  Sometimes \Max\
can deduce the value of a summation in closed form even though it
cannot be evaluated, because of built-in simplification capabilities.
Some summations can, for example,
be solved by a fairly general procedure analogous
to symbolic integration.

In \Max\ a distinction is sometimes
drawn between {\it noun} and {\it verb} forms of commands.
Most functions are {\it verbs} in that they will be evaluated {\it away} in
an effort to eliminate them from expressions.
To prevent such evaluation, the {\it quote} illustrated
above can generally be
used.  Some functions are nouns or verbs depending upon context such as the nature of
their arguments. The trigonometric functions are this way, being nouns
if they are given integer arguments, but verbs if they are given
floating-point arguments, or {\tt ev}
'd with the {\tt numer}
option set:
\begin{verbatim}
(c30) sin(1);
(d30)                               sin(1)

(c31) sin(1),numer;
(d31)                         0.8414709848078965
\end{verbatim}
Floating-point numbers are carried to double precision.
There is also an implementation of higher (arbitrarily higher!) precision {\it bigfloats} available
and described in the manual.

\section{More Expansion}

Let us return to our very first example of a command,
and provide some more details and techniques for expansion, or
application of the distributive law of multiplication.  In some
computations where an indeterminate represents a quantity of small magnitude,
you might wish to automatically drop higher-degree terms from an expansion.
In some cases you might wish to drop terms in several variables, e.g.
all terms in $q$ with exponent
greater than 7, and terms in $p$ with exponent greater than 4, or
terms of $p^n $ and $q^m $ combined so that their {\it weight} $2 n + m$
exceeds 7.  This sequence of commands does that:
{\footnotesize
\begin{verbatim}
(c32) ratwtlvl:7$

(c33) ratweight(q,1,p,2);
(d33)                            [q, 1, p, 2]

(c34) ratexpand((p+q+1)^8);

         7       6          5       5          4       4        2  3          3
(d34) 8 q  + 28 q  + 168 p q  + 56 q  + 280 p q  + 70 q  + 560 p  q  + 280 p q

       3        2  2          2       2        3          2
 + 56 q  + 420 p  q  + 168 p q  + 28 q  + 280 p  q + 168 p  q + 56 p q + 8 q

       3       2
 + 56 p  + 28 p  + 8 p + 1

\end{verbatim}}
The {\it rats} appearing in the command names
here are an indication that the commands use something called
{\it canonical RATional expression form},
an efficient form used for dealing with polynomials and ratios of
polynomials. We have also used {\tt \^\ } instead of {\tt **} for exponentiation (the two notations
are interchangeable in \Max\ .) We will return to representation issue shortly.

\section{Integration}

One of Maxima's flashiest features is its ability to compute symbolic indefinite
integrals:
{\footnotesize
\begin{verbatim}
(c35) x/(x^3+1);
                                      x
(d35)                               ------
                                     3
                                    x  + 1

(c36) integrate(%,x);
                                        2 x - 1
                      2            atan(-------)
                 log(x  - x + 1)        sqrt(3)    log(x + 1)
(d36)            --------------- + ------------- - ----------
                        6             sqrt(3)          3
\end{verbatim}}
To check the solution, we can differentiate.
{\small
\begin{verbatim}
(c37) diff(%,x);
                        2               2 x - 1           1
(d37)           ------------------ + -------------- - ---------
                            2            2            3 (x + 1)
                   (2 x - 1)         6 (x  - x + 1)
                3 (---------- + 1)
                       3
\end{verbatim}}
A more satisfactory form would result if the terms were expanded and
the sum put over a common denominator.  By converting this result to
a canonical rational form (the same form used for the previous RAT commands)
the expression is simplified. The {\tt ratsimp}
command does this:
\begin{verbatim}
(c38) ratsimp(%);
                                      x
(d38)                               ------
                                     3
                                    x  + 1
\end{verbatim}

\section{Representation and Simplification}

The multiplicity of representations illustrated by lines {\tt d38} and 
{\tt d37} constitute an important feature of \Max.
It is not always so clear which command will produce the most appealing
form of an expression.  {\tt Ratsimp}, which did such a fine job above,
would produce a huge expression if applied to $ (x + 5)^{100} $, since
it multiplies through all those terms.

The correct choice of representation is often the key to solving
challenging problems.

The {\tt factor} command is another way of changing representation,
illustrated below.
\begin{verbatim}
(c39) factor(x^12+1);
                              4        8    4
(d39)                       (x  + 1) (x  - x  + 1)
\end{verbatim}

{\tt Factor} finds exact integral factors, not approximate zeros, and is
thus qualitatively different from numerical root-finders.  It is generally
much slower than numerical routines, but gives a different type of answer, as
illustrated above.  If your system has a numerical program library for
zero finding, it can probably be connected to \Max.  For example,
on systems licensed to use the IMSL library, a routine called {\tt zrpoly}
is available, which finds approximate zeros for real polynomials. 

{\tt Factor} and {\tt integrate} are probably two of the more surprising
commands in \Max\
because most people who understand the problems involved
are not familiar with general algorithms for solving them.
There {\tt are} general algorithms for these problems, although the
algorithm for integration sometimes indicates that the answer does
not exist in terms of elementary functions.
When a general solution to a problem is not available, or even when
it is known but inefficient, it is
sometimes possible to simulate a good
solution method by {\it pattern recognition}: that is,
by recognizing those cases that can be solved, and providing the answers,
without dealing with the complete problem.  Many user programs, and
a few built-in \Max\ facilities use this approach.

{\tt Factor}, and indeed many of the commands illustrated above, are used
internally by \Max\ for its own more complicated algorithms.  For example, 
{\tt solve} uses {\tt factor} and other routines on polynomial problems.

\section{Limitations}

You should realize that an algebraic manipulation system like \Max\ cannot 
solve all symbolic problems. There are times when {\tt solve} or 
{\tt integrate} or other commands will determine that
there are no closed-form solutions to the problem posed (in which case
they will generally inform you of the situation).

There are other instances
in which the solution method may be known in principal, but because
the calculations are so onerous, the computer seems unlikely to finish
in a reasonable time.  Algebraic computations are often subject
to {\it intermediate expression swell} where (even though the final answer
may be small -- perhaps 0), the route to the answer is difficult.

Occasionally you may run out of memory space.  A clever
computer system administrator change the program
and operating system parameters to your benefit, but it is more
likely that you could
try to rearrange your computations.

Just because it is possible to type a command in a syntactically
satisfactory manner does not mean that the required computation
is easy or even feasible.  Once a computation
has started, you may have second thoughts
about allowing it to finish.  Hence you might be concerned with the
information in
the next section:

\section{Stopping}

You may, from time to time, get your system running on a fool's errand.  How do
you bring it to its senses?

There are several related notions of running uncontrollably.  If the output is streaming past you
at too high a speed to read, (this is unlikely to happen on a slow
printing terminal, but might happen on a display terminal) you
can make the system pause by typing Ctrl--S (that's done by holding
the control key down and typing S. 
Normally, no output gets lost, but transmission is temporarily
halted.  You can resume the display by typing Ctrl--Q.

Sometimes you want to halt computation, not just
printing. You have an interrupt character, usually Ctrl--C,
which you have chosen as your standard in your UNIX operating system shell.
If you wish to halt a computation,
you can type this interrupt character one, two, or three times.
\par\noindent
The first character will cause an interrupt at the next
available clean place in your
computation. (Technically, this would be
at the interface between some compiled and some interpreted code).
If the interrupt does not happen promptly
enough for you, you may type the interrupt character a second
time. (Technically speaking, this will snap
{\it transfer links} which are used when compiled code calls compiled
code, and then cause an
interrupt at the next such function-call.)
It is possible to be caught in a very tight loop in which there are
no function calls, 
in which case the third typing of the interrupt character will stop the computation
{\tt cold}.
Even using this drastic interrupt,
you will generally
be able to avail yourself of any of several alternatives.

When the system stops, it will type
\begin{verbatim}
 Interrupt (type h for help):
\end{verbatim}

You can then type one of several atoms:
\begin{itemize}

\item[{\tt q}]{Just quit out of the interrupt and continue the computation
(after displaying the time if {\tt  showtime} was set to {\tt true}
or {\tt  all.}}

\item[{\tt r}]{Reset the computation to the top-level of \Max\,}

\item[{\tt exit}]{Exit from \Max\,}

\item[{\tt l}]{Enter a LISP break, (something a LISP expert might want to do: 
LISP, an acronym for LISt Processing Language, is the computer language
in which \Max\ is implemented.),}

\item[{\tt m}]{Enter a \Max-break.  This gives you a kind of \Max-subprocess
within your running program, which you can use to inquire about variables,
resetting things, etc.  You exit by typing {\tt exit;}
which returns you to your previous computation.}

\item[{\tt h}]{Type a menu of options. Basically what you see above.}
\end{itemize}

It is also possible to quit temporarily out of your job by typing Ctrl--Z.
See your UNIX manual for details on job control, background jobs, and
similar issues. 

If you wish to exit from \Max\, in an orderly fashion, removing the 
quiescent job, returning control to the shell (or whatever invoked \Max),
you can do this by typing the command {\tt exit();}.

\section{Storage Allocation and Timing}
\label{gc}

If you run \Max\ for long enough, and especially if you set up a
long computation, you will see strange messages like the two below:
\begin{verbatim}
[*list:634{22%}; fixnum:43{2%}; ut:0%]
[*list:634{23%}; fixnum:43{2%}; ut:69%]
\end{verbatim}
This is caused by a phenomenon known as a {\it garbage collection}
(really) which is part of the underlying LISP language system.
This is an activity started up when the computation needs more
free storage. The system then stops doing {\it useful} work, and identifies
objects in memory which are no longer needed.  This takes a few
seconds of computer time (maybe 2),
which under heavy load may take a half-minute of real time.

A message occurs after each garbage collection. You cannot really stop
the garbage collector, but you can stop
the message from printing out by setting 
\begin{center} {\tt gcprint:false} \end{center}
You may think you don't want to see this information, but it is actually
reassuring to know that your program {\tt is} running sometimes, even
though it is printing nothing but {\it gc} messages.

Programs which may have run out of storage on some versions of \Max\
may run successfully on others. However, the address space
available to a user is in practice restricted by operating
system constraints, some of which have been incorporated as
parameters in the LISP system.  An error message which declares
{\it Attempt to allocate beyond static structures} indicates that
you will have to have a reconfigured LISP system to grow larger.
You should save your computation and ask your system administration or
manager to make a larger LISP system and \Max.  This
takes about 3 or 4 minutes of computation, but requires
familiarity with the instructions for generating a system.
Since the current allocation is
really fairly large, you should also take this opportunity
to see if you really want to continue with the computation.  Large
jobs in most time-sharing systems,
tend to be more burdensome than small ones, even those running for longer
periods of time.

It is possible to fiddle with various allocations to attempt to
decrease the number of garbage collections in a system which you
suspect will require large amounts of a particular kind of
space.  The command
\begin{center}
{\tt alloc($<$spacetype$>$,$<$numberofpages$>$)}
\end{center}
allocates some number of 
pages.  Spacetypes include  {\tt list, bignum, fixnum, flonum, array} and
a few others. Most \Max\ computations use cells predominantly.

The message {\tt [fasl hole filled up]}  which you may provoke by using
the {\tt fasl} or {\tt load} program, is merely informative, and is not 
an indication of trouble.

If the \Max\ variable {\tt  gcprint} is set to a non-false value then
after each garbage collection a summary of current memory allocation
will be printed out in this form: 
{\tt [*list:634\{87\%\}; fixnum:23\{27\%\}; ut:87\%]}.
The meaning of this is that after garbage collection and subsequent
allocation of new data space, there are 634 (512 byte) pages of list data and
23 pages of fixnum data. 87\% of the list space is used and 27\% of the fixnum
space is used.  The {\tt *} before list indicates that it was list space which 
ran out and caused the garbage collection. The ut indicates the percentage
of time utilized in non-garbage collection mode.  The first time the
message is printed, this item will be 0\% because 
various counters must be initialized. The allocation of storage is
automatic; you will never be asked to make a decision about which data
space to allocate, although a low utilization measure is an indication
that automatic allocation is not working appropriately for your problem,
and various parameters can be fiddled with via {\tt alloc}.

You
can also get brief information about the time taken by each command
by setting 
\begin{center}
{\tt  showtime : all}.
\end{center}
The {\it garbage collection} or 
{\it gc} time is indicated separately,
because it happens asynchronously and it seems unfair to penalize a
particular (perhaps millisecond) operation for the fact that it
was the unlucky one to trigger a {\it gc}.


\section{Operations with Trigonometric Forms}

In the next two sections we introduce a number of facilities in \Max\
useful in dealing with trigonometric functions. A section on rule-directed
transformations follows, since our favorite examples are
trigonometry simplifications.

Consider the expression $ \cos^2 x - \sin^2 x $.
\begin{verbatim}
(c40) cos(x)^2-sin(x)^2;
                               2         2 
(d40)                       cos (x) - sin (x)
\end{verbatim}

To evaluate the last expression at a point, say
$\pi / 3 $, you can use the {\tt ev}
command:
\begin{verbatim}
(c41)ev(%,x=%pi/3)
                                     1
(d41)                              - -
                                     2
\end{verbatim}
%.pp 
The value of $1 / 2 $ was obtained not by computing $ \pi / 3 $
numerically and approximating the value of $\sin$ at that point, but
by a routine which provides simplification of special values of
trigonometric functions at points $ n \pi / m $, where 
$m$ = 1,2,3,4,6 and $n$ is an integer.
To obtain a 
real approximation, we could use {\tt numer, }
as illustrated previously.

Of course
\Max\
is able to differentiate expressions
involving trigonometric functions, also as illustrated previously.
\begin{verbatim}
(c42) diff(d40,x);
(d42)                        - 4 cos(x) sin(x)
\end{verbatim}
and knows how to integrate them.
\begin{verbatim}
(c43) integrate(d40,x);

                       sin(2 x)           sin(2 x)
                       -------- + x   x - --------
                          2                  2
(d43)                  ------------ - ------------
                            2              2
\end{verbatim}
This result is less than satisfactory. See what we can do:
\begin{verbatim}
(c44) expand(%);
                                 sin(2 x)
(d44)                            --------
                                    2
\end{verbatim}

\section{Trigonometric Re-representations and Identities}

There are a number of identity transformations specifically oriented
to trigonometric forms. Whether these produce simpler or more
complex expressions depends on the expressions they are used upon,
and sometimes is a matter of opinion.
\Max\
can convert trigonometric functions with
argument $nx$, $n$ an integer, to trigonometric functions in $x$.
You use {\tt trigexpand}
for this transformation:
\begin{verbatim}
(c45) trigexpand(%);

(d45)                          cos(x) sin(x)
\end{verbatim}

Another operation named
{\tt trigreduce}
performs a related, almost {\it inverse} transformation,
that of converting products of
powers of trigonometric functions to functions with multiple
angles. 
\begin{verbatim}
(c46) trigreduce(%);

                                 sin(2 x)
(d46)                            --------
                                    2
\end{verbatim}

Sometimes you wish to convert all trigonometric
functions to exponentials with complex arguments.  With the
flag 
{\tt exponentialize}
set to {\tt true }
you can perform
this transformation:
\begin{verbatim}
(c47) exponentialize:true\$

(c48) sin(x);

                                 %i x     - %i x
                           %i (%e     - %e      )
(d48)                    - ----------------------
                                     2
\end{verbatim}

In order to convert back to trigonometric functions you can use
{\tt  realpart.}
First we must turn off the exponentialize flag.
\begin{verbatim}
(c49) exponentialize:false\$

(c50) realpart(d48);

(d50)                             sin(x)
\end{verbatim}

Exponentials with complex arguments of the form
$n i \pi / m , \ \ \ m = 1,2,3,4,6$, $n$  an integer, will be transformed
to algebraic numbers if the flag {\tt \%emode}
is set to 
{\tt true.}
\begin{verbatim}
(c51) %emode:true\$

(c52) d50,x=%pi;
(d52)                                0
\end{verbatim}

Before continuing, let's reset that flag.
\begin{verbatim}
(c53) %emode:false\$
\end{verbatim}

A very powerful technique for approximation of analytic functions
is the use of truncated Taylor series (more generally, Laurent series).
\Max\ provides a command for the computation of these approximations, as
illustrated below:
\begin{verbatim}
(c54) taylor(sin(x)/x,x,0,4);

                                  2    4
                                 x    x
(d54)/t/                     1 - -- + --- + . . .
                                 6    120
\end{verbatim}

This is a Taylor series in $x$ about
$x=0$ up to the 4th power.  Observe that the display
has
some unusual features: the terms are ordered in reverse of
the conventional (non-series) display, there is a {\tt /t/ }
mark near the
label, and the ellipsis (...) is printed to the right to indicate
truncation of other terms.
Taylor series are a separate representation of expressions in
\Max.
Recall that we have
encountered the {\it rational} representation
used internally by commands like {\tt ratsimp, factor,}
and sometimes in
{\tt integrate. }
This form can also be directly provided in answers from
some commands. All along we have been seeing
a {\it usual} or {\it general} representation in our interactions.
Thus we have already seen evidence of three representations. Many of
\Max's
most powerful commands for simplification
are essentially switching between representations.
There are a few more representations in the system directly
accessible by the user such as 
{\it Poisson} series, used in celestial mechanics; there are a
number of additional alternative representations used, but
away from the user's sight.

\section{Rules}

It is handy to have a facility for applying identities or side relations.
The prototypical one is $ \sin^2 x + cos^2 x  \rightarrow 1 $.
There are a number of ways of achieving the effect of such a rule.  T
he simplest is substitution.  Let us recall expression {\tt d40}.
\begin{verbatim}
(c55) d40;
                                2         2
(d55)                        cos (x) - sin (x)

(c56) %,sin(x)^2=1-cos(x)^2;
                                    2
(d56)                          2 cos (x) - 1
\end{verbatim}
        The same effect could have been achieved by using
\begin{center}
\begin{verbatim}
substitute(1-cos(x)^2,sin(x)^2,%)
\end{verbatim}
\end{center}

To continue with the same prototypical rule,
often one wishes to recognize that $sin^4 x $ can be
transformed using the same rule.  For this one needs the
added power of 
{\tt ratsubst.}
\begin{verbatim}
(c57) ratsubst(1-cos(x)^2,sin(x)^2,sin(x)^4);

                             4           2
(d57)                     cos (x) - 2 cos (x) + 1
\end{verbatim}

In general {\tt ratsubst}
will perform a {\tt ratsimp}
(and thus an expansion) as well as apply the substitution.

When performing calculations repeatedly, you may wish
to apply a substitution rule whenever possible.  You can have an
{\it automatic} facility, although not the full power of a
{\tt ratsubst}
command by using a {\tt tellsimp}
rule.
\begin{verbatim}
(c58) tellsimp(sin(x)^2,1-cos(x)^2)\$

(c59) (sin(x)+1)^2;
                                           2
(d59)                          (sin(x) + 1)

(c60) expand(%);
                                        2
(d60)                     2 sin(x) - cos (x) + 2

(c61) sin(x)^2;
                                       2
(c61)                           1 - cos (x)
\end{verbatim}

You can {\it tell the simplifier}
a more general rule which will convert $ sin^2 a $ to
$ 1 - cos^2 a $ for any $a$ using a
declaration:
\begin{verbatim}
(c62) matchdeclare(a,true)\$

(c63) tellsimp(sin(a)^2,1-cos(a)^2)\$

(c64) sin(y)^2;

                                       2
(d64)                           1 - cos (y)
\end{verbatim}

You should understand that the existence of such
rules generally slows down the simplification of expressions with the same
{\it main operator} as the {\tt tellsimp} rules.  In this case the main 
operator is {\tt \^\ }.

Another rule-defining mechanism, {\tt let} has much of the power of a 
{\tt ratsubst,} although it will be applied only when using {\tt letsimp.}
First let us remove the {\tt tellsimp} rule.
\begin{verbatim}
(c65) kill(rules)$

(c66) let(sin(a)^2,1-cos(a)^2);

                            2                 2
(d66)                   (sin (a)  -->  1 - cos (a))
\end{verbatim}

Note that $a$ is still declared 
{\tt true}
for matching
purposes.  To effect a transformation using the
{\tt let}
rules, whatever their number, you use the {\tt letsimp}
command.
\begin{verbatim}
(c67) sin(x)^4;
                                     4
(d67)                             sin (x)

(c68) letsimp(%);
                             4           2
(d68)                     cos (x) - 2 cos (x) + 1
\end{verbatim}

We have not exhausted 
\Max\
facilities for
dealing with trigonometric functions, or for that matter, its
facilities for defining and applying rules.

Poisson series, mentioned earlier, deals with a special class of
trigonometric expressions frequently used in celestial
mechanics have a special representation. A program called
{\tt trigsimp}
may provide appropriate simplifications in a goal-driven fashion
(to make the smallest expression). 
