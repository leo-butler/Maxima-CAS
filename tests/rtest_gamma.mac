/******************************************************************************
  rtest_gamma.mac
  Test for Factorial, Gamma function and related functions ...
******************************************************************************/

kill(all);
done;

(oldfpprec:fpprec, fpprec:16, done);
done;

/* Two definitions for numerical test functions
   For big results relerror is used */

(closeto(value,compare,tol):=
  block(
    [abse],
    abse:abs(value-compare),if(abse<tol) then true else abse),
    done);
done;

(relerror(value,compare,tol):=
  block(
    [abse],
    abse:abs((value-compare)/compare),
    if(abse<tol) then true else abse),
    done);
done;

/******************************************************************************
  Factorial
******************************************************************************/

/* Factorial has mirror symmetrie */

declare(z,complex);
done;

conjugate(factorial(z));
factorial(conjugate(z));

conjugate(factorial(x+%i*y));
factorial(x-%i*y);

/* some small positive integers or the real representation */

fpprec:16;
16;

map(factorial, [0,1,2,3,4]);
[1,1,2,6,24];

closeto(factorial(0.0),1.0,1e-13);
true;
closeto(factorial(1.0),1.0,1e-13);
true;
closeto(factorial(2.0),2.0,1e-13);
true;
closeto(factorial(3.0),6.0,1e-13);
true;
closeto(factorial(4.0),24.0,1e-13);
true;

closeto(factorial(0.0b0),1.0b0,1e-13);
true;
closeto(factorial(1.0b0),1.0b0,1e-13);
true;
closeto(factorial(2.0b0),2.0b0,1e-13);
true;
closeto(factorial(3.0b0),6.0b0,1e-13);
true;
closeto(factorial(4.0b0),24.0b0,1e-13);
true;

/* negatvie integers or there real representation */

errcatch(factorial(-1));
[];

errcatch(factorial(-1.0));
[];

errcatch(factorial(-1.0b0));
[];

errcatch(factorial(-10));
[];

errcatch(factorial(-10.0));
[];

errcatch(factorial(-10.0b0));
[];

/* half integral values */

factorial(1/2);
sqrt(%pi)/2;
factorial(-1/2);
sqrt(%pi);
factorial(3/2);
3*sqrt(%pi)/4;
factorial(-3/2);
-2*sqrt(%pi);
factorial(5/2);
15*sqrt(%pi)/8;
factorial(-5/2);
4*sqrt(%pi)/3;

/* No simplifcation for infinities and undeterminates */

map(factorial, [inf,minf,infinity,und,ind]);
[factorial(inf),factorial(minf),factorial(infinity),factorial(und),factorial(ind)];

/* some real values in double float and bigfloat precision */

fpprec:64;
64;

closeto(
  factorial(1.3),
  1.166711905198160345041881441202917938533994349719468893970206664b0,
  1e-14);
true;

closeto(
  factorial(2.3),
  2.683437381955768793596327314766711258628187004354778456131475327b0,
  1e-14);
true;

closeto(
  factorial(3.3),
  8.855343360454037018867880138730147153473017114370768905233868579b0,
  1e-14);
true;

closeto(
  factorial(1.3b0),
  1.166711905198160345041881441202917938533994349719468893970206664b0,
  1e-62);
true;

closeto(
  factorial(2.3b0),
  2.683437381955768793596327314766711258628187004354778456131475327b0,
  1e-62);
true;

closeto(
  factorial(3.3b0),
  8.855343360454037018867880138730147153473017114370768905233868579b0,
  1e-61);
true;

/* some complex values in double float and bigfloat precision */

closeto(
  factorial(1.3+%i),
  (0.7191409365372817791473038599462048083254863806205029128993808432b0 
  +0.5406144679098492753783510221774150545811250310680842509749769021b0*%i),
  1e-14);
true;

closeto(
  factorial(2.3+%i),
  (1.113409686125898816660447855698856004567493644359072448693599037b0 
  +1.962554212729935112517511210954259433862073952077096690141827718b0*%i),
  1e-14);
true;

closeto(
  factorial(3.3+%i),
  (1.711697751485530982461966712851965381210655074307842390547049105b0 
  +7.589838588134684687968234851847912136312337686213491526161630507b0*%i),
  1e-14);
true;

closeto(
  factorial(1.3b0+%i),
  (0.7191409365372817791473038599462048083254863806205029128993808432b0 
  +0.5406144679098492753783510221774150545811250310680842509749769021b0*%i),
  1e-62);
true;

closeto(
  factorial(2.3b0+%i),
  (1.113409686125898816660447855698856004567493644359072448693599037b0 
  +1.962554212729935112517511210954259433862073952077096690141827718b0*%i),
  1e-62);
true;

closeto(
  factorial(3.3b0+%i),
  (1.711697751485530982461966712851965381210655074307842390547049105b0 
  +7.589838588134684687968234851847912136312337686213491526161630507b0*%i),
  1e-61);
true;

/******************************************************************************
  General factorial: Tests for genfact(x,y,z)
******************************************************************************/

genfact(0,0,1);
1;
genfact(1,1,1);
1;
genfact(2,2,1);
2;
genfact(3,3,1);
6;
genfact(4,4,1);
24;

genfact(0,0/2,2);
1;
genfact(1,1/2,2);
1;
genfact(2,2/2,2);
2;
genfact(3,3/2,2);
3;
genfact(4,4/2,2);
8;

genfact(10,10,1);
3628800;
genfact(10,9,1);
3628800;
genfact(10,8,1);
1814400;
genfact(10,7,1);
604800;
genfact(10,6,1);
151200;
genfact(10,5,1);
30240;
genfact(10,4,1);
5040;
genfact(10,3,1);
720;
genfact(10,2,1);
90;
genfact(10,1,1);
10;
genfact(10,0,1);
1;

genfact(10,5,2);
3840;
genfact(10,4,2);
1920;
genfact(10,3,2);
480;
genfact(10,2,2);
80;
genfact(10,1,2);
10;
genfact(10,0,2);
1;

/* for non valid integers we get an error */
errcatch(genfact(-2,-2,1));
[];
errcatch(genfact(2,5,2));
[];

/* for all other numbers we get a noun form */
(3/2)!!;
genfact(3/2,0,2);
(2.5)!!;
genfact(2.5,1,2);
(2.5b0)!!;
genfact(2.5b0,1,2);

/******************************************************************************
  Double factorial
******************************************************************************/

factorial_double(-3);
-1;
errcatch(factorial_double(-2));
[];
factorial_double(-1);
1;
factorial_double(0);
1;
factorial_double(1);
1;
factorial_double(2);
2;
factorial_double(3);
3;
factorial_double(4);
8;
factorial_double(5);
15;
factorial_double(6);
48;
factorial_double(7);
105;
factorial_double(8);
384;
factorial_double(9);
945;
factorial_double(10);
3840;

/* The same for double float */

closeto(
  factorial_double(-3.0),
  -1.0,
  1e-13);
true;

errcatch(factorial_double(-2.0));
[];

closeto(
  factorial_double(-1.0),
  1.0,
  1e-13);
true;

closeto(
  factorial_double(0.0),
  1.0,
  1e-13);
true;

closeto(
  factorial_double(1.0),
  1.0,
  1e-13);
true;

closeto(
  factorial_double(2.0),
  2.0,
  1e-13);
true;

closeto(
  factorial_double(3.0),
  3.0,
  1e-13);
true;

closeto(
  factorial_double(4.0),
  8.0,
  1e-13);
true;

closeto(
  factorial_double(5.0),
  15.0,
  1e-13);
true;

closeto(
  factorial_double(6.0),
  48.0,
  1e-13);
true;

closeto(
  factorial_double(7.0),
  105.0,
  1e-13);
true;

closeto(
  factorial_double(8.0),
  384.0,
  1e-12);
true;

closeto(
  factorial_double(9.0),
  945.0,
  1e-11);
true;

closeto(
  factorial_double(10.0),
  3840.0,
  1e-12);
true;

/* The same with bigfloat */
fpprec:64;
64;

closeto(
  factorial_double(-3.0b0),
  -1.0b0,
  1e-13);
true;

errcatch(factorial_double(-2.0b0));
[];

closeto(
  factorial_double(-1.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  factorial_double(0.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  factorial_double(1.0b0),
  1.0b0,
  1e-13);
true;

closeto(
  factorial_double(2.0b0),
  2.0b0,
  1e-13);
true;

closeto(
  factorial_double(3.0b0),
  3.0b0,
  1e-13);
true;

closeto(
  factorial_double(4.0b0),
  8.0b0,
  1e-13);
true;

closeto(
  factorial_double(5.0b0),
  15.0b0,
  1e-13);
true;

closeto(
  factorial_double(6.0b0),
  48.0b0,
  1e-13);
true;

closeto(
  factorial_double(7.0b0),
  105.0b0,
  1e-13);
true;

closeto(
  factorial_double(8.0b0),
  384.0b0,
  1e-13);
true;

closeto(
  factorial_double(9.0b0),
  945.0b0,
  1e-13);
true;

closeto(
  factorial_double(10.0b0),
  3840.0b0,
  1e-13);
true;

/* Some real and complex values */

closeto(
  factorial_double(-3.5),
  -1.283770376595223397225456287264697304361344685971440894669095353b0,
  1e-13);
true;

closeto(
  factorial_double(-3.5b0),
  -1.283770376595223397225456287264697304361344685971440894669095353b0,
  1e-60);
true;

closeto(
  factorial_double(-3.5+%i),
  (-0.0026442534512730229977827874410755514695008373007370518369259413b0 
   +0.4140148090845355309500755922424659939330568167751526009311942842b0*%i),
  1e-13);
true;

closeto(
  factorial_double(3.5),
  4.832319386136852665658314936437452651454869331098044546829825309b0,
  1e-13);
true;

closeto(
  factorial_double(3.5b0),
  4.832319386136852665658314936437452651454869331098044546829825309b0,
  1e-60);
true;

closeto(
  factorial_double(3.5+%i),
  (-2.165793510810110416038389252512222520262890874310470919228355939b0 
   +4.032141259508464573377851775093179996368679285808989461893416849b0*%i),
  1e-13);
true;

/* Complex Bigfloat does not work. We get only double float precision.
   I have no idea why! Further work is needed.
*/

closeto(
  factorial_double(-3.5b0+%i),
  (-0.0026442534512730229977827874410755514695008373007370518369259413b0 
   +0.4140148090845355309500755922424659939330568167751526009311942842b0*%i),
  1e-60);
true;

closeto(
  factorial_double(3.5b0+%i),
  (-2.165793510810110416038389252512222520262890874310470919228355939b0 
   +4.032141259508464573377851775093179996368679285808989461893416849b0*%i),
  1b-60);
true;

closeto(
  factorial_double(3.3b0+%i),
  (-0.401169963963553982868990904015984192029807700247132080411340721b0 
  + 1.778201955902329072861901606357849890890501421219437116360540910b0*%i),
  1b-60);
true;

/* This test shows that the Gamma function works for complex bigfloat */

closeto(
  gamma(1+(3.3b0+%i)/2.0),
  (1.2972549927172942677789338941981645022071299145741135508593106691b0 
 + 0.5352362571886066062517362544937539933942267771249551706160092774b0*%i),
  1b-62);
true;

/* Test the expansion of Double factorial */

factorial_double(n-1),factorial_expand:true;
factorial(n)/factorial_double(n);

factorial_double(n+2),factorial_expand:true;
(n+2)*factorial_double(n);

factorial_double(n-2),factorial_expand:true;
factorial_double(n)/n;

/******************************************************************************
  Gamma function
******************************************************************************/

/* The Gamma function has mirror symmetry */

declare(z,complex);
done;

conjugate(gamma(z));
gamma(conjugate(z));

conjugate(gamma(x+%i*y));
gamma(x-%i*y);

/* Check simple values for integer, float and bigfloat */

map('gamma,[1,2,3,4,5]);
[1,1,2,6,24];

closeto(gamma(1.0),1.0,1e-13);
true;

closeto(gamma(2.0),1.0,1e-13);
true;

closeto(gamma(3.0),2.0,1e-13);
true;

closeto(gamma(4.0),6.0,1e-13);
true;

closeto(gamma(5.0),24.0,5e-13);  
true;

closeto(gamma(1.0b0),1.0b0,1e-13);
true;

closeto(gamma(2.0b0),1.0b0,1e-13);
true;

closeto(gamma(3.0b0),2.0b0,1e-13);
true;

closeto(gamma(4.0b0),6.0b0,1e-13);
true;

closeto(gamma(5.0b0),24.0b0,1e-13);
true;

/* Check for a zero argument */

errcatch(gamma(0));
[];
errcatch(gamma(0.0));
[];
errcatch(gamma(0.0b0));
[];

/* Check test for negative integer or a representation of a negative integer */

errcatch(gamma(-2));
[];
errcatch(gamma(-2.0));
[];
errcatch(gamma(-2.b0));
[];

/* Check half integral integers as values */

gamma(1/2);
sqrt(%pi);
gamma(-1/2);
-2*sqrt(%pi);
gamma(3/2);
sqrt(%pi)/2;
gamma(-3/2);
4*sqrt(%pi)/3;
gamma(5/2);
3*sqrt(%pi)/4;
gamma(-5/2);
-8*sqrt(%pi)/15;

/* We do not test the default value $gammalim and try not do test
   for big integers, the results are unpredictable.
   Perhaps we can set $gammalim and $factlim to default values which will
   work for most (all) systems.
   Here an attempt for big values which might work generally */

(x:gamma(100000),  /* Try this as the biggest integer */
 relerror(
   bfloat(x),
   gamma(100000.0b0),
   1e-10));
true;

(x:gamma(20001/2),   /* Try this as the biggest half integral value        */
 relerror(           /* perhaps such a big value is not very useful and we */
   bfloat(x),        /* should further reduce the default value eg. to 100 */
   gamma(bfloat(20001/2)),
   1e-10));
true;

/* Check test for overflow in flonum routine gamma-lanczos */
   
relerror(
  gamma(170.0),          /* should not overflow. For GCL 2.6.8 and */
  gamma(170),            /* and CLISP 2.46 the limit is ~171.6243  */
  1e-10);
true;       

errcatch(gamma(175.0));  /* should overflow */
[];

errcatch(gamma(250.0));  /* should overflow */
[];

/* No simplifcation for infinities and undeterminates */

map('gamma, [inf,minf,infinity,und,ind]);
[gamma(inf),gamma(minf),gamma(infinity),gamma(und),gamma(ind)];

/* Check real and complex arguments for double float. 
   This is a check for the numerical routine gamma-lanczos */

closeto(
  gamma(0.5),
  1.772453850905516027298167483341145182797549456122387128213807790b0,
  1e-14);
true;

closeto(
  gamma(1.5),
  0.8862269254527580136490837416705725913987747280611935641069038949b0,
  1e-14);
true;

closeto(
  gamma(2.5),
  1.329340388179137020473625612505858887098162092091790346160355842b0,
  1e-14);
true;

closeto(
  gamma(3.5),
  3.323350970447842551184064031264647217745405230229475865400889606b0,
  1e-14);
true;

relerror(
  gamma(75.5),
  2.859942315653572214189951793671955438617013849084406338093590075b108,
  5e-14);
true;

closeto(
  gamma(0.5+%i),
  (0.3006946172606558162173894638352104402306759641691949986162475934b0 
  -0.4249678794331238126098496402574059704734842223340586518754297249b0*%i),
  1e-14);
true;

closeto(
  gamma(1.5+%i),
  (0.5753151880634517207185443721750111905888222044186561511835535216b0 
  +0.0882106775440939099124646437065074549939338530021656726785327309b0*%i),
  1e-14);
true;

closeto(
  gamma(2.5+%i),
  (0.7747621045510836711653519145560093308892994536258185540967975514b0 
  +0.7076312043795925855872413377347723730797229839219046602013526179b0*%i),
  1e-14);
true;

closeto(
  gamma(3.5+%i),
  (1.229274056998116592326138448655250954143525650142641725040641261b0 
  +2.543840115500065135133455258892940263588606913430580204600179096b0*%i),
  1e-14);
true;

relerror(
  gamma(75.5+%i),
  (-1.092860022497734443706055997676557155572470037327121860702819811b108 
   -2.622326961675321010452173874453854546607804545768376326095021243b108*%i),
  5e-14);
true;

/* Check negative real arguments in double float precision. 
   This is a check for the reflection formula of gamma-lanzos */

closeto(
  gamma(-0.5b0),
  -3.544907701811032054596334966682290365595098912244774256427615580b0,
  1e-14);
true;

closeto(
  gamma(-1.5b0),
  2.363271801207354703064223311121526910396732608163182837618410386b0,
  1e-14);
true;

closeto(
  gamma(-2.5b0),
  -0.9453087204829418812256893244486107641586930432652731350473641546b0,
  1e-14);
true;

/* Check real arguments up to 64 digits. 
   This is a check for the numerical routine bffac */

closeto(
  gamma(0.5b0),
  1.772453850905516027298167483341145182797549456122387128213807790b0,
  1e-61);
true;

closeto(
  gamma(1.5b0),
  0.8862269254527580136490837416705725913987747280611935641069038949b0,
  1e-61);
true;

closeto(
  gamma(2.5b0),
  1.329340388179137020473625612505858887098162092091790346160355842b0,
  1e-61);
true;

closeto(
  gamma(3.5b0),
  3.323350970447842551184064031264647217745405230229475865400889606b0,
  1e-61);
true;

relerror(
  gamma(75.5b0),
  2.859942315653572214189951793671955438617013849084406338093590075b108,
  1e-61);
true;

/* Check negative real arguments up to 64 digits. 
   This is a check for the reflection formula of bffac */

closeto(
  gamma(-0.5b0),
  -3.544907701811032054596334966682290365595098912244774256427615580b0,
  1e-61);
true;

closeto(
  gamma(-1.5b0),
  2.363271801207354703064223311121526910396732608163182837618410386b0,
  1e-61);
true;

closeto(
  gamma(-2.5b0),
  -0.9453087204829418812256893244486107641586930432652731350473641546b0,
  1e-61);
true;

/* Check complex arguments up to 64 digits. 
   This is a check for the numerical routine cbffac */

closeto(
  gamma(0.5b0+%i),
  (0.3006946172606558162173894638352104402306759641691949986162475934b0 
  -0.4249678794331238126098496402574059704734842223340586518754297249b0*%i),
  1e-61);
true;

closeto(
  gamma(1.5b0+%i),
  (0.5753151880634517207185443721750111905888222044186561511835535216b0 
  +0.0882106775440939099124646437065074549939338530021656726785327309b0*%i),
  1e-61);
true;

closeto(
  gamma(2.5b0+%i),
  (0.7747621045510836711653519145560093308892994536258185540967975514b0 
  +0.7076312043795925855872413377347723730797229839219046602013526179b0*%i),
  1e-61);
true;

closeto(
  gamma(3.5b0+%i),
  (1.229274056998116592326138448655250954143525650142641725040641261b0 
  +2.543840115500065135133455258892940263588606913430580204600179096b0*%i),
  1e-61);
true;

relerror(
  gamma(75.5b0+%i),
  (-1.092860022497734443706055997676557155572470037327121860702819811b108 
   -2.622326961675321010452173874453854546607804545768376326095021243b108*%i),
  1e-61);
true;

(fpprec:oldfpprec,done);
done;