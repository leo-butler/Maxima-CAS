This is maxima.info, produced by makeinfo version 4.13 from maxima.texi.

Ver. 5.23 Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables de parámetros descriptivos,  Next: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables para el tratamiento de datos,  Up: descriptive

46.3 Funciones y variables de parámetros descriptivos
=====================================================

 -- Función: mean (<list>)
 -- Función: mean (<matrix>)
     Es la media muestral, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]


 -- Función: var (<list>)
 -- Función: var (<matrix>)
     Es la varianza muestral, definida como
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     Véase también `var1'.

 -- Función: var1 (<list>)
 -- Función: var1 (<matrix>)
     Es la cuasivarianza muestral, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     Véase también `var'.

 -- Función: std (<list>)
 -- Función: std (<matrix>)
     Es la desviación típica muestral, raíz cuadrada de `var'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Véanse también `var' y `std1'.

 -- Función: std1 (<list>)
 -- Función: std1 (<matrix>)
     Es la cuasidesviación típica muestral, raíz cuadrada de `var1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Véanse también `var1' y `std'.

 -- Función: noncentral_moment (<list>, <k>)
 -- Función: noncentral_moment (<matrix>, <k>)
     Es el momento no central de orden k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]
          (%i6) noncentral_moment (s2, 5);

     Véase también `central_moment'.

 -- Función: central_moment (<list>, <k>)
 -- Función: central_moment (<matrix>, <k>)
     Es el momento central de orden k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]
          (%i6) central_moment (s2, 3);

     Véanse también `central_moment' y `mean'.

 -- Función: cv (<list>)
 -- Función: cv (<matrix>)
     Es el coeficiente de variación, o cociente entre la desviación
     típica muestral (`std') y la media (`mean'),

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Véanse también `std' y `mean'.

 -- Función: smin (<list>)
 -- Función: smin (<matrix>)
     Es el valor mínimo de la muestra <list>.  Cuando el argumento es
     una matriz, `smin' devuelve una lista con los valores mínimos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smin (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smin (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Véase también `smax'.

 -- Función: smax (<list>)
 -- Función: smax (<matrix>)
     Es el valor máximo de la muestra <list>.  Cuando el argumento es
     una matriz, `smax' devuelve una lista con los valores máximos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smax (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smax (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Véase también `smin'.

 -- Función: range (<list>)
 -- Función: range (<matrix>)
     Es la diferencia entre los valores extremos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]


 -- Función: quantile (<list>, <p>)
 -- Función: quantile (<matrix>, <p>)
     Es el <p>-cuantil, siendo <p> un número del intervalo [0, 1], de
     la muestra <list>.  Aunque existen varias definiciones para el
     cuantil muestral (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles
     in statistical packages>. American Statistician, 50, 361-365), la
     programada en el paquete  `descriptive' es la basada en la
     interpolación lineal.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]


 -- Función: median (<list>)
 -- Función: median (<matrix>)
     Una vez ordenada una muestra, si el tamaño muestral es impar la
     mediana es el valor central, en caso contrario será la media de
     los dos valores centrales.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     La mediana es el cuantil 1/2.

     Véase también `quantile'.

 -- Función: qrange (<list>)
 -- Función: qrange (<matrix>)
     El rango intercuartílico es la diferencia entre el tercer y primer
     cuartil, `quantile(<list>,3/4) - quantile(<list>,1/4)',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Véase también `quantile'.

 -- Función: mean_deviation (<list>)
 -- Función: mean_deviation (<matrix>)
     Es la desviación media, definida como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Véase también `mean'.

 -- Función: median_deviation (<list>)
 -- Función: median_deviation (<matrix>)
     Es la desviación mediana, definida como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1

     siendo `med' la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Véase también `mean'.

 -- Función: harmonic_mean (<list>)
 -- Función: harmonic_mean (<matrix>)
     Es la media armónica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Véanse también `mean' y `geometric_mean'.

 -- Función: geometric_mean (<list>)
 -- Función: geometric_mean (<matrix>)
     Es la media geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Véanse también `mean' y `harmonic_mean'.

 -- Función: kurtosis (<list>)
 -- Función: kurtosis (<matrix>)
     Es el coeficiente de curtosis, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Véanse también `mean', `var' y `skewness'.

 -- Función: skewness (<list>)
 -- Función: skewness (<matrix>)
     Es el coeficiente de asimetría, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450306
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Véanse también `mean', `var' y `kurtosis'.

 -- Función: pearson_skewness (<list>)
 -- Función: pearson_skewness (<matrix>)
     Es el coeficiente de asimetría de Pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s

     siendo <med> la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Véanse también `mean', `var' y `median'.

 -- Función: quartile_skewness (<list>)
 -- Función: quartile_skewness (<matrix>)
     Es el coeficiente de asimetría cuartílico, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4

     siendo c_p el <p>-cuantil de la muestra <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Véase también `quantile'.

 -- Función: cov (<matrix>)
     Es la matriz de covarianzas de una muestra multivariante, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]
          (%i5) cov (s2);

     Véase también `cov1'.

 -- Función: cov1 (<matrix>)
     Es la matriz de cuasivarianzas de una muestra multivariante,
     definida como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]
          (%i5) cov1 (s2);

     Véase también `cov'.

 -- Función: global_variances (<matrix>)
 -- Función: global_variances (<matrix>, <logical_value>)
     La función `global_variances' devuelve una lista de medidas
     globales de variabilidad:

        * <varianza total>: `trace(S_1)',

        * <varianza media>: `trace(S_1)/p',

        * <varianza generalizada>: `determinant(S_1)',

        * <desviación típica generalizada>: `sqrt(determinant(S_1))',

        * <varianza efectiva> `determinant(S_1)^(1/p)', (definida en:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desviación típica efectiva>: `determinant(S_1)^(1/(2*p))'.
     donde <p> es la dimensión de la variable aleatoria multivariante y
     S_1 la matriz de covarianzas devuelta por la función `cov1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     La función `global_variances' tiene un argumento lógico opcional:
     `global_variances(x,true)' indica a Maxima que `x' es la matriz de
     datos, calculando entonces lo mismo que `global_variances(x)'. Por
     otro lado, `global_variances(x,false)' significa que  `x' no es la
     matriz de datos, sino la de covarianzas, evitando así recalcularla,

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Véanse también `cov' y `cov1'.

 -- Función: cor (<matrix>)
 -- Función: cor (<matrix>, <logical_value>)
     Es la matriz de correlaciones de la muestra multivariante.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     La función `cor' tiene un argumento lógico opcional: `cor(x,true)'
     indica a Maxima que `x' es la matriz de datos, calculando entonces
     lo mismo que `cor(x)'. Por otro lado, `cor(x,false)' significa que
     `x' no es la matriz de datos, sino la de covarianzas, evitando así
     recalcularla,

          (%i1) load (descriptive)$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Véanse también `cov' y `cov1'.

 -- Función: list_correlations (<matrix>)
 -- Función: list_correlations (<matrix>, <logical_value>)
     La función `list_correlations' devuelve una lista con medidas de
     correlación:

        * <matriz de precisión>: es la inversa de la matriz de
          covarianzas S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <multiple correlation vector>:  (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          es un indicador de la bondad de ajuste del modelo de
          regresión lineal multivariante de X_i cuando el resto de
          variables se utilizan como regresores.

        * <matriz de correlaciones parciales>: en la que el elemento
          (i, j) es
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%o6)       [.85063, .80634, .86474, .71867, .72675]
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o7)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     La función `list_correlations' tiene un argumento lógico opcional:
     `list_correlations(x,true)' indica a Maxima que `x' es la matriz
     de datos, calculando entonces lo mismo que `list_correlations(x)'.
     Por otro lado, `list_correlations(x,false)' significa que  `x' no
     es la matriz de datos, sino la de covarianzas, evitando así
     recalcularla.

     Véanse también `cov' y `cov1'.


File: maxima.info,  Node: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de parámetros descriptivos,  Up: descriptive

46.4 Funciones y variables para gráficos estadísticos
=====================================================

 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, ...)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Función: histogram (<one_row_matrix>)
 -- Función: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
     Esta función dibuja el histograma de una muestra de variable
     continua.  Los datos muestrales se deben almacenar en una lista de
     números o en una matriz unidimensional.

     Opciones disponibles:

        * Las definidas en el paquete `draw'. Véanse también `bars' y
          `barsplot'.

        * <nclasses>: número de clases del histograma (por defecto, 10).

     Véanse también `discrete_freq' y `continuous_freq' para recuentos,
     y `bars' y `barsplot' para representar gráficos.

     Ejemplos:

     Un histograma de ocho clases.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
               s1,
               nclasses     = 8,
               title        = "pi digits",
               xlabel       = "digits",
               ylabel       = "Absolute frequency",
               fill_color   = grey,
               fill_density = 0.6)$

 -- Función: scatterplot (<list>)
 -- Función: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Función: scatterplot (<matrix>)
 -- Función: scatterplot (<matrix>, <option_1>, <option_2>, ...)
     Dibuja diagramas de dispersión, tanto de muestras univariantes
     (<list>) como multivariantes (<matrix>).

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <nclasses>: número de clases del histograma (por defecto, 10).

     Ejemplos:

     Diagrama de dispersión univariante a partir de una muestra normal
     simulada.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
            random_normal(0,1,200),
            xaxis      = true,
            point_size = 2,
            terminal   = eps,
            eps_width  = 10,
            eps_height = 2)$

     Diagrama de dispersión bidimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
           submatrix(s2, 1,2,3),
           title      = "Data from stations #4 and #5",
           point_type = diamant,
           point_size = 2,
           color      = blue)$

     Diagrama de dispersión tridimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2))$

     Diagrama de dispersión de cinco dimensiones, con histogramas de
     cinco classes.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
            s2,
            nclasses     = 5,
            fill_color   = blue,
            fill_density = 0.3,
            xtics        = 5)$

     Para dibujar puntos aislados o unidos por segmentos, tanto en dos
     como en tres dimensiones, véase `points'.  Para las opciones
     relacionadas con los histogramas, véase `bars'.

     Véase también `histogram'.

 -- Función: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
     Dibuja diagramas de barras para variables estadísticas discretas,
     tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

        * Las definidas en el paquete `draw'.

        * <box_width>: ancho relativo de los rectángulos (`3/4' por
          defecto). Este valor debe pertenecer al rango `[0,1]'.

        * <groups_gap>: un número positivo que representa la separación
          entre dos grupos consecutivos de barras. El valor por defecto
          es 1.

        * <bars_colors>: una lista de colores para múltiples muestras.
          El valor por defecto es la lista vacía `[]'. Cuando el número
          de muestras sea mayor que el de colores especificados, los
          colores adicionales necesarios se seleccionan aleatoriamente.
          Véase `color' para más información.

        * <relative_frequencies>: si vale `false', se utilizarán
          frecuencias absolutas; si vale `true', las marcas del eje-<y>
          serán frecuencias relativas. El valor por defecto es `false'.

        * <ordering>: los valores admitidos para esta opción son:
          `orderlessp' y `ordergreatp', indicando cómo se deben ordenar
          los resultados muestrales sobre el eje-<x>. El valor por
          defecto es `orderlessp'.

        * <sample_keys>: es una lista de cadenas de texto a usar como
          leyendas.  Su valor por defecto es la lista vacía `[]'.
          Cuando la lista tenga una longitud diferente de cero o del
          número de muestras, se devolverá un mensaje de error.


     Ejemplos:

     Muestra univariante en formato matricial. Frecuencias absolutas.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Dos muestras de diferente tamaño, con frecuencias relativas y
     colores definidos por el usuario.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  relative_frequencies = true,
                  sample_keys = ["A", "B"])$

     Cuatro muestras no numéricas de igual tamaño.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     `barsplot' en un contexto multiplot.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) draw_compound : false $
          (%i5) bp1 :
                  barsplot(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   relative_frequencies = true)$
          (%i6) bp2 :
                  barsplot(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   relative_frequencies = true)$
          (%i7) draw(apply(gr2d,bp1),
                     apply(gr2d,bp2)) $

     Para las opciones relacionadas con los diagramas de barras, véase
     `bars' del paquete `draw'.

     Véanse también las funciones `histogram' y `piechart'.

 -- Función: piechart (<list>)
 -- Función: piechart (<list>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_column_matrix>)
 -- Función: piechart (<one_column_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_row_matrix>)
 -- Función: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
     Similar a `barsplot', pero dibuja sectores en lugar de rectángulos.

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <pie_center>: centro del diagrama (por defecto, `[0,0]').

        * <pie_radius>: radio del diagrama (por defecto, 1).

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
            s1,
            xrange      = [-1.1, 1.3],
            yrange      = [-1.1, 1.1],
            axis_top    = false,
            axis_right  = false,
            axis_left   = false,
            axis_bottom = false,
            xtics       = none,
            ytics       = none,
            title       = "Digit frequencies in pi")$

     Véase también la función `barsplot'.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, ...)
     Dibuja diagramas de cajas (box-and-whishker). El argumento <data>
     puede ser una lista, lo cual no es de gran interés, puesto que
     estos gráficos se utilizan principalmente para comparar distintas
     muestras, o una matriz, de manera que sea posible comparar dos o
     más componentes de una muestra multivariante. También se permite
     que <data> sea una lista de muestras con posibles tamaños
     diferentes; de hecho, esta es la única función del paquete
     `descriptive' que admite esta estructura de datos.

     Opciones disponibles:

        * Las definidas en el paquete `draw'.

        * <box_width>: ancho relativo de las cajas (por defecto,
          `3/4'). Este valor debe estar en el rango `[0,1]'.

     Ejemplos:

     Diagrama de cajas de una muestra multivariante.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
            box_width  = 0.2,
            title      = "Windspeed in knots",
            xlabel     = "Stations",
            color      = red,
            line_width = 2)$

     Diagrama de cajas de tres muestras de tamaños diferentes.

          (%i1) load (descriptive)$
          (%i2) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

47 diag
*******

* Menu:

* Funciones y variables para diag::


File: maxima.info,  Node: Funciones y variables para diag,  Prev: diag,  Up: diag

47.1 Funciones y variables para diag
====================================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la
     diagonal, siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden  <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima. Para obtener la matriz correspondiente, llámese a
     la función `dispJordan' utilizando como argumento la salida de
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `dispJordan' y `minimalPoly'.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `minimalPoly'.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la
     forma de Jordan de <A>. La lista <l> es la forma codificada de la
     forma de Jordan tal como la devuelve la función `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que `dispJordan(%o3)' es la forma de Jordan de la matriz
     `a'.

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: mat_function (<f>,<mat>)
     Devuelve  f(mat), siendo <f> una función analítica y <mat> una
     matriz. Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si `f(x)' es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])
                    * ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

48 distrib
**********

* Menu:

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Funciones y variables para distribuciones continuas,  Prev: distrib,  Up: distrib

48.1 Introducción a distrib
===========================

El paquete `distrib' contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

   A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

   Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua. La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que es igual a la probabilidad <Pr(X <= x)>.

   La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   La  <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que es un número real positivo. La raíz cuadrada de la varianza es
la <desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de
dispersión.

   El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Si X es normal, KU[X]=0. De hecho, tanto la asimetría como la
curtosis son parámetros de forma para medir la no normalidad de una
distribución.

   Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>,  f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar. En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   La media, varianza, desviación típica y los coeficientes de
asimetría y curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectivamente.

   Por favor, consúltese cualquier manual introductorio de probabilidad
y estadística para más información sobre toda esta parafernalia
matemática.

   Se sigue cierta convención a la hora de nombrar las funciones del
paquete `distrib'. Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

   La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Chi^2 no central    (*noncentral_chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)

   Por ejemplo, `pdf_student_t(x,n)' es la función de densidad de la
distribución de Student con <n> grados de libertad, `std_pareto(a,b)'
es la desviación típica de la distribución de Pareto de parámetros <a>
y <b>, y `kurtosis_poisson(m)' es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

   Para poder hacer uso del paquete `distrib' es necesario cargarlo
primero tecleando
     (%i1) load(distrib)$

   Para comentarios, errores o sugerencias, por favor contáctese
conmigo en <'mario ARROBA edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para distribuciones continuas,  Next: Funciones y variables para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

48.2 Funciones y variables para distribuciones continuas
========================================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0. Esta
     función se define en términos de la función de error,  `erf', de
     Maxima.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Véase también `erf'.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de  `cdf_normal'. El
     argumento <q> debe ser un número de [0,1]. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472


 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Normal(m,s), con s>0,
     es decir <m>. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Normal(m,s), con s>0, es decir <s>. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Normal(m,s), con s>0. Llamando a
     `random_normal' con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el de Box-Mueller, tal como está
     descrito en Knuth, D.E. (1981) <Seminumerical Algorithms. The Art
     of Computer Programming.> Addison-Wesley.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     `cdf_student_t'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n),
     con n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0. Llamando a
     `random_student_t' con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <Z> es
     una variable aleatoria normal N(0,1) y S^2 es una chi cuadrada de
     <n> grados de libertad, Chi^2(n), entonces
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria de Student de <n> grados de libertad,
     t(n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria no central de Student nc_t(n,ncp), con
     n>0 grados de libertad y parámetro de no centralidad ncp. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

     En ocasiones es necesario hacer algún trabajo extra para obtener
     el resultado final.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                 .01370030107589574 sqrt(5)
          (%o2)  --------------------------
                 sqrt(2) sqrt(14) sqrt(%pi)
             1.654562884111515E-4 sqrt(5)
           + ----------------------------
                      sqrt(%pi)
             .02434921505438663 sqrt(5)
           + --------------------------
                        %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Función: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp. Esta función no tiene expresión compacta y se
     calcula numéricamente si la variable global `numer' vale `true' o
     si alguno de sus argumentos es un número decimal, en otro caso
     devuelve una expresión nominal.  Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2) cdf_noncentral_student_t(- 2, 5, - 5)
          (%i3) cdf_noncentral_student_t(-2.0,5,-5);
          (%o3)          .9952030093319743


 -- Función: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp; en otras palabras, se trata de la inversa de
     `cdf_noncentral_student_t'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_noncentral_student_t (<n>,<ncp>)
     Devuelve la media de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>1 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) (assume(df>1), mean_noncentral_student_t(df,k));
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2


 -- Función: var_noncentral_student_t (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de no
     centralidad ncp. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_noncentral_student_t (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria no central
     de Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de
     no centralidad ncp. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>3 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de curtosis de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>4 grados de libertad y
     parámetro de no centralidad ncp. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_noncentral_student_t (<n>,<ncp>)
 -- Función: random_noncentral_student_t (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_t(n,ncp), con n>0. Llamando a
     `random_noncentral_student_t' con un tercer argumento <m>, se
     obtiene una muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <X> es
     una variable aleatoria normal N(ncp,1) y S^2 es una chi cuadrada
     de <n> grados de libertad, Chi^2(n), entonces
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria no central de Student de <n> grados de
     libertad y parámetro de no centralidad ncp, nc_t(n,ncp).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la función de
     densidad de la gamma.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de  `cdf_chi2'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal basada en la función cuantil
     de la gamma, puesto que la variable aleatoria Chi^2(n) equivale a
     una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Función: mean_chi2 (<n>)
     Devuelve la media de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la media de la
     gamma.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la varianza de la
     gamma.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la desviación
     típica de la gamma.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     asimetría de la gamma.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     curtosis de la gamma.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio  Chi^2(n), con n>0. Llamando a
     `random_chi2' con un segundo argumento <m>, se simulará una
     muestra aleatoria de tamaño <m>.

     La simulación está basada en el algoritmo de Ahrens-Cheng. Véase
     `random_gamma' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.
     Para hacer uso de esta función ejecútese primero `load(distrib)'.


 -- Función: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.


 -- Función: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0; en otras palabras, se trata de la inversa de
     `cdf_noncentral_chi2'. El argumento <q> debe ser un número de
     [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.


 -- Función: mean_noncentral_chi2 (<n>,<ncp>)
     Devuelve la media de  una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: var_noncentral_chi2 (<n>,<ncp>)
     Devuelve la varianza de  una variable aleatoria chi-cuadrado no
     centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.


 -- Función: std_noncentral_chi2 (<n>,<ncp>)
     Devuelve la desviación típica de  una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: skewness_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     chi-cuadrado no centrada  nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.


 -- Función: random_noncentral_chi2 (<n>,<ncp>)
 -- Función: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio  nc_Chi^2(n,ncp), con n>0 y parámetro
     de no centralidad ncp>=0. Llamando a `random_noncentral_chi2' con
     un tercer argumento <m>, se simulará una muestra aleatoria de
     tamaño <m>.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  F(m,n), con m,n>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  F(m,n), con m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria  F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de  `cdf_f'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de  una variable aleatoria  F(m,n), con m>0,
     n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de  una variable aleatoria  F(m,n), con m>0,
     n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de  una variable aleatoria  F(m,n),
     con m>0, n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     F(m,n), con m>0, n>8. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio  F(m,n), con m,n>0. Llamando a
     `random_f' con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el hecho de que si <X>
     es una variable aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                  n X
                              F = ---
                                  m Y

     es una variable aleatoria F con <m> y <n> grados de libertad,
     F(m,n).

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la densidad de Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la distribución de Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de  `cdf_exp'.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el cuantil de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de  una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la media de la Weibull.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de  una variable aleatoria Exponencial(m),
     con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la varianza de la Weibull.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de  una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la desviación típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio  Exponencial(m), con m>0. Llamando a
     `random_exp2' con un segundo argumento <k>, se simulará una
     muestra aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, `erf',
     de Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Véase también `erf'.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     `cdf_lognormal'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Lognormal(m,s), con
     s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Lognormal(m,s),
     con s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Lognormal(m,s), con s>0. Llamando a
     `random_lognormal' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Véase `random_normal' para más detalles.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_gamma'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gamma(a,b), con a,b>0. Llamando a
     `random_gamma' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación es una combinación de dos
     procedimientos, según sea el valor del parámetro <a>:

     Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979). <Some simple gamma
     variate generators>. Appl. Stat., 28, 3, 290-295.

     Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974). <Computer methods
     for sampling from gamma, beta, poisson and binomial
     distributions>. Computing, 12, 223-246.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_beta'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de  una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Beta(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0. Llamando a
     `random_beta' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño  <n>.

     El algoritmo de simulación es el decrito en Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  Uniforme Continua(a,b), con a<b. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  Uniforme Continua(a,b),
     con a<b. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria  Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de  `cdf_continuous_uniform'. El argumento <q> debe ser un número
     de [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Uniforme Continuo(a,b), con a<b.
     Llamando a `random_continuous_uniform' con un tercer argumento
     <n>, se simulará una muestra aleatoria de tamaño  <n>.

     Esta función es una aplicación directa de la función  `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_logistic'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de  una variable aleatoria Logística(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Logística(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Logístico(a,b), con b>0. Llamando a
     `random_logistic' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_pareto'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Pareto(a,b), con
     a>1,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Pareto(a,b),
     con a>2,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Pareto(a,b), con a>2,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Pareto(a,b), con a>0,b>0. Llamando a
     `random_pareto' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_weibull'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Weibull(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Weibull(a,b),
     con a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Weibull(a,b), con a,b>0. Llamando a
     `random_weibull' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la densidad de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la
     distribución de la Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_rayleigh'. El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en los cuantiles
     de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de  una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     Weibull.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de  una variable aleatoria de Rayleigh(b),
     con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio  Rayleigh(b), con b>0. Llamando a
     `random_rayleigh' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_laplace'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Laplace(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Laplace(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Laplace(a,b), con b>0. Llamando a
     `random_laplace' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_cauchy'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Cauchy(a,b), con b>0. Llamando a
     `random_cauchy' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_gumbel'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     donde el símbolo `%gamma' representa la constante de
     Euler-Mascheroni. Véase también `%gamma'.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Gumbel(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     donde `zeta' representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gumbel(a,b), con b>0. Llamando a
     `random_gumbel' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: Funciones y variables para distribuciones discretas,  Prev: Funciones y variables para distribuciones continuas,  Up: distrib

48.3 Funciones y variables para distribuciones discretas
========================================================

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0<p<1 y n entero positivo; en otras palabras, se trata de la
     inversa de  `cdf_binomial'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial  Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio  Binomial(n,p), con 0<p<1 y n entero
     positivo. Llamando a  `random_binomial' con un tercer argumento
     <m>, se simulará una muestra aleatoria de tamaño  <m>.

     El algoritmo de simulación es el descrito en Kachitvichyanukul, V.
     y Schmeiser, B.W. (1988) <Binomial Random Variate Generation>.
     Communications of the ACM, 31, Feb., 216.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     `cdf_poisson'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de  una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de  una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio  Poisson(m), con m>0. Llamando a
     `random_poisson' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo de simulación es el descrito en Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>. ACM Trans. Math. Software, 8, 2,
     June,163-179.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la función de
     probabilidad de la binomial.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_bernoulli'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de  una variable aleatoria de Bernoulli(p), con
     0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     binomial.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de  una variable aleatoria de Bernoulli(p),
     con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la binomial.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de  una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la binomial.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la binomial.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la binomial.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio  Bernoulli(p), con 0<p<1. Llamando a
     `random_bernoulli' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Es aplicación directa de la función `random' de Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_geometric'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_geometric (<p>)
     Devuelve la media de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0<p<1. Llamando a
     `random_geometric' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     El algoritmo está basado en la simulación de ensayos de Bernoulli.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de  `cdf_discrete_uniform'. El argumento <q> debe ser
     un número de [0,1]. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de  una variable aleatoria Uniforme Discreta(n),
     con n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio  Uniforme Discreto(n), con n entero
     positivo. Llamando a  `random_discrete_uniform' con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Se trata de una aplicación directa de la función `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     `cdf_hypergeometric'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de  una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2. Llamando a
     `random_hypergeometric' con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño  <m>.

     Algoritmo descrito en Kachitvichyanukul, V., Schmeiser, B.W.
     (1985) <Computer generation of hypergeometric random variates.>
     Journal of Statistical Computation and Simulation 22, 127-145.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288
          (%i3) float(%);
          (%o3)              .006238937377929687

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 y n entero positivo; en otras palabras,
     se trata de la inversa de  `cdf_negative_binomial'. El argumento
     <q> debe ser un número de [0,1]. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     binomial negativa  NB(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0<p<1 y n
     entero positivo. Llamando a  `random_negative_binomial' con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Algoritmo descrito en Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>. Springer Verlag, p. 480.

     Para hacer uso de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: draw,  Next: drawdf,  Prev: distrib,  Up: Top

49 draw
*******

* Menu:

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::


File: maxima.info,  Node: Introducción a draw,  Next: Funciones y variables para draw,  Prev: draw,  Up: draw

49.1 Introducción a draw
========================

`draw' es un interfaz para comunicar Maxima con Gnuplot.

   Tres son las funciones principales a utilizar a nivel de Maxima:
`draw2d', `draw3d' y `draw'.

   Sígase este enlace para ver ejemplos más elaborados de este paquete:

   `http://www.telefonica.net/web2/biomates/maxima/gpdraw'

   Se necesita tener instalado Gnuplot 4.2 para ejecutar este paquete.


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

49.2 Funciones y variables para draw
====================================

49.2.1 Escenas
--------------

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos. Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha. Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: `bars', `ellipse', `explicit', `image', `implicit',
     `label', `parametric', `points', `polar', `polygon',
     `quadrilateral', `rectangle', `triangle', `vector' y `geomap'
     (este último definido en el paquete `worldmap').

     Véanse también `draw' y `draw2d'.

     Para utilizar este objecto, ejecútese primero `load(draw)'.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos. Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha. Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: `cylindrical', `elevation_grid', `explicit',
     `implicit', `label', `mesh', `parametric', `parametric_surface',
     `points', `quadrilateral', `spherical', `triangle', `tube',
     `vector' y `geomap' (este último definido en el paquete
     `worldmap').

     Véanse también `draw' y `draw3d'.

     Para utilizar este objeto, ejecútese primero `load(draw)'.

49.2.2 Funciones
----------------

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Representa gráficamente una serie de escenas; sus argumentos son
     objetos `gr2d' y/o `gr3d', junto con algunas opciones, o listas de
     escenas y opciones.  Por defecto, las escenas se representan en
     una columna.

     La función `draw' acepta las siguientes opciones globales:
     `terminal', `columns', `dimensions', `file_name' y `delay'.

     Las funciones `draw2d' y `draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Véanse también `gr2d' y `gr3d'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también `gr2d', `gr3d', `draw2d' y `draw3d'.

 -- Función: draw2d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr2d'.

 -- Función: draw3d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr3d'.

 -- Función: draw_file (<Opción gráfica>, ..., <Opción gráfica>, ...)
     Almacena el gráfico actual en un fichero. Las opciones gráficas que
     acepta son: `terminal', `dimensions', `file_name' y
     `background_color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* dibujo en pantalla */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $

 -- Función: multiplot_mode (<term>)
     Esta función permite a Maxima trabajar en modo de gráficos
     múltiples en una sola ventana del terminal <term>; argumentos
     válidos para esta función son `screen', `wxt', `aquaterm' y `none'.

     Cuando el modo de gráficos múltiples está activo, cada llamada a
     `draw' envía un nuevo gr'afico a la misma ventana, sin borrar los
     anteriores.  Para desactivar el modo de gráficos múltiples
     escríbase `multiplot_mode(none)'.

     Cuando el modo de gráficos múltiples está activo, la opción global
     `terminal' se bloquea; para desbloquearla y cambiar de terminal es
     necesario desactivar previamente el modo de gráficos múltiples.

     Este modo de trabajo no funciona en plataformas Windows.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$

 -- Función: set_draw_defaults (<Opción gráfica>, ..., <Opción
          gráfica>, ...)
     Establece las opciones gráficas de usuario. Esta función es útil
     para dibujar varios gráficos con las mismas opciones. Llamando a
     la función sin argumentos se borran las opciones de usuario por
     defecto.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* dibujo con opciones de usuario */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* dibujo con opciones por defecto */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     Para utilizar esta función, ejecútese primero `load(draw)'.

49.2.3 Opciones gráficas
------------------------

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     `adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo `explicit' en
     2d.

 -- Opción gráfica: axis_3d
     Valor por defecto: `true'

     Cuando `axis_3d' vale `true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y
     `axis_right' for axis in 2d.

 -- Opción gráfica: axis_bottom
     Valor por defecto: `true'

     Cuando `axis_bottom' vale `true', el eje inferior permanece
     visible en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_left',  `axis_top', `axis_right' y `axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: `true'

     Cuando `axis_left' vale `true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_top', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: `true'

     Cuando `axis_right' vale `true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y `axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: `true'

     Cuando `axis_top' vale `true', el eje superior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: background_color
     Valor por defecto: `white'

     Establece el color de fondo en los terminales `gif', `png', `jpg'
     y `gif'. El color de fondo por defecto es blanco.

     Véase también `color'.

 -- Opción gráfica: border
     Valor por defecto: `true'

     Cuando `border' vale `true', los bordes de los polígonos se
     dibujan de acuerdo con `line_type' y `line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: cbrange
     Valor por defecto: `auto'

     Cuando `cbrange' vale `auto', el rango de los valores que se
     colorean cuando `enhanced3d' es diferente de `false' se calcula
     automáticamente. Valores fuera del rango utilizan el color del
     valor extremo más cercano.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbrange'
     no tiene efecto alguno.

     Si el usuario quiere especificar un intervalo para los valores a
     colorear, éste debe expresarse como una lista de Maxima, como en
     `cbrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d' y `cbtics'.

 -- Opción gráfica: cbtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas en la escala de color cuando la opción `enhanced3d' sea
     diferente de `false'.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `cbtics'
     no tiene efecto alguno.

     Véase `xtics' para una descripción completa.

     Ejemplo :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.

 -- Opción gráfica: color
     Valor por defecto: `black'

     `color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: `white', `black', `gray0',
     `grey0', `gray10', `grey10', `gray20', `grey20', `gray30',
     `grey30', `gray40', `grey40', `gray50', `grey50', `gray60',
     `grey60', `gray70', `grey70', `gray80', `grey80', `gray90',
     `grey90', `gray100', `grey100', `gray', `grey', `light_gray',
     `light_grey', `dark_gray', `dark_grey', `red', `light_red',
     `dark_red', `yellow', `light_yellow', `dark_yellow', `green',
     `light_green', `dark_green', `spring_green', `forest_green',
     `sea_green', `blue', `light_blue', `dark_blue', `midnight_blue',
     `navy', `medium_blue', `royalblue', `skyblue', `cyan',
     `light_cyan', `dark_cyan', `magenta', `light_magenta',
     `dark_magenta', `turquoise', `light_turquoise', `dark_turquoise',
     `pink', `light_pink', `dark_pink', `coral', `light_coral',
     `orange_red', `salmon', `light_salmon', `dark_salmon',
     `aquamarine', `khaki', `dark_khaki', `goldenrod',
     `light_goldenrod', `dark_goldenrod', `gold', `beige', `brown',
     `orange', `dark_orange', `violet', `dark_violet', `plum' y
     `purple'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato `"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también `fill_color'.

 -- Opción gráfica: colorbox
     Valor por defecto: `true'

     Cuando `colorbox' vale `true', se dibuja una escala de colores sin
     título al lado de los objetos `image' en 2D o de objetos
     coloreados en 3D. Cuando `colorbox' vale `false', no se presenta
     la escala de colores. Cuando `colorbox' es una cadena de
     caracteres, se mostrará la escala de colores con un título.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Escala de colores e imágenes.

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Escala de colores y objeto 3D coloreado.

          (%i1) load(draw)$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     Véase también `palette'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     `columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opción gráfica: contour
     Valor por defecto: `none'

     La opción `contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * `none': no se dibujan líneas de nivel.

        * `base': las líneas de nivel se proyectan sobre el plano xy.

        * `surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * `both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * `map': las líneas de nivel se proyectan sobre el plano xy y
          el punto de vista del observador se coloca perpendicularmente
          a él.


     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de
     nivel. A `contour_levels' se le puede asignar un número entero
     positivo, una lista de tres números o un conjunto numérico
     arbitrario:

        * Si a `contour_levels' se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales. Por defecto, se dibujaán cinco isolíneas.

        * Si a `contour_levels' se le asigna una lista de tres números
          de la forma `[inf,p,sup]', las isolíneas se dibujarán desde
          `inf' hasta `sup' en pasos de amplitud `p'.

        * Si a `contour_levels' se le asigna un conjunto de números de
          la forma `{n1, n2, ...}', entonces se dibujarán las isolíneas
          correspondientes a los niveles `n1', `n2', ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas. El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour'.

 -- Opción gráfica: data_file_name
     Valor por defecto: `"data.gnuplot"'

     `data_file_name' es el nombre del fichero que almacena la
     información numérica que necesita Gnuplot para crear el gráfico
     solicitado.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Véase ejemplo en `gnuplot_file_name'.


 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también `terminal', `dimensions'.

 -- Opción gráfica: dimensions
     Valor por defecto: `[600,500]'

     Dimensiones del terminal de salida. Su valor es una lista formada
     por el ancho y el alto. El significado de estos dos números
     depende del terminal con el que se esté trabajando.

     Con los terminales `gif', `animated_gif', `png', `jpg', `svg',
     `screen', `wxt' y `aquaterm', los enteros representan números de
     puntos en cada dirección. Si no son enteros se redondean.

     Con los terminales `eps', `eps_color', `pdf' y `pdfcairo', los
     números representan centésimas de cm, lo que significa que, por
     defecto, las imágenes en estos formatos tienen 6 cm de ancho por 5
     cm de alto.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplos:

     La opción `dimensions' aplicada a un fichero de salida y al lienzo
     wxt.

          (%i1) load(draw)$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     La opción `dimensions' aplicada a una salida eps.  En este caso
     queremos un fichero eps con dimensiones A4.

          (%i1) load(draw)$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $

 -- Opción gráfica: enhanced3d
     Valor por defecto: `none'

     Cuando `enhanced3d' vale `none', las superficies no se colorean en
     escenas 3D.  Para obtener una superficie coloreada se debe asignar
     una lista a la opción `enhanced3d', en la que el primer elemento
     es una expresión y el resto son los nombres de las variables o
     parámetros utilizados en la expresión.  Una lista tal como
     `[f(x,y,z), x, y, z]' significa que al punto `[x,y,z]' de la
     superficie se le asigna el número `f(x,y,z)', el cual será
     coloreado de acuerdo con el valor actual de `palette'.  Para
     aquellos objetos gráficos 3D definidos en términos de parámetros,
     es posible definir el número de color en términos de dichos
     parámetros, como en `[f(u), u]', para los objetos `parametric' y
     `tube', o `[f(u,v), u, v]', para el objeto `parametric_surface'.
     Mientras que todos los objetos 3D admiten el modelo basado en
     coordenadas absolutas, `[f(x,y,z), x, y, z]', solamente dos de
     ellos, esto es `explicit' y `elevation_grid', aceptan también el
     modelo basado en las coordenadas `[x,y]', `[f(x,y), x, y]'. El
     objeto 3D `implicit' acepta solamente el modelo `[f(x,y,z), x, y,
     z]'. El objeto `points' también acepta el modelo `[f(x,y,z), x, y,
     z]', pero cuando los puntos tienen naturaleza cronológica también
     admite el modelo `[f(k), k]', siendo `k' un parámetro de orden.

     Cuando a `enhanced3d' se le asigna algo diferente de `none', se
     ignoran las opciones `color' y `surface_hide'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     A fin de mantener compatibilidad con versiones anteriores,
     `enhanced3d = false' es equivalente a `enhanced3d = none' y
     `enhanced3d = true' es equivalente a `enhanced3d = [z, x, y, z]'.
     Si a `enhanced3d' se le asigna una expresión, sus variables deben
     ser las mismas utilizadas en la definición de la superficie. Esto
     no es necesario cuando se utilizan listas.

     Sobre la definición de paletas, véase `palette'.

     Ejemplos:

     Objeto `explicit' con coloreado definido por el modelo `[f(x,y,z),
     x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto `explicit' con coloreado definido por el modelo `[f(x,y),
     x, y]'.  Los nombres de las variables definidas en las listas
     pueden ser diferentes de aquellas utilizadas en las definiciones
     de los objetos gráficos 3D; en este caso, `r' corresponde a `x' y
     `s' a `y'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto `parametric' con coloreado definido por el modelo
     `[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     Objeto `parametric' con coloreado definido por el modelo `[f(u),
     u]'.  En este caso, `(u-1)^2' es una simplificación de
     `[(u-1)^2,u]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     Objeto `elevation_grid' con coloreado definido por el modelo
     `[f(x,y), x, y]'.

          (%i1) load(draw)$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     Objeto `tube' con coloreado definido por el modelo `[f(x,y,z), x,
     y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     Objeto `tube' con coloreado definido por el modelo `[f(u), u]'.
     En este caso, `enhanced3d = -a' puede ser una simplificación de
     `enhanced3d = [-foo,foo]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   tube_extremes = [open, closed],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     Objetos `implicit' y `points' con coloreado definido por el modelo
     `[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     cuando los puntos tienen naturaleza cronológica también se admite
     el modelo `[f(k), k]', siendo `k' un parámetro de orden.

          (%i1) load(draw)$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $

 -- Opción gráfica: error_type
     Valor por defecto: `y'

     Dependiendo de su valor, el cual puede ser `x', `y' o `xy', el
     objeto gráfico `errors' dibujará puntos con barras de error
     horizontales, verticales, o ambas. Si `error_type=boxes', se
     dibujarán cajas en lugar de cruces.

     Véase también `errors'.

 -- Opción gráfica: file_name
     Valor por defecto: `"maxima_out"'

     `file_name' es el nombre del fichero en el que los terminales
     `png', `jpg', `gif', `eps', `eps_color', `pdf', `pdfcairo' y `svg'
     guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también `terminal', `dimensions'.

 -- Opción gráfica: fill_color
     Valor por defecto: `"red"'

     `fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase `color' para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     `fill_density' es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por `fill_color') en los
     objetos `bars'.

     Véase `bars' para ejemplos.

 -- Opción gráfica: filled_func
     Valor por defecto: `false'

     La opción `filled_func' establece cómo se van a rellenar las
     regiones limitadas por funciones. Si `filled_func' vale `true', la
     región limitada por la función definida en el objeto `explicit' y
     el borde inferior del la ventana gráfica se rellena con
     `fill_color'.  Si `filled_func' guarda la expresión de una
     función, entonces la región limitada por esta función y la
     definida en el objeto `explicit' será la que se rellene. Por
     defecto, las funciones explícitas no se rellenan.

     Esta opción sólo afecta al objeto gráfico bidimensional `explicit'.

     Ejemplo:

     Región limitada por un objeto `explicit' y el borde inferior de la
     ventana gráfica.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto `explicit' y la función definida en
     la opción `filled_func'. Nótese que la variable en `filled_func'
     debe ser la misma que la utilizada en `explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también `fill_color' y `explicit'.

 -- Opción gráfica: font
     Valor por defecto: `""' (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal. Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font_size'.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía. A
     continuación un breve resumen:

        * x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico. Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú
          de la ventana gráfica.

        * png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno `GDFONTPATH'; en
          tal caso sólo es necesario darle a la opción `font' el nombre
          de la fuente. También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción `font' se le puede dar la ruta completa al
          fichero de la fuente:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno `GDFONTPATH' almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción `font' sólo el nombre de la fuente:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Las fuentes estándar de Postscript son:
          `"Times-Roman"', `"Times-Italic"', `"Times-Bold"',
          `"Times-BoldItalic"', `"Helvetica"', `"Helvetica-Oblique"',
          `"Helvetica-Bold"', `"Helvetic-BoldOblique"', `"Courier"',
          `"Courier-Oblique"', `"Courier-Bold"' y
          `"Courier-BoldOblique"'.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Utiliza las mismas fuentes que Postscript.

        * pdfcairo: Utiliza las mismas fuentes que wxt.

        * wxt: La librería pango encuentra las fuentes por medio de la
          utilidad `fontconfig'.

        * aqua: La fuente por defecto es `"Times-Roman"'.

     La documentación de gnuplot es una importante fuente de
     información sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 12

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal. Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico. `font_size' sólo se activa cuando la opción `font'
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font'.

 -- Opción gráfica: gnuplot_file_name
     Valor por defecto: `"maxout.gnuplot"'

     `gnuplot_file_name' es el nombre del fichero que almacena las
     instrucciones a ser procesadas por Gnuplot.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     Véase también `data_file_name'.


 -- Opción gráfica: grid
     Valor por defecto: `false'

     Cuando `grid' vale `true', se dibujará una rejilla sobre el plano
     <xy>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     `head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también `head_both', `head_length' y `head_type'.

 -- Opción gráfica: head_both
     Valor por defecto: `false'

     Cuando `head_both' vale `true', los vectores se dibujan
     bidireccionales.  Si vale `false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también `head_length', `head_angle' y `head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     `head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: `filled'

     `head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores. Los valores posibles para esta opción
     son: `filled' (flechas cerradas y rellenas), `empty' (flechas
     cerradas pero no rellenas) y `nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_length'.

 -- Opción gráfica: ip_grid
     Valor por defecto: `[50, 50]'

     `ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: `[5, 5]'

     `ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: key
     Valor por defecto: `""' (cadena vacía)

     `key' es la clave de una función en la leyenda. Si `key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric', y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: label_alignment
     Valor por defecto: `center'

     `label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia. Los
     valores posibles para esta opción son: `center', `left' y `right'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también `label_orientation' y `color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: `horizontal'

     `label_orientation' se utiliza para especificar la orientación de
     las etiquetas. Los valores posibles para esta opción son:
     `horizontal' y `vertical'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete `draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también `label_alignment' y `color'.

 -- Opción gráfica: line_type
     Valor por defecto: `solid'

     `line_type' indica cómo se van a dibujar las líneas; valores
     posibles son `solid' y `dots'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric' y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_width'.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     `line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points' y `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_type'.

 -- Opción gráfica: logcb
     Valor por defecto: `false'

     Cuando `logcb' vale `true', la escala de colores se dibuja
     logarítmicamente.

     Cuando `enhanced3d' o `colorbox' vale `false', la opción `logcb'
     no tiene efecto alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     Véanse también `enhanced3d', `colorbox' y `cbrange'.

 -- Opción gráfica: logx
     Valor por defecto: `false'

     Cuando `logx' vale `true', el eje <x> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también `logy' y `logz'.

 -- Opción gráfica: logy
     Valor por defecto: `false'

     Cuando `logy' vale `true', el eje <y> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también `logx' y `logz'.

 -- Opción gráfica: logz
     Valor por defecto: `false'

     Cuando `logz' vale `true', el eje <z> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también `logx' y `logy'.

 -- Opción gráfica: nticks
     Valor por defecto: 29

     En 2d, `nticks' es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas. También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' y `polar'.

        * `gr3d': `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: palette
     Valor por defecto: `color'

     `palette' indica cómo transformar los valores reales de una matriz
     pasada al objeto `image' en componentes cromáticas.

     `palette' es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

 -- Opción gráfica: point_size
     Valor por defecto: 1

     `point_size' establece el tamaño de los puntos dibujados. Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     `point_type' se le ha dado el valor `dot'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     `point_type' indica cómo se van a dibujar los puntos aislados. Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: `$none' (-1), `dot'
     (0), `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) y `filled_diamant'
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: `false'

     Cuando `points_joined' vale `true', los puntos se unen con
     segmentos; si vale `false', se dibujarán puntos aislados. Un
     tercer valor posible para esta opción gráfica es `impulses'; en
     tal caso, se dibujarán segmentos verticales desde los puntos hasta
     el eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: proportional_axes
     Valor por defecto: `none'

     Cuando `proportional_axes' es igual a `xy' o `xy', una escena 2D o
     3D se dibujará con los ejes proporcionales a sus longitudes
     relativas.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción sólo funciona con Gnuplot versión 4.2.6 o superior.

     Ejemplos:

     Gráfico en 2D.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1))


 -- Opción gráfica: surface_hide
     Valor por defecto: `false'

     Cuando `surface_hide' vale `true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: terminal
     Valor por defecto: `screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: `screen' (por defecto), `png', `jpg', `eps', `eps_color',
     `pdf', `pdfcairo', `gif', `animated_gif', `wxt', `svg' y
     `aquaterm'.

     Los terminales `screen', `wxt' y `aquaterm' también se pueden
     definir como una lista de dos elementos: el propio nombre del
     terminal y un número entero no negativo. De esta forma se pueden
     abrir varias ventanas al mismo tiempo, cada una de ellas con su
     número correspondiente. Esta modalidad no funciona en plataformas
     Windows.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     pdfcairo necesita Gnuplot 4.3.  `pdf' necesita que Gnuplot haya
     sido compilado con la opción `--enable-pdf' y libpdf debe estar
     instalado
     (`http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/').

     Ejemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Ventanas múltiples.
          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     Un fichero gif animado.
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opción `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también `file_name', `pic_width', `pic_height' y `delay'.

 -- Opción gráfica: title
     Valor por defecto: `""' (cadena vacía)

     La opción `title' almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: transform
     Valor por defecto: `none'

     Si `transform' vale `none', el espacio no sufre transformación
     alguna y los objetos gráficos se representan tal cual se definen.
     Si es necesario transformar el espacio, se debe asignar una lista
     a la opción `transform'. En caso de una escena 2D, la lista toma
     la forma `[f1(x,y), f2(x,y), x, y]'.  En caso de una escena 3D, la
     lista debe ser de la forma `[f1(x,y,z), f2(x,y,z), f3(x,y,z), x,
     y, z]'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     Ejemplos:

     Rotación en 2D.

          (%i1) load(draw)$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Traslación en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$

 -- Opción gráfica: transparent
     Valor por defecto: `false'

     Cuando `transparent' vale `true', las regiones internas de los
     polígonos se rellenan de acuerdo con `fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: tube_extremes
     Valor por defecto: `[open, open]'

     Una lista de dos elementos, `open' y `closed', indicando si los
     extremos de un objeto gráfico `tube' permanece abiertos o si deben
     ser cerrados. Por defecto, ambos extremos se dejan abiertos.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  tube_extremes = [open, closed],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$


 -- Opción gráfica: unit_vectors
     Valor por defecto: `false'

     Cuando `unit_vectors' vale `true', los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales. Cuando `unit_vectors' vale `false', los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: user_preamble
     Valor por defecto: `""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción `plot' o `splot'.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     El terminal dumb no está soportado por el paquete `draw', pero es
     posible activarlo haciendo uso de la opción `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opción gráfica: view
     Valor por defecto: `[60,30]'

     Un par de ángulos, medidos en grados, indicando la direcciÃ³n del
     observador en una escena 3D. El primer ángulo es la rotación
     vertical alrededor del eje <x>, dentro del intervalo [0, 180].  El
     segundo es la rotación horizontal alrededor del eje <z>, dentro
     del intervalo [0, 360].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(view = [170, 360],
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     `x_voxel' es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional. También se utiliza como opción del objeto gráfico
     `region'.

 -- Opción gráfica: xaxis
     Valor por defecto: `false'

     Si `xaxis' vale `true', se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también `xaxis_width', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_color
     Valor por defecto: `"black"'

     `xaxis_color' especifica el color para el eje <x>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_type'.

 -- Opción gráfica: xaxis_secondary
     Valor por defecto: `false'

     Si `xaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <x> secundario, el cual se
     dibuja en la parte superior de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     Véanse también `xrange_secondary', `xtics_secondary',
     `xtics_rotate_secondary', `xtics_axis_secondary' y
     `xaxis_secondary'.


 -- Opción gráfica: xaxis_type
     Valor por defecto: `dots'

     `xaxis_type' indica cómo se debe dibujar el eje <x>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_color'.

 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     `xaxis_width' es el ancho del eje <x>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también `xaxis', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `xlabel' almacena una cadena con la etiqueta del eje
     <x>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también `ylabel' y `zlabel'.

 -- Opción gráfica: xrange
     Valor por defecto: `auto'

     Cuando `xrange' vale `auto', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en `xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: xrange_secondary
     Valor por defecto: `auto'

     Cuando `xrange_secondary' vale `auto', el rango del eje <x>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <x>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `xrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véanse también `xrange', `yrange', `zrange' y `yrange_secondary'.

 -- Opción gráfica: xtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        * Cuando a `xtics' se le da el valor <auto>, las marcas se
          dibujarán de forma automática.

        * Cuando a `xtics' se le da el valor <none>, no habrá marcas en
          los ejes.

        * Cuando a `xtics' se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        * Cuando a `xtics' se le da una lista de longitud tres de la
          forma `[start,incr,end]', las marcas se dibujarán desde
          `start' hasta `end' a intervalos de longitud `incr'.

        * Cuando a `xtics' se le da un conjunto de números de la forma
          `{n1, n2, ...}', las marcas se dibujarán exactamente en los
          valores `n1', `n2', ...

        * Cuando a `xtics' se le da un conjunto de pares de la forma
          `{["label1", n1], ["label2", n2], ...}', las marcas
          correspondientes a los valores `n1', `n2', ... se etiquetarán
          con `"label1"', `"label2"', ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: xtics_axis
     Valor por defecto: `false'

     Si `xtics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: `false'

     Si `xtics_rotate' vale `true', las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate_secondary
     Valor por defecto: `false'

     Si `xtics_rotate_secondary' vale `true', las marcas del eje <x>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: xtics_secondary_axis
     Valor por defecto: `false'

     Si `xtics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <x> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     `xu_grid' es el número de coordenadas de la primera variable (`x'
     en superficies explcítas y `u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `yv_grid'.

 -- Opción gráfica: xy_file
     Valor por defecto: `""' (cadena vacía)

     `xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'. Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Graphic option: xyplane
     Valor por defecto: `false'

     Coloca el plano-xy en escenas 3D. Si `xyplane' vale `false', el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     `y_voxel' es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional. También se utiliza como opción del objeto gráfico
     `region'.

 -- Opción gráfica: yaxis
     Valor por defecto: `false'

     Si `yaxis' vale `true', se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también `yaxis_width', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_color
     Valor por defecto: `"black"'

     `yaxis_color' especifica el color para el eje <y>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_type'.

 -- Opción gráfica: yaxis_secondary
     Valor por defecto: `false'

     Si `yaxis_secondary' vale `true', los valores de las funciones se
     pueden representar respecto del eje <y> secundario, el cual se
     dibuja al lado derecho de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     Véanse también `yrange_secondary', `ytics_secondary',
     `ytics_rotate_secondary' y `ytics_axis_secondary'.


 -- Opción gráfica: yaxis_type
     Valor por defecto: `dots'

     `yaxis_type' indica cómo se debe dibujar el eje <y>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_color'.

 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     `yaxis_width' es el ancho del eje <y>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también `yaxis', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: ylabel
     Valor por defecto: `""' (cadena vacía)

     La opción `ylabel' almacena una cadena con la etiqueta del eje
     <y>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también `xlabel' y `zlabel'.

 -- Opción gráfica: yrange
     Valor por defecto: `auto'

     Cuando `yrange' vale `auto', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en `yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `zrange'.

 -- Opción gráfica: yrange_secondary
     Valor por defecto: `auto'

     Cuando `yrange_secondary' vale `auto', el rango del eje <y>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <y>
     secundario, éste debe expresarse como una lista de Maxima, como en
     `yrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     Véanse también `xrange', `yrange' y `zrange'.

 -- Opción gráfica: ytics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics_axis
     Valor por defecto: `false'

     Si `ytics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: `false'

     Si `ytics_rotate' vale `true', las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate_secondary
     Valor por defecto: `false'

     Si `ytics_rotate_secondary' vale `true', las marcas del eje <y>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_secondary
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y> secundario.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ytics_secondary_axis
     Valor por defecto: `false'

     Si `ytics_secondary_axis' vale `true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <y> secundario, si vale `false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     `yv_grid' es el número de coordenadas de la segunda variable (`y'
     en superficies explcítas y `v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `xu_grid'.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     `z_voxel' es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: zaxis
     Valor por defecto: `false'

     Si `zaxis' vale `true', se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también `zaxis_width', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_color
     Valor por defecto: `"black"'

     `zaxis_color' especifica el color para el eje <z>. Véase `color'
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_type'.

 -- Opción gráfica: zaxis_type
     Valor por defecto: `dots'

     `zaxis_type' indica cómo se debe dibujar el eje <z>; valores
     admisibles son `solid' y `dots'.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_color'.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     `zaxis_width' es el ancho del eje <z>.  Su valor debe ser un
     número positivo. Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también `zaxis', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `zlabel' almacena una cadena con la etiqueta del eje
     <z>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también `xlabel' y `ylabel'.

 -- Opción gráfica: zrange
     Valor por defecto: `auto'

     Cuando `zrange' vale `auto', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en `zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `yrange'.

 -- Opción gráfica: ztics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ztics_axis
     Valor por defecto: `false'

     Si `ztics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: `false'

     Si `ztics_rotate' vale `true', las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

49.2.4 Objetos gráficos
-----------------------

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     `bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' dibuja barras
     centradas en los valores <x1>, <x2>, ... de alturas <h1>, <h2>, ...
     y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `key', `fill_color', `fill_density' y `line_width'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     `cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)'
     dibuja la función `<radius>(<z>,<azi>)' definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz>
     hasta <maxz> y el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: elevation_grid (<mat>,<x0>,<y0>,<width>,<height>)
     Dibuja la matriz <mat> en 3D. Los valores <z> se toman de <mat>,
     las abscisas van desde <x0> hasta <x0> + <width> y las ordenadas
     desde <y0> hasta <y0> + <height>. El elemento a(1,1) se proyecta
     sobre el punto (x0,y0+height), a(1,n) sobre (x0+width,y0+height),
     a(m,1) sobre (x0,y0) y a(m,n) sobre (x0+width,y0).

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `key', `enhanced3d' y `color'.

     En versiones antiguas de Maxima, `elevation_grid' se llamaba
     `mesh'.  Véase también `mesh'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);


 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' dibuja una elipse
     de centro `[<xc>, <yc>]' con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `transparent', `fill_color', `border', `line_width',
     `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: errors ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja puntos con barras de error asociadas horizontales,
     verticales o de ambos tipos, según sea el valor de la opción
     `error_type'.

     2D

     Si `error_type=x', los argumentos a `errors' deben ser de la forma
     `[x,y,xdelta]' o `[x,y,xlow,xhigh]'. Si `error_type=y', los
     argumentos deben ser del tipo `[x,y,ydelta]' o `[x,y,ylow,yhigh]'.
     Si `error_type=xy' o `error_type=boxes', los argumentos deben ser
     de la forma `[x,y,xdelta,ydelta]' o `[x,y,xlow,xhigh,ylow,yhigh]'.

     Véase también `error_type'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `error_type', `points_joined', `line_width', `key', `line_type',
     `color', `fill_density', `xaxis_secondary' y `yaxis_secondary'.

     La opción `fill_density' solo es relevante cuando
     `error_type=boxes'.

     Ejemplos:

     Barras de error horizontales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Barras de error horizontales y verticales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));


 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     `explicit (<fcn>,<var>,<minval>,<maxval>)' dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `adapt_depth', `line_width', `line_type', `key',
     `filled_func', `fill_color' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)'
     dibuja la función explícita <fcn>, con la variable `var1' tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d'  y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también `filled_func' para el relleno de curvas.

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     `image (<im>,<x0>,<y0>,<width>,<height>)': dibuja la imagen <im>
     en la región rectangular desde el vértice <(X0,Y0)> hasta el
     `(x0+<width>,y0+<height>)' del plano real. El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo `picture'.

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette',
     que es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete `draw' carga automáticamente el paquete `picture'.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también `make_level_picture', `make_rgb_picture' y
     `read_xpm'.

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image'
     se encuentran ejemplos más elaborados.

 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     `implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' dibuja la
     función implícita <fcn>, con la variable `x' tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde
     <ymin> hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la
     variable <y> tomando valores desde <ymin> hasta <ymax> y la
     variable <z> tomando valores desde <zmin> hasta <zmax>. Este
     objeto está programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key'
     y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Las etiquetas coloreadas sólo trabajan con Gnuplot 4.3. Este es un
     fallo conocido del paquete `draw'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `label_alignment', `label_orientation' y `color'.

     2D

     `label([<string>,<x>,<y>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>,<x>,<y>,<z>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: mesh (<fila_1>,<fila_2>,...)
     Dibuja un enrejado cuadrangular en 3D.

     3D

     El argumento <fila_i> es una lista de <n> puntos en 3D de la forma
     `[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]', siendo todas las filas
     de igual longitud. Todos estos puntos definen una superficie
     arbitraria en 3D.  En cierto sentido, se trata de una
     generalización del objeto `elevation_grid'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `enhanced3d' y
     `transform'.

     Ejemplos:

     Un sencillo ejemplo.

          (%i1) load(draw)$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Dibujando un triángulo en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Dos cuadriláteros.

          (%i1) load(draw)$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key', `color' y `enhanced3d'.

     2D

     `parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' dibuja la
     función paramétrica `[<xfun>,<yfun>]', con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     `parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' dibuja
     la curva paramétrica `[<xfun>,<yfun>,<zfun>]', con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     `parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     dibuja la superficie paramétrica `[<xfun>,<yfun>,<zfun>]', con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
 -- Objeto gráfico: points (<1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Objeto gráfico: points (<2d_xy_array>)
 -- Objeto gráfico: points (<2d_xyz_array>)
     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' y `color'. En modo 3D también se ve afectado por
     `enhanced3d'.

     2D

     `points ([[<x1>,<y1>], [<x2>,<y2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' dibuja los puntos
     `[<x1>,<y1>]', `[<x2>,<y2>]', etc. Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que `points([<y1>,<y2>,...])' dibuja los puntos
     `[1,<y1>]', `[2,<y2>]', etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, `points (<matrix>)' dibuja los puntos
     asociados.

     Si <1d_y_array> es un array lisp de números en 1D, `points
     (<1d_y_array>)' los dibujará asignando las abscisas a números
     enteros consecutivos.  `points (<1d_x_array>, <1d_y_array>)'
     dibuja los puntos cuyas coordenadas se toman de los dos arrays
     pasados como argumentos. Si <2d_xy_array> es un array lisp 2D de
     dos filas, o de dos columnas, `points (<2d_xy_array>)' dibuja los
     correspondientes puntos del plano.

     Ejemplos:

     Dos tipos de argumentos para `points', una lista de pares ordenados
     y dos listas con las coordenadas separadas.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Dibujando impulsos.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array con ordenadas.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Dos arrays con coordenadas separadas.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     Un array 2D de dos columnas.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Dibujando un array rellenado con la función `read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     `points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' dibuja los
     puntos `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]', etc.  Si <matrix>
     es una matriz de tres columnas o de tres filas, `points (<matrix>)'
     dibuja los puntos asociados. Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     En caso de que los argumentos sean arrays lisp, `points
     (<1d_x_array>, <1d_y_array>, <1d_z_array>)' toma las coordenadas
     de los tres arrays unidimensionales. Si <2d_xyz_array> es un array
     2D de tres columnas, o de tres filas, entonces `points
     (<2d_xyz_array>)' dibuja los puntos correspondientes.

     Ejemplos:

     Una muestra tridimensional,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Arrays unidimensionales,
          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Array bidimensional coloreado,
          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Números de colores especificados explícitamente por el usuario.
          (%i1) load(draw)$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     `polar (<radius>,<ang>,<minang>,<maxang>)' dibuja la función
     `<radius>(<ang>)' definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     `polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' o `polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': dibuja en el plano un
     polígono de vértices `[<x1>,<y1>]', `[<x2>,<y2>]', etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Dibuja un cuadrilátero.

     2D

     `quadrilateral ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>],
     [<x4>,<y4>])' dibuja un cuadrilátero de vértices `[<x1>,<y1>]',
     `[<x2>,<y2>]', `[<x3>,<y3>]' y `[<x4>,<y4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     `quadrilateral ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],
     [<x3>,<y3>,<z3>], [<x4>,<y4>,<z4>])' dibuja un cuadrilátero de
     vértices `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]',
     `[<x3>,<y3>,<z3>]' y `[<x4>,<y4>,<z4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `enhanced3d' y
     `transform'.

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     `rectangle ([<x1>,<y1>], [<x2>,<y2>])' dibuja un rectángulo de
     vértices opuestos `[<x1>,<y1>]' y `[<x2>,<y2>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: region
          (<expr>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja una región del plano definida por desigualdades.

     2D <expr> es una expresión formada por desigualdades y los
     operadores lógicos `and', `or' y `not'. La región está acotada por
     el rectángulo definido por [<minval1>, <maxval1>] y [<minval2>,
     <maxval2>].

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `fill_color', `key', `x_voxel' y `y_voxel'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     `spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' dibuja
     la función `<radius>(<azi>,<zen>)' definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi> y el zenit <zen> tomando valores desde <minzen>
     hasta <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: triangle (<punto_1>, <punto_2>, <punto_3>)
     Dibuja un triángulo.

     2D

     `triangle ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>])' dibuja un
     triángulo de vértices `[<x1>,<y1>]', `[<x2>,<y2>]' y `[<x3>,<y3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     `triangle ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>], [<x3>,<y3>,<z3>])'
     dibuja un triángulo de vértices `[<x1>,<y1>,<z1>]',
     `[<x2>,<y2>,<z2>]' y `[<x3>,<y3>,<z3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_type', `line_width', `color', `key', `enhanced3d' y
     `transform'.

 -- Objeto gráfico: tube (<xfun>,<yfun>,<zfun>,<rfun>,<p>,<pmin>,<pmax>)
     Dibuja un tubo en 3D de diámetro variable.

     3D

     `[<xfun>,<yfun>,<zfun>]' es la curva paramétrica de parámetro <p>,
     el cual toma valores entre <pmin> y <pmax>. Se colocan círculos de
     radio <rfun> con sus centros sobre la curva paramétrica y
     perpendiculares a ella.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d', `color' y `tube_extremes'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$


 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' y `color'.

     2D

     `vector ([<x>,<y>], [<dx>,<dy>])' dibuja el vector `[<dx>,<dy>]'
     con origen en `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' dibuja el vector
     `[<dx>,<dy>,<dz>]' con origen en `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$


File: maxima.info,  Node: Funciones y variables para picture,  Next: Funciones y variables para worldmap,  Prev: Funciones y variables para draw,  Up: draw

49.3 Funciones y variables para picture
=======================================

 -- Función: get_pixel (<pic>,<x>,<y>)
     Devuelve el pixel de la imagen <pic>. Las coordenadas <x> e <y>
     van desde 0 hasta `ancho-1' y `alto-1', respectivamente.

 -- Función: make_level_picture (<data>)
 -- Función: make_level_picture (<data>,<width>,<height>)
     Devuelve un objeto `picture' consistente en una imagen de niveles.
     `make_level_picture (<data>)' construye el objeto `picture' a
     partir de la matriz <data>.  `make_level_picture
     (<data>,<width>,<height>)' construye el objeto a partir de una
     lista de números, en cuyo caso deben indicarse el ancho <width> y
     la altura <height> en píxeles.

     El objeto  `picture' devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `level'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros con los valores de los píxeles entre 0 y
          255. El argumento <data> debe contener sólo números entre 0 y
          255; los cantidades negativas se transforman en ceros y las
          que son mayores de 255 se igualan a este número.

     Ejemplo:

     Imagen de niveles a partir de una matriz.
          (%i1) load(draw)$
          (%i2) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o2)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Imagen de niveles a partir de una lista numérica.
          (%i1) load(draw)$
          (%i2) make_level_picture([-2,0,54,%pi],2,2);
          (%o2)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Función: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Devuelve un objeto <picture> conteniendo una imagen en color (RGB).
     Los tres argumentos deben ser imágenes de niveles, para el rojo
     (R), verde (G) y azul (B).

     El objeto  <picture> devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `rgb'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros de <3*ancho*alto> con los valores de los
          píxeles entre 0 y 255. Cada valor de pixel se representa en
          el array con tres números consecutivos (rojo, verde, azul).

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Función: negative_picture (<pic>)
     Devuelve el negativo de la imagen, sea ésta de tipo nivel (<level>)
     o color (<rgb>).

 -- Función: picture_equalp (<x>,<y>)
     Devuelve `true' si los dos argumentos son imágenes idénticas, o
     `false' en caso contrario.

 -- Función: picturep (<x>)
     Devuelve `true' si el argumento es una imagen bien formada, o
     `false' en caso contrario.

 -- Función: read_xpm (<xpm_file>)
     Lee el fichero gráfico en formato xpm y devuelve un objeto
     `picture'.

 -- Función: rgb2level (<pic>)
     Transforma una imagen en color <rgb> a otra de niveles <level>
     promediando los niveles.

 -- Función: take_channel (<im>,<color>)
     Si el argumento <color> es `red', `green' o `blue', la función
     `take_channel' devuelve el canal de color correspondiente de la
     imagen <im>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i6) take_channel(%,'green);  /* simple quote!!! */
          (%o6)           picture(level, 2, 2, {Array:  #(54 23 73 0)})


File: maxima.info,  Node: Funciones y variables para worldmap,  Prev: Funciones y variables para picture,  Up: draw

49.4 Funciones y variables para worldmap
========================================

Este paquete carga automáticamente el paquete `draw'.

49.4.1 Variables y Funciones
----------------------------

 -- Global variable: boundaries_array
     Valor por defecto: `false'

     `boundaries_array' es donde el objeto gráfico `geomap' lee las
     coordenadas de las líneas fronterizas.

     Cada componente de `boundaries_array' es un array de números
     decimales en coma flotante representando las coordenadas que
     definen un segmento poligonal o línea fronteriza.

     Véase también `geomap'.

 -- Función: numbered_boundaries (<nlist>)
     Dibuja una lista de segmentos poligonales (líneas fronterizas),
     etiquetadas con sus números correspondientes (coordenadas de
     `boundaries_array'). Esta función es de mucha ayuda a la hora de
     definir nuevas entidades geográficas.

     Ejemplo:

     Mapa de Europa con las fronteras y costas etiquetadas con su
     componente numérica de `boundaries_array'.
          (%i1) load(worldmap)$
          (%i2) european_borders:
                     region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i3) numbered_boundaries(european_borders)$

 -- Función: make_poly_continent (<continent_name>)
 -- Función: make_poly_continent (<country_list>)
     Construye los polígonos necesarios para dibujar un continente o
     lista de países coloreados.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) /* A continent */
                make_poly_continent(Africa)$
          (%i3) apply(draw2d, %)$
          (%i4) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i5) apply(draw2d, %)$

 -- Función: make_poly_country (<country_name>)
     Construye los polígonos necesarios para dibujar un país coloreado.
     En caso de contener islas, un país tendrá asociados varios
     polígonos.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) make_poly_country(India)$
          (%i3) apply(draw2d, %)$

 -- Función: make_polygon (<nlist>)
     Devuelve un objeto `polygon' a partie de una lista de líneas
     fronterizas y de costas. El argumento <nlist> debe ser una lista
     de componentes de `boundaries_array'.

     Ejemplo:

     La variable Bhutan (Bután) está definida con los números
     fronterizos 171, 173 y 1143, de manera que
     `make_polygon([171,173,1143])' concatena los arrays
     `boundaries_array[171]', `boundaries_array[173]' y
     `boundaries_array[1143]' y devuelve un objeto `polygon' apto para
     ser dibujado por `draw'. A fin de evitar mensajes de errores, los
     arrays deben ser compatibles en el sentido de que dos de ellos
     consecutivos deben tener dos coordenadas comunes en los extremos.
     En este ejemplo, las dos primeras componentes de
     `boundaries_array[171]' son iguales a las dos últimas de
     `boundaries_array[173]', y las dos primeras de
     `boundaries_array[173]' coinciden con las dos primeras de
     `boundaries_array[1143]'; en conclusión, los números de segmentos
     poligonales171, 173 y 1143 (en este orden) son compatibles y el
     polígono coloreado se podrá dibujar.
          (%i1) load(worldmap)$
          (%i2) Bhutan;
          (%o2)                        [[171, 173, 1143]]
          (%i3) boundaries_array[171];
          (%o3) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i4) boundaries_array[173];
          (%o4) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i5) boundaries_array[1143];
          (%o5) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i6) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i7) draw2d(Bhutan_polygon)$

 -- Función: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' totalmente contenidos en el rectángulo de
     vértices (<x1>,<y1>) -superior izquierdo- y (<x2>,<y2>) -inferior
     derecho-.

     Ejemplo:

     Devuelve los números de los segmentos necesarios para dibujar el
     sur de Italia.
          (%i1) load(worldmap)$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$

 -- Función: region_boundaries_plus (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' con al menos un vértice dentro del rectángulo
     definido por los extremos (<x1>,<y1>) -superior izquierdo- y
     (<x2>,<y2>) -inferior derecho-.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) region_boundaries_plus(10.4,41.5,20.7,35.4);
          (%o2) [1060, 1062, 1076, 1835, 1839, 1844, 1846, 1858,
                 1861, 1863, 1864, 1871, 1881, 1888, 1894, 1897]
          (%i3) draw2d(geomap(%))$

49.4.2 Objetos gráficos
-----------------------

 -- Objeto gráfico: geomap (<numlist>)
 -- Objeto gráfico: geomap (<numlist>,<3Dprojection>)
     Dibuja mapas cartográficos en 2D y 3D.

     2D

     Esta función trabaja junto con la variable global
     `boundaries_array'.

     El argumento <numlist> es una lista de números o de listas de
     números. Todos estos números deben ser enteros mayores o iguales
     que cero, representando las componentes del array global
     `boundaries_array'.

     Cada componente de `boundaries_array' es un array de decimales en
     coma flotante, las coordenadas de un segmento poligonal o línea
     fronteriza.

     `geomap (<numlist>)' toma los enteros de sus argumentos y dibuja
     los segmentos poligonales asociados de `boundaries_array'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_width', `line_type' y `color'.

     Ejemplos:

     Un sencillo mapa hecho a mano:
          (%i1) load(worldmap)$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$

     El paquete auxiliar `worldmap' asigna al array global
     `boundaries_array' líneas fronterizas reales en coordenadas
     (longitud, latitud). Estos datos son de dominio público y proceden
     de `http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html'.  El
     paquete `worldmap' también define fronteras de países, continentes
     y líneas costeras a partir de las componentes de
     `boundaries_array' (véase el fichero `share/draw/worldmap.mac'
     para más información). El paquete `worldmap' carga automáticamente
     el paquete `draw'.
          (%i1) load(worldmap)$
          (%i2) c1: gr2d(geomap(Canada,United_States,
                                Mexico,Cuba))$
          (%i3) c2: gr2d(geomap(Africa))$
          (%i4) c3: gr2d(geomap(Oceania,China,Japan))$
          (%i5) c4: gr2d(geomap(France,Portugal,Spain,
                                Morocco,Western_Sahara))$
          (%i6) draw(columns  = 2,
                     c1,c2,c3,c4)$

     `worldmap' se puede utilizar para dibujar países como polígonos.
     En este caso, ya no será necesario hacer uso del objeto gráfico
     `geomap', pero sí de `polygon'. Puesto que en este caso se
     utilizan listas en lugar de arrays, los mapas se reproducirán de
     forma más lenta. Véanse también `make_poly_country' y
     `make_poly_continent' para comprender el siguiente código.
          (%i1) load(worldmap)$
          (%i2) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i3) apply(draw2d, mymap)$

     3D

     `geomap (<numlist>)' proyecta los mapas sobre la esfera de radio 1
     y centro (0,0,0). Es posible cambiar la esfera o el tipo de
     proyección haciendo uso de `geomap (<numlist>,<3Dprojection>)'.

     Proyecciones 3D disponibles:

        * `[spherical_projection,<x>,<y>,<z>,<r>]': proyecta los mapas
          sobre la esfera de radio <r> y centro (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$

        * `[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]': re-proyecta
          mapas esféricos sobre el cilindro de radio <rc> cuyo eje pasa
          a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$

        * `[conic_projection,<x>,<y>,<z>,<r>,<alpha>]': re-proyecta
          mapas esféricos sobre los conos de ángulo <alpha>, cuyos ejes
          pasan a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>). Ambos conos, norte y sur, son tangentes a la
          esfera.
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/geomap'
     hay ejemplos más elaborados.


File: maxima.info,  Node: drawdf,  Next: dynamics,  Prev: draw,  Up: Top

50 drawdf
*********

* Menu:

* Introducción a drawdf::
* Funciones y variables para drawdf::


File: maxima.info,  Node: Introducción a drawdf,  Next: Funciones y variables para drawdf,  Prev: drawdf,  Up: drawdf

50.1 Introducción a drawdf
==========================

La función `drawdf' dibuja el campo de direcciones de una ecuación
diferencial ordinaria de primer orden (EDO) o de un sistema de dos
ecuaciones autónomas de primer orden.

   Puesto que `drawdf' es un paquete adicional, es necesario cargarlo en
memoria ejecutando previamente la instrucción `load(drawdf)'.  `drawdf'
utiliza el paquete `draw', que necesita como mínimo la versión 4.2 de
Gnuplot.

   Para dibujar el campo de direcciones de una EDO, ésta debe
escribirse de la forma
            dy
            -- = F(x,y)
            dx

   y ser la función <F> la que se pase a `drawdf' como argumento.  Si
las variables independiente y dependiente no son <x> e <y>, como en la
ecuación anterior, entonces deben nombrarse de forma explícita en una
lista que se pasará a `drawdf' (ver ejemplos más abajo).

   Para dibujar el campo de direcciones de un conjunto de dos EDOs
autónomas, deben escribirse de la forma
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   y será una lista con las dos funciones <G> y <F> la que se pase a
`drawdf' como argumento. El orden de las funciones es importante; la
primera será la derivada de la abscisa respecto del tiempo y la segunda
la derivada de la ordenada respecto del tiempo.  Si las variables no
son las <x> e <y> habituales, el segundo argumento que se pase a la
función `drawdf' será una lista con los nombres de ambas variables,
primero la correspondiente a las abscisas, seguida de la asociada a las
ordenadas.

   Si sólo se trata de una EDO, `drawdf' admitirá por defecto que `x=t'
y `G(x,y)=1', transformanado la ecuación no autónoma en un sistema de
dos ecuaciones autónomas.


File: maxima.info,  Node: Funciones y variables para drawdf,  Prev: Introducción a drawdf,  Up: drawdf

50.2 Funciones y variables para drawdf
======================================

50.2.1 Funciones
----------------

 -- Función: drawdf (<dydx>, ...options and objects...)
 -- Función: drawdf (<dvdu>, `['<u>,<v>`]', ...opciones y objetos...)
 -- Función: drawdf (<dvdu>, `['<u>,<umin>,<umax>`]',
          `['<v>,<vmin>,<vmax>`]', ...opciones y objetos...)
 -- Función: drawdf (`['<dxdt>,<dydt>`]', ...opciones y objetos...)
 -- Función: drawdf (`['<dudt>,<dvdt>`]', `['<u>,<v>`]', ...opciones y
          objetos...)
 -- Función: drawdf (`['<dudt>,<dvdt>`]', `['<u>,<umin>,<umax>`]',
          `['<v>,<vmin>,<vmax>`]', ...opciones y objetos...)
     La función `drawdf' dibuja un campo de direcciones 2D, incluyendo
     opcionalmente curvas asociadas a soluciones particulares, así como
     otros objeto gráficos del paquete `draw'.

     El primer argumento especifica la(s) derivada(s), el cual debe
     estar formado por una expresión o una lista de dos expresiones.
     <dydx>, <dxdt> y <dydt> son expresiones que dependen de <x> y <y>.
     <dvdu>, <dudt> y <dvdt> son expresiones que dependen de <u> y <v>.

     Si las variables independiente y dependiente no son <x> e <y>, sus
     nombres deben especificarse a continuación de las derivadas, bien
     como una lista de dos nombres, `['<u>,<v>`]', o como dos listas de
     la forma `['<u>,<umin>,<umax>`]' y `['<v>,<vmin>,<vmax>`]'.

     El resto de argumentos son opciones gráficas, objetos gráficos, o
     listas conteniendo elementos de ambos tipos. El conjunto de
     opciones y objetos gráficos soportados por `drawdf' incluye los
     soportados por `draw2d' y `gr2d' del paquete `draw'.

     Los argumentos se iterpretan secuencialmente: las opciones gráficas
     afectan a todos los objetos gráficos que le siguen. Además, los
     objetos gráficos se dibujan en el orden en el que se especifican,
     pudiendo tapar otros gráficos dibujados con anterioridad.  Algunas
     opciones gráficas afectan al aspecto general de la escena.

     Los nuevos objetos gráficos que se definen en `drawdf' son:
     `solns_at', `points_at', `saddles_at', `soln_at', `point_at' y
     `saddle_at'.

     Las nuevas opciones gráficas que se definen en `drawdf' son:
     `field_degree', `soln_arrows', `field_arrows', `field_grid',
     `field_color', `show_field', `tstep', `nsteps', `duration',
     `direction', `field_tstep', `field_nsteps' y `field_duration'.

     Objetos gráficos que se heredan del paquete `draw' incluyen:
     `explicit', `implicit', `parametric', `polygon', `points',
     `vector', `label' y cualesquiera otros soportados por `draw2d' y
     `gr2d'.

     Opciones gráficas que se heredan del paquete `draw' incluyen:
     `points_joined', `color', `point_type', `point_size', `line_width',
     `line_type', `key', `title', `xlabel', `ylabel', `user_preamble',
     `terminal', `dimensions', `file_name' y cualesquiera otros
     soportados por `draw2d' y `gr2d'.

     Véase también `draw2d'.

     Los usuarios de wxMaxima y Imaxima pueden hacer uso también
     `wxdrawdf', que es idéntica a `drawdf', pero que inserta el
     gráfico en el propio documento utilizando la función `wxdraw'.

     Para hacer uso de esta función, ejecútese primero `load(drawdf)'.

     Ejemplos:

          (%i1) load(drawdf)$
          (%i2) drawdf(exp(-x)+y)$        /* default vars: x,y */
          (%i3) drawdf(exp(-t)+y, [t,y])$ /* default range: [-10,10] */
          (%i4) drawdf([y,-9*sin(x)-y/5], [x,1,5], [y,-2,2])$

     A efectos de compatibilidad, `drawdf' acepta la mayor parte de
     parámetros soportados por `plotdf'.

          (%i5) drawdf(2*cos(t)-1+y, [t,y], [t,-5,10], [y,-4,9],
                       [trajectory_at,0,0])$

     `soln_at' y `solns_at' dibujan soluciones particulares que pasen
     por los puntos especificados, utilizando el integrador numérico de
     Runge Kutta de cuarto orden.

          (%i6) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     `field_degree=2' hace que el campo se componga de splines
     cuadráticos basados en las derivadas de primer y segundo orden en
     cada punto de la malla.  `field_grid=['<COLS>,<ROWS>`]' especifica
     el número de columnas y filas a utilizar en la malla.

          (%i7) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       field_degree=2, field_grid=[20,15],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     `soln_arrows=true' añade flechas a las soluciones particulares y,
     por defecto, las borra. También cambia los colores por defecto para
     destacar las curvas de las soluciones particulares.

          (%i8) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       soln_arrows=true,
                       solns_at([0,0.1],[0,-0.1],[0,0]))$

     `duration=40' especifica el intervalo temporal de la integración
     numérica, cuyo valor por defecto es 10. La integración se detendrá
     automáticamente si la solución se aparta mucho de la región a
     dibujar, o si la derivada se vuelve compleja o infinita. Aquí
     también hacemos `field_degree=2' para dibujar splines cuadráticos.
     Las ecuaciones de este ejemplo modelizan un sistema
     depredador-presa.

          (%i9) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                       field_degree=2, duration=40,
                       soln_arrows=true, point_at(1/2,1/2),
                       solns_at([0.1,0.2], [0.2,0.1], [1,0.8], [0.8,1],
                                [0.1,0.1], [0.6,0.05], [0.05,0.4],
                                [1,0.01], [0.01,0.75]))$

     `field_degree='solns' hace que el campo se componga de muchas
     pequeñas soluciones calculadas a partir del Runge Kutta de cuarto
     orden.

          (%i10) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                        field_degree='solns, duration=40,
                        soln_arrows=true, point_at(1/2,1/2),
                        solns_at([0.1,0.2], [0.2,0.1], [1,0.8],
                                 [0.8,1], [0.1,0.1], [0.6,0.05],
                                 [0.05,0.4], [1,0.01], [0.01,0.75]))$

     `saddles_at' trata de linearizar automáticamente la ecuación en
     cada punto de silla y dibujar la solución numérica correspondiente
     a cada vector propio, incluyendo las separatrices. `tstep=0.05'
     establece el salto temporal máximo para el integrador numérico,
     cuyo valor por defecto es 0.1. Las siguientes ecuaciones modelizan
     un péndulo amortiguado.

          (%i11) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        soln_arrows=true, point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        field_degree='solns,
                        saddles_at([%pi,0], [-%pi,0]))$

     `show_field=false' elimina el campo completamente.

          (%i12) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        show_field=false, soln_arrows=true,
                        point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        saddles_at([3*%pi,0], [-3*%pi,0],
                                   [%pi,0], [-%pi,0]))$

     `drawdf' pasa todos los parámetros que no reconoce a `draw2d' o
     `gr2d', permitiendo combinar la potencia del paquete `draw' con
     `drawdf'.

          (%i13) drawdf(x^2+y^2, [x,-2,2], [y,-2,2], field_color=gray,
                        key="soln 1", color=black, soln_at(0,0),
                        key="soln 2", color=red, soln_at(0,1),
                        key="isocline", color=green, line_width=2,
                        nticks=100, parametric(cos(t),sin(t),t,0,2*%pi))$

     `drawdf' acepta listas anidadas de opciones y objetos gráficos,
     permitiendo el uso de `makelist' y otras funciones de forma más
     flexible para generar gráficos.

          (%i14) colors : ['red,'blue,'purple,'orange,'green]$
          (%i15) drawdf([x-x*y/2, (x*y - 3*y)/4],
                        [x,2.5,3.5], [y,1.5,2.5],
                        field_color = gray,
                        makelist([ key   = concat("soln",k),
                                   color = colors[k],
                                   soln_at(3, 2 + k/20) ],
                                 k,1,5))$



File: maxima.info,  Node: dynamics,  Next: ezunits,  Prev: drawdf,  Up: Top

51 dynamics
***********

* Menu:

* Introducción a dynamics::
* Funciones y variables para dynamics::


File: maxima.info,  Node: Introducción a dynamics,  Next: Funciones y variables para dynamics,  Prev: dynamics,  Up: dynamics

51.1 Introducción a dynamics
============================

El paquete adicional `dynamics' incluye varias funciones para crear
diversas representaciones gráficas de sistemas dinámicos y fractales, y
además una implementación del método numérico de Runge-Kutta de cuarto
orden, para resolver sistemas de ecuaciones diferenciales.

   Para usar las funciones en este paquete será necesario primero que
todo cargarlo con `load("dynamics")', y las funciones que crean
gráficas necesitan que Xmaxima esté instalado.



Local Variables:
coding: iso-8859-1
End:
