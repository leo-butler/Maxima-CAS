This is maxima.info, produced by makeinfo version 4.13 from
/home/work/maxima/sandbox/maxima/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Mathematische Funktionen,  Next: Maximas Datenbank,  Prev: Vereinfachung,  Up: Top

10 Mathematische Funktionen
***************************

* Menu:

* Funktionen fÃ¼r Zahlen::
* Funktionen fÃ¼r komplexe Zahlen::
* Funktionen der Kombinatorik::
* Algebraische Funktionen::
* Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::


File: maxima.info,  Node: Funktionen fÃ¼r Zahlen,  Next: Funktionen fÃ¼r komplexe Zahlen,  Prev: Mathematische Funktionen,  Up: Mathematische Funktionen

10.1 Funktionen fÃ¼r Zahlen
===========================

 -- Funktion: abs (<expr>)
     Gibt den Betrag des Argumentes <expr> zurÃ¼ck. Ist <expr> eine
     komplexe Zahl wird das Argument zum komplexen Betrag vereinfacht.
     Allgemeine komplexe AusdrÃ¼cke oder komplexe Funktionen werden von
     `abs' nicht vereinfacht.  FÃ¼r komplexe AusdrÃ¼cke kann die Funktion
     `cabs' genutzt werden. Siehe `cabs'.


 -- Funktion: ceiling (<x>)
     FÃ¼r eine reelle Zahl <x> gibt `ceiling' die kleinste ganze Zahl
     zurÃ¼ck, die grÃ¶Ãer oder gleich <x> ist.

     Ist <expr> ein konstanter Ausdruck, zum Beispiel `10*%pi', dann
     wird der Ausdruck <expr> in eine groÃe Gleitkommazahl umgewandelt.
     Auf die groÃe Gleitkommazahl wird dann `ceiling' angewendet.
     Aufgrund der Umwandlung in Gleitkommazahlen fÃ¼r konstante
     AusdrÃ¼cke, ist es mÃ¶glich, dass `ceiling' ein fehlerhaftes
     Ergebnis errechnet. Um solche Fehler zu minimieren, wird bei der
     Umwandlung in Gleitkommazahlen die Genauigkeit `fpprec' um drei
     zusÃ¤tzliche Stellen erhÃ¶ht.

     Nicht-konstante AusdrÃ¼cke versucht `ceiling' zu vereinfachen. Es
     folgen Beispiele fÃ¼r solche Vereinfachungen:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     Ist das Argument der Funktion offenbar ein komplexer Ausdruck,
     wird die Substantivform zurÃ¼ck gegeben.

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als `integervalued' deklariert werden. Die Funktionen
     `ceiling' und `floor' kÃ¶nnen diese Information nutzen, um
     AusdrÃ¼cke zu vereinfachen:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Funktion: entier (<x>)
     `entier' ist eine andere Bezeichnung fÃ¼r die Funktion `floor'.
     Siehe `floor'.


 -- Funktion: floor (<x>)
     FÃ¼r eine reelle Zahl <x> gibt `floor' die grÃ¶Ãte ganze Zahl
     zurÃ¼ck, die kleiner oder gleich <x> ist.

     Ist <expr> ein konstanter Ausdruck, zum Beispiel `10*%pi', dann
     wird der Ausdruck <expr> in eine groÃe Gleitkommazahl umgewandelt.
     Auf die groÃe Gleitkommazahl wird dann `floor' angewendet.
     Aufgrund der Umwandlung in Gleitkommazahlen fÃ¼r konstante
     AusdrÃ¼cke, ist es mÃ¶glich, dass `floor' ein fehlerhaftes Ergebnis
     errechnet. Um solche Fehler zu minimieren, wird bei der Umwandlung
     in Gleitkommazahlen die Genauigkeit `fpprec' um drei zusÃ¤tzliche
     Stellen erhÃ¶ht.

     Nicht-konstante AusdrÃ¼cke versucht `floor' zu vereinfachen. Es
     folgen Beispiele fÃ¼r solche Vereinfachungen:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     Ist das Argument der Funktion offenbar ein komplexer Ausdruck,
     wird eine Substantivform zurÃ¼ck gegeben.

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als `integervalued' deklariert werden. Die Funktionen
     `ceiling' und `floor' kÃ¶nnen diese Information nutzen, um
     AusdrÃ¼cke zu vereinfachen:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Funktion: fix (<x>)
     `fix' ist eine andere Bezeichnung fÃ¼r die Funktion `floor'. Siehe
     `floor'.


 -- Funktion: lmax (<L>)
     Ist <L> eine Liste oder Menge, wird die Funktion `max' auf die
     Elemente der Liste oder Menge angewendet und das Ergebnis
     zurÃ¼ckgegeben. Ist <L> keine Liste oder Menge, wird ein
     Maxima-Fehler signalisiert.


 -- Funktion: lmin (<L>)
     Ist <L> eine Liste oder Menge, wird die Funktion `min' auf die
     Elemente der Liste oder Menge angewendet und das Ergebnis
     zurÃ¼ckgegeben. Ist <L> keine Liste oder Menge, wird ein
     Maxima-Fehler signalisiert.


 -- Funktion: max (<x_1>, ..., <x_n>)
     Gibt einen vereinfachten Wert fÃ¼r das Maximum der AusdrÃ¼cke <x_1>
     bis <x_n> zurÃ¼ck. Ist `get(trylevel, maxmin)' gleich 2 oder grÃ¶Ãer,
     nutzt `max' die Vereinfachung `max(e,-e) --> |e|'. Ist
     `get(trylevel, maxmin)' gleich 3 oder grÃ¶Ãer, versucht `max'
     AusdrÃ¼cke zu eleminieren, die zwischen zwei anderen Argumenten
     liegen. So wird zum Beispiel `max(x,2*x, 3*x)' zu `max(x, 3*x)'
     vereinfacht.  `put(trylevel, 2, maximin)' setzt den Wert von
     `trylevel' zu 2.


 -- Funktion: min (<x_1>, ..., <x_n>)
     Gibt einen vereinfachten Wert fÃ¼r das Minimum der AusdrÃ¼cke <x_1>
     bis <x_n> zurÃ¼ck. Ist `get(trylevel, maxmin)' gleich 2 oder grÃ¶Ãer,
     nutzt `min' die Vereinfachung `min(e,-e) --> |e|'. Ist
     `get(trylevel, maxmin)' gleich 3 oder grÃ¶Ãer, versucht `min'
     AusdrÃ¼cke zu eleminieren, die zwischen zwei anderen Argumenten
     liegen. So wird zum Beispiel `min(x,2*x, 3*x)' zu `min(x, 3*x)'
     vereinfacht.  `put(trylevel, 2, maximin)' setzt den Wert von
     `trylevel' zu 2.


 -- Funktion: mod (<x>, <y>)
     Sind <x> und <y> reelle Zahlen und ist <y> ungleich Null, gibt
     `mod(<x>, <y>)' das Ergebnis von `<x> - <y> * floor(<x> / <y>)'
     zurÃ¼ck. Weiterhin gilt fÃ¼r alle reellen Zahlen `mod(<x>, 0) =
     <x>'. FÃ¼r eine Diskussion dieser Definition siehe Kapitel 3.4,
     "Concrete Mathematics," by Graham, Knuth, and Patashnik. Die
     Funktion `mod(<x>, 1)' ist eine SÃ¤gezahnfunktion mit der Periode 1
     mit `mod(1, 1) = 0' und `mod (0, 1) = 0'.

     Der Hauptwert einer komplexen Zahl, die im Intervall `(-%pi, %pi)'
     liegt, kann mit `%pi - mod(%pi - <x>, 2*%pi)' bestimmt werden,
     wobei <x> die komplexe Zahl ist.

     Wie fÃ¼r die Funktionen `floor' oder `ceiling' werden konstante
     AusdrÃ¼cke, wie zum Beispiel `10 * %pi', in groÃe Gleitkommazahlen
     umgewandelt, um `mode' zu berechnen. Diese Umwandlung kann zu
     Fehlern fÃ¼hren.

     FÃ¼r nicht nummerische Argumente <x> oder <y> kennt `mod'
     verschiedene Vereinfachungen:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0


 -- Funktion: round (<x>)
     Ist <x> eine reelle Zahl, gibt `round' die am nÃ¤chsten liegende
     ganze Zahl zurÃ¼ck. Vielfache von 1/2 werden auf die nÃ¤chste gerade
     ganze Zahl gerundet. Die Berechnung von <x> ist vergleichbar mit
     den Methoden der Funktionen `floor' und `ceiling'.

     Siehe auch `floor'  und `ceiling'.


 -- Funktion: signum (<x>)
     Ist <x> eine Zahl, ist das Ergebnis 0, wenn <x> gleich 0 ist, oder
     -1 fÃ¼r eine Zahl kleiner als 0 und +1 fÃ¼r eine Zahl, die grÃ¶Ãer
     als 0 ist.

     Ist <x> keine Zahl, versucht Maxima den Ausdruck zu vereinfachen.
     So wird zum Beispiel `signum(-x)' zu `-signum(x)' vereinfacht.



File: maxima.info,  Node: Funktionen fÃ¼r komplexe Zahlen,  Next: Funktionen der Kombinatorik,  Prev: Funktionen fÃ¼r Zahlen,  Up: Mathematische Funktionen

10.2 Funktionen fÃ¼r komplexe Zahlen
====================================

 -- Funktion: cabs (<expr>)
     Gibt den Betrag eines komplexen Ausdrucks <expr> zurÃ¼ck. Im
     Unterschied zu der Funktion `abs', zerlegt die Funktion `cabs'
     einen komplexen Ausdruck immer in einen Realteil und einen
     ImaginÃ¤rteil, um den komplexen Betrag zu berechnen.


 -- Funktion: carg (<z>)
     Gibt das komplexe Argument von <z> zurÃ¼ck. Das komplexe Argument
     ist ein Winkel `theta' im Intervall `(-%pi, %pi)' derart, das <z> =
     `r exp (theta %i)' ist, wobei `r' den Betrag des komplexen
     Ausdrucks <z> bezeichnet.

     Siehe auch `cabs',  `polarform',  `rectform',  `realpart'  und
     `imagpart'.

     Beispiele:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Funktion: conjugate (<x>)
     Gibt den konjugiert komplexen Wert des Ausdruckes <x> zurÃ¼ck.

     Beispiele:

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Funktion: imagpart (<expr>)
     Gibt den ImaginÃ¤rteil des Ausdrucks <expr> zurÃ¼ck.

     Siehe auch `abs', `carg', `polarform', `rectform' und `realpart'.


 -- Funktion: polarform (<expr>)
     Gibt einen zu <expr> Ã¤quivalenten Ausdruck `r %e^(%i theta)'
     zurÃ¼ck. `r' ist der Betrag der komplexen Ausdrucks <expr> und
     `theta' das Argument des komplexen Ausdrucks.


 -- Funktion: realpart (<expr>)
     Gibt den Realteil des Ausrucks <expr> zurÃ¼ck.


 -- Funktion: rectform (<expr>)
     Zerlegt einen Ausdruck in den Realteil `a' und den ImaginÃ¤rteil `b'
     und gibt den komplexen Ausdruck `a + b %i' zurÃ¼ck.



File: maxima.info,  Node: Funktionen der Kombinatorik,  Next: Algebraische Funktionen,  Prev: Funktionen fÃ¼r komplexe Zahlen,  Up: Mathematische Funktionen

10.3 Funktionen der Kombinatorik
================================

 -- Operator: !!
     Ist der Operator der doppelten FakultÃ¤t.

     FÃ¼r eine ganze Zahl, rationale Zahl oder Gleitkommazahl `n',  wird
     `n!!' zu dem Produkt `n (n-2) (n-4) (n-6) ... (n - 2 (k-1))'
     vereinfacht, wobei `k' gleich `floor(n/2)' ist und `floor' die
     grÃ¶Ãte ganze Zahl liefert, die kleiner oder gleich `n/2' ist. Diese
     Definition entspricht fÃ¼r nicht ganze Zahlen nicht der Ã¼blichen
     Definition.

     FÃ¼r eine gerade (oder ungerade) ganze Zahl wird `n!!' zum Produkt
     aller aufeinanderfolgenden geraden (oder ungeraden) ganzen Zahlen
     beginnend mit 2 (oder 1) einschlieÃlich `n' vereinfacht.

     FÃ¼r ein Argument `n', das keine ganze, rationale oder
     Gleitkommazahl ist, gibt `n!!' die Substantivform `genfact(n,
     n/2,2)' zurÃ¼ck.

     Maxima kennt noch die Funktion `double_factorial', die wesentlich
     allgemeiner definiert ist. Siehe `double_factorial'.


 -- Funktion: bern (<n>)
     Gibt die <n>-te Bernoulli-Zahl der ganzen Zahl <n> zurÃ¼ck. Hat die
     Optionsvariable `zerobern' den Wert `false', werden
     Bernoulli-Zahlen unterdrÃ¼ckt, die Null sind.

     Siehe auch `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Funktion: bernpoly (<x>, <n>)
     Gibt das <n>-te Bernoulli-Polynom in der Variablen <x> zurÃ¼ck.


 -- Function: bfzeta (<s>, <n>)
     Die Riemannsche Zeta-Funktion fÃ¼r das Argument <s>, die wie folgt
     definiert ist:

                           inf
                           ====
                           \     1
               zeta(s) =    >    --
                           /      s
                           ====  k
                           k = 1

     `bfzeta' gibt einen Wert als groÃe Gleitkommazahl zurÃ¼ck. Die
     Anzahl der Stellen wird durch das Argument <n> angegeben.

     Anstatt der Funktion `bfzeta' ist die Funktion `zeta'  zu
     bevorzugen, die sowohl fÃ¼r reelle und komplexe Gleitkommazahlen
     und Gleitkommazahlen mit eine beliebigen Genauigkeit die
     Riemannsche Zeta-Funktion berechnen kann.


 -- Funktion: bfhzeta (<s>, <h>, <n>)
     Die Hurwitzsche Zeta-Funktion fÃ¼r die Argumente <s> und <h>, die
     wie folgt definiert ist:

                                  inf
                                  ====
                                  \        1
                   zeta (s,h)  =   >    --------
                                  /            s
                                  ====  (k + h)
                                  k = 0

     `bfhzeta' gibt einen Wert als groÃe Gleitkommazahl zurÃ¼ck. Die
     Anzahl der Stellen wird durch das Argument <n> angegeben.


 -- Funktion: binomial (<x>, <y>)
     Der Binomialkoeffizient `<x>!/(<y>! (<x> - <y>)!)'. Sind die
     Argumente <x> und <y> ganze Zahlen, wird der Binomialkoeffizient
     numerisch berechnet. Sind <y> oder <x-y> ganze Zahlen, dann wird
     der Binomialkoeffizient zu einem Polynom vereinfacht.

     Beispiele:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)


 -- Funktion: burn (<n>)
     Gibt eine rational Zahl zurÃ¼ck, die eine NÃ¤herung fÃ¼r die <n>-te
     Bernoulli Zahl fÃ¼r die ganze Zahl <n> ist. `burn' berechnet eine
     NÃ¤herung als groÃe Gleitkommatzahl mit der folgenden Beziehung:

                             n - 1  1 - 2 n
                        (- 1)      2        zeta(2 n) (2 n)!
               B(2 n) = ------------------------------------
                                          2 n
                                       %pi

     `burn' kann effizienter als die Funktion `bern' fÃ¼r groÃe,
     einzelne ganze Zahlen <n> sein, da `bern' zunÃ¤chst alle Bernoulli
     Zahlen bis <n> berechnet. `burn' ruft fÃ¼r ungerade ganze Zahlen und
     Zahlen die kleiner oder gleich 255 die Funktion `bern' auf.

     Das Kommando `load(bffac)' lÃ¤dt die Funktion. Siehe auch `bern'.


 -- Funktion: divsum (<n>, <k>)
 -- Funktion: divsum (<n>)
     `divsum(<n>, <k>)' potenziert die Teiler des Argumentes <n> mit
     dem Argument <k> und gibt die Summe als Ergebnis zurÃ¼ck.

     `divsum(<n>)' gibt die Summe der Teiler der Zahl <n> zurÃ¼ck.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Funktion: euler (<n>)
     Gibt die <n>-te Eulersche Zahl fÃ¼r eine nichtnegative ganze Zahl
     <n> zurÃ¼ck.

     FÃ¼r die Euler-Mascheroni Konstante siehe `%gamma'.

     Beispiele:

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Funktion: factcomb (<expr>)
     Fasst Faktoren in AusdrÃ¼cken mit FakultÃ¤ten zusammen. Zum Beispiel
     wird `(n+1)*n!' zu `(n+1)!' zusammengefasst.

     Hat die Optionsvariable `sumsplitfact' den Wert `false', wird die
     Vereinfachung mit der Funktion `minfactorial' nach der Funktion
     `factcomb' angewendet.


 -- Funktion: factorial (<x>)
 -- Operator: !
     `factorial' ist die Funktion fÃ¼r die Berechnung der FakultÃ¤t. Der
     Operator fÃ¼r die FakultÃ¤t `!', ist identisch mit der Funktion. FÃ¼r
     jede komplexe Zahl `x', einschlieÃlich ganze und rationale Zahlen,
     sowie Gleitkommazahlen und mit Ausnahme der negative ganzen
     Zahlen, ist die FakultÃ¤t definiert als `gamma(x+1'.

     FÃ¼r eine ganze Zahl `x', vereinfacht `x!' zum Produkt der ganzen
     Zahlen von 1 bis einschlieÃlich `x'. `0!' vereinfacht zu 1. FÃ¼r
     eine Gleitkommazahl vereinfacht `x!' zu `gamma(x+1)'. FÃ¼r eine
     halbzahlige rationale Zahl `n/2', wobei `n' eine ungerade ganze
     Zahl ist, vereinfacht `(n/2)!' zu einem rationalen Faktor
     multipliziert mit `sqrt(%pi)'. FÃ¼r jedes andere Argument wird `x!'
     nicht vereinfacht.

     Die Optionsvariablen `factlim' und `gammalim' steuern die
     numerische Berechnung von AusdrÃ¼cken, die FakultÃ¤ten enthalten.
     Siehe `factlim' und `gammalim'.

     Die Funktionen `minfactorial' und `factcomb' vereinfachen
     AusdrÃ¼cken, die die FakultÃ¤t enthalten. Siehe `minfactorial' und
     `factcomb'.

     Die Funktionen `gamma', `bbfac' und `cbffac' sind Varianten der
     Gamma Funktion. `bffac' und `cbffac' werden intern von Maxima
     aufgerufen, um die Gammafunktion fÃ¼r reelle und komplexe groÃe
     Gleitkommazahlen zu berechnen.

     Die Funktion `makegamma' ersetzt die Gamma Funktion `gamma' fÃ¼r die
     FakultÃ¤t und verwandte Funktionen in einem Ausdruck.

     Maxima kennt die Ableitung der FakultÃ¤t und den Grenzwert fÃ¼r
     spezielle Wert wie negative ganze Zahlen.

     Die Optionsvariable `factorial_expand' kontrolliert die
     Vereinfachung von AusdrÃ¼cken wie `(n+1)!', wobei `n' eine ganze
     Zahl ist.

     Siehe auch `binomial'.

     Beispiele:

     Die FakultÃ¤t einer ganzen Zahl wird zu einer exakten Zahl
     vereinfacht, wenn das Argument nicht grÃ¶Ãer als `factlim' ist. Die
     FakultÃ¤t fÃ¼r reelle und komplexe Zahlen wird in als Gleitkommazahl
     berechnet.

          (%i1) factlim:10;
          (%o1)                                 10
          (%i2) [0!, (7/2)!, 8!, 20!];
                                      105 sqrt(%pi)
          (%o2)                   [1, -------------, 40320, 20!]
                                           16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3)    [81.44668037931197,
                    .3430658398165454 %i + .6529654964201665]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0,
                 3.430658398165454b-1 %i + 6.529654964201667b-1]

     Die FakultÃ¤t einer komplexen Zahl, bekannten Konstanten oder eines
     allgemeinen Ausdrucks wird nicht vereinfacht. Der Vereinfachung
     kann mÃ¶glich sein, wenn der Operand zu einer Zahl ausgewertet
     werden kann.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165454 %i + .6529654964201665,
                 7.188082728976031,
                 4.260820476357003, 1.227580202486819]

     FakultÃ¤ten werden vereinfacht und nicht ausgewertet. Daher kann
     `x!' auch in AusdrÃ¼cken ersetzt werden, deren Auswertung mit dem
     Quote-Operator verhindert wurde.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]

     Maxima kennt die Ableitung der FakultÃ¤t.

          (%i1) diff(x!,x);
          (%o1)                           x! psi (x + 1)
                                                0

     Die Optionsvariable `factorial_expand' steuert die Expansion und
     Vereinfachung von AusdrÃ¼cken, die die FakultÃ¤t enthalten.

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                                n + 1


 -- Optionsvariable: factlim
     Standardwert: 100000

     Die Optionsvariable `factlim' spezifiziert die grÃ¶Ãte ganze Zahl,
     fÃ¼r die die FakultÃ¤t einer ganzen Zahl berechnet wird. Wenn
     `factlim' den Wert -1 hat, wird die FakultÃ¤t fÃ¼r jede ganze Zahl
     berechnet.


 -- Optionsvariable: factorial_expand
     Standardwert: `false'

     Die Optionsvariable `factorial_expand' kontrolliert die
     Vereinfachung von AusdrÃ¼cken wie `(n+1)!', wobei `n' eine ganze
     Zahl ist. Siehe `factorial' fÃ¼r ein Beispiel.


 -- Funktion: fib (<n>)
     Gibt die <n-te> Fibonacci-Zahl zurÃ¼ck. Die Fibonacci-Folge ist
     rekursiv definiert:

             fib(0) = 0
             fib(1) = 1
             fib(n) = fib(n-1) + fib(n-2)

     FÃ¼r negative ganze Zahlen kann die Fibonacci-Folge erweitert wird
     mit:

                             n + 1
             fib(- n) = (- 1)      f(n)

     Nach einem Aufruf der Funktion `fib(n)', enthÃ¤lt die Systemvariable
     `prevfib' die zur Zahl `n' vorhergehende Fibonacci-Zahl.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Funktion: fibtophi (<expr>)
     Fibonacci-Zahlen im Ausdruck <expr> werden durch die Goldene Zahl
     `%phi' ausgedrÃ¼ckt. Siehe `%phi'.

     Beispiele:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0


 -- Funktion: genfact (<x>, <y>, <z>)
     Gibt die verallgemeinerte FakultÃ¤t zurÃ¼ck, die als `x (x-z) (x - 2
     z) ... (x - (y - 1) z)' definiert ist. Damit gilt fÃ¼r ein
     ganzzahliges Argument <x>, `genfact (x, x, 1) = x!' und `genfact
     (x, x/2, 2) = x!!'.


 -- Function: ifactors (<n>)
     Faktorisiert eine positive ganze Zahl <n>. Sind `n = p1^e1..pk^nk'
     die Faktoren der ganzen Zahl <n>, dann gibt `ifactor' das Ergebnis
     `[[p1, e1], ... , [pk, ek]]' zurÃ¼ck.

     FÃ¼r die Faktorisierung kommen eine einfache Primfaktorzerlegung
     mit Primzahlen bis zu 9973, das ZÃ¤hlkÃ¶rpersieb nach Pollard oder
     die Methode der Elliptischen Kurven zum Einsatz.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600


 -- Funktion: inrt (<x>, <n>)
     Gibt die ganzzahlige <n>-te Wurzel des Betrags von <x> zurÃ¼ck.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Function: inv_mod (<n>, <m>)
     Berechnet die Inverse zu <n> Modulo <m>. `inv_mod(n,m)' gibt
     `false' zurÃ¼ck, wenn `n,m' Null ist.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false


 -- Funktion: jacobi (<p>, <q>)
     Berechnet das Jacobi-Symbol fÃ¼r die Argumente <p> und <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Funktion: lcm (<expr_1>, ..., <expr_n>)
     Gibt den kleinsten gemeinsamen Teiler der Argumente zurÃ¼ck. Die
     Argumente kÃ¶nnen ganze Zahlen und allgemeine AusdrÃ¼cke sein.

     Mit dem Kommando `load(functs)' wird die Funktion geladen.


 -- Funktion: minfactorial (<expr>)
     Treten mehrere FakultÃ¤ten in einem Ausdruck <expr> auf, die sich
     nur um ganze Zahlen voneinander unterscheiden, werden diese
     vereinfacht.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Funktion: next_prime (<n>)
     Gibt die kleinste Primzahl zurÃ¼ck, die der Zahl <n> folgt.

          (%i1) next_prime(27);
          (%o1)                       29


 -- Funktion: power_mod (<a>, <n>, <m>)
     Berechnet `a^n mod m', wobei <a> und <n> ganze Zahlen sind und <m>
     eine positive ganze Zahl ist. Ist <n> negativ, wird die Funktion
     `inv_mod' aufgerufen, um die Inverse zu berechnen.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3


 -- Funktion: primep (<n>)
     FÃ¼hrt einen Test auf eine Primzahl fÃ¼r das Argument <n> durch. Hat
     `primep' das Ergebnis `false', ist <n> keine Primzahl. Ist das
     Ergebnis `true', ist <n> mit groÃer Wahrscheinlichkeit eine
     Primzahl.

     FÃ¼r ganze Zahlen <n> die kleiner als 10^16 sind wird eine
     probalistisches Miller-Rabin-Verfahren. Hat in diesem Fall
     `primep' das Ergebnis `true', dann ist <n> eine Primzahl.

     FÃ¼r ganze Zahlen <n> grÃ¶Ãer als 10^16 nutzt `primep' den
     Pseudo-Primzahlentest nach Miller-Rabin mit
     `primep_number_of_tests'  Tests und den Pseudo_Primzahlentest nach
     Lucas. Die Wahrscheinlichkeit, dass eine Zahl <n> den
     Pseudo-Primzahlentest nach Miller-Rabin passiert, ist kleiner als
     1/4. Mit dem Standardwert 25 fÃ¼r die Optionsvariable
     `primpe_number_of_tests' ist die Wahrscheinlichkeit viel kleiner
     als 10^-15.


 -- Optionsvariable: primep_number_of_tests
     Standardwert: 25

     Die Anzal der Pseudo-Primzahlentests nach Miller-Rabin der Funktion
     `primep'.


 -- Funktion: prev_prime (<n>)
     Gibt die grÃ¶Ãte Primzahl zurÃ¼ck, die kleiner als die Zahl <n> ist.

          (%i1) prev_prime(27);
          (%o1)                       23


 -- Funktion: qunit (<n>)
     Findet fÃ¼r das Argument <n> LÃ¶sungen der Pellschen Gleichung `a^2
     - <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Optionsvariable: sumsplitfact
     Standardwert: `true'

     Hat die Optionsvariable `sumsplitfact' den Wert `false', wird die
     Vereinfachung mit der Funktion `minfactorial' nach der Funktion
     `factcomb' angewendet.


 -- Funktion: totient (<n>)
     Gibt die Anzahl der ganzen Zahlen zurÃ¼ck, die kleiner oder gleich
     <n> sind und die kein Teiler von <n> sind.


 -- Optionsvariable: zerobern
     Standardwert: `true'

     Hat `zerobern' den Wert `false', werden von den Funktionen `bern'
     die Bernoulli Zahlen und von `euler' die Euler Zahlen
     ausgeschlossen, die als Ergenis Null haben. Siehe `bern'  und
     `euler'.


 -- Funktion: zeta (<n>)
     Die Riemannsche Zeta-Funktion fÃ¼r <s>, die wie folgt definiert ist:

                           inf
                           ====
                           \     1
               zeta(s) =    >    --
                           /      s
                           ====  k
                           k = 1

     FÃ¼r negative ganze Zahlen <n>, Null und postive gerade ganze Zahlen
     vereinfacht `zeta' zu einem exakten Ergebnis. Damit diese
     Vereinfachung fÃ¼r positive ganze Zahlen ausgefÃ¼hrt wird, muss die
     Optionsvariable `zeta%pi' den Wert `true' haben. Siehe `zeta%pi'.
     FÃ¼r einfache und groÃe Gleitkommazahlen hat `zeta' ein numerisches
     Ergebnis. FÃ¼r alle anderen Argumente einschlieÃlich komplexe
     Zahlen und rationale Zahlen gibt `zeta' eine Substantivform
     zurÃ¼ck. Hat die Optionsvariable `zeta%pi' den Wert `false', gibt
     `zeta' auch fÃ¼r gerade ganze Zahlen eine Substantivform zurÃ¼ck.

     `zeta(1)' ist nicht definiert. Maxima kennt jedoch die einseitigen
     Grenzwerte `limit(zeta(x), x, 1, plus' und `limit(zeta(x), x, 1,
     minus'.

     Die Riemannsche Zeta-Funktion wird auf die Argumente von Listen,
     Matrizen und Gleichungen angewendendet, wenn die Optionsvariable
     `distribute_over' den Wert `true' hat.

     Siehe auch `bfzeta'  und `zeta%pi'.

     Beispiele:

          (%i1) zeta([-2,-1,0,0.5,2,3,1+%i]);
                                                       2
                      1     1                       %pi
          (%o1) [0, - --, - -, - 1.460354508809586, ----, zeta(3),
                      12    2                        6
                                                              zeta(%i + 1)]
          (%i2) limit(zeta(x),x,1,plus);
          (%o2)                          inf
          (%i3) limit(zeta(x),x,1,minus);
          (%o3)                         minf


 -- Optionsvariable: zeta%pi
     Standardwert: `true'

     Hat `zeta%pi' den Wert `true', vereinfacht die Funktion `zeta(n)'
     fÃ¼r gerade ganzen Zahlen <n> zu einem Ergebnis, das proportional zu
     `%pi^n' ist. Ansonsten ist das Ergebnis von `zeta' eine
     Substantivform fÃ¼r gerade ganze Zahlen.

     Beispiele:

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Algebraische Funktionen,  Next: Exponential- und Logarithmusfunktion,  Prev: Funktionen der Kombinatorik,  Up: Mathematische Funktionen

10.4 Algebraische Funktionen
============================

 -- Funktion: isqrt (<x>)
     Gibt die ganzzahlige Wurzel des Betrages von <x> zurÃ¼ck, wenn <x>
     eine ganze Zahl ist. Andernfalls wird eine Substantivform
     zurÃ¼ckgegeben.


 -- Funktion: sqrt (<x>)
     Ist die Wurzelfunktion. Intern stellt Maxima die Wurzelfunktion als
     `sqrt<x>^(1/2)' dar. Siehe auch die Funktion `rootscontract'.

     Hat die Optionsvariable `radexpand' den Wert `true', werden die
     n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel
     herausgezogen.  So wird zum Beispiel `sqrt(16*x^2)' nur dann zu
     `4*x' vereinfacht, wenn `radexpand' den Wert `true' hat.



File: maxima.info,  Node: Exponential- und Logarithmusfunktion,  Next: Winkelfunktionen,  Prev: Algebraische Funktionen,  Up: Mathematische Funktionen

10.5 Exponential- und Logarithmusfunktion
=========================================

 -- Funktion: exp (<x>)
     Ist die Exponentialfunktion. Die Exponentialfunkton <exp> wird
     sofort zu `%e^<x>' vereinfacht und tritt in vereinfachten
     AusdrÃ¼cken nicht auf.

     Hat die Optionsvariable `demoivre' den Wert `true', werden
     AusdrÃ¼cke der Form `%e^(a + b %i)' zu `%e^(a (cos(b) + %i
     sin(b)))' vereinfacht, wobei <a> und <b> reelle AusdrÃ¼cke sind.

     Hat die Optionsvariable `%emode' den Wert `true', dann werden
     AusdrÃ¼cke der Form  `%e^(%pi %i x)' vereinfacht. Siehe `%emode'.

     Hat die Optionsvariable `%enumer' den Wert `true', wird die
     Konstante `%e' durch ihren nummerischen Wert 2.718... ersetzt,
     sobald auch die Optionsvariable `numer' den Wert `true' hat. Siehe
     `%enumer'.


 -- Optionsvariable: %emode
     Standardwert: `true'

     Hat die Optionsvariable `%emode' den Wert `true', wird `%e^(%pi %i
     x)' wie folgt vereinfacht:

     `%e^(%pi %i x)' wird zu `cos (%pi x) + %i sin (%pi x)' vereinfacht,
     wenn `x' eine Gleitkommazahl, eine ganze Zahl oder ein vielfaches
     von 1/2, 1/3, 1/4 oder 1/6 ist.

     FÃ¼r andere nummerische Werte `x' wird `%e^(%pi %i x)' zu `%e^(%pi
     %i y)' vereinfacht, wobei `y' eine ganze Zahl `x - 2 k' mit einem
     `k' ist, so dass `abs(y) < 1' gilt.

     Hat `%emode' den Wert `false', werden keine speziellen
     Vereinfachungen fÃ¼r den Ausdruck `%e^(%pi %i x)' vorgenommen.


 -- Optionsvariable: %enumer
     Standardwert: `false'

     Hat `%enumer' den Wert `true', wird die Konstante `%e' immer dann
     durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable
     `numer' den Wert `true' hat.

     Hat `%enumer' den Wert `false', wird die Konstante `%e' nur dann
     durch ihren nummerischen Wert ersetzt, wenn der Exponent von
     `%e^x' zu einer Gleitkommazahl ausgewertet wird.

     Siehe auch `ev' und `numer'.


 -- Optionsvariable: %e_to_numlog
     Standardwert: `false'

     Hat die Optionsvariable `%e_to_numlog' den Wert `true', wird ein
     Ausdruck `%e^(r*log(x))' zu `x^r' vereinfacht. Dabei sind `r' eine
     rationale Zahl und `x' ein beliebiger Ausdruck. Die Funktion
     `radcan' fÃ¼hrt diese Vereinfachung ebenfalls aus.


 -- Funktion: log (<x>)
     Ist der natÃ¼rliche Logaritmus zur Basis e.

     Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10
     oder anderen Basen. Eine einfache Definition ist zum Beispiel
     `log10(x) := log(x)/log(10)'.

     FÃ¼r die Vereinfachung und Auswertung der Logarithmusfunktion hat
     Maxima verschiedene Optionsvariablen:

        * `logexpand'

          `log(a^b)' wird zu `b*log(a)' vereinfacht. Hat `logexpand' den
          Wert `all', wird zusÃ¤tzlich `log(a*b)' zu `log(a)+log(b)'
          vereinfacht. Mit den Wert `super' vereinfacht Maxima weiterhin
          `log(a/b)' zu `log(a)-log(b)', wobei `a/b' eine rationale Zahl
          ist. `log(1/b' wird fÃ¼r eine ganze Zahl `b' immer
          vereinfacht. Hat die Optionsvariable `logexpand' den Wert
          `false' werden alle obigen Vereinfachungen ausgeschaltet.

        * `logsimp'

          Hat die Optionsvariable `logsimp' den Wert `false', werden
          Exponentialfunktionen `exp', die Logarithmusfunktionen im
          Exponenten enthalten, nicht vereinfacht.

        * `lognumer'

          Hat die Optionsvariable `lognumer' den Wert `true', wird von
          negativen Gleitkommazahlen der Absolutwert genommen, bevor
          der Logarithmus berechnet wird.

        * `lognegint'

          Hat die Optionsvariable `lognegint' den Wert `true', wird
          `log(-n)' zu `log(n)+%i*%pi' fÃ¼r postive `n' vereinfacht.

        * `%e_to_numlog'

          Hat die Optionsvariable `%e_to_numlog' den Wert `true', wird
          ein Ausdruck `%e^(r*log(x))' zu `x^r' vereinfacht. Dabei sind
          `r' eine rationale Zahl und `x' ein beliebiger Ausdruck. Die
          Funktion `radcan' fÃ¼hrt diese Vereinfachung ebenfalls aus.


 -- Optionsvariable: logabs
     Standardwert: `false'

     Werden unbestimmte Integrale mit Logarithmusfunktionen erzeugt,
     zum Beispiel `integrate(1/x,x)', wird der Betrag der Argumente der
     Logarithmusfunktionen gebildet `log(abs(...))', wenn die
     Optionsvariable `logabs' den Wert `true' hat. Ist der Wert `false'
     werden keine BetrÃ¤ge gebildet `log(...)'.

     Bei der Berechnung von bestimmten Integralen setzt Maxima die
     Optionsvariable `logabs' zu den Wert `false'.


 -- Funktion: logarc (<expr>)
 -- Optionsvariable: logarc
     Hat die Optionsvariable `logarc' den Wert `true', werden inverse
     Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen
     ersetzt. Der Standwert von `logarc' ist `false'.

     Die Funktion `logarc(<expr>)' fÃ¼hrt diese Ersetzung aus, ohne dass
     die Optionsvariable `logarc' gesetzt wird.


 -- Optionsvariable: logconcoeffp
     Standardwert: `false'

     Die Optionsvariable `logconcoeffp' kontrolliert, welche
     Koeffizienten von der Funktion `logcontract' zusammengezogen
     werden. Der Optionsvariable kann der Name einer Aussagefunktion
     mit einem Argument zugewiesen werden. Sollen z. B. Wurzeln
     generiert werden, kann folgende Definition verwendet:
     `logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or
     ratnump(m)$'. Dann ergibt sich fÃ¼r `logcontract(1/2*log(x));' das
     folgende Ergebnis `log(sqrt(x))'.


 -- Funktion: logcontract (<expr>)
     Der Ausdruck <expr> wird rekursiv nach AusdrÃ¼cken der Form
     `a1*log(b1) + a2*log(b2) + c' abgesucht. Diese werden zu
     `log(ratsimp(b1^a1 * b2^a2)) + c' transformiert.

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Wird die Variable <n> als eine ganze Zahl deklariert,
     `declare(n,integer);', dann wird  `logcontract(2*a*n*log(x));' zu
     `a*log(x^(2*n))' vereinfacht. Die Koeffizienten, die
     zusammengezogen werden, sind in diesem Fall die Zahl 2 und die
     Variable <n>, welche die folgende Aussage erfÃ¼llen
     `featurep(coeff,integer)'. Der Nutzer kann kontrollieren, welche
     Koeffizienten zusammengezogen werden. Dazu wird der
     Optionsvariablen `logconcoeffp' eine Aussagefunktion mit einem
     Argument zugewiesen. Sollen z. B. Wurzeln generiert werden, kann
     folgende Definition verwendet: `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$'. Dann ergibt
     sich fÃ¼r `logcontract(1/2*log(x));' das folgende Ergebnis
     `log(sqrt(x))'.


 -- Optionsvariable: logexpand
     Standardwert: `true'

     `log(a^b)' wird zu `b*log(a)' vereinfacht. Hat `logexpand' den
     Wert `all', wird zusÃ¤tzlich `log(a*b)' zu `log(a)+log(b)'
     vereinfacht. Mit den Wert `super' vereinfacht Maxima weiterhin
     `log(a/b)' zu `log(a)-log(b)', wobei `a/b' eine rationale Zahl
     ist. `log(1/b' wird fÃ¼r eine ganze Zahl `b' immer vereinfacht. Hat
     die Optionsvariable `logexpand' den Wert `false' werden alle obigen
     Vereinfachungen ausgeschaltet.


 -- Optionsvariable: lognegint
     Standardwert: `false'

     Hat die Optionsvariable `lognegint' den Wert `true', wird
     `log(-n)' zu `log(n)+%i*%pi' fÃ¼r postive `n' vereinfacht.


 -- Optionsvariable: lognumer
     Standardwert: `false'

     Hat die Optionsvariable `lognumer' den Wert `true', wird von
     negativen Gleitkommazahlen der Absolutwert genommen, bevor der
     Logarithmus berechnet wird.


 -- Optionsvariable: logsimp
     Standardwert: `true'

     Hat die Optionsvariable `logsimp' den Wert `false', werden
     Exponentialfunktionen `exp', die Logarithmusfunktionen im
     Exponenten enthalten, nicht vereinfacht.


 -- Funktion: plog (<x>)
     Gibt den Hauptwert des komplexen natÃ¼rlichen Logarithmus im
     Intervall `-%pi' < `carg(<x>)' <= `+%pi' zurÃ¼ck.



File: maxima.info,  Node: Winkelfunktionen,  Next: Hyperbelfunktionen,  Prev: Exponential- und Logarithmusfunktion,  Up: Mathematische Funktionen

10.6 Winkelfunktionen
=====================

* Menu:

* EinfÃ¼hrung in Winkelfunktionen::
* Funktionen und Variablen fÃ¼r Winkelfunktionen::


File: maxima.info,  Node: EinfÃ¼hrung in Winkelfunktionen,  Next: Funktionen und Variablen fÃ¼r Winkelfunktionen,  Prev: Winkelfunktionen,  Up: Winkelfunktionen

10.6.1 EinfÃ¼hrung in Winkelfunktionen
--------------------------------------

Maxima kennt viele Winkel- und Hyperbelfunktionen. Nicht alle
IdentitÃ¤ten fÃ¼r Winkel- und Hyperbelfunktionen sind programmiert, aber
es ist mÃ¶glich weitere IdentitÃ¤ten mit der FÃ¤higkeit der Erkennung von
Mustern hinzuzufÃ¼gen.

   Maxima kennt die folgenden Winkel- und Hypelfunktionen sowie deren
Inverse:

`sin'       `cos'       `tan'
`sec'       `csc'       `cot'
`asin'      `acos'      `atan'
`asec'      `acsc'      `acot'
`sinh'      `cosh'      `tanh'
`sech'      `csch'      `coth'
`asinh'     `acosh'     `atanh'
`asech'     `acsch'     `acoth'


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Winkelfunktionen,  Prev: EinfÃ¼hrung in Winkelfunktionen,  Up: Winkelfunktionen

10.6.2 Funktionen und Variablen fÃ¼r Winkelfunktionen
-----------------------------------------------------

 -- Funktion: acos (<x>)
     - Arkuskosinus.


 -- Funktion: acot (<x>)
     - Arkuskotangens.


 -- Funktion: acsc (<x>)
     - Arkuskosekans.


 -- Funktion: asec (<x>)
     - Arkussekans.


 -- Funktion: asin (<x>)
     - Arkussinus.


 -- Funktion: atan (<x>)
     - Arkustangens.


 -- Funktion: atan2 (<y>, <x>)
     - Gibt den Wert von `atan(<y>/<x>)' im Intervall `-%pi' bis `%pi'
     zurÃ¼ck.


 -- Funktion: cos (<x>)
     - Kosinus.


 -- Funktion: cot (<x>)
     - Kotangens.


 -- Funktion: csc (<x>)
     - Kosekans.


 -- Funktion: sec (<x>)
     - Sekans.


 -- Funktion: sin (<x>)
     - Sinus.


 -- Funktion: tan (<x>)
     - Tangens.


 -- Optionsvariable: %piargs
     Standardwert: `true'

     Hat `%piargs' den Wert `true', werden Winkel- und
     Hyperbelfunktionen sowie deren Inverse zu algebraischen Konstanten
     vereinfacht, wenn das Argument ein ganzzahliges Vielfaches der
     folgenden Konstanten ist: `%pi', `%pi/2', `%pi/3', `%pi/4' oder
     `%pi/6'.

     Maxima kennt weiterhin einige IdentitÃ¤ten, wenn die Konstante `%pi'
     mit einer Variablen multipliziert wird, die als ganzzahlig
     deklariert wurde.

     Beispiele:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Weitere IdentitÃ¤ten werden angewendet, wenn `%pi' und `%pi/2' mit
     einer ganzzahligen Variable multipliziert werden.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]


 -- Optionsvariable: %iargs
     Standardwert: `true'

     Hat `%iargs' den Wert `true', werden Winkelfunktionen zu
     Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches
     der imaginÃ¤ren Einheit `%i' ist.

     Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgefÃ¼hrt,
     wenn das Argument offensichtlich reel ist.

     Beispiele:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     Auch wenn das Argument offensichtlich reel ist, wird zu einer
     Hyperbelfunktion vereinfacht.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)


 -- Optionsvariable: halfangles
     Standardwert: `false'

     Hat `halfangles' den Wert `true', werden Winkel- und
     Hyperbelfunktionen mit halbzahligen Argumenten `<expr>/2'
     vereinfacht.

     FÃ¼r ein reelles Argument <x> im Intervall `0 < x < 2*%pi'
     vereinfacht der Sinus fÃ¼r ein halbzahliges Argument zu einer
     einfachen Formel:

                                   sqrt(1 - cos(x))
                                   ----------------
                                       sqrt(2)

     Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt
     ist fÃ¼r ein komplexes Argument <z>:

                     realpart(z)
               floor(-----------)
                        2 %pi
          (- 1)                   (1 - unit_step(- imagpart(z))

                                      realpart(z)            realpart(z)
                                floor(-----------) - ceiling(-----------)
                                         2 %pi                  2 %pi
                          ((- 1)                                          + 1))

     Maxima kennt diesen Faktor und Ã¤hnliche Faktoren fÃ¼r die Sinus,
     Cosinus, Sinus Hyperbolicus und Cosinus Hyperbolicus Funktionen.
     FÃ¼r spezielle Argumente z dieser Funktionen vereinfachen diese
     Funktionen entsprechend.

     Beispiele:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)


 -- Packet: ntrig
     Das Packet `ntrig' enthÃ¤lt Regeln, um Winkelfunktionen zu
     vereinfachen, die Argumente der Form `<f>(<n> %pi/10)' haben. <f>
     ist eine der Funktionen `sin', `cos', `tan', `csc', `sec' oder
     `cot'.

     Das Kommando `load(ntrig)' lÃ¤dt das Paket. Die Vereinfachungen
     werden dann von Maxima automatisch ausgefÃ¼hrt.


 -- Funktion: trigexpand (<expr>)
     Die Funktion `trigexpand' expandiert Winkel- und
     Hyperbelfunktionen im Ausdruck <expr>, die Summen und Vielfache
     von Winkeln als Argument haben.  Die besten Ergebnisse werden
     erzielt, wenn der Ausdruck <expr> zunÃ¤chst expandiert wird.

     Folgende Schalter kontrollieren `trigexpand':

    `trigexpand'
          Wenn `true', werden Sinus- und Cosinus-Funktionen expandiert.

    `halfangles'
          Wenn `true', werden Vereinfachungen fÃ¼r halbzahlige Argumente
          angewendet.

    `trigexpandplus'
          Wenn `true', werden Winkelfunktionen, die eine Summe als
          Argument haben, wie zum Beispiel `sin(x+y)', vereinfacht.

    `trigexpandtimes'
          Wenn `true',  werden Winkelfunktionen, die ein Produkt als
          Argument haben, wie zum Beispiel `sin(2 x)', vereinfacht.


     Beispiele:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Optionsvariable: trigexpandplus
     Standardwert: `true'

     `trigexpandplus' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion `trigexpand' fÃ¼r den Fall, dass
     Winkelfunktionen mit Summen als Argumente auftreten. Hat
     `trigexpandplus' den Wert `true', werden zum Beispiel
     Winkelfunktionen wie `sin(x+y)' vereinfacht.


 -- Optionsvariable: trigexpandtimes
     Standardwert: `true'

     `trigexpandtimes' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion `trigexpand' fÃ¼r den Fall, dass
     Winkelfunktionen mit Produkten als Argumente auftreten. Hat
     `trigexpandtimes' den Wert `true', werden zum Beispiel
     Winkelfunktionen wie `sin(2 x)' vereinfacht.


 -- Optionsvariable: triginverses
     Standardwert: `true'

     Kontrolliert die Vereinfachung, wenn das Argument einer
     Trigonometrischen oder Hyperbolischen Funktion eine der inversen
     Funktion ist.

     Hat `triginverses' den Wert `all', vereinfachen beide AusdrÃ¼cke
     `atan(tan(<x>))' und `tan(atan(<x>))' zum Wert <x>.

     Hat `triginverses' den Wert `all', wird `<arcfun>(<fun>(<x>))'
     nicht vereinfacht.

     Hat `triginverses' den Wert `false', werden `<arcfun>(<fun>(<x>))'
     und `<fun>(<arcfun>(<x>))' nicht vereinfacht.


 -- Funktion: trigreduce (<expr>, <x>)
 -- Funktion: trigreduce (<expr>)
     Produkte und Potenzen von Trigonometrischen und Hyperbolischen
     Sinus und Cosinus Funktionen mit dem Argument <x> werden zu
     Funktionen vereinfacht, die Vielfache von <x> enthalten.
     `trigreduce' versucht auch, Sinus und Cosinus Funktionen in einem
     Nenner zu eleminieren. Wird keine Variable <x> angegeben, werden
     alle Variablen im Ausdruck `expr' betrachtet.

     Siehe auch `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2


 -- Optionsvariable: trigsign
     Standardwert: `true'

     Hat `trigsign' den Wert `true', werden Trigonometrische Funktionen
     mit einem negativem Argument vereinfacht. Zum Beispiel vereinfacht
     in diesem Fall `sin(-x)' zu `-sin(x)'.


 -- Funktion: trigsimp (<expr>)
     Wendet die IdentitÃ¤ten `sin(x)^2 + cos(x)^2 = 1' und `cosh(x)^2 -
     sinh(x)^2 = 1' an, um AusdrÃ¼cke, die Funktionen wie `tan', `sec',
     usw. enthalten, zu AusdrÃ¼cken mit den Funktionen `sin', `cos',
     `sinh', `cosh' zu vereinfachen.

     Die Anwendung von Funktionen wie `trigreduce', `ratsimp' und
     `radcan' kann den Ausdruck weiter vereinfachen.

     Das Kommando `demo(trgsmp)' zeigt einige Beispiele.


 -- Funktion: trigrat (<expr>)
     Gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; <expr> is a rational fraction of several `sin', `cos'
     or `tan', the arguments of them are linear forms in some variables
     (or kernels) and `%pi/<n>' (<n> integer) with integer coefficients.
     The result is a simplified fraction with numerator and denominator
     linear in `sin' and `cos'. Thus `trigrat' linearize always when it
     is possible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     The following example is taken from Davenport, Siret, and
     Tournier, Calcul Formel, Masson (or in English, Addison-Wesley),
     section 1.5.5, Morley theorem.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4



File: maxima.info,  Node: Hyperbelfunktionen,  Next: Zufallszahlen,  Prev: Winkelfunktionen,  Up: Mathematische Funktionen

10.7 Hyperbelfunktionen
=======================

* Menu:

* EinfÃ¼hrung in Hyperbelfunktionen::
* Funktionen und Variablen fÃ¼r Hyperbelfunktionen::


File: maxima.info,  Node: EinfÃ¼hrung in Hyperbelfunktionen,  Next: Funktionen und Variablen fÃ¼r Hyperbelfunktionen,  Prev: Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.7.1 EinfÃ¼hrung in Hyperbelfunktionen
----------------------------------------


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Hyperbelfunktionen,  Prev: EinfÃ¼hrung in Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.7.2 Funktionen und Variablen fÃ¼r Hyperbelfunktionen
-------------------------------------------------------

 -- Funktion: acosh (<x>)
     - Areakosinus Hyperbolicus.


 -- Funktion: acoth (<x>)
     - Areakotangens Hyperbolicus.


 -- Funktion: acsch (<x>)
     - Areakosekans Hyperbolicus.


 -- Funktion: asech (<x>)
     - Areasekans Hyperbolicus.


 -- Funktion: asinh (<x>)
     - Areasinus Hyperbolicus.


 -- Funktion: atanh (<x>)
     - Areatangens Hyperbolicus.


 -- Funktion: cosh (<x>)
     - Kosinus Hyperbolicus.


 -- Funktion: coth (<x>)
     - Kotangens Hyperbolicus.


 -- Funktion: csch (<x>)
     - Kosekans Hyperbolicus.


 -- Funktion: sech (<x>)
     - Sekans Hyperbolicus.


 -- Funktion: sinh (<x>)
     - Sinus Hyperbolicus.


 -- Funktion: tanh (<x>)
     - Tangens Hyperbolicus.



File: maxima.info,  Node: Zufallszahlen,  Prev: Hyperbelfunktionen,  Up: Mathematische Funktionen

10.8 Zufallszahlen
==================

 -- Funktion: make_random_state (<n>)
 -- Funktion: make_random_state (<s>)
 -- Funktion: make_random_state (true)
 -- Funktion: make_random_state (false)
     Ein Zufallszustand reprÃ¤sentiert den Zustand des
     Zufallszahlengenerators. Der Zustand enthÃ¤lt 627 32-Bit Worte.

     `make_random_state(<n>)' gibt einen neuen Zufallszustand zurÃ¼ck,
     der aus einer ganzen Zahl <n> modulo 2^32 erzeugt wird. <n> kann
     eine negative Zahl sein.

     `make_random_state(<s>)' gibt eine Kopie des Zufallszutandes <s>
     zurÃ¼ck.

     `make_random_state(true)' gibt einen neuen Zufallszustand zurÃ¼ck,
     der aus der aktuellen Systemzeit des Computers erzeugt wird.

     `make_random_state(false)' gibt eine Kopie des aktuellen Zustands
     des Zufallszahlengenerators zurÃ¼ck.


 -- Funktion: set_random_state (<s>)
     Kopiert <s> in den Zufallszustand des Zufallszahlengenerators.

     `set_random_state' gibt immer `done' zurÃ¼ck.


 -- Funktion: random (<x>)
     Erzeugt eine Pseudo-Zufallszahl. Ist <x> eine ganze Zahl, gibt
     `random(<x>)' eine ganze Zahl im Intervall 0 bis einschlieÃlich
     `<x>-1' zurÃ¼ck. Ist <x> eine Gleitkommazahl, gibt `random(<x>)'
     eine positive Gleitkommazahl zurÃ¼ck, die kleiner als <x> ist.
     `random' gibt eine Fehlermeldung, wenn <x> weder eine ganze Zahl
     noch eine Gleitkommazahl ist oder wenn <x> eine negative Zahl ist.

     Die Funktionen `make_random_state' und `set_random_state' verwalten
     den Zustand des Zufallszahlengenerators.

     Der Maxima-Zufallszahlengenerator ist eine Implementation des
     Mersenne twister MT 19937.

     Beispiele:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853



File: maxima.info,  Node: Maximas Datenbank,  Next: Grafische Darstellung,  Prev: Mathematische Funktionen,  Up: Top

11 Maximas Datenbank
********************

* Menu:

* EinfÃ¼hrung in Maximas Datenbank::
* Funktionen und Variablen fÃ¼r Eigenschaften::
* Funktionen und Variablen fÃ¼r Fakten::
* Funktionen und Variablen fÃ¼r Aussagen::


File: maxima.info,  Node: EinfÃ¼hrung in Maximas Datenbank,  Next: Funktionen und Variablen fÃ¼r Eigenschaften,  Prev: Maximas Datenbank,  Up: Maximas Datenbank

11.1 EinfÃ¼hrung in Maximas Datenbank
=====================================

Eigenschaften
-------------

Variablen und Funktionen kÃ¶nnen mit der Funktion `declare' Eigenschaften
zugewiesen werden. Diese Eigenschaften werden in eine Datenbank
abgelegt oder in eine von Lisp bereitgestellte Eigenschaftsliste
eingetragen.

Variablen kÃ¶nnen die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden:

   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex

Funktionen kÃ¶nnen die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden:

   increasing     decreasing
   posfun         integervalued

Die folgenden Eigenschaften kÃ¶nnen fÃ¼r Funktionen definiert werden und
wirken sich auf die Vereinfachung dieser Funktionen aus:

   linear         additive       multiplicative
   outative       commutative    symmetric
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun

Weitere Eigenschaften, die Variablen und Funktionen erhalten kÃ¶nnen,
sind:

   bindtest       feature        alphabetic
   scalar         nonscalar


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Eigenschaften,  Next: Funktionen und Variablen fÃ¼r Fakten,  Prev: EinfÃ¼hrung in Maximas Datenbank,  Up: Maximas Datenbank

11.2 Funktionen und Variablen fÃ¼r Eigenschaften
================================================

 -- Eigenschaft: alphabetic
     Das Kommando `declare(s, alphabetic)' deklariert alle Zeichen der
     Zeichenkette <s> als alphabetisch. Das Argument <s> muss eine
     Zeichenkette sein. Siehe auch `Bezeichner'.

     Beispiele:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]


 -- Eigenschaft: bindtest
     Hat ein Symbol <x> die Eigenschaft `bindtest' und wird es
     ausgewertet, ohne das dem Symbol bisher ein Wert zugewiesen wurde,
     signalisiert Maxima einen Fehler. Siehe `declare'.


 -- Eigenschaft: constant
     `declare(<a>, constant)' deklariert ein Symbol <a> als konstant.
     Siehe `declare'.


 -- Funktion: constantp (<expr>)
     Gibt fÃ¼r einen konstanten Ausdruck <expr> den Wert `true' zurÃ¼ck,
     andernfalls `false'.

     Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt,
     wenn seine Argumente Zahlen sind (einschlieÃlich von Zahlen in
     einer CRE-Darstellung), symbolische Konstanten wie `%pi', `%e' und
     `%i', Variablen, die einen konstanten Wert haben oder die mit
     `declare' als konstant deklariert sind, oder Funktionen, deren
     Argumente konstant sind.

     Die Funktion `constantp' wertet ihre Argument aus.

     Beispiele:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)


 -- Funktion: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Weist dem Atom oder den Atomen einer Liste <a_i> die Eigenschaft
     oder die Eigenschaften in einer Liste <p_i> zu. Ist <a_i> und/oder
     <p_i> eine Liste, erhÃ¤lt jedes Atom die aufgefÃ¼hrten Eigenschaften.

     Die Funktion `declare' wertet ihre Argumente nicht aus. `declare'
     gibt stets `done' zurÃ¼ck.

     Wie in den folgenden Beschreibungen ausgefÃ¼hrt, gibt
     `featurep(<object>, <feature>)' fÃ¼r einige Schalter `true' zurÃ¼ck,
     wenn <object> die Eigenschaft <feature> erhalten hat.

     Die Funktion `declare' kennt die folgenden Eigenschaften:

    `evfun'
          Deklariert <a_i> als eine Auswertungsfunktion. Tritt die
          Funktion <a_i> als Argument der Funktion `ev' auf, so wird
          die Funktion angewendet. Siehe `evfun'.

    `evflag'
          Deklariert `a_i' als ein Auswertungsflag. WÃ¤hrend der
          Auswertung von `ev' erhÃ¤lt das Auswertungsflag `a_i' den Wert
          `true'. Siehe `evflag'.

    `bindtest'
          Wird das Symbol <a_i> ausgewertet, ohne das dem Symbol bisher
          ein Wert zugewiesen wurde, signalisiert Maxima einen Fehler.

    `noun'
          <a_i> wird als Substantivform interpretiert. AbhÃ¤ngig vom
          Kontext wird <a_i> durch `'<a_i>' oder `nounify(<a_i>)'
          ersetzt.

    `constant'
          <a_i> wird als eine symbolische Konstante interpretiert.

    `scalar'
          <a_i> wird als skalare Variable interpretiert.

    `nonscalar'
          <a_i> wird als eine nicht-skalare Variable interpretiert.
          Ãberlicherweise wird damit ein symbolischer Vektor oder eine
          Matrix deklariert.

    `nonarray'
          <a_i> wird nicht als ein Array interpretiert. Diese
          Deklaration verhindert die mehrfache Auswertung, wenn <a_i>
          als indizierte Variable genutzt wird.

    `mainvar'
          <mainvar> wird als eine "Hauptvariable" interpretiert. Eine
          Hauptvariable wird vor allen Konstanten und Variablen in
          einer kanonischen Ordnung eines Maxima-AusdrÃ¼ckes angeordnet.
          Die Anordnung wird durch die Funktion `ordergreatp' bestimmt.

    `alphabetic'
          <a_i> is ein String, dessen Zeichen von Maxima als
          alphabetische Zeichen interpretiert werden.

    `feature'
          <a_i> wird als eine Eigenschaft `feature' interpretiert.
          Andere Symbole kÃ¶nnen dann diese Eigenschaft erhalten.

    `rassociative', `lassociative'
          <a_i> wird als eine rechts- oder links-assoziative Funktion
          interpretiert.

    `nary'
          <a_i> wird als eine Nary-Funktion interpretiert.
          Verschachtelte AusdrÃ¼cke wie `foo(x, foo(y,z))' werden zu
          `foo(x, y, z)' vereinfacht. Die Deklaration `nary'
          unterscheidet sich von der Funktion `nary'. WÃ¤hrend der
          Funktionsaufruf einen neuen Operator definiert, wirkt sich
          die Deklaration nur auf die Vereinfachung aus.

    `symmetric', `antisymmetric', `commutative'
          <a_i> wird als eine symmetrische, antisymmetrische oder
          kommutative Funktion interpretiert. `commutative' und
          `symmtric' sind Ã¤quivalent.

    `oddfun', `evenfun'
          <a_i> wird als eine ungerade oder gerade Funktion
          interpretiert.

    `outative'
          AusdrÃ¼cke mit der Funktion <a_i> werden so vereinfacht, dass
          konstante Faktoren aus dem Argument herausgezogen werden. Hat
          die Funktion <a_i> ein Argument, wird ein Faktor dann als
          konstant angesehen, wenn er ein Symbol oder eine deklarierte
          Konstante ist. Hat die Funktion <a_i> zwei oder mehr
          Argumente, wird ein Faktor dann als konstant angesehen, wenn
          das zweite Argument ein Symbol und der Faktor unabhÃ¤ngig vom
          zweiten Argument ist.

    `multiplicative'
          AusdrÃ¼cke `<a_i>(x * y * z * ...)' werden durch `<a_i>(x) *
          <a_i>(y) * <a_i>(z) * ...' ersetzt. Die Ersetzung wird nur
          fÃ¼r das Argument der Funktion <a_i> ausgefÃ¼hrt.

    `additive'
          AusdrÃ¼cke `<a_i>(x + y + z + ...)' werden  durch `<a_i>(x) +
          <a_i>(y) + <a_i>(z) + ...' ersetzt. Die Ersetzung wird nur
          fÃ¼r das Argument ausgefÃ¼hrt.

    `linear'
          Entspricht der Deklaration einer Funktion als `outative' und
          `additive'.

    `integer', `noninteger'
          <a_i> wird als eine ganzzahlige oder nichtganzzahlige Variable
          interpretiert.

    `even', `odd'
          <a_i> wird als eine gerade oder ungerade ganze Zahl
          interpretiert.

    `rational', `irrational'
          <a_i> wird als eine rationale oder irrationale Zahl
          interpretiert.

    `real', `imaginary', `complex'
          <a_i> wird als eine reelle, imaginÃ¤re oder komplexe Zahl
          interpretiert.

    `increasing', `decreasing'
          <a_i> wird als eine steigende oder fallende Funktion
          interpretiert.

    `posfun'
          <a_i> wird als eine positive Funktion interpretiert.

    `integervalued'
          <a_i> wird als Funktion mit ganzzahligen Werten interpretiert.


     Beispiele:

     `evfun' und `evflag' Deklarationen.

          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     `bindtest' Deklaration.

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     `noun' Deklaration.

          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     `alphabetic' Deklaration.

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     `feature' Deklaration.

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     `nary' Deklaration.

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     `symmetric' und `antisymmetric' Deklarationen.

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     `oddfun' und `evenfun' Deklarationen.

          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     `outative' Deklaration.

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     `multiplicative' Deklaration.

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     `additive' Deklaration.

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     `linear' Deklaration.

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1


 -- Eigenschaft: feature
     Maxima kennt Systemeigenschaften und mathematische Eigenschaften,
     die Symbole und AusdrÃ¼cke haben kÃ¶nnen. FÃ¼r Systemeigenschaften
     siehe die Funktion `status'.   FÃ¼r mathematische Eigenschaften
     siehe die Funktionen `declare'  und `featurep'.

     `feature' ist eine Eigenschaft, die ein Symbol <sym> mit der
     Funktion `declare' erhalten kann. In diesem Fall ist das Symbol
     selbst eine Eigenschaft, so dass das Kommando `declare(x, sym)'
     einem Symobl <x> die neu definierte Eigenschaft `sym' gibt.


 -- Funktion: featurep (<a>, <f>)
     Stellt fest, ob das Symbol oder der Ausdruck <a> die Eigenschaft
     <f> hat. Maxima nutzt dafÃ¼r die Fakten der Datenbank und die
     definierten Eigenschaften fÃ¼r Symbole und Funktionen.

     `featurep' gibt sowohl fÃ¼r den Fall `false' zurÃ¼ck, dass das
     Argument <a> nicht die Eigenschaft <f> hat, als auch fÃ¼r den Fall,
     dass Maxima dies nicht anhand der bekannten Fakten und
     Eigenschaften entscheiden kann.

     `featurep' wertet seine Argumente aus.

     Siehe auch `declare'  und `featurep'.  .

     Beispiele:

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Systemvariable: features
     Standardwert: `[]'

     Maxima erkennt spezielle mathematische Eigenschaften von
     Funktionen und Variablen.

     `declare(<x>)', <foo> gibt der Funktion oder Variablen <x> die
     Eigenschaft <foo>.

     `declare(<foo>, feature)' deklariert die neue Eigenschaft <foo>.
     Zum  Beispiel deklariert `declare([red, green, blue], feature)'
     die drei neuen Eigenschaften `red', `green' und `blue'.

     `featurep(<x>, <foo>)' hat die RÃ¼ckgabe `true', wenn <x> die
     Eigenschaft <foo> hat. Ansonsten wird `false' zurÃ¼ckgegeben.

     Die Informationsliste `features' enthÃ¤lt eine Liste der
     Eigenschaften, die Funktionen und Variablen erhalten kÃ¶nnen und in
     die Datenbank eingetragen werden:

     `integer', `noninteger', `even', `odd', `rational', `irrational',
     `real', `imaginary', `complex', `analytic', `increasing',
     `decreasing', `oddfun', `evenfun', `posfun', `commutative',
     `lassociative', `rassociative', `symmetric', und `antisymmetric'.

     Hinzu kommen die vom Nutzer definierten Eigenschaften.

     `features' ist eine Liste der mathematischen Eigenschaften. Es gibt
     weitere Eigenschaften. Siehe `declare'  und `status'.


 -- Eigenschaft: nonarray
     `declare(a, nonarray)' gibt dem Symbol <a> die Eigenschaft nicht
     ein Array zu sein. Dies verhindert die mehrfache Auswertung, wenn
     das Symbol <a> als indizierte Variable genutzt wird.

     Beispiel:

          (%i1) a:'b$ b:'c$ c:'d$

          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x


 -- Eigenschaft: nonscalar
     Hat ein Symbol die Eigenschaft `nonscalar', verhÃ¤lt es sich wie
     eine Matrix oder Liste bei nicht-kommutativen Rechenoperationen.


 -- Funktion: nonscalarp (<expr>)
     Gibt `true' zurÃ¼ck, wenn der Ausdruck <expr> kein Skalar ist. Der
     Ausdruck enthÃ¤lt dann Matrizen, Listen oder Symbole, die als
     `nonscalar' deklariert wurden.


 -- Eigenschaft: posfun
     `declare(f, posfun)' deklariert die Funktion `f' als positive
     Funktion. `is (f(x) > 0)' gibt dann `true' zurÃ¼ck.


 -- Funktion: printprops (<a>, <i>)
 -- Funktion: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Funktion: printprops (all, <i>)
     Zeigt die zum Kennzeichen <i> zugeordnete Eigenschaft des Atoms
     <a> an.  <a> kann sowohl eine Liste von Atomen, als auch das Atom
     `all' sein. In diesem Fall werden alle Atome angezeigt, die eine
     Eigenschaft zum Kennzeichen <i> haben. `printprops' zeigt die
     Eigenschaften von Atomen, die auf andere Weise nicht angezeigt
     werden kÃ¶nnen, zum Beispiel fÃ¼r `atvalue', `atomgrad', `gradef'
     und `matchdeclare'.


 -- Eigenschaft: scalar
     Hat ein Symbol die Eigenschaft `scalar', verhÃ¤lt es sich wie ein
     Skalar bei nicht-kommutativen Rechenoperationen.



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Fakten,  Next: Funktionen und Variablen fÃ¼r Aussagen,  Prev: Funktionen und Variablen fÃ¼r Eigenschaften,  Up: Maximas Datenbank

11.3 Funktionen und Variablen fÃ¼r Fakten
=========================================

 -- Funktion: activate (<context_1>, ..., <context_n>)
     Die Funktion `activate(<context>)' aktiviert den Kontext <context>.
     Der Funktion `activate' kÃ¶nnen auch mehrere Kontexte <context_1>,
     ..., <context_n> Ã¼bergeben werden. Nur die Fakten eines aktiven
     Kontextes stehen fÃ¼r die Auswertung von Aussagen zur VerfÃ¼gung.

     Maxima gibt `done' zurÃ¼ck, wenn der Kontext erfolgreich aktiviert
     werden konnte oder wenn der Kontext bereits aktiv ist. Wird
     versucht, einen nicht existierenden Kontext zu aktivieren, gibt
     Maxima eine Fehlermeldung aus.

     Das Kommando `facts()' gibt immer die Fakten des aktuellen
     Kontextes aus.  Die Fakten anderer Kontexte kÃ¶nnen zwar aktiv
     sein, sind aber in der RÃ¼ckgabe von `facts' nicht enthalten. Um
     die Fakten eines anderen Kontextes <context> auszugeben, kann das
     Kommando `facts(<context>)' ausgefÃ¼hrt werden.

     Die Systemvariable `activecontexts'  enthÃ¤lt eine Liste der aktiven
     Kontexte.


 -- Systemvariable: activecontexts
     Standardwert: `[]'

     Die Systemvariable `activecontexts' enthÃ¤lt eine Liste der
     Kontexte, die mit der Funktion `activate' aktiviert wurden.
     Subkontexte eines Kontexts sind aktiv, ohne dass die Funktion
     `activate' aufgerufen werden muss und sind daher nicht in der
     Liste `activecontexts' enthalten. Siehe auch die Funktion
     `activate'.


 -- Systemvariable: askexp
     Wenn `asksign' aufgerufen wird, enthÃ¤lt `askexp' den Ausdruck, der
     von `asksign' getestet wird.

     Es war einmal mÃ¶glich, die Variable `askexp' nach einer
     Unterbrechnung mit Control-A zu inspezieren.


 -- Funktion: askinteger (<expr>, integer)
 -- Funktion: askinteger (<expr>)
 -- Funktion: askinteger (<expr>, even)
 -- Funktion: askinteger (<expr>, odd)
     `askinteger(<expr>, integer)' versucht anhand der Fakten in der
     `assume'-Datenbank zu entscheiden, ob <expr> eine ganze Zahl ist.
     Kann `askinteger' die Frage nicht beantworten, fragt Maxima den
     Nutzer. Die erhaltene Anwort wird in die Datenbank eingetragen.
     `askinteger(<expr>)' ist Ã¤quivalent zu `askinteger(<expr>,
     integer)'.

     `askinteger(<expr>, even)' und `askinteger(<expr>, odd)' versuchen
     zu entscheiden, ob <expr> eine gerade oder gerade ganze Zahl ist.
     Kann Maxima dies nicht entscheiden, wird der Nutzer gefragt. Die
     Antwort wird jedoch nur dann in die Datenbank eingetragen, wenn
     bereits eingetragen ist, dass <expr> eine ganze Zahl ist.


 -- Funktion: asksign (<expr>)
     Die Funktion `asksign' versucht zu entscheiden, ob der Ausdruck
     <expr> positiv, negativ oder null ist. Kann Maxima dies nicht
     feststellen, wird der Nutzer nach weiteren Informationen gefragt,
     um die Frage zu entscheiden. Die Antworten des Nutzers werden fÃ¼r
     die laufende Auswertung in die Datenbank eingetragen. Der
     RÃ¼ckgabewert von `asksign' ist `pos', `neg' oder `zero'.


 -- Funktion: assume (<pred_1>, ..., <pred_n>)
     FÃ¼gt die Aussagen <pred_1>, ..., <pred_n> dem gegenwÃ¤rtigen Kontext
     hinzu. Eine inkonsistente oder redunante Aussage wird dem Kontext
     nicht hinzugefÃ¼gt. Jeder Aufruf von `assume' fÃ¼gt dem Kontext
     weitere Aussagen hinzu.

     `assume' gibt eine Liste mit den Aussagen zurÃ¼ck, die dem Kontext
     hinzugefÃ¼gt wurden, oder die Symbole `redunant' sowie
     `inconsistent'.

     Die Aussagen <pred_1>, ..., <pred_n> kÃ¶nnen nur AusdrÃ¼cke mit den
     Relationalen Operatoren `< <= equal notequal >=' und `>' sein.
     Aussagen kÃ¶nnen nicht die Operatoren `=' fÃ¼r die Gleichheit oder
     `#' fÃ¼r die Ungleichheit enthalten. Auch kÃ¶nnen keine
     Aussagefunktionen wie `integerp' verwendet werden.

     Zusammengesetzte Aussagen der Form `<pred_1> and ... and <pred_n>'
     werden erkannt, nicht dagegen Aussagen der Form `<pred_1> or ... or
     <pred_n>'. `not(<pred_k>' wird erkannt, wenn <pred_k> eine
     relationale Aussage ist. Aussagen der Form `not (<pred_1> and
     <pred_2>)' and `not (<pred_1> or <pred_2>)' werden nicht erkannt.

     Der Folgerungsmechanismus von Maxima ist nicht sehr stark. Viele
     offensichtlichen SchluÃfolgerungen kÃ¶nnen von Maxima nicht
     abgeleitet werden.  Dies ist eine bekannte SchwÃ¤che von Maxima.

     `assume' behandelt keine Aussagen mit komplexen Zahlen. EnthÃ¤lt
     eine Aussage eine komplexe Zahl, gibt `assume' den Wert
     `inconsistent' oder `redunant' zurÃ¼ck.

     `assume' wertet seine Argumente aus.

     Siehe auch `is', , `facts', , `forget', , `context'  und `declare'.

     Beispiele:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Optionsvariable: assumescalar
     Standardwert: `true'

     Hat die Optionsvariable `assumescalar' den Wert `true', werden
     AusdrÃ¼cke die mit `nonscalarp(expr)' den Wert `false' haben, in
     bestimmten Transformationen als ein Scalar behandelt.

     Ist `expr' irgendein Ausdruck bis auf eine Liste oder eine Matix
     und `[1, 2, 3]' reprÃ¤sentiert eine Liste oder eine Matrix. Dann
     ergibt `expr . [1, 2, 3]' das Ergebnis `[expr, 2 expr, 3 expr]',
     wenn `assumescalar', `scalarp(expr)' oder `constantp(expr' den Wert
     `true' hat.

     Hat `assumescalar' den Wert `true', solche AusdrÃ¼cke verhalten sich
     wie Skalare nur fÃ¼r kommutative Operatoren, aber nicht fÃ¼r die
     nicht-kommutative Multiplikation `.'.

     Hat `assumescalar' den Wert `false', verhalten sich solche
     AusdrÃ¼cke wie Nicht-Skalare.

     Hat `assumescalar' den Wert `all', verhalten sich solche AusdrÃ¼cke
     wie Skalare fÃ¼r alle oben genannten Operatoren.


 -- Optionsvariable: assume_pos
     Standardwert: `false'

     Hat die Optionsvariable `assume_pos' den Wert `true' und das
     Vorzeichen eines Parameters <x> kann nicht bestimmt werden vom
     gegenwÃ¤rtigen Kontext oder aus anderen ZusammenhÃ¤ngen, geben
     `sign(<x>)' und `asksign(<x>)' das Ergebnis `true'. Dadurch kÃ¶nnen
     automatische Abfragen wie sie von `integrate' ausgefÃ¼hrt werden,
     vermieden werden.

     StandardmÃ¤Ãig ist ein Parameter <x>, so dass `symbolp(<x>)' oder
     `subvarp(<x>)'. Die Klasse an AusdrÃ¼cken, die als Parameter
     betrachtet werden, kann mit der Optionsvariablen `assume_pos_pred'
     erweitert werden.

     `sign' und `asksing' versuchen das Vorzeichen eines Ausdruckes vom
     Vorzeichen der Operanten eines Ausdruckes zu ermitteln. Sind zum
     Beispiel `a' und `b' beide postive, dann hat auch `a+b' ein
     positives Vorzeichen.

     Jedoch gibt es keine MÃ¶glichkeit, alle Fragen von `asksign' zu
     vermeiden.  So fragt `asksign' auf jeden Fall nach dem Vorzeichen
     fÃ¼r eine Differenz `<x> - <y>' oder einen Logarithmus `log(<x>)',
     auch wenn `assume_pos' den Wert `true' hat und `assume_pos_pred'
     eine Funktion ist, die fÃ¼r alle Argumente den Wert `true'
     zurÃ¼ckgibt.


 -- Optionsvariable: assume_pos_pred
     Standardwert: `false'

     Wird der Optionsvariablen `assume_pos_pred' der Name einer
     Funktion oder ein Lambda-Ausdruck mit einem Argument <x>
     zugewiesen, wird diese Funktion aufgerufen, um festzustellen, ob
     <x> als ein Parameter im Zusammenhang mit `assume_pos' behandelt
     wird. `assume_pos_pred' wird ignoriert, wenn die Optionsvariable
     `assume_pos' den Wert `false' hat.

     Die `assume_pos_pred'-Funktion wird von den Funktionen `sign' und
     `asksign' mit einem Argument <x> aufgerufen, welches entweder ein
     Symbol, eine indizierte Variable oder ein Funktionsaufruf ist. Gibt
     `assume_pos_pred' den Wert `true' zurÃ¼ck, wird <x> als ein
     Parameter fÃ¼r `assuem_pos' betrachtet.

     StandardmÃ¤Ãig ist ein Parameter <x>, so dass `symbolp(<x>)' oder
     `subvarp(<x>)'.

     Siehe auch `assume' und `assume_pos'.

     Beispiele:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Optionsvariable: context
     Standardwert: `initial'

     Die Optionsvariable `context' enthÃ¤lt den Namen des aktuellen
     Kontexts. Das ist der Kontext, der die Fakten der Funktion
     `assume' aufnimmt oder aus dem Fakten mit der Funktion `forget'
     gelÃ¶scht werden.

     Wird der Optionsvariable `context' der Name <foo> zugewiesen, wird
     der Kontext <foo> zum aktuellen Kontext. Existiert dieser Kontext
     noch nicht, wird er automatisch durch Aufruf der Funktion
     `newcontext' erzeugt.

     Siehe auch `contexts'  fÃ¼r eine allgemeinere Beschreibung von
     Kontexten.


 -- Optionsvariable: contexts
     Standardwert: `[initial, global]'

     Die Optionsvariable `contexts' enthÃ¤lt eine Liste der Kontexte,
     die aktuell vorhanden sind. Darin sind auch die Kontexte
     enthalten, die aktuell nicht aktiv sind.

     Kontexte kÃ¶nnen genutzt werden, um eine Vielzahl von Fakten
     zusammenzustellen.  Diese Fakten kÃ¶nnen dann durch Aktivierung
     oder Deaktivierung des Kontextes fÃ¼r die Auswertung von Aussagen
     verfÃ¼gbar gemacht und wieder ausgeschaltet werden.

     Der Name eines Kontextes kann irgendein Symbol sein. Die Fakten in
     einem Kontext bleiben so lange verfÃ¼gbar, bis sie entweder einzeln
     mit der Funktion `forget' oder der gesamte Kontext mit der
     Funktion `kill' gelÃ¶scht werden.

     Kontexte haben eine Hierarchie. Die Wurzel ist immer der Kontext
     `global', welcher Informationen enthÃ¤lt, die Maxima fÃ¼r die
     Auswertung und Vereinfachung von Funktionen benÃ¶tigt. Neben den
     Fakten des aktuellen Kontextes sind immer auch alle Fakten alle
     Subkontexte verfÃ¼gbar.

     Wird Maxima gestarted, ist der aktuelle und aktive Kontext
     `initial'.  Dieser enthÃ¤lt den Subkontext `global'.

     Siehe auch `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume', und `forget'.


 -- Funktion: deactivate (<context_1>, ..., <context_n>)
     Die Kontexte <context_1>, ..., <context_n> werden deaktiviert. Die
     Fakten dieser Kontexte stehen fÃ¼r die Auswertung von Aussagen
     nicht mehr zur VerfÃ¼gung. Die Kontexte werden jedoch nicht
     gelÃ¶scht und kÃ¶nnen mit der Funktion `activate' wieder aktiviert
     werden.

     Die deaktivierten Kontexte werden aus der Liste `activecontexts'
     entfernt.

     Siehe auch `activate'  und `activecontexts'.


 -- Funktion: facts (<item>)
 -- Funktion: facts ()
     Ist <item> der Name eines Kontexts, gibt `facts(<item>)' eine
     Liste aller Fakten des Kontextes zurÃ¼ck.

     Ist <item> nicht der Name eines Kontexts, gibt `facts (<item>)'
     eine List der Fakten zurÃ¼ck, die zu <item> im aktuellen Kontext
     bekannt sind. Fakten, die aktiv sind, aber zu einem anderen
     Kontext gehÃ¶ren, sind nicht in der Liste enthalten.

     `facts()' gibt eine Liste der Fakten des aktuellen Kontextes
     zurÃ¼ck.


 -- Funktion: forget (<pred_1>, ..., <pred_n>)
 -- Funktion: forget (<L>)
     Entfernt Fakten die mit `assume' einem Kontext hinzugefÃ¼gt wurden.
     Die Fakten kÃ¶nnen AusdrÃ¼cke sein, die Ã¤quivalent aber nicht
     unbedingt identisch zu vorherigen Fakten sind.

     `forget(<L>)' entfernt alle Fakten, die in der Liste <L> enthalten
     sind.


 -- Funktion: is (<expr>)
     versucht festzustellen, ob die Aussage <expr> mit Hilfe der Fakten
     in der Datenbank entschieden werden kann.

     Kann die Aussage zu `true' oder `false' entschieden werden, wird
     das entsprechende zurÃ¼ck gegeben. Andernfalls wird der
     RÃ¼ckgabewert durch das globale Flag `prederror' bestimmt. Hat
     `prederror' den Wert `true', wird eine Fehlermeldung erzeugt.
     Andernfalls wird `unknown' zurÃ¼ck gegeben.

     Siehe auch `assume', `facts' und `maybe'.

     Beispiele:

     `is' wertet Aussagen aus:

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' versucht Aussagen anhand der Fakten der Datenbank zu
     entscheiden.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Wenn `is' eine Aussage anhand der Fakten der Datenbank nicht
     entscheiden kann, wird der RÃ¼ckgabewert vom Wert des globalen
     Flags `prederror' bestimmt.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Funktion: killcontext (<context_1>, ..., <context_n>)
     Das Kommando `killcontext(<context>)' lÃ¶scht den Kontext <context>.

     Ist einer der Kontexte der aktuelle Kontext, wird der erste
     vorhandene Subkontext zum aktuellen Kontext. Ist der erste
     verfÃ¼gbare Kontext der Kontext `global', dann wird der Kontext
     `initial' zum aktuellen Kontext. Wird der Kontext `initial'
     gelÃ¶scht, dann wird eine neuer leerer Kontext `initial' erzeugt.

     `killcontext' lÃ¶scht einen Kontext nicht, wenn dieser ein
     Subkontext des aktuellen Kontextes ist oder wenn der Kontext mit
     der Funktion `activate' aktiviert wurde.

     `killcontext' wertet seine Argumente aus. `killcontext' gibt
     `done' zurÃ¼ck.


 -- Funktion: maybe (<expr>)
     Versucht festzustellen, ob die Aussage <expr> anhand der `assume'
     Datenbank beweisbar ist.

     Kann die Aussage als `true' oder `false' bewiesen werden, gibt
     `maybe' entsprechend `true' oder `false' zurÃ¼ck. Andernfalls gibt
     `maybe' den Wert `unknown' zurÃ¼ck.

     `maybe' entspricht der Funktion `is' mit `prederror: false'.
     Dabei wird `maybe' ausgefÃ¼hrt, ohne dass `prederror' einen Wert
     erhÃ¤lt.

     Siehe auch `assume', `facts' und `is'.

     Beispiele:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Funktion: newcontext (<name>)
     `newcontext(<name>)' erzeugt einen neuen, leeren Kontext mit dem
     Namen <name>. Der neue Kontext hat den Kontext `global' als
     Subkontext und wird zum aktuellen Kontext.

     `newcontext' wertet seine Argumente aus. `newcontext' gibt `name'
     zurÃ¼ck.


 -- Funktion: sign (<expr>)
     Versucht das Vorzeichen des Ausdrucks <expr> auf Grundlage der
     Fakten der aktuellen Datenbank zu finden. `sign' gibt eine der
     folgende Antworten zurÃ¼ck: `pos' (positiv), `neg' (negative),
     `zero' (null), `pz' (positive oder null), `nz' (negative oder
     null), `pn' (positiv oder negative) oder `pnz' (positiv, negative
     oder null, fÃ¼r den Fall das Vorzeichen nicht bekannt ist).


 -- Funktion: supcontext (<name>, <context>)
 -- FunKtion: supcontext (<name>)
     erzeugt einen neuen Kontext, mit dem Namen `name', der den Kontext
     `context' als eine Subkontext enthÃ¤lt. Der Kontext <context> muss
     existieren.

     Wird <context> nicht spezifiziert, wird der aktuelle Kontext zum
     Subkontext.



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Aussagen,  Prev: Funktionen und Variablen fÃ¼r Fakten,  Up: Maximas Datenbank

11.4 Funktionen und Variablen fÃ¼r Aussagen
===========================================

 -- Funktion: charfun (<p>)
     Gibt den Wert 0 zurÃ¼ck, wenn die Aussage <p> zu `false' ausgewertet
     werden kann und den Wert 1, wenn die Auswertung `true' liefert.
     Kann die Aussage weder zu `false' oder `true' ausgewertet werden,
     wird eine Substantiv-Form zurÃ¼ck gegeben.

     Beispiele:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]


 -- Funktion: compare (<x>, <y>)
     Liefert den Vergleichsoperator <op> (`<', `<=', `>', `>=', `='
     oder `#'), so dass der Ausdruck `is(<x> <op> <y>)' zu `true'
     ausgewertet werden kann. Ist eines der Argumente eine komplexe
     Zahl, dann wird `notcomparable' zurÃ¼ckgegeben.  Kann Maxima keinen
     Vergleichsoperator bestimmen, wird `unknown' zurÃ¼ckgegeben.

     Beispiele:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     Die Funktion `compare' versucht nicht festzustellen, ob der
     Wertebereich einer Funktion reelle Zahlen enthÃ¤lt. Obwohl der
     Wertebereich von `acos(x^2+1)' bis auf Null keine reellen Zahlen
     enthÃ¤lt, gibt `compare' das folgende Ergebnis zurÃ¼ck:

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <


 -- Funktion: equal (<a>, <b>)
     ReprÃ¤sentiert die Ãquivalenz, das heiÃt den gleichen Wert.

     `equal' wird nicht ausgewertet oder vereinfacht. Die Funktion `is'
     versucht einen Ausdruck mit `equal' zu einem boolschen Wert
     auszuwerten.  `is(equal(<a>, <b>))' gibt `true' oder `false'
     zurÃ¼ck, wenn und nur wenn <a> und <b> gleich oder ungleich sind
     fÃ¼r alle Werte ihrer Variablen, was mit `ratsimp(<a> - <b>)'
     bestimmt wird. Gibt `ratsimp' das Ergebnis 0 zurÃ¼ck, werden die
     beiden AusdrÃ¼cke als Ã¤quivalent betracht. Zwei AusdrÃ¼cke kÃ¶nnen
     Ã¤quivalent sein, obwohl sie nicht syntaktisch gleich (im
     allgemeinen identisch) sind.

     Kann `is' einen Ausdruck mit `equal' nicht zu `true' oder `false'
     auswerten, hÃ¤ngt das Ergebnis vom Wert des globalen Flags
     `prederror' ab. Hat `prederror' den Wert `true', gibt `is' eine
     Fehlermeldung zurÃ¼ck. Ansonsten wird `unknown' zurÃ¼ckgegeben.

     Es gibt weitere Operatoren, die einen Ausdruck mit `equal' zu
     `true' oder `false' auswerten kÃ¶nnen. Dazu gehÃ¶ren `if', `and',
     `or' und `not'.

     Die Umkehrung von `equal' ist `notequal'.

     Beispiele:

     `equal' wird von allein weder ausgewertet noch vereinfacht:

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     Die Funktion `is' versucht, `equal' zu einem boolschen Wert
     auszuwerten. `is(equal(<a>, <b>))' gibt den Wert `true' zurÃ¼ck,
     when `ratsimp(<a> - <b>)' den Wert 0 hat. Zwei AusdrÃ¼cke kÃ¶nnen
     Ã¤quivalent sein, obwohl sie nicht syntaktisch gleich sind.

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Kann `is' einen Ausdruck mit `equal' nicht zu `true' oder `false'
     vereinfachen, hÃ¤ngt das Ergebnis vom Wert des globalen Flags
     `prederror' ab.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Einige weitere Operatoren werten `equal' und `notequal' zu einem
     boolschen Wert aus.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Da `not <expr>' den Ausdruck <expr> auswertet, ist `not equal(<a>,
     <b>)' Ã¤quivalent zu `is(notequal(<a>, <b>))'

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true


 -- Funktion: notequal (<a>, <b>)
     ReprÃ¤sentiert die Verneinung von `equal(<a>, <b>)'.

     Beispiele:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true


 -- Funktion: unknown (<expr>)
     Gibt den Wert `true' zurÃ¼ck, wenn der Ausdruck <expr> einen
     Operator oder eine Funktion enthÃ¤lt, die nicht von Maximas
     Vereinfacher erkannt wird.


 -- Funktion: zeroequiv (<expr>, <v>)
     Testet, ob ein Ausdruck <expr> mit der Variablen <v> Ã¤quivalent zu
     Null ist. Die Funktion gibt `true', `false' oder `dontknow' zurÃ¼ck.

     `zeroequiv' hat EinschrÃ¤nkungen:

       1. Funktionen im Ausdruck <expr> mÃ¼ssen von Maxima
          differenzierbar und auswertbar sein.

       2. Hat der Ausdruck Pole auf der reellen Achse, kÃ¶nnen Fehler
          auftreten.

       3. EnthÃ¤lt der Ausdruck Funktionen, die nicht LÃ¶sung einer
          Differentialgleichung erster Ordnung sind (zum Beispiel
          Bessel Funktionen), kÃ¶nnen die Ergebnisse fehlerhaft sein.

       4. Der Algorithmus wertet die Funktion an zufÃ¤llig Punkten fÃ¼r
          ausgewÃ¤hlte TeilausdrÃ¼cke aus. Dies ist ein riskantes
          Verfahren und kann zu Fehlern fÃ¼hren.

     `zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)' hat zum Beispiel das
     Ergebnis `true' und  `zeroequiv (%e^x + x, x)' hat das Ergebnis
     `false'.  Andererseits hat `zeroequiv (log(a*b) - log(a) - log(b),
     a)' das Ergebnis `dontknow', wegen dem zusÃ¤tzlichem Parameter `b'.



File: maxima.info,  Node: Grafische Darstellung,  Next: Eingabe und Ausgabe,  Prev: Maximas Datenbank,  Up: Top

12 Grafische Darstellung
************************

* Menu:

* EinfÃ¼hrung in die grafische Darstellung::
* Grafikformate::
* Funktionen und Variablen fÃ¼r die grafische Darstellung::
* Grafikoptionen::
* Gnuplot Optionen::
* Gnuplot_pipes Formatfunktionen::


File: maxima.info,  Node: EinfÃ¼hrung in die grafische Darstellung,  Next: Grafikformate,  Prev: Grafische Darstellung,  Up: Grafische Darstellung

12.1 EinfÃ¼hrung in die grafische Darstellung
=============================================

Maxima verwendet externe Grafikprogramme, um grafische Darstellungen
auszugeben.  Die Grafikfunktionen berechnen die Punkte der Grafik und
senden diese mit einem Satz an Kommandos an das externe Grafikprogramm.
Die Daten werden als Datenstrom Ã¼ber eine Pipe oder als eine Datei an
das Grafikprogramm Ã¼bergeben. Die Datei erhÃ¤lt den Namen
`maxout.interface', wobei `interface' der Name des externen
Grafikprogramms ist. Die mÃ¶glichen Werte sind: gnuplot, xmaxima,
mgnuplot oder gnuplot_pipes.

   Die Datei `maxout.interface' wird in dem Verzeichnis gespeichert, das
durch die Systemvariable `maxima_tempdir' bezeichnet wird. Siehe
`maxima_tempdir'.

   Die Datei `maxout.interface' kann wiederholt an das Grafikprogramm
Ã¼bergeben werden. Gibt Maxima keine Grafik aus, kann diese Datei geprÃ¼ft
werden, um mÃ¶gliche Fehler festzustellen.


File: maxima.info,  Node: Grafikformate,  Next: Funktionen und Variablen fÃ¼r die grafische Darstellung,  Prev: EinfÃ¼hrung in die grafische Darstellung,  Up: Grafische Darstellung

12.2 Grafikformate
==================

Maxima verwendet fÃ¼r die Ausgabe von Grafiken die Grafikprogramme
Gnuplot oder Xmaxima. Mit der Grafikoption `plot_format' kÃ¶nnen
verschiedene Grafikformate fÃ¼r diese Programme ausgewÃ¤hlt werden. Die
Grafikformate sind:

   * *gnuplot* (Standard fÃ¼r Windows)

     Startet das externe Programm Gnuplot. Gnuplot muss installiert
     sein. Die Grafikkommandos und Daten werden in die Datei
     `maxout.gnuplot' gespeichert.

   * *gnuplot_pipes* (Standard, wenn nicht Windows)

     Dieses Format ist fÃ¼r Windows nicht verfÃ¼gbar. Es ist Ã¤hnlich dem
     Format `gnuplot', mit der Ausnahme, dass die Grafikkommandos als
     Datenstrom Ã¼ber eine Pipe an Gnuplot gesendet werden, wÃ¤hrend die
     Daten in der Datei `maxout.gnuplot_pipes' gespeichert werden. Es
     wird nur eine Instanz von Gnuplot gestartet. Aufeinander folgende
     Grafikkommandos werden an ein bereits geÃ¶ffnetes Gnuplot-Programm
     gesendet. Gnuplot wird mit dem Kommando `gnuplot_close()'
     geschlossen. In diesem Grafikformat kann das Kommando
     `gnuplot_replot()' genutzt werden, um eine Grafik zu modifizieren,
     die bereits auf dem Bildschirm ausgegeben wurde. Siehe
     `gnuplot_replot'.

     Dieses Grafikformat sollte nur fÃ¼r die Ausgabe von Grafiken auf
     den Bildschirm verwendet werden. FÃ¼r die Ausgabe von Grafiken in
     eine Datei ist das Grafikformat `gnuplot' eher geeignet.

   * *mgnuplot*

     Mgnuplot ist eine Tcl/Tk-Anwendung, die Gnuplot fÃ¼r die Ausgabe
     von Grafiken nutzt. Die Anwendung ist in der Maxima-Distribution
     enthalten. Mgnuplot bietet eine rudimentÃ¤re GUI fÃ¼r Gnuplot, hat
     aber weniger FÃ¤higkeiten als Gnuplot. Mgnuplot benÃ¶tigt die
     Installation von Gnuplot und Tcl/Tk.

   * *xmaxima*

     Xmaxima ist eine auf Tcl/Tk basierende grafische
     BenutzeroberflÃ¤che, die von der Maxima-Konsole gestartet werden
     kann, um Grafiken auszugeben. Um dieses Grafikformat zu nutzen,
     muss Xmaxima installiert sein, das in der Distribution von Maxima
     enthalten ist. Wird Maxima aus Xmaxima gestartet, werden die
     Grafikkommandos und Daten Ã¼ber denselben Socket gesendet, der auch
     fÃ¼r die Kommunikation zwischen Xmaxima und Maxima geÃ¶ffnet wird.
     Wird das Grafikformat von einer Konsole oder einer anderen
     BenutzeroberflÃ¤che gestartet, werden die Grafikkommandos und Daten
     in die Datei `maxout.xmaxima' gespeichert. Diese Datei wird an
     Xmaxima fÃ¼r die Ausgabe der Grafik Ã¼bergeben.

     In frÃ¼heren Versionen wurde dieses Grafikformat `openmath' genannt.
     Dieser Name wird weiterhin als ein Synonym fÃ¼r `xmaxima'
     akzeptiert.



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r die grafische Darstellung,  Next: Grafikoptionen,  Prev: Grafikformate,  Up: Grafische Darstellung

12.3 Funktionen und Variablen fÃ¼r die grafische Darstellung
============================================================

 -- Funktion: contour_plot (<expr>, <x_range>, <y_range>, <options>,
          ...)
     Zeichnet einen Konturgraphen (die Isolinien einer Funktion) von
     <expr> im Bereich <x_range> und <y_range> mit den Optionen
     <options>.  <expr> ist eine Funktion `f(x,y)' mit zwei Argumenten.
     Alle weiteren Argumente entsprechen denen der Funktion `plot3d'.

     Die Funktion steht nur fÃ¼r die Grafikformate `gnuplot' und
     `gnuplot_pipes' zur VerfÃ¼gung. Das Paket `implicit_plot' enthÃ¤lt
     die Funktion `implicit_plot' mit der fÃ¼r alle Grafikformate
     Konturgraphen erstellt werden kÃ¶nnen. Siehe `implicit_plot'.

     Beispiele:

          (%i1) contour_plot(x^2 + y^2, [x, -4, 4], [y, -4, 4])$

          (%i1) f(x, y) := x^3 + y^2;
                                             3    2
          (%o1)                  f(x, y) := x  + y
          (%i2) contour_plot(f, [u, -4, 4], [v, -4, 4])$

     Es kann jede Option genutzt werden, die von der Funktion `plot3d'
     akzeptiert wird. StandardmÃ¤Ãig zeichnet Gnuplot den Graphen mit 3
     Isolinien. Die Anzahl der Isolinien kann mit der Gnuplot-Option
     `gnuplot_preamble' erhÃ¶ht werden. In diesem Beispiel ist die
     Legende entfernt.

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
            [legend,false], [gnuplot_preamble, "set cntrparam levels 12"])$


 -- Funktion: get_plot_option (<keyword>, <index>)
     Gibt die Werte der Parameter der Option mit dem Namen <keyword>
     zurÃ¼ck.  Die Optionen und ihre Parameter sind in der Variablen
     `plot_options' gespeichert. Hat <index> den Wert 1 wird der Name
     der Option <keyword> zurÃ¼ckgeben. Der Wert 2 fÃ¼r <index> gibt den
     Wert des ersten Parameters zurÃ¼ck, und so weiter.

     Siehe auch `plot_options',  `set_plot_option'  und das Kapitel
     Grafikoptionen.


 -- Funktion: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Funktion: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)
     Zeigt einen Graphen eines oder mehrerer AusdrÃ¼cke, die implizit
     gegeben sind.  <expr> ist der Ausdruck der gezeichnet werden soll,
     <x_range> ist der Wertebereich der x-Achse und <y_range> der
     Wertebereich der y-Achse. Die Funktion `implicit_plot' beachtet
     die Werte der Parameter der Grafikoptionen in der Systemvariablen
     `plot_options'. Grafikoptionen kÃ¶nnen auch als Argumente Ã¼bergeben
     werden.

     Der Algorithmus von `implicit_plot' stellt Vorzeichenwechsel der
     Funktion in den Bereichen <x_range> und <y_range> fest. FÃ¼r
     komplizierte FlÃ¤chen kann der Algorithmus versagen.

     Die Funktion wird mit dem Kommando `load(implicit_plot)' geladen.

     Beispiel:

          (%i1) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4],
           [gnuplot_preamble, "set zeroaxis"]);


 -- Funktion: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>,
          <fz>)
     Gibt eine Funktion zurÃ¼ck, die als Parameter fÃ¼r die Grafikoption
     `transform_xy' geeignet ist. Die zwei Argumente <var1> und <var2>
     reprÃ¤sentieren die zwei unabhÃ¤ngigen Variablen der Funktion
     `plot3d'. Das dritte Argument <var3> ist die Funktion, die von den
     zwei Variablen abhÃ¤ngt. Die drei Funktionen <fx>, <fy> und <fz>
     mÃ¼ssen von den drei Argumenten <var1>, <var2> und <var3> abhÃ¤ngen
     und die Argumente der Funktion `plot3d' in kartesische Koordinaten
     fÃ¼r die Ausgabe des Graphen transformieren.

     Die Transformationen `polar_to_xy'  fÃ¼r die Transformation von
     Polarkoordinaten und `spherical_to_xyz'  fÃ¼r die Transformation von
     Kugelkoordinaten in kartesische Koordinaten sind bereits definiert.


 -- Systemfunktion: polar_to_xy
     Kann als Parameter der Grafikoption `transform_xy' der Funktion
     `plot3d' Ã¼bergeben werden. Der Parameter `polar_to_xy' bewirkt,
     dass die zwei unabhÃ¤ngigen Variablen der Funktion `plot3d' von
     Polarkoordinaten in kartesische Koordinaten transformiert werden.


 -- Funktion: plot2d (<plot>, <x_range>, ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], <x_range>,...,
          <options>, ...)
     <plot>, <plot_1>, ..., <plot_n> sind AusdrÃ¼cke, Namen von
     Funktionen oder Listen der folgenden Form: `[discrete, [<x1>, ...,
     <xn>], [<y1>, ..., <yn>]]', `[discrete, [[<x1>, <y1>], ..., [<xn>,
     ..., <yn>]]' oder `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Die Funktion `plot2d' zeichnet einen zweidimensionalen Graphen
     einer oder mehrerer AusdrÃ¼cke als Funktion einer Variablen oder
     eines Parameters. Mit der Grafikoption <x_range> wird der Name der
     unabhÃ¤ngigen Variablen und deren Bereich angegeben. Die Syntax der
     Grafikoption <x_range> ist: `[<variable>, <min>, <max>]'.

     Ein diskreter Graph wird durch eine Liste definiert, die mit dem
     SchlÃ¼sselwort <disrecte> beginnt. Es folgen ein oder zwei Listen
     mit den Werten. Werden zwei Listen Ã¼bergeben, mÃ¼ssen diese
     dieselbe LÃ¤nge haben.  Die Daten der ersten Listen werden als die
     x-Koordinaten der Punkte und die der zweiten als die y-Koordinaten
     der Punkte interpretiert. Wird nur eine Liste Ã¼bergeben, sind die
     Elemente Listen mit je zwei Elementen, die die x- und
     y-Koordinaten der Punkte reprÃ¤sentieren.

     Ein parametrischer Graph wird durch eine Liste definiert, die mit
     dem SchlÃ¼sselwort <parametric> beginnt. Es folgen zwei AusdrÃ¼cke
     oder Namen von Funktionen und ein Parameter. Der Bereich fÃ¼r den
     Parameter muss eine Liste sein, die den Namen des Parameters,
     seinen grÃ¶Ãten und seinen kleinsten Wert enthÃ¤lt: `[<parameter>,
     <min>, <max>]'. Der Graph ist der Weg fÃ¼r die zwei AusdrÃ¼cke oder
     Namen von Funktionen, wenn der Parameter <parameter> von <min>
     nach <max> zunimmt.

     Als optionales Argument kann ein Wertebereich fÃ¼r die vertikale
     Koordinatenachse mit der Grafikoption `y' angegeben werden: `[y,
     <min>, <max>]'. Die vertikale Achse wird immer mit dem
     SchlÃ¼sselwort <y> bezeichnet. Wird kein Wertebereich <y> angegeben,
     wird dieser durch den grÃ¶Ãten und kleinsten y-Wert des zu
     zeichnenden Graphen festgelegt.

     Auch alle anderen Grafikoptionen werden als Listen angegeben, die
     mit einem SchlÃ¼sselwort beginnen, auf das die Parameter der
     Grafikoption folgen. Siehe `plot_options'.

     Werden mehrere Graphen gezeichnet, wird eine Legende hinzugefÃ¼gt,
     die die einzelnen Graphen unterscheidet. Mit der Grafikoption
     <legend> kÃ¶nnen die Bezeichnungen fÃ¼r die Legende festgelegt
     werden. Wird diese Option nicht genutzt, generiert Maxima die
     Bezeichnungen der Legende aus den AusdrÃ¼cken oder Namen der
     Funktionen, die als Argument Ã¼bergeben wurden.

     Siehe auch das Kapitel `Grafikoptionen'.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     WÃ¤chst die Funktion sehr schnell, kann es notwendig sein, die
     Werte auf der vertikalen Achse mit der Grafikoption `y' zu
     begrenzen.

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$
          plot2d: some values were clipped.

     Die Ansicht eines Graphen kann sich fÃ¼r verschiedene
     Grafikprogramme unterscheiden. In Xmaxima bewirkt die Grafikoption
     `[box, false]', das die Koordinatenachsen mit Pfeilen dargestellt
     werden.

          (%i1) plot2d ( x^2-1, [x, -3, 3], [y, -2, 10],
                                [box, false],
                                [plot_format, xmaxima])$

     Ein Graph mit einer logarithmischen Skala:

          (%i1) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Graphen von Funktionen, deren Namen als Argumente Ã¼bergeben werden.

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Graph einer parametrisch definierten Schmetterlingskurve.

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t), [t, -8*%pi, 8*%pi],
                       [nticks, 2000]])$

     Ein parametrischer Kreis mit zwei vollstÃ¤ndigen Drehungen, der nur
     fÃ¼r 7 Punkte gezeichnet ist.

          (%i1) plot2d ([parametric, cos(t), sin(t), [t, -2*%pi, 2*%pi],
                        [nticks, 8]])$

     Graph der Funktion `abs(x)' und eines parametrischen Kreises. Das
     SeitenverhÃ¤ltnis der Grafik wurde mit den Grafikoptionen `x' und
     `y' so angepasst, dass der Kreis rund erscheint. Das hier gewÃ¤hlte
     SeitenverhÃ¤ltnis funktioniert gut fÃ¼r die Ausgabe im
     Postscript-Format.

          (%i1) plot2d([[parametric, cos(t), sin(t) ,[t,0,2*%pi],
                  [nticks, 80]], abs(x)], [x,-2,2], [y, -1.5, 1.5])$
          plot2d: some values were clipped.

     Graph fÃ¼r diskrete Punkte. Die Punkte sind in zwei separaten
     Listen jeweils fÃ¼r die x- und y-Koordinaten angegeben.
     StandardmÃ¤Ãig werden die Punkte mit einer Linie verbunden.

          (%i1) plot2d([discrete, [10, 20, 30, 40, 50],
                                  [.6, .9, 1.1, 1.3, 1.4]])$

     Dieselben Punkte des letzten Beispiels. Jeder Punkt wird einzeln
     in eine Liste eingetragen und die Punkte werden nicht miteinander
     verbunden.

          (%i1) plot2d([discrete, [[10, .6], [20, .9], [30, 1.1],
                                   [40, 1.3], [50, 1.4]]],
                                   [style, points])$

     In diesem Beispiel wird eine Tabelle mit drei Spalten in eine Datei
     `data.txt' gespeichert. Die Datei wird gelesen und die zweite und
     dritte Spalte werden gezeichnet.

          (%i1) with_stdout ("data.txt",
                             for x:0 thru 10 do print (x, x^2, x^3))$
          (%i2) data: read_matrix ("data.txt")$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     Graph von experimentellen Datenpunkten zusammen mit einer
     theoretischen Funktion, die die Daten beschreibt.

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk], [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$


 -- Funktion: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Funktion: plot3d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>,
          ..., <options>, ...)
     Zeichnet einen Graph mit einer oder mehreren FlÃ¤chen, die als eine
     Funktion von zwei Variablen oder in parametrischer Form definiert
     sind.

     Die zu zeichnenden Funktionen werden als AusdrÃ¼cke oder mit ihrem
     Namen als Argumente Ã¼bergeben. Mit der Maus kann der Graph rotiert
     werden, um die FlÃ¤che aus verschiedenen Blickwinkeln zu betrachten.

     Siehe auch das Kapitel Grafikoptionen.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2])$

     Mit der Grafikoption `z' wird der Wertebereich der z-Achse
     begrenzt.  Dieses Beispiel zeigt den Graph ohne FÃ¤rbung der FlÃ¤che.

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     Unendlich groÃe Werte der z-Koordinate kÃ¶nnen auch durch Wahl eines
     Gitters vermieden werden, das nicht mit einer der Asymptoten
     zusammenfÃ¤llt.  Das Beispiel zeigt die Nutzung einer
     vordefinierten Palette.

          (%i1) plot3d (log (x^2*y^2), [x, -2, 2], [y, -2, 2],
                   [grid, 29, 29], [palette, get_plot_option(palette,5)])$

     Graph mit zwei FlÃ¤chen, die denselben Wertebereich haben und eine
     Palette nutzen.

          (%i1) plot3d ([2^(-x^2 + y^2), 4*sin(3*(x^2+y^2))/(x^2+y^2),
                   [x, -3, 3], [y, -2, 2]])$

     Die gleichen zwei FlÃ¤chen mit verschiedenen Wertebereichen. In
     Xmaxima nutzen die zwei FlÃ¤chen verschiedene Paletten.

          (%i1) plot3d ([[2^(-x^2 + y^2), [x,-2,2], [y,-2,2]],
                   4*sin(3*(x^2+y^2))/(x^2+y^2), [x, -3, 3], [y, -2, 2]],
                   [plot_format,xmaxima])$

     Graph der kleinschen Flasche, die parametrisch definiert ist.

          (%i1) expr_1: 5*cos(x)*(cos(x/2)*cos(y)
                        + sin(x/2)*sin(2*y) + 3.0) - 10.0$
          (%i2) expr_2: -5*sin(x)*(cos(x/2)*cos(y)
                        + sin(x/2)*sin(2*y) + 3.0)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 40, 40])$

     Graph einer Kugelfunktion, wobei die vordefinierte
     Koordinatentransformation `spherical_xyz' genutzt wird, um von
     Kugelkoordinaten in ein kartesisches Koordinatensystem zu
     transformieren. Siehe auch `spherical_to_xyz'.

          (%i1) plot3d (sin(2*theta)*cos(phi),
                  [theta, 0, %pi], [phi, 0, 2*%pi],
                  [transform_xy, spherical_to_xyz], [grid,30,60])$

     Gebrauch der vordefinierten Funktion `polar_to_xy', um von
     zylindrischen Koordinaten in ein kartesisches Koordinatensystem zu
     transformieren. Siehe auch `polar_to_xy'.   Dieses Beispiel zeigt
     auch wie der Rahmen und die Legende entfernt werden kÃ¶nnen.

          (%i1) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                  [grid, 12, 80],
                  [transform_xy, polar_to_xy], [box, false], [legend,false])$

     Graph einer Kugel, wobei die Koordinatentransformation von
     Kugelkoordinaten in ein kartesisches Koordinatensystem genutzt
     wird. In Xmaxima werden die drei Achsen gleichmÃ¤Ãig skaliert, um
     die Proportionen der Kugel zu bewahren.  Eine Palette mit
     verschiedenen Schattierungen einer Farbe wird genutzt.

          (%i1) plot3d( 5, [theta, 0, %pi], [phi, 0, 2*%pi],
                   [plot_format,xmaxima], [transform_xy, spherical_to_xyz],
                   [palette,[value,0.65,0.7,0.1,0.9]])$

     Definition einer Funktion mit zwei Variablen als eine Matrix. Der
     Quote-Operator in der Definition der Funktion verhindert, das
     `plot3d' fehlschlÃ¤gt, wenn die Argumente keine ganze Zahlen sind.

          (%i1) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                          [1, 2, 3, 3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x, 1, 4], [y, 1, 4], [grid, 4, 4])$
          apply: subscript must be an integer; found: round(x)

     Wird die HÃ¶henangabe `elevation' auf Null gesetzt, kann die FlÃ¤che
     als eine Karte betrachtet werden. Jede Farbe reprÃ¤sentiert einen
     anderen Wert der FlÃ¤che. Die Option `colorbox' wird genutzt, um
     die Werte der Farben zu zeigen. Die Gitterlinien sind
     ausgeschaltet.

          (%i1) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [mesh_lines_color, false], [elevation, 0], [azimuth, 0],
                  [colorbox, true], [grid, 150, 150])$


 -- Systemvariable: plot_options
     Die Elemente dieser Liste definieren die Standardwerte fÃ¼r die
     Ausgabe von Graphen. Ist einer der Werte ein Argument der
     Funktionen `plot2d' oder `plot3d', wird der Standwert
     Ã¼berschrieben. Die Standardwerte kÃ¶nnen mit der Funktion
     `set_plot_option' gesetzt werden. Einige Grafikoptionen sind nicht
     in der Liste `plot_options' enthalten.

     Jedes Element der Liste `plot_options' ist eine Liste mit zwei oder
     mehr EintrÃ¤gen. Der erste Eintrag ist der Name der Grafikoption.
     Die weiteren EintrÃ¤ge sind die Parameter der Option. In einigen
     FÃ¤llen kann der Parameter einer Option wiederum eine Liste sein.

     Siehe auch `set_plot_option',  `get_plot_option'  und das Kapitel
     Grafikoptionen.


 -- Funktion: set_plot_option (<option>)
     Akzeptiert die meisten der Optionen, die im Kapitel Grafikoptionen
     aufgelistet sind und speichert diese in der globalen Variable
     `plot_options'.

     `set_plot_options' wertet seine Argumente aus und gibt die
     vollstÃ¤ndige Liste `plot_optons' zurÃ¼ck.

     Siehe auch `plot_options',  `get_plot_option'  und das Kapitel
     Grafikoptionen.

     Beispiele:

     Setze einen neuen Wert fÃ¼r die Option `grid'.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript \
          eps enhanced color solid 24], [plot_realpart, false]]


 -- System function: spherical_to_xyz
     Kann als Parameter fÃ¼r die Option `transform_xy' der Funktion
     `plot3d' Ã¼bergeben werden. Der Parameter `spherical_to_xyz'
     bewirkt, dass die zwei unabhÃ¤ngigen Variablen und die Funktion
     beim Aufruf von `plot3d' von Kugelkoordinaten in kartesische
     Koordinaten umgerechnet werden.



File: maxima.info,  Node: Grafikoptionen,  Next: Gnuplot Optionen,  Prev: Funktionen und Variablen fÃ¼r die grafische Darstellung,  Up: Grafische Darstellung

12.4 Grafikoptionen
===================

Die Grafikoptionen bestehen aus einer Liste, die mit einem der hier
folgenden SchlÃ¼sselworte beginnt und ein oder mehrere Parameter
enthÃ¤lt. Die meisten Optionen kÃ¶nnen mit den Funktionen `plot2d',
`plot3d', `contour_plot' oder `implicit_plot' genutzt und mit der
Funktion `set_plot_option' gesetzt werden. Auf Ausnahmen wird im
Folgenden hingewiesen.

 -- Grafikoption: adapt_depth [adapt_depth, <integer>]
     Standardwert: 5

     The maximum number of splittings used by the adaptive plotting
     routine.


 -- Grafikoption: axes [axes, <symbol>]
     Standardwert: `true'

     `symbol' kann einen der Werte `true', `false', `x' oder `y' haben.
     Ist der Wert `false', werden keine Achsen gezeichnet. Mit `x' oder
     `y' werden nur die x- oder nur die y-Achse gezeichnet. Mit `true'
     werden beide Achsen gezeichnet. Diese Option wird nur von den
     Funktionen `plot2d' und `implicit_plot' genutzt.


 -- Grafikoption: azimuth [azimuth, <number>]
     Standartwert: 30

     Setzt den Wert in Grad des Azimutwinkels einer dreidimensionalen
     Grafik.

     Siehe auch `elevation'.


 -- Grafikoption: box [box, <symbol>]
     Standardwert: `true'

     Hat die Grafikoption `box' den Wert `true', erhÃ¤lt die Grafik einen
     Rahmen. Mit `false' wird die Ausgabe des Rahmens ausgeschaltet.


 -- Grafikoption: color [color, <color_1>, ..., <color_n>]
     Standardwert: blue, red, green, magenta, black, cyan

     FÃ¼r die Funktionen `plot2d' und `implicit_plot' definiert die
     Grafikoption `color' die Farben der Graphen. FÃ¼r einen 3D-Graphen
     definiert diese Option die EinfÃ¤rbung der FlÃ¤chen.

     Gibt es mehr Kurven oder FlÃ¤chen als Farben, werden die Farben
     wiederholt.  Mit Gnuplot und Xmaxima kÃ¶nnen die Farben blue, red,
     green, magenta, black, cyan verwendet werden.


 -- Grafikoption: colorbox [colorbox, <symbol>]
     Standardwert: `false'

     Hat die Grafikoption `colorbox' den Wert `true', wird immer dann,
     wenn das Grafikkommando `plot3d' eine Palette mit verschiedenen
     Farben nutzt, um die z-Werte darzustellen, eine Legende mit den
     Farben und den dazugehÃ¶renden z-Werten angezeigt.


 -- Grafikoption: elevation [elevation, <number>]
     Standardwert: 60

     Setzt den Wert in Grad des Elevationswinkels einer
     dreidimensionalen Grafik.

     Siehe auch `azimuth'.


 -- Grafikoption: grid [grid, <integer>, <integer>]
     Standardwert: 30, 30

     Setzt die Anzahl der Gitterlinen fÃ¼r die x- und y-Richtung einer
     dreidimensionalen Grafik.


 -- Plot option: legend [legend, <string_1>, ..., <string_n>]
 -- Plot option: legend [legend, <false>]
     Definiert die EintrÃ¤ge in eine Legende, wenn mehrere Grafiken
     gezeichnet werden. Sind mehr Grafiken als EintrÃ¤ge in die Legende
     vorhanden, werden die EintrÃ¤ge wiederholt. Hat die Grafikoption
     `legend' den Wert `false', wird keine Legende gezeichnet.
     StandardmÃ¤Ãig werden die AusdrÃ¼cke oder Namen der Funktionen als
     EintrÃ¤ge verwendet. FÃ¼r diskrete Grafiken werden die EintrÃ¤ge mit
     discrete1, discrete2, ... bezeichnet. Diese Grafikoption kann
     nicht mit der Funktion `set_plot_option' gesetzt werden.


 -- Grafikoption: logx [logx]
     Bewirkt, dass die horizontale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion `set_plot_option'
     genutzt werden.


 -- Grafikoption: logy [logy]
     Bewirkt, dass die vertikale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion `set_plot_option'
     genutzt werden.


 -- Grafikoption: mesh_lines_color [mesh_lines_color, <color>]
     Standardwert: black

     Setzt die Farbe, die von der Funktion `plot3d' genutzt wird, um die
     Gitterlinien zu zeichnen. Es kÃ¶nnen dieselben Farben verwendet
     werden wie fÃ¼r die Grafikoption `color'. Mit den Wert `false' wird
     die Anzeige der Gitterlinien ausgeschaltet.


 -- Grafikoption: nticks [nticks, <integer>]
     Standardwert: 29

     Wird eine Grafik mit der Funktion `plot2d' gezeichnet, gibt
     `nticks' die Anzahl der Anfangspunkte an, die fÃ¼r das Zeichnen der
     Grafik genutzt wird.  FÃ¼r parametrische Graphen mit den Funktionen
     `plot2d' und `plot3d' ist `nticks' die Anzahl der Punkte fÃ¼r die
     der Graph gezeichnet wird.


 -- Grafikoption: palette [palette, [<palette_1>], ..., [<palette_n>]]
 -- Grafikoption: palette [palette, <false>]
     Standardwert: [hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8, 0.9,
     0.55], [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]

     Eine Palette kann aus einer oder mehreren Paletten bestehen. Sie
     beginnt mit einem SchlÃ¼sselwort, worauf 4 Zahlen folgen. Die
     ersten drei Zahlen haben Werte zwischen 0 und 1. Diese definieren
     den Farbton `hue', die SÃ¤ttigung `saturation' und die Grundfarbe
     `value', die der kleinste z Wert erhÃ¤lt. Die SchlÃ¼sselworte `hue',
     `saturation' und `value' spezifizieren welcher der drei Attribute
     mit dem Wert von z geÃ¤ndert werden.  Der letzte Wert der Liste,
     spezifiziert welcher Wert zum grÃ¶Ãten z Wert gehÃ¶rt. Dieser grÃ¶Ãte
     Wert kann grÃ¶Ãer als 1 und auch negativ sein. Die Werte der
     modifizierten Attribute werden Modulo 1 gerundet.

     Gnuplot nutzt nur die erste Palette in einer Liste mit Paletten.
     Xmaxima nutzt alle Paletten nacheinander, wenn mehrere FlÃ¤chen
     gezeichnet werden. Sind nicht genÃ¼gend Paletten vorhanden, werden
     die Paletten wiederholt.

     Die Farbe der Gitterlinien wird mit der Option `mesh_lines_color'
     angegeben. Hat `palette' den Wert `false', werden die FlÃ¤chen nicht
     gefÃ¤rbt, sondern als ein Gitternetz gezeichnet. Die Farbe der
     Gitterlinien wird in diesem Fall mit der Grafikoption `color'
     definiert.


 -- Grafikoption: plot_format [plot_format, <format>]
     Standardwert: gnuplot fÃ¼r Windows oder gnuplot_pipes fÃ¼r andere
     Betriebssysteme.

     Setzt das Format fÃ¼r die Ausgabe einer Grafik.

     `format' kann die Werte `gnuplot', `xmaxima', `mgnuplot' oder
     `gnuplot_pipes' annehmen.


 -- Grafikoption: plot_real_part [plot_realpart, <symbol>]
     Standardwert: `false'

     Hat `plot_real_part' den Wert `true', werden Funktionen als komplex
     angenommen und der Realteil wird gezeichnet. Dies ist Ã¤quivalent
     zu einem Aufruf mit der Funktion `realpart(<function>'. Mit dem
     Wert `false' wird keine Grafik gezeichnet, wenn die Funktion
     keinen Realteil hat. Zum Beispiel ist `log(x)' komplex, wenn <x>
     negativ ist. Hat `plot_real_part' den Wert `true', wird der Wert
     `log(-5)' als `log(5)' gezeichnet. Hat `plot_real_part' den Wert
     `false' wird kein Wert gezeichnet.


 -- Grafikoption: point_type [point_type, <type_1>, ..., <type_n>]
     Standardwert: bullet, circle, plus, times, asterisk, box,
     square,triangle, delta, wedge, nabla, diamond, lozenge

     Wird in Gnuplot ein Satz an Punkten mit den Stilen "points" oder
     "linespoints" gezeichnet, werden die Symbole fÃ¼r die einzelnen
     DatensÃ¤tze nacheinander der Liste `point_type' entnommen. Gibt es
     mehr DatensÃ¤tze als definierte Stile, werden diese wiederholt.


 -- Grafikoption: psfile [psfile, <string>]
     Speichert die Grafik in eine Postscript-Datei mit den Namen
     <string> und gibt die Grafik nicht auf dem Bildschirm aus.
     StandardmÃ¤Ãig wird die Datei in dem Ordner abgespeichert, dessen
     Namen in der Optionsvariablen `maxima_tempdir' enthalten ist.


 -- Grafikoption: run_viewer [run_viewer, <symbol>]
     Standardwert: `true'

     Kontrolliert, ob die Bildschirmausgabe des Grafikformats gestartet
     wird.


 -- Grafikoption: style [style, <type_1>, ..., <type1_n>]
 -- Grafikoption: style [style, [<style_1>], ..., [<style_n>]]
     Standardwert: <lines> (will plot all sets of points joined with
     lines of thickness 1 and the first color given by the option
     `color').

     The styles that will be used for the various functions or sets of
     data in a 2d plot. The word <style> must be followed by one or more
     styles. If there are more functions and data sets than the styles
     given, the styles will be repeated. Each style can be either
     <lines> for line segments, <points> for isolated points,
     <linespoints> for segments and points, or <dots> for small
     isolated dots. Gnuplot accepts also an <impulses> style.

     Each of the styles can be enclosed inside a list with some
     aditional parameters. <lines> accepts one or two numbers: the
     width of the line and an integer that identifies a color. The
     default color codes are: 1: blue, 2: red, 3: magenta, 4: orange,
     5: brown, 6: lime and 7: aqua. If you use Gnuplot with a terminal
     different than X11, those colors might be different; for example,
     if you use the option [<gnuplot_term>,<ps>], color index 4 will
     correspond to black, instead of orange.

     <points> accepts one two or three parameters; the first parameter
     is the radius of the points, the second parameter is an integer
     that selects the color, using the same code used for <lines> and
     the third parameter is currently used only by Gnuplot and it
     corresponds to several objects instead of points. The default
     types of objects are: 1: filled circles, 2: open circles, 3: plus
     signs, 4: x, 5: *, 6: filled squares, 7: open squares, 8: filled
     triangles, 9: open triangles, 10: filled inverted triangles, 11:
     open inverted triangles, 12: filled lozenges and 13: open lozenges.

     <linesdots> accepts up to four parameters: line width, points
     radius, color and type of object to replace the points.

     See also `color' and `point_type'.


 -- Grafikoption: t [t, <min>, <max>]
     Standardwert: -3, 3

     Standardbereich fÃ¼r eine parametrische Grafik.


 -- Grafikoption: transform_xy [transform_xy, <symbol>]
     Standardwert: `false'

     <symbol> hat entweder den Wert `false' oder ist das Ergebnis, wenn
     die Funktion `transform_xy'. Wenn verschieden von `false', wird die
     Funktion genutzt, um die drei Koordinaten einer dreidimensionalen
     Grafik zu transformieren.

     Siehe auch `make_transform',  `polar_to_xy'  und
     `spherical_to_xyz'.


 -- Grafikoption: x [x, <min>, <max>]
     Wird diese Grafikoption als eine der ersten fÃ¼r das Kommando
     `plot3d' genutzt, wird der x-Bereich angegeben. FÃ¼r eine
     zweidimensional Grafik gibt diese Option den Bereich fÃ¼r die
     Ausgabe an.


 -- Grafikoption: xlabel [xlabel, <string>]
     Spezifiziert die Zeichenkette <string>, die die x-Achse einer
     Grafik bezeichnet. Wird diese Option nicht angegeben, wird die
     x-Achse mit "x" bezeichnet. Diese Grafikoption kann nicht mit dem
     Kommando `set_plot_option' genutzt werden.


 -- Grafikoption: y [y, <min>, <max>]
     Wird diese Grafikoption als eine der ersten fÃ¼r das Kommando
     `plot3d' genutzt, wird der y-Bereich angegeben. FÃ¼r eine
     zweidimensional Grafik gibt diese Option den Bereich fÃ¼r die
     Ausgabe an.


 -- Grafikoption: ylabel [ylabel, <string>]
     Spezifiziert die Zeichenkette <string>, die die y-Achse einer
     Grafik bezeichnet. Wird diese Option nicht angegeben, wird die
     y-Achse mit "y" bezeichnet. Diese Grafikoption kann nicht mit dem
     Kommando `set_plot_option' genutzt werden.


 -- Grafikoption: z [z, <min>, <max>]
     Wird in dreidimensionalen Grafiken genutzt, um die Bereich der
     z-Achse festzulegen.


 -- Plot option: zlabel [zlabel, <string>]
     Spezifiziert die Zeichenkette <string>, die die z-Achse fÃ¼r eine
     dreidimensionale Grafik bezeichnet. Wird diese Option nicht
     angegeben, wird die z-Achse mit "z" bezeichnet. Diese Grafikoption
     kann nicht mit dem Kommando `set_plot_option' genutzt werden und
     wird von den Funktionen `plot2d' und `implicit_plot' ignoriert.



File: maxima.info,  Node: Gnuplot Optionen,  Next: Gnuplot_pipes Formatfunktionen,  Prev: Grafikoptionen,  Up: Grafische Darstellung

12.5 Gnuplot Optionen
=====================

Es gibt einige spezielle Optionen fÃ¼r Gnuplot. Diese Optionen werden als
SchlÃ¼sselwort und einer Zeichenkette, die ein gÃ¼ltiges Kommando ist und
an Gnuplot weitergeleitet wird. In den meisten FÃ¤llen gibt es eine
entsprechende Grafikoption, die ein vergleichbares Ergebnis liefert.
Die Grafikoptionen sollten den Gnuplot-Optionen vorgezogen werden.

 -- Grafikoption: gnuplot_term
     Setzt den Terminaltyp fÃ¼r Gnuplot.

        * *default* (Standardwert)

          Die Ausgabe von Gnuplot wird in einem separatem Fenster
          angezeigt.

        * *dumb*

          Die Ausgabe von Gnuplot wird in der Maxima Konsole mit
          Ascii-Zeichen angezeigt.

        * *ps*

          Gnuplot generiert PostScript-Kommandos. Mit der Grafikoption
          `gnuplot_out_file' werden die PostScript-Kommandos in eine
          Datei <filename> geschrieben. Ansonsten werden die Kommandos
          in die Datei `maxplot.ps' geschrieben.

          any other valid gnuplot term specification

        * Jede andere gÃ¼ltige Gnuplot Spezifikation

          Gnuplot kann Ausgaben in verschiedenen Formaten wie zum
          Beispiel PNG, JPEG, SVG generieren. Die verschiedenen Formate
          werden mit der Option `gnuplot_term' angegeben. Weiterhin
          kann jedes gÃ¼ltige Kommando als Zeichenkette Ã¼bergeben
          werden. Zum Beispiel generiert `[gnuplot_term, png]' eine
          Grafik im PNG-Format (Portable Network Graphics) und
          `[gnuplot_term, "png size 1000, 1000"]' generiert eine Grafik
          im PNG-Format im Format 1000x1000 Punkte. Mit der
          Grafikoption `gnuplot_out_file' werden die Ausgabe in eine
          Datei <filename> geschrieben. Ansonsten werden die Kommandos
          in die Datei `maxplot.<term>' geschrieben, wobei <term> das
          Gnuplot-Format ist.



 -- Grafikoption: gnuplot_out_file
     Zusammen mit der Option `gnuplot_term', kann die Ausgabe in dem
     angegebenen Gnuplot-Format in eine Datei geschrieben werden. Eine
     Postscript-Datei kann auch mit der Option `psfile' ausgegeben
     werden. Die Option `psfile' funktioniert auch im Grafikformat
     `xmaxima'.

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]


 -- Grafikoption: gnuplot_pm3d
     Hat die Grafikoption `gnuplot_pm3d' den Wert `false', wird der
     PM3D-Modus ausgeschaltet. Dieser ist Modus ist standardmÃ¤Ãig
     eingeschaltet.


 -- Grafikoption: gnuplot_preamble
     FÃ¼gt Gnuplot-Kommandos ein, die vor dem Zeichnen der Grafik
     ausgefÃ¼hrt werden.  Jedes gÃ¼ltige Gnuplot-Kommando kann genutzt
     werden. Mehrere Kommandos sollten mit einem Semikolon voneinander
     getrennt werden. Der Standardwert der Option `gnuplot_preamble'
     ist eine leere Zeichenkette `""'.


 -- Grafikoption: gnuplot_curve_titles
     Dies ist eine veraltete Option, die von der Grafikoption `legend'
     ersetzt wurde.


 -- Grafikoption: gnuplot_curve_styles
     Dies ist eine veraltete Option, die von der Grafikoption `style'
     ersetzt wurde.


 -- Grafikoption: gnuplot_default_term_command
     Ist das Gnuplot-Kommando um den Standardtyp eines Terminals zu
     setzen.  Der Standardwert ist `set term pop'.


 -- Grafikoption: gnuplot_dumb_term_command
     Ist das Gnuplot-Kommando um den Terminaltyp fÃ¼r ein dumb-Terminal
     zu setzen.  Der Standardwert ist `"set term dumb 79 22"'. Die
     Ausgabe hat eine Breite von 79 Zeichen und eine HÃ¶he von 22
     Zeichen.


 -- Grafikoption: gnuplot_ps_term_command
     Ist das Gnuplot-Kommando, um den Terminaltyp fÃ¼r eine
     Postscript-Terminal zu setzen. Der Standardwert ist `"set size
     1.5, 1.5;set term postscript eps enhanced color solid 24"'. Das
     Terminal wird auf das 1,5 fache des Standardwertes der GrÃ¶Ãe
     gesetzt und die SchriftgrÃ¶Ãe wird auf 24 gesetzt. Siehe die
     Gnuplot-Dokumentation fÃ¼r weitere Parameter die fÃ¼r ein
     Postscript-Terminal gesetzt werden kÃ¶nnen.



File: maxima.info,  Node: Gnuplot_pipes Formatfunktionen,  Prev: Gnuplot Optionen,  Up: Grafische Darstellung

12.6 Gnuplot_pipes Formatfunktionen
===================================

 -- Funktion: gnuplot_start ()
     Ãffnet eine Pipe, die im Grafikformat `gnuplot_pipes' fÃ¼r den
     Austausch der Daten genutzt wird.


 -- Funktion: gnuplot_close ()
     SchlieÃt die Pipe, die im Grafikformat `gnuplot_pipes' fÃ¼r den
     Austausch der Daten genutzt wird.


 -- Funktion: gnuplot_restart ()
     SchlieÃt die Pipe, die im Grafikformat `gnuplot_pipes' fÃ¼r den
     Austausch der Daten genutzt wird, und Ã¶ffnet eine neue Pipe.


 -- Funktion: gnuplot_replot ()
 -- Funktion: gnuplot_replot (<s>)
     Aktualisiert die Ausgabe von Gnuplot. Wird `gnuplot_replot' mit
     einem Kommando <s> aufgerufen, dann wird das Kommando <s> vor der
     Aktualisierung an Gnuplot gesendet.


 -- Funktion: gnuplot_reset ()
     Im Grafikformat `gnuplot_pipes' wird Gnuplot zurÃ¼ckgesetzt. Um die
     Anzeige zu aktualisieren, kann das Kommando `gnuplot_replot' nach
     dem Kommando `gnuplot_reset' ausgefÃ¼hrt werden.



File: maxima.info,  Node: Eingabe und Ausgabe,  Next: Mengen,  Prev: Grafische Darstellung,  Up: Top

13 Eingabe und Ausgabe
**********************

* Menu:

* Kommentare::
* Dateien::
* Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe::
* Funktionen und Variablen fÃ¼r die Tex-Ausgabe::


File: maxima.info,  Node: Kommentare,  Next: Dateien,  Prev: Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.1 Kommentare
===============

Ein Kommentar in der Maxima-Eingabe ist ein Text der von `/*' und `*/'
eingeschlossen ist. Der Maxima-Parser behandelt einen Kommentar wie ein
Zwischenraumzeichen, wenn ein Token eingelesen wird. Ein Token endet
immer an einem Zwischenraumzeichen. Eine Einabe wie `a/* foo */b'
enthÃ¤lt die beiden Token `a' und `b' und nicht das einzelne Token `ab'.
Ansonsten werden Kommentare von Maxima ignoriert. Kommentare werden im
eingelesenen Ausdruck nicht gespeichert.

   Kommentare kÃ¶nnen in beliebiger Tiefe verschachtelt werden. Die `/*'
und `*/' Begrenzungen mÃ¼ssen paarweise auftreten.

   Beispiele:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Dateien,  Next: Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe,  Prev: Kommentare,  Up: Eingabe und Ausgabe

13.2 Dateien
============

Folgende Funktionen und Variable arbeiten mit Dateien:

     appendfile           batch                 batchload
     closefile            file_output_append    filename_merge
     file_search          file_search_maxima    file_search_lisp
     file_search_demo     file_search_usage     file_search_tests
     file_type            load                  load_pathname
     loadfile             loadprint             printfile
     pathname_directory   pathname_name         pathname_type
     save                 stringout             with_stdout
     writefile


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe,  Next: Funktionen und Variablen fÃ¼r die Tex-Ausgabe,  Prev: Dateien,  Up: Eingabe und Ausgabe

13.3 Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe
==========================================================

 -- Funktion: appendfile (<filename>)
     Startet wie die Funktion `writefile' eine Aufzeichnung aller Ein-
     und Ausgaben der Konsole. Die Ein- und Ausgaben werden in die
     Datei <filename> geschrieben. Im Unterschied zu `writefile' werden
     die Daten immer an eine existierende Datei angehÃ¤ngt. Existiert
     die Datei nicht, wird diese angelegt.

     `closefile' beendet die Aufzeichnung. Siehe auch `writefile'.


 -- Funktion: batch (<filename>)
 -- Funktion: batch (<filename>, option)
     `batch(<filename>)' liest Maxima AusdrÃ¼cke aus der Datei
     <filename> ein, wertet diese aus und gibt die Ergebnisse auf der
     Konsole aus. `batch' sucht die Datei <filename> in den
     Verzeichnissen, die in der Liste `file_search_maxima' enthalten
     sind. Siehe `file_search'.

     `batch(<filename>, `demo')' entspricht dem Kommando
     `demo(<filename>)'. `batch' sucht fÃ¼r diesen Fall die Datei in der
     Liste der Verzeichnisse `file_search_demo'. Siehe `demo'.

     `batch(<filename>, `test')' entspricht dem Kommando
     `run_testsuite' mit der Option `display_all=true'. In diesem Fall
     sucht `batch' die Datei <filename> in den Verzeichnissen der Liste
     `file_search_maxima' und nicht in der Liste `file_search_tests' wie
     der Befehl `run_testsuite'. Siehe auch `run_testsuite'.

     Die Maxima-AusdrÃ¼cke in der Datei werden wie auf der Konsoloe mit
     den Zeichen `;' oder `$' beendet. Die Systemvariable `%' und die
     Funktion `%th' beziehen sich auf vorhergende Zeilen in der Datei.
     Die Datei kann `:lisp'-Breakkommandos enthalten. Leerzeichen,
     Tabulatoren, Zeilenschaltungen und Kommentare werden ignoriert.
     Eine geeignete Datei kann mit einem Texteditor oder der Funktion
     `stringout' erstellt werden.

     Den Ein- und Ausgaben werden jeweils Ein- und Ausgabemarken
     zugewiesen. Tritt wÃ¤hrend der Auswertung eines Ausrucks ein Fehler
     auf, wird das Einlesen der Datei abgebrochen. Werden Eingaben vom
     Nutzer benÃ¶tigt, wie zum Beispiel bei Fragen der Funktionen
     `asksign' oder `askinteger', dann wartet `batch' auf die
     Antworten, um dann die Bearbeitung der Datei fortzusetzen.

     Die Verarbeitung von `batch' kann durch die Eingabe von `control-C'
     abgebrochen werden. Die weitere Reaktion auf einen Abbruch mit
     `control-C' hÃ¤ngt von der Lisp-Implementation ab.

     `batch' wertet seine Argument aus. `batch' gibt den Namen der Datei
     <filename> als Zeichenkette zurÃ¼ck, wenn die Funktion ohne zweites
     Argument oder mit der Option `demo' aufgerufen wird. Wir die
     Funktion mit `test' als Option aufgerufen, ist die RÃ¼ckgabe eine
     leere Liste `[]' oder eine Liste, die <filename> und die Nummern
     der fehlgeschlagenen Tests enthÃ¤lt.

     Siehe auch `load',  `batchload'  und `demo'.


 -- Funktion: batchload (<filename>)
     Liest AusdrÃ¼cke aus der Datei <filename> ein und wertet diese aus,
     ohne die eingelesenen und ausgewerteten AusdrÃ¼cke anzuzeigen und
     ohne Zuweisung von Eingabe- und Ausgabemarken. Die Ausgabe von
     Fehlermeldungen oder sonstigem Text, der von Funktionen ausgegeben
     wird, wird nicht unterdrÃ¼ckt.

     Die Systemvariable `%' und die Funktion `%th' beziehen sich auf die
     letzten Eingabe auf der Konsole und nicht auf Zeilen oder
     Ergebnisse der Datei.  Im Gegensatz zur Funktion `batch', darf
     eine Datei die von `batchload' geladen wird, keine
     `:lisp'-Breakkommandos enthalten.

     `batchload' gibt eine Zeichenkette mit dem Pfad der Datei
     <filename> zurÃ¼ck.

     Siehe auch `batch'  und `load'.


 -- Funktion: closefile ()
     Beendet eine Aufzeichnung, die von den Funktionen `writefile' oder
     `appendfile' gestartet wurde, und schlieÃt die Ausgabedatei.


 -- Optionsvariable: file_output_append
     Standardwert: `false'

     `file_output_append' kontrolliert, ob Funktionen, die in eine Datei
     schreiben, diese lÃ¶schen und neu anlegen oder die Daten an eine
     existierende Datei anhÃ¤ngen. Wenn `file_output_append' den Wert
     `true' hat, werden die Daten an die existierende Datei angehÃ¤ngt.
     Ansonsten wird eine neue Datei erstellt.

     Die Funktionen `save', `stringout' und `with_stdout' beachten den
     Wert von `file_output_append'. Dagegen erstellen Plot-Funktionen
     und der Ãbersetzer grundsÃ¤tzlich neue Dateien und die Funktionen
     `tex' und `appendfile' hÃ¤ngen die Ausgabe immer an eine bestehende
     Datei an.


 -- Funktion: filename_merge (<path>, <filename>)
     Konstruiert einen Pfad aus <path> und <filename>. Endet <path> mit
     einer Zeichenkette der Form `###.<something>', wird diese
     Zeichenkette durch `<filename.SOMETHING>' ersetzt. Ansonsten wird
     der Endbestandteil durch <filename> ersetzt.

     Die RÃ¼ckgabe ist ein Lisp-Dateiname.


 -- Funktion: file_search (<filename>)
 -- Funktion: file_search (<filename>, <pathlist>)
     `file_search' sucht die Datei <filename> und gibt den Pfad als eine
     Zeichenkette zurÃ¼ck, wenn die Datei gefunden wurde. Ansonsten wird
     `false' zurÃ¼ckgegeben. `file_search (<filename>)' sucht in den
     Standardsuchverzeichnissen, die mit den Optionsvariablen
     `file_search_maxima', `file_search_lisp' und `file_search_demo'
     spezifiziert werden.

     `file_search' prÃ¼ft zuerst, ob die Datei `filename' existiert. Dann
     prÃ¼ft `file_search', ob die Datei anhand von Mustern im Dateinamen
     gefunden werden kann. Siehe `file_search_maxima'  fÃ¼r die Suche von
     Dateien.

     Das Argument <filename> kann ein Name mit einer Pfadangabe oder
     allein der Dateiname sein. Sind in den Suchverzeichnissen
     Dateinamen mit Mustern enthalten, kann die Datei auch ohne Endung
     angegeben werden. Zum Beispiel finden die folgende Kommandos
     dieselbe Datei, wenn `/home/wfs/special/###.mac' in der Liste
     `file_search_maxima' enthalten ist:

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     `file_search (<filename>, <pathlist>)' sucht nur in den
     Verzeichnissen <pathlist>. Das Argument <pathlist> Ã¼berschreibt die
     Standardsuchverzeichnisse. Auch ein einzelnes Verzeichnis muss als
     eine Liste Ã¼bergeben werden.

     Die Standardsuchverzeichnisse kÃ¶nnen modifiziert werden. Siehe
     `file_search_maxima'.

     `file_search' wird von den Funktionen `load' mit den
     Verzeichnislisten `file_search_maxima' und `file_search_lisp'
     aufgerufen.


 -- Optionsvariable: file_search_maxima
 -- Optionsvariable: file_search_lisp
 -- Optionsvariable: file_search_demo
 -- Optionsvariable: file_search_usage
 -- Optionsvariable: file_search_tests
     Diese Optionsvariablen bezeichnen Listen mit Verzeichnisen, die
     von den Funktionen `load', `demo' und anderen Funktionen
     durchsucht werden, um eine Datei zu finden. Die Standardwerte
     bezeichnen verschiedene Verzeichnisse der Maxima-Installation.

     Diese Variablen kÃ¶nnen modifiziert werden, indem die Standardwerte
     ersetzt oder weitere Verzeichnisse angehÃ¤ngt werden. Zum Beispiel
     wird im Folgenden der Standardwert der Optionsvariablen
     `file_search_maxima' ersetzt:

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     In diesem Beispiel werden zwei weitere Verzeichnisse zu der
     Optionsvariablen `file_search_maxima' hinzugefÃ¼gt:

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     Soll eine erweiterte Liste der Suchverzeichnisse nach jedem Start
     von Maxima zur VerfÃ¼gung stehen, kann das obige Kommando in die
     Datei `maxima-init.mac' aufgenommen werden.

     Mehrere Dateiendungen und Pfade kÃ¶nnen mit Wildcard-Konstruktionen
     spezifiziert werden. Eine Zeichenkette `###' wird durch einen
     Dateinamen ersetzt. Werden mehrere Zeichenketten durch Kommata
     getrennt und mit geschweiften Klammern angegeben `{foo, bar,
     baz}', expandiert die Liste in mehrere Zeichenketten. So
     expandiert das folgende Beispiel fÃ¼r `neumann'

          "/home/{wfs,gcj}/###.{lisp,mac}"

     in `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac' und `/home/gcj/neumann.mac'.


 -- Funktion: file_type (<filename>)
     Gibt eine Vermutung Ã¼ber den Inhalt der Datei <filename> zurÃ¼ck.
     Es wird nur die Dateiendung betrachtet.

     Die RÃ¼ckgabe ist ein Symbol. Ist die Dateiendung "mac", "mc",
     "demo", "dem", "dm1", "dm2", "dm3" oder "dmt", ist die RÃ¼ckgabe
     `maxima'. Ist die Dateiendung "l", "lsp" oder "lisp", ist die
     RÃ¼ckgabe `lisp'. In allen anderen FÃ¤llen ist die RÃ¼ckgabe `object'.


 -- Funktion: load (<filename>)
     Wertet die AusdrÃ¼cke in der Datei <filename> aus, wodurch die
     Variablen, Funktionen und andere Objekte in Maxima geladen werden.
     Alle bisher zugewiesen Variablen und Definitionen werden
     Ã¼berschrieben. Um die Datei zu finden, wird von `load' die
     Funktion `file_search' mit den Verzeichnislisten
     `file_search_maxima' und `file_search_lisp' aufgerufen. Ist `load'
     erfolgreich, wird der Dateiname zurÃ¼ckgegeben. Ansonsten gibt
     `load' eine Fehlermeldung aus.

     `load' verarbeitet gleichermaÃen Dateien mit Lisp-Code und
     Maxima-Code.  Dateien, die mit den Funktionen `save',
     `translate_file' und `compile_file' erstellt wurden, enthalten
     Lisp-Code. Dateien, die mit `stringout' erstellt wurden, enthalten
     Maxima-Code. Alle diese Dateien kÃ¶nnen mit `load' geladen werden.
     `load' ruft die Funktion `loadfile' auf, um Lisp-Dateien zu
     verarbeiten, und `batchload', um Maxima-Dateien zu verarbeiten.

     `load' erkennt keine `:lisp'-Breakkommandos in Maxima-Dateien. Die
     Systemvariablen `_', `__' und `%' und die Funktion `%th' behalten
     jeweils ihren letzten Wert vor dem Aufruf von `load'.

     Siehe auch `loadfile', `batch', `batchload', and `demo'.
     `loadfile' verarbeitet Lisp-Dateien. `batch', `batchload' und
     `demo' verarbeiten Maxima-Dateien.

     Siehe `file_search' fÃ¼r mehr Details zum Auffinden von Dateien.

     `load' wertet seine Argumente aus.


 -- Systemvariable: load_pathname
     Standardwert: `false'

     Wird eine Datei mit den Funktionen `load', `loadfile' oder
     `batchload' geladen, enthÃ¤lt die Systemvariable `load_pathname'
     den Namen der Datei. Der Wert der Systemvariablen kann in der
     Datei, die geladen wird, ausgelesen werden.

     Beispiele:

     Ist eine Batch-Datei `test.mac' in dem Verzeichnis
          "/home/dieter/workspace/mymaxima/temp/"
     abgelegt und enthÃ¤lt die Datei die folgenden Befehle

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     dann erhÃ¤lt man die folgenden Ausgaben:

          (%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                             /home/dieter/workspace/mymaxima/temp/test.mac
          End of batchfile


 -- Funktion: loadfile (<filename>)
     Wertet Lisp-AusdrÃ¼cke in der Datei <filename> aus. `filename' ruft
     nicht `file_search' auf, um eine Datei zu finden. Daher muss
     `filename' ein vollstÃ¤ndiger Dateiname sein.

     `loadfile' kann Dateien verarbeiten, die mit den Funktionen `save',
     `translate_file' und `compile_file' erzeugt wurden.


 -- Optionsvariable: loadprint
     Standardwert: `true'

     `loadprint' kontrolliert, ob Meldungen ausgegeben werden, wenn
     eine Datei geladen wird.

        * Hat `loadprint' den Wert `true', wird immer eine Meldung
          ausgegeben.

        * Hat `loadprint' den Wert `'loadfile', wird eine Meldung
          ausgegeben, wenn die Datei mit der Funktion `loadfile'
          geladen wird.

        * Hat `loadprint' den Wert `'autoload', wird eine Meldung
          ausgegeben, wenn eine Datei automatisch geladen wird.

        * Hat `loadprint' den Wert `false', werden keine Meldung beim
          Laden von Dateien ausgegben.


 -- Funktion: pathname_directory (<pathname>)
 -- Funktion: pathname_name (<pathname>)
 -- Funktion: pathname_type (<pathname>)
     Diese Funktionen geben die Bestandteile eines Pfadnamens zurÃ¼ck.

     Beispiele:

          (%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
          (%o1)                 /home/dieter/maxima/
          (%i2) pathname_name("/home/dieter/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/dieter/maxima/changelog.txt");
          (%o3)                          txt


 -- Funktion: printfile (<path>)
     Druckt eine Datei mit dem Namen <path> auf der Konsole aus. <path>
     kann ein Symbol oder ein String sein.

     `printfile' sucht die Datei in den Verzeichnissen, die in der
     Optionsvariablen `file_search_usage' enthalten sind.

     `printfile' gibt <path> zurÃ¼ck, wenn die Datei existiert.


 -- Funktion: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Funktion: save (<filename>, values, functions, labels, ...)
 -- Funktion: save (<filename>, [<m>, <n>])
 -- Funktion: save (<filename>, <name_1>=<expr_1>, ...)
 -- Funktion: save (<filename>, all)
 -- Funktion: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)
     Speichert die aktuellen Werte von <name_1>, <name_2>, <name_3>,
     ..., in die Datei <filename>. Die Argumente sind die Namen von
     Variablen, Funktionen oder anderen Objekten. Argumente, die keinen
     Wert haben, werden ignoriert. `save' gibt den Namen der Datei
     `filename' zurÃ¼ck.

     `save' speichert die Daten in einem Lisp-Format. Die gespeicherten
     Daten kÃ¶nnen mit dem Kommando `load(<filename>)' zurÃ¼ckgelesen
     werden.

     Die Optionsvariable `file_output_append' bestimmt, ob `save' die
     Daten an die Ausgabedatei anhÃ¤ngt oder die Ausgabedatei zuvor
     lÃ¶scht. Hat `file_output_append' den Wert `true', werden die Daten
     angehÃ¤ngt.  Ansonsten wird die Datei gelÃ¶scht und neu angelegt.
     Existiert die Ausgabedatei noch nicht, wird diese angelegt.

     `save(<filename>, values, functions, labels, ...)' speichert die
     Werte aller EintrÃ¤ge der Listen `values', `functions', `labels',
     u.s.w. in die Ausgabedatei. Es kann jede der vorhandenen
     Informationslisten, die in der Systemvariablen `infolists'
     enthalten ist, als Argument Ã¼bergeben werden. `values' enthÃ¤lt zum
     Beispiel alle vom Nutzer definierten Variablen.

     `save(<filename>, [<m>, <n>])' speichert die Werte der Eingabe-
     und Ausgabemarken von <m> bis <n>. <m> und <n> mÃ¼ssen ganze Zahlen
     sein. Die Eingabe- und Ausgabemarken kÃ¶nnen auch einzeln
     gespeichert werden, zum Beispiel mit `save("foo.1", %i42, %o42)'.
     `save(<filename>, labels)' speichert alle Eingabe- und
     Ausgabemarken.  Beim ZurÃ¼ckgelesen der Marken, werden vorhandene
     Werte Ã¼berschrieben.

     `save(<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>, ...)'
     speichert die Werte <expr_1>, <expr_2>,  ..., unter den Namen
     <name_1>, <name_2>, .... ab. Dies kann nÃ¼tzlich sein, um zum
     Beispiel die Werte von Marken mit einem neuen Namen abzuspeichern,
     zum Beispiel mit `save("foo.1", aa=%o88)'. Die rechte Seite der
     Gleichungen kann ein beliebiger ausgewerteter Ausdruck sein. Die
     neuen Namen werden der aktuellen Sitzung nicht hinzugefÃ¼gt und nur
     in der Ausgabedatei gespeichert.

     Die verschiedenen MÃ¶glichkeiten die Funktion `save' aufzurufen,
     kÃ¶nnen miteinander kombiniert werden, zum Beispiel
     `save(<filename>, aa, bb, cc=42, functions, [11,17])'.

     `save(<filename>, all)' speichert den aktuellen Zustand von Maxima
     in eine Ausgabedatei. Eingeschlossen sind alle benutzerdefinierten
     Variablen, Funktionen, Arrays, usw., einschlieÃlich automatischer
     Definitionen. Die gespeicherten Daten enthalten auch die Werte von
     geÃ¤nderten System- oder Optionsvariablen, siehe `myoptions'.

     `save' wertet das Argument <filename> aus. Alle anderen Argumente
     werden nicht ausgewertet.


 -- Funktion: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: stringout (<filename>, [<m>, <n>])
 -- Funktion: stringout (<filename>, input)
 -- Funktion: stringout (<filename>, functions)
 -- Funktion: stringout (<filename>, values)
     `stringout' schreibt AusdrÃ¼cke in einem Format in eine Datei, dass
     identisch mit dem Format der Eingabe ist. Die Datei kann als
     Eingabedatei fÃ¼r die Funktionen `batch' oder `demo' genutzt
     werden. Sie kann mit einem Texteditor fÃ¼r jeden Zweck editiert
     werden. `stringout' kann ausgefÃ¼hrt werden, wenn das Kommando
     `writefile' aktiv ist.

     Die Optionsvariable `file_output_append' bestimmt, ob `stringout'
     die Daten an die Ausgabedatei anhÃ¤ngt oder die Ausgabedatei zuvor
     lÃ¶scht. Hat `file_output_append' den Wert `true', werden die Daten
     angehÃ¤ngt.  Ansonsten wird die Datei gelÃ¶scht und neu angelegt.
     Existiert die Ausgabedatei noch nicht, wird diese angelegt.

     Die allgemeine Form von `stringout' schreibt die Werte eines oder
     mehrerer AusdrÃ¼cke in die Ausgabedatei. Ist ein Ausdruck eine
     Variable, wird nur der Wert der Variablen, nicht jedoch der Name
     der Variablen in die Ausgabedatei geschrieben. Ein nÃ¼tzlicher
     Spezialfall ist, dass Eingabe- (`%i1', `%i2', `%i3', ...) und
     Ausgabemarken (`%o1', `%o2', `%o3', ...) in die Datei geschrieben
     werden kÃ¶nnen.

     Hat die Optionsvariable `grind' den Wert `true', wird die Ausgabe
     im Format der Funktion `grind' in die Ausgabedatei geschrieben.
     Ansonsten wird das Format der Funktion `string' fÃ¼r die Ausgabe
     genutzt. Siehe die Funktionen `grind' und `string'.

     `stringout(<filename>, [<m>, <n>])' schreibt die Werte aller
     Eingabemarken von <m> bis <n> in die Ausgabedatei.

     `stringout(<filename>, input)' schreibt alle Eingabemarken in die
     Ausgabedatei.

     `stringout(<filename>, functions)' schreibt alle vom Nutzer
     definierten Funktionen, die in der Informationsliste `functions'
     enthalten sind, in die Ausgabedatei.

     `stringout(<filename>, values)' schreibt alle benuzterdefinierten
     Variablen, die in der Informationsliste `values' enthalten sind,
     in die Ausgabedatei. Die Variablen werden als eine Zuweisung, mit
     dem Namen der Variablen, dem Zuweisungsoperator `:' und dem Wert
     in die Datei geschrieben. Beachte, dass die allgemeine Form der
     Funktion `stringout' die Werte der Variablen nicht als Zuweisung
     in die Datei speichert.


 -- Funktion: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     `with_stdout' wertet Argumente <expr_1>, <expr_2>, <expr_3>, ...
     aus und schreibt die Ergebnisse der Auswertung in die Ausgabedatei
     `f' oder in den Stream `s'. Die Ergebnisse werden nicht auf der
     Konsole ausgegeben.

     Die Optionsvariable `file_output_append' bestimmt, ob `with_stdout'
     die Daten an die Ausgabedatei anhÃ¤ngt oder die Ausgabedatei zuvor
     lÃ¶scht.  Hat `file_output_append' den Wert `true', werden die Daten
     angehÃ¤ngt. Ansonsten wird die Datei gelÃ¶scht und neu angelegt.
     Existiert die Ausgabedatei noch nicht, wird diese angelegt.

     `with_stout' gibt das Ergebnis des letzten Argumentes zurÃ¼ck.

     Siehe auch `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do
                print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Funktion: writefile (<filename>)
     Startet eine Aufzeichnung aller Ein- und Ausgaben der Konsole. Die
     Ein- und Ausgaben werden in die Datei <filename> geschrieben.

     Die Ausgabedatei kann von Maxima nicht wieder zurÃ¼ckgelesen
     werden. Um ein Datei zu erzeugen, die von Maxima zurÃ¼ckgelesen
     werden kann, siehe die Funktionen `save' and `stringout'. `save'
     speichert AusdrÃ¼cke in einem Lisp-Format und `stringout' speichert
     AusdrÃ¼cke in einem Maxima-Format.

     Die Reaktion der Funktion `writefile' fÃ¼r den Fall, dass die
     Ausgabedatei bereits existiert, hÃ¤ngt von der Lisp-Implementation
     ab. Die Ausgabedatei kann zurÃ¼ckgesetzt werden oder die Daten
     werden angehÃ¤ngt. Die Funktion `appendfile' hÃ¤ngt die Daten immer
     an eine existierende Datei an.

     Um eine Aufzeichnung ohne Textausgaben von Funktionen zu erhalten,
     kann `writefile' nach der AusfÃ¼hrung von `playback' ausgefÃ¼hrt
     werden.  `playback' gibt alle vorhergenden Eingabe- und
     Ausgabemarken aus, jedoch nicht sonstige Textausgaben von
     Maxima-Funktionen.

     Mit `closefile' wird die Aufzeichnung beendet.



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r die Tex-Ausgabe,  Prev: Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.4 Funktionen und Variablen fÃ¼r die Tex-Ausgabe
==================================================

 -- Function: tex (<expr>)
 -- Function: tex (<expr>, <destination>)
 -- Function: tex (<expr>, false)
 -- Function: tex (<label>)
 -- Function: tex (<label>, <destination>)
 -- Function: tex (<label>, false)
     Prints a representation of an expression suitable for the TeX
     document preparation system. The result is a fragment of a
     document, which can be copied into a larger document but not
     processed by itself.

     `tex (<expr>)' prints a TeX representation of <expr> on the
     console.

     `tex (<label>)' prints a TeX representation of the expression
     named by <label> and assigns it an equation label (to be displayed
     to the left of the expression). The TeX equation label is the same
     as the Maxima label.

     <destination> may be an output stream or file name. When
     <destination> is a file name, `tex' appends its output to the
     file. The functions `openw' and `opena' create output streams.

     `tex (<expr>, false)' and `tex (<label>, false)' return their TeX
     output as a string.

     `tex' evaluates its first argument after testing it to see if it
     is a label. Quote-quote `''' forces evaluation of the argument,
     thereby defeating the test and preventing the label.

     See also `texput'.

     Examples:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     `tex (<expr>, false)' returns its TeX output as a string.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$


 -- Function: tex1 (<e>)
     Returns a string which represents the TeX output for the
     expressions <e>.  The TeX output is not enclosed in delimiters for
     an equation or any other environment.

     Examples:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Function: texput (<a>, <s>)
 -- Function: texput (<a>, <f>)
 -- Function: texput (<a>, <s>, <operator_type>)
 -- Function: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Function: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Assign the TeX output for the atom <a>, which can be a symbol or
     the name of an operator.

     `texput (<a>, <s>)' causes the `tex' function to interpolate the
     string <s> into the TeX output in place of <a>.

     `texput (<a>, <f>)' causes the `tex' function to call the function
     <f> to generate TeX output. <f> must accept one argument, which is
     an expression which has operator <a>, and must return a string
     (the TeX output). <f> may call `tex1' to generate TeX output for
     the arguments of the input expression.

     `texput (<a>, <s>, <operator_type>)', where <operator_type> is
     `prefix', `infix', `postfix', `nary', or `nofix', causes the `tex'
     function to interpolate <s> into the TeX output in place of <a>,
     and to place the interpolated text in the appropriate position.

     `texput (<a>, [<s_1>, <s_2>], matchfix)' causes the `tex' function
     to interpolate <s_1> and <s_2> into the TeX output on either side
     of the arguments of <a>. The arguments (if more than one) are
     separated by commas.

     `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' causes the `tex'
     function to interpolate <s_1> and <s_2> into the TeX output on
     either side of the arguments of <a>, with <s_3> separating the
     arguments.

     Examples:

     Assign TeX output for a variable.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Assign TeX output for an ordinary function (not an operator).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Call a function to generate TeX output.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b), "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

     Assign TeX output for a prefix operator.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Assign TeX output for an infix operator.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Assign TeX output for a postfix operator.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Assign TeX output for a nary operator.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Assign TeX output for a nofix operator.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Assign TeX output for a matchfix operator.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false


 -- Function: get_tex_environment (<op>)
 -- Function: set_tex_environment (<op>, <before>, <after>)
     Customize the TeX environment output by `tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     Only the TeX environment of the top-level operator in an expression
     is output; TeX environments associated with other operators are
     ignored.

     `get_tex_environment' returns the TeX enviroment which is applied
     to the operator <op>; returns the default if no other environment
     has been assigned.

     `set_tex_environment' assigns the TeX environment for the operator
     <op>.

     Examples:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false


 -- Function: get_tex_environment_default ()
 -- Function: set_tex_environment_default (<before>, <after>)
     Customize the TeX environment output by `tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     `get_tex_environment_default' returns the TeX environment which is
     applied to expressions for which the top-level operator has no
     specific TeX environment (as assigned by `set_tex_environment').

     `set_tex_environment_default' assigns the default TeX environment.

     Examples:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false



File: maxima.info,  Node: Mengen,  Next: Summen Produkte und Reihen,  Prev: Eingabe und Ausgabe,  Up: Top

14 Mengen
*********

* Menu:

* Introduction to Sets::
* Functions and Variables for Sets::


File: maxima.info,  Node: Introduction to Sets,  Next: Functions and Variables for Sets,  Prev: Mengen,  Up: Mengen

14.1 Introduction to Sets
=========================

Maxima provides set functions, such as intersection and union, for
finite sets that are defined by explicit enumeration.  Maxima treats
lists and sets as distinct objects. This feature makes it possible to
work with sets that have members that are either lists or sets.

   In addition to functions for finite sets, Maxima provides some
functions related to combinatorics; these include the Stirling numbers
of the first and second kind, the Bell numbers, multinomial
coefficients, partitions of nonnegative integers, and a few others.
Maxima also defines a Kronecker delta function.

14.1.1 Usage
------------

To construct a set with members `a_1, ..., a_n', write `set(a_1, ...,
a_n)' or `{a_1, ..., a_n}'; to construct the empty set, write `set()'
or `{}'.  In input, `set(...)' and `{ ... }' are equivalent.  Sets are
always displayed with curly braces.

   If a member is listed more than once, simplification eliminates the
redundant member.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Two would-be elements <x> and <y> are redundant (i.e., considered
the same for the purpose of set construction) if and only if `is(<x> =
<y>)' yields `true'.  Note that `is(equal(<x>, <y>))' can yield `true'
while `is(<x> = <y>)' yields `false'; in that case the elements <x> and
<y> are considered distinct.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   To construct a set from the elements of a list, use `setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Set members `x' and `y' are equal provided `is(x = y)' evaluates to
`true'. Thus `rat(x)' and `x' are equal as set members; consequently,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Further, since `is((x - 1)*(x + 1) = x^2 - 1)' evaluates to `false',
`(x - 1)*(x + 1)' and `x^2 - 1' are distinct set members; thus

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   To reduce this set to a singleton set, apply `rat' to each set
member:

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   To remove redundancies from other sets, you may need to use other
simplification functions. Here is an example that uses `trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   A set is simplified when its members are non-redundant and sorted.
The current version of the set functions uses the Maxima function
`orderlessp' to order sets; however, future versions of the set
functions might use a different ordering function.

   Some operations on sets, such as substitution, automatically force a
re-simplification; for example,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima treats lists and sets as distinct objects; functions such as
`union' and `intersection' complain if any argument is not a set. If
you need to apply a set function to a list, use the `setify' function
to convert it to a set. Thus

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   To extract all set elements of a set `s' that satisfy a predicate
`f', use `subset(s, f)'. (A predicate is a boolean-valued function.)
For example, to find the equations in a given set that do not depend on
a variable `z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   The section *note Functions and Variables for Sets:: has a complete
list of the set functions in Maxima.

14.1.2 Set Member Iteration
---------------------------

There two ways to to iterate over set members. One way is the use
`map'; for example:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   The other way is to use `for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   The Maxima functions `first' and `rest' work correctly on sets.
Applied to a set, `first' returns the first displayed element of a set;
which element that is may be implementation-dependent. If `s' is a set,
then `rest(s)' is equivalent to `disjoin(first(s), s)'.  Currently,
there are other Maxima functions that work correctly on sets.  In
future versions of the set functions, `first' and `rest' may function
differently or not at all.

14.1.3 Bugs
-----------

The set functions use the Maxima function `orderlessp' to order set
members and the (Lisp-level) function `like' to test for set member
equality. Both of these functions have known bugs that may manifest if
you attempt to use sets with members that are lists or matrices that
contain expressions in canonical rational expression (CRE) form. An
example is

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   This expression causes Maxima to halt with an error (the error
message depends on which version of Lisp your Maxima uses). Another
example is

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   These bugs are caused by bugs in `orderlessp' and `like'; they are
not caused by bugs in the set functions. To illustrate, try the
expressions

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Until these bugs are fixed, do not construct sets with members that
are lists or matrices containing expressions in CRE form; a set with a
member in CRE form, however, shouldn't be a problem:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   Maxima's `orderlessp' has another bug that can cause problems with
set functions, namely that the ordering predicate `orderlessp' is not
transitive. The simplest known example that shows this is

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   This bug can cause trouble with all set functions as well as with
Maxima functions in general. It is probable, but not certain, that this
bug can be avoided if all set members are either in CRE form or have
been simplified using `ratsimp'.

   Maxima's `orderless' and `ordergreat' mechanisms are incompatible
with the set functions. If you need to use either `orderless' or
`ordergreat', call those functions before constructing any sets, and do
not call `unorder'.

   If you find something that you think might be a set function bug,
please report it to the Maxima bug database. See `bug_report'.

14.1.4 Authors
--------------

Stavros Macrakis of Cambridge, Massachusetts and Barton Willis of the
University of Nebraska at Kearney (UNK) wrote the Maxima set functions
and their documentation.


File: maxima.info,  Node: Functions and Variables for Sets,  Prev: Introduction to Sets,  Up: Mengen

14.2 Functions and Variables for Sets
=====================================

 -- Function: adjoin (<x>, <a>)
     Returns the union of the set <a> with `{<x>}'.

     `adjoin' complains if <a> is not a literal set.

     `adjoin(<x>, <a>)' and `union(set(<x>), <a>)' are equivalent;
     however, `adjoin' may be somewhat faster than `union'.

     See also `disjoin'.

     Examples:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}


 -- Function: belln (<n>)
     Represents the n-th Bell number.  `belln(n)' is the number of
     partitions of a set with <n> members.

     For nonnegative integers <n>, `belln(<n>)' simplifies to the n-th
     Bell number.  `belln' does not simplify for any other arguments.

     `belln' distributes over equations, lists, matrices, and sets.

     Examples:

     `belln' applied to nonnegative integers.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     `belln' applied to arguments which are not nonnegative integers.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]


 -- Function: cardinality (<a>)
     Returns the number of distinct elements of the set <a>.

     `cardinality' ignores redundant elements even when simplification
     is disabled.

     Examples:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3


 -- Function: cartesian_product (<b_1>, ... , <b_n>)
     Returns a set of lists of the form `[<x_1>, ..., <x_n>]', where
     <x_1>, ..., <x_n> are elements of the sets <b_1>, ... , <b_n>,
     respectively.

     `cartesian_product' complains if any argument is not a literal set.

     Examples:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}


 -- Function: disjoin (<x>, <a>)
     Returns the set <a> without the member <x>.  If <x> is not a
     member of <a>, return <a> unchanged.

     `disjoin' complains if <a> is not a literal set.

     `disjoin(<x>, <a>)', `delete(<x>, <a>)', and `setdifference(<a>,
     set(<x>))' are all equivalent.  Of these, `disjoin' is generally
     faster than the others.

     Examples:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}


 -- Function: disjointp (<a>, <b>)
     Returns `true' if and only if the sets <a> and <b> are disjoint.

     `disjointp' complains if either <a> or <b> is not a literal set.

     Examples:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false


 -- Function: divisors (<n>)
     Represents the set of divisors of <n>.

     `divisors(<n>)' simplifies to a set of integers when <n> is a
     nonzero integer.  The set of divisors includes the members 1 and
     <n>.  The divisors of a negative integer are the divisors of its
     absolute value.

     `divisors' distributes over equations, lists, matrices, and sets.

     Examples:

     We can verify that 28 is a perfect number: the sum of its divisors
     (except for itself) is 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     `divisors' is a simplifying function.  Substituting 8 for `a' in
     `divisors(a)' yields the divisors without reevaluating
     `divisors(8)'.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     `divisors' distributes over equations, lists, matrices, and sets.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}


 -- Function: elementp (<x>, <a>)
     Returns `true' if and only if <x> is a member of the set <a>.

     `elementp' complains if <a> is not a literal set.

     Examples:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false


 -- Function: emptyp (<a>)
     Return `true' if and only if <a> is the empty set or the empty
     list.

     Examples:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]


 -- Function: equiv_classes (<s>, <F>)
     Returns a set of the equivalence classes of the set <s> with
     respect to the equivalence relation <F>.

     <F> is a function of two variables defined on the Cartesian
     product of <s> with <s>.  The return value of <F> is either `true'
     or `false', or an expression <expr> such that `is(<expr>)' is
     either `true' or `false'.

     When <F> is not an equivalence relation, `equiv_classes' accepts
     it without complaint, but the result is generally incorrect in
     that case.

     Examples:

     The equivalence relation is a lambda expression which returns
     `true' or `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     The equivalence relation is the name of a relational function
     which `is' evaluates to `true' or `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     The equivalence classes are numbers which differ by a multiple of
     3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}


 -- Function: every (<f>, <s>)
 -- Function: every (<f>, <L_1>, ..., <L_n>)
     Returns `true' if the predicate <f> is `true' for all given
     arguments.

     Given one set as the second argument, `every(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for all <a_i> in <s>.
     `every' may or may not evaluate <f> for all <a_i> in <s>.  Since
     sets are unordered, `every' may evaluate `<f>(<a_i>)' in any order.

     Given one or more lists as arguments, `every(<f>, <L_1>, ...,
     <L_n>)' returns `true' if `is(<f>(<x_1>, ..., <x_n>))' returns
     `true' for all <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectively.  `every' may or may not evaluate <f> for every
     combination <x_1>, ..., <x_n>.  `every' evaluates lists in the
     order of increasing index.

     Given an empty set `{}' or empty lists `[]' as arguments, `every'
     returns `false'.

     When the global flag `maperror' is `true', all lists <L_1>, ...,
     <L_n> must have equal lengths.  When `maperror' is `false', list
     arguments are effectively truncated to the length of the shortest
     list.

     Return values of the predicate <f> which evaluate (via `is') to
     something other than `true' or `false' are governed by the global
     flag `prederror'.  When `prederror' is `true', such values are
     treated as `false', and the return value from `every' is `false'.
     When `prederror' is `false', such values are treated as `unknown',
     and the return value from `every' is `unknown'.

     Examples:

     `every' applied to a single set.  The predicate is a function of
     one argument.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     `every' applied to two lists.  The predicate is a function of two
     arguments.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Return values of the predicate <f> which evaluate to something
     other than `true' or `false' are governed by the global flag
     `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false


 -- Function: extremal_subset (<s>, <f>, max)
 -- Function: extremal_subset (<s>, <f>, min)
     Returns the subset of <s> for which the function <f> takes on
     maximum or minimum values.

     `extremal_subset(<s>, <f>, max)' returns the subset of the set or
     list <s> for which the real-valued function <f> takes on its
     maximum value.

     `extremal_subset(<s>, <f>, min)' returns the subset of the set or
     list <s> for which the real-valued function <f> takes on its
     minimum value.

     Examples:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}


 -- Function: flatten (<expr>)
     Collects arguments of subexpressions which have the same operator
     as <expr> and constructs an expression from these collected
     arguments.

     Subexpressions in which the operator is different from the main
     operator of `expr' are copied without modification, even if they,
     in turn, contain some subexpressions in which the operator is the
     same as for `expr'.

     It may be possible for `flatten' to construct expressions in which
     the number of arguments differs from the declared arguments for an
     operator; this may provoke an error message from the simplifier or
     evaluator.  `flatten' does not try to detect such situations.

     Expressions with special representations, for example, canonical
     rational expressions (CRE), cannot be flattened; in such cases,
     `flatten' returns its argument unchanged.

     Examples:

     Applied to a list, `flatten' gathers all list elements that are
     lists.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Applied to a set, `flatten' gathers all members of set elements
     that are sets.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     `flatten' is similar to the effect of declaring the main operator
     n-ary.  However, `flatten' has no effect on subexpressions which
     have an operator different from the main operator, while an n-ary
     declaration affects those.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     `flatten' treats subscripted functions the same as any other
     operator.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     It may be possible for `flatten' to construct expressions in which
     the number of arguments differs from the declared arguments for an
     operator;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Function: full_listify (<a>)
     Replaces every set operator in <a> by a list operator, and returns
     the result.  `full_listify' replaces set operators in nested
     subexpressions, even if the main operator is not `set'.

     `listify' replaces only the main operator.

     Examples:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))


 -- Function: fullsetify (<a>)
     When <a> is a list, replaces the list operator with a set operator,
     and applies `fullsetify' to each member which is a set.  When <a>
     is not a list, it is returned unchanged.

     `setify' replaces only the main operator.

     Examples:

     In line `(%o2)', the argument of `f' isn't converted to a set
     because the main operator of `f([b])' isn't a list.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}


 -- Function: identity (<x>)
     Returns <x> for any argument <x>.

     Examples:

     `identity' may be used as a predicate when the arguments are
     already Boolean values.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Function: integer_partitions (<n>)
 -- Function: integer_partitions (<n>, <len>)
     Returns integer partitions of <n>, that is, lists of integers
     which sum to <n>.

     `integer_partitions(<n>)' returns the set of all partitions of the
     integer <n>.  Each partition is a list sorted from greatest to
     least.

     `integer_partitions(<n>, <len>)' returns all partitions that have
     length <len> or less; in this case, zeros are appended to each
     partition with fewer than <len> terms to make each partition have
     exactly <len> terms.  Each partition is a list sorted from
     greatest to least.

     A list [a_1, ..., a_m] is a partition of a nonnegative integer n
     when (1) each a_i is a nonzero integer, and (2) a_1 + ... + a_m =
     n. Thus 0 has no partitions.

     Examples:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     To find all partitions that satisfy a condition, use the function
     `subset'; here is an example that finds all partitions of 10 that
     consist of prime numbers.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}


 -- Function: intersect (<a_1>, ..., <a_n>)
     `intersect' is the same as `intersection', which see.


 -- Function: intersection (<a_1>, ..., <a_n>)
     Returns a set containing the elements that are common to the sets
     <a_1> through <a_n>.

     `intersection' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}


 -- Function: kron_delta (<x>, <y>)
     Represents the Kronecker delta function.

     `kron_delta' simplifies to 1 when <x> and <y> are identical or
     demonstrably equivalent, and it simplifies to 0 when <x> and <y>
     are demonstrably not equivalent.  Otherwise, it is not certain
     whether <x> and <y> are equivalent, and `kron_delta' simplifies to
     a noun expression.  `kron_delta' implements a cautious policy with
     respect to floating point expressions: if the difference `<x> -
     <y>' is a floating point number, `kron_delta' simplifies to a noun
     expression when <x> is apparently equivalent to <y>.

     Specifically, `kron_delta(<x>, <y>)' simplifies to 1 when `is(x =
     y)' is `true'.  `kron_delta' also simplifies to 1 when
     `sign(abs(<x> - <y>))' is `zero' and `<x> - <y>' is not a floating
     point number (neither an ordinary float nor a bigfloat).
     `kron_delta' simplifies to 0 when `sign(abs(<x> - <y>))' is `pos'.

     Otherwise, `sign(abs(<x> - <y>))' is something other than `pos' or
     `zero', or it is `zero' and `<x> - <y>' is a floating point number.
     In these cases, `kron_delta' returns a noun expression.

     `kron_delta' is declared to be symmetric.  That is,
     `kron_delta(<x>, <y>)' is equal to `kron_delta(<y>, <x>)'.

     Examples:

     The arguments of `kron_delta' are identical.  `kron_delta'
     simplifies to 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     The arguments of `kron_delta' are equivalent, and their difference
     is not a floating point number.  `kron_delta' simplifies to 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     The arguments of `kron_delta' are not equivalent.  `kron_delta'
     simplifies to 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     The arguments of `kron_delta' might or might not be equivalent.
     `kron_delta' simplifies to a noun expression.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     The arguments of `kron_delta' are equivalent, but their difference
     is a floating point number.  `kron_delta' simplifies to a noun
     expression.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     `kron_delta' is symmetric.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true


 -- Function: listify (<a>)
     Returns a list containing the members of <a> when <a> is a set.
     Otherwise, `listify' returns <a>.

     `full_listify' replaces all set operators in <a> by list operators.

     Examples:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})


 -- Function: lreduce (<F>, <s>)
 -- Function: lreduce (<F>, <s>, <s_0>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a list.

     `lreduce(<F>, <s>)' returns `F(... F(F(s_1, s_2), s_3), ... s_n)'.
     When the optional argument <s_0> is present, the result is
     equivalent to `lreduce(<F>, cons(<s_0>, <s>))'.

     The function <F> is first applied to the leftmost list elements,
     thus the name "lreduce".

     See also `rreduce', `xreduce', and `tree_reduce'.

     Examples:

     `lreduce' without the optional argument.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     `lreduce' with the optional argument.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     `lreduce' applied to built-in binary operators.  `/' is the
     division operator.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d


 -- Function: makeset (<expr>, <x>, <s>)
     Returns a set with members generated from the expression <expr>,
     where <x> is a list of variables in <expr>, and <s> is a set or
     list of lists.  To generate each set member, <expr> is evaluated
     with the variables <x> bound in parallel to a member of <s>.

     Each member of <s> must have the same length as <x>.  The list of
     variables <x> must be a list of symbols, without subscripts.  Even
     if there is only one symbol, <x> must be a list of one element,
     and each member of <s> must be a list of one element.

     See also `makelist'.

     Examples:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}


 -- Function: moebius (<n>)
     Represents the Moebius function.

     When <n> is product of k distinct primes, `moebius(<n>)'
     simplifies to (-1)^k; when <n> = 1, it simplifies to 1; and it
     simplifies to 0 for all other positive integers.

     `moebius' distributes over equations, lists, matrices, and sets.

     Examples:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}


 -- Function: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Function: multinomial_coeff ()
     Returns the multinomial coefficient.

     When each <a_k> is a nonnegative integer, the multinomial
     coefficient gives the number of ways of placing `<a_1> + ... +
     <a_n>' distinct objects into n boxes with <a_k> elements in the
     k'th box. In general, `multinomial_coeff (<a_1>, ..., <a_n>)'
     evaluates to `(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     `multinomial_coeff()' (with no arguments) evaluates to 1.

     `minfactorial' may be able to simplify the value returned by
     `multinomial_coeff'.

     Examples:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10


 -- Function: num_distinct_partitions (<n>)
 -- Function: num_distinct_partitions (<n>, list)
     Returns the number of distinct integer partitions of <n> when <n>
     is a nonnegative integer.  Otherwise, `num_distinct_partitions'
     returns a noun expression.

     `num_distinct_partitions(<n>, list)' returns a list of the number
     of distinct partitions of 1, 2, 3, ..., <n>.

     A distinct partition of <n> is a list of distinct positive
     integers k_1, ..., k_m such that <n> = k_1 + ... + k_m.

     Examples:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)


 -- Function: num_partitions (<n>)
 -- Function: num_partitions (<n>, list)
     Returns the number of integer partitions of <n> when <n> is a
     nonnegative integer.  Otherwise, `num_partitions' returns a noun
     expression.

     `num_partitions(<n>, list)' returns a list of the number of
     integer partitions of 1, 2, 3, ..., <n>.

     For a nonnegative integer <n>, `num_partitions(<n>)' is equal to
     `cardinality(integer_partitions(<n>))'; however, `num_partitions'
     does not actually construct the set of partitions, so it is much
     faster.

     Examples:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)


 -- Function: partition_set (<a>, <f>)
     Partitions the set <a> according to the predicate <f>.

     `partition_set' returns a list of two sets.  The first set
     comprises the elements of <a> for which <f> evaluates to `false',
     and the second comprises any other elements of <a>.
     `partition_set' does not apply `is' to the return value of <f>.

     `partition_set' complains if <a> is not a literal set.

     See also `subset'.

     Examples:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]


 -- Function: permutations (<a>)
     Returns a set of all distinct permutations of the members of the
     list or set <a>. Each permutation is a list, not a set.

     When <a> is a list, duplicate members of <a> are included in the
     permutations.

     `permutations' complains if <a> is not a literal list or set.

     See also `random_permutation'.

     Examples:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}


 -- Function: powerset (<a>)
 -- Function: powerset (<a>, <n>)
     Returns the set of all subsets of <a>, or a subset of that set.

     `powerset(<a>)' returns the set of all subsets of the set <a>.
     `powerset(<a>)' has `2^cardinality(<a>)' members.

     `powerset(<a>, <n>)' returns the set of all subsets of <a> that
     have cardinality <n>.

     `powerset' complains if <a> is not a literal set, or if <n> is not
     a nonnegative integer.

     Examples:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}


 -- Function: random_permutation (<a>)
     Returns a random permutation of the set or list <a>, as
     constructed by the Knuth shuffle algorithm.

     The return value is a new list, which is distinct from the
     argument even if all elements happen to be the same.  However, the
     elements of the argument are not copied.

     Examples:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]


 -- Function: rreduce (<F>, <s>)
 -- Function: rreduce (<F>, <s>, <s_{n + 1}>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a list.

     `rreduce(<F>, <s>)' returns `F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  When the optional argument <s_{n + 1}> is present, the
     result is equivalent to `rreduce(<F>, endcons(<s_{n + 1}>, <s>))'.

     The function <F> is first applied to the rightmost list elements,
     thus the name "rreduce".

     See also `lreduce', `tree_reduce', and `xreduce'.

     Examples:

     `rreduce' without the optional argument.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     `rreduce' with the optional argument.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     `rreduce' applied to built-in binary operators.  `/' is the
     division operator.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d


 -- Function: setdifference (<a>, <b>)
     Returns a set containing the elements in the set <a> that are not
     in the set <b>.

     `setdifference' complains if either <a> or <b> is not a literal
     set.

     Examples:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}


 -- Function: setequalp (<a>, <b>)
     Returns `true' if sets <a> and <b> have the same number of elements
     and `is(<x> = <y>)' is `true' for `x' in the elements of <a> and
     `y' in the elements of <b>, considered in the order determined by
     `listify'.  Otherwise, `setequalp' returns `false'.

     Examples:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false


 -- Function: setify (<a>)
     Constructs a set from the elements of the list <a>. Duplicate
     elements of the list <a> are deleted and the elements are sorted
     according to the predicate `orderlessp'.

     `setify' complains if <a> is not a literal list.

     Examples:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}


 -- Function: setp (<a>)
     Returns `true' if and only if <a> is a Maxima set.

     `setp' returns `true' for unsimplified sets (that is, sets with
     redundant members) as well as simplified sets.

     `setp' is equivalent to the Maxima function `setp(a) := not
     atom(a) and op(a) = 'set'.

     Examples:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true


 -- Function: set_partitions (<a>)
 -- Function: set_partitions (<a>, <n>)
     Returns the set of all partitions of <a>, or a subset of that set.

     `set_partitions(<a>, <n>)' returns a set of all decompositions of
     <a> into <n> nonempty disjoint subsets.

     `set_partitions(<a>)' returns the set of all partitions.

     `stirling2' returns the cardinality of the set of partitions of a
     set.

     A set of sets P is a partition of a set S when

       1. each member of P is a nonempty set,

       2. distinct members of P are disjoint,

       3. the union of the members of P equals S.

     Examples:

     The empty set is a partition of itself, the conditions 1 and 2
     being vacuously true.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     The cardinality of the set of partitions of a set can be found
     using `stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Each member of `p' should have <n> = 3 members; let's check.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finally, for each member of `p', the union of its members should
     equal `s'; again let's check.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}


 -- Function: some (<f>, <a>)
 -- Function: some (<f>, <L_1>, ..., <L_n>)
     Returns `true' if the predicate <f> is `true' for one or more
     given arguments.

     Given one set as the second argument, `some(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for one or more <a_i> in
     <s>.  `some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, `some' may evaluate `<f>(<a_i>)' in any
     order.

     Given one or more lists as arguments, `some(<f>, <L_1>, ...,
     <L_n>)' returns `true' if `is(<f>(<x_1>, ..., <x_n>))' returns
     `true' for one or more <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectively.  `some' may or may not evaluate <f> for some
     combinations <x_1>, ..., <x_n>.  `some' evaluates lists in the
     order of increasing index.

     Given an empty set `{}' or empty lists `[]' as arguments, `some'
     returns `false'.

     When the global flag `maperror' is `true', all lists <L_1>, ...,
     <L_n> must have equal lengths.  When `maperror' is `false', list
     arguments are effectively truncated to the length of the shortest
     list.

     Return values of the predicate <f> which evaluate (via `is') to
     something other than `true' or `false' are governed by the global
     flag `prederror'.  When `prederror' is `true', such values are
     treated as `false'.  When `prederror' is `false', such values are
     treated as `unknown'.

     Examples:

     `some' applied to a single set.  The predicate is a function of
     one argument.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     `some' applied to two lists.  The predicate is a function of two
     arguments.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Return values of the predicate <f> which evaluate to something
     other than `true' or `false' are governed by the global flag
     `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true


 -- Function: stirling1 (<n>, <m>)
     Represents the Stirling number of the first kind.

     When <n> and <m> are nonnegative integers, the magnitude of
     `stirling1 (<n>, <m>)' is the number of permutations of a set with
     <n> members that have <m> cycles.  For details, see Graham, Knuth
     and Patashnik Concrete Mathematics.  Maxima uses a recursion
     relation to define `stirling1 (<n>, <m>)' for <m> less than 0; it
     is undefined for <n> less than 0 and for non-integer arguments.

     `stirling1' is a simplifying function.  Maxima knows the following
     identities.

       1. stirling1(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling1(n, n) = 1 (Ref. [1])

       3. stirling1(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling1(n + 1, 0) = 0 (Ref. [1])

       5. stirling1(n + 1, 1) = n! (Ref. [1])

       6. stirling1(n + 1, 2) = 2^n  - 1 (Ref. [1])

     These identities are applied when the arguments are literal
     integers or symbols declared as integers, and the first argument
     is nonnegative.  `stirling1' does not simplify for non-integer
     arguments.

     References:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     Examples:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' does not simplify for non-integer arguments.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima applies identities to `stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!


 -- Function: stirling2 (<n>, <m>)
     Represents the Stirling number of the second kind.

     When <n> and <m> are nonnegative integers, `stirling2 (<n>, <m>)'
     is the number of ways a set with cardinality <n> can be
     partitioned into <m> disjoint subsets.  Maxima uses a recursion
     relation to define `stirling2 (<n>, <m>)' for <m> less than 0; it
     is undefined for <n> less than 0 and for non-integer arguments.

     `stirling2' is a simplifying function.  Maxima knows the following
     identities.

       1. stirling2(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling2(n, n) = 1 (Ref. [1])

       3. stirling2(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling2(n + 1, 1) = 1 (Ref. [1])

       5. stirling2(n + 1, 2) = 2^n  - 1 (Ref. [1])

       6. stirling2(n, 0) = kron_delta(n, 0) (Ref. [2])

       7. stirling2(n, m) = 0 when m > n (Ref. [2])

       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!  when m and n are integers, and n is nonnegative. (Ref.
          [3])

     These identities are applied when the arguments are literal
     integers or symbols declared as integers, and the first argument
     is nonnegative.  `stirling2' does not simplify for non-integer
     arguments.

     References:

     [1] Donald Knuth. The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik. Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun. Handbook of Mathematical Functions,
     Section 24.1.4.

     Examples:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' does not simplify for non-integer arguments.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima applies identities to `stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1


 -- Function: subset (<a>, <f>)
     Returns the subset of the set <a> that satisfies the predicate <f>.

     `subset' returns a set which comprises the elements of <a> for
     which <f> returns anything other than `false'.  `subset' does not
     apply `is' to the return value of <f>.

     `subset' complains if <a> is not a literal set.

     See also `partition_set'.

     Examples:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}


 -- Function: subsetp (<a>, <b>)
     Returns `true' if and only if the set <a> is a subset of <b>.

     `subsetp' complains if either <a> or <b> is not a literal set.

     Examples:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false


 -- Function: symmdifference (<a_1>, ..., <a_n>)
     Returns the symmetric difference of sets ` <a_1>, ..., <a_n>'.
     Given two arguments, `symmdifference ( <a>, <b>)' is the same as
     `union ( setdifference ( <a>, <b>), setdifference(<b>, <a>))'.

     `symmdifference' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, b, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1,b, z}


 -- Function: tree_reduce (<F>, <s>)
 -- Function: tree_reduce (<F>, <s>, <s_0>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a set or list.

     `tree_reduce' is equivalent to the following: Apply <F> to
     successive pairs of elements to form a new list `[<F>(<s_1>,
     <s_2>), <F>(<s_3>, <s_4>), ...]', carrying the final element
     unchanged if there are an odd number of elements.  Then repeat
     until the list is reduced to a single element, which is the return
     value.

     When the optional argument <s_0> is present, the result is
     equivalent `tree_reduce(<F>, cons(<s_0>, <s>)'.

     For addition of floating point numbers, `tree_reduce' may return a
     sum that has a smaller rounding error than either `rreduce' or
     `lreduce'.

     The elements of <s> and the partial results may be arranged in a
     minimum-depth binary tree, thus the name "tree_reduce".

     Examples:

     `tree_reduce' applied to a list with an even number of elements.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     `tree_reduce' applied to a list with an odd number of elements.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)


 -- Function: union (<a_1>, ..., <a_n>)
     Returns the union of the sets <a_1> through <a_n>.

     `union()' (with no arguments) returns the empty set.

     `union' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}


 -- Function: xreduce (<F>, <s>)
 -- Function: xreduce (<F>, <s>, <s_0>)
     Extends the function <F> to an n-ary function by composition, or,
     if <F> is already n-ary, applies <F> to <s>.  When <F> is not
     n-ary, `xreduce' is the same as `lreduce'.  The argument <s> is a
     list.

     Functions known to be n-ary include addition `+', multiplication
     `*', `and', `or', `max', `min', and `append'.  Functions may also
     be declared n-ary by `declare(<F>, nary)'.  For these functions,
     `xreduce' is expected to be faster than either `rreduce' or
     `lreduce'.

     When the optional argument <s_0> is present, the result is
     equivalent to `xreduce(<s>, cons(<s_0>, <s>))'.

     Floating point addition is not exactly associative; be that as it
     may, `xreduce' applies Maxima's n-ary addition when <s> contains
     floating point numbers.

     Examples:

     `xreduce' applied to a function known to be n-ary.  `F' is called
     once, with all arguments.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     `xreduce' applied to a function not known to be n-ary.  `G' is
     called several times, with two arguments each time.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]



File: maxima.info,  Node: Summen Produkte und Reihen,  Next: Analysis,  Prev: Mengen,  Up: Top

15 Summen, Produkte und Reihen
******************************

* Menu:

* Summen und Produkte::
* EinfÃ¼hrung in Reihen::
* Funktionen und Variablen fÃ¼r Reihen::
* Poisson Reihen::
* KettenbrÃ¼che::


File: maxima.info,  Node: Summen und Produkte,  Next: EinfÃ¼hrung in Reihen,  Prev: Summen Produkte und Reihen,  Up: Summen Produkte und Reihen

15.1 Summen und Produkte
========================

 -- Funktion: bashindices (<expr>)
     Transformiert einen Ausdruck <expr> der mehrere Summen oder
     Produkte enthÃ¤lt so, dass alle Summen und Produkte einen
     unterschiedlichen Index haben.  Dies erleichtert Substitutionen
     wie zum Beispiel mit `changevar'.  Die neuen Indizes lauten
     `j<nummer>'. Die Zahl <nummer> ist der Wert der Optionsvariablen
     `gensumnum'. Siehe `gensumnum'.

     Beispiel:

          (%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                                 inf       inf
                                 ====      ====
                                 \     1   \     1
          (%o1)                   >    - +  >    --
                                 /     k   /      2
                                 ====      ====  k
                                 k = 0     k = 0
          (%i2) bashindices(%);
                               inf         inf
                               ====        ====
                               \      1    \       1
          (%o2)                 >     -- +  >     ---
                               /      j2   /        2
                               ====        ====   j1
                               j2 = 0      j1 = 0


 -- Optionsvariable: cauchysum
     Standardwert: `false'

     Werden zwei unendliche Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum' haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Beispiele:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Optionsvariable: genindex
     Standardwert: `i'

     `genindex' enthÃ¤lt das Zeichen fÃ¼r den PrÃ¤fix, um einen neuen Index
     fÃ¼r eine Summe oder ein Produkt zu generieren.


 -- Optionsvariable: gensumnum
     Standardwert: 0

     `gensumnum' enthÃ¤lt die Nummer, die an den PrÃ¤fix angehÃ¤ngt wird,
     um den nÃ¤chsten Index fÃ¼r eine Summe oder ein Produkt zu
     generieren. Hat `gensumnum' den Wert `false', wird der Index nur
     aus dem Zeichen `genindex' gebildet.


 -- Funktion: intosum (<expr>)
     Multipliziert Faktoren in eine Summe herein. Tritt der Index der
     Summe auÃerhalb der Summe auf, wird von der Funktion `intosum' ein
     neuer Index gesucht. Summen haben die Eigenschaft `outative',  so
     dass Faktoren aus der Summe herausgezogen werden. Mit der Funktion
     `intosum' wird diese Vereinfachung rÃ¼ckgÃ¤ngig gemacht.

     In einigen FÃ¤llen kann die Vereinfachung `scanmap(multthru,
     <expr>)' vor einem Aufruf von `intosum' notwendig sein.

     Beispiel:

          (%i1) sum(2*x^2*n^k, k , 0, inf);
                                         inf
                                         ====
                                       2 \      k
          (%o1)                     2 x   >    n
                                         /
                                         ====
                                         k = 0
          (%i2) intosum(%);
                                    inf
                                    ====
                                    \        k  2
          (%o2)                      >    2 n  x
                                    /
                                    ====
                                    k = 0


 -- Funktion: lsum (<expr>, <i>, <L>)
     Bildet die Summe fÃ¼r den Ausdruck <expr>. <i> ist der Index, dessen
     Elemente in der Liste <L> aufgezÃ¤hlt sind. Kann das Argument <L>
     nicht zu einer Liste ausgewertet werden, wird eine Substantivform
     zurÃ¼ckgegeben.

     Beispiele:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Funktion: niceindices (<expr>)
     Gibt den Indizes von Summen und Produkten im Ausdruck <expr> einen
     neuen Namen. `niceindices' benennt die Indizes nacheinander mit
     den Namen, die in der Liste der Optionsvariablen `niceindicespref'
     enthalten sind. Die Standardnamen sind `[i, j, k, l, m, n]'. Sind
     nicht genÃ¼gend Namen in der Liste vorhanden, werden weitere
     Indizes durch anhÃ¤ngen einer Nummer gebildet.

     `niceindices' wertet sein Argument aus.

     Beispiele:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Optionsvariable: niceindicespref
     Standardwert: `[i, j, k, l, m, n]'

     `niceindicespref' ist die Liste der Namen, die die Funktion
     `niceindices'  nutzt, um die Indizes von Summen und Produkte
     umzubennen.

     Beispiele:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Funktion: nusum (<expr>, <i>, <i_0>, <i_1>)
     Wendet den Gosper-Algorithmus der unbestimmten Summation fÃ¼r den
     Ausdruck <expr> und dem Index <i> an. Der Index <i> lÃ¤uft von <i_0>
     bis <i_1>. Der Ausdruck <expr> und das Ergebnis der Summation
     mÃ¼ssen als Produkte von ganzzahligen Exponentiationen, FakultÃ¤ten,
     Binomialen und rationalen Funktionen ausdrÃ¼ckbar sein.

     `nusum' und `unsum' kennen einige fÃ¼r Summen und Differenzen von
     endlichen Produkten. Siehe auch `unsum'.

     Beispiele:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Funktion: product (<expr>, <i>, <i_0>, <i_1>)
     Bildet das Produkt des Ausdrucks <expr> zum Index <i> in den
     Grenzen <i_0> bis <i_1>. Die Substantivform `'product' wird mit
     einem groÃgeschriebenen Buchstaben Pi dargestellt.

     `product' wertet <expr> sowie die untere <i_0> und obere Grenze
     <i_1> aus. Der Index <i> wird nicht ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> fÃ¼r jeden Wert des Index <i> ausgewertet. Das Ergebnis
     ist ein explizites Produkt.

     Andernfalls ist der Bereich des Index unbestimmt. Maxima wendet
     einige einfache Regeln an, um das Produkt zu vereinfachen. Hat die
     Optionsvariable `simpproduct'  den Wert `true', wendet Maxima
     weitere Regeln an, um Produkte zu vereinfachen.

     Siehe auch `nouns'  und `evflag'.

     Beispiele:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Optionsvariable: simpproduct
     Standardwert: `false'

     Hat `simpproduct' den Wert `true', versucht Maxima ein Produkt
     weiter zu vereinfachen. Die Vereinfachung kann eine geschlossene
     Form liefern. Hat `simpproduct' den Wert `false' oder wird das
     Produkt in der Substantivform `'product' definiert, werden nur
     einige einfache Regeln von Maxima fÃ¼r die Vereinfachung angewendet.


 -- Optionsvariable: simpsum
     Standardwert: `false'

     Hat `simpsum' den Wert `true', versucht Maxima eine Summe oder
     Reihe weiter zu vereinfachen. Die Vereinfachung kann eine
     geschlossene Form liefern.  Hat `simpsum' den Wert `false' oder
     die Summe oder Reihe in der Substantivform `'sum' definiert,
     werden nur einige einfache Regeln von Maxima fÃ¼r die Vereinfachung
     angewendet.


 -- Funktion: sum (<expr>, <i>, <i_0>, <i_1>)
     Bildet die Summe des Ausdrucks <expr> zum Index <i> in den Grenzen
     <i_0> bis <i_1>. Die Substantivform `'sum' wird mit einem
     groÃgeschriebenen Buchstaben Sigma dargestellt.

     `sum' wertet <expr> sowie die untere <i_0> und obere Grenze <i_1>
     aus. Der Index <i> wird nicht ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> fÃ¼r jeden Wert des Index <i> ausgewertet. Das Ergebnis
     ist eine explizite Summe.

     Andernfalls ist der Bereich des Index unbestimmt. Maxima wendet
     einige einfache Regeln an, um die Summe zu vereinfachen. Hat die
     Optionsvariable `simpsum'  den Wert `true', wendet Maxima weitere
     Regeln an, um Summen zu vereinfachen.

     Werden zwei unendliche Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum' haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Die Optionsvariable `genindex'  enthÃ¤lt das Zeichen, das der PrÃ¤fix
     eines automatisch generierten Index ist.

     `gensumnum' enthÃ¤lt eine ganze Zahl, die an den PrÃ¤fix `genindex'
     angehÃ¤ngt wird, um einen automatischen Index zu generieren.
     `gensumnum' wird von Maxima automatisch erhÃ¶ht. Hat `gensumnum'
     den Wert `false', wird keine Zahl an den PrÃ¤fix angehÃ¤ngt.

     Siehe auch `sumcontract',   `sumexpand',  `intosum',
     `bashindices',  `niceindices',  `nouns',   `evflag',  `cauchysum'
     und `zeilberger'.

     Beispiele:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Funktion: sumcontract (<expr>)
     Combines all sums of an addition that have upper and lower bounds
     that differ by constants. The result is an expression containing
     one summation for each set of such summations added to all
     appropriate extra terms that had to be extracted to form this sum.
     `sumcontract' combines all compatible sums and uses one of the
     indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.

     It may be necessary to do an `intosum (<expr>)' before the
     `sumcontract'.


 -- Optionsvariable: sumexpand
     Standardwert: `false'

     Hat die Optionsvariable `sumexpand' den Wert `true', werden
     Produkte von Summen und Potenzen von Summen zu verschachtelten
     Summen vereinfacht. Siehe auch `cauchysum'.

     Beispiele:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Funktion: unsum (<f>, <n>)
     Returns the first backward difference `<f>(<n>) - <f>(<n> - 1)'.
     Thus `unsum' in a sense is the inverse of `sum'. See also `nusum'.

     Beispiele:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)



File: maxima.info,  Node: EinfÃ¼hrung in Reihen,  Next: Funktionen und Variablen fÃ¼r Reihen,  Prev: Summen und Produkte,  Up: Summen Produkte und Reihen

15.2 EinfÃ¼hrung in Reihen
==========================

Maxima hat die Funktionen `taylor' und `powerseries', um die
Reihenentwicklung von differenzierbaren Funktionen zu finden. Maxima hat
weiterhin Funktionen wie `nusum', um geschlossene Formen von Reihen zu
finden. Operationen wie die Addition und Multiplikation arbeiten wie
gewohnt fÃ¼r Reihen. Das folgende Kapitel stellt die Variablen und
Funktionen fÃ¼r eine Reihenentwicklung dar.


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Reihen,  Next: Poisson Reihen,  Prev: EinfÃ¼hrung in Reihen,  Up: Summen Produkte und Reihen

15.3 Funktionen und Variablen fÃ¼r Reihen
=========================================

 -- Funktion: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     FÃ¼r eine Funktion <f_i> einer Variablen <x_i> definiert
     `deftaylor' den Ausdruck <expr_i> als die Taylorreihe um den
     Nullpunkt.  <expr_i> ist typischerweise ein Polynom in der
     Variable <x_i> oder eine Summe. `deftaylor' aktzeptiert aber auch
     allgemeinere AusdrÃ¼cke.

     `powerseries(<f_i>(<x_i>), <x_i>, 0)' gibt die Reihe zurÃ¼ck, die
     mit `deftaylor' definiert wurde.

     `deftaylor' gibt eine Liste der Funktionen <f_1>, ..., <f_n>.
     `deftaylor' wertet seine Argumente aus.

     Beispiele:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Option variable: maxtayorder
     Default value: `true'

     When `maxtayorder' is `true', then during algebraic manipulation of
     (truncated) Taylor series, `taylor' tries to retain as many terms
     as are known to be correct.


 -- Function: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)
     Returns a list of all rational functions which have the given
     Taylor series expansion where the sum of the degrees of the
     numerator and the denominator is less than or equal to the
     truncation level of the power series, i.e. are "best"
     approximants, and which additionally satisfy the specified degree
     bounds.

     <taylor_series> is a univariate Taylor series. <numer_deg_bound>
     and <denom_deg_bound> are positive integers specifying degree
     bounds on the numerator and denominator.

     <taylor_series> can also be a Laurent series, and the degree
     bounds can be `inf' which causes all rational functions whose
     total degree is less than or equal to the length of the power
     series to be returned.  Total degree is defined as
     `<numer_deg_bound> + <denom_deg_bound>'. Length of a power series
     is defined as `"truncation level" + 1 - min(0, "order of series")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     There is no rational function of degree 4 numerator/denominator,
     with this power series expansion.  You must in general have degree
     of the numerator and degree of the denominator adding up to at
     least the degree of the power series, in order to have enough
     unknown coefficients to solve.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Option variable: powerdisp
     Default value: `false'

     When `powerdisp' is `true', a sum is displayed with its terms in
     order of increasing power. Thus a polynomial is displayed as a
     truncated power series, with the constant term first and the
     highest power last.

     By default, terms of a sum are displayed in order of decreasing
     power.


 -- Function: powerseries (<expr>, <x>, <a>)
     Returns the general form of the power series expansion for <expr>
     in the variable <x> about the point <a> (which may be `inf' for
     infinity):
                     inf
                     ====
                     \               n
                      >    b  (x - a)
                     /      n
                     ====
                     n = 0

     If `powerseries' is unable to expand <expr>, `taylor' may give the
     first several terms of the series.

     When `verbose' is `true', `powerseries' prints progress messages.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Option variable: psexpand
     Default value: `false'

     When `psexpand' is `true', an extended rational function
     expression is displayed fully expanded.  The switch `ratexpand'
     has the same effect.

     When `psexpand' is `false', a multivariate expression is displayed
     just as in the rational function package.

     When `psexpand' is  `multi', then terms with the same total degree
     in the variables are grouped together.


 -- Function: revert (<expr>, <x>)
 -- Function: revert2 (<expr>, <x>, <n>)
     These functions return the reversion of <expr>, a Taylor series
     about zero in the variable <x>. `revert' returns a polynomial of
     degree equal to the highest power in <expr>. `revert2' returns a
     polynomial of degree <n>, which may be greater than, equal to, or
     less than the degree of <expr>.

     `load ("revert")' loads these functions.

     Examples:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Function: taylor (<expr>, <x>, <a>, <n>)
 -- Function: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Function: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Function: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Function: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     `taylor (<expr>, <x>, <a>, <n>)' expands the expression <expr> in
     a truncated Taylor or Laurent series in the variable <x> around
     the point <a>, containing terms through `(<x> - <a>)^<n>'.

     If <expr> is of the form `<f>(<x>)/<g>(<x>)' and `<g>(<x>)' has no
     terms up to degree <n> then `taylor' attempts to expand `<g>(<x>)'
     up to degree `2 <n>'. If there are still no nonzero terms,
     `taylor' doubles the degree of the expansion of `<g>(<x>)' so long
     as the degree of the expansion is less than or equal to `<n>
     2^taylordepth'.

     `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' returns a
     truncated power series of degree <n> in all variables <x_1>,
     <x_2>, ... about the point `(<a>, <a>, ...)'.

     `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)' returns a truncated power series in the variables <x_1>,
     <x_2>, ... about the point `(<a_1>, <a_2>, ...)', truncated at
     <n_1>, <n_2>, ....

     `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' returns a truncated power series in the variables
     <x_1>, <x_2>, ... about the point `(<a_1>, <a_2>, ...)', truncated
     at <n_1>, <n_2>, ....

     `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' returns an expansion of
     <expr> in negative powers of `<x> - <a>'. The highest order term
     is `(<x> - <a>)^<-n>'.

     When `maxtayorder' is `true', then during algebraic manipulation of
     (truncated) Taylor series, `taylor' tries to retain as many terms
     as are known to be correct.

     When `psexpand' is `true', an extended rational function expression
     is displayed fully expanded. The switch `ratexpand' has the same
     effect.  When `psexpand' is `false', a multivariate expression is
     displayed just as in the rational function package. When
     `psexpand' is  `multi', then terms with the same total degree in
     the variables are grouped together.

     See also the `taylor_logexpand' switch for controlling expansion.

     Examples:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Option variable: taylordepth
     Default value: 3

     If there are still no nonzero terms, `taylor' doubles the degree
     of the expansion of `<g>(<x>)' so long as the degree of the
     expansion is less than or equal to `<n> 2^taylordepth'.


 -- Function: taylorinfo (<expr>)
     Returns information about the Taylor series <expr>. The return
     value is a list of lists. Each list comprises the name of a
     variable, the point of expansion, and the degree of the expansion.

     `taylorinfo' returns `false' if <expr> is not a Taylor series.

     Example:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Function: taylorp (<expr>)
     Returns `true' if <expr> is a Taylor series, and `false' otherwise.


 -- Option variable: taylor_logexpand
     Default value: `true'

     `taylor_logexpand' controls expansions of logarithms in `taylor'
     series.

     When `taylor_logexpand' is `true', all logarithms are expanded
     fully so that zero-recognition problems involving logarithmic
     identities do not disturb the expansion process.  However, this
     scheme is not always mathematically correct since it ignores
     branch information.

     When `taylor_logexpand' is set to `false', then the only expansion
     of logarithms that occur is that necessary to obtain a formal
     power series.


 -- Option variable: taylor_order_coefficients
     Default value: `true'

     `taylor_order_coefficients' controls the ordering of coefficients
     in a Taylor series.

     When `taylor_order_coefficients' is `true', coefficients of taylor
     series are ordered canonically.


 -- Function: taylor_simplifier (<expr>)
     Simplifies coefficients of the power series <expr>. `taylor' calls
     this function.


 -- Option variable: taylor_truncate_polynomials
     Default value: `true'

     When `taylor_truncate_polynomials' is `true', polynomials are
     truncated based upon the input truncation levels.

     Otherwise, polynomials input to `taylor' are considered to have
     infinite precison.


 -- Function: taytorat (<expr>)
     Converts <expr> from `taylor' form to canonical rational expression
     (CRE) form. The effect is the same as `rat (ratdisrep (<expr>))',
     but faster.


 -- Function: trunc (<expr>)
     Annotates the internal representation of the general expression
     <expr> so that it is displayed as if its sums were truncated
     Taylor series.  <expr> is not otherwise modified.

     Example:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Option variable: verbose
     Default value: `false'

     When `verbose' is `true', `powerseries' prints progress messages.



File: maxima.info,  Node: Poisson Reihen,  Next: KettenbrÃ¼che,  Prev: Funktionen und Variablen fÃ¼r Reihen,  Up: Summen Produkte und Reihen

15.4 Poisson Reihen
===================

 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.


 -- Function: outofpois (<a>)
     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, `outofpois' carries out the
     conversion, i.e., the return value is `outofpois (intopois
     (<a>))'. This function is thus a canonical simplifier for sums of
     powers of sine and cosine terms of a particular type.


 -- Function: poisdiff (<a>, <b>)
     Differentiates <a> with respect to <b>. <b> must occur only in the
     trig arguments or only in the coefficients.


 -- Function: poisexpt (<a>, <b>)
     Functionally identical to `intopois (<a>^<b>)'. <b> must be a
     positive integer.


 -- Function: poisint (<a>, <b>)
     Integrates in a similarly restricted sense (to `poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.


 -- Option variable: poislim
     Default value: 5

     `poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].


 -- Function: poismap (<series>, <sinfn>, <cosfn>)
     will map the functions <sinfn> on the sine terms and <cosfn> on the
     cosine terms of the Poisson series given. <sinfn> and <cosfn> are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.


 -- Function: poisplus (<a>, <b>)
     Is functionally identical to `intopois (a + b)'.


 -- Function: poissimp (<a>)
     Converts <a> into a Poisson series for <a> in general
     representation.


 -- Special symbol: poisson
     The symbol `/P/' follows the line label of Poisson series
     expressions.


 -- Function: poissubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., `6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands `cos(<d>)' and
     `sin(<d>)' to order <n> so as to provide the result of substituting
     `<a> + <d>' for <b> in <c>.  The idea is that <d> is an expansion
     in terms of a small parameter.  For example, `poissubst (u, v,
     cos(v), %e, 3)' yields `cos(u)*(1 - %e^2/2) - sin(u)*(%e -
     %e^3/6)'.


 -- Function: poistimes (<a>, <b>)
     Is functionally identical to `intopois (<a>*<b>)'.


 -- Function: poistrim ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the <u>,
     <v>, ..., <z> in a term.  Terms for which `poistrim' is `true'
     (for the coefficients of that term) are eliminated during
     multiplication.


 -- Function: printpois (<a>)
     Prints a Poisson series in a readable format.  In common with
     `outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.



File: maxima.info,  Node: KettenbrÃ¼che,  Prev: Poisson Reihen,  Up: Summen Produkte und Reihen

15.5 KettenbrÃ¼che
==================

 -- Function: cf (<expr>)
     Converts <expr> into a continued fraction. <expr> is an expression
     comprising continued fractions and square roots of integers.
     Operands in the expression may be combined with arithmetic
     operators. Aside from continued fractions and square roots,
     factors in the expression must be integer or rational numbers.
     Maxima does not know about operations on continued fractions
     outside of `cf'.

     `cf' evaluates its arguments after binding `listarith' to `false'.
     `cf' returns a continued fraction, represented as a list.

     A continued fraction `a + 1/(b + 1/(c + ...))' is represented by
     the list `[a, b, c, ...]'. The list elements `a', `b', `c', ...
     must evaluate to integers. <expr> may also contain `sqrt (n)'
     where `n' is an integer. In this case `cf' will give as many terms
     of the continued fraction as the value of the variable `cflength'
     times the period.

     A continued fraction can be evaluated to a number by evaluating
     the arithmetic representation returned by `cfdisrep'. See also
     `cfexpand' for another way to evaluate a continued fraction.

     See also `cfdisrep', `cfexpand', and `cflength'.

     Examples:

        * <expr> is an expression comprising continued fractions and
          square roots of integers.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controls how many periods of the continued fraction
          are computed for algebraic, irrational numbers.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * A continued fraction can be evaluated by evaluating the
          arithmetic representation returned by `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima does not know about operations on continued fractions
          outside of `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]



 -- Function: cfdisrep (<list>)
     Constructs and returns an ordinary arithmetic expression of the
     form `a + 1/(b + 1/(c + ...))' from the list representation of a
     continued fraction `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Function: cfexpand (<x>)
     Returns a matrix of the numerators and denominators of the last
     (column 1) and next-to-last (column 2) convergents of the
     continued fraction <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Option variable: cflength
     Default value: 1

     `cflength' controls the number of terms of the continued fraction
     the function `cf' will give, as the value `cflength' times the
     period.  Thus the default is to give one period.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]



File: maxima.info,  Node: Analysis,  Next: Polynome,  Prev: Summen Produkte und Reihen,  Up: Top

16 Analysis
***********

* Menu:

* Funktionen und Variablen fÃ¼r Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Grenzwerte,  Next: Funktionen und Variablen der Differentiation,  Prev: Analysis,  Up: Analysis

16.1 Funktionen und Variablen fÃ¼r Grenzwerte
=============================================

 -- Optionsvariable: lhospitallim
     Standardwert: 4

     `lhospitallim' enthÃ¤lt die maximale Zahl an Iterationen fÃ¼r die die
     L'Hospitalsche Regel von der Funktion `limit' angewendet wird.
     Damit wird verhindert, dass `limit' in eine unendliche Schleife
     fÃ¼r Grenzwerte wie `limit(cot(x)/csc(x), x, 0)' gerÃ¤t.


 -- Funktion: limit (<expr>, <x>, <val>, <dir>)
 -- Funktion: limit (<expr>, <x>, <val>)
 -- Funktion: limit (<expr>)
     Berechnet den Grenzwert des Ausdrucks <expr>, wenn die reelle
     Variable <x> gegen den Wert <val> in Richtung <dir> geht. Die
     Richtung <dir> kann die Werte <plus> fÃ¼r einen Grenzwert von oben
     und <minus> fÃ¼r einen Grenzwert von unten haben. FÃ¼r einen
     zweiseitigen Grenzwert braucht die Richtung nicht angegeben werden.

     `limit' nutzt die folgenden speziellen Symbole: `inf' (positiv
     unendlich) und `minf' (negativ unendlich). In der Ausgabe kÃ¶nnen
     die Symbole `und' (nicht definiert), `ind' (unbestimmt) und
     `infinity' (komplex unendlich) auftreten.

     `infinity' (komplex unendlich) wird zurÃ¼ckgegeben, wenn der
     Grenzwert des Betrags des Ausdrucks positiv unendlich ist, aber
     der Grenzwert des Ausdrucks selbst weder positive noch negativ
     unendlich ist. Dies schlieÃt FÃ¤lle ein, wo der Grenzwert eines
     komplexen Arguments eine Konstante ist, wie zum Beispiel in
     `limit(log(x),x, minf)', FÃ¤lle in denen das komplexe Argument
     oszilliert, wie zum Beispiel in `limit((-2)^x, x, inf)' und FÃ¤lle,
     wo das komlexe Argument fÃ¼r die beiden Seiten des Grenzwertes
     verschieden ist, wie zum Beispiel in `limit(1/x, x, 0)' und
     `limit(log(x), x, 0)'.

     `lhospitallim' enthÃ¤lt die maximale Zahl an Iterationen fÃ¼r die die
     L'Hospitalsche Regel von der Funktion `limit' angewendet wird.
     Damit wird verhindert, dass `limit' in eine unendliche Schleife
     fÃ¼r Grenzwerte wie `limit(cot(x)/csc(x), x, 0)' gerÃ¤t.

     Hat `tlimswitch' den Wert `true', nutzt die Funktion `limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.

     Die Optionsvariable `limsubst' verhindet Substitution der Funktion
     `limit' fÃ¼r unbekannte AusdrÃ¼cke. Dies vermeidet Fehler wie zum
     Beispiel ein Ergebnis von 1 fÃ¼r den Grenzwert `limit (f(n)/f(n+1),
     n, inf)'. ErhÃ¤lt `limsubst' den Wert `true', sind solche
     Substitution gestattet.

     `limit' kann mit einem Argument aufgerufen werden, um konstante
     AusdrÃ¼cke zu vereinfachen. Zum Beispiel `limit (inf-1)'.

     Das Kommando `example(limit)' zeigt einige Beispiele.

     Der Algorithmus ist in der folgenden Arbeit beschrieben: Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.


 -- Optionsvariable: limsubst
     Standardwert: `false'

     Die Optionsvariable `limsubst' verhindet Substitution der Funktion
     `limit' fÃ¼r unbekannte AusdrÃ¼cke. Dies vermeidet Fehler wie zum
     Beispiel ein Ergebnis von 1 fÃ¼r den Grenzwert `limit (f(n)/f(n+1),
     n, inf)'. ErhÃ¤lt `limsubst' den Wert `true', sind solche
     Substitution gestattet.


 -- Funktion: tlimit (<expr>, <x>, <val>, <dir>)
 -- Funktion: tlimit (<expr>, <x>, <val>)
 -- Funktion: tlimit (<expr>)
     Nimmt den Grenzwert der Taylor-Reihenwicklung des Ausdrucks
     `expr', wenn die Variable <x> gegen den Wert `val' aus der
     Richtung <dir> geht.


 -- Optionsvariable: tlimswitch
     Standardwert: `true'

     Hat `tlimswitch' den Wert `true', nutzt die Funktion `limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann. Dies erlaubt die Bestimmung von
     Grenzwerten wie `limit(x/(x-1)-1/log(x),x,1,plus)'.



File: maxima.info,  Node: Funktionen und Variablen der Differentiation,  Next: Integration,  Prev: Funktionen und Variablen fÃ¼r Grenzwerte,  Up: Analysis

16.2 Funktionen und Variablen der Differentiation
=================================================

 -- Funktion: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Funktion: at (<expr>, <eqn>)
     Wertet den Ausdruck <expr> aus, wobei dessen Variablen die Werte
     annehmen, die in der Liste der Gleichungen `[<eqn_1>, ...,
     <eqn_n>]' oder in der einzelnen Gleichung <eqn> angegeben sind.

     Wenn ein Teilausdruck von einer Variablen abhÃ¤ngt, fÃ¼r die ein Wert
     angegeben ist, aber kein `atvalue', und er auch sonst nicht
     ausgewertet werden kann, dann wird von `at' eine Substantivform
     zurÃ¼ckgegeben, dargestellt in einer zweidimensionalen Form.

     `at' fÃ¼hrt mehrfache Ersetzungen nacheinander und nicht nicht
     parallel durch.

     Siehe auch `atvalue'. FÃ¼r andere Funktionen, die Ersetzungen
     durchfÃ¼hren, siehe weiterhin `subst' und `ev'.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Funktion: antid (<expr>, <x>, <u(x)>)
     Gibt eine Liste mit zwei Elementen zurÃ¼ck aus denen die
     Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     konstruiert werden kann. Der Ausdruck <expr> kann eine unbekannte
     Funktion <u> und deren Ableitungen enthalten.

     Ist <L> das Ergebnis der Funktion `antid', dann ist der Ausdruck
     `<L>[1]+ 'integrate(<L>[2], <x>)' der gesuchte Stammfunktion des
     Ausdrucks <expr> mit der Variablen <x>.

     Kann `antid' die Stammfunktion vollstÃ¤ndig bestimmen, ist das
     zweite Element der Liste Null. Hat `antid' keinerlei Erfolg, ist
     das erste Element der Liste Null. In anderen FÃ¤llen enthÃ¤lt das
     erste Elemente den integrierbaren Anteil des Ausdrucks <expr> und
     das zweite Element den nicht integrierbaren Anteil des Ausdrucks.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antid' steht in folgender Beziehung zur Funktion `antidiff': Ist
     <L> die Liste mit den Ergebnissen der Funktion `antid', dann hat
     die Funktion `antidiff' das Ergebnis `<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     Beispiele:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Funktion: antidiff (<expr>, <x>, <u>(<x>))
     Gibt die Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     zurÃ¼ck. Der Ausdruck <expr> kann eine unbekannte Funktion <u> und
     deren Ableitungen enthalten.

     Kann `antidiff' die Stammfunktion nicht oder nur teilweise
     bestimmen, enthÃ¤lt das Ergebnis das Integral des nicht
     bestimmbaren Anteils.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antidiff' steht in folgender Beziehung zur Funktion `antid': Ist
     <L> die Liste mit den Ergebnissen der Funktion `antid', dann hat
     die Funktion `antidiff' das Ergebnis `<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     FÃ¼r Beispiele und weitere AusfÃ¼hrungen siehe die Funktion `antid'.


 -- Eigenschaft: atomgrad
     Wird fÃ¼r ein Symbol eine Ableitung mit der Funktion `gradef'
     definiert, dann erhÃ¤lt das Symbol die Eigenschaft `atomgrad'.


 -- Funktion: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Funktion: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Dem Ausdruck <expr> wird der Wert <c> am Punkt `<x> = <a>'
     zugewiesen. Typischerweise werden Randwerte mit der Funktion
     `atvalue' definiert.

     Der Ausdruck <expr> ist entweder eine Funktion `<f>(<x_1>, ...,
     <x_m>)' oder die Ableitung einer Funktion `diff(<f>(<x_1>, ...,
     <x_m>), <x_1>, <n_1>, ..., <x_n>, <n_m>)'. Die Argumente mÃ¼ssen
     explizit auftreten. <n_i> ist die Ordnung der Ableitung bezÃ¼glich
     der Variablen <x_i>.

     Die Randwerte werden durch die Liste `[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]' definiert. Eine einzelne Gleichung muss nicht als Liste
     angegeben werden.

     `printprops([<f_1>, <f_2>, ...], atvalue)' zeigt die Randwerte der
     Funktionen `<f_1>, <f_2>, ...' wie sie mit der Funktion `atvalue'
     definiert wurden. `printprops (<f>, atvalue)' zeigt nur die
     Randwerte fÃ¼r die Funktion <f>. `printprops (all, atvalue)' zeigt
     die Randwerte aller Funktionen.

     Die Symbole `@1', `@2', ... reprÃ¤sentieren die Variablen <x_1>,
     <x_2>, ..., wenn die Randwerte angezeigt werden.

     `atvalue' wertet die Argumente aus. `atvalue' gibt den Randwert
     <c> zurÃ¼ck.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Packet: cartan
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations. The
     `cartan' package implements the functions `ext_diff' and
     `lie_diff', along with the operators `~' (wedge product) and `|'
     (contraction of a form with a vector.)  Type `demo (tensor)' to
     see a brief description of these commands along with examples.

     `cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.


 -- Funktion: del (<x>)
     `del(<x>)' reprÃ¤sentiert das Differential der Variablen <x>.

     `diff' gibt AusdrÃ¼cke zurÃ¼ck, die Differentiale enthalten, wenn
     keine Variablen angegeben sind, nach denen abgeleitet werden soll.
     In diesem Fall gibt `diff' das totale Differential zurÃ¼ck.

     Beispiele:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Funktion: delta (<t>)
     Die Diracsche Delta-Funktion.

     Maxima kennt die Delta-Funktion nur im Zusammenhang mit
     Laplace-Transformationen. Siehe `laplace'.

     Beispiel:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Systemvariable: dependencies
     Standardwert: `[]'

     `dependencies' ist eine Liste der Symbole, fÃ¼r die eine
     AbhÃ¤ngigkeit mit den Funktionen `depends' oder `gradef' definiert
     wurde. Siehe `depends'  und `gradef'.


 -- Funktion: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Definiert die AbhÃ¤ngigkeit einer Funktion <f> von einer Variablen
     <x>.  Ist keine AbhÃ¤ngigkeit definiert, dann hat die Ableitung
     `diff(f, x)' das Ergebnis Null. Wird mit dem Kommando `depends(f,
     x)' definiert, dass die Funktion <f> von der Variablen <x>
     abhÃ¤ngt, dann ist das Ergebnis der Ableitung die Substantivform
     `'diff(f,x,1)'.

     Jedes Argument <f_1>, <x_1>, ... kann der Name einer Variablen,
     eines Arrays oder eine Liste mit Namen sein. Jedes Symbol <f_i>
     hÃ¤ngt ab von den Symbolen der Liste <x_i>. Ist eines der Symbole
     <f_i> der Name eines Arrays, dann hÃ¤ngen alle Elemente des Arrays
     von <x_i> ab.

     `diff' erkennt indirekte AbhÃ¤ngigkeiten und wendet fÃ¼r diesen Fall
     die Kettenregel an.

     `remove(<f>, dependency)' entfernt alle AbhÃ¤ngigkeiten, die fÃ¼r
     <f> definiert wurden.

     `depends' gibt eine Liste der AbhÃ¤ngigkeiten zurÃ¼ck. Die
     AbhÃ¤ngigkeiten werden in die Informationsliste `dependencies'
     eingetragen. `depends' wertet die Argumente aus.

     Die Funktion `diff' ist die einzige Maxima-Funktion, die
     AbhÃ¤ngigkeiten erkennt, die mit `depends' definiert wurden. Andere
     Funktionen wie `integrate' oder `laplace' erkennen eine
     AbhÃ¤ngigkeiten die mit der `depends' definiert wurden. FÃ¼r diese
     Funktionen mÃ¼ssen die AbhÃ¤ngigkeiten explizit angegeben werden,
     zum Beispiel `integrate(f(x), x)'.

     Beispiele:

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Optionsvariable: derivabbrev
     Standardwert: `false'

     Hat `derivabbrev' den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt. Ansonsten werden
     Ableitungen als `dy/dy' angezeigt.


 -- Funktion: derivdegree (<expr>, <y>, <x>)
     Gibt die hÃ¶chste Ableitung des Arguments <y> in Bezug auf die
     Variable <x> zurÃ¼ck, die in dem Ausdruck <expr> enthalten ist.

     Beispiel:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Auswertungsschalter: derivlist (<var_1>, ..., <var_k>)
     `derivlist' ist ein Auswertungsschalter fÃ¼r die Funktion `ev'.
     `ev' fÃ¼hrt nur die Ableitungen in Bezug auf die angegebenen
     Variablen <var_1>, ..., <var_k> aus.


 -- Optionsvariable: derivsubst
     Standardwert: `false'

     Hat `derivsubst' den Wert `true', werden Substitutionen auch in
     AusdrÃ¼cke mit Ableitungen ausgefÃ¼hrt. Zum Beispiel hat dann
     `subst(x, 'diff(y, t), 'diff(y, t, 2))' das Ergebnis `'diff(x, t)'.


 -- Funktion: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Funktion: diff (<expr>, <x>, <n>)
 -- Funktion: diff (<expr>, <x>)
 -- Funktion: diff (<expr>)
     Gibt die Ableitungen oder Differentiale des Ausdrucks <expr> in
     Bezug auf alle oder einige der Variablen des Ausdrucks zurÃ¼ck.

     `diff(<expr>, <x>, <n>)' gibt die n-te Ableitung des Ausdrucks
     <expr> in Bezug auf die Variable <x> zurÃ¼ck.

     `diff(<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' gibt die partielle
     Ableitung des Ausdrucks <expr> in Bezug auf die Variablen <x_1>,
     ..., <x_m> zurÃ¼ck. Dies ist Ã¤quivalent zu `diff(...  (diff(<expr>,
     <x_m>, <n_m>) ...), <x_1>, <n_1>)'.

     `diff(<expr>, <x>)' gibt die erste Ableitung des Ausdrucks <expr>
     in Bezug auf die Variable <x> zurÃ¼ck.

     `diff(<expr>)' gibt das totale Differential des Ausdrucks <expr>
     zurÃ¼ck. Siehe auch `del'.

     Wenn die Ableitungen nicht ausgefÃ¼hrt werden sollen, kann der
     Quote-Operator verwendet werden, um eine Substantivform der
     Ableitung zu erhalten.

     Hat `derivabbrev' den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt. Ansonsten werden
     Ableitungen als `dy/dy' angezeigt.

     Beispiele:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

       1. The derivatives of any indexed objects in <expr> will have the
          variables <x_i> appended as additional arguments.  Then all
          the derivative indices will be sorted.

       2. The <x_i> may be integers from 1 up to the value of the
          variable `dimension' [default value: 4].  This will cause the
          differentiation to be carried out with respect to the
          <x_i>'th member of the list `coordinates' which should be set
          to a list of the names of the coordinates, e.g., `[x, y, z,
          t]'. If `coordinates' is bound to an atomic variable, then
          that variable subscripted by <x_i> will be used for the
          variable of differentiation.  This permits an array of
          coordinate names or subscripted names like `X[1]', `X[2]',
          ... to be used.  If `coordinates' has not been assigned a
          value, then the variables will be treated as in (1) above.


 -- Auswertungsschalter: diff
     `diff' ist ein Auswertungsschalter fÃ¼r die Funktion `ev'. Das
     Kommando `ev(expr), diff' bewirkt, dass alle Ableitungen ausgefÃ¼hrt
     werden, die im Ausdruck <expr> enhalten sind. Siehe auch die
     Funktion `ev'.


 -- Funktion: dscalar (<f>)
     Wendet den d'Alembert-Operator auf eine skalare Funktion <f> an.
     Der d'Alembert-Operator ist die Verallgemeinerung des Gradienten
     auf den vierdimensionalen Minkowski-Raum.

     Das Kommando `load(ctensor)' lÃ¤dt die Funktion.


 -- Funktion: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Funktion: gradef (<a>, <x>, <expr>)
     Definiert eine partielle Ableitung der Funktion <f> oder Variablen
     <a>.

     `gradef(<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' definiert die
     partielle Ableitung `d<f>/d<x_i>' als <g_i>.  <g_i> ist ein
     Ausdruck. <g_i> kann ein Funktionsaufruf sein, aber nicht der Name
     einer Funktion. Die Anzahl der partiellen Ableitungen <m> kann
     kleiner sein als die Anzahl der Argumente <n>.

     `gradef(<a>, <x>, <expr>)' definierte die Ableitung der Variablen
     <a> in Bezug auf die Variable <x> als <expr>. Wie mit der Funktion
     `depends' wird <a> als abhÃ¤ngig von <x> deklariert. Die
     AbhÃ¤ngigkeit wird in die Liste `dependencies' eingetragen. Siehe
     auch `depends'.

     Bis auf erste Argument werden die Argumente der Funktion `gradef'
     ausgewertet. `gradef' gibt die Funktion oder Variable zurÃ¼ck, fÃ¼r
     die eine partielle Ableitung definiert wurde.

     `gradef' kann die Ableitungen von vorhandenen Maxima-Funktionen neu
     definieren. Zum Beispiel definiert `gradef(sin(x), sqrt (1 -
     sin(x)^2))' eine neue Ableitung der Sinusfunktion.

     `gradef' kann keine partiellen Ableitungen fÃ¼r indizierte
     Funktionen definieren.

     `printprops([<f_1>, ..., <f_n>], gradef)' zeigt die mit `gradef'
     definierten partiellen Ableitungen der Funktionen <f_1>, ...,
     <f_n> an.

     `printprops([<a_n>, ..., <a_n>], atomgrad)' zeigt die mit `gradef'
     definierten partiellen Ableitungen der Variablen <a_n>, ..., <a_n>
     an.

     `gradefs' ist eine Informationsliste, die die Funktionen enthÃ¤lt,
     fÃ¼r die mit `gradef' eine Ableitung definierte wurde. Die Liste
     enthÃ¤lt keine Variablen, fÃ¼r die Ableitungen definiert wurden.


 -- Systemvariable: gradefs
     Standardwert: `[]'

     `gradefs' ist eine Liste der Funktionen, fÃ¼r die eine Ableitung
     definiert wurde.




Local Variables:
coding: utf-8
End:
