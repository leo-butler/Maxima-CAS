This is maxima.info, produced by makeinfo version 4.13 from
/home/work/maxima/sandbox/maxima/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Programmierung,  Next: Fehlersuche,  Prev: Funktionsdefinitionen,  Up: Top

26 Programmierung
*****************

* Menu:

* Lisp und Maxima::
* Introduction to Program Flow::
* Functions and Variables for Program Flow::


File: maxima.info,  Node: Lisp und Maxima,  Next: Introduction to Program Flow,  Prev: Programmierung,  Up: Programmierung

26.1 Lisp und Maxima
====================

Maxima is written in Lisp, and it is easy to access Lisp functions and
variables from Maxima and vice versa.  Lisp and Maxima symbols are
distinguished by a naming convention.  A Lisp symbol which begins with
a dollar sign `$' corresponds to a Maxima symbol without the dollar
sign.  A Maxima symbol which begins with a question mark `?'
corresponds to a Lisp symbol without the question mark.  For example,
the Maxima symbol `foo' corresponds to the Lisp symbol `$foo', while
the Maxima symbol `?foo' corresponds to the Lisp symbol `foo', Note
that `?foo' is written without a space between `?' and `foo'; otherwise
it might be mistaken for `describe ("foo")'.

   Hyphen `-', asterisk `*', or other special characters in Lisp symbols
must be escaped by backslash `\' where they appear in Maxima code.  For
example, the Lisp identifier `*foo-bar*' is written `?\*foo\-bar\*' in
Maxima.

   Lisp code may be executed from within a Maxima session.  A single
line of Lisp (containing one or more forms) may be executed by the
special command `:lisp'. For example,

     (%i1) :lisp (foo $x $y)

calls the Lisp function `foo' with Maxima variables `x' and `y' as
arguments.  The `:lisp' construct can appear at the interactive prompt
or in a file processed by `batch' or `demo', but not in a file
processed by `load', `batchload', `translate_file', or `compile_file'.

   The function `to_lisp()' opens an interactive Lisp session.
Entering `(to-maxima)' closes the Lisp session and returns to Maxima.

   Lisp functions and variables which are to be visible in Maxima as
functions and variables with ordinary names (no special punctuation)
must have Lisp names beginning with the dollar sign `$'.

   Maxima is case-sensitive, distinguishing between lowercase and
uppercase letters in identifiers, while Lisp is not.  There are some
rules governing the translation of names between Lisp and Maxima.

  1. A Lisp identifier not enclosed in vertical bars corresponds to a
     Maxima identifier in lowercase.  Whether the Lisp identifier is
     uppercase, lowercase, or mixed case, is ignored.  E.g., Lisp
     `$foo', `$FOO', and `$Foo' all correspond to Maxima `foo'.

  2. A Lisp identifier which is all uppercase or all lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     case reversed.  That is, uppercase is changed to lowercase and
     lowercase to uppercase.  E.g., Lisp `|$FOO|' and `|$foo|'
     correspond to Maxima `foo' and `FOO', respectively.

  3. A Lisp identifier which is mixed uppercase and lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     the same case.  E.g., Lisp `|$Foo|' corresponds to Maxima `Foo'.

   The `#$' Lisp macro allows the use of Maxima expressions in Lisp
code.  `#$<expr>$' expands to a Lisp expression equivalent to the
Maxima expression <expr>.

     (msetq $foo #$[x, y]$)

This has the same effect as entering

     (%i1) foo: [x, y];

The Lisp function `displa' prints an expression in Maxima format.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Functions defined in Maxima are not ordinary Lisp functions.  The
Lisp function `mfuncall' calls a Maxima function.  For example:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Some Lisp functions are shadowed in the Maxima package, namely the
following.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', and `gcd'.


File: maxima.info,  Node: Introduction to Program Flow,  Next: Functions and Variables for Program Flow,  Prev: Lisp und Maxima,  Up: Programmierung

26.2 Introduction to Program Flow
=================================

Maxima provides a `do' loop for iteration, as well as more primitive
constructs such as `go'.


File: maxima.info,  Node: Functions and Variables for Program Flow,  Prev: Introduction to Program Flow,  Up: Programmierung

26.3 Functions and Variables for Program Flow
=============================================

 -- Function: backtrace ()
 -- Function: backtrace (<n>)
     Prints the call stack, that is, the list of functions which called
     the currently active function.

     `backtrace()' prints the entire call stack.

     `backtrace (<n>)' prints the <n> most recent functions, including
     the currently active function.

     `backtrace' can be called from a script, a function, or the
     interactive prompt (not only in a debugging context).

     Examples:

        * `backtrace()' prints the entire call stack.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * `backtrace (<n>)' prints the <n> most recent functions,
          including the currently active function.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49


 -- Special operator: do
     The `do' statement is used for performing iteration.  Due to its
     great generality the `do' statement will be described in two parts.
     First the usual form will be given which is analogous to that used
     in several other programming languages (Fortran, Algol, PL/I,
     etc.); then the other features will be mentioned.

     There are three variants of this form that differ only in their
     terminating conditions.  They are:

        * `for <variable>: <initial_value> step <increment>       thru
          <limit> do <body>'

        * `for <variable>: <initial_value> step <increment>       while
          <condition> do <body>'

        * `for <variable>: <initial_value> step <increment>
          unless <condition> do <body>'

     (Alternatively, the `step' may be given after the termination
     condition or limit.)

     <initial_value>, <increment>, <limit>, and <body> can be any
     expressions.  If the increment is 1 then "`step 1'" may be omitted.

     The execution of the `do' statement proceeds by first assigning
     the <initial_value> to the <variable> (henceforth called the
     control-variable). Then: (1) If the control-variable has exceeded
     the limit of a `thru' specification, or if the condition of the
     `unless' is `true', or if the condition of the `while' is `false'
     then the `do' terminates. (2) The <body> is evaluated.  (3) The
     increment is added to the control-variable.  The process from (1)
     to (3) is performed repeatedly until the termination condition is
     satisfied.  One may also give several termination conditions in
     which case the `do' terminates when any of them is satisfied.

     In general the `thru' test is satisfied when the control-variable
     is greater than the <limit> if the <increment> was non-negative,
     or when the control-variable is less than the <limit> if the
     <increment> was negative.  The <increment> and <limit> may be
     non-numeric expressions as long as this inequality can be
     determined.  However, unless the <increment> is syntactically
     negative (e.g. is a negative number) at the time the `do'
     statement is input, Maxima assumes it will be positive when the
     `do' is executed.  If it is not positive, then the `do' may not
     terminate properly.

     Note that the <limit>, <increment>, and termination condition are
     evaluated each time through the loop.  Thus if any of these involve
     much computation, and yield a result that does not change during
     all the executions of the <body>, then it is more efficient to set
     a variable to their value prior to the `do' and use this variable
     in the `do' form.

     The value normally returned by a `do' statement is the atom
     `done'.  However, the function `return' may be used inside the
     <body> to exit the `do' prematurely and give it any desired value.
     Note however that a `return' within a `do' that occurs in a
     `block' will exit only the `do' and not the `block'. Note also
     that the `go' function may not be used to exit from a `do' into a
     surrounding `block'.

     The control-variable is always local to the `do' and thus any
     variable may be used without affecting the value of a variable with
     the same name outside of the `do'.  The control-variable is unbound
     after the `do' terminates.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note that the condition `while i <= 10' is equivalent to `unless i
     > 10' and also `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     which gives 8 terms of the Taylor series for `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     This example computes the negative square root of 10 using the
     Newton- Raphson iteration a maximum of 10 times.  Had the
     convergence criterion not been met the value returned would have
     been `done'.

     Instead of always adding a quantity to the control-variable one
     may sometimes wish to change it in some other way for each
     iteration.  In this case one may use `next <expression>' instead
     of `step <increment>'.  This will cause the control-variable to be
     set to the result of evaluating <expression> each time through the
     loop.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     As an alternative to `for <variable>: <value> ...do...' the syntax
     `for <variable> from <value> ...do...'  may be used.  This permits
     the `from <value>' to be placed after the `step' or `next' value
     or after the termination condition.  If `from <value>' is omitted
     then 1 is used as the initial value.

     Sometimes one may be interested in performing an iteration where
     the control-variable is never actually used.  It is thus
     permissible to give only the termination conditions omitting the
     initialization and updating information as in the following
     example to compute the square-root of 5 using a poor initial guess.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     If it is desired one may even omit the termination conditions
     entirely and just give `do <body>' which will continue to evaluate
     the <body> indefinitely.  In this case the function `return'
     should be used to terminate execution of the `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note that `return', when executed, causes the current value of
     `x' to be returned as the value of the `do'.  The `block' is
     exited and this value of the `do' is returned as the value of the
     `block' because the `do' is the last statement in the block.)

     One other form of the `do' is available in Maxima.  The syntax is:

          for <variable> in <list> <end_tests> do <body>

     The elements of <list> are any expressions which will successively
     be assigned to the `variable' on each iteration of the <body>.
     The optional termination tests <end_tests> can be used to
     terminate execution of the `do'; otherwise it will terminate when
     the <list> is exhausted or when a `return' is executed in the
     <body>.  (In fact, `list' may be any non-atomic expression, and
     successive parts are taken.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Function: errcatch (<expr_1>, ..., <expr_n>)
     Evaluates <expr_1>, ..., <expr_n> one by one and returns
     `[<expr_n>]' (a list) if no error occurs.  If an error occurs in
     the evaluation of any argument, `errcatch' prevents the error from
     propagating and returns the empty list `[]' without evaluating any
     more arguments.

     `errcatch' is useful in `batch' files where one suspects an error
     might occur which would terminate the `batch' if the error weren't
     caught.


 -- Function: error (<expr_1>, ..., <expr_n>)
 -- System variable: error
     Evaluates and prints <expr_1>, ..., <expr_n>, and then causes an
     error return to top level Maxima or to the nearest enclosing
     `errcatch'.

     The variable `error' is set to a list describing the error.  The
     first element of `error' is a format string, which merges all the
     strings among the arguments <expr_1>, ..., <expr_n>, and the
     remaining elements are the values of any non-string arguments.

     `errormsg()' formats and prints `error'.  This is effectively
     reprinting the most recent error message.


 -- Option variable: error_size
     Default value: 10

     `error_size' modifies error messages according to the size of
     expressions which appear in them. If the size of an expression (as
     determined by the Lisp function `ERROR-SIZE') is greater than
     `error_size', the expression is replaced in the message by a
     symbol, and the symbol is assigned the expression. The symbols are
     taken from the list `error_syms'.

     Otherwise, the expression is smaller than `error_size', and the
     expression is displayed in the message.

     See also `error' and `error_syms'.

     Example:

     The size of `U', as determined by `ERROR-SIZE', is 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Option variable: error_syms
     Default value: `[errexp1, errexp2, errexp3]'

     In error messages, expressions larger than `error_size' are
     replaced by symbols, and the symbols are set to the expressions.
     The symbols are taken from the list `error_syms'. The first
     too-large expression is replaced by `error_syms[1]', the second by
     `error_syms[2]', and so on.

     If there are more too-large expressions than there are elements of
     `error_syms', symbols are constructed automatically, with the
     <n>-th symbol equivalent to `concat ('errexp, <n>)'.

     See also `error' and `error_size'.


 -- Function: errormsg ()
     Reprints the most recent error message.  The variable `error'
     holds the message, and `errormsg' formats and prints it.


 -- Special operator: for
     Used in iterations. See `do' for a description of Maxima's
     iteration facilities.


 -- Function: go (<tag>)
     is used within a `block' to transfer control to the statement of
     the block which is tagged with the argument to `go'.  To tag a
     statement, precede it by an atomic argument as another statement in
     the `block'.  For example:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     The argument to `go' must be the name of a tag appearing in the
     same `block'.  One cannot use `go' to transfer to tag in a `block'
     other than the one containing the `go'.


 -- Special operator: if
     Represents conditional evaluation. Various forms of `if'
     expressions are recognized.

     `if <cond_1> then <expr_1> else <expr_0>' evaluates to <expr_1> if
     <cond_1> evaluates to `true', otherwise the expression evaluates
     to <expr_0>.

     `if <cond_1> then <expr_1> elseif <cond_2> then <expr_2> elseif
     ... else <expr_0>' evaluates to <expr_k> if <cond_k> is `true' and
     all preceding conditions are `false'.  If none of the conditions
     are `true', the expression evaluates to `expr_0'.

     A trailing `else false' is assumed if `else' is missing.  That is,
     `if <cond_1> then <expr_1>' is equivalent to `if <cond_1> then
     <expr_1> else false', and `if <cond_1> then <expr_1> elseif ...
     elseif <cond_n> then <expr_n>' is equivalent to `if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     The alternatives <expr_0>, ..., <expr_n> may be any Maxima
     expressions, including nested `if' expressions.  The alternatives
     are neither simplified nor evaluated unless the corresponding
     condition is `true'.

     The conditions <cond_1>, ..., <cond_n> are expressions which
     potentially or actually evaluate to `true' or `false'.  When a
     condition does not actually evaluate to `true' or `false', the
     behavior of `if' is governed by the global flag `prederror'.  When
     `prederror' is `true', it is an error if any evaluated condition
     does not evaluate to `true' or `false'.  Otherwise, conditions
     which do not evaluate to `true' or `false' are accepted, and the
     result is a conditional expression.

     Among other elements, conditions may comprise relational and
     logical operators as follows.

          Operation            Symbol      Type

          less than            <           relational infix
          less than            <=
            or equal to                    relational infix
          equality (syntactic) =           relational infix
          negation of =        #           relational infix
          equality (value)     equal       relational function
          negation of equal    notequal    relational function
          greater than         >=
            or equal to                    relational infix
          greater than         >           relational infix
          and                  and         logical infix
          or                   or          logical infix
          not                  not         logical prefix


 -- Function: map (<f>, <expr_1>, ..., <expr_n>)
     Returns an expression whose leading operator is the same as that
     of the expressions <expr_1>, ..., <expr_n> but whose subparts are
     the results of applying <f> to the corresponding subparts of the
     expressions.  <f> is either the name of a function of n arguments
     or is a `lambda' form of n arguments.

     `maperror' - if `false' will cause all of the mapping functions to
     (1) stop when they finish going down the shortest <expr_i> if not
     all of the <expr_i> are of the same length and (2) apply <f> to
     [<expr_1>, <expr_2>, ...]  if the <expr_i> are not all the same
     type of object. If `maperror' is `true' then an error message will
     be given in the above two instances.

     One of the uses of this function is to `map' a function (e.g.
     `partfrac') onto each term of a very large expression where it
     ordinarily wouldn't be possible to use the function on the entire
     expression due to an exhaustion of list storage space in the
     course of the computation.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]


 -- Function: mapatom (<expr>)
     Returns `true' if and only if <expr> is treated by the mapping
     routines as an atom.  "Mapatoms" are atoms, numbers (including
     rational numbers), and subscripted variables.


 -- Option variable: maperror
     Default value: `true'

     When `maperror' is `false', causes all of the mapping functions,
     for example

          map (<f>, <expr_1>, <expr_2>, ...)

     to (1) stop when they finish going down the shortest <expr_i> if
     not all of the <expr_i> are of the same length and (2) apply <f>
     to [<expr_1>, <expr_2>, ...] if the <expr_i> are not all the same
     type of object.

     If `maperror' is `true' then an error message is displayed in the
     above two instances.


 -- Option variable: mapprint
     Default value: `true'

     When `mapprint' is `true', various information messages from
     `map', `mapl', and `fullmap' are produced in certain situations.
     These include situations where `map' would use `apply', or `map'
     is truncating on the shortest list.

     If `mapprint' is `false', these messages are suppressed.


 -- Function: maplist (<f>, <expr_1>, ..., <expr_n>)
     Returns a list of the applications of <f> to the parts of the
     expressions <expr_1>, ..., <expr_n>.  <f> is the name of a
     function, or a lambda expression.

     `maplist' differs from `map (<f>, <expr_1>, ..., <expr_n>)' which
     returns an expression with the same main operator as <expr_i> has
     (except for simplifications and the case where `map' does an
     `apply').


 -- Option variable: prederror
     Default value: `false'

     When `prederror' is `true', an error message is displayed whenever
     the predicate of an `if' statement or an `is' function fails to
     evaluate to either `true' or `false'.

     If `false', `unknown' is returned instead in this case.  The
     `prederror: false' mode is not supported in translated code;
     however, `maybe' is supported in translated code.

     See also `is' and `maybe'.


 -- Function: return (<value>)
     May be used to exit explicitly from a block, bringing its
     argument.  See `block' for more information.


 -- Function: scanmap (<f>, <expr>)
 -- Function: scanmap (<f>, <expr>, bottomup)
     Recursively applies <f> to <expr>, in a top down manner.  This is
     most useful when complete factorization is desired, for example:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note the way in which `scanmap' applies the given function
     `factor' to the constituent subexpressions of <expr>; if another
     form of <expr> is presented to `scanmap' then the result may be
     different. Thus, `%o2' is not recovered when `scanmap' is applied
     to the expanded form of `exp':

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Here is another example of the way in which `scanmap' recursively
     applies a given function to all subexpressions, including
     exponents:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' applies <f> to <expr> in a
     bottom-up manner.  E.g., for undefined `f',

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     In this case, you get the same answer both ways.


 -- Function: throw (<expr>)
     Evaluates <expr> and throws the value back to the most recent
     `catch'.  `throw' is used with `catch' as a nonlocal return
     mechanism.


 -- Special operator: while
 -- Special operator: unless
     See `do'.


 -- Function: outermap (<f>, <a_1>, ..., <a_n>)
     Applies the function <f> to each one of the elements of the outer
     product <a_1> cross <a_2> ... cross <a_n>.

     <f> is the name of a function of n arguments or a lambda
     expression of n arguments.  Each argument <a_k> may be a list or
     nested list, or a matrix, or any other kind of expression.

     The `outermap' return value is a nested structure.  Let <x> be the
     return value.  Then <x> has the same structure as the first list,
     nested list, or matrix argument, `<x>[i_1]...[i_m]' has the same
     structure as the second list, nested list, or matrix argument,
     `<x>[i_1]...[i_m][j_1]...[j_n]' has the same structure as the
     third list, nested list, or matrix argument, and so on, where <m>,
     <n>, ... are the numbers of indices required to access the
     elements of each argument (one for a list, two for a matrix, one
     or more for a nested list).  Arguments which are not lists or
     matrices have no effect on the structure of the return value.

     Note that the effect of `outermap' is different from that of
     applying <f> to each one of the elements of the outer product
     returned by `cartesian_product'.  `outermap' preserves the
     structure of the arguments in the return value, while
     `cartesian_product' does not.

     `outermap' evaluates its arguments.

     See also `map', `maplist', and `apply'.

     Examples:

     Elementary examples of `outermap'.  To show the argument
     combinations more clearly, `F' is left undefined.

          (%i1) outermap(F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     A closer examination of the `outermap' return value. The first,
     second, and third arguments are a matrix, a list, and a matrix,
     respectively. The return value is a matrix. Each element of that
     matrix is a list, and each element of each list is a matrix.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                             arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     `outermap' preserves the structure of the arguments in the return
     value, while `cartesian_product' does not.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map(lambda([L], apply(F, L)),
                               cartesian_product({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true



File: maxima.info,  Node: Fehlersuche,  Next: Verschiedene Optionen,  Prev: Programmierung,  Up: Top

27 Fehlersuche
**************

* Menu:

* Source Level Debugging::
* Keyword Commands::
* Functions and Variables for Debugging::


File: maxima.info,  Node: Source Level Debugging,  Next: Keyword Commands,  Up: Fehlersuche

27.1 Source Level Debugging
===========================

Maxima has a built-in source level debugger.  The user can set a
breakpoint at a function, and then step line by line from there.  The
call stack may be examined, together with the variables bound at that
level.

   The command `:help' or `:h' shows the list of debugger commands.
(In general, commands may be abbreviated if the abbreviation is unique.
If not unique, the alternatives will be listed.)  Within the debugger,
the user can also use any ordinary Maxima functions to examine, define,
and manipulate variables and expressions.

   A breakpoint is set by the `:br' command at the Maxima prompt.
Within the debugger, the user can advance one line at a time using the
`:n' ("next") command.  The `:bt' ("backtrace") command shows a list of
stack frames.  The `:r' ("resume") command exits the debugger and
continues with execution.  These commands are demonstrated in the
example below.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investigate value of u
     28

     (dbm:1) u: 33;                     <-- Change u to be 33
     33

     (dbm:1) :r                         <-- Type :r to resume the computation

     (%o2)                                1094

   The file `/tmp/foobar.mac' is the following:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USE OF THE DEBUGGER THROUGH EMACS

   If the user is running the code under GNU emacs in a shell window
(dbl shell), or is running the graphical interface version, Xmaxima,
then if he stops at a break point, he will see his current position in
the source file which will be displayed in the other half of the
window, either highlighted in red, or with a little arrow pointing at
the right line.  He can advance single lines at a time by typing M-n
(Alt-n).

   Under Emacs you should run in a `dbl' shell, which requires the
`dbl.el' file in the elisp directory.  Make sure you install the elisp
files or add the Maxima elisp directory to your path: e.g., add the
following to your `.emacs' file or the `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   then in emacs

     M-x dbl

   should start a shell window in which you can run programs, for
example Maxima, gcl, gdb etc.   This shell window also knows about
source level debugging, and display of source code in the other window.

   The user may set a break point at a certain line of the file by
typing `C-x space'.  This figures out which function the cursor is in,
and then it sees which line of that function the cursor is on.   If the
cursor is on, say, line 2 of `foo', then it will insert in the other
window the command, "`:br foo 2'", to break `foo' at its second line.
To have this enabled, the user must have maxima-mode.el turned on in
the window in which the file `foobar.mac' is visiting.  There are
additional commands available in that file window, such as evaluating
the function into the Maxima, by typing `Alt-Control-x'.


File: maxima.info,  Node: Keyword Commands,  Next: Functions and Variables for Debugging,  Prev: Source Level Debugging,  Up: Fehlersuche

27.2 Keyword Commands
=====================

Keyword commands are special keywords which are not interpreted as
Maxima expressions.  A keyword command can be entered at the Maxima
prompt or the debugger prompt, although not at the break prompt.
Keyword commands start with a colon, '`:''.  For example, to evaluate a
Lisp form you may type `:lisp' followed by the form to be evaluated.

     (%i1) :lisp (+ 2 3)
     5

   The number of arguments taken depends on the particular command.
Also, you need not type the whole command, just enough to be unique
among the break keywords.   Thus `:br' would suffice for `:break'.

   The keyword commands are listed below.

`:break F n'
     Set a breakpoint in function `F' at line offset `n' from the
     beginning of the function.  If `F' is given as a string, then it
     is assumed to be a file, and `n' is the offset from the beginning
     of the file.  The offset is optional. If not given, it is assumed
     to be zero (first line of the function or file).

`:bt'
     Print a backtrace of the stack frames

`:continue'
     Continue the computation

`:delete'
     Delete the specified breakpoints, or all if none are specified

`:disable'
     Disable the specified breakpoints, or all if none are specified

`:enable'
     Enable the specified breakpoints, or all if none are specified

`:frame n'
     Print stack frame `n', or the current frame if none is specified

`:help'
     Print help on a debugger command, or all commands if none is
     specified

`:info'
     Print information about item

`:lisp some-form'
     Evaluate `some-form' as a Lisp form

`:lisp-quiet some-form'
     Evaluate Lisp form `some-form' without any output

`:next'
     Like `:step', except `:next' steps over function calls

`:quit'
     Quit the current debugger level without completing the computation

`:resume'
     Continue the computation

`:step'
     Continue the computation until it reaches a new source line

`:top'
     Return to the Maxima prompt (from any debugger level) without
     completing the computation


File: maxima.info,  Node: Functions and Variables for Debugging,  Prev: Keyword Commands,  Up: Fehlersuche

27.3 Functions and Variables for Debugging
==========================================

 -- Option variable: debugmode
     Default value: `false'

     When a Maxima error occurs, Maxima will start the debugger if
     `debugmode' is `true'.  The user may enter commands to examine the
     call stack, set breakpoints, step through Maxima code, and so on.
     See `debugging' for a list of debugger commands.

     Enabling `debugmode' will not catch Lisp errors.


 -- Option variable: refcheck
     Default value: `false'

     When `refcheck' is `true', Maxima prints a message each time a
     bound variable is used for the first time in a computation.


 -- Option variable: setcheck
     Default value: `false'

     If `setcheck' is set to a list of variables (which can be
     subscripted), Maxima prints a message whenever the variables, or
     subscripted occurrences of them, are bound with the ordinary
     assignment operator `:', the `::' assignment operator, or function
     argument binding, but not the function assignment `:=' nor the
     macro assignment `::=' operators.  The message comprises the name
     of the variable and the value it is bound to.

     `setcheck' may be set to `all' or `true' thereby including all
     variables.

     Each new assignment of `setcheck' establishes a new list of
     variables to check, and any variables previously assigned to
     `setcheck' are forgotten.

     The names assigned to `setcheck' must be quoted if they would
     otherwise evaluate to something other than themselves.  For
     example, if `x', `y', and `z' are already bound, then enter

          setcheck: ['x, 'y, 'z]$

     to put them on the list of variables to check.

     No printout is generated when a variable on the `setcheck' list is
     assigned to itself, e.g., `X: 'X'.


 -- Option variable: setcheckbreak
     Default value: `false'

     When `setcheckbreak' is `true', Maxima will present a break prompt
     whenever a variable on the `setcheck' list is assigned a new value.
     The break occurs before the assignment is carried out.  At this
     point, `setval' holds the value to which the variable is about to
     be assigned.  Hence, one may assign a different value by assigning
     to `setval'.

     See also `setcheck' and `setval'.


 -- System variable: setval
     Holds the value to which a variable is about to be set when a
     `setcheckbreak' occurs.  Hence, one may assign a different value
     by assigning to `setval'.

     See also `setcheck' and `setcheckbreak'.


 -- Function: timer (<f_1>, ..., <f_n>)
 -- Function: timer (all)
 -- Function: timer ()
     Given functions <f_1>, ..., <f_n>, `timer' puts each one on the
     list of functions for which timing statistics are collected.
     `timer(f)$ timer(g)$' puts `f' and then `g' onto the list; the
     list accumulates from one call to the next.

     `timer(all)' puts all user-defined functions (as named by the
     global variable `functions') on the list of timed functions.

     With no arguments, `timer' returns the list of timed functions.

     Maxima records how much time is spent executing each function on
     the list of timed functions.  `timer_info' returns the timing
     statistics, including the average time elapsed per function call,
     the number of calls, and the total time elapsed.  `untimer'
     removes functions from the list of timed functions.

     `timer' quotes its arguments.  `f(x) := x^2$ g:f$ timer(g)$' does
     not put `f' on the timer list.

     If `trace(f)' is in effect, then `timer(f)' has no effect; `trace'
     and `timer' cannot both be in effect at the same time.

     See also `timer_devalue'.


 -- Function: untimer (<f_1>, ..., <f_n>)
 -- Function: untimer ()
     Given functions <f_1>, ..., <f_n>, `untimer' removes each function
     from the timer list.

     With no arguments, `untimer' removes all functions currently on
     the timer list.

     After `untimer (f)' is executed, `timer_info (f)' still returns
     previously collected timing statistics, although `timer_info()'
     (with no arguments) does not return information about any function
     not currently on the timer list.  `timer (f)' resets all timing
     statistics to zero and puts `f' on the timer list again.


 -- Option variable: timer_devalue
     Default value: `false'

     When `timer_devalue' is `true', Maxima subtracts from each timed
     function the time spent in other timed functions. Otherwise, the
     time reported for each function includes the time spent in other
     functions.  Note that time spent in untimed functions is not
     subtracted from the total time.

     See also `timer' and `timer_info'.


 -- Function: timer_info (<f_1>, ..., <f_n>)
 -- Function: timer_info ()
     Given functions <f_1>, ..., <f_n>, `timer_info' returns a matrix
     containing timing information for each function.  With no
     arguments, `timer_info' returns timing information for all
     functions currently on the timer list.

     The matrix returned by `timer_info' contains the function name,
     time per function call, number of function calls, total time, and
     `gctime', which meant "garbage collection time" in the original
     Macsyma but is now always zero.

     The data from which `timer_info' constructs its return value can
     also be obtained by the `get' function:

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     See also `timer'.


 -- Function: trace (<f_1>, ..., <f_n>)
 -- Function: trace (all)
 -- Function: trace ()
     Given functions <f_1>, ..., <f_n>, `trace' instructs Maxima to
     print out debugging information whenever those functions are
     called.  `trace(f)$ trace(g)$' puts `f' and then `g' onto the list
     of functions to be traced; the list accumulates from one call to
     the next.

     `trace(all)' puts all user-defined functions (as named by the
     global variable `functions') on the list of functions to be traced.

     With no arguments, `trace' returns a list of all the functions
     currently being traced.

     The `untrace' function disables tracing.  See also `trace_options'.

     `trace' quotes its arguments. Thus, `f(x) := x^2$ g:f$ trace(g)$'
     does not put `f' on the trace list.

     When a function is redefined, it is removed from the timer list.
     Thus after `timer(f)$ f(x) := x^2$', function `f' is no longer on
     the timer list.

     If `timer (f)' is in effect, then `trace (f)' has no effect;
     `trace' and `timer' can't both be in effect for the same function.


 -- Function: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Function: trace_options (<f>)
     Sets the trace options for function <f>.  Any previous options are
     superseded.  `trace_options (<f>, ...)' has no effect unless
     `trace (<f>)' is also called (either before or after
     `trace_options').

     `trace_options (<f>)' resets all options to their default values.

     The option keywords are:

        * `noprint' Do not print a message at function entry and exit.

        * `break' Put a breakpoint before the function is entered, and
          after the function is exited. See `break'.

        * `lisp_print' Display arguments and return values as Lisp
          objects.

        * `info' Print `-> true' at function entry and exit.

        * `errorcatch' Catch errors, giving the option to signal an
          error, retry the function call, or specify a return value.

     Trace options are specified in two forms. The presence of the
     option keyword alone puts the option into effect unconditionally.
     (Note that option <foo> is not put into effect by specifying
     `<foo>: true' or a similar form; note also that keywords need not
     be quoted.) Specifying the option keyword with a predicate
     function makes the option conditional on the predicate.

     The argument list to the predicate function is always `[level,
     direction, function, item]' where `level' is the recursion level
     for the function,  `direction' is either `enter' or `exit',
     `function' is the name of the function, and `item' is the argument
     list (on entering) or the return value (on exiting).

     Here is an example of unconditional trace options:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Here is the same function, with the `break' option conditional on
     a predicate:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Function: untrace (<f_1>, ..., <f_n>)
 -- Function: untrace ()
     Given functions <f_1>, ..., <f_n>, `untrace' disables tracing
     enabled by the `trace' function.  With no arguments, `untrace'
     disables tracing for all functions.

     `untrace' returns a list of the functions for which it disabled
     tracing.



File: maxima.info,  Node: Verschiedene Optionen,  Next: affine,  Prev: Fehlersuche,  Up: Top

28 Verschiedene Optionen
************************

* Menu:

* Introduction to Miscellaneous Options::
* Share::
* Functions and Variables for Miscellaneous Options::


File: maxima.info,  Node: Introduction to Miscellaneous Options,  Next: Share,  Prev: Verschiedene Optionen,  Up: Verschiedene Optionen

28.1 Introduction to Miscellaneous Options
==========================================

In this section various options are discussed which have a global effect
on the operation of Maxima.   Also various lists such as the list of all
user defined functions, are discussed.


File: maxima.info,  Node: Share,  Next: Functions and Variables for Miscellaneous Options,  Prev: Introduction to Miscellaneous Options,  Up: Verschiedene Optionen

28.2 Share
==========

The Maxima "share" directory contains programs and other files of
interest to Maxima users, but not part of the core implementation of
Maxima.  These programs are typically loaded via `load' or
`setup_autoload'.

   `:lisp *maxima-sharedir*' displays the location of the share
directory within the user's file system.

   `printfile ("share.usg")' prints an out-of-date list of share
packages.  Users may find it more informative to browse the share
directory using a file system browser.


File: maxima.info,  Node: Functions and Variables for Miscellaneous Options,  Prev: Share,  Up: Verschiedene Optionen

28.3 Functions and Variables for Miscellaneous Options
======================================================

 -- Function: properties (<a>)
     Returns a list of the names of all the properties associated with
     the atom <a>.


 -- Systemvariable: props
     Standardwert: `[]'

     `props' ist eine Liste der Symbole, die eine Eigenschaft mit den
     Funktionen `declare', `atvaule' oder `matchdeclare' erhalten hat.


 -- Function: propvars (<prop>)
     Returns a list of those atoms on the `props' list which have the
     property indicated by <prop>.  Thus `propvars (atvalue)' returns a
     list of atoms which have atvalues.


 -- Function: put (<atom>, <value>, <indicator>)
     Assigns <value> to the property (specified by <indicator>) of
     <atom>.  <indicator> may be the name of any property, not just a
     system-defined property.

     `put' evaluates its arguments.  `put' returns <value>.

     Examples:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Function: qput (<atom>, <value>, <indicator>)
     Assigns <value> to the property (specified by <indicator>) of
     <atom>.  This is the same as `put', except that the arguments are
     quoted.

     Example:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Function: rem (<atom>, <indicator>)
     Removes the property indicated by <indicator> from <atom>.


 -- Function: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Function: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Function: remove ("<a>", operator)
 -- Function: remove (<a>, transfun)
 -- Function: remove (all, <p>)
     Removes properties associated with atoms.

     `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' removes property `p_k'
     from atom `a_k'.

     `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' removes
     properties `<p_1>, ..., <p_n>' from atoms <a_1>, ..., <a_m>.
     There may be more than one pair of lists.

     `remove (all, <p>)' removes the property <p> from all atoms which
     have it.

     The removed properties may be system-defined properties such as
     `function', `macro', or `mode_declare', or user-defined properties.

     A property may be `transfun' to remove the translated Lisp version
     of a function.  After executing this, the Maxima version of the
     function is executed rather than the translated version.

     `remove ("<a>", operator)' or, equivalently, `remove ("<a>", op)'
     removes from <a> the operator properties declared by `prefix',
     `infix', `nary', `postfix', `matchfix', or `nofix'.  Note that the
     name of the operator must be written as a quoted string.

     `remove' always returns `done' whether or not an atom has a
     specified property.  This behavior is unlike the more specific
     remove functions `remvalue', `remarray', `remfunction', and
     `remrule'.


 -- Function: remvalue (<name_1>, ..., <name_n>)
 -- Function: remvalue (all)
     Removes the values of user variables <name_1>, ..., <name_n>
     (which can be subscripted) from the system.

     `remvalue (all)' removes the values of all variables in `values',
     the list of all variables given names by the user (as opposed to
     those which are automatically assigned by Maxima).

     See also `values'.


 -- Function: rncombine (<expr>)
     Transforms <expr> by combining all terms of <expr> that have
     identical denominators or denominators that differ from each other
     by numerical factors only.  This is slightly different from the
     behavior of `combine', which collects terms that have identical
     denominators.

     Setting `pfeformat: true' and using `combine' yields results
     similar to those that can be obtained with `rncombine', but
     `rncombine' takes the additional step of cross-multiplying
     numerical denominator factors.  This results in neater forms, and
     the possibility of recognizing some cancellations.

     `load(rncomb)' loads this function.


 -- Function: scalarp (<expr>)
     Returns `true' if <expr> is a number, constant, or variable
     declared `scalar' with `declare', or composed entirely of numbers,
     constants, and such variables, but not containing matrices or
     lists.


 -- Function: setup_autoload (<filename>, <function_1>, ...,
          <function_n>)
     Specifies that if any of <function_1>, ..., <function_n> are
     referenced and not yet defined, <filename> is loaded via `load'.
     <filename> usually contains definitions for the functions
     specified, although that is not enforced.

     `setup_autoload' does not work for array functions.

     `setup_autoload' quotes its arguments.

     Example:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


 -- Function: tcl_output (<list>, <i0>, <skip>)
 -- Function: tcl_output (<list>, <i0>)
 -- Function: tcl_output ([<list_1>, ..., <list_n>], <i>)
     Prints elements of a list enclosed by curly braces `{ }', suitable
     as part of a program in the Tcl/Tk language.

     `tcl_output (<list>, <i0>, <skip>)' prints <list>, beginning with
     element <i0> and printing elements `<i0> + <skip>', `<i0> + 2
     <skip>', etc.

     `tcl_output (<list>, <i0>)' is equivalent to `tcl_output (<list>,
     <i0>, 2)'.

     `tcl_output ([<list_1>, ..., <list_n>], <i>)' prints the <i>'th
     elements of <list_1>, ..., <list_n>.

     Examples:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }


File: maxima.info,  Node: affine,  Next: asympa,  Prev: Verschiedene Optionen,  Up: Top

29 affine
*********

* Menu:

* Introduction to Affine::
* Functions and Variables for Affine::


File: maxima.info,  Node: Introduction to Affine,  Next: Functions and Variables for Affine,  Prev: affine,  Up: affine

29.1 Introduction to Affine
===========================

`affine' is a package to work with groups of polynomials.


File: maxima.info,  Node: Functions and Variables for Affine,  Prev: Introduction to Affine,  Up: affine

29.2 Functions and Variables for Affine
=======================================

 -- Function: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Solves the simultaneous linear equations <expr_1>, ..., <expr_m>
     for the variables <x_1>, ..., <x_n>. Each <expr_i> may be an
     equation or a general expression; if given as a general
     expression, it is treated as an equation of the form `<expr_i> =
     0'.

     The return value is a list of equations of the form `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' where <a_1>, ..., <a_n> are all free
     of <x_1>, ..., <x_n>.

     `fast_linsolve' is faster than `linsolve'  for system of equations
     which are sparse.

     `load(affine)' loads this function.


 -- Function: grobner_basis ([<expr_1>, ..., <expr_m>])
     Returns a Groebner basis for the equations <expr_1>, ..., <expr_m>.
     The function `polysimp' can then be used to simplify other
     functions relative to the equations.

     `polysimp(f)' yields 0 if and only if <f> is in the ideal
     generated by <expr_1>, ..., <expr_m>, that is, if and only if <f>
     is a polynomial combination of the elements of <expr_1>, ...,
     <expr_m>.

     `load(affine)' loads this function.

     Beispiel:

          (%i1) load(affine)$

          (%i2) grobner_basis ([3*x^2+1, y*x]);
          eliminated one
           . 0 . 0                                   2
          (%o2)/R/                [- y, - 3 x  - 1]
          (%i3) polysimp(y^2*x+x^3*9+2);
          (%o3)/R/                    - 3 x + 2


 -- Function: set_up_dot_simplifications (<eqns>,
          <check_through_degree>)
 -- Function: set_up_dot_simplifications (<eqns>)
     The <eqns> are polynomial equations in non commutative variables.
     The value of `current_variables' is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     `dot_simplifications' above the degree of <f>, then the following
     is true: `dotsimp(<f>)' yields 0 if and only if <f> is in the ideal
     generated by the equations, i.e., if and only if <f> is a
     polynomial combination of the elements of the equations.

     The degree is that returned by `nc_degree'.   This in turn is
     influenced by the weights of individual variables.

     `load(affine)' loads this function.


 -- Function: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Assigns weights <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectively. These are the weights used in computing `nc_degree'.

     `load(affine)' loads this function.


 -- Function: nc_degree (<p>)
     Returns the degree of a noncommutative polynomial <p>.  See
     `declare_weights'.

     `load(affine)' loads this function.


 -- Function: dotsimp (<f>)
     Returns 0 if and only if <f> is in the ideal generated by the
     equations, i.e., if and only if <f> is a polynomial combination of
     the elements of the equations.

     `load(affine)' loads this function.


 -- Function: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     If `set_up_dot_simplifications'  has been previously done, finds
     the central polynomials in the variables <x_1>, ..., <x_n> in the
     given degree, <n>.

     For example:

          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     `load(affine)' loads this function.


 -- Function: check_overlaps (<n>, <add_to_simps>)
     Checks the overlaps thru degree <n>, making sure that you have
     sufficient simplification rules in each degree, for `dotsimp'  to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is. If it is of
     finite global dimension, then `hilbert' should be used.  If you
     don't know the monomial dimensions, do not specify a
     `rank_function'. An optional third argument `reset', `false' says
     don't bother to query about resetting things.

     `load(affine)' loads this function.


 -- Function: mono ([<x_1>, ..., <x_n>], <n>)
     Returns the list of independent monomials relative to the current
     dot simplifications of degree <n> in the variables <x_1>, ...,
     <x_n>.

     `load(affine)' loads this function.


 -- Function: monomial_dimensions (<n>)
     Compute the Hilbert series through degree <n> for the current
     algebra.

     `load(affine)' loads this function.


 -- Function: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Makes a list of the coefficients of the noncommutative polynomials
     <p_1>, ..., <p_n> of the noncommutative monomials <m_1>, ...,
     <m_n>. The coefficients should be scalars.   Use
     `list_nc_monomials' to build the list of monomials.

     `load(affine)' loads this function.


 -- Function: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Function: list_nc_monomials (<p>)
     Returns a list of the non commutative monomials occurring in a
     polynomial <p> or a list of polynomials <p_1>, ..., <p_n>.

     `load(affine)' loads this function.


 -- Option variable: all_dotsimp_denoms
     Default value: `false'

     When `all_dotsimp_denoms' is a list, the denominators encountered
     by `dotsimp'  are appended to the list. `all_dotsimp_denoms' may
     be initialized to an empty list `[]' before calling `dotsimp'.

     By default, denominators are not collected by `dotsimp'.



File: maxima.info,  Node: asympa,  Next: augmented_lagrangian,  Prev: affine,  Up: Top

30 asympa
*********

* Menu:

* Introduction to asympa::
* Functions and variables for asympa::


File: maxima.info,  Node: Introduction to asympa,  Next: Functions and variables for asympa,  Prev: asympa,  Up: asympa

30.1 Introduction to asympa
===========================

 -- Function: asympa
     `asympa' is a package for asymptotic analysis. The package contains
     simplification functions for asymptotic analysis, including the
     "big O" and "little o" functions that are widely used in
     complexity analysis and numerical analysis.

     `load ("asympa")' loads this package.



File: maxima.info,  Node: Functions and variables for asympa,  Prev: Introduction to asympa,  Up: asympa

30.2 Functions and variables for asympa
=======================================


File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: asympa,  Up: Top

31 augmented_lagrangian
***********************

* Menu:

* Functions and Variables for augmented_lagrangian::


File: maxima.info,  Node: Functions and Variables for augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

31.1 Functions and Variables for augmented_lagrangian
=====================================================

 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          optional_args)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>, optional_args)
     Returns an approximate minimum of the expression <FOM> with
     respect to the variables <xx>, holding the constraints <C> equal
     to zero. <yy> is a list of initial guesses for <xx>. The method
     employed is the augmented Lagrangian method (see Refs [1] and [2]).

     <grad>, if present, is the gradient of <FOM> with respect to <xx>,
     represented as a list of expressions, one for each variable in
     <xx>.  If not present, the gradient is constructed automatically.

     <FOM> and each element of <grad>, if present, must be ordinary
     expressions, not names of functions or lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'. The optional arguments recognized are:

    `niter'
          Number of iterations of the augmented Lagrangian algorithm

    `lbfgs_tolerance'
          Tolerance supplied to LBFGS

    `iprint'
          IPRINT parameter (a list of two integers which controls
          verbosity) supplied to LBFGS

    `%lambda'
          Initial value of `%lambda' to be used for calculating the
          augmented Lagrangian

     This implementation minimizes the augmented Lagrangian by applying
     the limited-memory BFGS (LBFGS) algorithm, which is a quasi-Newton
     algorithm.

     `load(augmented_lagrangian)' loads this function.

     See also `lbfgs'.

     References:

     [1]
     `http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html'

     [2] `http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf'

     Examples:

          (%i1) load (lbfgs);
          (%o1)     /maxima/share/lbfgs/lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2)
             /maxima/share/contrib/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method(FOM, xx, C, yy, iprint=[-1,0]);
          (%o7) [[x = 0.66665984108002, y = 0.33334027245545],
                                           %lambda = [- 1.333337940892525]]

     Same example as before, but this time the gradient is supplied as
     an argument.

          (%i1) load (lbfgs)$
          (%i2) load (augmented_lagrangian)$
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) FOM: x^2 + 2*y^2;
                                         2    2
          (%o4)                       2 y  + x
          (%i5) xx: [x, y];
          (%o5)                        [x, y]
          (%i6) grad : [2*x, 4*y];
          (%o6)                      [2 x, 4 y]
          (%i7) C: [x + y - 1];
          (%o7)                      [y + x - 1]
          (%i8) yy: [1, 1];
          (%o8)                        [1, 1]
          (%i9) augmented_lagrangian_method ([FOM, grad], xx, C, yy, iprint = [-1, 0]);
          (%o9) [[x = 0.666659841080025, y = .3333402724554462],
                                           %lambda = [- 1.333337940892543]]



File: maxima.info,  Node: bode,  Next: cobyla,  Prev: augmented_lagrangian,  Up: Top

32 bode
*******

* Menu:

* Functions and Variables for bode::


File: maxima.info,  Node: Functions and Variables for bode,  Prev: bode,  Up: bode

32.1 Functions and Variables for bode
=====================================

 -- Function: bode_gain (<H>, <range>, ...<plot_opts>...)
     Function to draw Bode gain plots. To use this function write first
     `load(bode)'. See also `bode_phase'.

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$


 -- Function: bode_phase (<H>, <range>, ...<plot_opts>...)
     Function to draw Bode phase plots. To use this function write first
     `load(bode)'. See also `bode_gain'.

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));



File: maxima.info,  Node: cobyla,  Next: contrib_ode,  Prev: bode,  Up: Top

33 cobyla
*********

* Menu:

* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::


File: maxima.info,  Node: Introduction to cobyla,  Next: Functions and Variables for cobyla,  Prev: cobyla,  Up: cobyla

33.1 Introduction to cobyla
===========================

`fmin_cobyla' is a Common Lisp translation (via `f2cl') of the Fortran
constrained optimization routine COBYLA by Powell[1][2][3].

   COBYLA minimizes an objective function F(X) subject to M inequality
constraints of the form g(X) >= 0 on X, where X is a vector of
variables that has N components.

   Equality constraints g(X)=0 can often be implemented by a pair of
inequality constraints g(X)>=0 and -g(X)>= 0.  Maxima's interface to
COBYLA allows equality constraints and internally converts the equality
constraints to a pair of inequality constraints.

   The algorithm employs linear approximations to the objective and
constraint functions, the approximations being formed by linear
interpolation at N+1 points in the space of the variables.  The
interpolation points are regarded as vertices of a simplex. The
parameter RHO controls the size of the simplex and it is reduced
automatically from RHOBEG to RHOEND. For each RHO the subroutine tries
to achieve a good vector of variables for the current size, and then
RHO is reduced until the value RHOEND is reached. Therefore RHOBEG and
RHOEND should be set to reasonable initial changes to and the required
accuracy in the variables respectively, but this accuracy should be
viewed as a subject for experimentation because it is not guaranteed.
The routine treats each constraint individually when calculating a
change to the variables, rather than lumping the constraints together
into a single penalty function. The name of the subroutine is derived
from the phrase Constrained Optimization BY Linear Approximations.

   References:

   [1] Fortran Code is from
`http://plato.asu.edu/sub/nlores.html#general'

   [2] M. J. D. Powell, "A direct search optimization method that
models the objective and constraint functions by linear interpolation,"
in Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J.-P. Hennart (Kluwer Academic: Dordrecht, 1994), p. 51-67.

   [3] M. J. D. Powell, "Direct search algorithms for optimization
calculations," Acta Numerica 7, 287-336 (1998).  Also available as
University of Cambridge, Department of Applied Mathematics and
Theoretical Physics,  Numerical Analysis Group, Report NA1998/04 from
`http://www.damtp.cam.ac.uk/user/na/reports.html'


File: maxima.info,  Node: Functions and Variables for cobyla,  Next: Examples for cobyla,  Prev: Introduction to cobyla,  Up: cobyla

33.2 Functions and Variables for cobyla
=======================================

 -- Function: fmin_cobyla (<F>, <X>, <Y>)
 -- Function: fmin_cobyla (<F>, <X>, <Y>, optional_args)
     Returns an approximate minimum of the expression <F> with respect
     to the variables <X>, subject to an optional set of constraints.
     <Y> is a list of initial guesses for <X>.

     <F> must be an ordinary expressions, not names of functions or
     lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'. The optional arguments recognized are:

    `constraints'
          List of inequality and equality constraints that must be
          satisfied by <X>.  The inequality constraints must be actual
          inequalities of the form `g(<X>) >= h(<X>)' or `g(<X>) <=
          h(<X>)'. The equality constraints must be of the form `g(<X>)
          = h(<X>)'.

    `rhobeg'
          Initial value of the internal RHO variable which controls the
          size of simplex.  (Defaults to 1.0)

    `rhoend'
          The desired final value rho parameter.  It is approximately
          the accuracy in the variables. (Defaults to 1d-6.)

    `iprint'
          Verbose output level.  (Defaults to 0)
             * 0 - No output

             * 1 - Summary at the end of the calculation

             * 2 - Each new value of RHO and SIGMA is printed, including
               the vector of variables, some function information when
               RHO is reduced.

             * 3 - Like 2, but information is printed when F(X) is
               computed.

    `maxfun'
          The maximum number of function evaluations.  (Defaults to
          1000).

     On return, a vector is given:

       1. The value of the variables giving the minimum.  This is a
          list of elements of the form `<var> = <value>' for each of the
          variables listed in <X>.

       2. The minimized function value

       3. The number of function evaluations.

       4. Return code with the following meanings
            1.  0 - No errors.

            2.  1 - Limit on maximum number of function evaluations
               reached.

            3.  2 - Rounding errors inhibiting progress.

     `load(fmin_cobyla)' loads this function.

 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>)
 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>, optional_args)
     This function is identical to `fmin_cobyla', except that bigfloat
     operations are used, and the default value for <rhoend> is
     `10^(fpprec/2)'.

     See `fmin_cobyla' for more information.

     `load(fmin_cobyla)' loads this function.


File: maxima.info,  Node: Examples for cobyla,  Prev: Functions and Variables for cobyla,  Up: cobyla

33.3 Examples for cobyla
========================

Minimize x1*x2 with 1-x1^2-x2^2 >= 0.  The theoretical solution is x1 =
1/sqrt(2), x2 = -1/sqrt(2).

     (%i1) load(fmin_cobyla)$

     (%i2) fmin_cobyla(x1*x2, [x1, x2], [1,1],
                              constraints = [x1^2+x2^2<=1], iprint=1);

        Normal return from subroutine COBYLA

        NFVALS =   66   F =-5.000000E-01    MAXCV = 1.999956E-12
        X = 7.071058E-01  -7.071077E-01
     (%o2) [[x1 = .7071058493484819, x2 = - .7071077130247994],
                                           - .499999999999263

   There are additional examples in the share/cobyla/ex directory.


File: maxima.info,  Node: contrib_ode,  Next: Package descriptive,  Prev: cobyla,  Up: Top

34 contrib_ode
**************

* Menu:

* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::


File: maxima.info,  Node: Introduction to contrib_ode,  Next: Functions and Variables for contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

34.1 Introduction to contrib_ode
================================

Maxima's ordinary differential equation (ODE) solver `ode2' solves
elementary linear ODEs of first and second order.  The function
`contrib_ode' extends `ode2' with additional methods for linear and
non-linear first order ODEs and linear homogeneous second order ODEs.
The code is still under development and the calling sequence may change
in future releases.  Once the code has stabilized it may be moved from
the contrib directory and integrated into Maxima.

   This package must be loaded with the command `load('contrib_ode)'
before use.

   The calling convention for `contrib_ode' is identical to `ode2'.  It
takes three arguments: an ODE (only the left hand side need be given if
the right hand side is 0), the dependent variable, and the independent
variable.  When successful, it returns a list of solutions.

   The form of the solution differs from `ode2'.  As non-linear
equations can have multiple solutions, `contrib_ode' returns a list of
solutions.  Each  solution can have a number of forms:
   * an explicit solution for the dependent variable,

   * an implicit solution for the dependent variable,

   * a parametric solution in terms of variable `%t', or

   * a tranformation into another ODE in variable `%u'.


   `%c' is used to represent the constant of integration for first order
equations. `%k1' and `%k2' are the constants for second order
equations. If `contrib_ode' cannot obtain a solution for whatever
reason, it returns `false', after perhaps printing out an error message.

   It is necessary to return a list of solutions, as even first order
non-linear ODEs can have multiple solutions.  For example:

     (%i1) load('contrib_ode)$

     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);

                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;

     (%o4)                        factor

   Nonlinear ODEs can have singular solutions without constants of
integration, as in the second solution of the following example:

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;

                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);

                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;

     (%o4)                       clairault

   The following ODE has two parametric solutions in terms of the dummy
variable `%t'.  In this case the parametric solutions can be manipulated
to give explicit solutions.

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);

     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;

     (%o4)                       lagrange

   The following example (Kamke 1.112) demonstrates an implicit
solution.

     (%i1) load('contrib_ode)$

     (%i2) assume(x>0,y>0);

     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);

                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;

     (%o5)                          lie

   The following Riccati equation is transformed into a linear second
order ODE in the variable `%u'.  Maxima is unable to solve the new ODE,
so it is returned unevaluated.

     (%i1) load('contrib_ode)$

     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;

     (%o4)                        riccati

   For first order ODEs `contrib_ode' calls `ode2'.  It then tries the
following methods: factorization, Clairault, Lagrange, Riccati, Abel
and Lie symmetry methods.  The Lie method is not attempted on Abel
equations if the Abel method fails, but it is tried if the Riccati
method returns an unsolved second order ODE.

   For second order ODEs `contrib_ode' calls `ode2' then `odelin'.

   Extensive debugging traces and messages are displayed if the command
`put('contrib_ode,true,'verbose)' is executed.


File: maxima.info,  Node: Functions and Variables for contrib_ode,  Next: Possible improvements to contrib_ode,  Prev: Introduction to contrib_ode,  Up: contrib_ode

34.2 Functions and Variables for contrib_ode
============================================

 -- Function: contrib_ode (<eqn>, <y>, <x>)
     Returns a list of solutions of the ODE <eqn> with independent
     variable <x> and dependent variable <y>.


 -- Function: odelin (<eqn>, <y>, <x>)
     `odelin' solves linear homogeneous ODEs of first and second order
     with independent variable <x> and dependent variable <y>.  It
     returns a fundamental solution set of the ODE.

     For second order ODEs, `odelin' uses a method, due to Bronstein
     and Lafaille, that searches for solutions in terms of given
     special functions.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x


 -- Function: ode_check (<eqn>, <soln>)
     Returns the value of ODE <eqn> after substituting a possible
     solution <soln>.  The value is equivalent to zero if <soln> is a
     solution of <eqn>.

          (%i1) load('contrib_ode)$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0


 -- System variable: method
     The variable `method' is set to the successful solution method.


 -- Variable: %c
     `%c' is the integration constant for first order ODEs.


 -- Variable: %k1
     `%k1' is the first integration constant for second order ODEs.


 -- Variable: %k2
     `%k2' is the second integration constant for second order ODEs.


 -- Function: gauss_a (<a>, <b>, <c>, <x>)
     `gauss_a(a,b,c,x)' and `gauss_b(a,b,c,x)' are 2F1 geometric
     functions.  They represent any two independent solutions of the
     hypergeometric differential equation `x(1-x) diff(y,x,2) +
     [c-(a+b+1)x diff(y,x) - aby = 0' (A&S 15.5.1).

     The only use of these functions is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of these
     functions may change in future releases of Maxima.

     See also `gauss_b', `dgauss_a' and `gauss_b'.


 -- Function: gauss_b (<a>, <b>, <c>, <x>)
     See `gauss_a'.


 -- Function: dgauss_a (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_a(<a>, <b>, <c>,
     <x>)'.


 -- Function: dgauss_b (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_b(<a>, <b>, <c>,
     <x>)'.


 -- Function: kummer_m (<a>, <b>, <x>)
     Kummer's M function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.2.

     The only use of this function is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of this
     function may change in future releases of Maxima.

     See also `kummer_u', `dkummer_m' and `dkummer_u'.


 -- Function: kummer_u (<a>, <b>, <x>)
     Kummer's U function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.3.

     See `kummer_m'.


 -- Function: dkummer_m (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_m(<a>, <b>, <x>)'.


 -- Function: dkummer_u (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_u(<a>, <b>, <x>)'.



File: maxima.info,  Node: Possible improvements to contrib_ode,  Next: Test cases for contrib_ode,  Prev: Functions and Variables for contrib_ode,  Up: contrib_ode

34.3 Possible improvements to contrib_ode
=========================================

These routines are work in progress.  I still need to:

   * Extend the FACTOR method `ode1_factor' to work for multiple roots.

   * Extend the FACTOR method `ode1_factor' to attempt to solve higher
     order factors.  At present it only attemps to solve linear factors.

   * Fix the LAGRANGE routine `ode1_lagrange' to prefer real roots over
      complex roots.

   * Add additional methods for Riccati equations.

   * Improve the detection of Abel equations of second kind.  The
     exisiting   pattern matching is weak.

   * Work on the Lie symmetry group routine `ode1_lie'.  There are
     quite a   few problems with it: some parts are unimplemented; some
     test cases   seem to run forever; other test cases crash; yet
     others return very   complex "solutions".  I wonder if it really
     ready for release yet.

   * Add more test cases.



File: maxima.info,  Node: Test cases for contrib_ode,  Next: References for contrib_ode,  Prev: Possible improvements to contrib_ode,  Up: contrib_ode

34.4 Test cases for contrib_ode
===============================

The routines have been tested on a approximately one thousand  test
cases from Murphy, Kamke, Zwillinger and elsewhere.  These are included
in the tests subdirectory.

   * The Clairault routine `ode1_clairault' finds all known solutions,
     including singular solutions, of the Clairault equations in Murphy
     and   Kamke.

   * The other routines often return a single solution when multiple
     solutions exist.

   * Some of the "solutions" from `ode1_lie' are overly complex and
     impossible to check.

   * There are some crashes.



File: maxima.info,  Node: References for contrib_ode,  Prev: Test cases for contrib_ode,  Up: contrib_ode

34.5 References for contrib_ode
===============================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen,
     Vol 1,     Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
        Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel's Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel's Equation,     Computing
     61, 39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order     ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (`http://lie.uwaterloo.ca/papers/ode_vii.pdf')

  7. E. S. Cheb-Terrab, T. Kolokolnikov,  First Order ODEs,
     Symmetries and Linear Transformations, European Journal of
     Applied Mathematics, Vol. 14, No. 2, pp. 231-246 (2003).
     (`http://arxiv.org/abs/math-ph/0007023',
     `http://lie.uwaterloo.ca/papers/ode_iv.pdf')

  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M. Bronstein, S. Lafaille, Solutions of linear ordinary
     differential equations in terms of special functions, Proceedings
     of ISSAC 2002, Lille, ACM Press, 23-28.
     (`http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf')



File: maxima.info,  Node: Package descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

35 Package descriptive
**********************

* Menu:

* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for specific multivariate descriptive statistics::
* Functions and Variables for statistical graphs::


File: maxima.info,  Node: Introduction to descriptive,  Next: Functions and Variables for data manipulation,  Prev: Package descriptive,  Up: Package descriptive

35.1 Introduction to descriptive
================================

Package `descriptive' contains a set of functions for making descriptive
statistical computations and graphing. Together with the source code
there are three data sets in your Maxima tree: `pidigits.data',
`wind.data' and `biomed.data'.

   Any statistics manual can be used as a reference to the functions in
package `descriptive'.

   For comments, bugs or suggestions, please contact me at <'mario AT
edu DOT xunta DOT es'>.

   Here is a simple example on how the descriptive functions in
`descriptive' do they work, depending on the nature of their arguments,
lists or matrices,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* multivariate sample */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   Note that in multivariate samples the mean is calculated for each
column.

   In case of several samples with possible different sizes, the Maxima
function `map' can be used to get the desired results for each sample,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   In this case, two samples of sizes 3 and 2 were stored into a list.

   Univariate samples must be stored in lists like

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   and multivariate samples in matrices as in

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   In this case, the number of columns equals the random variable
dimension and the number of rows is the sample size.

   Data can be introduced by hand, but big samples are usually stored
in plain text files. For example, file `pidigits.data' contains the
first 100 digits of number `%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   In order to load these digits in Maxima,

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

   On the other hand, file `wind.data' contains daily average wind
speeds at 5 meteorological stations in the Republic of Ireland (This is
part of a data set taken at 12 meteorological stations. The original
file is freely downloadable from the StatLib Data Repository and its
analysis is discused in Haslett, J., Raftery, A. E. (1989) <Space-time
Modelling with Long-memory Dependence: Assessing Ireland's Wind Power
Resource, with Discussion>. Applied Statistics 38, 1-50). This loads
the data:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

   Some samples contain non numeric data. As an example, file
`biomed.data' (which is part of another bigger one downloaded from the
StatLib Data Repository) contains four blood measures taken from two
groups of patients, `A' and `B', of different ages,

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

   The first individual belongs to group `A', is 30 years old and
his/her blood measures were 167.0, 89.0, 25.6 and 364.

   One must take care when working with categorical data. In the next
example, symbol `a' is asigned a value in some previous moment and then
a sample with categorical value `a' is taken,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Functions and Variables for data manipulation,  Next: Functions and Variables for descriptive statistics,  Prev: Introduction to descriptive,  Up: Package descriptive

35.2 Functions and Variables for data manipulation
==================================================

 -- Function: continuous_freq (<list>)
 -- Function: continuous_freq (<list>, <m>)
     The argument of `continuous_freq' must be a list of numbers, which
     will be then grouped in intervals and counted how many of them
     belong to each group.  Optionally, function `continuous_freq'
     admits a second argument indicating the number of classes, 10 is
     default,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     The first list contains the interval limits and the second the
     corresponding counts: there are 16 digits inside the interval `[0,
     1.8]', that is 0's and 1's, 24 digits in `(1.8, 3.6]', that is 2's
     and 3's, and so on.


 -- Function: discrete_freq (<list>)
     Counts absolute frequencies in discrete samples, both numeric and
     categorical.  Its unique argument is a list,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     The first list gives the sample values and the second their
     absolute frequencies. Commands `? col' and `? transpose' should
     help you to understand the last input.


 -- Function: subsample (<data_matrix>, <predicate_function>)
 -- Function: subsample (<data_matrix>, <predicate_function>,
          <col_num1>, <col_num2>, ...)
     This is a sort of variant of the Maxima `submatrix' function. The
     first argument is the data matrix, the second is a predicate
     function and optional additional arguments are the numbers of the
     columns to be taken. Its behaviour is better understood with
     examples.

     These are multivariate records in which the wind speed in the first
     meteorological station were greater than 18. See that in the
     lambda expression the <i>-th component is refered to as `v[i]'.
          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     In the following example, we request only the first, second and
     fifth components of those records with wind speeds greater or
     equal than 16 in station number 1 and less than 25 knots in
     station number 4. The sample contains only data from stations 1, 2
     and 5. In this case, the predicate function is defined as an
     ordinary Maxima function.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Here is an example with the categorical variables of `biomed.data'.
     We want the records corresponding to those patients in group `B'
     who are older than 38 years.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probably, the statistical analysis will involve only the blood
     measures,

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                           3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     This is the multivariate mean of `s3',

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8144.999999999999
          (%o3) [-----------, ---, 87.178, ------------------------,
                     100      10                     100
                                                              3 NA + 19587
                                                      18.123, ------------]
                                                                  100

     Here, the first component is meaningless, since `A' and `B' are
     categorical, the second component is the mean age of individuals
     in rational form, and the fourth and last values exhibit some
     strange behaviour. This is because symbol `NA' is used here to
     indicate <non available> data, and the two means are nonsense. A
     possible solution would be to take out from the matrix those rows
     with `NA' symbols, although this deserves some loss of information.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13



File: maxima.info,  Node: Functions and Variables for descriptive statistics,  Next: Functions and Variables for specific multivariate descriptive statistics,  Prev: Functions and Variables for data manipulation,  Up: Package descriptive

35.3 Functions and Variables for descriptive statistics
=======================================================

 -- Function: mean (<list>)
 -- Function: mean (<matrix>)
     This is the sample mean, defined as
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]


 -- Function: var (<list>)
 -- Function: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     See also function `var1'.


 -- Function: var1 (<list>)
 -- Function: var1 (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function `var'.


 -- Function: std (<list>)
 -- Function: std (<matrix>)
     This is the the square root of function `var', the variance with
     denominator n.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     See also functions `var' and `std1'.


 -- Function: std1 (<list>)
 -- Function: std1 (<matrix>)
     This is the the square root of function `var1', the variance with
     denominator n-1.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.170835096721089, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     See also functions `var1' and `std'.


 -- Function: noncentral_moment (<list>, <k>)
 -- Function: noncentral_moment (<matrix>, <k>)
     The non central moment of order k, defined as
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) noncentral_moment (s2, 5);
          (%o6) [319793.8724761505, 320532.1923892463,
                391249.5621381556, 2502278.205988911, 1691881.797742255]

     See also function `central_moment'.


 -- Function: central_moment (<list>, <k>)
 -- Function: central_moment (<matrix>, <k>)
     The central moment of order k, defined as
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) central_moment (s2, 3);
          (%o6) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     See also functions `central_moment' and `mean'.


 -- Function: cv (<list>)
 -- Function: cv (<matrix>)
     The variation coefficient is the quotient between the sample
     standard deviation (`std') and the `mean',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     See also functions `std' and `mean'.


 -- Function: mini (<list>)
 -- Function: mini (<matrix>)
     This is the minimum value of the sample <list>,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mini (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mini (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     See also function `maxi'.


 -- Function: maxi (<list>)
 -- Function: maxi (<matrix>)
     This is the maximum value of the sample <list>,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) maxi (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) maxi (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     See also function `mini'.


 -- Function: range (<list>)
 -- Function: range (<matrix>)
     The range is the difference between the extreme values.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]


 -- Function: quantile (<list>, <p>)
 -- Function: quantile (<matrix>, <p>)
     This is the <p>-quantile, with <p> a number in [0, 1], of the
     sample <list>. Although there are several definitions for the
     sample quantile (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles
     in statistical packages>. American Statistician, 50, 361-365), the
     one based on linear interpolation is implemented in package
     `descriptive'.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]


 -- Function: median (<list>)
 -- Function: median (<matrix>)
     Once the sample is ordered, if the sample size is odd the median
     is the central value, otherwise it is the mean of the two central
     values.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     The median is the 1/2-quantile.

     See also function `quantile'.


 -- Function: qrange (<list>)
 -- Function: qrange (<matrix>)
     The interquartilic range is the difference between the third and
     first quartiles, `quantile(<list>,3/4) - quantile(<list>,1/4)',

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.022500000000001,
                                      8.729999999999999, 6.649999999999999]

     See also function `quantile'.


 -- Function: mean_deviation (<list>)
 -- Function: mean_deviation (<matrix>)
     The mean deviation, defined as
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     See also function `mean'.


 -- Function: median_deviation (<list>)
 -- Function: median_deviation (<matrix>)
     The median deviation, defined as
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     where `med' is the median of <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     See also function `mean'.


 -- Function: harmonic_mean (<list>)
 -- Function: harmonic_mean (<matrix>)
     The harmonic mean, defined as
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     See also functions `mean' and `geometric_mean'.


 -- Function: geometric_mean (<list>)
 -- Function: geometric_mean (<matrix>)
     The geometric mean, defined as
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Example:

          (%i1) load (descriptive)$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     See also functions `mean' and `harmonic_mean'.


 -- Function: kurtosis (<list>)
 -- Function: kurtosis (<matrix>)
     The kurtosis coefficient, defined as
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$

          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
                 - .4275233490482861, - .6405361979019522, - .4952382132352935]

     See also functions `mean', `var' and `skewness'.


 -- Function: skewness (<list>)
 -- Function: skewness (<matrix>)
     The skewness coefficient, defined as
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450424
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000978, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890831]

     See also functions `mean', `var' and `kurtosis'.


 -- Function: pearson_skewness (<list>)
 -- Function: pearson_skewness (<matrix>)
     Pearson's skewness coefficient, defined as
                          _
                       3 (x - med)
                       -----------
                            s
     where <med> is the median of <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     See also functions `mean', `var' and `median'.


 -- Function: quartile_skewness (<list>)
 -- Function: quartile_skewness (<matrix>)
     The quartile skewness coefficient, defined as
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     where c_p is the <p>-quantile of sample <list>.

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, .2105263157894735]

     See also function `quantile'.



File: maxima.info,  Node: Functions and Variables for specific multivariate descriptive statistics,  Next: Functions and Variables for statistical graphs,  Prev: Functions and Variables for descriptive statistics,  Up: Package descriptive

35.4 Functions and Variables for specific multivariate descriptive statistics
=============================================================================

 -- Function: cov (<matrix>)
     The covariance matrix of the multivariate sample, defined as
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
          (%i4) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     See also function `cov1'.


 -- Function: cov1 (<matrix>)
     The covariance matrix of the multivariate sample, defined as
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
          (%i4) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     See also function `cov'.


 -- Function: global_variances (<matrix>)
 -- Function: global_variances (<matrix>, <logical_value>)
     Function `global_variances' returns a list of global variance
     measures:

        * <total variance>: `trace(S_1)',

        * <mean variance>: `trace(S_1)/p',

        * <generalized variance>: `determinant(S_1)',

        * <generalized standard deviation>: `sqrt(determinant(S_1))',

        * <efective variance> `determinant(S_1)^(1/p)', (defined in:
          PeÃ±a, D.  (2002) <AnÃ¡lisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <efective standard deviation>: `determinant(S_1)^(1/(2*p))'.
     where <p> is the dimension of the multivariate random variable and
     S_1 the covariance matrix returned by `cov1'.

     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     Function `global_variances' has an optional logical argument:
     `global_variances(x,true)' tells Maxima that `x' is the data
     matrix, making the same as `global_variances(x)'. On the other
     hand, `global_variances(x,false)' means that `x' is not the data
     matrix, but the covariance matrix, avoiding its recalculation,

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     See also `cov' and `cov1'.


 -- Function: cor (<matrix>)
 -- Function: cor (<matrix>, <logical_value>)
     The correlation matrix of the multivariate sample.

     Example:

          (%i1) load (descriptive)$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Function `cor' has an optional logical argument: `cor(x,true)'
     tells Maxima that `x' is the data matrix, making the same as
     `cor(x)'. On the other hand, `cor(x,false)' means that `x' is not
     the data matrix, but the covariance matrix, avoiding its
     recalculation,

          (%i1) load (descriptive)$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     See also `cov' and `cov1'.


 -- Function: list_correlations (<matrix>)
 -- Function: list_correlations (<matrix>, <logical_value>)
     Function `list_correlations' returns a list of correlation
     measures:

        * <precision matrix>: the inverse of the covariance matrix S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <multiple correlation vector>:  (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          being an indicator of the goodness of fit of the linear
          multivariate regression model on X_i when the rest of
          variables are used as regressors.

        * <partial correlation matrix>: with element (i, j) being
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Example:

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
          (%i5) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i6) z[2];  /* multiple correlation vector */
          (%o6)      [.85063, .80634, .86474, .71867, .72675]
          (%i7) z[3];  /* partial correlation matrix */
                [  - 1.0     .38244   .36627   .49908   - .13049 ]
                [                                                ]
                [  .38244    - 1.0    .37927  - .19907   .23492  ]
                [                                                ]
          (%o7) [  .36627    .37927   - 1.0    .10911    .37956  ]
                [                                                ]
                [  .49908   - .19907  .10911   - 1.0     .26719  ]
                [                                                ]
                [ - .13049   .23492   .37956   .26719    - 1.0   ]

     Function `list_correlations' also has an optional logical argument:
     `list_correlations(x,true)' tells Maxima that `x' is the data
     matrix, making the same as `list_correlations(x)'. On the other
     hand, `list_correlations(x,false)' means that `x' is not the data
     matrix, but the covariance matrix, avoiding its recalculation.

     See also `cov' and `cov1'.



File: maxima.info,  Node: Functions and Variables for statistical graphs,  Prev: Functions and Variables for specific multivariate descriptive statistics,  Up: Package descriptive

35.5 Functions and Variables for statistical graphs
===================================================

 -- Function: histogram (<list>)
 -- Function: histogram (<list>, <option_1>, <option_2>, ...)
 -- Function: histogram (<one_column_matrix>)
 -- Function: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Function: histogram (<one_row_matrix>)
 -- Function: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
     This function plots an histogram from a continuous sample. Sample
     data must be stored in a list of numbers or a one dimensional
     matrix.

     Available options are:

        * Those defined in the `draw' package. See also `bars' and
          `barsplot'.

        * <nclasses>: number of classes of the histogram (10 by
          default).

     See also `discrete_freq' and `continuous_freq' to count data, and
     `bars' and `barsplot' to display bar graphs.

     Examples:

     A simple histogram with eight classes.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = 8,
                     title        = "pi digits",
                     xlabel       = "digits",
                     ylabel       = "Absolute frequency",
                     fill_color   = grey,
                     fill_density = 0.6)$


 -- Function: scatterplot (<list>)
 -- Function: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Function: scatterplot (<matrix>)
 -- Function: scatterplot (<matrix>, <option_1>, <option_2>, ...)
     Plots scatter diagrams both for univariate (<list>) and
     multivariate (<matrix>) samples.

     Available options are:

        * Those defined in the `draw' package.

        * <nclasses>: number of classes of the histogram (10 by
          default).

     Examples:

     Univariate scatter diagram from a simulated Gaussian sample.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
                  random_normal(0,1,200),
                  xaxis      = true,
                  point_size = 2,
                  terminal   = eps,
                  eps_width  = 10,
                  eps_height = 2)$

     Two dimensional scatter plot.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                 submatrix(s2, 1,2,3),
                 title      = "Data from stations #4 and #5",
                 point_type = diamant,
                 point_size = 2,
                 color      = blue)$

     Three dimensional scatter plot.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2))$

     Five dimensional scatter plot, with five classes histograms.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                  s2,
                  nclasses     = 5,
                  fill_color   = blue,
                  fill_density = 0.3,
                  xtics        = 5)$

     For plotting isolated or line-joined points in two and three
     dimensions, see `points'. For histogram related options, see
     `bars'.

     See also `histogram'.


 -- Function: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
     Plots bars diagrams for discrete statistical variables, both for
     one or multiple samples.

     <data> can be a list of outcomes representing one sample, or a
     matrix of <m> rows and <n> columns, representing <n> samples of
     size <m> each.

     Available options are:

        * Those defined in the `draw' package.

        * <box_width>: relative width of rectangles (`3/4' by default).
          This value must be in the range `[0,1]'.

        * <groups_gap>: a positive integer number representing the gap
          between two consecutive groups of bars. Default value is 1.

        * <bars_colors>: a list of colors for multiple samples.
          Defaults to the empty list `[]'. When there are more samples
          than specified colors, the extra necesary colors are chosen
          at random. See `color' to learn more about them.

        * <relative_frequencies>: if `false', absolute frequencies are
          used; if `true', tics on the <y>-axis are relative
          frequencies.  Default value is `false'.

        * <ordering>: possible values are `orderlessp' or `ordergreatp',
          indicating how statistical outcomes should be ordered on the
          <x>-axis.  Default value is `orderlessp'.

        * <sample_keys>: a list with the strings to be used in the
          legend. Defaults to the empty list `[]'. When the list length
          is other than 0 or the number of samples, an error message is
          returned.


     Examples:

     Univariate sample in matrix form. Absolute frequencies.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Two samples of different sizes, with relative frequencies and user
     declared colors.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  relative_frequencies = true,
                  sample_keys = ["A", "B"])$

     Four non numeric samples of equal size.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     `barsplot' in a multiplot context.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) draw_compound : false $
          (%i5) bp1 :
                  barsplot(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   relative_frequencies = true)$
          (%i6) bp2 :
                  barsplot(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   relative_frequencies = true)$
          (%i7) draw(apply(gr2d,bp1),
                     apply(gr2d,bp2)) $

     For bars diagrams related options, see `bars' of package `draw'.
     See also functions `histogram' and `piechart'.


 -- Function: piechart (<list>)
 -- Function: piechart (<list>, <option_1>, <option_2>, ...)
 -- Function: piechart (<one_column_matrix>)
 -- Function: piechart (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Function: piechart (<one_row_matrix>)
 -- Function: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
     Similar to `barsplot', but plots sectors instead of rectangles.

     Available options are:

        * Those defined in the `draw' package.

        * <pie_center>: diagram's center (`[0,0]' by default).

        * <pie_radius>: diagram's radius (1 by default).

     Example:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
                  s1,
                  xrange      = [-1.1, 1.3],
                  yrange      = [-1.1, 1.1],
                  axis_top    = false,
                  axis_right  = false,
                  axis_left   = false,
                  axis_bottom = false,
                  xtics       = none,
                  ytics       = none,
                  title       = "Digit frequencies in pi")$

     See also function `barsplot'.


 -- Function: boxplot (<data>)
 -- Function: boxplot (<data>, <option_1>, <option_2>, ...)
     This function plots box-and-whishker diagrams. Argument <data> can
     be a list, which is not of great interest, since these diagrams
     are mainly used for comparing different samples, or a matrix, so
     it is possible to compare two or more components of a multivariate
     statistical variable.  But it is also allowed <data> to be a list
     of samples with possible different sample sizes, in fact this is
     the only function in package `descriptive' that admits this type
     of data structure.

     Available options are:

        * Those defined in the `draw' package.

        * <box_width>: relative width of boxes (`3/4' by default). This
          value must be in the range `[0,1]'.

     Examples:

     Box-and-whishker diagram from a multivariate sample.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
                  box_width  = 0.2,
                  title      = "Windspeed in knots",
                  xlabel     = "Stations",
                  color      = red,
                  line_width = 2)$

     Box-and-whishker diagram from three samples of different sizes.

          (%i1) load (descriptive)$
          (%i2) A :
                 [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
                  [8, 10, 7, 9, 12, 8, 10],
                  [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A)$



File: maxima.info,  Node: diag,  Next: Package distrib,  Prev: Package descriptive,  Up: Top

36 diag
*******

* Menu:

* Functions and Variables for diag::


File: maxima.info,  Node: Functions and Variables for diag,  Prev: diag,  Up: diag

36.1 Functions and Variables for diag
=====================================

 -- Function: diag (<lm>)
     Constructs a square matrix with the matrices of <lm> in the
     diagonal.  <lm> is a list of matrices or scalars.

     Example:

          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     To use this function write first `load("diag")'.


 -- Function: JF (<lambda>,<n>)
     Returns the Jordan cell of order <n> with eigenvalue <lambda>.

     Example:

          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     To use this function write first `load("diag")'.


 -- Function: jordan (<mat>)
     Returns the Jordan form of matrix <mat>, but codified in a Maxima
     list.  To get the corresponding matrix, call function `dispJordan'
     using as argument the output of `jordan'.

     Example:

          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     To use this function write first `load("diag")'. See also
     `dispJordan' and `minimalPoly'.


 -- Function: dispJordan (<l>)
     Returns the Jordan matrix associated to the codification given by
     the Maxima list <l>, which is the output given by function
     `jordan'.

     Example:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     To use this function write first `load("diag")'. See also `jordan'
     and `minimalPoly'.


 -- Function: minimalPoly (<l>)
     Returns the minimal polynomial associated to the codification
     given by the Maxima list <l>, which is the output given by
     function `jordan'.

     Example:

          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     To use this function write first `load("diag")'. See also `jordan'
     and `dispJordan'.


 -- Function: ModeMatrix (<A>,<l>)
     Returns the matrix <M> such that (M^^-1).A.M=J, where <J> is the
     Jordan form of <A>. The Maxima list <l> is the codified form of
     the Jordan form as returned by function `jordan'.

     Example:

          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true

     Note that `dispJordan(%o3)' is the Jordan form of matrix `a'.

     To use this function write first `load("diag")'. See also `jordan'
     and `dispJordan'.


 -- Function: mat_function (<f>,<mat>)
     Returns f(mat), where <f> is an analytic function and <mat> a
     matrix. This computation is based on Cauchy's integral formula,
     which states that if `f(x)' is analytic and

          mat = diag([JF(m1,n1),...,JF(mk,nk)]),

     then

          f(mat) = ModeMatrix*diag([f(JF(m1,n1)), ..., f(JF(mk,nk))])
                                                        *ModeMatrix^^(-1)

     Note that there are about 6 or 8 other methods for this
     calculation.

     Some examples follow.

     Example 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Example 2:

          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Example 3:

          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     To use this function write first `load("diag")'.



File: maxima.info,  Node: Package distrib,  Next: draw,  Prev: diag,  Up: Top

37 Package distrib
******************

* Menu:

* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::


File: maxima.info,  Node: Introduction to distrib,  Next: Functions and Variables for continuous distributions,  Prev: Package distrib,  Up: Package distrib

37.1 Introduction to distrib
============================

Package `distrib' contains a set of functions for making probability
computations on both discrete and continuous univariate models.

   What follows is a short reminder of basic probabilistic related
definitions.

   Let f(x) be the <density function> of an absolute continuous random
variable X. The <distribution function> is defined as
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   which equals the probability <Pr(X <= x)>.

   The <mean> value is a localization parameter and is defined as
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   The <variance> is a measure of variation,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   which is a positive real number. The square root of the variance is
the <standard deviation>, D[X]=sqrt(V[X]), and it is another measure of
variation.

   The <skewness coefficient> is a measure of non-symmetry,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   And the <kurtosis coefficient> measures the peakedness of the
distribution,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   If X is gaussian, KU[X]=0. In fact, both skewness and kurtosis are
shape parameters used to measure the non-gaussianity of a distribution.

   If the random variable X is discrete, the density, or <probability>,
function f(x) takes positive values within certain countable set of
numbers x_i, and zero elsewhere. In this case, the distribution function
is
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   The mean, variance, standard deviation, skewness coefficient and
kurtosis coefficient take the form
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectively.

   There is a naming convention in package `distrib'. Every function
name has two parts, the first one makes reference to the function or
parameter we want to calculate,
     Functions:
        Density function            (pdf_*)
        Distribution function       (cdf_*)
        Quantile                    (quantile_*)
        Mean                        (mean_*)
        Variance                    (var_*)
        Standard deviation          (std_*)
        Skewness coefficient        (skewness_*)
        Kurtosis coefficient        (kurtosis_*)
        Random variate              (random_*)

   The second part is an explicit reference to the probabilistic model,
     Continuous distributions:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Noncentral Chi^2    (*noncentral_chi2)
        F                   (*f)
        Exponential         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continuous uniform  (*continuous_uniform)
        Logistic            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Discrete distributions:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geometric            (*geometric)
        Discrete uniform     (*discrete_uniform)
        hypergeometric       (*hypergeometric)
        Negative binomial    (*negative_binomial)

   For example, `pdf_student_t(x,n)' is the density function of the
Student distribution with <n> degrees of freedom, `std_pareto(a,b)' is
the standard deviation of the Pareto distribution with parameters <a>
and <b> and `kurtosis_poisson(m)' is the kurtosis coefficient of the
Poisson distribution with mean <m>.

   In order to make use of package `distrib' you need first to load it
by typing
     (%i1) load(distrib)$

   For comments, bugs or suggestions, please contact the author at
<'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Functions and Variables for continuous distributions,  Next: Functions and Variables for discrete distributions,  Prev: Introduction to distrib,  Up: Package distrib

37.2 Functions and Variables for continuous distributions
=========================================================

 -- Function: pdf_normal (<x>,<m>,<s>)
     Returns the value at <x> of the density function of a Normal(m,s)
     random variable, with s>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_normal (<x>,<m>,<s>)
     Returns the value at <x> of the distribution function of a
     Normal(m,s) random variable, with s>0. This function is defined in
     terms of Maxima's built-in error function `erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     See also `erf'.


 -- Function: quantile_normal (<q>,<m>,<s>)
     Returns the <q>-quantile of a Normal(m,s) random variable, with
     s>0; in other words, this is the inverse of `cdf_normal'. Argument
     <q> must be an element of [0,1]. To make use of this function,
     write first `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472


 -- Function: mean_normal (<m>,<s>)
     Returns the mean of a Normal(m,s) random variable, with s>0,
     namely <m>. To make use of this function, write first
     `load(distrib)'.


 -- Function: var_normal (<m>,<s>)
     Returns the variance of a Normal(m,s) random variable, with s>0,
     namely <s^2>. To make use of this function, write first
     `load(distrib)'.


 -- Function: std_normal (<m>,<s>)
     Returns the standard deviation of a Normal(m,s) random variable,
     with s>0, namely <s>. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_normal (<m>,<s>)
     Returns the skewness coefficient of a Normal(m,s) random variable,
     with s>0, which is always equal to 0. To make use of this
     function, write first `load(distrib)'.


 -- Function: kurtosis_normal (<m>,<s>)
     Returns the kurtosis coefficient of a Normal(m,s) random variable,
     with s>0, which is always equal to 0. To make use of this
     function, write first `load(distrib)'.


 -- Function: random_normal (<m>,<s>)
 -- Function: random_normal (<m>,<s>,<n>)
     Returns a Normal(m,s) random variate, with s>0. Calling
     `random_normal' with a third argument <n>, a random sample of size
     <n> will be simulated.

     This is an implementation of the Box-Mueller algorithm, as
     described in Knuth, D.E. (1981) <Seminumerical Algorithms. The Art
     of Computer Programming.> Addison-Wesley.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_student_t (<x>,<n>)
     Returns the value at <x> of the density function of a Student
     random variable t(n), with n>0 degrees of freedom. To make use of
     this function, write first `load(distrib)'.


 -- Function: cdf_student_t (<x>,<n>)
     Returns the value at <x> of the distribution function of a Student
     random variable t(n), with n>0 degrees of freedom.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415


 -- Function: quantile_student_t (<q>,<n>)
     Returns the <q>-quantile of a Student random variable t(n), with
     n>0; in other words, this is the inverse of `cdf_student_t'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_student_t (<n>)
     Returns the mean of a Student random variable t(n), with n>0,
     which is always equal to 0. To make use of this function, write
     first `load(distrib)'.


 -- Function: var_student_t (<n>)
     Returns the variance of a Student random variable t(n), with n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2


 -- Function: std_student_t (<n>)
     Returns the standard deviation of a Student random variable t(n),
     with n>2. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_student_t (<n>)
     Returns the skewness coefficient of a Student random variable
     t(n), with n>3, which is always equal to 0. To make use of this
     function, write first `load(distrib)'.


 -- Function: kurtosis_student_t (<n>)
     Returns the kurtosis coefficient of a Student random variable
     t(n), with n>4. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_student_t (<n>)
 -- Function: random_student_t (<n>,<m>)
     Returns a Student random variate t(n), with n>0. Calling
     `random_student_t' with a second argument <m>, a random sample of
     size <m> will be simulated.

     The implemented algorithm is based on the fact that if <Z> is a
     normal random variable N(0,1) and S^2 is a chi square random
     variable with <n> degrees of freedom, Chi^2(n), then
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /
     is a Student random variable with <n> degrees of freedom, t(n).

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Returns the value at <x> of the density function of a noncentral
     Student random variable nc_t(n,ncp), with n>0 degrees of freedom
     and noncentrality parameter ncp. To make use of this function,
     write first `load(distrib)'.

     Sometimes an extra work is necessary to get the final result.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                 .01370030107589574 sqrt(5)
          (%o2)  --------------------------
                 sqrt(2) sqrt(14) sqrt(%pi)
             1.654562884111515E-4 sqrt(5)
           + ----------------------------
                      sqrt(%pi)
             .02434921505438663 sqrt(5)
           + --------------------------
                        %pi
          (%i3) float(%);
          (%o3)          .02080593159405669


 -- Function: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Returns the value at <x> of the distribution function of a
     noncentral Student random variable nc_t(n,ncp), with n>0 degrees
     of freedom and noncentrality parameter ncp. This function has no
     closed form and it is numerically computed if the global variable
     `numer' equals `true' or at least one of the arguments is a float,
     otherwise it returns a nominal expression.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2) cdf_noncentral_student_t(- 2, 5, - 5)
          (%i3) cdf_noncentral_student_t(-2.0,5,-5);
          (%o3)          .9952030093319743


 -- Function: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Returns the <q>-quantile of a noncentral Student random variable
     nc_t(n,ncp), with n>0 degrees of freedom and noncentrality
     parameter ncp; in other words, this is the inverse of
     `cdf_noncentral_student_t'. Argument <q> must be an element of
     [0,1]. To make use of this function, write first `load(distrib)'.


 -- Function: mean_noncentral_student_t (<n>,<ncp>)
     Returns the mean of a noncentral Student random variable
     nc_t(n,ncp), with n>1 degrees of freedom and noncentrality
     parameter ncp. To make use of this function, write first
     `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) (assume(df>1), mean_noncentral_student_t(df,k));
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2


 -- Function: var_noncentral_student_t (<n>,<ncp>)
     Returns the variance of a noncentral Student random variable
     nc_t(n,ncp), with n>2 degrees of freedom and noncentrality
     parameter ncp. To make use of this function, write first
     `load(distrib)'.


 -- Function: std_noncentral_student_t (<n>,<ncp>)
     Returns the standard deviation of a noncentral Student random
     variable nc_t(n,ncp), with n>2 degrees of freedom and noncentrality
     parameter ncp. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_noncentral_student_t (<n>,<ncp>)
     Returns the skewness coefficient of a noncentral Student random
     variable nc_t(n,ncp), with n>3 degrees of freedom and noncentrality
     parameter ncp. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_noncentral_student_t (<n>,<ncp>)
     Returns the kurtosis coefficient of a noncentral Student random
     variable nc_t(n,ncp), with n>4 degrees of freedom and noncentrality
     parameter ncp. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_noncentral_student_t (<n>,<ncp>)
 -- Function: random_noncentral_student_t (<n>,<ncp>,<m>)
     Returns a noncentral Student random variate nc_t(n,ncp), with n>0.
     Calling `random_noncentral_student_t' with a third argument <m>, a
     random sample of size <m> will be simulated.

     The implemented algorithm is based on the fact that if <X> is a
     normal random variable N(ncp,1) and S^2 is a chi square random
     variable with <n> degrees of freedom, Chi^2(n), then
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /
     is a noncentral Student random variable with <n> degrees of
     freedom and noncentrality parameter ncp, nc_t(n,ncp).

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_chi2 (<x>,<n>)
     Returns the value at <x> of the density function of a Chi-square
     random variable Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma density is returned.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2


 -- Function: cdf_chi2 (<x>,<n>)
     Returns the value at <x> of the distribution function of a
     Chi-square random variable Chi^2(n), with n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256


 -- Function: quantile_chi2 (<q>,<n>)
     Returns the <q>-quantile of a Chi-square random variable Chi^2(n),
     with n>0; in other words, this is the inverse of `cdf_chi2'.
     Argument <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression based on the gamma quantile function, since the
     Chi^2(n) random variable is equivalent to the Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2


 -- Function: mean_chi2 (<n>)
     Returns the mean of a Chi-square random variable Chi^2(n), with
     n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma mean is returned.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n


 -- Function: var_chi2 (<n>)
     Returns the variance of a Chi-square random variable Chi^2(n), with
     n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma variance is returned.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n


 -- Function: std_chi2 (<n>)
     Returns the standard deviation of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma standard deviation is
     returned.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)


 -- Function: skewness_chi2 (<n>)
     Returns the skewness coefficient of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma skewness coefficient is
     returned.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)


 -- Function: kurtosis_chi2 (<n>)
     Returns the kurtosis coefficient of a Chi-square random variable
     Chi^2(n), with n>0.

     The Chi^2(n) random variable is equivalent to the Gamma(n/2,2),
     therefore when Maxima has not enough information to get the
     result, a noun form based on the gamma kurtosis coefficient is
     returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n


 -- Function: random_chi2 (<n>)
 -- Function: random_chi2 (<n>,<m>)
     Returns a Chi-square random variate Chi^2(n), with n>0. Calling
     `random_chi2' with a second argument <m>, a random sample of size
     <m> will be simulated.

     The simulation is based on the Ahrens-Cheng algorithm. See
     `random_gamma' for details.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Returns the value at <x> of the density function of a noncentral
     Chi-square random variable nc_Chi^2(n,ncp), with n>0 and
     noncentrality parameter ncp>=0. To make use of this function,
     write first `load(distrib)'.


 -- Function: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Returns the value at <x> of the distribution function of a
     noncentral Chi-square random variable nc_Chi^2(n,ncp), with n>0 and
     noncentrality parameter ncp>=0. To make use of this function, write
     first `load(distrib)'.


 -- Function: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Returns the <q>-quantile of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0; in other words, this is the inverse of
     `cdf_noncentral_chi2'. Argument <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression.


 -- Function: mean_noncentral_chi2 (<n>,<ncp>)
     Returns the mean of a noncentral Chi-square random variable
     nc_Chi^2(n,ncp), with n>0 and noncentrality parameter ncp>=0.


 -- Function: var_noncentral_chi2 (<n>,<ncp>)
     Returns the variance of a noncentral Chi-square random variable
     nc_Chi^2(n,ncp), with n>0 and noncentrality parameter ncp>=0.


 -- Function: std_noncentral_chi2 (<n>,<ncp>)
     Returns the standard deviation of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.


 -- Function: skewness_noncentral_chi2 (<n>,<ncp>)
     Returns the skewness coefficient of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.


 -- Function: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Returns the kurtosis coefficient of a noncentral Chi-square random
     variable nc_Chi^2(n,ncp), with n>0 and noncentrality parameter
     ncp>=0.


 -- Function: random_noncentral_chi2 (<n>,<ncp>)
 -- Function: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Returns a noncentral Chi-square random variate nc_Chi^2(n,ncp),
     with n>0 and noncentrality parameter ncp>=0. Calling
     `random_noncentral_chi2' with a third argument <m>, a random
     sample of size <m> will be simulated.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_f (<x>,<m>,<n>)
     Returns the value at <x> of the density function of a F random
     variable F(m,n), with m,n>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_f (<x>,<m>,<n>)
     Returns the value at <x> of the distribution function of a F
     random variable F(m,n), with m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008


 -- Function: quantile_f (<q>,<m>,<n>)
     Returns the <q>-quantile of a F random variable F(m,n), with
     m,n>0; in other words, this is the inverse of `cdf_f'. Argument
     <q> must be an element of [0,1].

     This function has no closed form and it is numerically computed if
     the global variable `numer' equals `true',  otherwise it returns a
     nominal expression.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693


 -- Function: mean_f (<m>,<n>)
     Returns the mean of a F random variable F(m,n), with m>0, n>2. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_f (<m>,<n>)
     Returns the variance of a F random variable F(m,n), with m>0, n>4.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_f (<m>,<n>)
     Returns the standard deviation of a F random variable F(m,n), with
     m>0, n>4. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_f (<m>,<n>)
     Returns the skewness coefficient of a F random variable F(m,n),
     with m>0, n>6. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_f (<m>,<n>)
     Returns the kurtosis coefficient of a F random variable F(m,n),
     with m>0, n>8. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_f (<m>,<n>)
 -- Function: random_f (<m>,<n>,<k>)
     Returns a F random variate F(m,n), with m,n>0. Calling `random_f'
     with a third argument <k>, a random sample of size <k> will be
     simulated.

     The simulation algorithm is based on the fact that if <X> is a
     Chi^2(m) random variable and Y is a Chi^2(n) random variable, then
                                  n X
                              F = ---
                                  m Y
     is a F random variable with <m> and <n> degrees of freedom, F(m,n).

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_exp (<x>,<m>)
     Returns the value at <x> of the density function of an
     Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull density is
     returned.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e


 -- Function: cdf_exp (<x>,<m>)
     Returns the value at <x> of the distribution function of an
     Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull distribution
     is returned.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e


 -- Function: quantile_exp (<q>,<m>)
     Returns the <q>-quantile of an Exponential(m) random variable,
     with m>0; in other words, this is the inverse of `cdf_exp'.
     Argument <q> must be an element of [0,1].

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull quantile is
     returned.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m


 -- Function: mean_exp (<m>)
     Returns the mean of an Exponential(m) random variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull mean is
     returned.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m


 -- Function: var_exp (<m>)
     Returns the variance of an Exponential(m) random variable, with
     m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m


 -- Function: std_exp (<m>)
     Returns the standard deviation of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m


 -- Function: skewness_exp (<m>)
     Returns the skewness coefficient of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2


 -- Function: kurtosis_exp (<m>)
     Returns the kurtosis coefficient of an Exponential(m) random
     variable, with m>0.

     The Exponential(m) random variable is equivalent to the
     Weibull(1,1/m), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6


 -- Function: random_exp (<m>)
 -- Function: random_exp (<m>,<k>)
     Returns an Exponential(m) random variate, with m>0. Calling
     `random_exp' with a second argument <k>, a random sample of size
     <k> will be simulated.

     The simulation algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_lognormal (<x>,<m>,<s>)
     Returns the value at <x> of the density function of a
     Lognormal(m,s) random variable, with s>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: cdf_lognormal (<x>,<m>,<s>)
     Returns the value at <x> of the distribution function of a
     Lognormal(m,s) random variable, with s>0. This function is defined
     in terms of Maxima's built-in error function `erf'.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     See also `erf'.


 -- Function: quantile_lognormal (<q>,<m>,<s>)
     Returns the <q>-quantile of a Lognormal(m,s) random variable, with
     s>0; in other words, this is the inverse of `cdf_lognormal'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_lognormal(95/100,0,1);
                            sqrt(2) inverse_erf(9/10)
          (%o2)           %e
          (%i3) float(%);
          (%o3)               5.180251602233015


 -- Function: mean_lognormal (<m>,<s>)
     Returns the mean of a Lognormal(m,s) random variable, with s>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_lognormal (<m>,<s>)
     Returns the variance of a Lognormal(m,s) random variable, with
     s>0. To make use of this function, write first `load(distrib)'.


 -- Function: std_lognormal (<m>,<s>)
     Returns the standard deviation of a Lognormal(m,s) random
     variable, with s>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_lognormal (<m>,<s>)
     Returns the skewness coefficient of a Lognormal(m,s) random
     variable, with s>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_lognormal (<m>,<s>)
     Returns the kurtosis coefficient of a Lognormal(m,s) random
     variable, with s>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_lognormal (<m>,<s>)
 -- Function: random_lognormal (<m>,<s>,<n>)
     Returns a Lognormal(m,s) random variate, with s>0. Calling
     `random_lognormal' with a third argument <n>, a random sample of
     size <n> will be simulated.

     Log-normal variates are simulated by means of random normal
     variates. See `random_normal' for details.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_gamma (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Gamma(a,b)
     random variable, with a,b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_gamma (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Gamma(a,b) random variable, with a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7


 -- Function: quantile_gamma (<q>,<a>,<b>)
     Returns the <q>-quantile of a Gamma(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_gamma'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_gamma (<a>,<b>)
     Returns the mean of a Gamma(a,b) random variable, with a,b>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_gamma (<a>,<b>)
     Returns the variance of a Gamma(a,b) random variable, with a,b>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_gamma (<a>,<b>)
     Returns the standard deviation of a Gamma(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_gamma (<a>,<b>)
     Returns the skewness coefficient of a Gamma(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_gamma (<a>,<b>)
     Returns the kurtosis coefficient of a Gamma(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_gamma (<a>,<b>)
 -- Function: random_gamma (<a>,<b>,<n>)
     Returns a Gamma(a,b) random variate, with a,b>0. Calling
     `random_gamma' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is a combinantion of two procedures,
     depending on the value of parameter <a>:

     For a>=1, Cheng, R.C.H. and Feast, G.M. (1979). <Some simple gamma
     variate generators>. Appl. Stat., 28, 3, 290-295.

     For 0<a<1, Ahrens, J.H. and Dieter, U. (1974). <Computer methods
     for sampling from gamma, beta, poisson and binomial
     cdf_tributions>. Computing, 12, 223-246.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_beta (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Beta(a,b)
     random variable, with a,b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_beta (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Beta(a,b) random variable, with a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7


 -- Function: quantile_beta (<q>,<a>,<b>)
     Returns the <q>-quantile of a Beta(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_beta'. Argument
     <q> must be an element of [0,1]. To make use of this function,
     write first `load(distrib)'.


 -- Function: mean_beta (<a>,<b>)
     Returns the mean of a Beta(a,b) random variable, with a,b>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_beta (<a>,<b>)
     Returns the variance of a Beta(a,b) random variable, with a,b>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_beta (<a>,<b>)
     Returns the standard deviation of a Beta(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_beta (<a>,<b>)
     Returns the skewness coefficient of a Beta(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_beta (<a>,<b>)
     Returns the kurtosis coefficient of a Beta(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_beta (<a>,<b>)
 -- Function: random_beta (<a>,<b>,<n>)
     Returns a Beta(a,b) random variate, with a,b>0. Calling
     `random_beta' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is defined in Cheng, R.C.H.  (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_continuous_uniform (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Continuous
     Uniform(a,b) random variable, with a<b. To make use of this
     function, write first `load(distrib)'.


 -- Function: cdf_continuous_uniform (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Continuous Uniform(a,b) random variable, with a<b. To make use of
     this function, write first `load(distrib)'.


 -- Function: quantile_continuous_uniform (<q>,<a>,<b>)
     Returns the <q>-quantile of a Continuous Uniform(a,b) random
     variable, with a<b; in other words, this is the inverse of
     `cdf_continuous_uniform'. Argument <q> must be an element of
     [0,1]. To make use of this function, write first `load(distrib)'.


 -- Function: mean_continuous_uniform (<a>,<b>)
     Returns the mean of a Continuous Uniform(a,b) random variable,
     with a<b. To make use of this function, write first
     `load(distrib)'.


 -- Function: var_continuous_uniform (<a>,<b>)
     Returns the variance of a Continuous Uniform(a,b) random variable,
     with a<b. To make use of this function, write first
     `load(distrib)'.


 -- Function: std_continuous_uniform (<a>,<b>)
     Returns the standard deviation of a Continuous Uniform(a,b) random
     variable, with a<b. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_continuous_uniform (<a>,<b>)
     Returns the skewness coefficient of a Continuous Uniform(a,b)
     random variable, with a<b. To make use of this function, write
     first `load(distrib)'.


 -- Function: kurtosis_continuous_uniform (<a>,<b>)
     Returns the kurtosis coefficient of a Continuous Uniform(a,b)
     random variable, with a<b. To make use of this function, write
     first `load(distrib)'.


 -- Function: random_continuous_uniform (<a>,<b>)
 -- Function: random_continuous_uniform (<a>,<b>,<n>)
     Returns a Continuous Uniform(a,b) random variate, with a<b.
     Calling `random_continuous_uniform' with a third argument <n>, a
     random sample of size <n> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'. To make use of this function, write first
     `load(distrib)'.


 -- Function: pdf_logistic (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a
     Logistic(a,b) random variable , with b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: cdf_logistic (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Logistic(a,b) random variable , with b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_logistic (<q>,<a>,<b>)
     Returns the <q>-quantile of a Logistic(a,b) random variable , with
     b>0; in other words, this is the inverse of `cdf_logistic'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_logistic (<a>,<b>)
     Returns the mean of a Logistic(a,b) random variable , with b>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_logistic (<a>,<b>)
     Returns the variance of a Logistic(a,b) random variable , with
     b>0. To make use of this function, write first `load(distrib)'.


 -- Function: std_logistic (<a>,<b>)
     Returns the standard deviation of a Logistic(a,b) random variable
     , with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_logistic (<a>,<b>)
     Returns the skewness coefficient of a Logistic(a,b) random
     variable , with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_logistic (<a>,<b>)
     Returns the kurtosis coefficient of a Logistic(a,b) random
     variable , with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_logistic (<a>,<b>)
 -- Function: random_logistic (<a>,<b>,<n>)
     Returns a Logistic(a,b) random variate, with b>0. Calling
     `random_logistic' with a third argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_pareto (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Pareto(a,b)
     random variable, with a,b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_pareto (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Pareto(a,b) random variable, with a,b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_pareto (<q>,<a>,<b>)
     Returns the <q>-quantile of a Pareto(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_pareto'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_pareto (<a>,<b>)
     Returns the mean of a Pareto(a,b) random variable, with a>1,b>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: var_pareto (<a>,<b>)
     Returns the variance of a Pareto(a,b) random variable, with
     a>2,b>0. To make use of this function, write first `load(distrib)'.


 -- Function: std_pareto (<a>,<b>)
     Returns the standard deviation of a Pareto(a,b) random variable,
     with a>2,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_pareto (<a>,<b>)
     Returns the skewness coefficient of a Pareto(a,b) random variable,
     with a>3,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_pareto (<a>,<b>)
     Returns the kurtosis coefficient of a Pareto(a,b) random variable,
     with a>4,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_pareto (<a>,<b>)
 -- Function: random_pareto (<a>,<b>,<n>)
     Returns a Pareto(a,b) random variate, with a>0,b>0. Calling
     `random_pareto' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_weibull (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Weibull(a,b)
     random variable, with a,b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_weibull (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Weibull(a,b) random variable, with a,b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_weibull (<q>,<a>,<b>)
     Returns the <q>-quantile of a Weibull(a,b) random variable, with
     a,b>0; in other words, this is the inverse of `cdf_weibull'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_weibull (<a>,<b>)
     Returns the mean of a Weibull(a,b) random variable, with a,b>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_weibull (<a>,<b>)
     Returns the variance of a Weibull(a,b) random variable, with
     a,b>0. To make use of this function, write first `load(distrib)'.


 -- Function: std_weibull (<a>,<b>)
     Returns the standard deviation of a Weibull(a,b) random variable,
     with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_weibull (<a>,<b>)
     Returns the skewness coefficient of a Weibull(a,b) random
     variable, with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_weibull (<a>,<b>)
     Returns the kurtosis coefficient of a Weibull(a,b) random
     variable, with a,b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_weibull (<a>,<b>)
 -- Function: random_weibull (<a>,<b>,<n>)
     Returns a Weibull(a,b) random variate, with a,b>0. Calling
     `random_weibull' with a third argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_rayleigh (<x>,<b>)
     Returns the value at <x> of the density function of a Rayleigh(b)
     random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull density is
     returned.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e


 -- Function: cdf_rayleigh (<x>,<b>)
     Returns the value at <x> of the distribution function of a
     Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull distribution
     is returned.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e


 -- Function: quantile_rayleigh (<q>,<b>)
     Returns the <q>-quantile of a Rayleigh(b) random variable, with
     b>0; in other words, this is the inverse of `cdf_rayleigh'.
     Argument <q> must be an element of [0,1].

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull quantile is
     returned.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b


 -- Function: mean_rayleigh (<b>)
     Returns the mean of a Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull mean is
     returned.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b


 -- Function: var_rayleigh (<b>)
     Returns the variance of a Rayleigh(b) random variable, with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b


 -- Function: std_rayleigh (<b>)
     Returns the standard deviation of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b


 -- Function: skewness_rayleigh (<b>)
     Returns the skewness coefficient of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4


 -- Function: kurtosis_rayleigh (<b>)
     Returns the kurtosis coefficient of a Rayleigh(b) random variable,
     with b>0.

     The Rayleigh(b) random variable is equivalent to the
     Weibull(2,1/b), therefore when Maxima has not enough information
     to get the result, a noun form based on the Weibull kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4


 -- Function: random_rayleigh (<b>)
 -- Function: random_rayleigh (<b>,<n>)
     Returns a Rayleigh(b) random variate, with b>0. Calling
     `random_rayleigh' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_laplace (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Laplace(a,b)
     random variable, with b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_laplace (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Laplace(a,b) random variable, with b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_laplace (<q>,<a>,<b>)
     Returns the <q>-quantile of a Laplace(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_laplace'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_laplace (<a>,<b>)
     Returns the mean of a Laplace(a,b) random variable, with b>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_laplace (<a>,<b>)
     Returns the variance of a Laplace(a,b) random variable, with b>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_laplace (<a>,<b>)
     Returns the standard deviation of a Laplace(a,b) random variable,
     with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_laplace (<a>,<b>)
     Returns the skewness coefficient of a Laplace(a,b) random
     variable, with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_laplace (<a>,<b>)
     Returns the kurtosis coefficient of a Laplace(a,b) random
     variable, with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_laplace (<a>,<b>)
 -- Function: random_laplace (<a>,<b>,<n>)
     Returns a Laplace(a,b) random variate, with b>0. Calling
     `random_laplace' with a third argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_cauchy (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Cauchy(a,b)
     random variable, with b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_cauchy (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Cauchy(a,b) random variable, with b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_cauchy (<q>,<a>,<b>)
     Returns the <q>-quantile of a Cauchy(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_cauchy'. Argument
     <q> must be an element of [0,1]. To make use of this function,
     write first `load(distrib)'.


 -- Function: random_cauchy (<a>,<b>)
 -- Function: random_cauchy (<a>,<b>,<n>)
     Returns a Cauchy(a,b) random variate, with b>0. Calling
     `random_cauchy' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_gumbel (<x>,<a>,<b>)
     Returns the value at <x> of the density function of a Gumbel(a,b)
     random variable, with b>0. To make use of this function, write
     first `load(distrib)'.


 -- Function: cdf_gumbel (<x>,<a>,<b>)
     Returns the value at <x> of the distribution function of a
     Gumbel(a,b) random variable, with b>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_gumbel (<q>,<a>,<b>)
     Returns the <q>-quantile of a Gumbel(a,b) random variable, with
     b>0; in other words, this is the inverse of `cdf_gumbel'. Argument
     <q> must be an element of [0,1]. To make use of this function,
     write first `load(distrib)'.


 -- Function: mean_gumbel (<a>,<b>)
     Returns the mean of a Gumbel(a,b) random variable, with b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     where symbol `%gamma' stands for the Euler-Mascheroni constant.
     See also `%gamma'.


 -- Function: var_gumbel (<a>,<b>)
     Returns the variance of a Gumbel(a,b) random variable, with b>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_gumbel (<a>,<b>)
     Returns the standard deviation of a Gumbel(a,b) random variable,
     with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_gumbel (<a>,<b>)
     Returns the skewness coefficient of a Gumbel(a,b) random variable,
     with b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     where `zeta' stands for the Riemann's zeta function.


 -- Function: kurtosis_gumbel (<a>,<b>)
     Returns the kurtosis coefficient of a Gumbel(a,b) random variable,
     with b>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_gumbel (<a>,<b>)
 -- Function: random_gumbel (<a>,<b>,<n>)
     Returns a Gumbel(a,b) random variate, with b>0. Calling
     `random_gumbel' with a third argument <n>, a random sample of size
     <n> will be simulated.

     The implemented algorithm is based on the general inverse method.

     To make use of this function, write first `load(distrib)'.



File: maxima.info,  Node: Functions and Variables for discrete distributions,  Prev: Functions and Variables for continuous distributions,  Up: Package distrib

37.3 Functions and Variables for discrete distributions
=======================================================

 -- Function: pdf_binomial (<x>,<n>,<p>)
     Returns the value at <x> of the probability function of a
     Binomial(n,p) random variable, with 0<p<1 and n a positive
     integer. To make use of this function, write first `load(distrib)'.


 -- Function: cdf_binomial (<x>,<n>,<p>)
     Returns the value at <x> of the distribution function of a
     Binomial(n,p) random variable, with 0<p<1 and n a positive integer.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548


 -- Function: quantile_binomial (<q>,<n>,<p>)
     Returns the <q>-quantile of a Binomial(n,p) random variable, with
     0<p<1 and n a positive integer; in other words, this is the
     inverse of `cdf_binomial'. Argument <q> must be an element of
     [0,1]. To make use of this function, write first `load(distrib)'.


 -- Function: mean_binomial (<n>,<p>)
     Returns the mean of a Binomial(n,p) random variable, with 0<p<1
     and n a positive integer. To make use of this function, write
     first `load(distrib)'.


 -- Function: var_binomial (<n>,<p>)
     Returns the variance of a Binomial(n,p) random variable, with
     0<p<1 and n a positive integer. To make use of this function,
     write first `load(distrib)'.


 -- Function: std_binomial (<n>,<p>)
     Returns the standard deviation of a Binomial(n,p) random variable,
     with 0<p<1 and n a positive integer. To make use of this function,
     write first `load(distrib)'.


 -- Function: skewness_binomial (<n>,<p>)
     Returns the skewness coefficient of a Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: kurtosis_binomial (<n>,<p>)
     Returns the kurtosis coefficient of a Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: random_binomial (<n>,<p>)
 -- Function: random_binomial (<n>,<p>,<m>)
     Returns a Binomial(n,p) random variate, with 0<p<1 and n a
     positive integer. Calling `random_binomial' with a third argument
     <m>, a random sample of size <m> will be simulated.

     The implemented algorithm is based on the one described in
     Kachitvichyanukul, V. and Schmeiser, B.W. (1988) <Binomial Random
     Variate Generation>. Communications of the ACM, 31, Feb., 216.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_poisson (<x>,<m>)
     Returns the value at <x> of the probability function of a
     Poisson(m) random variable, with m>0. To make use of this
     function, write first `load(distrib)'.


 -- Function: cdf_poisson (<x>,<m>)
     Returns the value at <x> of the distribution function of a
     Poisson(m) random variable, with m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623


 -- Function: quantile_poisson (<q>,<m>)
     Returns the <q>-quantile of a Poisson(m) random variable, with
     m>0; in other words, this is the inverse of `cdf_poisson'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_poisson (<m>)
     Returns the mean of a Poisson(m) random variable, with  m>0. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_poisson (<m>)
     Returns the variance of a Poisson(m) random variable, with  m>0.
     To make use of this function, write first `load(distrib)'.


 -- Function: std_poisson (<m>)
     Returns the standard deviation of a Poisson(m) random variable,
     with m>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_poisson (<m>)
     Returns the skewness coefficient of a Poisson(m) random variable,
     with m>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_poisson (<m>)
     Returns the kurtosis coefficient of a Poisson random variable
     Poi(m), with m>0. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_poisson (<m>)
 -- Function: random_poisson (<m>,<n>)
     Returns a Poisson(m) random variate, with m>0. Calling
     `random_poisson' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The implemented algorithm is the one described in Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>. ACM Trans. Math. Software, 8, 2,
     June,163-179.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_bernoulli (<x>,<p>)
     Returns the value at <x> of the probability function of a
     Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial probability
     function is returned.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p


 -- Function: cdf_bernoulli (<x>,<p>)
     Returns the value at <x> of the distribution function of a
     Bernoulli(p) random variable, with 0<p<1. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_bernoulli (<q>,<p>)
     Returns the <q>-quantile of a Bernoulli(p) random variable, with
     0<p<1; in other words, this is the inverse of `cdf_bernoulli'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_bernoulli (<p>)
     Returns the mean of a Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial mean is returned.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p


 -- Function: var_bernoulli (<p>)
     Returns the variance of a Bernoulli(p) random variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial variance is
     returned.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p


 -- Function: std_bernoulli (<p>)
     Returns the standard deviation of a Bernoulli(p) random variable,
     with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial standard
     deviation is returned.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)


 -- Function: skewness_bernoulli (<p>)
     Returns the skewness coefficient of a Bernoulli(p) random
     variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial skewness
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)


 -- Function: kurtosis_bernoulli (<p>)
     Returns the kurtosis coefficient of a Bernoulli(p) random
     variable, with 0<p<1.

     The Bernoulli(p) random variable is equivalent to the
     Binomial(1,p), therefore when Maxima has not enough information to
     get the result, a noun form based on the binomial kurtosis
     coefficient is returned.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p


 -- Function: random_bernoulli (<p>)
 -- Function: random_bernoulli (<p>,<n>)
     Returns a Bernoulli(p) random variate, with 0<p<1. Calling
     `random_bernoulli' with a second argument <n>, a random sample of
     size <n> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'. To make use of this function, write first
     `load(distrib)'.


 -- Function: pdf_geometric (<x>,<p>)
     Returns the value at <x> of the probability function of a
     Geometric(p) random variable, with 0<p<1. To make use of this
     function, write first `load(distrib)'.


 -- Function: cdf_geometric (<x>,<p>)
     Returns the value at <x> of the distribution function of a
     Geometric(p) random variable, with 0<p<1. To make use of this
     function, write first `load(distrib)'.


 -- Function: quantile_geometric (<q>,<p>)
     Returns the <q>-quantile of a Geometric(p) random variable, with
     0<p<1; in other words, this is the inverse of `cdf_geometric'.
     Argument <q> must be an element of [0,1]. To make use of this
     function, write first `load(distrib)'.


 -- Function: mean_geometric (<p>)
     Returns the mean of a Geometric(p) random variable, with 0<p<1. To
     make use of this function, write first `load(distrib)'.


 -- Function: var_geometric (<p>)
     Returns the variance of a Geometric(p) random variable, with
     0<p<1. To make use of this function, write first `load(distrib)'.


 -- Function: std_geometric (<p>)
     Returns the standard deviation of a Geometric(p) random variable,
     with 0<p<1. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_geometric (<p>)
     Returns the skewness coefficient of a Geometric(p) random
     variable, with 0<p<1. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_geometric (<p>)
     Returns the kurtosis coefficient of a geometric random variable
     Geo(p), with 0<p<1. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_geometric (<p>)
 -- Function: random_geometric (<p>,<n>)
     Returns a Geometric(p) random variate, with 0<p<1. Calling
     `random_geometric' with a second argument <n>, a random sample of
     size <n> will be simulated.

     The algorithm is based on simulation of Bernoulli trials.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_discrete_uniform (<x>,<n>)
     Returns the value at <x> of the probability function of a Discrete
     Uniform(n) random variable, with n a strictly positive integer. To
     make use of this function, write first `load(distrib)'.


 -- Function: cdf_discrete_uniform (<x>,<n>)
     Returns the value at <x> of the distribution function of a
     Discrete Uniform(n) random variable, with n a strictly positive
     integer. To make use of this function, write first `load(distrib)'.


 -- Function: quantile_discrete_uniform (<q>,<n>)
     Returns the <q>-quantile of a Discrete Uniform(n) random variable,
     with n a strictly positive integer; in other words, this is the
     inverse of `cdf_discrete_uniform'. Argument <q> must be an element
     of [0,1]. To make use of this function, write first
     `load(distrib)'.


 -- Function: mean_discrete_uniform (<n>)
     Returns the mean of a Discrete Uniform(n) random variable, with n
     a strictly positive integer. To make use of this function, write
     first `load(distrib)'.


 -- Function: var_discrete_uniform (<n>)
     Returns the variance of a Discrete Uniform(n) random variable,
     with n a strictly positive integer. To make use of this function,
     write first `load(distrib)'.


 -- Function: std_discrete_uniform (<n>)
     Returns the standard deviation of a Discrete Uniform(n) random
     variable, with n a strictly positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: skewness_discrete_uniform (<n>)
     Returns the skewness coefficient of a Discrete Uniform(n) random
     variable, with n a strictly positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: kurtosis_discrete_uniform (<n>)
     Returns the kurtosis coefficient of a Discrete Uniform(n) random
     variable, with n a strictly positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: random_discrete_uniform (<n>)
 -- Function: random_discrete_uniform (<n>,<m>)
     Returns a Discrete Uniform(n) random variate, with n a strictly
     positive integer. Calling `random_discrete_uniform' with a second
     argument <m>, a random sample of size <m> will be simulated.

     This is a direct application of the `random' built-in Maxima
     function.

     See also `random'. To make use of this function, write first
     `load(distrib)'.


 -- Function: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Returns the value at <x> of the probability function of a
     Hypergeometric(n1,n2,n) random variable, with <n1>, <n2> and <n>
     non negative integers and n<=n1+n2. To make use of this function,
     write first `load(distrib)'.


 -- Function: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Returns the value at <x> of the distribution function of a
     Hypergeometric(n1,n2,n) random variable, with <n1>, <n2> and <n>
     non negative integers and n<=n1+n2. To make use of this function,
     write first `load(distrib)'.


 -- Function: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Returns the <q>-quantile of a Hypergeometric(n1,n2,n) random
     variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2; in other words, this is the inverse of
     `cdf_hypergeometric'. Argument <q> must be an element of [0,1]. To
     make use of this function, write first `load(distrib)'.


 -- Function: mean_hypergeometric (<n1>,<n2>,<n>)
     Returns the mean of a discrete uniform random variable
     Hyp(n1,n2,n), with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2. To make use of this function, write first
     `load(distrib)'.


 -- Function: var_hypergeometric (<n1>,<n2>,<n>)
     Returns the variance of a hypergeometric  random variable
     Hyp(n1,n2,n), with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2. To make use of this function, write first
     `load(distrib)'.


 -- Function: std_hypergeometric (<n1>,<n2>,<n>)
     Returns the standard deviation of a Hypergeometric(n1,n2,n) random
     variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2. To make use of this function, write first
     `load(distrib)'.


 -- Function: skewness_hypergeometric (<n1>,<n2>,<n>)
     Returns the skewness coefficient of a Hypergeometric(n1,n2,n)
     random variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2. To make use of this function, write first
     `load(distrib)'.


 -- Function: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Returns the kurtosis coefficient of a Hypergeometric(n1,n2,n)
     random variable, with <n1>, <n2> and <n> non negative integers and
     n<=n1+n2. To make use of this function, write first
     `load(distrib)'.


 -- Function: random_hypergeometric (<n1>,<n2>,<n>)
 -- Function: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Returns a Hypergeometric(n1,n2,n) random variate, with <n1>, <n2>
     and <n> non negative integers and n<=n1+n2. Calling
     `random_hypergeometric' with a fourth argument <m>, a random
     sample of size <m> will be simulated.

     Algorithm described in Kachitvichyanukul, V., Schmeiser, B.W.
     (1985) <Computer generation of hypergeometric random variates.>
     Journal of Statistical Computation and Simulation 22, 127-145.

     To make use of this function, write first `load(distrib)'.


 -- Function: pdf_negative_binomial (<x>,<n>,<p>)
     Returns the value at <x> of the probability function of a Negative
     Binomial(n,p) random variable, with 0<p<1 and n a positive
     integer. To make use of this function, write first `load(distrib)'.


 -- Function: cdf_negative_binomial (<x>,<n>,<p>)
     Returns the value at <x> of the distribution function of a
     Negative Binomial(n,p) random variable, with 0<p<1 and n a
     positive integer.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288
          (%i3) float(%);
          (%o3)              .006238937377929687


 -- Function: quantile_negative_binomial (<q>,<n>,<p>)
     Returns the <q>-quantile of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer; in other words,
     this is the inverse of `cdf_negative_binomial'. Argument <q> must
     be an element of [0,1]. To make use of this function, write first
     `load(distrib)'.


 -- Function: mean_negative_binomial (<n>,<p>)
     Returns the mean of a Negative Binomial(n,p) random variable, with
     0<p<1 and n a positive integer. To make use of this function,
     write first `load(distrib)'.


 -- Function: var_negative_binomial (<n>,<p>)
     Returns the variance of a Negative Binomial(n,p) random variable,
     with 0<p<1 and n a positive integer. To make use of this function,
     write first `load(distrib)'.


 -- Function: std_negative_binomial (<n>,<p>)
     Returns the standard deviation of a Negative Binomial(n,p) random
     variable, with 0<p<1 and n a positive integer. To make use of this
     function, write first `load(distrib)'.


 -- Function: skewness_negative_binomial (<n>,<p>)
     Returns the skewness coefficient of a Negative Binomial(n,p)
     random variable, with 0<p<1 and n a positive integer. To make use
     of this function, write first `load(distrib)'.


 -- Function: kurtosis_negative_binomial (<n>,<p>)
     Returns the kurtosis coefficient of a Negative Binomial(n,p)
     random variable, with 0<p<1 and n a positive integer. To make use
     of this function, write first `load(distrib)'.


 -- Function: random_negative_binomial (<n>,<p>)
 -- Function: random_negative_binomial (<n>,<p>,<m>)
     Returns a Negative Binomial(n,p) random variate, with 0<p<1 and n
     a positive integer. Calling `random_negative_binomial' with a
     third argument <m>, a random sample of size <m> will be simulated.

     Algorithm described in Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>. Springer Verlag, p. 480.

     To make use of this function, write first `load(distrib)'.



File: maxima.info,  Node: draw,  Next: drawdf,  Prev: Package distrib,  Up: Top

38 draw
*******

* Menu:

* Introduction to draw::
* Functions and Variables for draw::
* Functions and Variables for pictures::
* Functions and Variables for worldmap::


File: maxima.info,  Node: Introduction to draw,  Next: Functions and Variables for draw,  Prev: draw,  Up: draw

38.1 Introduction to draw
=========================

`draw' is a Maxima-Gnuplot interface.

   There are three main functions to be used at Maxima level: `draw2d',
`draw3d' and `draw'.

   Follow this link for more elaborated examples of this package:

   `http://www.telefonica.net/web2/biomates/maxima/gpdraw'

   You need Gnuplot 4.2 to run this program.


File: maxima.info,  Node: Functions and Variables for draw,  Next: Functions and Variables for pictures,  Prev: Introduction to draw,  Up: draw

38.2 Functions and Variables for draw
=====================================

38.2.1 Scenes
-------------

 -- Scene constructor: gr2d (<graphic option>, ..., <graphic object>,
          ...)
     Function `gr2d' builds an object describing a 2D scene. Arguments
     are graphic options, graphic objects, or lists containing both
     graphic options and objects. This scene is interpreted
     sequentially: graphic options affect those graphic objects placed
     on its right. Some graphic options affect the global appearence of
     the scene.

     This is the list of graphic objects available for scenes in two
     dimensions: `bars', `ellipse', `explicit', `image', `implicit',
     `label', `parametric', `points', `polar', `polygon',
     `quadrilateral', `rectangle', `triangle', `vector', and `geomap'
     (this one defined in package `worldmap').

     See also `draw' and `draw2d'.

     To make use of this object, write first `load(draw)'.


 -- Scene constructor: gr3d (<graphic option>, ..., <graphic object>,
          ...)
     Function `gr3d' builds an object describing a 3d scene. Arguments
     are graphic options, graphic objects, or lists containing both
     graphic options and objects. This scene is interpreted
     sequentially: graphic options affect those graphic objects placed
     on its right. Some graphic options affect the global appearence of
     the scene.

     This is the list of graphic objects available for scenes in three
     dimensions: `cylindrical', `elevation_grid', `explicit',
     `implicit', `label', `mesh', `parametric', `parametric_surface',
     `points', `quadrilateral', `spherical', `triangle', `tube',
     `vector', and `geomap' (this one defined in package `worldmap').

     See also `draw' and `draw3d'.

     To make use of this object, write first `load(draw)'.


38.2.2 Functions
----------------

 -- Function: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Plots a series of scenes; its arguments are `gr2d' and/or `gr3d'
     objects, together with some options, or lists of scenes and
     options.  By default, the scenes are put together in one column.

     Function `draw' accepts the following global options: `terminal',
     `columns', `dimensions', `file_name' and `delay'.

     Functions `draw2d' and `draw3d' are short cuts to be used when
     only one scene is required, in two or three dimensions,
     respectively.

     See also `gr2d' and `gr3d'.

     To make use of this function, write first `load(draw)'.

     Example:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     The two draw sentences are equivalent:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     An animated gif file:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     See also `gr2d', `gr3d', `draw2d' and `draw3d'..


 -- Function: draw2d (<option>, <graphic_object>, ...)
     This function is a short cut for `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     It can be used to plot a unique scene in 2d.

     To make use of this function, write first `load(draw)'.

     See also `draw' and `gr2d'.


 -- Function: draw3d (<option>, <graphic_object>, ...)
     This function is a short cut for `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     It can be used to plot a unique scene in 3d.

     To make use of this function, write first `load(draw)'.

     See also `draw' and `gr3d'.


 -- Function: draw_file (<graphic option>, ..., <graphic object>, ...)
     Saves the current plot into a file. Accepted graphics options are:
     `terminal', `dimensions', `file_name' and `background_color'.

     Example:

          (%i1) load(draw)$
          (%i2) /* screen plot */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $


 -- Function: multiplot_mode (<term>)
     This function enables Maxima to work in one-window multiplot mode
     with terminal <term>; accepted arguments for this function are
     `screen', `wxt', `aquaterm' and `none'.

     When multiplot mode is enabled, each call to `draw' sends a new
     plot to the same window, without erasing the previous ones. To
     disable the multiplot mode, write `multiplot_mode(none)'.

     When multiplot mode is enabled, global option `terminal' is
     blocked and you have to disable this working mode before changing
     to another terminal.

     This feature does not work in Windows platforms.

     Example:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$


 -- Function: set_draw_defaults (<graphic option>, ..., <graphic
          object>, ...)
     Sets user graphics options. This function is useful for plotting a
     sequence of graphics with common graphics options. Calling this
     function without arguments removes user defaults.

     Example:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* plot with user defaults */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* plot with standard defaults */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     To make use of this function, write first `load(draw)'.


38.2.3 Graphics options
-----------------------

 -- Graphic option: adapt_depth
     Default value: 10

     `adapt_depth' is the maximum number of splittings used by the
     adaptive plotting routine.

     This option is relevant only for 2d `explicit' functions.


 -- Graphic option: axis_3d
     Default value: `true'

     If `axis_3d' is `true', the <x>, <y> and <z> axis are shown in 3d
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     See also `axis_bottom',  `axis_left', `axis_top', and `axis_right'
     for axis in 2d.


 -- Graphic option: axis_bottom
     Default value: `true'

     If `axis_bottom' is `true', the bottom axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_left',  `axis_top', `axis_right', and `axis_3d'.


 -- Graphic option: axis_left
     Default value: `true'

     If `axis_left' is `true', the left axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_top', `axis_right', and `axis_3d'.


 -- Graphic option: axis_right
     Default value: `true'

     If `axis_right' is `true', the right axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_left', `axis_top', and `axis_3d'.


 -- Graphic option: axis_top
     Default value: `true'

     If `axis_top' is `true', the top axis is shown in 2d scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     See also `axis_bottom',  `axis_left', `axis_right', and `axis_3d'.


 -- Graphic option: background_color
     Default value: `white'

     Sets the background color for terminals `gif', `png', `jpg', and
     `gif'. Default background color is white.

     See also `color'.


 -- Graphic option: border
     Default value: `true'

     If `border' is `true', borders of polygons are painted according
     to `line_type' and `line_width'.

     This option affects the following graphic objects:
        * `gr2d': `polygon', `rectangle', and `ellipse'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$


 -- Graphic option: cbrange
     Default value: `auto'

     If `cbrange' is `auto', the range for the values which are colored
     when `enhanced3d' is not `false' is computed automatically. Values
     outside of the color range use color of the nearest extreme.

     When `enhanced3d' or `colorbox' is `false', option `cbrange' has
     no effect.

     If the user wants a specific interval for the colored values, it
     must be given as a Maxima list, as in `cbrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbtics'.


 -- Graphic option: cbtics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     colorbox when option `enhanced3d' is not `false'.

     When `enhanced3d' or `colorbox' is `false', option `cbtics' has no
     effect.

     See `xtics' for a complete description.

     Example :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.


 -- Graphic option: color
     Default value: `black'

     `color' specifies the color for plotting lines, points, borders of
     polygons and labels.

     Colors can be given as names or in hexadecimal rgb code.

     Available color names are: `white', `black', `gray0', `grey0',
     `gray10', `grey10', `gray20', `grey20', `gray30', `grey30',
     `gray40', `grey40', `gray50', `grey50', `gray60', `grey60',
     `gray70', `grey70', `gray80', `grey80', `gray90', `grey90',
     `gray100', `grey100', `gray', `grey', `light_gray', `light_grey',
     `dark_gray', `dark_grey', `red', `light_red', `dark_red', `yellow',
     `light_yellow', `dark_yellow', `green', `light_green',
     `dark_green', `spring_green', `forest_green', `sea_green', `blue',
     `light_blue', `dark_blue', `midnight_blue', `navy', `medium_blue',
     `royalblue', `skyblue', `cyan', `light_cyan', `dark_cyan',
     `magenta', `light_magenta', `dark_magenta', `turquoise',
     `light_turquoise', `dark_turquoise', `pink', `light_pink',
     `dark_pink', `coral', `light_coral', `orange_red', `salmon',
     `light_salmon', `dark_salmon', `aquamarine', `khaki',
     `dark_khaki', `goldenrod', `light_goldenrod', `dark_goldenrod',
     `gold', `beige', `brown', `orange', `dark_orange', `violet',
     `dark_violet', `plum' and `purple'.

     Cromatic componentes in hexadecimal code are introduced in the form
     `"#rrggbb"'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,_1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     See also `fill_color'.


 -- Graphic option: colorbox
     Default value: `true'

     If `colorbox' is `true', a color scale without label is drawn
     together with `image' 2D objects, or coloured 3d objects. If
     `colorbox' is `false', no color scale is shown. If `colorbox' is a
     string, a color scale with label is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

     Color scale and images.

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Color scale and 3D coloured object.

          (%i1) load(draw)$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     See also `palette'.


 -- Graphic option: columns
     Default value: 1

     `columns' is the number of columns in multiple plots.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Graphic option: contour
     Default value: `none'

     Option `contour' enables the user to select where to plot contour
     lines.  Possible values are:

        * `none': no contour lines are plotted.

        * `base': contour lines are projected on the xy plane.

        * `surface': contour lines are plotted on the surface.

        * `both': two contour lines are plotted: on the xy plane and on
          the surface.

        * `map': contour lines are projected on the xy plane, and the
          view point is set just in the vertical.


     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $


 -- Graphic option: contour_levels
     Default value: 5

     This graphic option controls the way contours are drawn.
     `contour_levels' can be set to a positive integer number, a list
     of three numbers or an arbitrary set of numbers:

        * When option `contour_levels' is bounded to positive integer
          <n>, <n> contour lines will be drawn at equal intervals. By
          default, five equally spaced contours are plotted.

        * When option `contour_levels' is bounded to a list of length
          three of the form `[lowest,s,highest]', contour lines are
          plotted from `lowest' to `highest' in steps of `s'.

        * When option `contour_levels' is bounded to a set of numbers
          of the form `{n1, n2, ...}', contour lines are plotted at
          values `n1', `n2', ...

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

     Ten equally spaced contour lines. The actual number of levels can
     be adjusted to give simple labels.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     From -8 to 8 in steps of 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Isolines at levels -7, -6, 0.8 and 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     See also `contour'.


 -- Graphic option: data_file_name
     Default value: `"data.gnuplot"'

     This is the name of the file with the numeric data needed by
     Gnuplot to build the requested plot.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     See example in `gnuplot_file_name'.


 -- Graphic option: delay
     Default value: 5

     This is the delay in 1/100 seconds of frames in animated gif files.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Option `delay' is only active in animated gif's; it is ignored in
     any other case.

     See also `terminal', `dimensions'.


 -- Graphic option: dimensions
     Default value: `[600,500]'

     Dimensions of the output terminal. Its value is a list formed by
     the width and the height. The meaning of the two numbers depends on
     the terminal you are working with.

     With terminals `gif', `animated_gif', `png', `jpg', `svg',
     `screen', `wxt', and `aquaterm', the integers represent the number
     of points in each direction. If they are not intergers, they are
     rounded.

     With terminals `eps', `eps_color', `pdf', and `pdfcairo', both
     numbers represent hundredths of cm, which means that, by default,
     pictures in these formats are 6 cm in width and 5 cm in height.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     Examples:

     Option `dimensions' applied to file output and to wxt canvas.

          (%i1) load(draw)$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     Option `dimensions' applied to eps output.  We want an eps file
     with A4 portrait dimensions.

          (%i1) load(draw)$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $


 -- Graphic option: enhanced3d
     Default value: `none'

     If `enhanced3d' is `none', surfaces are not colored in 3D plots. In
     order to get a colored surface, a list must be assigned to option
     `enhanced3d', where the first element is an expression and the
     rest are the names of the variables or parameters used in that
     expression. A list such `[f(x,y,z), x, y, z]' means that point
     `[x,y,z]' of the surface is assigned number `f(x,y,z)', which will
     be colored according to the actual `palette'. For those 3D graphic
     objects defined in terms of parameters, it is possible to define
     the color number in terms of the parameters, as in `[f(u), u]', as
     in objects `parametric' and `tube', or `[f(u,v), u, v]', as in
     object `parametric_surface'. While all 3D objects admit the model
     based on absolute coordinates, `[f(x,y,z), x, y, z]', only two of
     them, namely `explicit' and `elevation_grid', accept also models
     defined on the `[x,y]' coordinates, `[f(x,y), x, y]'. 3D graphic
     object `implicit' accepts only the `[f(x,y,z), x, y, z]' model.
     Object `points' accepts also the `[f(x,y,z), x, y, z]' model, but
     when points have a chronological nature, model `[f(k), k]' is also
     valid, being `k' an ordering parameter.

     When `enhanced3d' is assigned something different to `none',
     options `color' and `surface_hide' are ignored.

     The names of the variables defined in the lists may be different
     to those used in the definitions of the graphic objects.

     In order to maintain back compatibility, `enhanced3d = false' is
     equivalent to `enhanced3d = none', and `enhanced3d = true' is
     equivalent to `enhanced3d = [z, x, y, z]'.  If an expression is
     given to `enhanced3d', its variables must be the same used in the
     surface definition. This is not necessary when using lists.

     See option `palette' to learn how palettes are specified.

     Examples:

     `explicit' object with coloring defined by the `[f(x,y,z), x, y,
     z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     `explicit' object with coloring defined by the `[f(x,y), x, y]'
     model.  The names of the variables defined in the lists may be
     different to those used in the definitions of the graphic objects;
     in this case, `r' corresponds to `x', and `s' to `y'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     `parametric' object with coloring defined by the `[f(x,y,z), x, y,
     z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     `parametric' object with coloring defined by the `[f(u), u]' model.
     In this case, `(u-1)^2' is a shortcut for `[(u-1)^2,u]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     `elevation_grid' object with coloring defined by the `[f(x,y), x,
     y]' model.

          (%i1) load(draw)$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     `tube' object with coloring defined by the `[f(x,y,z), x, y, z]'
     model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     `tube' object with coloring defined by the `[f(u), u]' model.
     Here, `enhanced3d = -a' would be the shortcut for `enhanced3d =
     [-foo,foo]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   tube_extremes = [open, closed],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     `implicit' and `points' objects with coloring defined by the
     `[f(x,y,z), x, y, z]' model.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     When points have a chronological nature, model `[f(k), k]' is also
     valid, being `k' an ordering parameter.

          (%i1) load(draw)$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $


 -- Graphic option: error_type
     Default value: `y'

     Depending on its value, which can be `x', `y', or `xy', graphic
     object `errors' will draw points with horizontal, vertical, or
     both, error bars. When `error_type=boxes', boxes will be drawn
     instead of crosses.

     See also `errors'.

 -- Graphic option: file_name
     Default value: `"maxima_out"'

     This is the name of the file where terminals `png', `jpg', `gif',
     `eps', `eps_color', `pdf', `pdfcairo' and `svg' will save the
     graphic.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     See also `terminal', `dimensions'.


 -- Graphic option: fill_color
     Default value: `"red"'

     `fill_color' specifies the color for filling polygons and 2d
     `explicit' functions.

     See `color' to learn how colors are specified.


 -- Graphic option: fill_density
     Default value: 0

     `fill_density' is a number between 0 and 1 that specifies the
     intensity of the `fill_color' in `bars' objects.

     See `bars' for examples.

 -- Graphic option: filled_func
     Default value: `false'

     Option `filled_func' controls how regions limited by functions
     should be filled. When `filled_func' is `true', the region bounded
     by the function defined with object `explicit' and the bottom of
     the graphic window is filled with `fill_color'. When `filled_func'
     contains a function expression, then the region bounded by this
     function and the function defined with object `explicit' will be
     filled. By default, explicit functions are not filled.

     This option affects only the 2d graphic object `explicit'.

     Example:

     Region bounded by an `explicit' object and the bottom of the
     graphic window.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Region bounded by an `explicit' object and the function defined by
     option `filled_func'. Note that the variable in `filled_func' must
     be the same as that used in `explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     See also `fill_color' and `explicit'.


 -- Graphic option: font
     Default value: `""' (empty string)

     This option can be used to set the font face to be used by the
     terminal.  Only one font face and size can be used throughout the
     plot.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `font_size'.

     Gnuplot doesn't handle fonts by itself, it leaves this task to the
     support libraries of the different terminals, each one with its own
     philosophy about it. A brief summary follows:

        * x11: Uses the normal x11 font server mechanism.

          Example:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: The windows terminal doesn't support changing of
          fonts from inside the plot.  Once the plot has been
          generated, the font can be changed right-clicking on the menu
          of the graph window.

        * png, jpeg, gif: The libgd library uses the font path stored
          in the environment variable `GDFONTPATH'; in this case, it is
          only necessary to set option `font' to the font's name. It is
          also possible to give the complete path to the font file.

          Examples:

          Option `font' can be given the complete path to the font file:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          If environment variable `GDFONTPATH' is set to the path where
          font files are allocated, it is possible to set graphic
          option `font' to the name of the font.
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Standard Postscript fonts are: `"Times-Roman"',
          `"Times-Italic"', `"Times-Bold"', `"Times-BoldItalic"',
          `"Helvetica"', `"Helvetica-Oblique"', `"Helvetica-Bold"',
          `"Helvetic-BoldOblique"', `"Courier"', `"Courier-Oblique"',
          `"Courier-Bold"', and `"Courier-BoldOblique"'.

          Example:

               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Uses same fonts as Postscript.

        * pdfcairo: Uses same fonts as wxt.

        * wxt: The pango library finds fonts via the `fontconfig'
          utility.

        * aqua: Default is `"Times-Roman"'.

     The gnuplot documentation is an important source of information
     about terminals and fonts.


 -- Graphic option: font_size
     Default value: 12

     This option can be used to set the font size to be used by the
     terminal.  Only one font face and size can be used throughout the
     plot. `font_size' is active only when option `font' is not equal
     to the empty string.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `font'.


 -- Graphic option: gnuplot_file_name
     Default value: `"maxout.gnuplot"'

     This is the name of the file with the necessary commands to be
     processed by Gnuplot.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     See also `data_file_name'.


 -- Graphic option: grid
     Default value: `false'

     If `grid' is `true', a grid will be drawn on the <xy> plane.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$


 -- Graphic option: head_angle
     Default value: 45

     `head_angle' indicates the angle, in degrees, between the arrow
     heads and the segment.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     See also `head_both', `head_length', and `head_type'.


 -- Graphic option: head_both
     Default value: `false'

     If `head_both' is `true', vectors are plotted with two arrow heads.
     If `false', only one arrow is plotted.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     See also `head_length', `head_angle', and `head_type'.


 -- Graphic option: head_length
     Default value: 2

     `head_length' indicates, in <x>-axis units, the length of arrow
     heads.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     See also `head_both', `head_angle', and `head_type'.


 -- Graphic option: head_type
     Default value: `filled'

     `head_type' is used to specify how arrow heads are plotted.
     Possible values are: `filled' (closed and filled arrow heads),
     `empty' (closed but not filled arrow heads), and `nofilled' (open
     arrow heads).

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     See also `head_both', `head_angle', and `head_length'.


 -- Graphic option: ip_grid
     Default value: `[50, 50]'

     `ip_grid' sets the grid for the first sampling in implicit plots.

     This option is relevant only for `implicit' objects.


 -- Graphic option: ip_grid_in
     Default value: `[5, 5]'

     `ip_grid_in' sets the grid for the second sampling in implicit
     plots.

     This option is relevant only for `implicit' objects.


 -- Graphic option: key
     Default value: `""' (empty string)

     `key' is the name of a function in the legend. If `key' is an
     empty string, no key is assigned to the function.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric', and `polar'.

        * `gr3d': `points', `explicit', `parametric', and
          `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$


 -- Graphic option: label_alignment
     Default value: `center'

     `label_alignment' is used to specify where to write labels with
     respect to the given coordinates. Possible values are: `center',
     `left', and `right'.

     This option is relevant only for `label' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     See also `label_orientation', and `color'.


 -- Graphic option: label_orientation
     Default value: `horizontal'

     `label_orientation' is used to specify orientation of labels.
     Possible values are: `horizontal', and `vertical'.

     This option is relevant only for `label' objects.

     Example:

     In this example, a dummy point is added to get an image.  Package
     `draw' needs always data to draw an scene.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     See also `label_alignment' and `color'.


 -- Graphic option: line_type
     Default value: `solid'

     `line_type' indicates how lines are displayed; possible values are
     `solid' and `dots'.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' and `polar'.

        * `gr3d': `points', `explicit', `parametric' and
          `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     See also `line_width'.


 -- Graphic option: line_width
     Default value: 1

     `line_width' is the width of plotted lines.  Its value must be a
     positive number.

     This option affects the following graphic objects:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' and `polar'.

        * `gr3d': `points' and `parametric'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     See also `line_type'.


 -- Graphic option: logcb
     Default value: `false'

     If `logcb' is `true', the tics in the colorbox will be drawn in the
     logarithmic scale.

     When `enhanced3d' or `colorbox' is `false', option `logcb' has no
     effect.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     See also `enhanced3d', `colorbox' and `cbrange'.


 -- Graphic option: logx
     Default value: `false'

     If `logx' is `true', the <x> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     See also `logy' and `logz'.


 -- Graphic option: logy
     Default value: `false'

     If `logy' is `true', the <y> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     See also `logx' and `logz'.


 -- Graphic option: logz
     Default value: `false'

     If `logz' is `true', the <z> axis will be drawn in the logarithmic
     scale.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     See also `logx' and `logy'.


 -- Graphic option: nticks
     Default value: 29

     In 2d, `nticks' gives the initial number of points used by the
     adaptive plotting routine for explicit objects. It is also the
     number of points that will be shown in parametric and polar curves.

     This option affects the following graphic objects:
        * `gr2d': `ellipse', `explicit', `parametric' and `polar'.

        * `gr3d': `parametric'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$


 -- Graphic option: palette
     Default value: `color'

     `palette' indicates how to map the real values of a matrix passed
     to object `image' onto color components.

     `palette' is a vector of length three with components ranging from
     -36 to +36; each value is an index for a formula mapping the
     levels onto red, green and blue colors, respectively:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     negative numbers mean negative colour component.

     `palette = gray' and `palette = color' are short cuts for `palette
     = [3,3,3]' and `palette = [7,5,15]', respectively.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     See also `colorbox'.


 -- Graphic option: point_size
     Default value: 1

     `point_size' sets the size for plotted points. It must be a non
     negative number.

     This option has no effect when graphic option `point_type' is set
     to `dot'.

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$


 -- Graphic option: point_type
     Default value: 1

     `point_type' indicates how isolated points are displayed; the
     value of this option can be any integer index greater or equal
     than -1, or the name of a point style: `$none' (-1), `dot' (0),
     `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) and `filled_diamant'
     (13).

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$


 -- Graphic option: points_joined
     Default value: `false'

     When `points_joined' is `true', points are joined by lines; when
     `false', isolated points are drawn. A third possible value for this
     graphic option is `impulses'; in such case, vertical segments are
     drawn from points to the x-axis (2D) or to the xy-plane (3D).

     This option affects the following graphic objects:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$


 -- Graphic option: proportional_axes
     Default value: `none'

     When `proportional_axes' is equal to `xy' or `xyz', a 2D or 3D
     scene will be drawn with axes proportional to their relative
     lengths.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     This option works with Gnuplot version 4.2.6 or greater.

     Examples:

     Single 2D plot.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1))


 -- Graphic option: surface_hide
     Default value: `false'

     If `surface_hide' is `true', hidden parts are not plotted in 3d
     surfaces.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$


 -- Graphic option: terminal
     Default value: `screen'

     Selects the terminal to be used by Gnuplot; possible values are:
     `screen' (default), `png', `jpg', `eps', `eps_color', `pdf',
     `pdfcairo', `gif', `animated_gif', `wxt', `svg', and `aquaterm'.

     Terminals `screen', `wxt' and `aquaterm' can be also defined as a
     list with two elements: the name of the terminal itself and a non
     negative integer number. In this form, multiple windows can be
     opened at the same time, each with its corresponding number. This
     feature does not work in Windows platforms.

     Since this is a global graphics option, its position in the scene
     description does not matter. It can be also used as an argument of
     function `draw'.

     N.B. pdfcairo requires Gnuplot 4.3 or newer.  `pdf' requires
     Gnuplot to be compiled with the option `--enable-pdf' and libpdf
     must be installed. The pdf library is available from:
     `http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/'

     Examples:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Multiple windows.
          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     An animated gif file.
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Option `delay' is only active in animated gif's; it is ignored in
     any other case.

     See also `file_name', `dimensions' and `delay'.


 -- Graphic option: title
     Default value: `""' (empty string)

     Option `title', a string, is the main title for the scene.  By
     default, no title is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$


 -- Graphic option: transform
     Default value: `none'

     If `transform' is `none', the space is not transformed and graphic
     objects are drawn as defined. When a space transformation is
     desired, a list must be assigned to option `transform'. In case of
     a 2D scene, the list takes the form `[f1(x,y), f2(x,y), x, y]'.
     In case of a 3D scene, the list is of the form `[f1(x,y,z),
     f2(x,y,z), f3(x,y,z), x, y, z]'.

     The names of the variables defined in the lists may be different
     to those used in the definitions of the graphic objects.

     Examples:

     Rotation in 2D.

          (%i1) load(draw)$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Translation in 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$


 -- Graphic option: transparent
     Default value: `false'

     If `transparent' is `true', interior regions of polygons are
     filled according to `fill_color'.

     This option affects the following graphic objects:
        * `gr2d': `polygon', `rectangle', and `ellipse'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$


 -- Graphic option: tube_extremes
     Default value: `[open, open]'

     A list with two possible elements, `open' and `closed', indicating
     whether the extremes of a graphic object `tube' remain open or
     must be closed. By default, both extremes are left open.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  tube_extremes = [open, closed],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$


 -- Graphic option: unit_vectors
     Default value: `false'

     If `unit_vectors' is `true', vectors are plotted with module 1.
     This is useful for plotting vector fields. If `unit_vectors' is
     `false', vectors are plotted with its original length.

     This option is relevant only for `vector' objects.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$


 -- Graphic option: user_preamble
     Default value: `""' (empty string)

     Expert Gnuplot users can make use of this option to fine tune
     Gnuplot's behaviour by writing settings to be sent before the
     `plot' or `splot' command.

     The value of this option must be a string or a list of strings
     (one per line).

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

     The dumb terminal is not supported by package `draw', but it is
     possible to set it by making use of option `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$


 -- Graphic option: view
     Default value: `[60,30]'

     A pair of angles, measured in degrees, indicating the view
     direction in a 3D scene. The first angle is the vertical rotation
     around the <x> axis, in the range [0, 180]. The second one is the
     horizontal rotation around the <z> axis, in the range [0, 360].

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(view = [170, 360],
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$


 -- Graphic option: x_voxel
     Default value: 10

     `x_voxel' is the number of voxels in the x direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object. It is also used by graphic object `region'.


 -- Graphic option: xaxis
     Default value: `false'

     If `xaxis' is `true', the <x> axis is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     See also `xaxis_width', `xaxis_type' and `xaxis_color'.


 -- Graphic option: xaxis_color
     Default value: `"black"'

     `xaxis_color' specifies the color for the <x> axis. See `color' to
     know how colors are defined.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     See also `xaxis', `xaxis_width' and `xaxis_type'.


 -- Graphic option: xaxis_secondary
     Default value: `false'

     If `xaxis_secondary' is `true', function values can be plotted with
     respect to the second <x> axis, which will be drawn on top of the
     scene.

     Note that this is a local graphics option which only affects to 2d
     plots.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     See also `xrange_secondary', `xtics_secondary',
     `xtics_rotate_secondary', `xtics_axis_secondary' and
     `xaxis_secondary'.


 -- Graphic option: xaxis_type
     Default value: `dots'

     `xaxis_type' indicates how the <x> axis is displayed; possible
     values are `solid' and `dots'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     See also `xaxis', `xaxis_width' and `xaxis_color'.


 -- Graphic option: xaxis_width
     Default value: 1

     `xaxis_width' is the width of the <x> axis.  Its value must be a
     positive number.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     See also `xaxis', `xaxis_type' and `xaxis_color'.


 -- Graphic option: xlabel
     Default value: `""' (empty string)

     Option `xlabel', a string, is the label for the <x> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     See also `ylabel', and `zlabel'.


 -- Graphic option: xrange
     Default value: `auto'

     If `xrange' is `auto', the range for the <x> coordinate is
     computed automatically.

     If the user wants a specific interval for <x>, it must be given as
     a Maxima list, as in `xrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     See also `yrange' and `zrange'.


 -- Graphic option: xrange_secondary
     Default value: `auto'

     If `xrange_secondary' is `auto', the range for the second <x> axis
     is computed automatically.

     If the user wants a specific interval for the second <x> axis, it
     must be given as a Maxima list, as in `xrange_secondary=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     See also `xrange', `yrange', `zrange' and `yrange_secondary'.


 -- Graphic option: xtics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <x> axis.

        * When option `xtics' is bounded to symbol <auto>, tic marks are
          drawn automatically.

        * When option `xtics' is bounded to symbol <none>, tic marks are
          not drawn.

        * When option `xtics' is bounded to a positive number, this is
          the distance between two consecutive tic marks.

        * When option `xtics' is bounded to a list of length three of
          the form `[start,incr,end]', tic marks are plotted from
          `start' to `end' at intervals of length `incr'.

        * When option `xtics' is bounded to a set of numbers of the
          form `{n1, n2, ...}', tic marks are plotted at values `n1',
          `n2', ...

        * When option `xtics' is bounded to a set of pairs of the form
          `{["label1", n1], ["label2", n2], ...}', tic marks
          corresponding to values `n1', `n2', ... are labeled with
          `"label1"', `"label2"', ..., respectively.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Examples:

     Disable tics.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Tics every 1/4 units.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Tics from -3/4 to 3/4 in steps of 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Tics at points -1/2, -1/4 and 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Labeled tics.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

     See also `ytics', and `ztics'.


 -- Graphic option: xtics_axis
     Default value: `false'

     If `xtics_axis' is `true', tic marks and their labels are plotted
     just along the <x> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: xtics_rotate
     Default value: `false'

     If `xtics_rotate' is `true', tic marks on the <x> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: xtics_rotate_secondary
     Default value: `false'

     If `xtics_rotate_secondary' is `true', tic marks on the secondary
     <x> axis are rotated 90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: xtics_secondary
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     second <x> axis.

     See `xtics' for a complete description.


 -- Graphic option: xtics_secondary_axis
     Default value: `false'

     If `xtics_secondary_axis' is `true', tic marks and their labels are
     plotted just along the secondary <x> axis, if it is `false' tics
     are plotted on the border.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: xu_grid
     Default value: 30

     `xu_grid' is the number of coordinates of the first variable (`x'
     in explicit and `u' in parametric 3d surfaces) to build the grid
     of sample points.

     This option affects the following graphic objects:
        * `gr3d': `explicit' and `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     See also `yv_grid'.


 -- Graphic option: xy_file
     Default value: `""' (empty string)

     `xy_file' is the name of the file where the coordinates will be
     saved after clicking with the mouse button and hitting the 'x'
     key. By default, no coordinates are saved.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: xyplane
     Default value: `false'

     Allocates the xy-plane in 3D scenes. When `xyplane' is `false',
     the xy-plane is placed automatically; when it is a real number,
     the xy-plane intersects the z-axis at this level.  This option has
     no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$


 -- Graphic option: y_voxel
     Default value: 10

     `y_voxel' is the number of voxels in the y direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object. It is also used by graphic object `region'.


 -- Graphic option: yaxis
     Default value: `false'

     If `yaxis' is `true', the <y> axis is drawn.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     See also `yaxis_width', `yaxis_type' and `yaxis_color'.


 -- Graphic option: yaxis_color
     Default value: `"black"'

     `yaxis_color' specifies the color for the <y> axis. See `color' to
     know how colors are defined.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     See also `yaxis', `yaxis_width' and `yaxis_type'.


 -- Graphic option: yaxis_secondary
     Default value: `false'

     If `yaxis_secondary' is `true', function values can be plotted with
     respect to the second <y> axis, which will be drawn on the right
     side of the scene.

     Note that this is a local graphics option which only affects to 2d
     plots.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     See also `yrange_secondary', `ytics_secondary',
     `ytics_rotate_secondary' and `ytics_axis_secondary'.


 -- Graphic option: yaxis_type
     Default value: `dots'

     `yaxis_type' indicates how the <y> axis is displayed; possible
     values are `solid' and `dots'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     See also `yaxis', `yaxis_width' and `yaxis_color'.


 -- Graphic option: yaxis_width
     Default value: 1

     `yaxis_width' is the width of the <y> axis.  Its value must be a
     positive number.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     See also `yaxis', `yaxis_type' and `yaxis_color'.


 -- Graphic option: ylabel
     Default value: `""' (empty string)

     Option `ylabel', a string, is the label for the <y> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     See also `xlabel', and `zlabel'.


 -- Graphic option: yrange
     Default value: `auto'

     If `yrange' is `auto', the range for the <y> coordinate is
     computed automatically.

     If the user wants a specific interval for <y>, it must be given as
     a Maxima list, as in `yrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     See also `xrange', `yrange_secondary' and `zrange'.


 -- Graphic option: yrange_secondary
     Default value: `auto'

     If `yrange_secondary' is `auto', the range for the second <y> axis
     is computed automatically.

     If the user wants a specific interval for the second <y> axis, it
     must be given as a Maxima list, as in `yrange_secondary=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     See also `xrange', `yrange' and `zrange'.


 -- Graphic option: ytics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <y> axis.

     See `xtics' for a complete description.


 -- Graphic option: ytics_axis
     Default value: `false'

     If `ytics_axis' is `true', tic marks and their labels are plotted
     just along the <y> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: ytics_rotate
     Default value: `false'

     If `ytics_rotate' is `true', tic marks on the <y> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: ytics_rotate_secondary
     Default value: `false'

     If `ytics_rotate_secondary' is `true', tic marks on the secondary
     <y> axis are rotated 90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: ytics_secondary
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     second <y> axis.

     See `xtics' for a complete description.


 -- Graphic option: ytics_secondary_axis
     Default value: `false'

     If `ytics_secondary_axis' is `true', tic marks and their labels are
     plotted just along the secondary <y> axis, if it is `false' tics
     are plotted on the border.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: yv_grid
     Default value: 30

     `yv_grid' is the number of coordinates of the second variable (`y'
     in explicit and `v' in parametric 3d surfaces) to build the grid
     of sample points.

     This option affects the following graphic objects:
        * `gr3d': `explicit' and `parametric_surface'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     See also `xu_grid'.


 -- Graphic option: z_voxel
     Default value: 10

     `z_voxel' is the number of voxels in the z direction to be used by
     the marching cubes algorithm implemented by the 3d `implicit'
     object.


 -- Graphic option: zaxis
     Default value: `false'

     If `zaxis' is `true', the <z> axis is drawn in 3D plots.  This
     option has no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     See also `zaxis_width', `zaxis_type' and `zaxis_color'.


 -- Graphic option: zaxis_color
     Default value: `"black"'

     `zaxis_color' specifies the color for the <z> axis. See `color' to
     know how colors are defined.  This option has no effect in 2D
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     See also `zaxis', `zaxis_width' and `zaxis_type'.


 -- Graphic option: zaxis_type
     Default value: `dots'

     `zaxis_type' indicates how the <z> axis is displayed; possible
     values are `solid' and `dots'.  This option has no effect in 2D
     scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     See also `zaxis', `zaxis_width' and `zaxis_color'.


 -- Graphic option: zaxis_width
     Default value: 1

     `zaxis_width' is the width of the <z> axis.  Its value must be a
     positive number. This option has no effect in 2D scenes.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     See also `zaxis', `zaxis_type' and `zaxis_color'.


 -- Graphic option: zlabel
     Default value: `""' (empty string)

     Option `zlabel', a string, is the label for the <z> axis.  By
     default, no label is written.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     See also `xlabel', and `ylabel'.


 -- Graphic option: zrange
     Default value: `auto'

     If `zrange' is `auto', the range for the <z> coordinate is
     computed automatically.

     If the user wants a specific interval for <z>, it must be given as
     a Maxima list, as in `zrange=[-2, 3]'.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     See also `xrange' and `yrange'.


 -- Graphic option: ztics
     Default value: `auto'

     This graphic option controls the way tic marks are drawn on the
     <z> axis.

     See `xtics' for a complete description.


 -- Graphic option: ztics_axis
     Default value: `false'

     If `ztics_axis' is `true', tic marks and their labels are plotted
     just along the <z> axis, if it is `false' tics are plotted on the
     border.

     Since this is a global graphics option, its position in the scene
     description does not matter.


 -- Graphic option: ztics_rotate
     Default value: `false'

     If `ztics_rotate' is `true', tic marks on the <z> axis are rotated
     90 degrees.

     Since this is a global graphics option, its position in the scene
     description does not matter.


38.2.4 Graphics objects
-----------------------

 -- Graphic object: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Draws vertical bars in 2D.

     2D

     `bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' draws bars
     centered at values <x1>, <x2>, ... with heights <h1>, <h2>, ...
     and widths <w1>, <w2>, ...

     This object is affected by the following graphic options: `key',
     `fill_color', `fill_density' and `line_width'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Group A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Group B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);


 -- Graphic object: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Draws 3D functions defined in cylindrical coordinates.

     3D

     `cylindrical(<radius>, <z>, <minz>, <maxz>, <azi>, <minazi>,
     <maxazi>)' plots function `<radius>(<z>, <azi>)' defined in
     cylindrical coordinates, with variable <z> taking values from
     <minz> to <maxz> and azimuth <azi> taking values from <minazi> to
     <maxazi>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$


 -- Graphic object: elevation_grid (<mat>,<x0>,<y0>,<width>,<height>)
     Draws matrix <mat> in 3D space. <z> values are taken from <mat>,
     the abscissas range from <x0> to <x0> + <width> and ordinates from
     <y0> to <y0> + <height>. Element a(1,1) is projected on point
     (x0,y0+height), a(1,n) on (x0+width,y0+height), a(m,1) on (x0,y0),
     and a(m,n) on (x0+width,y0).

     This object is affected by the following graphic options:
     `line_type', `line_width', `key', `enhanced3d', and `color'.

     In older versions of Maxima, `elevation_grid' was called `mesh'.
     See also `mesh'.

     Example:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);


 -- Graphic object: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Draws ellipses and circles in 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' plots an ellipse
     centered at `[<xc>, <yc>]' with horizontal and vertical semi axis
     <a> and <b>, respectively, starting at angle <ang1> with an
     amplitude equal to angle <ang2>.

     This object is affected by the following graphic options: `nticks',
     `transparent', `fill_color', `border', `line_width', `line_type',
     `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$


 -- Graphic object: errors ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Draws points with error bars, horizontally, vertically or both,
     depending on the value of option `error_type'.

     2D

     If `error_type=x', arguments to `errors' must be of the form
     `[x,y,xdelta]' or `[x,y,xlow,xhigh]'. If `error_type=y', arguments
     must be of the form `[x,y,ydelta]' or `[x,y,ylow,yhigh]'.  If
     `error_type=xy' or `error_type=boxes', arguments to `errors' must
     be of the form `[x,y,xdelta,ydelta]' or
     `[x,y,xlow,xhigh,ylow,yhigh]'.

     See also `error_type'.

     This object is affected by the following graphic options:
     `error_type', `points_joined', `line_width', `key', `line_type',
     `color', `fill_density', `xaxis_secondary', and `yaxis_secondary'.

     Option `fill_density' is only relevant when `error_type=boxes'.

     Examples:

     Horizontal error bars.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Vertical and horizontal error bars.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));


 -- Graphic object: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Graphic object: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Draws explicit functions in 2D and 3D.

     2D

     `explicit(<fcn>,<var>,<minval>,<maxval>)' plots explicit function
     <fcn>, with variable <var> taking values from <minval> to <maxval>.

     This object is affected by the following graphic options: `nticks',
     `adapt_depth', `line_width', `line_type', `key', `filled_func',
     `fill_color' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit(<fcn>, <var1>, <minval1>, <maxval1>, <var2>, <minval2>,
     <maxval2>)' plots explicit function <fcn>, with variable <var1>
     taking values from <minval1> to <maxval1> and variable <var2>
     taking values from <minval2> to <maxval2>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d', and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     See also `filled_func' for filled functions.


 -- Graphic object: image (<im>,<x0>,<y0>,<width>,<height>)
     Renders images in 2D.

     2D

     `image (<im>,<x0>,<y0>,<width>,<height>)' plots image <im> in the
     rectangular region from vertex `(<x0>,<y0>)' to
     `(x0+<width>,y0+<height>)' on the real plane. Argument <im> must
     be a matrix of real numbers, a matrix of vectors of length three
     or a <picture> object.

     If <im> is a matrix of real numbers or a <levels picture> object,
     pixel values are interpreted according to graphic option `palette',
     which is a vector of length three with components ranging from -36
     to +36; each value is an index for a formula mapping the levels
     onto red, green and blue colors, respectively:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125                  31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     negative numbers mean negative colour component.

     `palette = gray' and `palette = color' are short cuts for `palette
     = [3,3,3]' and `palette = [7,5,15]', respectively.

     If <im> is a matrix of vectors of length three or an <rgb picture>
     object, they are interpreted as red, green and blue color
     components.

     Examples:

     If <im> is a matrix of real numbers, pixel values are interpreted
     according to graphic option `palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     See also `colorbox'.

     If <im> is a matrix of vectors of length three, they are
     interpreted as red, green and blue color components.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     Package `draw' automatically loads package `picture'. In this
     example, a level picture object is built by hand and then rendered.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     An xpm file is read and then rendered.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     See also `make_level_picture', `make_rgb_picture' and `read_xpm'.

     URL `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image'
     contains more elaborated examples.


 -- Graphic object: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Graphic object: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Draws implicit functions in 2D and 3D.

     2D

     `implicit(<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' plots the
     implicit function defined by <fcn>, with variable <x> taking values
     from <xmin> to <xmax>, and variable <y> taking values from <ymin>
     to <ymax>.

     This object is affected by the following graphic options:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' and
     `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' plots the implicit surface defined by <fcn>,
     with variable <x> taking values from <xmin> to <xmax>, variable
     <y> taking values from <ymin> to <ymax> and variable <z> taking
     values from <zmin> to <zmax>. This object implements the marching
     cubes algorithm.

     This object is affected by the following graphic options:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key'
     and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);


 -- Graphic object: label ([<string>,<x>,<y>],...)
 -- Graphic object: label ([<string>,<x>,<y>,<z>],...)
     Writes labels in 2D and 3D.

     Colored labels work only with Gnuplot 4.3. This is a known bug in
     package `draw'.

     This object is affected by the following graphic options:
     `label_alignment', `label_orientation' and `color'.

     2D

     `label([<string>,<x>,<y>])' writes the <string> at point
     `[<x>,<y>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>,<x>,<y>,<z>])' writes the <string> at point
     `[<x>,<y>,<z>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$


 -- Graphic object: mesh (<row_1>,<row_2>,...)
     Draws a quadrangular mesh in 3D.

     3D

     Argument <row_i> is a list of <n> 3D points of the form
     `[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]', and all rows are of
     equal length. All these points define an arbitrary surface in 3D
     and in some sense it's a generalization of the `elevation_grid'
     object.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `enhanced3d', and
     `transform'.

     Examples:

     A simple example.

          (%i1) load(draw)$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Plotting a triangle in 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Two quadrilaterals.

          (%i1) load(draw)$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $


 -- Graphic object: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Graphic object: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Draws parametric functions in 2D and 3D.

     This object is affected by the following graphic options: `nticks',
     `line_width', `line_type', `key', `color' and `enhanced3d'.

     2D

     `parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' plots
     parametric function `[<xfun>,<yfun>]', with parameter <par> taking
     values from <parmin> to <parmax>.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     `parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' plots
     parametric curve `[<xfun>,<yfun>,<zfun>]', with parameter <par>
     taking values from <parmin> to <parmax>.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$


 -- Graphic object: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Draws parametric surfaces in 3D.

     3D

     `parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     plots parametric surface `[<xfun>,<yfun>,<zfun>]', with parameter
     <par1> taking values from <par1min> to <par1max> and parameter
     <par2> taking values from <par2min> to <par2max>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d',  and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$


 -- Graphic object: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Graphic object: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Graphic object: points ([<y1>,<y2>,...])
 -- Graphic object: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Graphic object: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Graphic object: points (<matrix>)
 -- Graphic object: points (<1d_y_array>)
 -- Graphic object: points (<1d_x_array>, <1d_y_array>)
 -- Graphic object: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Graphic object: points (<2d_xy_array>)
 -- Graphic object: points (<2d_xyz_array>)
     Draws points in 2D and 3D.

     This object is affected by the following graphic options:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' and `color'. In 3D mode, it is also affected by
     `enhanced3d'.

     2D

     `points ([[<x1>,<y1>], [<x2>,<y2>],...])' or `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' plots points `[x1,y1]',
     `[x2,y2]', etc. If abscissas are not given, they are set to
     consecutive positive integers, so that `points ([<y1>,<y2>,...])'
     draws points `[1,<y1>]', `[2,<y2>]', etc.  If <matrix> is a
     two-column or two-row matrix, `points (<matrix>)' draws the
     associated points. If <matrix> is a one-column or one-row matrix,
     abscissas are assigned automatically.

     If <1d_y_array> is a 1D lisp array of numbers, `points
     (<1d_y_array>)' plots them setting abscissas to consecutive
     positive integers. `points (<1d_x_array>, <1d_y_array>)' plots
     points with their coordinates taken from the two arrays passed as
     arguments. If <2d_xy_array> is a 2D array with two columns, or
     with two rows, `points (<2d_xy_array>)' plots the corresponding
     points on the plane.

     Examples:

     Two types of arguments for `points', a list of pairs and two lists
     of separate coordinates.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Drawing impulses.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array with ordinates.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Two arrays with separate coordinates.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     A two-column 2D array.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Drawing an array filled with function `read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     `points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' or `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' plots points
     `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]', etc.  If <matrix> is a
     three-column or three-row matrix, `points (<matrix>)' draws the
     associated points.

     When arguments are lisp arrays, `points (<1d_x_array>,
     <1d_y_array>, <1d_z_array>)' takes coordinates from the three 1D
     arrays.  If <2d_xyz_array> is a 2D array with three columns, or
     with three rows, `points (<2d_xyz_array>)' plots the corresponding
     points.

     Examples:

     One tridimensional sample,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Two tridimensional samples,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Unidimensional arrays,
          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Bidimensional colored array,
          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Color numbers explicitly specified by the user.
          (%i1) load(draw)$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$


 -- Graphic object: polar (<radius>,<ang>,<minang>,<maxang>)
     Draws 2D functions defined in polar coordinates.

     2D

     `polar (<radius>,<ang>,<minang>,<maxang>)' plots function
     `<radius>(<ang>)' defined in polar coordinates, with variable
     <ang> taking values from <minang> to <maxang>.

     This object is affected by the following graphic options: `nticks',
     `line_width', `line_type', `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$


 -- Graphic object: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Graphic object: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Draws polygons in 2D.

     2D

     `polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' or `polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': plots on the plane a polygon
     with vertices `[<x1>,<y1>]', `[<x2>,<y2>]', etc..

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$


 -- Graphic object: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Draws a quadrilateral.

     2D

     `quadrilateral ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>],
     [<x4>,<y4>])' draws a quadrilateral with vertices `[<x1>,<y1>]',
     `[<x2>,<y2>]', `[<x3>,<y3>]', and `[<x4>,<y4>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform' and
     `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     `quadrilateral ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],
     [<x3>,<y3>,<z3>], [<x4>,<y4>,<z4>])' draws a quadrilateral with
     vertices `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]',
     `[<x3>,<y3>,<z3>]', and `[<x4>,<y4>,<z4>]'.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `enhanced3d', and
     `transform'.


 -- Graphic object: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Draws rectangles in 2D.

     2D

     `rectangle ([<x1>,<y1>], [<x2>,<y2>])' draws a rectangle with
     opposite vertices `[<x1>,<y1>]' and `[<x2>,<y2>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$


 -- Graphic object: region
          (<expr>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Plots a region on the plane defined by inequalities.

     2D <expr> is an expression formed by inequalities and boolean
     operators `and', `or', and `not'. The region is bounded by the
     rectangle defined by [<minval1>, <maxval1>] and [<minval2>,
     <maxval2>].

     This object is affected by the following graphic options:
     `fill_color', `key', `x_voxel', and `y_voxel'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Graphic object: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Draws 3D functions defined in spherical coordinates.

     3D

     `spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' plots
     function `<radius>(<azi>,<zen>)' defined in spherical coordinates,
     with azimuth <azi> taking values from <minazi> to <maxazi> and
     zenith <zen> taking values from <minzen> to <maxzen>.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `key' and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$


 -- Graphic object: triangle (<point_1>, <point_2>, <point_3>)
     Draws a triangle.

     2D

     `triangle ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>])' draws a
     triangle with vertices `[<x1>,<y1>]', `[<x2>,<y2>]', and
     `[<x3>,<y3>]'.

     This object is affected by the following graphic options:
     `transparent', `fill_color', `border', `line_width', `key',
     `xaxis_secondary', `yaxis_secondary', `line_type', `transform',
     and `color'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     `triangle ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>], [<x3>,<y3>,<z3>])'
     draws a triangle with vertices `[<x1>,<y1>,<z1>]',
     `[<x2>,<y2>,<z2>]', and `[<x3>,<y3>,<z3>]'.

     This object is affected by the following graphic options:
     `line_type', `line_width', `color', `key', `enhanced3d', and
     `transform'.


 -- Graphic object: tube (<xfun>,<yfun>,<zfun>,<rfun>,<p>,<pmin>,<pmax>)
     Draws a tube in 3D with varying diameter.

     3D

     `[<xfun>,<yfun>,<zfun>]' is the parametric curve with parameter
     <p> taking values from <pmin> to <pmax>. Circles of radius <rfun>
     are placed with their centers on the parametric curve and
     perpendicular to it.

     This object is affected by the following graphic options:
     `xu_grid', `yv_grid', `line_type', `line_width', `key',
     `enhanced3d', `color', and `tube_extremes'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$


 -- Graphic object: vector ([<x>,<y>], [<dx>,<dy>])
 -- Graphic object: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Draws vectors in 2D and 3D.

     This object is affected by the following graphic options:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' and `color'.

     2D

     `vector([<x>,<y>], [<dx>,<dy>])' plots vector `[<dx>,<dy>]' with
     origin in `[<x>,<y>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' plots vector
     `[<dx>,<dy>,<dz>]' with origin in `[<x>,<y>,<z>]'.

     Example:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$




Local Variables:
coding: utf-8
End:
