This is maxima.info, produced by makeinfo version 4.13 from
/home/work/maxima/sandbox/maxima/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Functions and Variables for itensor,  Next: Introduction to ctensor,  Prev: Introduction to itensor,  Up: Tensoren

20.2 Functions and Variables for itensor
========================================

20.2.1 Managing indexed objects
-------------------------------

 -- Function: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Function: dispcon (all)
     Displays the contraction properties of its arguments as were given
     to `defcon'.  `dispcon (all)' displays all the contraction
     properties which were defined.


 -- Function: entertensor (<name>)
     is a function which, by prompting, allows one to create an indexed
     object called <name> with any number of tensorial and derivative
     indices. Either a single index or a list of indices (which may be
     null) is acceptable input (see the example under `covdiff').


 -- Function: changename (<old>, <new>, <expr>)
     will change the name of all indexed objects called <old> to <new>
     in <expr>. <old> may be either a symbol or a list of the form
     `[<name>, <m>, <n>]' in which case only those indexed objects
     called <name> with <m> covariant and <n> contravariant indices
     will be renamed to <new>.


 -- Function: listoftens
     Lists all tensors in a tensorial expression, complete with their
     indices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Function: ishow (<expr>)
     displays <expr> with the indexed objects in it shown having their
     covariant indices as subscripts and contravariant indices as
     superscripts. The derivative indices are displayed as subscripts,
     separated from the covariant indices by a comma (see the examples
     throughout this document).


 -- Function: indices (<expr>)
     Returns a list of two elements.  The first is a list of the free
     indices in <expr> (those that occur only once). The second is the
     list of the dummy indices in <expr> (those that occur exactly
     twice) as the following example demonstrates.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     A tensor product containing the same index more than twice is
     syntactically illegal. `indices' attempts to deal with these
     expressions in a reasonable manner; however, when it is called to
     operate upon such an illegal expression, its behavior should be
     considered undefined.


 -- Function: rename (<expr>)
 -- Function: rename (<expr>, <count>)
     Returns an expression equivalent to <expr> but with the dummy
     indices in each term chosen from the set `[%1, %2,...]', if the
     optional second argument is omitted. Otherwise, the dummy indices
     are indexed beginning at the value of <count>.  Each dummy index
     in a product will be different. For a sum, `rename' will operate
     upon each term in the sum resetting the counter with each term. In
     this way `rename' can serve as a tensorial simplifier. In
     addition, the indices will be sorted alphanumerically (if `allsym'
     is `true') with respect to covariant or contravariant indices
     depending upon the value of `flipflag'.  If `flipflag' is `false'
     then the indices will be renamed according to the order of the
     contravariant indices. If `flipflag' is `true' the renaming will
     occur according to the order of the covariant indices. It often
     happens that the combined effect of the two renamings will reduce
     an expression more than either one by itself.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                  %4 %5  %6 %7      u          %1         %3         %2
               - g      g      ichr2      ichr2      ichr2      ichr2
                                    %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                  %4 %5  %6 %7      u          %1         %3         %2
               - g      g      ichr2      ichr2      ichr2      ichr2
                                    %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                  %1 %2  %3 %4      %6         %5         %7        u
               - g      g      ichr2      ichr2      ichr2     ichr2
                                    %1 %3      %2 %6      %4 r      %5 %7


 -- Function: show (<expr>)
     Displays `expr' with the indexed objects in it shown having
     covariant indices as subscripts, contravariant indices as
     superscripts.  The derivative indices are displayed as subscripts,
     separated from the covariant indices by a comma.


 -- Option variable: flipflag
     Default: `false'. If `false' then the indices will be renamed
     according to the order of the contravariant indices, otherwise
     according to the order of the covariant indices.

     If `flipflag' is `false' then `rename' forms a list of the
     contravariant indices as they are encountered from left to right
     (if `true' then of the covariant indices). The first dummy index
     in the list is renamed to `%1', the next to `%2', etc.  Then
     sorting occurs after the `rename'-ing (see the example under
     `rename').


 -- Function: defcon (<tensor_1>)
 -- Function: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     gives <tensor_1> the property that the contraction of a product of
     <tensor_1> and <tensor_2> results in <tensor_3> with the
     appropriate indices.  If only one argument, <tensor_1>, is given,
     then the contraction of the product of <tensor_1> with any indexed
     object having the appropriate indices (say `my_tensor') will yield
     an indexed object with that name, i.e. `my_tensor', and with a new
     set of indices reflecting the contractions performed.      For
     example, if `imetric:g', then `defcon(g)' will implement the
     raising and lowering of indices through contraction with the metric
     tensor.      More than one `defcon' can be given for the same
     indexed object; the latest one given which applies in a particular
     contraction will be used.  `contractions' is a list of those
     indexed objects which have been given contraction properties with
     `defcon'.


 -- Function: remcon (<tensor_1>, ..., <tensor_n>)
 -- Function: remcon (all)
     removes all the contraction properties from the <tensor_1>, ...,
     <tensor_n>). `remcon(all)' removes all contraction properties from
     all indexed objects.


 -- Function: contract (<expr>)
     Carries out the tensorial contractions in <expr> which may be any
     combination of sums and products. This function uses the
     information given to the `defcon' function. For best results,
     `expr' should be fully expanded. `ratexpand' is the fastest way to
     expand products and powers of sums if there are no variables in
     the denominators of the terms. The `gcd' switch should be `false'
     if GCD cancellations are unnecessary.


 -- Function: indexed_tensor (<tensor>)
     Must be executed before assigning components to a <tensor> for
     which a built in value already exists as with `ichr1', `ichr2',
     `icurvature'. See the example under `icurvature'.


 -- Function: components (<tensor>, <expr>)
     permits one to assign an indicial value to an expression <expr>
     giving the values of the components of <tensor>. These are
     automatically substituted for the tensor whenever it occurs with
     all of its indices. The tensor must be of the form `t([...],[...])'
     where either list may be empty. <expr> can be any indexed
     expression involving other objects with the same free indices as
     <tensor>. When used to assign values to the metric tensor wherein
     the components contain dummy indices one must be careful to define
     these indices to avoid the generation of multiple dummy indices.
     Removal of this assignment is given to the function `remcomps'.

     It is important to keep in mind that `components' cares only about
     the valence of a tensor, not about any particular index ordering.
     Thus assigning components to, say, `x([i,-j],[])', `x([-j,i],[])',
     or `x([i],[j])' all produce the same result, namely components
     being assigned to a tensor named `x' with valence `(1,1)'.

     Components can be assigned to an indexed expression in four ways,
     two of which involve the use of the `components' command:

     1) As an indexed expression. For instance:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) As a matrix:


          (%i5) lg:-ident(4)$lg[1,1]:1$lg;
                                      [ 1   0    0    0  ]
                                      [                  ]
                                      [ 0  - 1   0    0  ]
          (%o5)                       [                  ]
                                      [ 0   0   - 1   0  ]
                                      [                  ]
                                      [ 0   0    0   - 1 ]

          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([1,1],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) As a function. You can use a Maxima function to specify the
     components of a tensor based on its indices. For instance, the
     following code assigns `kdelta' to `h' if `h' has the same number
     of covariant and contravariant indices and no derivative indices,
     and `g' otherwise:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Using Maxima's pattern matching capabilities, specifically the
     `defrule' and `applyb1' commands:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Function: remcomps (<tensor>)
     Unbinds all values from <tensor> which were assigned with the
     `components' function.


 -- Function: showcomps (<tensor>)
     Shows component assignments of a tensor, as made using the
     `components' command. This function can be particularly useful
     when a matrix is assigned to an indicial tensor using
     `components', as demonstrated by the following example:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     The `showcomps' command can also display components of a tensor of
     rank higher than 2.


 -- Function: idummy ()
     Increments `icounter' and returns as its value an index of the form
     `%n' where n is a positive integer.  This guarantees that dummy
     indices which are needed in forming expressions will not conflict
     with indices already in use (see the example under `indices').


 -- Option variable: idummyx
     Default value: `%'

     Is the prefix for dummy indices (see the example under `indices').


 -- Option variable: icounter
     Default value: `1'

     Determines the numerical suffix to be used in generating the next
     dummy index in the tensor package.  The prefix is determined by
     the option `idummy' (default: `%').


 -- Function: kdelta (<L1>, <L2>)
     is the generalized Kronecker delta function defined in the
     `itensor' package with <L1> the list of covariant indices and <L2>
     the list of contravariant indices.  `kdelta([i],[j])' returns the
     ordinary Kronecker delta.  The command `ev(<expr>,kdelta)' causes
     the evaluation of an expression containing `kdelta([],[])' to the
     dimension of the manifold.

     In what amounts to an abuse of this notation, `itensor' also allows
     `kdelta' to have 2 covariant and no contravariant, or 2
     contravariant and no covariant indices, in effect providing a
     co(ntra)variant "unit matrix" capability. This is strictly
     considered a programming aid and not meant to imply that
     `kdelta([i,j],[])' is a valid tensorial object.


 -- Function: kdels (<L1>, <L2>)
     Symmetricized Kronecker delta, used in some calculations. For
     instance:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Function: levi_civita (<L>)
     is the permutation (or Levi-Civita) tensor which yields 1 if the
     list <L> consists of an even permutation of integers, -1 if it
     consists of an odd permutation, and 0 if some indices in <L> are
     repeated.


 -- Function: lc2kdt (<expr>)
     Simplifies expressions containing the Levi-Civita symbol,
     converting these to Kronecker-delta expressions when possible. The
     main difference between this function and simply evaluating the
     Levi-Civita symbol is that direct evaluation often results in
     Kronecker expressions containing numerical indices. This is often
     undesirable as it prevents further simplification.  The `lc2kdt'
     function avoids this problem, yielding expressions that are more
     easily simplified with `rename' or `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     The `lc2kdt' function sometimes makes use of the metric tensor.
     If the metric tensor was not defined previously with `imetric',
     this results in an error.


          (%i7) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g
                              %3             %4               %3
                        k
                  kdelta  ) a
                        %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i    l i  j
          (%t11)                           a    - g    a
                                                        j


 -- Function: lc_l
     Simplification rule used for expressions containing the
     unevaluated Levi-Civita symbol (`levi_civita'). Along with `lc_u',
     it can be used to simplify many expressions more efficiently than
     the evaluation of `levi_civita'.  For example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
          (%t4)                                  0
          (%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
          (%t5)                                  0


 -- Function: lc_u
     Simplification rule used for expressions containing the
     unevaluated Levi-Civita symbol (`levi_civita'). Along with `lc_u',
     it can be used to simplify many expressions more efficiently than
     the evaluation of `levi_civita'.  For details, see `lc_l'.


 -- Function: canten (<expr>)
     Simplifies <expr> by renaming (see `rename') and permuting dummy
     indices. `rename' is restricted to sums of tensor products in
     which no derivatives are present. As such it is limited and should
     only be used if `canform' is not capable of carrying out the
     required simplification.

     The `canten' function returns a mathematically correct result only
     if its argument is an expression that is fully symmetric in its
     indices.  For this reason, `canten' returns an error if `allsym'
     is not set to `true'.


 -- Function: concan (<expr>)
     Similar to `canten' but also performs index contraction.


20.2.2 Tensor symmetries
------------------------

 -- Option variable: allsym
     Default: `false'. if `true' then all indexed objects are assumed
     symmetric in all of their covariant and contravariant indices. If
     `false' then no symmetries of any kind are assumed in these
     indices. Derivative indices are always taken to be symmetric
     unless `iframe_flag' is set to `true'.


 -- Function: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declares symmetry properties for <tensor> of <m> covariant and <n>
     contravariant indices. The <cov_i> and <contr_i> are
     pseudofunctions expressing symmetry relations among the covariant
     and contravariant indices respectively.  These are of the form
     `symoper(<index_1>, <index_2>,...)' where `symoper' is one of
     `sym', `anti' or `cyc' and the <index_i> are integers indicating
     the position of the index in the <tensor>.  This will declare
     <tensor> to be symmetric, antisymmetric or cyclic respectively in
     the <index_i>. `symoper(all)' is also an allowable form which
     indicates all indices obey the symmetry condition. For example,
     given an object `b' with 5 covariant indices,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declares `b'
     symmetric in its first and second and antisymmetric in its third
     and fourth covariant indices, and cyclic in all of its
     contravariant indices.  Either list of symmetry declarations may
     be null.  The function which performs the simplifications is
     `canform' as the example below illustrates.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract( expand( a([i1, j1, k1], [])
                     *kdels([i, j, k], [i1, j1, k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Function: remsym (<tensor>, <m>, <n>)
     Removes all symmetry properties from <tensor> which has <m>
     covariant indices and <n> contravariant indices.


 -- Function: canform (<expr>)
 -- Function: canform (<expr>, <rename>)
     Simplifies <expr> by renaming dummy indices and reordering all
     indices as dictated by symmetry conditions imposed on them. If
     `allsym' is `true' then all indices are assumed symmetric,
     otherwise symmetry information provided by `decsym' declarations
     will be used. The dummy indices are renamed in the same manner as
     in the `rename' function. When `canform' is applied to a large
     expression the calculation may take a considerable amount of time.
     This time can be shortened by calling `rename' on the expression
     first.  Also see the example under `decsym'. Note: `canform' may
     not be able to reduce an expression completely to its simplest
     form although it will always return a mathematically correct
     result.

     The optional second parameter <rename>, if set to `false',
     suppresses renaming.


20.2.3 Indicial tensor calculus
-------------------------------

 -- Function: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     is the usual Maxima differentiation function which has been
     expanded in its abilities for `itensor'. It takes the derivative
     of <expr> with respect to <v_1> <n_1> times, with respect to <v_2>
     <n_2> times, etc. For the tensor package, the function has been
     modified so that the <v_i> may be integers from 1 up to the value
     of the variable `dim'.  This will cause the differentiation to be
     carried out with respect to the <v_i>th member of the list
     `vect_coords'.  If `vect_coords' is bound to an atomic variable,
     then that variable subscripted by <v_i> will be used for the
     variable of differentiation.  This permits an array of coordinate
     names or subscripted names like `x[1]', `x[2]', ...  to be used.

     A further extension adds the ability to `diff' to compute
     derivatives with respect to an indexed variable. In particular,
     the tensor package knows how to differentiate expressions
     containing combinations of the metric tensor and its derivatives
     with respect to the metric tensor and its first and second
     derivatives. This capability is particularly useful when
     considering Lagrangian formulations of a gravitational theory,
     allowing one to derive the Einstein tensor and field equations
     from the action principle.


 -- Function: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Indicial differentiation. Unlike `diff', which differentiates with
     respect to an independent variable, `idiff)' can be used to
     differentiate with respect to a coordinate. For an indexed object,
     this amounts to appending the <v_i> as derivative indices.
     Subsequently, derivative indices will be sorted, unless
     `iframe_flag' is set to `true'.

     `idiff' can also differentiate the determinant of the metric
     tensor. Thus, if `imetric' has been bound to `G' then
     `idiff(determinant(g),k)' will return
     `2*determinant(g)*ichr2([%i,k],[%i])' where the dummy index `%i'
     is chosen appropriately.


 -- Function: liediff (<v>, <ten>)
     Computes the Lie-derivative of the tensorial expression <ten> with
     respect to the vector field <v>. <ten> should be any indexed
     tensor expression; <v> should be the name (without indices) of a
     vector field. For example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                    %1  k        %1  k      %1  k
                                + (v   b      - b   v    + v   b   ) a
                                        ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Function: rediff (<ten>)
     Evaluates all occurrences of the `idiff' command in the tensorial
     expression <ten>.


 -- Function: undiff (<expr>)
     Returns an expression equivalent to <expr> but with all derivatives
     of indexed objects replaced by the noun form of the `idiff'
     function. Its arguments would yield that indexed object if the
     differentiation were carried out.  This is useful when it is
     desired to replace a differentiated indexed object with some
     function definition resulting in <expr> and then carry out the
     differentiation by saying `ev(<expr>, idiff)'.


 -- Function: evundiff (<expr>)
     Equivalent to the execution of `undiff', followed by `ev' and
     `rediff'.

     The point of this operation is to easily evalute expressions that
     cannot be directly evaluated in derivative form. For instance, the
     following causes an error:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     However, if `icurvature' is entered in noun form, it can be
     evaluated using `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                       l              l         %1           l           %1
                + ichr2        + ichr2     ichr2      + ichr2       ichr2
                       i j,k m        %1 k      i j,m        %1 k,m      i j

     Note: In earlier versions of Maxima, derivative forms of the
     Christoffel-symbols also could not be evaluated. This has been
     fixed now, so `evundiff' is no longer necessary for expressions
     like this:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Function: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Set to zero, in <expr>, all occurrences of the <tensor_i> that
     have no derivative indices.


 -- Function: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Set to zero, in <expr>, all occurrences of the <tensor_i> that
     have derivative indices.


 -- Function: flushnd (<expr>, <tensor>, <n>)
     Set to zero, in <expr>, all occurrences of the differentiated
     object <tensor> that have <n> or more derivative indices as the
     following example demonstrates.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r


 -- Function: coord (<tensor_1>, <tensor_2>, ...)
     Gives <tensor_i> the coordinate differentiation property that the
     derivative of contravariant vector whose name is one of the
     <tensor_i> yields a Kronecker delta. For example, if `coord(x)' has
     been done then `idiff(x([],[i]),j)' gives `kdelta([i],[j])'.
     `coord' is a list of all indexed objects having this property.


 -- Function: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Function: remcoord (all)
     Removes the coordinate differentiation property from the `tensor_i'
     that was established by the function `coord'.  `remcoord(all)'
     removes this property from all indexed objects.


 -- Function: makebox (<expr>)
     Display <expr> in the same manner as `show'; however, any tensor
     d'Alembertian occurring in <expr> will be indicated using the
     symbol `[]'.  For example, `[]p([m],[n])' represents
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Function: conmetderiv (<expr>, <tensor>)
     Simplifies expressions containing ordinary derivatives of both
     covariant and contravariant forms of the metric tensor (the
     current restriction).  For example, `conmetderiv' can relate the
     derivative of the contravariant metric tensor with the Christoffel
     symbols as seen from the following:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c


 -- Function: simpmetderiv (<expr>)
 -- Function: simpmetderiv (<expr>[, <stop>])
     Simplifies expressions containing products of the derivatives of
     the metric tensor. Specifically, `simpmetderiv' recognizes two
     identities:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     hence


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     and


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     which follows from the symmetries of the Christoffel symbols.

     The `simpmetderiv' function takes one optional parameter which,
     when present, causes the function to stop after the first
     successful substitution in a product expression. The
     `simpmetderiv' function also makes use of the global variable
     <flipflag> which determines how to apply a "canonical" ordering to
     the product indices.

     Put together, these capabilities can be used to achieve powerful
     simplifications that are difficult or impossible to accomplish
     otherwise.  This is demonstrated through the following example
     that explicitly uses the partial simplification features of
     `simpmetderiv' to obtain a contractible expression:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     See also `weyl.dem' for an example that uses `simpmetderiv' and
     `conmetderiv' together to simplify contractions of the Weyl tensor.


 -- Function: flush1deriv (<expr>, <tensor>)
     Set to zero, in `expr', all occurrences of `tensor' that have
     exactly one derivative index.


20.2.4 Tensors in curved spaces
-------------------------------

 -- Function: imetric (<g>)
 -- System variable: imetric
     Specifies the metric by assigning the variable `imetric:<g>' in
     addition, the contraction properties of the metric <g> are set up
     by executing the commands `defcon(<g>),defcon(<g>,<g>,kdelta)'.
     The variable `imetric' (unbound by default), is bound to the
     metric, assigned by the `imetric(<g>)' command.


 -- Function: idim (<n>)
     Sets the dimensions of the metric. Also initializes the
     antisymmetry properties of the Levi-Civita symbols for the given
     dimension.


 -- Function: ichr1 ([<i>, <j>, <k>])
     Yields the Christoffel symbol of the first kind via the definition
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     To evaluate the Christoffel symbols for a particular metric, the
     variable `imetric' must be assigned a name as in the example under
     `chr2'.


 -- Function: ichr2 ([<i>, <j>], [<k>])
     Yields the Christoffel symbol of the second kind defined by the
     relation
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s


 -- Function: icurvature ([<i>, <j>, <k>], [<h>])
     Yields the Riemann curvature tensor in terms of the Christoffel
     symbols of the second kind (`ichr2').  The following notation is
     used:
                      h             h            h         %1         h
            icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                      i j k         i k,j        %1 j      i k        i j,k
                                      h          %1
                               + ichr2      ichr2
                                      %1 k       i j


 -- Function: covdiff (<expr>, <v_1>, <v_2>, ...)
     Yields the covariant derivative of <expr> with respect to the
     variables <v_i> in terms of the Christoffel symbols of the second
     kind (`ichr2').  In order to evaluate these, one should use
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k
          (%t3)     - a     ichr2    - a     ichr2    + a
                       i %1      j s    %1 j      i s    i j,s

                       k     %1
                + ichr2     a
                       %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s
          (%i6)


 -- Function: lorentz_gauge (<expr>)
     Imposes the Lorentz condition by substituting 0 for all indexed
     objects in <expr> that have a derivative index identical to a
     contravariant index.


 -- Function: igeodesic_coords (<expr>, <name>)
     Causes undifferentiated Christoffel symbols and first derivatives
     of the metric tensor vanish in <expr>. The <name> in the
     `igeodesic_coords' function refers to the metric <name> (if it
     appears in <expr>) while the connection coefficients must be
     called with the names `ichr1' and/or `ichr2'. The following example
     demonstrates the verification of the cyclic identity satisfied by
     the Riemann curvature tensor using the `igeodesic_coords' function.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u
          (%t2) - ichr2      - ichr2     ichr2    + ichr2
                       r t,s        %1 s      r t        r s,t

                                                        u         %1
                                                 + ichr2     ichr2
                                                        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t

                                                       u            u
                                                - ichr2      + ichr2
                                                       r t,s        r s,t
          (%i5) canform(%);
          (%o5)                                  0


20.2.5 Moving frames
--------------------

Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary
frame.

   To use frames, you must first set `iframe_flag' to `true'. This
causes the Christoffel-symbols, `ichr1' and `ichr2', to be replaced by
the more general frame connection coefficients `icc1' and `icc2' in
calculations. Speficially, the behavior of `covdiff' and `icurvature'
is changed.

   The frame is defined by two tensors: the inverse frame field (`ifri',
the dual basis tetrad), and the frame metric `ifg'. The frame metric is
the identity matrix for orthonormal frames, or the Lorentz metric for
orthonormal frames in Minkowski spacetime. The inverse frame field
defines the frame base (unit vectors).  Contraction properties are
defined for the frame field and the frame metric.

   When `iframe_flag' is true, many `itensor' expressions use the frame
metric `ifg' instead of the metric defined by `imetric' for raising and
lowerind indices.

   IMPORTANT: Setting the variable `iframe_flag' to `true' does NOT
undefine the contraction properties of a metric defined by a call to
`defcon' or `imetric'. If a frame field is used, it is best to define
the metric by assigning its name to the variable `imetric' and NOT
invoke the `imetric' function.

   Maxima uses these two tensors to define the frame coefficients
(`ifc1' and `ifc2') which form part of the connection coefficients
(`icc1' and `icc2'), as the following example demonstrates:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                                    %1     i       i
     (%t4)                         v   ifc2     + v
                                           %1 j    ,j
     (%i5) ishow(ev(%,ifc2))$
                               %1    i %2                i
     (%t5)                    v   ifg     ifc1        + v
                                              %1 j %2    ,j
     (%i6) ishow(ev(%,ifc1))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t6)      -------------------------------------------------- + v
                                        2                             ,j
     (%i7) ishow(ifb([a,b,c]))$
                                                        %3    %4
     (%t7)               (ifri        - ifri       ) ifr   ifr
                              a %3,%4       a %4,%3     b     c

   An alternate method is used to compute the frame bracket (`ifb') if
the `iframe_bracket_form' flag is set to `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                     %6    %5        %5      %6
     (%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                            a %5     b     c,%6      b,%6    c

 -- Function: iframes ()
     Since in this version of Maxima, contraction identities for `ifr'
     and `ifri' are always defined, as is the frame bracket (`ifb'),
     this function does nothing.


 -- Variable: ifb
     The frame bracket. The contribution of the frame metric to the
     connection coefficients is expressed using the frame bracket:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     The frame bracket itself is defined in terms of the frame field
     and frame metric. Two alternate methods of computation are used
     depending on the value of `frame_bracket_form'. If true (the
     default) or if the `itorsion_flag' is `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variable: icc1
     Connection coefficients of the first kind. In `itensor', defined as


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr1' is replaced with the frame connection
     coefficient `ifc1'.  If `itorsion_flag' is `false', `ikt1' will be
     omitted. It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc1' will not be present.


 -- Variable: icc2
     Connection coefficients of the second kind. In `itensor', defined
     as


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr2' is replaced with the frame connection
     coefficient `ifc2'.  If `itorsion_flag' is `false', `ikt2' will be
     omitted. It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc2' will not be present.


 -- Variable: ifc1
     Frame coefficient of the first kind (also known as Ricci-rotation
     coefficients.) This tensor represents the contribution of the
     frame metric to the connection coefficient of the first kind.
     Defined as:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variable: ifc2
     Frame coefficient of the first kind. This tensor represents the
     contribution of the frame metric to the connection coefficient of
     the first kind. Defined as a permutation of the frame bracket
     (`ifb') with the appropriate indices raised and lowered as
     necessary:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variable: ifr
     The frame field. Contracts with the inverse frame field (`ifri') to
     form the frame metric (`ifg').


 -- Variable: ifri
     The inverse frame field. Specifies the frame base (dual basis
     vectors). Along with the frame metric, it forms the basis of all
     calculations based on frames.


 -- Variable: ifg
     The frame metric. Defaults to `kdelta', but can be changed using
     `components'.


 -- Variable: ifgi
     The inverse frame metric. Contracts with the frame metric (`ifg')
     to `kdelta'.


 -- Option variable: iframe_bracket_form
     Default value: `true'

     Specifies how the frame bracket (`ifb') is computed.


20.2.6 Torsion and nonmetricity
-------------------------------

Maxima can now take into account torsion and nonmetricity. When the flag
`itorsion_flag' is set to `true', the contribution of torsion is added
to the connection coefficients. Similarly, when the flag `inonmet_flag'
is true, nonmetricity components are included.

 -- Variable: inm
     The nonmetricity vector. Conformal nonmetricity is defined through
     the covariant derivative of the metric tensor. Normally zero, the
     metric tensor's covariant derivative will evaluate to the
     following when `inonmet_flag' is set to `true':


          g     =- g  inm
           ij;k     ij   k


 -- Variable: inmc1
     Covariant permutation of the nonmetricity vector components.
     Defined as


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: inmc2
     Contravariant permutation of the nonmetricity vector components.
     Used in the connection coefficients if `inonmet_flag' is `true'.
     Defined as:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: ikt1
     Covariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: ikt2
     Contravariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: itr
     The torsion tensor. For a metric with torsion, repeated covariant
     differentiation on a scalar function will not commute, as
     demonstrated by the following example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


20.2.7 Exterior algebra
-----------------------

The `itensor' package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge
product, is defined.

   Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of two
vector fields, for instance, would be defined as

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   More generally, the product of a p-form and a q-form would be
defined as

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   where `D' stands for the Kronecker-delta.

   Other authors, however, prefer a "geometric" definition that
corresponds with the notion of the volume element:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   and, in the general case

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Since `itensor' is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications,
however, utilize the second definition. To resolve this dilemma, a flag
has been implemented that controls the behavior of the wedge product: if
`igeowedge_flag' is `false' (the default), the first, "tensorial"
definition is used, otherwise the second, "geometric" definition will
be applied.

 -- Operator: ~
     The wedge product operator is denoted by the tilde `~'. This is a
     binary operator. Its arguments should be expressions involving
     scalars, covariant tensors of rank one, or covariant tensors of
     rank `l' that have been declared antisymmetric in all covariant
     indices.

     The behavior of the wedge product operator is controlled by the
     `igeowedge_flag' flag, as in the following example:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operator: |
     The vertical bar `|' denotes the "contraction with a vector" binary
     operation. When a totally antisymmetric covariant tensor is
     contracted with a contravariant vector, the result is the same
     regardless which index was used for the contraction. Thus, it is
     possible to define the contraction operation in an index-free
     manner.

     In the `itensor' package, contraction with a vector is always
     carried out with respect to the first index in the literal sorting
     order. This ensures better simplification of expressions involving
     the `|' operator. For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note that it is essential that the tensors used with the `|'
     operator be declared totally antisymmetric in their covariant
     indices. Otherwise, the results will be incorrect.


 -- Function: extdiff (<expr>, <i>)
     Computes the exterior derivative of <expr> with respect to the
     index <i>. The exterior derivative is formally defined as the wedge
     product of the partial derivative operator and a differential
     form. As such, this operation is also controlled by the setting of
     `igeowedge_flag'.  For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                    - (a      - a      + a     )
                                       k j,i    k i,j    j i,k


 -- Function: hodge (<expr>)
     Compute the Hodge-dual of <expr>. For instance:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g
                                                               %1 %106
                                       g        g        g      A         /6
                                        %2 %107  %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Option variable: igeowedge_flag
     Default value: `false'

     Controls the behavior of the wedge product and exterior
     derivative. When set to `false' (the default), the notion of
     differential forms will correspond with that of a totally
     antisymmetric covariant tensor field.  When set to `true',
     differential forms will agree with the notion of the volume
     element.


20.2.8 Exporting TeX expressions
--------------------------------

The `itensor' package provides limited support for exporting tensor
expressions to TeX. Since `itensor' expressions appear as function
calls, the regular Maxima `tex' command will not produce the expected
output. You can try instead the `tentex' command, which attempts to
translate tensor expressions into appropriately indexed TeX objects.

 -- Function: tentex (<expr>)
     To use the `tentex' function, you must first load `tentex', as in
     the following example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
                      j k      m1 l        j l      m1 k        j l,k

                                                                i
                                                         + ichr2
                                                                j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note the use of the `idummyx' assignment, to avoid the appearance
     of the percent sign in the TeX expression, which may lead to
     compile errors.

     NB: This version of the `tentex' function is somewhat experimental.


20.2.9 Interfacing with ctensor
-------------------------------

The `itensor' package has the ability to generate Maxima code that can
then be executed in the context of the `ctensor' package. The function
that performs this task is `ic_convert'.

 -- Function: ic_convert (<eqn>)
     Converts the `itensor' equation <eqn> to a `ctensor' assignment
     statement.  Implied sums over dummy indices are made explicit
     while indexed objects are transformed into arrays (the array
     subscripts are in the order of covariant followed by contravariant
     indices of the indexed objects). The derivative of an indexed
     object will be replaced by the noun form of `diff' taken with
     respect to `ct_coords' subscripted by the derivative index. The
     Christoffel symbols `ichr1' and `ichr2' will be translated to
     `lcs' and `mcs', respectively and if `metricconvert' is `true'
     then all occurrences of the metric with two covariant
     (contravariant) indices will be renamed to `lg' (`ug'). In
     addition, `do' loops will be introduced summing over all free
     indices so that the transformed assignment statement can be
     evaluated by just doing `ev'. The following examples demonstrate
     the features of this function.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
                *b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


20.2.10 Reserved words
----------------------

The following Maxima words are used by the `itensor' package internally
and should not be redefined:

       Keyword    Comments
       ------------------------------------------
       indices2() Internal version of indices()
       conti      Lists contravariant indices
       covi       Lists covariant indices of a indexed object
       deri       Lists derivative indices of an indexed object
       name       Returns the name of an indexed object
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: Introduction to ctensor,  Next: Functions and Variables for ctensor,  Prev: Functions and Variables for itensor,  Up: Tensoren

20.3 Introduction to ctensor
============================

`ctensor' is a component tensor manipulation package.  To use the
`ctensor' package, type `load(ctensor)'.  To begin an interactive
session with `ctensor', type `csetup()'.  You are first asked to
specify the dimension of the manifold. If the dimension is 2, 3 or 4
then the list of coordinates defaults to `[x,y]', `[x,y,z]' or
`[x,y,z,t]' respectively.  These names may be changed by assigning a
new list of coordinates to the variable `ct_coords' (described below)
and the user is queried about this. Care must be taken to avoid the
coordinate names conflicting with other object definitions.

   Next, the user enters the metric either directly or from a file by
specifying its ordinal position.  The metric is stored in the matrix
`lg'. Finally, the metric inverse is computed and stored in the matrix
`ug'. One has the option of carrying out all calculations in a power
series.

   A sample protocol is begun below for the static, spherically
symmetric metric (standard coordinates) which will be applied to the
problem of deriving Einstein's vacuum equations (which lead to the
Schwarzschild solution) as an example. Many of the functions in
`ctensor' will be displayed for the standard metric as examples.

     (%i1) load(ctensor);
     (%o1)      /share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Functions and Variables for ctensor,  Next: Introduction to atensor,  Prev: Introduction to ctensor,  Up: Tensoren

20.4 Functions and Variables for ctensor
========================================

20.4.1 Initialization and setup
-------------------------------

 -- Function: csetup ()
     A function in the `ctensor' (component tensor) package which
     initializes the package and allows the user to enter a metric
     interactively. See `ctensor' for more details.


 -- Function: cmetric (<dis>)
 -- Function: cmetric ()
     A function in the `ctensor' (component tensor) package that
     computes the metric inverse and sets up the package for further
     calculations.

     If `cframe_flag' is `false', the function computes the inverse
     metric `ug' from the (user-defined) matrix `lg'. The metric
     determinant is also computed and stored in the variable `gdet'.
     Furthermore, the package determines if the metric is diagonal and
     sets the value of `diagmetric' accordingly. If the optional
     argument <dis> is present and not equal to `false', the user is
     prompted to see the metric inverse.

     If `cframe_flag' is `true', the function expects that the values of
     `fri' (the inverse frame matrix) and `lfg' (the frame metric) are
     defined. From these, the frame matrix `fr' and the inverse frame
     metric `ufg' are computed.


 -- Function: ct_coordsys (<coordinate_system>, <extra_arg>)
 -- Function: ct_coordsys (<coordinate_system>)
     Sets up a predefined coordinate system and metric. The argument
     <coordinate_system> can be one of the following symbols:


           SYMBOL             Dim Coordinates     Description/comments
           ------------------------------------------------------------------
           cartesian2d           2  [x,y]             Cartesian 2D coordinate
                                                      system
           polar                 2  [r,phi]           Polar coordinate system
           elliptic              2  [u,v]             Elliptic coord. system
           confocalelliptic      2  [u,v]             Confocal elliptic
                                                      coordinates
           bipolar               2  [u,v]             Bipolar coord. system
           parabolic             2  [u,v]             Parabolic coord. system
           cartesian3d           3  [x,y,z]           Cartesian 3D coordinate
                                                      system
           polarcylindrical      3  [r,theta,z]       Polar 2D with
                                                      cylindrical z
           ellipticcylindrical   3  [u,v,z]           Elliptic 2D with
                                                      cylindrical z
           confocalellipsoidal   3  [u,v,w]           Confocal ellipsoidal
           bipolarcylindrical    3  [u,v,z]           Bipolar 2D with
                                                      cylindrical z
           paraboliccylindrical  3  [u,v,z]           Parabolic 2D with
                                                      cylindrical z
           paraboloidal          3  [u,v,phi]         Paraboloidal coords.
           conical               3  [u,v,w]           Conical coordinates
           toroidal              3  [u,v,phi]         Toroidal coordinates
           spherical             3  [r,theta,phi]     Spherical coord. system
           oblatespheroidal      3  [u,v,phi]         Oblate spheroidal
                                                      coordinates
           oblatespheroidalsqrt  3  [u,v,phi]
           prolatespheroidal     3  [u,v,phi]         Prolate spheroidal
                                                      coordinates
           prolatespheroidalsqrt 3  [u,v,phi]
           ellipsoidal           3  [r,theta,phi]     Ellipsoidal coordinates
           cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate
                                                      system
           spherical4d           4  [r,theta,eta,phi] Spherical 4D coordinate
                                                      system
           exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
           interiorschwarzschild 4  [t,z,u,v]         Interior Schwarzschild
                                                      metric
           kerr_newman           4  [t,r,theta,phi]   Charged axially
                                                      symmetric metric

     `coordinate_system' can also be a list of transformation functions,
     followed by a list containing the coordinate variables. For
     instance, you can specify a spherical metric as follows:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Transformation functions can also be used when `cframe_flag' is
     `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
          (%o4)
           [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
           [                                                                ]
           [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
           [                                                                ]
           [    sin(theta)           r cos(theta)                0          ]

          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     The optional argument <extra_arg> can be any one of the following:

     `cylindrical' tells `ct_coordsys' to attach an additional
     cylindrical coordinate.

     `minkowski' tells `ct_coordsys' to attach an additional coordinate
     with negative metric signature.

     `all' tells `ct_coordsys' to call `cmetric' and `christof(false)'
     after setting up the metric.

     If the global variable `verbose' is set to `true', `ct_coordsys'
     displays the values of `dim', `ct_coords', and either `lg' or
     `lfg' and `fri', depending on the value of `cframe_flag'.


 -- Function: init_ctensor ()
     Initializes the `ctensor' package.

     The `init_ctensor' function reinitializes the `ctensor' package.
     It removes all arrays and matrices used by `ctensor', resets all
     flags, resets `dim' to 4, and resets the frame metric to the
     Lorentz-frame.


20.4.2 The tensors of curved space
----------------------------------

The main purpose of the `ctensor' package is to compute the tensors of
curved space(time), most notably the tensors used in general relativity.

   When a metric base is used, `ctensor' can compute the following
tensors:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' can also work using moving frames. When `cframe_flag' is
set to `true', the following tensors can be calculated:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Function: christof (<dis>)
     A function in the `ctensor' (component tensor) package.  It
     computes the Christoffel symbols of both kinds.  The argument
     <dis> determines which results are to be immediately displayed.
     The Christoffel symbols of the first and second kinds are stored
     in the arrays `lcs[i,j,k]' and `mcs[i,j,k]' respectively and
     defined to be symmetric in the first two indices. If the argument
     to `christof' is `lcs' or `mcs' then the unique non-zero values of
     `lcs[i,j,k]' or `mcs[i,j,k]', respectively, will be displayed. If
     the argument is `all' then the unique non-zero values of
     `lcs[i,j,k]' and `mcs[i,j,k]' will be displayed.  If the argument
     is `false' then the display of the elements will not occur. The
     array elements `mcs[i,j,k]' are defined in such a manner that the
     final index is contravariant.


 -- Function: ricci (<dis>)
     A function in the `ctensor' (component tensor) package. `ricci'
     computes the covariant (symmetric) components `ric[i,j]' of the
     Ricci tensor.  If the argument <dis> is `true', then the non-zero
     components are displayed.


 -- Function: uricci (<dis>)
     This function first computes the covariant components `ric[i,j]'
     of the Ricci tensor.  Then the mixed Ricci tensor is computed
     using the contravariant metric tensor.  If the value of the
     argument <dis> is `true', then these mixed components, `uric[i,j]'
     (the index `i' is covariant and the index `j' is contravariant),
     will be displayed directly.  Otherwise, `ricci(false)' will simply
     compute the entries of the array `uric[i,j]' without displaying
     the results.


 -- Function: scurvature ()
     Returns the scalar curvature (obtained by contracting the Ricci
     tensor) of the Riemannian manifold with the given metric.


 -- Function: einstein (<dis>)
     A function in the `ctensor' (component tensor) package.
     `einstein' computes the mixed Einstein tensor after the
     Christoffel symbols and Ricci tensor have been obtained (with the
     functions `christof' and `ricci').  If the argument <dis> is
     `true', then the non-zero values of the mixed Einstein tensor
     `ein[i,j]' will be displayed where `j' is the contravariant index.
     The variable `rateinstein' will cause the rational simplification
     on these components. If `ratfac' is `true' then the components will
     also be factored.


 -- Function: leinstein (<dis>)
     Covariant Einstein-tensor. `leinstein' stores the values of the
     covariant Einstein tensor in the array `lein'. The covariant
     Einstein-tensor is computed from the mixed Einstein tensor `ein'
     by multiplying it with the metric tensor. If the argument <dis> is
     `true', then the non-zero values of the covariant Einstein tensor
     are displayed.


 -- Function: riemann (<dis>)
     A function in the `ctensor' (component tensor) package.  `riemann'
     computes the Riemann curvature tensor from the given metric and
     the corresponding Christoffel symbols. The following index
     conventions are used:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     This notation is consistent with the notation used by the `itensor'
     package and its `icurvature' function.  If the optional argument
     <dis> is `true', the non-zero components `riem[i,j,k,l]' will be
     displayed.  As with the Einstein tensor, various switches set by
     the user control the simplification of the components of the
     Riemann tensor.  If `ratriemann' is `true', then rational
     simplification will be done. If `ratfac' is `true' then each of
     the components will also be factored.

     If the variable `cframe_flag' is `false', the Riemann tensor is
     computed directly from the Christoffel-symbols. If `cframe_flag' is
     `true', the covariant Riemann-tensor is computed first from the
     frame field coefficients.


 -- Function: lriemann (<dis>)
     Covariant Riemann-tensor (`lriem[]').

     Computes the covariant Riemann-tensor as the array `lriem'. If the
     argument <dis> is `true', unique nonzero values are displayed.

     If the variable `cframe_flag' is `true', the covariant Riemann
     tensor is computed directly from the frame field coefficients.
     Otherwise, the (3,1) Riemann tensor is computed first.

     For information on index ordering, see `riemann'.


 -- Function: uriemann (<dis>)
     Computes the contravariant components of the Riemann curvature
     tensor as array elements `uriem[i,j,k,l]'.  These are displayed if
     <dis> is `true'.


 -- Function: rinvariant ()
     Forms the Kretchmann-invariant (`kinvariant') obtained by
     contracting the tensors

          lriem[i,j,k,l]*uriem[i,j,k,l].

     This object is not automatically simplified since it can be very
     large.


 -- Function: weyl (<dis>)
     Computes the Weyl conformal tensor.  If the argument <dis> is
     `true', the non-zero components `weyl[i,j,k,l]' will be displayed
     to the user.  Otherwise, these components will simply be computed
     and stored.  If the switch `ratweyl' is set to `true', then the
     components will be rationally simplified; if `ratfac' is `true'
     then the results will be factored as well.


20.4.3 Taylor series expansion
------------------------------

The `ctensor' package has the ability to truncate results by assuming
that they are Taylor-series approximations. This behavior is controlled
by the `ctayswitch' variable; when set to true, `ctensor' makes use
internally of the function `ctaylor' when simplifying results.

   The `ctaylor' function is invoked by the following `ctensor'
functions:


         Function     Comments
         ---------------------------------
         christof()   For mcs only
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Function: ctaylor ()
     The `ctaylor' function truncates its argument by converting it to
     a Taylor-series using `taylor', and then calling `ratdisrep'. This
     has the combined effect of dropping terms higher order in the
     expansion variable `ctayvar'. The order of terms that should be
     dropped is defined by `ctaypov'; the point around which the series
     expansion is carried out is specified in `ctaypt'.

     As an example, consider a simple metric that is a perturbation of
     the Minkowski metric. Without further restrictions, even a diagonal
     metric produces expressions for the Einstein tensor that are far
     too complex:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                          [0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                [ h11 l - 1      0          0                 0            ]
                [                                                          ]
                [     0      h22 l + 1      0                 0            ]
                [                                                          ]
          (%o8) [                        2                                 ]
                [     0          0      r  + h33 l            0            ]
                [                                                          ]
                [                                    2    2                ]
                [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     However, if we recompute this example as an approximation that is
     linear in the variable `l', we get much simpler expressions:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                      2               2      4    2
                        - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                 r r                r

     This capability can be useful, for instance, when working in the
     weak field limit far from a gravitational source.


20.4.4 Frame fields
-------------------

When the variable `cframe_flag' is set to true, the `ctensor' package
performs its calculations using a moving frame.

 -- Function: frame_bracket (<fr>, <fri>, <diagframe>)
     The frame bracket (`fb[]').

     Computes the frame bracket according to the following definition:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


20.4.5 Algebraic classification
-------------------------------

A new feature (as of November, 2004) of `ctensor' is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
`share/tensor/petrov.dem'.

 -- Function: nptetrad ()
     Computes a Newman-Penrose null tetrad (`np') and its raised-index
     counterpart (`npi'). See `petrov' for an example.

     The null tetrad is constructed on the assumption that a
     four-diemensional orthonormal frame metric with metric signature
     (-,+,+,+) is being used.  The components of the null tetrad are
     related to the inverse frame matrix as follows:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Function: psi (<dis>)
     Computes the five Newman-Penrose coefficients `psi[0]'...`psi[4]'.
     If `psi' is set to `true', the coefficients are displayed.  See
     `petrov' for an example.

     These coefficients are computed from the Weyl-tensor in a
     coordinate base.  If a frame base is used, the Weyl-tensor is
     first converted to a coordinate base, which can be a
     computationally expensive procedure. For this reason, in some
     cases it may be more advantageous to use a coordinate base in the
     first place before the Weyl tensor is computed. Note however, that
     constructing a Newman-Penrose null tetrad requires a frame base.
     Therefore, a meaningful computation sequence may begin with a
     frame base, which is then used to compute `lg' (computed
     automatically by `cmetric' and then `ug'. At this point, you can
     switch back to a coordinate base by setting `cframe_flag' to false
     before beginning to compute the Christoffel symbols. Changing to a
     frame base at a later stage could yield inconsistent results, as
     you may end up with a mixed bag of tensors, some computed in a
     frame base, some in a coordinate base, with no means to
     distinguish between the two.


 -- Function: petrov ()
     Computes the Petrov classification of the metric characterized by
     `psi[0]'...`psi[4]'.

     For example, the following demonstrates how to obtain the
     Petrov-classification of the Kerr metric:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

          [ sqrt(r - 2 m)           sqrt(r)                                 ]
          [---------------   ---------------------    0            0        ]
          [sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
          [                                                                 ]
          [ sqrt(r - 2 m)            sqrt(r)                                ]
          [---------------  - ---------------------   0            0        ]
          [sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
          [                                                                 ]
          [                                          r      %i r sin(theta) ]
          [       0                    0          -------   --------------- ]
          [                                       sqrt(2)       sqrt(2)     ]
          [                                                                 ]
          [                                          r       %i r sin(theta)]
          [       0                    0          -------  - ---------------]
          [                                       sqrt(2)        sqrt(2)    ]

                                       sqrt(r)         sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     The Petrov classification function is based on the algorithm
     published in "Classifying geometries in general relativity: III
     Classification in practice" by Pollney, Skea, and d'Inverno,
     Class. Quant. Grav. 17 2885-2902 (2000).  Except for some simple
     test cases, the implementation is untested as of December 19,
     2004, and is likely to contain errors.


20.4.6 Torsion and nonmetricity
-------------------------------

`ctensor' has the ability to compute and include torsion and
nonmetricity coefficients in the connection coefficients.

   The torsion coefficients are calculated from a user-supplied tensor
`tr', which should be a rank (2,1) tensor. From this, the torsion
coefficients `kt' are computed according to the following formulae:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note that only the mixed-index tensor is calculated and stored in the
array `kt'.

   The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector `nm'. From this, the nonmetricity coefficients
`nmc' are computed as follows:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   where D stands for the Kronecker-delta.

   When `ctorsion_flag' is set to `true', the values of `kt' are
substracted from the mixed-indexed connection coefficients computed by
`christof' and stored in `mcs'. Similarly, if `cnonmet_flag' is set to
`true', the values of `nmc' are substracted from the mixed-indexed
connection coefficients.

   If necessary, `christof' calls the functions `contortion' and
`nonmetricity' in order to compute `kt' and `nm'.

 -- Function: contortion (<tr>)
     Computes the (2,1) contortion coefficients from the torsion tensor
     <tr>.


 -- Function: nonmetricity (<nm>)
     Computes the (2,1) nonmetricity coefficients from the nonmetricity
     vector <nm>.


20.4.7 Miscellaneous features
-----------------------------

 -- Function: ctransform (<M>)
     A function in the `ctensor' (component tensor) package which will
     perform a coordinate transformation upon an arbitrary square
     symmetric matrix <M>. The user must input the functions which
     define the transformation.  (Formerly called `transform'.)


 -- Function: findde (<A>, <n>)
     returns a list of the unique differential equations (expressions)
     corresponding to the elements of the <n> dimensional square array
     <A>. Presently, <n> may be 2 or 3. `deindex' is a global list
     containing the indices of <A> corresponding to these unique
     differential equations. For the Einstein tensor (`ein'), which is
     a two dimensional array, if computed for the metric in the example
     below, `findde' gives the following independent differential
     equations:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                                        [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
                  x                     x x         x        x    x

                                                        2          2
                                    + 2 a d d   - 2 a  d , a  x + a  - a]
                                             x       x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Function: cograd ()
     Computes the covariant gradient of a scalar function allowing the
     user to choose the corresponding vector name as the example under
     `contragrad' illustrates.


 -- Function: contragrad ()
     Computes the contravariant gradient of a scalar function allowing
     the user to choose the corresponding vector name as the example
     below for the Schwarzschild metric illustrates:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Function: dscalar ()
     computes the tensor d'Alembertian of the scalar function once
     dependencies have been declared upon the function. For example:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Function: checkdiv ()
     computes the covariant divergence of the mixed second rank tensor
     (whose first index must be covariant) by printing the
     corresponding n components of the vector field (the divergence)
     where n = `dim'. If the argument to the function is `g' then the
     divergence of the Einstein tensor will be formed and must be zero.
     In addition, the divergence (vector) is given the array name `div'.


 -- Function: cgeodesic (<dis>)
     A function in the `ctensor' (component tensor) package.
     `cgeodesic' computes the geodesic equations of motion for a given
     metric.  They are stored in the array `geod[i]'.  If the argument
     <dis> is `true' then these equations are displayed.


 -- Function: bdvac (<f>)
     generates the covariant components of the vacuum field equations of
     the Brans- Dicke gravitational theory. The scalar field is
     specified by the argument <f>, which should be a (quoted) function
     name with functional dependencies, e.g., `'p(x)'.

     The components of the second rank covariant field tensor are
     represented by the array `bd'.


 -- Function: invariant1 ()
     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of R^2. The field equations are the
     components of an array named `inv1'.


 -- Function: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of `ric[i,j]*uriem[i,j]'. The field
     equations are the components of an array named `inv2'.


 -- Function: bimetric ()
     *** NOT YET IMPLEMENTED ***

     generates the field equations of Rosen's bimetric theory. The field
     equations are the components of an array named `rosen'.


20.4.8 Utility functions
------------------------

 -- Function: diagmatrixp (<M>)
     Returns `true' if <M> is a diagonal matrix or (2D) array.


 -- Function: symmetricp (<M>)
     Returns `true' if <M> is a symmetric matrix or (2D) array.


 -- Function: ntermst (<f>)
     gives the user a quick picture of the "size" of the doubly
     subscripted tensor (array) <f>.  It prints two element lists where
     the second element corresponds to NTERMS of the components
     specified by the first elements.  In this way, it is possible to
     quickly find the non-zero expressions and attempt simplification.


 -- Function: cdisplay (<ten>)
     displays all the elements of the tensor <ten>, as represented by a
     multidimensional array. Tensors of rank 0 and 1, as well as other
     types of variables, are displayed as with `ldisplay'. Tensors of
     rank 2 are displayed as 2-dimensional matrices, while tensors of
     higher rank are displayed as a list of 2-dimensional matrices. For
     instance, the Riemann-tensor of the Schwarzschild metric can be
     viewed as:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                    [ 0               0                   0           0     ]
                    [                                                       ]
                    [                              2                        ]
                    [      3 m (r - 2 m)   m    2 m                         ]
                    [ 0  - ------------- + -- - ----      0           0     ]
                    [            4          3     4                         ]
                    [           r          r     r                          ]
                    [                                                       ]
          riem    = [                                m (r - 2 m)            ]
              1, 1  [ 0               0              -----------      0     ]
                    [                                     4                 ]
                    [                                    r                  ]
                    [                                                       ]
                    [                                           m (r - 2 m) ]
                    [ 0               0                   0     ----------- ]
                    [                                                4      ]
                    [                                               r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                       [     2 m                                         ]
                       [ ------------  0        0               0        ]
                       [  2                                              ]
                       [ r  (r - 2 m)                                    ]
                       [                                                 ]
                       [      0        0        0               0        ]
                       [                                                 ]
            riem     = [                         m                       ]
                2, 2   [      0        0  - ------------        0        ]
                       [                     2                           ]
                       [                    r  (r - 2 m)                 ]
                       [                                                 ]
                       [                                         m       ]
                       [      0        0        0         - ------------ ]
                       [                                     2           ]
                       [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                     [        2                                             ]
                     [   m sin (theta)                                      ]
                     [ - -------------         0                0         0 ]
                     [         r                                            ]
                     [                                                      ]
                     [                         2                            ]
                     [                    m sin (theta)                     ]
          riem     = [        0         - -------------         0         0 ]
              4, 4   [                          r                           ]
                     [                                                      ]
                     [                                          2           ]
                     [                                   2 m sin (theta)    ]
                     [        0                0         ---------------  0 ]
                     [                                          r           ]
                     [                                                      ]
                     [        0                0                0         0 ]

          (%o5)                                done


 -- Function: deleten (<L>, <n>)
     Returns a new list consisting of <L> with the <n>'th element
     deleted.


20.4.9 Variables used by `ctensor'
----------------------------------

 -- Option variable: dim
     Default value: 4

     An option in the `ctensor' (component tensor) package.  `dim' is
     the dimension of the manifold with the default 4. The command
     `dim: n' will reset the dimension to any other value `n'.


 -- Option variable: diagmetric
     Default value: `false'

     An option in the `ctensor' (component tensor) package.  If
     `diagmetric' is `true' special routines compute all geometrical
     objects (which contain the metric tensor explicitly) by taking
     into consideration the diagonality of the metric. Reduced run
     times will, of course, result. Note: this option is set
     automatically by `csetup' if a diagonal metric is specified.


 -- Option variable: ctrgsimp
     Causes trigonometric simplifications to be used when tensors are
     computed. Presently, `ctrgsimp' affects only computations
     involving a moving frame.


 -- Option variable: cframe_flag
     Causes computations to be performed relative to a moving frame as
     opposed to a holonomic metric. The frame is defined by the inverse
     frame array `fri' and the frame metric `lfg'. For computations
     using a Cartesian frame, `lfg' should be the unit matrix of the
     appropriate dimension; for computations in a Lorentz frame, `lfg'
     should have the appropriate signature.


 -- Option variable: ctorsion_flag
     Causes the contortion tensor to be included in the computation of
     the connection coefficients. The contortion tensor itself is
     computed by `contortion' from the user-supplied tensor `tr'.


 -- Option variable: cnonmet_flag
     Causes the nonmetricity coefficients to be included in the
     computation of the connection coefficients. The nonmetricity
     coefficients are computed from the user-supplied nonmetricity
     vector `nm' by the function `nonmetricity'.


 -- Option variable: ctayswitch
     If set to `true', causes some `ctensor' computations to be carried
     out using Taylor-series expansions. Presently, `christof', `ricci',
     `uricci', `einstein', and `weyl' take into account this setting.


 -- Option variable: ctayvar
     Variable used for Taylor-series expansion if `ctayswitch' is set to
     `true'.


 -- Option variable: ctaypov
     Maximum power used in Taylor-series expansion when `ctayswitch' is
     set to `true'.


 -- Option variable: ctaypt
     Point around which Taylor-series expansion is carried out when
     `ctayswitch' is set to `true'.


 -- System variable: gdet
     The determinant of the metric tensor `lg'. Computed by `cmetric'
     when `cframe_flag' is set to `false'.


 -- Option variable: ratchristof
     Causes rational simplification to be applied by `christof'.


 -- Option variable: rateinstein
     Default value: `true'

     If `true' rational simplification will be performed on the
     non-zero components of Einstein tensors; if `ratfac' is `true'
     then the components will also be factored.


 -- Option variable: ratriemann
     Default value: `true'

     One of the switches which controls simplification of Riemann
     tensors; if `true', then rational simplification will be done; if
     `ratfac' is `true' then each of the components will also be
     factored.


 -- Option variable: ratweyl
     Default value: `true'

     If `true', this switch causes the `weyl' function to apply
     rational simplification to the values of the Weyl tensor. If
     `ratfac' is `true', then the components will also be factored.


 -- Variable: lfg
     The covariant frame metric. By default, it is initialized to the
     4-dimensional Lorentz frame with signature (+,+,+,-). Used when
     `cframe_flag' is `true'.


 -- Variable: ufg
     The inverse frame metric. Computed from `lfg' when `cmetric' is
     called while `cframe_flag' is set to `true'.


 -- Variable: riem
     The (3,1) Riemann tensor. Computed when the function `riemann' is
     invoked. For information about index ordering, see the description
     of `riemann'.

     If `cframe_flag' is `true', `riem' is computed from the covariant
     Riemann-tensor `lriem'.


 -- Variable: lriem
     The covariant Riemann tensor. Computed by `lriemann'.


 -- Variable: uriem
     The contravariant Riemann tensor. Computed by `uriemann'.


 -- Variable: ric
     The mixed Ricci-tensor. Computed by `ricci'.


 -- Variable: uric
     The contravariant Ricci-tensor. Computed by `uricci'.


 -- Variable: lg
     The metric tensor. This tensor must be specified (as a `dim' by
     `dim' matrix) before other computations can be performed.


 -- Variable: ug
     The inverse of the metric tensor. Computed by `cmetric'.


 -- Variable: weyl
     The Weyl tensor. Computed by `weyl'.


 -- Variable: fb
     Frame bracket coefficients, as computed by `frame_bracket'.


 -- Variable: kinvariant
     The Kretchmann invariant. Computed by `rinvariant'.


 -- Variable: np
     A Newman-Penrose null tetrad. Computed by `nptetrad'.


 -- Variable: npi
     The raised-index Newman-Penrose null tetrad. Computed by
     `nptetrad'.  Defined as `ug.np'. The product `np.transpose(npi)'
     is constant:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variable: tr
     User-supplied rank-3 tensor representing torsion. Used by
     `contortion'.


 -- Variable: kt
     The contortion tensor, computed from `tr' by `contortion'.


 -- Variable: nm
     User-supplied nonmetricity vector. Used by `nonmetricity'.


 -- Variable: nmc
     The nonmetricity coefficients, computed from `nm' by
     `nonmetricity'.


 -- System variable: tensorkill
     Variable indicating if the tensor package has been initialized.
     Set and used by `csetup', reset by `init_ctensor'.


 -- Option variable: ct_coords
     Default value: `[]'

     An option in the `ctensor' (component tensor) package.
     `ct_coords' contains a list of coordinates.  While normally
     defined when the function `csetup' is called, one may redefine the
     coordinates with the assignment `ct_coords: [j1, j2, ..., jn]'
     where the j's are the new coordinate names.  See also `csetup'.


20.4.10 Reserved names
----------------------

The following names are used internally by the `ctensor' package and
should not be redefined:

       Name         Description
       ---------------------------------------------------------------------
       _lg()        Evaluates to lfg if frame metric used, lg otherwise
       _ug()        Evaluates to ufg if frame metric used, ug otherwise
       cleanup()    Removes items drom the deindex list
       contract4()  Used by psi()
       filemet()    Used by csetup() when reading the metric from a file
       findde1()    Used by findde()
       findde2()    Used by findde()
       findde3()    Used by findde()
       kdelt()      Kronecker-delta (not generalized)
       newmet()     Used by csetup() for setting up a metric interactively
       setflags()   Used by init_ctensor()
       readvalue()
       resimp()
       sermet()     Used by csetup() for entering a metric as Taylor-series
       txyzsum()
       tmetric()    Frame metric, used by cmetric() when cframe_flag:true
       triemann()   Riemann-tensor in frame base, used when cframe_flag:true
       tricci()     Ricci-tensor in frame base, used when cframe_flag:true
       trrc()       Ricci rotation coefficients, used by christof()
       yesp()

20.4.11 Changes
---------------

In November, 2004, the `ctensor' package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of Macsyma.

       New Name     Old Name        Description
       ---------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
       lgeod[]      EM              Geodesic equations
       ein[]        G[]             Mixed Einstein-tensor
       ric[]        LR[]            Mixed Ricci-tensor
       ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
       ctaypov      MINP            Maximum power in Taylor-series expansion
       cgeodesic()  MOTION          Compute geodesic equations
       ct_coords    OMEGA           Metric coordinates
       ctayvar      PARAM           Taylor-series expansion variable
       lriem[]      R[]             Covariant Riemann-tensor
       uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
       ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
       uric[]       RICCI[]         Contravariant Ricci-tensor
       uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
       cmetric()    SETMETRIC()     Set up the metric
       ctaypt       TAYPT           Point for Taylor-series expansion
       ctayswitch   TAYSWITCH       Taylor-series setting switch
       csetup()     TSETUP()        Start interactive setup session
       ctransform() TTRANSFORM()    Interactive coordinate transformation
       uriem[]      UR[]            Contravariant Riemann-tensor
       weyl[]       W[]             (3,1) Weyl-tensor


File: maxima.info,  Node: Introduction to atensor,  Next: Functions and Variables for atensor,  Prev: Functions and Variables for ctensor,  Up: Tensoren

20.5 Introduction to atensor
============================

`atensor' is an algebraic tensor manipulation package. To use `atensor',
type `load(atensor)', followed by a call to the `init_atensor' function.

   The essence of `atensor' is a set of simplification rules for the
noncommutative (dot) product operator ("`.'"). `atensor' recognizes
several algebra types; the corresponding simplification rules are put
into effect when the `init_atensor' function is called.

   The capabilities of `atensor' can be demonstrated by defining the
algebra of quaternions as a Clifford-algebra Cl(0,2) with two basis
vectors. The three quaternionic imaginary units are then the two basis
vectors and their product, i.e.:

         i = v     j = v     k = v  . v
              1         2         1    2

   Although the `atensor' package has a built-in definition for the
quaternion algebra, it is not used in this example, in which we
endeavour to build the quaternion multiplication table as a matrix:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  . v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  . v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  . v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  . v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  . v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' recognizes as base vectors indexed symbols, where the
symbol is that stored in `asymbol' and the index runs between 1 and
`adim'.  For indexed symbols, and indexed symbols only, the bilinear
forms `sf', `af', and `av' are evaluated. The evaluation substitutes
the value of `aform[i,j]' in place of `fun(v[i],v[j])' where `v'
represents the value of `asymbol' and `fun' is either `af' or `sf'; or,
it substitutes `v[aform[i,j]]' in place of `av(v[i],v[j])'.

   Needless to say, the functions `sf', `af' and `av' can be redefined.

   When the `atensor' package is loaded, the following flags are set:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   If you wish to experiment with a nonassociative algebra, you may also
consider setting `dotassoc' to `false'. In this case, however,
`atensimp' will not always be able to obtain the desired
simplifications.


File: maxima.info,  Node: Functions and Variables for atensor,  Prev: Introduction to atensor,  Up: Tensoren

20.6 Functions and Variables for atensor
========================================

 -- Function: init_atensor (<alg_type>, <opt_dims>)
 -- Function: init_atensor (<alg_type>)
     Initializes the `atensor' package with the specified algebra type.
     <alg_type> can be one of the following:

     `universal': The universal algebra has no commutation rules.

     `grassmann': The Grassman algebra is defined by the commutation
     relation `u.v+v.u=0'.

     `clifford': The Clifford algebra is defined by the commutation
     relation `u.v+v.u=-2*sf(u,v)' where `sf' is a symmetric
     scalar-valued function. For this algebra, <opt_dims> can be up to
     three nonnegative integers, representing the number of positive,
     degenerate, and negative dimensions of the algebra, respectively.
     If any <opt_dims> values are supplied, `atensor' will configure the
     values of `adim' and `aform' appropriately. Otherwise, `adim' will
     default to 0 and `aform' will not be defined.

     `symmetric': The symmetric algebra is defined by the commutation
     relation `u.v-v.u=0'.

     `symplectic': The symplectic algebra is defined by the commutation
     relation `u.v-v.u=2*af(u,v)' where `af' is an antisymmetric
     scalar-valued function. For the symplectic algebra, <opt_dims> can
     be up to two nonnegative integers, representing the nondegenerate
     and degenerate dimensions, respectively. If any <opt_dims> values
     are supplied, `atensor' will configure the values of `adim' and
     `aform' appropriately. Otherwise, `adim' will default to 0 and
     `aform' will not be defined.

     `lie_envelop': The algebra of the Lie envelope is defined by the
     commutation relation `u.v-v.u=2*av(u,v)' where `av' is an
     antisymmetric function.

     The `init_atensor' function also recognizes several predefined
     algebra types:

     `complex' implements the algebra of complex numbers as the
     Clifford algebra Cl(0,1). The call `init_atensor(complex)' is
     equivalent to `init_atensor(clifford,0,0,1)'.

     `quaternion' implements the algebra of quaternions. The call
     `init_atensor(quaternion)' is equivalent to
     `init_atensor(clifford,0,0,2)'.

     `pauli' implements the algebra of Pauli-spinors as the
     Clifford-algebra Cl(3,0). A call to `init_atensor(pauli)' is
     equivalent to `init_atensor(clifford,3)'.

     `dirac' implements the algebra of Dirac-spinors as the
     Clifford-algebra Cl(3,1). A call to `init_atensor(dirac)' is
     equivalent to `init_atensor(clifford,3,0,1)'.


 -- Function: atensimp (<expr>)
     Simplifies an algebraic tensor expression <expr> according to the
     rules configured by a call to `init_atensor'. Simplification
     includes recursive application of commutation relations and
     resolving calls to `sf', `af', and `av' where applicable. A
     safeguard is used to ensure that the function always terminates,
     even for complex expressions.


 -- Function: alg_type
     The algebra type. Valid values are `universal', `grassmann',
     `clifford', `symmetric', `symplectic' and `lie_envelop'.


 -- Variable: adim
     Default value: 0

     The dimensionality of the algebra. `atensor' uses the value of
     `adim' to determine if an indexed object is a valid base vector.
     See `abasep'.


 -- Variable: aform
     Default value: `ident(3)'

     Default values for the bilinear forms `sf', `af', and `av'. The
     default is the identity matrix `ident(3)'.


 -- Variable: asymbol
     Default value: `v'

     The symbol for base vectors.


 -- Function: sf (<u>, <v>)
     A symmetric scalar function that is used in commutation relations.
     The default implementation checks if both arguments are base
     vectors using `abasep' and if that is the case, substitutes the
     corresponding value from the matrix `aform'.


 -- Function: af (<u>, <v>)
     An antisymmetric scalar function that is used in commutation
     relations.  The default implementation checks if both arguments
     are base vectors using `abasep' and if that is the case,
     substitutes the corresponding value from the matrix `aform'.


 -- Function: av (<u>, <v>)
     An antisymmetric function that is used in commutation relations.
     The default implementation checks if both arguments are base
     vectors using `abasep' and if that is the case, substitutes the
     corresponding value from the matrix `aform'.

     For instance:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Function: abasep (<v>)
     Checks if its argument is an `atensor' base vector. That is, if it
     is an indexed symbol, with the symbol being the same as the value
     of `asymbol', and the index having a numeric value between 1 and
     `adim'.



File: maxima.info,  Node: Spezielle Funktionen,  Next: Fouriertransformationen,  Prev: Tensoren,  Up: Top

21 Spezielle Funktionen
***********************

* Menu:

* Einfhrung fr spezielle Funktionen::
* Besselfunktionen::
* Airyfunktionen::
* Struvefunktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Funktionen und Variablen fr spezielle Funktionen::


File: maxima.info,  Node: Einfhrung fr spezielle Funktionen,  Next: Besselfunktionen,  Prev: Spezielle Funktionen,  Up: Spezielle Funktionen

21.1 Einfhrung fr spezielle Funktionen
==========================================

Special function notation follows:

     bessel_j (index, expr)         Bessel function, 1st kind
     bessel_y (index, expr)         Bessel function, 2nd kind
     bessel_i (index, expr)         Modified Bessel function, 1st kind
     bessel_k (index, expr)         Modified Bessel function, 2nd kind

     hankel_1 (v,z)                 Hankel function of the 1st kind
     hankel_2 (v,z)                 Hankel function of the 2nd kind
     struve_h (v,z)                 Struve H function
     struve_l (v,z)                 Struve L function

     assoc_legendre_p[v,u] (z)      Legendre function of degree v and order u
     assoc_legendre_q[v,u] (z)      Legendre function, 2nd kind

     %f[p,q] ([], [], expr)         Generalized Hypergeometric function
     gamma()                        Gamma function
     gammagreek(a,z)                Incomplete gamma function
     gammaincomplete(a,z)           Tail of incomplete gamma function
     hypergeometric(l1, l2, z)      Hypergeometric function
     slommel
     %m[u,k] (z)                    Whittaker function, 1st kind
     %w[u,k] (z)                    Whittaker function, 2nd kind
     erfc (z)                       Complement of the erf function

     expintegral_e (v,z)            Exponential integral E
     expintegral_e1 (z)             Exponential integral E1
     expintegral_ei (z)             Exponential integral Ei
     expintegral_li (z)             Logarithmic integral Li
     expintegral_si (z)             Exponential integral Si
     expintegral_ci (z)             Exponential integral Ci
     expintegral_shi (z)            Exponential integral Shi
     expintegral_chi (z)            Exponential integral Chi

     kelliptic (z)                  Complete elliptic integral of the first
                                    kind (K)
     parabolic_cylinder_d (v,z)     Parabolic cylinder D function


File: maxima.info,  Node: Besselfunktionen,  Next: Airyfunktionen,  Prev: Einfhrung fr spezielle Funktionen,  Up: Spezielle Funktionen

21.2 Besselfunktionen
=====================

 -- Function: bessel_j (<v>, <z>)
     The Bessel function of the first kind of order v and argument z.

     `bessel_j' is defined as

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_y (<v>, <z>)
     The Bessel function of the second kind of order v and argument z.

     `bessel_y' is defined as
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.


 -- Function: bessel_i (<v>, <z>)
     The modified Bessel function of the first kind of order v and
     argument z.

     `bessel_i' is defined as
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_k (<v>, <z>)
     The modified Bessel function of the second kind of order v and
     argument z.

     `bessel_k' is defined as
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.


 -- Function: hankel_1 (<v>, <z>)
     The Hankel function of the first kind of order v and argument z
     (A&S 9.1.3). `hankel_1' is defined as

             bessel_j(v,z) + %i * bessel_y(v,z)

     Maxima evaluates `hankel_1' numerically for a real order v and
     complex argument z in float precision. The numerical evaluation in
     bigfloat precision and for a complex order v is not supported.

     When `besselexpand' is `true', `hankel_1' is expanded in terms of
     elementary functions when the order v is half of an odd integer.
     See `besselexpand'.

     Maxima knows the derivative of `hankel_1' wrt the argument z.

     Examples:

     Numerical evaluation:

          (%i1) hankel_1(1,0.5);
          (%o1)              .2422684576748738 - 1.471472392670243 %i
          (%i2) hankel_1(1,0.5+%i);
          (%o2)             - .2558287994862166 %i - 0.239575601883016

     A complex order v is not supported. Maxima returns a noun form:

          (%i3) hankel_1(%i,0.5+%i);
          (%o3)                       hankel_1(%i, %i + 0.5)

     Expansion of `hankel_1' when `besselexpand' is `true':

          (%i4) hankel_1(1/2,z),besselexpand:true;
                                sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o4)                 ----------------------------------
                                        sqrt(%pi) sqrt(z)

     Derivative of `hankel_1' wrt the argument z. The derivative wrt the
     order v is not supported. Maxima returns a noun form:

          (%i5) diff(hankel_1(v,z),z);
                              hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o5)               ---------------------------------------
                                                 2
          (%i6) diff(hankel_1(v,z),v);
                                       d
          (%o6)                        -- (hankel_1(v, z))
                                       dv


 -- Function: hankel_2 (<v>, <z>)
     The Hankel function of the second kind of order v and argument z
     (A&S 9.1.4). `hankel_2' is defined as

             bessel_j(v,z) - %i * bessel_y(v,z)

     Maxima evaluates `hankel_2' numerically for a real order v and
     complex argument z in float precision. The numerical evaluation in
     bigfloat precision and for a complex order v is not supported.

     When `besselexpand' is `true', `hankel_2' is expanded in terms of
     elementary functions when the order v is half of an odd integer.
     See `besselexpand'.

     Maxima knows the derivative of `hankel_2' wrt the argument z.

     For examples see `hankel_1'.


 -- Option variable: besselexpand
     Default value: `false'

     Controls expansion of the Bessel functions when the order is half
     of an odd integer.  In this case, the Bessel functions can be
     expanded in terms of other elementary functions.  When
     `besselexpand' is `true', the Bessel function is expanded.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                                  sin(z)   cos(z)
                                 sqrt(2) sqrt(z) (------ - ------)
                                                     2       z
                                                    z
          (%o4)                  ---------------------------------
                                             sqrt(%pi)


 -- Function: scaled_bessel_i (<v>, <z>)
     The scaled modified Bessel function of the first kind of order v
     and argument z.  That is, scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  This function is particularly useful
     for calculating bessel_i for large z, which is large.  However,
     maxima does not otherwise know much about this function.  For
     symbolic work, it is probably preferable to work with the
     expression `exp(-abs(z))*bessel_i(v, z)'.


 -- Function: scaled_bessel_i0 (<z>)
     Identical to `scaled_bessel_i(0,z)'.


 -- Function: scaled_bessel_i1 (<z>)
     Identical to `scaled_bessel_i(1,z)'.


 -- Function: %s [<u>,<v>] (<z>)
     Lommel's little s[u,v](z) function.  Probably Gradshteyn & Ryzhik
     8.570.1.



File: maxima.info,  Node: Airyfunktionen,  Next: Struvefunktionen,  Prev: Besselfunktionen,  Up: Spezielle Funktionen

21.3 Airyfunktionen
===================

The Airy functions Ai(x) and Bi(x) are defined in Abramowitz and Stegun,
Handbook of Mathematical Functions, Section 10.4.

   `y = Ai(x)' and `y = Bi(x)' are two linearly independent solutions
of the Airy differential equation `diff (y(x), x, 2) - x y(x) = 0'.

   If the argument `x' is a real or complex floating point number, the
numerical value of the function is returned.

 -- Function: airy_ai (<x>)
     The Airy function Ai(x).  (A&S 10.4.2)

     The derivative `diff (airy_ai(x), x)' is `airy_dai(x)'.

     See also `airy_bi', `airy_dai', `airy_dbi'.


 -- Function: airy_dai (<x>)
     The derivative of the Airy function Ai `airy_ai(x)'.

     See `airy_ai'.


 -- Function: airy_bi (<x>)
     The Airy function Bi(x).  (A&S 10.4.3)

     The derivative `diff (airy_bi(x), x)' is `airy_dbi(x)'.

     See `airy_ai', `airy_dbi'.


 -- Function: airy_dbi (<x>)
     The derivative of the Airy Bi function `airy_bi(x)'.

     See `airy_ai' and `airy_bi'.



File: maxima.info,  Node: Struvefunktionen,  Next: Gammafunktionen und verwandte Funktionen,  Prev: Airyfunktionen,  Up: Spezielle Funktionen

21.4 Struvefunktionen
=====================

The Struve functions are defined in Abramowitz and Stegun, Handbook of
Mathematical Functions, Chapter 12.

 -- Function: struve_h (<v>, <z>)
     The Struve Function H of order v and argument z. (A&S 12.1.1)


 -- Function: struve_l (<v>, <z>)
     The Modified Struve Function L of order v and argument z. (A&S
     12.2.1)



File: maxima.info,  Node: Gammafunktionen und verwandte Funktionen,  Next: Exponentielle Integrale,  Prev: Struvefunktionen,  Up: Spezielle Funktionen

21.5 Gammafunktionen und verwandte Funktionen
=============================================

The gamma function and the related beta, psi and incomplete gamma
functions are defined in Abramowitz and Stegun, Handbook of
Mathematical Functions, Chapter 6.

 -- Function: bffac (<expr>, <n>)
     Bigfloat version of the factorial (shifted gamma) function.  The
     second argument is how many digits to retain and return, it's a
     good idea to request a couple of extra.


 -- Function: bfpsi (<n>, <z>, <fpprec>)
 -- Function: bfpsi0 (<z>, <fpprec>)
     `bfpsi' is the polygamma function of real argument <z> and integer
     order <n>. `bfpsi0' is the digamma function.  `bfpsi0 (<z>,
     <fpprec>)' is equivalent to `bfpsi (0, <z>, <fpprec>)'.

     These functions return bigfloat values. <fpprec> is the bigfloat
     precision of the return value.


 -- Function: cbffac (<z>, <fpprec>)
     Complex bigfloat factorial.

     `load ("bffac")' loads this function.


 -- Function: gamma (<z>)
     The basic definition of the gamma function (A&S 6.1.1) is

                                         inf
                                        /
                                        [     z - 1   - t
                             gamma(z) = I    t      %e    dt
                                        ]
                                        /
                                         0

     Maxima simplifies `gamma' for positive integer and positive and
     negative rational numbers. For half integral values the result is
     a rational number times `sqrt(%pi)'. The simplification for
     integer values is controlled by `factlim'. For integers greater
     than `factlim' the numerical result of the factorial function,
     which is used to calculate `gamma', will overflow.  The
     simplification for rational numbers is controlled by `gammalim' to
     avoid internal overflow. See `factlim' and `gammalim'.

     For negative integers `gamma' is not definied.

     Maxima can evalute `gamma' numerically for real and complex values
     in float and bigfloat precision.

     `gamma' has mirror symmetry.

     When `gamma_expand' is `true', Maxima expands `gamma' for
     arguments `z+n' and `z-n' where `n' is an integer.

     Maxima knows the derivate of `gamma'.

     Examples:

     Simplification for integer, half integral, and rational numbers:

          (%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
          (%o1)               [1, 1, 2, 6, 24, 120, 720, 5040, 40320]

          (%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                                     sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
          (%o2)          [sqrt(%pi), ---------, -----------, ------------]
                                         2           4            8

          (%i3) map('gamma,[2/3,5/3,7/3]);
                                                  2           1
                                          2 gamma(-)  4 gamma(-)
                                      2           3           3
          (%o3)                [gamma(-), ----------, ----------]
                                      3       3           9

     Numerical evaluation for real and complex values:

          (%i4) map('gamma,[2.5,2.5b0]);
          (%o4)             [1.329340388179137, 1.329340388179137b0]

          (%i5) map('gamma,[1.0+%i,1.0b0+%i]);
          (%o5) [.4980156681183558 - .1549498283018108 %i,
                                4.980156681183561b-1 - 1.549498283018107b-1 %i]

     `gamma' has mirror symmetry:

          (%i8) declare(z,complex)$
          (%i9) conjugate(gamma(z));
          (%o9)                         gamma(conjugate(z))

     Maxima expands `gamma(z+n)' and `gamma(z-n)', when `gamma_expand'
     is `true':

          (%i10) gamma_expand:true$
          (%i11) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                                gamma(z)
          (%o11)                   [z gamma(z), --------, z + 1]
                                                 z - 1

     The deriviative of `gamma':

          (%i12) diff(gamma(z),z);
          (%o12)                         psi (z) gamma(z)
                                            0

     See also `makegamma'.

     The Euler-Mascheroni constant is `%gamma'.


 -- Function: log_gamma (<z>)
     The natural logarithm of the gamma function.


 -- Function: gamma_incomplete (<a>, <z>)
     The incomplete upper gamma function A&S 6.5.2: gamma_incomplete(a,
     z) = integrate(exp(-t)*t^(a-1), t, z, inf)


 -- Function: gamma_incomplete_regularized (<a>,<z>)
     The regularized incomplete upper gamma function A&S 6.5.1.

     `gamma_incomplete_regularized(a,z) =
     gamma_incomplete(a,z)/gamma(a)'


 -- Function: gamma_incomplete_generalized (<a>,<z1>,<z1> )
     The generalized incomplete gamma function.

     `gamma_incomplete_generalized(a,z) = integrate(t^(a-1)*exp(-t), z,
     z1,z2) '


 -- Option variable: gammalim
     Default value: 1000000

     `gammalim' controls simplification of the gamma function for
     integral and rational number arguments.  If the absolute value of
     the argument is not greater than `gammalim', then simplification
     will occur.  Note that the `factlim' switch controls
     simplification of the result of `gamma' of an integer argument as
     well.


 -- Function: makegamma (<expr>)
     Transforms instances of binomial, factorial, and beta functions in
     <expr> into gamma functions.

     See also `makefact'.


 -- Function: beta (<a>, <b>)
     The beta function is defined as `gamma(a) gamma(b)/gamma(a+b)'
     (A&S 6.2.1).

     Maxima simplifies the beta function for positive integers and
     rational numbers, which sum to an integer. When
     `beta_args_sum_to_integer' is `true', Maxima simplifies also
     general expressions which sum to an integer.

     For <a> or <b> equal to zero the beta function is not defined.

     In general the beta function is not defined for negative integers
     as an argument. The exception is for <a=-n>, <n> a positive integer
     and <b> a positive integer with <b<=n>, it is possible to define an
     analytic continuation. Maxima gives for this case a result.

     When `beta_expand' is `true', expressions like `beta(a+n,b)' and
     `beta(a-n,b)' or `beta(a,b+n)' and `beta(a,b-n)' with `n' an
     integer are simplified.

     Maxima can evaluate the beta function for real and complex values
     in float and bigfloat precision. For numerical evaluation Maxima
     uses `log_gamma':

                     - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
                   %e

     Maxima knows that the beta function is symmetric and has mirror
     symmetry.

     Maxima knows the derivatives of the beta function with respect to
     <a> or <b>.

     To express the beta function as a ratio of gamma functions see
     `makegamma'.

     Examples:

     Simplification, when one of the arguments is an integer:

          (%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                                         1   9      1
          (%o1)                         [--, -, ---------]
                                         12  4  a (a + 1)

     Simplification for two rational numbers as arguments which sum to
     an integer:

          (%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                                    3 %pi   2 %pi
          (%o2)                    [-----, -------, sqrt(2) %pi]
                                      8    sqrt(3)

     When setting `beta_args_sum_to_integer' to `true' more general
     expression are simplified, when the sum of the arguments is an
     integer:

          (%i3) beta_args_sum_to_integer:true$
          (%i4) beta(a+1,-a+2);
                                          %pi (a - 1) a
          (%o4)                         ------------------
                                        2 sin(%pi (2 - a))

     The possible results, when one of the arguments is a negative
     integer:

          (%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                              1  1    1
          (%o5)                            [- -, -, - -]
                                              3  6    3

     `beta(a+n,b)' or `beta(a-n)' with `n' an integer simplifies when
     `beta_expand' is `true':

          (%i6) beta_expand:true$
          (%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                              a beta(a, b)  beta(a, b) (b + a - 1)  a
          (%o7)              [------------, ----------------------, -]
                                 b + a              a - 1           b

     Beta is not definied, when one of the arguments is zero:

          (%i7) beta(0,b);
          beta: expected nonzero arguments; found 0, b
           -- an error.  To debug this try debugmode(true);

     Numercial evaluation for real and complex arguments in float or
     bigfloat precision:

          (%i8) beta(2.5,2.3);
          (%o8) .08694748611299981

          (%i9) beta(2.5,1.4+%i);
          (%o9) 0.0640144950796695 - .1502078053286415 %i

          (%i10) beta(2.5b0,2.3b0);
          (%o10) 8.694748611299969b-2

          (%i11) beta(2.5b0,1.4b0+%i);
          (%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i

     Beta is symmetric and has mirror symmetry:

          (%i14) beta(a,b)-beta(b,a);
          (%o14)                                 0
          (%i15) declare(a,complex,b,complex)$
          (%i16) conjugate(beta(a,b));
          (%o16)                 beta(conjugate(a), conjugate(b))

     The derivative of the beta function wrt `a':
          (%i17) diff(beta(a,b),a);
          (%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                                0             0


 -- Function: beta_incomplete (<a>, <b>, <z>)
     The basic definition of the incomplete beta function (A&S 6.6.1) is

                                 z
                                /
                                [         b - 1  a - 1
                                I  (1 - t)      t      dt
                                ]
                                /
                                 0

     This definition is possible for realpart(a)>0 and realpart(b)>0
     and abs(z)<1. For other values the incomplete beta function can be
     defined through a generalized hypergeometric function:

             gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z

     (See functions.wolfram.com for a complete definition of the
     incomplete beta function.)

     For negative integers a = -n and positive integers b=m with m<=n
     the incomplete beta function is defined through

                                      m - 1           k
                                      ====  (1 - m)  z
                                n - 1 \            k
                               z       >    -----------
                                      /     k! (n - k)
                                      ====
                                      k = 0

     Maxima uses this definition to simplify `beta_incomplete' for <a> a
     negative integer.

     For <a> a positive integer, `beta_incomplete' simplifies for any
     argument <b> and <z> and for <b> a positive integer for any
     argument <a> and <z>, with the exception of <a> a negative integer.

     For z=0 and realpart(a)>0, `beta_incomplete' has the specific
     value zero. For <z=1> and realpart(b)>0, `beta_incomplete'
     simplifies to the beta function `beta(a,b)'.

     Maxima evaluates `beta_incomplete' numerically for real and
     complex values in float or bigfloat precision. For the numerical
     evaluation an expansion of the incomplete beta function in
     continued fractions is used.

     When `beta_expand' is `true', Maxima expands expressions like
     `beta_incomplete(a+n,b,z)' and `beta_incomplete(a-n,b,z)' where n
     is a positive integer.

     Maxima knows the derivatives of `beta_incomplete' with respect to
     the variables <a>, <b> and <z> and the integral with respect to the
     variable <z>.

     Examples:

     Simplification for <a> a positive integer:

          (%i1) beta_incomplete(2,b,z);
                                                 b
                                      1 - (1 - z)  (b z + 1)
          (%o1)                       ----------------------
                                            b (b + 1)

     Simplification for <b> a positive integer:

          (%i2) beta_incomplete(a,2,z);
                                                         a
                                        (a (1 - z) + 1) z
          (%o2)                         ------------------
                                            a (a + 1)

     Simplification for <a> and <b> a positive integer:

          (%i3) beta_incomplete(3,2,z);
                                                         3
                                        (3 (1 - z) + 1) z
          (%o3)                         ------------------
                                                12

     <a> is a negative integer and b<=(-a), Maxima simplifies:

          (%i4) beta_incomplete(-3,1,z);
                                                 1
          (%o4)                              - ----
                                                  3
                                               3 z

     For the specific values z=0 and z=1, Maxima simplifies:

          (%i5) assume(a>0,b>0)$
          (%i6) beta_incomplete(a,b,0);
          (%o6)                                 0
          (%i7) beta_incomplete(a,b,1);
          (%o7)                            beta(a, b)

     Numerical evaluation in float or bigfloat precision:

          (%i8) beta_incomplete(0.25,0.50,0.9);
          (%o8)                          4.594959440269333
          (%i9)  fpprec:25$
          (%i10) beta_incomplete(0.25,0.50,0.9b0);
          (%o10)                    4.594959440269324086971203b0

     For abs(z)>1 `beta_incomplete' returns a complex result:

          (%i11) beta_incomplete(0.25,0.50,1.7);
          (%o11)              5.244115108584249 - 1.45518047787844 %i

     Results for more general complex arguments:

          (%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
          (%o14)             2.726960675662536 - .3831175704269199 %i
          (%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
          (%o15)             13.04649635168716 %i - 5.802067956270001
          (%i16)

     Expansion, when `beta_expand' is `true':

          (%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                                 b  a
                             a beta_incomplete(a, b, z)   (1 - z)  z
          (%o23)             -------------------------- - -----------
                                       b + a                 b + a

          (%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                                     b  a - 1
                     beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
          (%o24)     -------------------------------------- - ---------------
                                     1 - a                         1 - a

     Derivative and integral for `beta_incomplete':

          (%i34) diff(beta_incomplete(a,b,z),z);
                                               b - 1  a - 1
          (%o34)                        (1 - z)      z
          (%i35) integrate(beta_incomplete(a,b,z),z);
          (%o35)     beta_incomplete(a, b, z) z - beta_incomplete(a + 1, b, z)
          (%i36) diff(%,z);
          (%o36)                     beta_incomplete(a, b, z)


 -- Function: beta_incomplete_regularized (<a>, <b>, <z>)
     The regularized incomplete beta function A&S 6.6.2, defined as
     `beta_incomplete(a,b,z)/beta(a,b)'.

     As for `beta_incomplete' this definition is not complete. See
     functions.wolfram.com for a complete definition of
     `beta_incomplete_regularized'.

     `beta_incomplete_regularized' simplifies <a> or <b> a positive
     integer.

     For z=0 and realpart(a)>0, `beta_incomplete_regularized' has the
     specific value 0. For <z=1> and realpart(b)>0,
     `beta_incomplete_regularized' simplifies to 1.

     Maxima can evaluate `beta_incomplete_regularized' for real and
     complex arguments in float and bigfloat precision.

     When `beta_expand' is `true', Maxima expands
     `beta_incomplete_regularized' for arguments a+n or a-n, where n is
     an integer.

     Maxima knows the derivatives of `beta_incomplete_regularized' with
     respect to the variables <a>, <b>, and <z> and the integral with
     respect to the variable <z>.

     Examples:

     Simplification for <a> or <b> a positive integer:

          (%i1) beta_incomplete_regularized(2,b,z);
                                                 b
          (%o1)                       1 - (1 - z)  (b z + 1)

          (%i2) beta_incomplete_regularized(a,2,z);
                                                         a
          (%o2)                         (a (1 - z) + 1) z

          (%i3) beta_incomplete_regularized(3,2,z);
                                                         3
          (%o3)                         (3 (1 - z) + 1) z

     For the specific values z=0 and z=1, Maxima simplifies:

          (%i4) assume(a>0,b>0)$
          (%i5) beta_incomplete_regularized(a,b,0);
          (%o5)                                 0
          (%i6) beta_incomplete_regularized(a,b,1);
          (%o6)                                 1

     Numerical evaluation for real and complex arguments in float and
     bigfloat precision:

          (%i7) beta_incomplete_regularized(0.12,0.43,0.9);
          (%o7)                         .9114011367359802
          (%i8) fpprec:32$
          (%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
          (%o9)               9.1140113673598075519946998779975b-1
          (%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
          (%o10)             .2865367499935403 %i - 0.122995963334684
          (%i11) fpprec:20$
          (%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
          (%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1

     Expansion, when `beta_expand' is `true':

          (%i13) beta_incomplete_regularized(a+1,b,z);
                                                                      b  a
                                                               (1 - z)  z
          (%o13)        beta_incomplete_regularized(a, b, z) - ------------
                                                               a beta(a, b)
          (%i14) beta_incomplete_regularized(a-1,b,z);
                                                                    b  a - 1
                                                             (1 - z)  z
          (%o14)   beta_incomplete_regularized(a, b, z) - ----------------------
                                                          beta(a, b) (b + a - 1)

     The derivative and the integral wrt <z>:

          (%i15) diff(beta_incomplete_regularized(a,b,z),z);
                                               b - 1  a - 1
                                        (1 - z)      z
          (%o15)                        -------------------
                                            beta(a, b)

          (%i16) integrate(beta_incomplete_regularized(a,b,z),z);
          (%o16) beta_incomplete_regularized(a, b, z) z
                                     a beta_incomplete_regularized(a + 1, b, z)
                                   - ------------------------------------------
                                                       b + a


 -- Function: beta_incomplete_generalized (<a>, <b>, <z1>, <z2>)
     The basic definition of the generalized incomplete beta function is

                                z2
                               /
                               [          b - 1  a - 1
                               I   (1 - t)      t      dt
                               ]
                               /
                                z1

     Maxima simplifies `beta_incomplete_regularized' for <a> and <b> a
     positive integer.

     For realpart(a)>0 and z1=0 or z2=0, Maxima simplifies
     `beta_incomplete_generalized' to `beta_incomplete'. For
     realpart(b)>0 and z1=1 or <z2=1>, Maxima simplifies to an
     expression with `beta' and `beta_incomplete'.

     Maxima evaluates `beta_incomplete_regularized' for real and
     complex values in float and bigfloat precision.

     When `beta_expand' is `true', Maxima expands
     `beta_incomplete_generalized' for a+n and a-n, <n> a positive
     integer.

     Maxima knows the derivative of `beta_incomplete_generalized' with
     respect to the variables <a>, <b>, <z1>, and <z2> and the
     integrals with respect to the variables <z1> and <z2>.

     Examples:

     Maxima simplifies `beta_incomplete_generalized' for <a> and <b> a
     positive integer:

          (%i1) beta_incomplete_generalized(2,b,z1,z2);
                                    b                      b
                            (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
          (%o1)             -------------------------------------------
                                             b (b + 1)

          (%i2) beta_incomplete_generalized(a,2,z1,z2);
                                               a                      a
                            (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
          (%o2)             -------------------------------------------
                                             a (a + 1)

          (%i3) beta_incomplete_generalized(3,2,z1,z2);
                            2      2                       2      2
                    (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
          (%o3)     -----------------------------------------------------------
                                                12

     Simplification for specific values z1=0, z2=0, z1=1, or z2=1:

          (%i4) assume(a > 0, b > 0)$
          (%i5) beta_incomplete_generalized(a,b,z1,0);
          (%o5)                    - beta_incomplete(a, b, z1)

          (%i6) beta_incomplete_generalized(a,b,0,z2);
          (%o6)                    - beta_incomplete(a, b, z2)

          (%i7) beta_incomplete_generalized(a,b,z1,1);
          (%o7)              beta(a, b) - beta_incomplete(a, b, z1)

          (%i8) beta_incomplete_generalized(a,b,1,z2);
          (%o8)              beta_incomplete(a, b, z2) - beta(a, b)

     Numerical evaluation for real arguments in float or bigfloat
     precision:

          (%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
          (%o9)                        .09638178086368676

          (%i10) fpprec:32$
          (%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
          (%o10)               9.6381780863686935309170054689964b-2

     Numerical evaluation for complex arguments in float or bigfloat
     precision:

          (%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
          (%o11)           - .09625463003205376 %i - .003323847735353769
          (%i12) fpprec:20$
          (%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
          (%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3

     Expansion for a+n or a-n, <n> a positive integer, when
     `beta_expand' is `true':

          (%i14) beta_expand:true$
          (%i15) beta_incomplete_generalized(a+1,b,z1,z2);
                         b   a           b   a
                 (1 - z1)  z1  - (1 - z2)  z2
          (%o15) -----------------------------
                             b + a
                                      a beta_incomplete_generalized(a, b, z1, z2)
                                    + -------------------------------------------
                                                         b + a

          (%i16) beta_incomplete_generalized(a-1,b,z1,z2);
                 beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
          (%o16) -------------------------------------------------------
                                          1 - a
                                                    b   a - 1           b   a - 1
                                            (1 - z2)  z2      - (1 - z1)  z1
                                          - -------------------------------------
                                                            1 - a

     Derivative wrt the variable <z1> and integrals wrt <z1> and <z2>:

          (%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                                b - 1   a - 1
          (%o17)                      - (1 - z1)      z1

          (%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
          (%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                                  + beta_incomplete(a + 1, b, z1)

          (%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
          (%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                                  - beta_incomplete(a + 1, b, z2)


 -- Option variable: beta_expand
     Default value: false

     When `beta_expand' is `true', `beta(a,b)' and related functions
     are expanded for arguments like a+n or a-n, where n is an integer.


 -- Option variable: beta_args_sum_to_integer
     Default value: false

     When `beta_args_sum_to_integer' is `true', Maxima simplifies
     `beta(a,b)', when the arguments <a> and <b> sum to an integer.


 -- Function: psi [<n>](<x>)
     The derivative of `log (gamma (<x>))' of order `<n>+1'.  Thus,
     `psi[0](<x>)' is the first derivative, `psi[1](<x>)' is the second
     derivative, etc.

     Maxima does not know how, in general, to compute a numerical value
     of `psi', but it can compute some exact values for rational args.
     Several variables control what range of rational args `psi' will
     return an exact value, if possible.  See `maxpsiposint',
     `maxpsinegint', `maxpsifracnum', and `maxpsifracdenom'.  That is,
     <x> must lie between `maxpsinegint' and `maxpsiposint'.  If the
     absolute value of the fractional part of <x> is rational and has a
     numerator less than `maxpsifracnum' and has a denominator less
     than `maxpsifracdenom', `psi' will return an exact value.

     The function `bfpsi' in the `bffac' package can compute numerical
     values.


 -- Option variable: maxpsiposint
     Default value: 20

     `maxpsiposint' is the largest positive value for which `psi[n](x)'
     will try to compute an exact value.


 -- Option variable: maxpsinegint
     Default value: -10

     `maxpsinegint' is the most negative value for which `psi[n](x)'
     will try to compute an exact value.  That is if <x> is less than
     `maxnegint', `psi[n](<x>)' will not return simplified answer, even
     if it could.


 -- Option variable: maxpsifracnum
     Default value: 6

     Let <x> be a rational number less than one of the form `p/q'.  If
     `p' is greater than `maxpsifracnum', then `psi[<n>](<x>)' will not
     try to return a simplified value.


 -- Option variable: maxpsifracdenom
     Default value: 6

     Let <x> be a rational number less than one of the form `p/q'.  If
     `q' is greater than `maxpsifracdenom', then `psi[<n>](<x>)' will
     not try to return a simplified value.


 -- Function: makefact (<expr>)
     Transforms instances of binomial, gamma, and beta functions in
     <expr> into factorials.

     See also `makegamma'.


 -- Function: numfactor (<expr>)
     Returns the numerical factor multiplying the expression <expr>,
     which should be a single term.

     `content' returns the greatest common divisor (gcd) of all terms
     in a sum.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8



File: maxima.info,  Node: Exponentielle Integrale,  Next: Fehlerfunktionen,  Prev: Gammafunktionen und verwandte Funktionen,  Up: Spezielle Funktionen

21.6 Exponentielle Integrale
============================

The Exponential Integral and related funtions are defined in Abramowitz
and Stegun, Handbook of Mathematical Functions, Chapter 5

 -- Function: expintegral_e1 (<z>)
     The Exponential Integral E1(z) (A&S 5.1.1)


 -- Function: expintegral_ei (<z>)
     The Exponential Integral Ei(z) (A&S 5.1.2)


 -- Function: expintegral_li (<n>,<z>)
     The Exponential Integral Li(z)  (A&S 5.1.3)


 -- Function: expintegral_e (<n>,<z>)
     The Exponential Integral En(z)  (A&S 5.1.4)


 -- Function: expintegral_si (<z>)
     The Exponential Integral Si(z) (A&S 5.2.1)


 -- Function: expintegral_ci (<z>)
     The Exponential Integral Ci(z) (A&S 5.2.2)


 -- Function: expintegral_shi (<z>)
     The Exponential Integral Shi(z) (A&S 5.2.3)


 -- Function: expintegral_chi (<z>)
     The Exponential Integral Chi(z) (A&S 5.2.4)


 -- Option variable: expintrep
     Default value: false

     Change the representation of the Exponential Integral to
     gamma_incomplete, expintegral_e1, expintegral_ei,
     expintegral_li, expintegral_trig, expintegral_hyp


 -- Option variable: expintexpand
     Default value: false

     Expand the Exponential Integral E[n](z) for half integral values
     in terms of Erfc or Erf and for positive integers in terms of Ei



File: maxima.info,  Node: Fehlerfunktionen,  Next: Elliptische Funktionen und Integrale,  Prev: Exponentielle Integrale,  Up: Spezielle Funktionen

21.7 Fehlerfunktionen
=====================

The Error function and related funtions are defined in Abramowitz and
Stegun, Handbook of Mathematical Functions, Chapter 7

 -- Function: erf (<z>)
     The Error Function erf(z) (A&S 7.1.1)

     See also flag `erfflag'.


 -- Function: erfc (<z>)
     The Complementary Error Function erfc(z) (A&S 7.1.2)

     `erfc(z) = 1-erf(z)'


 -- Function: erfi (<z>)
     The Imaginary Error Function.

     `erfi(z) = -%i*erf(%i*z)'


 -- Function: erf_generalized (<z1>,<z2>)
     Generalized Error function Erf(z1,z2)


 -- Function: fresnel_c (<z>)
     The Fresnel Integral C(z) = integrate(cos((%pi/2)*t^2),t,0,z).
     (A&S 7.3.1)

     The simplification fresnel_c(-x) = -fresnel_c(x) is applied when
     flag `trigsign' is true.

     The simplification fresnel_c(%i*x) =  %i*fresnel_c(x) is applied
     when flag `%iargs' is true.

     See flags `erf_representation' and `hypergeometric_representation'.


 -- Function: fresnel_s (<z>)
     The Fresnel Integral S(z) = integrate(sin((%pi/2)*t^2),t,0,z).
     (A&S 7.3.2)

     The simplification fresnel_s(-x) = -fresnel_s(x) is applied when
     flag `trigsign' is true.

     The simplification fresnel_s(%i*x) =  %i*fresnel_s(x) is applied
     when flag `%iargs' is true.

     See flags `erf_representation' and `hypergeometric_representation'.


 -- Option variable: erf_representation
     Default value: false

     When T erfc, erfi, erf_generalized, fresnel_s and fresnel_c are
     transformed to erf.

 -- Option variable: hypergeometric_representation
     Default value: false

     Enables transformation to a Hypergeometric representation for
     fresnel_s and fresnel_c


File: maxima.info,  Node: Elliptische Funktionen und Integrale,  Next: Hypergeometrische Funktionen,  Prev: Fehlerfunktionen,  Up: Spezielle Funktionen

21.8 Elliptische Funktionen und Integrale
=========================================

* Menu:

* Einfhrung in Elliptische Funktionen und Integrale::
* Funktionen und Variablen fr Elliptische Funktionen::
* Funktionen und Variablen fr Elliptische Integrale::


File: maxima.info,  Node: Einfhrung in Elliptische Funktionen und Integrale,  Next: Funktionen und Variablen fr Elliptische Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

21.8.1 Einfhrung in Elliptische Funktionen und Integrale
----------------------------------------------------------

Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16-17.  As much as possible, we
use the definitions and relationships given there.

   In particular, all elliptic functions and integrals use the parameter
m instead of the modulus k or the modular angle \alpha.  This is one
area where we differ from Abramowitz and Stegun who use the modular
angle for the elliptic functions.  The following relationships are true:
m = k^2 and k = \sin(\alpha)

   The elliptic functions and integrals are primarily intended to
support symbolic computation.  Therefore, most of derivatives of the
functions and integrals are known.  However, if floating-point values
are given, a floating-point result is returned.

   Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

   Some examples of elliptic functions:
     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Some examples of elliptic integrals:
     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.


File: maxima.info,  Node: Funktionen und Variablen fr Elliptische Funktionen,  Next: Funktionen und Variablen fr Elliptische Integrale,  Prev: Einfhrung in Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

21.8.2 Funktionen und Variablen fr Elliptische Funktionen
-----------------------------------------------------------

 -- Function: jacobi_sn (<u>, <m>)
     The Jacobian elliptic function sn(u,m).


 -- Function: jacobi_cn (<u>, <m>)
     The Jacobian elliptic function cn(u,m).


 -- Function: jacobi_dn (<u>, <m>)
     The Jacobian elliptic function dn(u,m).


 -- Function: jacobi_ns (<u>, <m>)
     The Jacobian elliptic function ns(u,m) = 1/sn(u,m).


 -- Function: jacobi_sc (<u>, <m>)
     The Jacobian elliptic function sc(u,m) = sn(u,m)/cn(u,m).


 -- Function: jacobi_sd (<u>, <m>)
     The Jacobian elliptic function sd(u,m) = sn(u,m)/dn(u,m).


 -- Function: jacobi_nc (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).


 -- Function: jacobi_cs (<u>, <m>)
     The Jacobian elliptic function cs(u,m) = cn(u,m)/sn(u,m).


 -- Function: jacobi_cd (<u>, <m>)
     The Jacobian elliptic function cd(u,m) = cn(u,m)/dn(u,m).


 -- Function: jacobi_nd (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).


 -- Function: jacobi_ds (<u>, <m>)
     The Jacobian elliptic function ds(u,m) = dn(u,m)/sn(u,m).


 -- Function: jacobi_dc (<u>, <m>)
     The Jacobian elliptic function dc(u,m) = dn(u,m)/cn(u,m).


 -- Function: inverse_jacobi_sn (<u>, <m>)
     The inverse of the Jacobian elliptic function sn(u,m).


 -- Function: inverse_jacobi_cn (<u>, <m>)
     The inverse of the Jacobian elliptic function cn(u,m).


 -- Function: inverse_jacobi_dn (<u>, <m>)
     The inverse of the Jacobian elliptic function dn(u,m).


 -- Function: inverse_jacobi_ns (<u>, <m>)
     The inverse of the Jacobian elliptic function ns(u,m).


 -- Function: inverse_jacobi_sc (<u>, <m>)
     The inverse of the Jacobian elliptic function sc(u,m).


 -- Function: inverse_jacobi_sd (<u>, <m>)
     The inverse of the Jacobian elliptic function sd(u,m).


 -- Function: inverse_jacobi_nc (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).


 -- Function: inverse_jacobi_cs (<u>, <m>)
     The inverse of the Jacobian elliptic function cs(u,m).


 -- Function: inverse_jacobi_cd (<u>, <m>)
     The inverse of the Jacobian elliptic function cd(u,m).


 -- Function: inverse_jacobi_nd (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).


 -- Function: inverse_jacobi_ds (<u>, <m>)
     The inverse of the Jacobian elliptic function ds(u,m).


 -- Function: inverse_jacobi_dc (<u>, <m>)
     The inverse of the Jacobian elliptic function dc(u,m).



File: maxima.info,  Node: Funktionen und Variablen fr Elliptische Integrale,  Prev: Funktionen und Variablen fr Elliptische Funktionen,  Up: Elliptische Funktionen und Integrale

21.8.3 Funktionen und Variablen fr Elliptische Integrale
----------------------------------------------------------

 -- Function: elliptic_f (<phi>, <m>)
     The incomplete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *note elliptic_e:: and *note elliptic_kc::.


 -- Function: elliptic_e (<phi>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *note elliptic_e:: and *note elliptic_ec::.


 -- Function: elliptic_eu (<u>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     where tau = sn(u,m).

     This is related to elliptic_e by

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)

     See also *note elliptic_e::.

 -- Function: elliptic_pi (<n>, <phi>, <m>)
     The incomplete elliptic integral of the third kind, defined as

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Only the derivative with respect to phi is known by Maxima.


 -- Function: elliptic_kc (<m>)
     The complete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.


 -- Function: elliptic_ec (<m>)
     The complete elliptic integral of the second kind, defined as

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.



File: maxima.info,  Node: Hypergeometrische Funktionen,  Next: Funktionen und Variablen fr spezielle Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Spezielle Funktionen

21.9 Hypergeometrische Funktionen
=================================

The Hypergeometric Functions are defined in Abramowitz and Stegun,
Handbook of Mathematical Functions, Chapters 13 and 15.

   Maxima has very limited knowledge of these functions.  They can be
returned from function `hgfred'.

 -- Function: %m [<k>,<u>] (<z>)
     Whittaker M function `M[k,u](z) =
     exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)'.  (A&S 13.1.32)


 -- Function: %w [<k>,<u>] (<z>)
     Whittaker W function.  (A&S 13.1.33)


 -- Function: %f [<p>,<q>] (<[a],[b],z>)
     The pFq(a1,a2,..ap;b1,b2,..bq;z) hypergeometric function, where
     `a' a list of length `p' and `b' a list of length `q'.


 -- Function: hypergeometric ([<a1>, ..., <ap>],[<b1>, ... ,<bq>], x)
     The hypergeometric function. Unlike Maxima's `%f' hypergeometric
     function, the function `hypergeometric' is a simplifying function;
     also, `hypergeometric' supports complex double and big floating
     point evaluation. For the Gauss hypergeometric function, that is p
     = 2 and q = 1, floating point evaluation outside the unit circle
     is supported, but in general, it is not supported.

     When the option variable `expand_hypergeometric' is true (default
     is false) and one of the arguments `a1' through `ap' is a negative
     integer (a polynomial case), `hypergeometric' returns an expanded
     polynomial.

     Examples:
           (%i1)  hypergeometric([],[],x);
           (%o1) %e^x
     Polynomial cases automatically expand when `expand_hypergeometric'
     is true:
           (%i2) hypergeometric([-3],[7],x);
           (%o2) hypergeometric([-3],[7],x)

           (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
           (%o3) -x^3/504+3*x^2/56-3*x/7+1
     Both double float and big float evaluation is supported:
           (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
           (%o4) 1.346250786375334-0.0559061414208204*%i

           (%i5) hypergeometric([5,6],[8], 5.7 - %i);
           (%o5) 0.00737582400977495-0.00104981368857867*%i

           (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
           (%o6) 7.37582400977494674506442010824b-3-1.04981368857867315858055393376b-3*%i

 -- Function: parabolic_cylinder_d (<v>, <z>)
     The parabolic cylinder function `parabolic_cylinder_d(v,z)'. (A&s
     19.3.1)

     The Parabolic Cylinder Functions are defined in Abramowitz and
     Stegun, Handbook of Mathematical Functions, Chapter 19.

     Maxima has very limited knowledge of these functions.  They can be
     returned from function `hgfred'.



File: maxima.info,  Node: Funktionen und Variablen fr spezielle Funktionen,  Prev: Hypergeometrische Funktionen,  Up: Spezielle Funktionen

21.10 Funktionen und Variablen fr spezielle Funktionen
========================================================

 -- Funktion: li [<s>] (<z>)
     ist der Polylogarithmus der Ordnung <s> und dem Argument <z>. Der
     Polylogarithmus wird durch die folgende Reihe definiert werden:

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     Fr <s=1> geht der Polylogarithmus in die gewhnliche
     Logarithmusfunktion ber und man erhlt `-log(1-z)'. Fr <s=2>
     oder <s=3> spricht man vom Dilogarithmus oder Trilogarithmus.

     Maxima vereinfacht fr <s=1> sofort zum gewhnlichen Logarithmus.
     Fr negative ganze Zahlen <s> einschlielich der Null vereinfacht
     Maxima den Polylogarithmus zu einer rationalen Funktion.

     Ist <s=2> oder <s=3> und das Argument <z> eine Gleitkommazahl,
     vereinfacht Maxima den Di- oder Trilogarithmus zu einer
     Gleitkommazahl.

     Beispiele:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Function: specint (exp(- s*<t>) * <expr>, <t>)
     Compute the Laplace transform of <expr> with respect to the
     variable <t>.  The integrand <expr> may contain special functions.

     The following special functions are handled by `specint':
     incomplete gamma function, error functions (but not the error
     function `erfi', it is easy to transform `erfi' e.g. to the error
     function `erf'), exponential integrals, bessel functions
     (including products of bessel functions), hankel functions,
     hermite and the laguerre polynomials.

     Furthermore, `specint' can handle the hypergeometric function
     `%f[p,q]([],[],z)', the whittaker function of the first kind
     `%m[u,k](z)' and of the second kind `%w[u,k](z)'.

     The result may be in terms of special functions and can include
     unsimplified hypergeomtric functions.

     When `laplace' fails to find a Laplace transform, `specint' is
     called.  Because `laplace' knows more general rules for Laplace
     transforms, it is preferable to use `laplace' and not `specint'.

     `demo(hypgeo)' displays several examples of Laplace transforms
     computed by `specint'.

     Examples:

          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     Examples for exponential integrals:

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)*(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                              log(s)
          (%o5)                               ------
                                              s - a

          (%i6) logarc:true$
          (%i7) gamma_expand:true$
          (%i8) radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                              log(s)
          (%o8)                               ------
                                               2
                                              s  + 1

          (%i9) ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                                2    2
                                           log(s  + a )
          (%o9)                            ------------
                                                 2
                                                s

     Results when using the expansion of `gamma_incomplete' and when
     changing the representation to `expintegral_e1':

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a


 -- Function: hgfred (<a>, <b>, <t>)
     Simplify the generalized hypergeometric function in terms of other,
     simpler, forms.  <a> is a list of numerator parameters and <b> is
     a list of the denominator parameters.

     If `hgfred' cannot simplify the hypergeometric function, it returns
     an expression of the form `%f[p,q]([a], [b], x)' where <p> is the
     number of elements in <a>, and <q> is the number of elements in
     <b>.  This is the usual `pFq' generalized hypergeometric function.

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

     It can be beneficial to load orthopoly too as the following example
     shows.  Note that <L> is the generalized Laguerre polynomial.

          (%i5) load(orthopoly)$
          (%i6) hgfred([-2],[a],z);

                                              (a - 1)
                                           2 L       (z)
                                              2
          (%o6)                            -------------
                                             a (a + 1)
          (%i7) ev(%);

                                            2
                                           z        2 z
          (%o7)                         --------- - --- + 1
                                        a (a + 1)    a


 -- Function: lambert_w (<z>)
     The principal branch of Lambert's W funtion W(z), the solution of
     `z = W(z) * exp(W(z))'.


 -- Function: nzeta (<z>)
     The Plasma Dispersion Function `nzeta(z) =
     %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))'


 -- Function: nzetar (<z>)
     Returns `realpart(nzeta(z))'.


 -- Function: nzetai (<z>)
     Returns `imagpart(nzeta(z))'.



File: maxima.info,  Node: Fouriertransformationen,  Next: Laufzeitumgebung,  Prev: Spezielle Funktionen,  Up: Top

22 Fouriertransformationen
**************************

* Menu:

* Introduction to fast Fourier transform::
* Functions and Variables for fast Fourier transform::
* Introduction to Fourier series::
* Functions and Variables for Fourier series::


File: maxima.info,  Node: Introduction to fast Fourier transform,  Next: Functions and Variables for fast Fourier transform,  Prev: Fouriertransformationen,  Up: Fouriertransformationen

22.1 Introduction to fast Fourier transform
===========================================

The `fft' package comprises functions for the numerical (not symbolic)
computation of the fast Fourier transform.


File: maxima.info,  Node: Functions and Variables for fast Fourier transform,  Next: Introduction to Fourier series,  Prev: Introduction to fast Fourier transform,  Up: Fouriertransformationen

22.2 Functions and Variables for fast Fourier transform
=======================================================

 -- Function: polartorect (<r>, <t>)
     Translates complex values of the form `r %e^(%i t)' to the form `a
     + b %i', where <r> is the magnitude and <t> is the phase.  <r> and
     <t> are 1-dimensional arrays of the same size.  The array size
     need not be a power of 2.

     The original values of the input arrays are replaced by the real
     and imaginary parts, `a' and `b', on return.  The outputs are
     calculated as

          a = r cos(t)
          b = r sin(t)

     `polartorect' is the inverse function of `recttopolar'.

     `load(fft)' loads this function. See also `fft'.


 -- Function: recttopolar (<a>, <b>)
     Translates complex values of the form `a + b %i' to the form `r
     %e^(%i t)', where <a> is the real part and <b> is the imaginary
     part.  <a> and <b> are 1-dimensional arrays of the same size.  The
     array size need not be a power of 2.

     The original values of the input arrays are replaced by the
     magnitude and angle, `r' and `t', on return.  The outputs are
     calculated as

          r = sqrt(a^2 + b^2)
          t = atan2(b, a)

     The computed angle is in the range `-%pi' to `%pi'.

     `recttopolar' is the inverse function of `polartorect'.

     `load(fft)' loads this function. See also `fft'.


 -- Function: inverse_fft (<y>)
     Computes the inverse complex fast Fourier transform.  <y> is a
     list or array (named or unnamed) which contains the data to
     transform.  The number of elements must be a power of 2.  The
     elements must be literal numbers (integers, rationals, floats, or
     bigfloats) or symbolic constants, or expressions `a + b*%i' where
     `a' and `b' are literal numbers or symbolic constants.

     `inverse_fft' returns a new object of the same type as <y>, which
     is not modified.  Results are always computed as floats or
     expressions `a + b*%i' where `a' and `b' are floats.

     The inverse discrete Fourier transform is defined as follows.  Let
     `x' be the output of the inverse transform.  Then for `j' from 0
     through `n - 1',

          x[j] = sum(y[k] exp(+2 %i %pi j k / n), k, 0, n - 1)

     `load(fft)' loads this function.

     See also `fft' (forward transform), `recttopolar', and
     `polartorect'.

     Examples:

     Real data.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Complex data.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17


 -- Function: fft (<x>)
     Computes the complex fast Fourier transform.  <x> is a list or
     array (named or unnamed) which contains the data to transform.
     The number of elements must be a power of 2.  The elements must be
     literal numbers (integers, rationals, floats, or bigfloats) or
     symbolic constants, or expressions `a + b*%i' where `a' and `b'
     are literal numbers or symbolic constants.

     `fft' returns a new object of the same type as <x>, which is not
     modified.  Results are always computed as floats or expressions `a
     + b*%i' where `a' and `b' are floats.

     The discrete Fourier transform is defined as follows.  Let `y' be
     the output of the transform.  Then for `k' from 0 through `n - 1',

          y[k] = (1/n) sum(x[j] exp(-2 %i %pi j k / n), j, 0, n - 1)

     When the data <x> are real, real coefficients `a' and `b' can be
     computed such that

          x[j] = sum (a[k] * cos (2*%pi*j*k / n) + b[k] * sin (2*%pi*j*k / n), k, 0, n/2)

     with

          a[0] = realpart (y[0])
          b[0] = 0

     and, for k from 1 through n/2 - 1,

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     and

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     `load(fft)' loads this function.

     See also `inverse_fft' (inverse transform), `recttopolar', and
     `polartorect'.

     Examples:

     Real data.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, - 1.811 %i - .1036, 0.0, .6036 - .3107 %i, 0.0,
                                   .3107 %i + .6036, 0.0, 1.811 %i - .1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Complex data.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, .3536 %i + .3536, - 0.25 %i - 0.25,
          0.5 - 6.776L-21 %i, 0.0, - .3536 %i - .3536, 0.25 %i - 0.25,
          0.5 - 3.388L-20 %i]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0 - 4.066E-20 %i, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          - 1.008L-19 %i - 1.0, 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.947L-20 %i + 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.83L-17

     Computation of sine and cosine coefficients.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k] * cos (2*%pi*j*k / n) + b[k] * sin (2*%pi*j*k / n), k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]


 -- Option variable: fortindent
     Default value: 0

     `fortindent' controls the left margin indentation of expressions
     printed out by the `fortran' command.  0 gives normal printout
     (i.e., 6 spaces), and positive values will causes the expressions
     to be printed farther to the right.


 -- Function: fortran (<expr>)
     Prints <expr> as a Fortran statement.  The output line is indented
     with spaces.  If the line is too long, `fortran' prints
     continuation lines.  `fortran' prints the exponentiation operator
     `^' as `**', and prints a complex number `a + b %i' in the form
     `(a,b)'.

     <expr> may be an equation. If so, `fortran' prints an assignment
     statement, assigning the right-hand side of the equation to the
     left-hand side.  In particular, if the right-hand side of <expr>
     is the name of a matrix, then `fortran' prints an assignment
     statement for each element of the matrix.

     If <expr> is not something recognized by `fortran', the expression
     is printed in `grind' format without complaint.  `fortran' does
     not know about lists, arrays, or functions.

     `fortindent' controls the left margin of the printed lines.  0 is
     the normal margin (i.e., indented 6 spaces). Increasing
     `fortindent' causes expressions to be printed further to the right.

     When `fortspaces' is `true', `fortran' fills out each printed line
     with spaces to 80 columns.

     `fortran' evaluates its arguments; quoting an argument defeats
     evaluation.  `fortran' always returns `done'.

     Examples:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done


 -- Option variable: fortspaces
     Default value: `false'

     When `fortspaces' is `true', `fortran' fills out each printed line
     with spaces to 80 columns.


 -- Function: horner (<expr>, <x>)
 -- Function: horner (<expr>)
     Returns a rearranged representation of <expr> as in Horner's rule,
     using <x> as the main variable if it is specified.  `x' may be
     omitted in which case the main variable of the canonical rational
     expression form of <expr> is used.

     `horner' sometimes improves stability if `expr' is to be
     numerically evaluated.  It is also useful if Maxima is used to
     generate programs to be run in Fortran. See also `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Function: find_root (<expr>, <x>, <a>, <b>)
 -- Function: find_root (<f>, <a>, <b>)
 -- Option variable: find_root_error
 -- Option variable: find_root_abs
 -- Option variable: find_root_rel
     Finds a root of the expression <expr> or the function <f> over the
     closed interval [<a>, <b>].  The expression <expr> may be an
     equation, in which case `find_root' seeks a root of `lhs(<expr>) -
     rhs(<expr>)'.

     Given that Maxima can evaluate <expr> or <f> over [<a>, <b>] and
     that <expr> or <f> is continuous, `find_root' is guaranteed to
     find the root, or one of the roots if there is more than one.

     `find_root' initially applies binary search.  If the function in
     question appears to be smooth enough, `find_root' applies linear
     interpolation instead.

     The accuracy of `find_root' is governed by `find_root_abs' and
     `find_root_rel'.  `find_root' stops when the function in question
     evaluates to something less than or equal to `find_root_abs', or
     if successive approximants <x_0>, <x_1> differ by no more than
     `find_root_rel * max(abs(x_0), abs(x_1))'.  The default values of
     `find_root_abs' and `find_root_rel' are both zero.

     `find_root' expects the function in question to have a different
     sign at the endpoints of the search interval.  When the function
     evaluates to a number at both endpoints and these numbers have the
     same sign, the behavior of `find_root' is governed by
     `find_root_error'.  When `find_root_error' is `true', `find_root'
     prints an error message.  Otherwise `find_root' returns the value
     of `find_root_error'.  The default value of `find_root_error' is
     `true'.

     If <f> evaluates to something other than a number at any step in
     the search algorithm, `find_root' returns a partially-evaluated
     `find_root' expression.

     The order of <a> and <b> is ignored; the region in which a root is
     sought is [min(<a>, <b>), max(<a>, <b>)].

     Examples:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046


 -- Function: newton (<expr>, <x>, <x_0>, <eps>)
     Returns an approximate solution of `<expr> = 0' by Newton's method,
     considering <expr> to be a function of one variable, <x>.  The
     search begins with `<x> = <x_0>' and proceeds until `abs(<expr>) <
     <eps>' (with <expr> evaluated at the current value of <x>).

     `newton' allows undefined variables to appear in <expr>, so long
     as the termination test `abs(<expr>) < <eps>' evaluates to `true'
     or `false'.  Thus it is not necessary that <expr> evaluate to a
     number.

     `load(newton1)' loads this function.

     See also `realroots', `allroots', `find_root', and `mnewton'.

     Examples:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a



File: maxima.info,  Node: Introduction to Fourier series,  Next: Functions and Variables for Fourier series,  Prev: Functions and Variables for fast Fourier transform,  Up: Fouriertransformationen

22.3 Introduction to Fourier series
===================================

The `fourie' package comprises functions for the symbolic computation
of Fourier series.  There are functions in the `fourie' package to
calculate Fourier integral coefficients and some functions for
manipulation of expressions.


File: maxima.info,  Node: Functions and Variables for Fourier series,  Prev: Introduction to Fourier series,  Up: Fouriertransformationen

22.4 Functions and Variables for Fourier series
===============================================

 -- Function: equalp (<x>, <y>)
     Returns `true' if `equal (<x>, <y>)' otherwise `false' (doesn't
     give an error message like `equal (x, y)' would do in this case).


 -- Function: remfun (<f>, <expr>)
 -- Function: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' replaces all occurrences of `<f> (<arg>)'
     by <arg> in <expr>.

     `remfun (<f>, <expr>, <x>)' replaces all occurrences of `<f>
     (<arg>)' by <arg> in <expr> only if <arg> contains the variable
     <x>.


 -- Function: funp (<f>, <expr>)
 -- Function: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' returns `true' if <expr> contains the
     function <f>.

     `funp (<f>, <expr>, <x>)' returns `true' if <expr> contains the
     function <f> and the variable <x> is somewhere in the argument of
     one of the instances of <f>.


 -- Function: absint (<f>, <x>, <halfplane>)
 -- Function: absint (<f>, <x>)
 -- Function: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' returns the indefinite integral
     of <f> with respect to <x> in the given halfplane (`pos', `neg',
     or `both').  <f> may contain expressions of the form `abs (x)',
     `abs (sin (x))', `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' is equivalent to `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' returns the definite integral of <f>
     with respect to <x> from <a> to <b>.  <f> may include absolute
     values.


 -- Function: fourier (<f>, <x>, <p>)
     Returns a list of the Fourier coefficients of `<f>(<x>)' defined
     on the interval `[-p, p]'.


 -- Function: foursimp (<l>)
     Simplifies `sin (n %pi)' to 0 if `sinnpiflag' is `true' and `cos
     (n %pi)' to `(-1)^n' if `cosnpiflag' is `true'.


 -- Option variable: sinnpiflag
     Default value: `true'

     See `foursimp'.


 -- Option variable: cosnpiflag
     Default value: `true'

     See `foursimp'.


 -- Function: fourexpand (<l>, <x>, <p>, <limit>)
     Constructs and returns the Fourier series from the list of Fourier
     coefficients <l> up through <limit> terms (<limit> may be `inf').
     <x> and <p> have same meaning as in `fourier'.


 -- Function: fourcos (<f>, <x>, <p>)
     Returns the Fourier cosine coefficients for `<f>(<x>)' defined on
     `[0, <p>]'.


 -- Function: foursin (<f>, <x>, <p>)
     Returns the Fourier sine coefficients for `<f>(<x>)' defined on
     `[0, <p>]'.


 -- Function: totalfourier (<f>, <x>, <p>)
     Returns `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Function: fourint (<f>, <x>)
     Constructs and returns a list of the Fourier integral coefficients
     of `<f>(<x>)' defined on `[minf, inf]'.


 -- Function: fourintcos (<f>, <x>)
     Returns the Fourier cosine integral coefficients for `<f>(<x>)' on
     `[0, inf]'.


 -- Function: fourintsin (<f>, <x>)
     Returns the Fourier sine integral coefficients for `<f>(<x>)' on
     `[0, inf]'.



File: maxima.info,  Node: Laufzeitumgebung,  Next: Regeln und Muster,  Prev: Fouriertransformationen,  Up: Top

23 Laufzeitumgebung
*******************

* Menu:

* Introduction for Runtime Environment::
* Interrupts::
* Functions and Variables for Runtime Environment::


File: maxima.info,  Node: Introduction for Runtime Environment,  Next: Interrupts,  Prev: Laufzeitumgebung,  Up: Laufzeitumgebung

23.1 Introduction for Runtime Environment
=========================================

`maxima-init.mac' is a file which is loaded automatically when Maxima
starts.  You can use `maxima-init.mac' to customize your Maxima
environment.  `maxima-init.mac', if it exists, is typically placed in
the directory named by `maxima_userdir', although it can be in any
directory searched by the function `file_search'.

   Here is an example `maxima-init.mac' file:

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   In this example, `setup_autoload' tells Maxima to load the specified
file (`specfun.mac') if any of the functions (`ultraspherical',
`assoc_legendre_p') are called but not yet defined.  Thus you needn't
remember to load the file before calling the functions.

   The statement `showtime: all' tells Maxima to set the `showtime'
variable.  The `maxima-init.mac' file can contain any other assignments
or other Maxima statements.


File: maxima.info,  Node: Interrupts,  Next: Functions and Variables for Runtime Environment,  Prev: Introduction for Runtime Environment,  Up: Laufzeitumgebung

23.2 Interrupts
===============

The user can stop a time-consuming computation with the ^C (control-C)
character.  The default action is to stop the computation and print
another user prompt.  In this case, it is not possible to restart a
stopped computation.

   If the Lisp variable `*debugger-hook*' is set to `nil', by executing

     :lisp (setq *debugger-hook* nil)

then upon receiving ^C, Maxima will enter the Lisp debugger, and the
user may use the debugger to inspect the Lisp environment.  The stopped
computation can be restarted by entering `continue' in the Lisp
debugger.  The means of returning to Maxima from the Lisp debugger
(other than running the computation to completion) is different for
each version of Lisp.

   On Unix systems, the character ^Z (control-Z) causes Maxima to stop
altogether, and control is returned to the shell prompt.  The `fg'
command causes Maxima to resume from the point at which it was stopped.


File: maxima.info,  Node: Functions and Variables for Runtime Environment,  Prev: Interrupts,  Up: Laufzeitumgebung

23.3 Functions and Variables for Runtime Environment
====================================================

 -- System variable: maxima_tempdir
     `maxima_tempdir' names the directory in which Maxima creates some
     temporary files.  In particular, temporary files for plotting are
     created in `maxima_tempdir'.

     The initial value of `maxima_tempdir' is the user's home directory,
     if Maxima can locate it; otherwise Maxima makes a guess about a
     suitable directory.

     `maxima_tempdir' may be assigned a string which names a directory.


 -- System variable: maxima_userdir
     `maxima_userdir' names a directory which Maxima searches to find
     Maxima and Lisp files.  (Maxima searches some other directories as
     well; `file_search_maxima' and `file_search_lisp' are the complete
     lists.)

     The initial value of `maxima_userdir' is a subdirectory of the
     user's home directory, if Maxima can locate it; otherwise Maxima
     makes a guess about a suitable directory.

     `maxima_userdir' may be assigned a string which names a directory.
     However, assigning to `maxima_userdir' does not automatically
     change `file_search_maxima' and `file_search_lisp'; those
     variables must be changed separately.


 -- Function: room ()
 -- Function: room (true)
 -- Function: room (false)
     Prints out a description of the state of storage and stack
     management in Maxima. `room' calls the Lisp function of the same
     name.

        * `room ()' prints out a moderate description.

        * `room (true)' prints out a verbose description.

        * `room (false)' prints out a terse description.


 -- Function: sstatus (<keyword>, <item>)
     When <keyword> is the symbol `feature', <item> is put on the list
     of system features. After `sstatus (keyword, item)' is executed,
     `status (feature, item)' returns `true'. If <keyword> is the
     symbol `nofeature', <item> is deleted from the list of system
     features.  This can be useful for package writers, to keep track
     of what features they have loaded in.

     See also `status'.


 -- Function: status (`feature')
 -- Function: status (`feature', <item>)
     Returns information about the presence or absence of certain
     system-dependent features.

        * `status (feature)' returns a list of system features. These
          include Lisp version, operating system type, etc. The list
          may vary from one Lisp type to another.

        * `status (feature, item)' returns `true' if <item> is on the
          list of items returned by `status (feature)' and `false'
          otherwise.  `status' quotes the argument <item>. The
          quote-quote operator `''' defeats quotation. A feature whose
          name contains a special character, such as a hyphen, must be
          given as a string argument. For example, `status (feature,
          "ansi-cl")'.

     See also `sstatus'.

     The variable `features' contains a list of features which apply to
     mathematical expressions. See `features' and `featurep' for more
     information.


 -- Function: time (%o1, %o2, %o3, ...)
     Returns a list of the times, in seconds, taken to compute the
     output lines `%o1', `%o2', `%o3', .... The time returned is
     Maxima's estimate of the internal computation time, not the
     elapsed time. `time' can only be applied to output line variables;
     for any other variables, `time' returns `unknown'.

     Set `showtime: true' to make Maxima print out the computation time
     and elapsed time with each output line.


 -- Function: timedate ()
     Returns a string representing the current time and date.  The
     string has the format `HH:MM:SS Day, mm/dd/yyyy (GMT-n)', where
     the fields are hours, minutes, seconds, day of week, month, day of
     month, year, and hours different from GMT.

     Example:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate reports current time", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)


 -- Function: absolute_real_time ()
     Returns the number of seconds since midnight, January 1, 1900 UTC.
     The return value is an integer.

     See also `elapsed_real_time' and `elapsed_run_time'.

     Example:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104


 -- Function: elapsed_real_time ()
     Returns the number of seconds (including fractions of a second)
     since Maxima was most recently started or restarted.  The return
     value is a floating-point number.

     See also `absolute_real_time' and `elapsed_run_time'.

     Example:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087


 -- Function: elapsed_run_time ()
     Returns an estimate of the number of seconds (including fractions
     of a second) which Maxima has spent in computations since Maxima
     was most recently started or restarted.  The return value is a
     floating-point number.

     See also `absolute_real_time' and `elapsed_real_time'.

     Example:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26



File: maxima.info,  Node: Regeln und Muster,  Next: Funktionsdefinitionen,  Prev: Laufzeitumgebung,  Up: Top

24 Regeln und Muster
********************

* Menu:

* Introduction to Rules and Patterns::
* Functions and Variables for Rules and Patterns::


File: maxima.info,  Node: Introduction to Rules and Patterns,  Next: Functions and Variables for Rules and Patterns,  Prev: Regeln und Muster,  Up: Regeln und Muster

24.1 Introduction to Rules and Patterns
=======================================

This section describes user-defined pattern matching and simplification
rules.  There are two groups of functions which implement somewhat
different pattern matching schemes.  In one group are `tellsimp',
`tellsimpafter', `defmatch', `defrule', `apply1', `applyb1', and
`apply2'.  In the other group are `let' and `letsimp'.  Both schemes
define patterns in terms of pattern variables declared by
`matchdeclare'.

   Pattern-matching rules defined by `tellsimp' and `tellsimpafter' are
applied automatically by the Maxima simplifier.  Rules defined by
`defmatch', `defrule', and `let' are applied by an explicit function
call.

   There are additional mechanisms for rules applied to polynomials by
`tellrat', and for commutative and noncommutative algebra in `affine'
package.


File: maxima.info,  Node: Functions and Variables for Rules and Patterns,  Prev: Introduction to Rules and Patterns,  Up: Regeln und Muster

24.2 Functions and Variables for Rules and Patterns
===================================================

 -- Function: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repeatedly applies <rule_1> to <expr> until it fails, then
     repeatedly applies the same rule to all subexpressions of <expr>,
     left to right, until <rule_1> has failed on all subexpressions.
     Call the result of transforming <expr> in this manner <expr_2>.
     Then <rule_2> is applied in the same fashion starting at the top
     of <expr_2>.  When <rule_n> fails on the final subexpression, the
     result is returned.

     `maxapplydepth' is the depth of the deepest subexpressions
     processed by `apply1' and `apply2'.

     See also `applyb1', `apply2', and `let'.


 -- Function: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     If <rule_1> fails on a given subexpression, then <rule_2> is
     repeatedly applied, etc.  Only if all rules fail on a given
     subexpression is the whole set of rules repeatedly applied to the
     next subexpression.  If one of the rules succeeds, then the same
     subexpression is reprocessed, starting with the first rule.

     `maxapplydepth' is the depth of the deepest subexpressions
     processed by `apply1' and `apply2'.

     See also `apply1' and `let'.


 -- Function: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repeatedly applies <rule_1> to the deepest subexpression of <expr>
     until it fails, then repeatedly applies the same rule one level
     higher (i.e., larger subexpressions), until <rule_1> has failed on
     the top-level expression.  Then <rule_2> is applied in the same
     fashion to the result of <rule_1>.  After <rule_n> has been
     applied to the top-level expression, the result is returned.

     `applyb1' is similar to `apply1' but works from the bottom up
     instead of from the top down.

     `maxapplyheight' is the maximum height which `applyb1' reaches
     before giving up.

     See also `apply1', `apply2', and `let'.


 -- Optionsvariable: current_let_rule_package
     Standardwert: `default_let_rule_package'

     `current_let_rule_package' is the name of the rule package that is
     used by functions in the `let' package (`letsimp', etc.)  if no
     other rule package is specified. This variable may be assigned the
     name of any rule package defined via the `let' command.

     If a call such as `letsimp (expr, rule_pkg_name)' is made, the
     rule package `rule_pkg_name' is used for that function call only,
     and the value of `current_let_rule_package' is not changed.


 -- Option variable: default_let_rule_package
     Default value: `default_let_rule_package'

     `default_let_rule_package' is the name of the rule package used
     when one is not explicitly set by the user with `let' or by
     changing the value of `current_let_rule_package'.


 -- Function: defmatch (<progname>, <pattern>, <x_1>, ..., <x_n>)
 -- Function: defmatch (<progname>, <pattern>)
     Defines a function `<progname>(<expr>, <x_1>, ..., <x_n>)' which
     tests <expr> to see if it matches <pattern>.

     <pattern> is an expression containing the pattern arguments <x_1>,
     ..., <x_n> (if any) and some pattern variables (if any).  The
     pattern arguments are given explicitly as arguments to `defmatch'
     while the pattern variables are declared by the `matchdeclare'
     function.  Any variable not declared as a pattern variable in
     `matchdeclare' or as a pattern argument in `defmatch' matches only
     itself.

     The first argument to the created function <progname> is an
     expression to be matched against the pattern and the other
     arguments are the actual arguments which correspond to the dummy
     variables <x_1>, ..., <x_n> in the pattern.

     If the match is successful, <progname> returns a list of equations
     whose left sides are the pattern arguments and pattern variables,
     and whose right sides are the subexpressions which the pattern
     arguments and variables matched.  The pattern variables, but not
     the pattern arguments, are assigned the subexpressions they match.
     If the match fails, <progname> returns `false'.

     A literal pattern (that is, a pattern which contains neither
     pattern arguments nor pattern variables) returns `true' if the
     match succeeds.

     See also `matchdeclare', `defrule', `tellsimp', and
     `tellsimpafter'.

     Examples:

     Define a function `linearp(expr, x)' which tests `expr' to see if
     it is of the form `a*x + b' such that `a' and `b' do not contain
     `x' and `a' is nonzero.  This match function matches expressions
     which are linear in any variable, because the pattern argument `x'
     is given to `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define a function `linearp(expr)' which tests `expr' to see if it
     is of the form `a*x + b' such that `a' and `b' do not contain `x'
     and `a' is nonzero.  This match function only matches expressions
     linear in `x', not any other variable, because no pattern argument
     is given to `defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define a function `checklimits(expr)' which tests `expr' to see if
     it is a definite integral.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]


 -- Function: defrule (<rulename>, <pattern>, <replacement>)
     Defines and names a replacement rule for the given pattern.  If
     the rule named <rulename> is applied to an expression (by
     `apply1', `applyb1', or `apply2'), every subexpression matching
     the pattern will be replaced by the replacement. All variables in
     the replacement which have been assigned values by the pattern
     match are assigned those values in the replacement which is then
     simplified.

     The rules themselves can be treated as functions which transform
     an expression by one operation of the pattern match and
     replacement.  If the match fails, the rule function returns
     `false'.


 -- Function: disprule (<rulename_1>, ..., <rulename_2>)
 -- Function: disprule (all)
     Display rules with the names <rulename_1>, ..., <rulename_n>, as
     returned by `defrule', `tellsimp', or `tellsimpafter', or a
     pattern defined by `defmatch'.  Each rule is displayed with an
     intermediate expression label (`%t').

     `disprule (all)' displays all rules.

     `disprule' quotes its arguments.  `disprule' returns the list of
     intermediate expression labels corresponding to the displayed
     rules.

     See also `letrules', which displays rules defined by `let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Function: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Function: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)
     Defines a substitution rule for `letsimp' such that <prod> is
     replaced by <repl>.  <prod> is a product of positive or negative
     powers of the following terms:

        * Atoms which `letsimp' will search for literally unless
          previous to calling `letsimp' the `matchdeclare' function is
          used to associate a predicate with the atom.  In this case
          `letsimp' will match the atom to any term of a product
          satisfying the predicate.

        * Kernels such as `sin(x)', `n!', `f(x,y)', etc.  As with atoms
          above `letsimp' will look for a literal match unless
          `matchdeclare' is used to associate a predicate with the
          argument of the kernel.

     A term to a positive power will only match a term having at least
     that power.  A term to a negative power on the other hand will
     only match a term with a power at least as negative.  In the case
     of negative powers in <prod> the switch `letrat' must be set to
     `true'.  See also `letrat'.

     If a predicate is included in the `let' function followed by a
     list of arguments, a tentative match (i.e. one that would be
     accepted if the predicate were omitted) is accepted only if
     `predname (arg_1', ..., arg_n')' evaluates to `true' where
     <arg_i'> is the value matched to <arg_i>.  The <arg_i> may be the
     name of any atom or the argument of any kernel appearing in <prod>.
     <repl> may be any rational expression. If any of the atoms or
     arguments from <prod> appear in <repl> the appropriate
     substitutions are made.  The global flag `letrat' controls the
     simplification of quotients by `letsimp'.  When `letrat' is
     `false', `letsimp' simplifies the numerator and denominator of
     <expr> separately, and does not simplify the quotient.
     Substitutions such as `n!/n' goes to `(n-1)!' then fail.  When
     `letrat' is `true', then the numerator, denominator, and the
     quotient are simplified in that order.

     These substitution functions allow you to work with several rule
     packages at once.  Each rule package can contain any number of
     `let' rules and is referenced by a user-defined name.  `let
     ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
     <package_name>)' adds the rule <predname> to the rule package
     <package_name>.  `letsimp (<expr>, <package_name>)' applies the
     rules in <package_name>.  `letsimp (<expr>, <package_name1>,
     <package_name2>, ...)' is equivalent to `letsimp (<expr>,
     <package_name1>)' followed by `letsimp (%, <package_name2>)', ....

     `current_let_rule_package' is the name of the rule package that is
     presently being used.  This variable may be assigned the name of
     any rule package defined via the `let' command.  Whenever any of
     the functions comprising the `let' package are called with no
     package name, the package named by `current_let_rule_package' is
     used.  If a call such as `letsimp (<expr>, <rule_pkg_name>)' is
     made, the rule package <rule_pkg_name> is used for that `letsimp'
     command only, and `current_let_rule_package' is not changed.  If
     not otherwise specified, `current_let_rule_package' defaults to
     `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Option variable: letrat
     Default value: `false'

     When `letrat' is `false', `letsimp' simplifies the numerator and
     denominator of a ratio separately, and does not simplify the
     quotient.

     When `letrat' is `true', the numerator, denominator, and their
     quotient are simplified in that order.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Function: letrules ()
 -- Function: letrules (<package_name>)
     Displays the rules in a rule package.  `letrules ()' displays the
     rules in the current rule package.  `letrules (<package_name>)'
     displays the rules in <package_name>.

     The current rule package is named by `current_let_rule_package'.
     If not otherwise specified, `current_let_rule_package' defaults to
     `default_let_rule_package'.

     See also `disprule', which displays rules defined by `tellsimp'
     and `tellsimpafter'.


 -- Function: letsimp (<expr>)
 -- Function: letsimp (<expr>, <package_name>)
 -- Function: letsimp (<expr>, <package_name_1>, ..., <package_name_n>)
     Repeatedly applies the substitution rules defined by `let' until
     no further change is made to <expr>.

     `letsimp (<expr>)' uses the rules from `current_let_rule_package'.

     `letsimp (<expr>, <package_name>)' uses the rules from
     <package_name> without changing `current_let_rule_package'.

     `letsimp (<expr>, <package_name_1>, ..., <package_name_n>)' is
     equivalent to `letsimp (<expr>, <package_name_1>', followed by
     `letsimp (%, <package_name_2>)', and so on.


 -- Optionsvariable: let_rule_packages
     Standardwert: `[default_let_rule_package]'

     `let_rule_packages' ist eine Informationsliste mit den vom Benutzer
     definierten `let'-Regeln.


 -- Function: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associates a predicate <pred_k> with a variable or list of
     variables <a_k> so that <a_k> matches expressions for which the
     predicate returns anything other than `false'.

     A predicate is the name of a function, or a lambda expression, or
     a function call or lambda call missing the last argument, or
     `true' or `all'.  Any expression matches `true' or `all'.  If the
     predicate is specified as a function call or lambda call, the
     expression to be tested is appended to the list of arguments; the
     arguments are evaluated at the time the match is evaluated.
     Otherwise, the predicate is specified as a function name or lambda
     expression, and the expression to be tested is the sole argument.
     A predicate function need not be defined when `matchdeclare' is
     called; the predicate is not evaluated until a match is attempted.

     A predicate may return a Boolean expression as well as `true' or
     `false'.  Boolean expressions are evaluated by `is' within the
     constructed rule function, so it is not necessary to call `is'
     within the predicate.

     If an expression satisfies a match predicate, the match variable
     is assigned the expression, except for match variables which are
     operands of addition `+' or multiplication `*'.  Only addition and
     multiplication are handled specially; other n-ary operators (both
     built-in and user-defined) are treated like ordinary functions.

     In the case of addition and multiplication, the match variable may
     be assigned a single expression which satisfies the match
     predicate, or a sum or product (respectively) of such expressions.
     Such multiple-term matching is greedy: predicates are evaluated in
     the order in which their associated variables appear in the match
     pattern, and a term which satisfies more than one predicate is
     taken by the first predicate which it satisfies.  Each predicate
     is tested against all operands of the sum or product before the
     next predicate is evaluated.  In addition, if 0 or 1
     (respectively) satisfies a match predicate, and there are no other
     terms which satisfy the predicate, 0 or 1 is assigned to the match
     variable associated with the predicate.

     The algorithm for processing addition and multiplication patterns
     makes some match results (for example, a pattern in which a "match
     anything" variable appears) dependent on the ordering of terms in
     the match pattern and in the expression to be matched.  However,
     if all match predicates are mutually exclusive, the match result
     is insensitive to ordering, as one match predicate cannot accept
     terms matched by another.

     Calling `matchdeclare' with a variable <a> as an argument changes
     the `matchdeclare' property for <a>, if one was already declared;
     only the most recent `matchdeclare' is in effect when a rule is
     defined, Later changes to the `matchdeclare' property (via
     `matchdeclare' or `remove') do not affect existing rules.

     `propvars (matchdeclare)' returns the list of all variables for
     which there is a `matchdeclare' property.  `printprops (<a>,
     matchdeclare)' returns the predicate for variable `a'.
     `printprops (all, matchdeclare)' returns the list of predicates
     for all `matchdeclare' variables.  `remove (<a>, matchdeclare)'
     removes the `matchdeclare' property from <a>.

     The functions `defmatch', `defrule', `tellsimp', `tellsimpafter',
     and `let' construct rules which test expressions against patterns.

     `matchdeclare' quotes its arguments.  `matchdeclare' always
     returns `done'.

     Examples:

     A predicate is the name of a function, or a lambda expression, or
     a function call or lambda call missing the last argument, or
     `true' or `all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     If an expression satisfies a match predicate, the match variable
     is assigned the expression.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     In the case of addition and multiplication, the match variable may
     be assigned a single expression which satisfies the match
     predicate, or a sum or product (respectively) of such expressions.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     When matching arguments of `+' and `*', if all match predicates
     are mutually exclusive, the match result is insensitive to
     ordering, as one match predicate cannot accept terms matched by
     another.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     The functions `propvars' and `printprops' return information about
     match variables.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]


 -- Optionsvariable: maxapplydepth
     Standardwert: 10000

     `maxapplydepth' ist die maximale Tiefe mit der `apply1' und
     `apply2' angewendet werden.


 -- Optionsvariable: maxapplyheight
     Standardwert: 10000

     `maxapplyheigt' ist die maximale Gre die `applyb1' erreichen
     kann, bevor die Funktion aufgibt.


 -- Function: remlet (<prod>, <name>)
 -- Function: remlet ()
 -- Function: remlet (all)
 -- Function: remlet (all, <name>)
     Deletes the substitution rule, <prod> -> repl, most recently
     defined by the `let' function.  If name is supplied the rule is
     deleted from the rule package name.

     `remlet()' and `remlet(all)' delete all substitution rules from
     the current rule package.  If the name of a rule package is
     supplied, e.g. `remlet (all, <name>)', the rule package <name> is
     also deleted.

     If a substitution is to be changed using the same product,
     `remlet' need not be called, just redefine the substitution using
     the same product (literally) with the `let' function and the new
     replacement and/or predicate name.  Should `remlet (<prod>)' now be
     called the original substitution rule is revived.

     See also `remrule', which removes a rule defined by `tellsimp' or
     `tellsimpafter'.


 -- Function: remrule (<op>, <rulename>)
 -- Function: remrule (<op>, all)
     Removes rules defined by `tellsimp' or `tellsimpafter'.

     `remrule (<op>, <rulename>)' removes the rule with the name
     <rulename> from the operator <op>.  When <op> is a built-in or
     user-defined operator (as defined by `infix', `prefix', etc.),
     <op> and <rulename> must be enclosed in double quote marks.

     `remrule (<op>, all)' removes all rules for the operator <op>.

     See also `remlet', which removes a rule defined by `let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", ?\+rule1);
          (%o9)                           +
          (%i10) remrule ("@@", ?\@\@rule1);
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]


 -- Systemvariable: rules
     Standardwert: `[]'

     Enthlt die vom Benutzer mit den Funktionen `tellsimp',
     `tellsimpafter', `defmatch' oder `defrule' definierten Regeln.
     Siehe auch `infolists'.


 -- Function: tellsimp (<pattern>, <replacement>)
     is similar to `tellsimpafter' but places new information before
     old so that it is applied before the built-in simplification rules.

     `tellsimp' is used when it is important to modify the expression
     before the simplifier works on it, for instance if the simplifier
     "knows" something about the expression, but what it returns is not
     to your liking.  If the simplifier "knows" something about the
     main operator of the expression, but is simply not doing enough for
     you, you probably want to use `tellsimpafter'.

     The pattern may not be a sum, product, single variable, or number.

     `rules' is the list of rules defined by `defrule', `defmatch',
     `tellsimp', and `tellsimpafter'.

     Examples:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Function: tellsimpafter (<pattern>, <replacement>)
     Defines a simplification rule which the Maxima simplifier applies
     after built-in simplification rules.  <pattern> is an expression,
     comprising pattern variables (declared by `matchdeclare') and
     other atoms and operators, considered literals for the purpose of
     pattern matching.  <replacement> is substituted for an actual
     expression which matches <pattern>; pattern variables in
     <replacement> are assigned the values matched in the actual
     expression.

     <pattern> may be any nonatomic expression in which the main
     operator is not a pattern variable; the simplification rule is
     associated with the main operator.  The names of functions (with
     one exception, described below), lists, and arrays may appear in
     <pattern> as the main operator only as literals (not pattern
     variables); this rules out expressions such as `aa(x)' and `bb[y]'
     as patterns, if `aa' and `bb' are pattern variables.  Names of
     functions, lists, and arrays which are pattern variables may
     appear as operators other than the main operator in <pattern>.

     There is one exception to the above rule concerning names of
     functions.  The name of a subscripted function in an expression
     such as `aa[x](y)' may be a pattern variable, because the main
     operator is not `aa' but rather the Lisp atom `mqapply'.  This is
     a consequence of the representation of expressions involving
     subscripted functions.

     Simplification rules are applied after evaluation (if not
     suppressed through quotation or the flag `noeval').  Rules
     established by `tellsimpafter' are applied in the order they were
     defined, and after any built-in rules.  Rules are applied
     bottom-up, that is, applied first to subexpressions before
     application to the whole expression.  It may be necessary to
     repeatedly simplify a result (for example, via the quote-quote
     operator `''' or the flag `infeval') to ensure that all rules are
     applied.

     Pattern variables are treated as local variables in simplification
     rules.  Once a rule is defined, the value of a pattern variable
     does not affect the rule, and is not affected by the rule.  An
     assignment to a pattern variable which results from a successful
     rule match does not affect the current assignment (or lack of it)
     of the pattern variable.  However, as with all atoms in Maxima,
     the properties of pattern variables (as declared by `put' and
     related functions) are global.

     The rule constructed by `tellsimpafter' is named after the main
     operator of <pattern>.  Rules for built-in operators, and
     user-defined operators defined by `infix', `prefix', `postfix',
     `matchfix', and `nofix', have names which are Lisp identifiers.
     Rules for other functions have names which are Maxima identifiers.

     The treatment of noun and verb forms is slightly confused. If a
     rule is defined for a noun (or verb) form and a rule for the
     corresponding verb (or noun) form already exists, the
     newly-defined rule applies to both forms (noun and verb).  If a
     rule for the corresponding verb (or noun) form does not exist, the
     newly-defined rule applies only to the noun (or verb) form.

     The rule constructed by `tellsimpafter' is an ordinary Lisp
     function.  If the name of the rule is `$foorule1', the construct
     `:lisp (trace $foorule1)' traces the function, and `:lisp
     (symbol-function '$foorule1' displays its definition.

     `tellsimpafter' quotes its arguments.  `tellsimpafter' returns the
     list of rules for the main operator of <pattern>, including the
     newly established rule.

     See also `matchdeclare', `defmatch', `defrule', `tellsimp', `let',
     `kill', `remrule', and `clear_rules'.

     Examples:

     <pattern> may be any nonatomic expression in which the main
     operator is not a pattern variable.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Rules are applied in the order they were defined.  If two rules
     can match an expression, the rule which was defined first is
     applied.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Pattern variables are treated as local variables in simplification
     rules.  (Compare to `defmatch', which treats pattern variables as
     global variables.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     As with all atoms, properties of pattern variables are global even
     though values are local.  In this example, an assignment property
     is declared via `define_variable'.  This is a property of the atom
     `bb' throughout Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Rules are named after main operators.  Names of rules for built-in
     and user-defined operators are Lisp identifiers, while names for
     other functions are Maxima identifiers.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) remrule (foo, foorule1);
          (%o10)                         foo
          (%i11) remrule ("^", ?\^rule1);
          (%o11)                          ^
          (%i12) rules;
          (%o12)        [foorule2, foorule3, +rule1, *rule1]

     A worked example: anticommutative multiplication.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


 -- Function: clear_rules ()
     Executes `kill (rules)' and then resets the next rule number to 1
     for addition `+', multiplication `*', and exponentiation `^'.



File: maxima.info,  Node: Funktionsdefinitionen,  Next: Programmierung,  Prev: Regeln und Muster,  Up: Top

25 Funktionsdefinitionen
************************

* Menu:

* Einfhrung in Funktionsdefinitionen::
* Funktionen::
* Makros::
* Funktionen und Variablen fr Funktionsdefinitionen::


File: maxima.info,  Node: Einfhrung in Funktionsdefinitionen,  Next: Funktionen,  Prev: Funktionsdefinitionen,  Up: Funktionsdefinitionen

25.1 Einfhrung in Funktionsdefinitionen
=========================================


File: maxima.info,  Node: Funktionen,  Next: Makros,  Prev: Einfhrung in Funktionsdefinitionen,  Up: Funktionsdefinitionen

25.2 Funktionen
===============

25.2.1 Einfache Funktionen
--------------------------

Eine Maxima-Funktion wird mit dem Operator `:=' definiert. Im folgenden
wird die Funktion `f' definiert:

     f(x) := sin(x)

Funktionen, die mit der Funktion `lambda' definiert werden, sind anonyme
Funktionen, die keinen Namen haben. Diese werden auch `lambda'-Ausdrcke
genannt:

     lambda ([i, j], ...)

Anonyme Funktionen knnen berall dort genutzt werden, wo eine Funktion
als Argument erwartet wird. Das folgene Beispiel gibt eine Liste
zurck, bei der jedes Element mit 1 addiert wurde:

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

   Ist das letzte Argument einer Funktion eine Liste, kann auch eine
variable Anzahl an Argumenten an die Funktion bergeben werden:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   Die rechte Seite einer Funktionsdefinition ist ein Ausdruck. Mehrere
Ausdrcke werden durch Kommata getrennt und mit Klammern umgegeben. Das
Ergebnis der Funktion ist der Wert des letzten Ausdruck <exprn>:

     f(x) := (expr1, expr2, ...., exprn);

   Einen Rcksprung mit `return' aus einer Funktion ist mglich, wenn
die Definition der Funktion in einen Block `block' eingefgt wird:

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   Das obige Beispiel ist ein Ausdruck, der entweder `exprn' oder den
Wert des Symbols `a' als Ergebnis hat.

   Das erste paar Klammern `[]' in eine Block `block' enthlt die
Definition von lokalen Variablen wie zum Beispiel `[a: 3, b, c: []]'.
Die Variablen sind auerhalb des Blocks nicht sichtbar und die Werte von
globalen Variablen werden von den lokalen Werten berschrieben.
Auerhalb des Blocks haben die Variablen, wenn vorhanden, wieder ihre
alten Werte. Die Zuweisungen der Werte an die lokalen Variablen wird
parallel durchgefhrt.

   Im folgenden Beispiel wird der Wert der globalen Variablen <a> der
lokalen Variablen <a> zugewiesen. nderungen von <a> im Block wirken
sich nicht auf den globalen Wert der Variablen aus.

     block ([a: a], expr1, ... a: a+3, ..., exprn)

   Die Anweisung `block ([x], ...' bewirkt, dass `x' als lokale Variable
ohne einen Wert verwendet werden kann.

   Die Argumente einer Funktion werden in gleicher Weise wie lokal
definierte Variable behandelt. Die folgende Defintion

     f(x) := (expr1, ..., exprn);

   mit

     f(1);

   hat denselben Effekt wie der folgende Block:

     block ([x: 1], expr1, ..., exprn)

   Muss innerhalb von Funktionen die rechte Seite einer Defintion
berechnet werden, kann es sinnvoll sein, die Funktion `define' oder
auch `buildq' zu nutzen.

25.2.2 Array-Funktionen
-----------------------

Eine Array-Funktion speichert bei dem ersten Aufruf den Funktionswert
zu dem Argument. Wird die Array-Funktion mit demselben Argument
aufgerufen, wird der gespeicherte Wert zurckgeben, ohne diesen neu zu
berechnen. Dies wird auch Memoisation genannt.

   Die Namen der Array-Funktionen werden in die Informationsliste
`arrays' und nicht in die Liste `functions' eingetragen. `arrayinfo'
gibt eine Liste der Argumente zurck, fr die Werte gespeichert sind und
`listarrays' gibt die Werte zurck. `dispfun' und `fundef' geben die
Definition der Array-Funktion zurck.

   `arraymake' erzeugt den Aufruf einer Array-Funktion. Dies ist analog
zu der Funktion `funmake' fr gewhnliche Funktionen. `arrayapply'
wendet eine Array-Funktion auf die Argumente an. Dies entspricht der
Funktion `apply' fr gewhnliche Funktionen. Die Funktion `map' hat
keine Entsprechung fr Array-Funktionen. Vergleichbare Konstruktionen
sind `map(lambda([<x>], <a>[<x>]), <L>)' oder `makelist(<a>[<x>], <x>,
<L>)', wobei <L> eine Liste ist.

   `remarray' entfernt die Definition einer Array-Funktion
einschlielich der gespeicherten Werte. Dies entspricht `remfunction'
fr gewhnliche Funktionen.

   `kill(<a>[<x>])' entfernt den fr das Argument <x> gespeicherten
Wert einer Array-Funktion <a>. Beim nchsten Aufruf von <a> mit dem
Argument <x> wird der Funktionswert neu berechnet. Es gibt keine
Mglichkeit, alle gespeicherten Wert zu lschen. Die Kommandos
`kill(<a>)' und `remarray(<a>)' lschen alle Werte einschlielich der
Definition der Funktion.


File: maxima.info,  Node: Makros,  Next: Funktionen und Variablen fr Funktionsdefinitionen,  Prev: Funktionen,  Up: Funktionsdefinitionen

25.3 Makros
===========

 -- Funktion: buildq (<L>, <expr>)
     Die Namen der Variablen der Liste <L> werden in den Ausdruck <expr>
     substituiert. Die Substitution wird parallel ausgefhrt. Das
     Ergebnis der Substitution wird vereinfacht, aber nicht ausgewertet.

     Die Elemente der Liste <L> sind Symbole oder Zuweisungen
     `<symbol>: <value>'. Zuweisungen werden parallel ausgewertet.  Der
     Wert einer Variablen auf der rechten Seite einer Zuweisung ist der
     globale Wert in dem Kontext in dem `buildq' aufgerufen wird und
     nicht der lokale Wert einer vorhergenden Zuweisung. Erhlt eine
     Variable keinen Wert, dann behlt die Variable den globalen Wert.

     Dann werden die in der Liste <L> enthaltenen Variablen parallel in
     den Ausdruck <expr> substituiert.

     Enthlt <expr> Ausdrcke der Form `splice(<x>)', muss die Variable
     <x> eine Liste sein. Die Liste wird in den Ausdruck eingefgt.

     Variablen in <expr>, die nicht in <L> enthalten sind, werden nicht
     durch einen Wert ersetzt, auch wenn es eine globale Variable mit
     demselben Namen gibt.

     Beispiele:

     Der Variable `a' wird der Wert zugewiesen. Die Variable `b' erhlt
     den globalen Wert. Die Variable `c' hat keinen Wert. Das Ergebnis
     ist ein nicht ausgewerteter Ausdruck. Die Auswertung wird mit dem
     Quote-Quote-Opearator erzwungen.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' ist eine Liste, die einmal als Argument der Funktion `foo'
     vorliegt und zum anderen in die Argumentliste der Funktion `bar'
     eingefgt wird.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     Das Ergebnis wird nach der Substitution vereinfacht, ansonsten
     htten die beiden folgenden Beispiele dasselbe Ergebnis.

          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     Die Variablen der Liste <L> erhalten ihren Wert parallel,
     ansonsten wre das erste Ergebnis `foo(b,b)'. Substitutionen
     werden parallel ausgefhrt.  Im Gegensatz dazu werden die
     Substitution mit der Funktion `subst' nacheinander ausgefhrt.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
                        bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
                       bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Konstruktion einer List mit Gleichungen mit Variablen oder
     Ausdrcken auf der linken Seite und deren Werten auf der rechten
     Seite. Die Funktion `macroexpand' expandiert das Makro
     `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

     Konstruktion einer Funktion.

          (%i1) curry (f, [a]) :=
                  buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
          (%i2) by3 : curry ("*", 3);
          (%o2)        lambda([[x]], apply(*, append([3], x)))
          (%i3) by3 (a + b);
          (%o3)                       3 (b + a)


 -- Funktion: macroexpand (<expr>)
     Ist <expr> eine Makrodefinition, wird das Makro expandiert, ohne
     dass es ausgewertet wird. Ansonsten wird <expr> zurckgegeben.

     Ist die Expansion des Makros selbst ein Makro, wird dieses Makro
     wiederholt expandiert.

     `macroexpand' wertet das Argument <expr> nicht aus. Hat die
     Expansion des Makros Seiteneffekte, dann werden diese ausgefhrt.

     Siehe auch `::=',  `Makros'  und `macroexpand1'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Funktion: macroexpand1 (<expr>)
     Gibt die Makro-Expansion von <expr> zurck, ohne das Ergebnis
     auszuwerten.  Ist <expr> keine Makro-Funktion gibt `macroexpand1'
     das Argument <expr> zurck.

     `macroexpand1' wertet das Argument nicht aus. Hat die Expansion
     des Makros Seiteneffekte, dann werden diese ausgefhrt.

     Enthlt die Expansion <expr> wiederum Makros, werden diese im
     Unterschied zur Funktion `macroexpand' nicht expandiert.

     Siehe auch `::=',  `Makros'  und `macroexpand'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Systemvariable: macros
     Standardwert: `[]'

     `macros' ist eine Informationsliste, die die vom Nutzer mit dem
     Operator `::=' definierten Makro-Funktionen enthlt. Wird die
     Makro-Funktion mit einer der Funktionen `kill', `remove' oder
     `remfunction' gelscht, wird der Eintrag aus der Informationsliste
     entfernt. Siehe auch `infolists'.


 -- Funktion: remfunction (<f_1>, ..., <f_n>)
 -- Funktion: remfunction (all)
     Hebt die Bindung der Symbole <f_1>, ..., <f_n> an ihren
     Funktionsdefinitionen auf. Die Argumente knnen die Namen von
     Funktionen sein, die durch `:=' oder `define' definiert wurden
     sowie Makro-Funktionen, die durch `::=' definiert wurden.

     `remfunction(all)' entfernt alle Bindungen von
     Funktionsdefinitionen.

     `remfunction' wertet seine Argumente nicht aus.

     `remfunction' gibt eine Liste mit den Symbolen zurck, die von
     ihren Funktionsdefinitionen entbunden wurden. `false' wird statt
     der Symbole zurckgegeben, fr die es keine Funktionsdefinition
     gibt.

     `remfunction' kann nicht auf Array-Funktionen und indizierte
     Funktionen angewendet werden. Fr diese Funktionen kann `remarray'
     verwendet werden.


 -- Funktion: splice (<a>)
     Die Funktion `splice' kann nur im Zusammenhang mit der Funktion
     `buildq' genutzt werden. Das Argument <a> bezeichnet eine Liste,
     die an Stelle von `splice(a)' in einen Ausdruck eingefgt wird.
     <a> kann nicht selbst eine Liste sein oder ein Ausdruck sein, der
     zu einer Liste auswertet.

     Beispiele:

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Funktionen und Variablen fr Funktionsdefinitionen,  Prev: Makros,  Up: Funktionsdefinitionen

25.4 Funktionen und Variablen fr Funktionsdefinitionen
========================================================

 -- Funktion: apply (<F>, [<x_1>, ..., <x_n>])
     Konstuiert den Ausdruck `<F>(<arg_1>, ..., <arg_n>)' und wertet
     diesen aus.

     `apply' versucht nicht Array-Funktionen von gewhnlichen
     Funktionen zu unterscheiden. Ist <F> der Name eine Array-Funktion,
     wertet `apply' den Ausdruck `<F>(...)' aus. `arrayapply'
     entspricht der Funktion `apply', wenn <F> eine Array-Funktion ist.

     Beispiele:

     `apply' wertet die Argumente aus. In diesem Beispiel wird die
     Funktion `min' auf die Liste `L' angewendet.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     `apply' wertet die Argumente auch dann aus, wenn die Funktion `F'
     die Auswertung ihrer Argumente unterdrckt.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     `apply' wertet den Namen der Funktion <F> aus. Mit dem
     Quote-Operator `'' wird die Auswertung unterdrckt. `demoivre' ist
     der Name einer globalen Optionsvariable und einer Funktion.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)


 -- Function: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Function: block (<expr_1>, ..., <expr_n>)
     `block' wertet die Argument <expr_1>, <expr_2>, ..., <expr_n>
     nacheinander aus und gibt das Ergebnis des letzten ausgewerteten
     Ausdrucks zurck. Die Reihenfolge kann mit den Funktionen `go',
     `throw' und `return' beeinflusst werden. Die Liste der Variablen
     `[v_1, ..., v_m]' am Anfang von `block' bezeichnet Variablen, die
     innerhalb von `block' lokal sind. Alle anderen Variablen, die in
     einem Block verwendet werden, beziehen sich auf globale Variablen.

     `block' sichert die aktuellen Werte der Variablen <v_1>, ...,
     <v_m>. Wird `block' verlassen, werden diese Werte
     wiederhergestellt.

     Die Deklaration `local(<v_1>, ..., <v_m>)' innerhalb `block'
     sichert nicht nur die Werte, sondern auch die Eigenschaften der
     Variablen. Beim Verlassen von `block' werden die Eigenschaften
     wiederhergestellt. Erhalten die Variablen Eigenschaften innerhalb
     von `block', werden diese wieder entfernt, wenn `block' verlassen
     wird.

     `block' may appear within another `block'. Local variables are
     established each time a new `block' is evaluated. Local variables
     appear  to be global to any enclosed blocks. If a variable is
     non-local in a block,  its value is the value most recently
     assigned by an enclosing block, if any,  otherwise, it is the
     value of the variable in the global environment. This  policy may
     coincide with the usual understanding of "dynamic scope".

     The value of the block is the value of the last statement or the
     value of the  argument to the function `return' which may be used
     to exit explicitly  from the block. The function `go' may be used
     to transfer control to the  statement of the block that is tagged
     with the argument to `go'. To tag  a statement, precede it by an
     atomic argument as another statement in the  block.  For example:
     `block ([x], x:1, loop, x: x+1, ...,  go(loop), ...)'.  The
     argument to `go' must be the name of a tag  appearing within the
     block.  One cannot use `go' to transfer to a tag in  a block other
     than the one containing the `go'.

     Blocks typically appear on the right side of a function definition
     but can  be used in other places as well.


 -- Function: break (<expr_1>, ..., <expr_n>)
     Evaluates and prints <expr_1>, ..., <expr_n> and then causes a
     Maxima break at which point the user can examine and change his
     environment.  Upon typing `exit;' the computation resumes.


 -- Function: catch (<expr_1>, ..., <expr_n>)
     Evaluates <expr_1>, ..., <expr_n> one by one; if any leads to the
     evaluation of an expression of the form `throw (arg)', then the
     value of the `catch' is the value of `throw (arg)', and no further
     expressions are evaluated.  This "non-local return" thus goes
     through any depth of nesting to the nearest enclosing `catch'.  If
     there is no `catch' enclosing a `throw', an error message is
     printed.

     If the evaluation of the arguments does not lead to the evaluation
     of any `throw' then the value of `catch' is the value of <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     The function `g' returns a list of `f' of each element of `l' if
     `l' consists only of non-negative numbers; otherwise, `g'
     "catches" the first negative element of `l' and "throws" it up.


 -- Function: compfile (<filename>, <f_1>, ..., <f_n>)
 -- Function: compfile (<filename>, functions)
 -- Function: compfile (<filename>, all)
     Translates Maxima functions into Lisp and writes the translated
     code into the file <filename>.

     `compfile(<filename>, <f_1>, ..., <f_n>)' translates the specified
     functions.  `compfile(<filename>, functions)' and
     `compfile(<filename>, all)' translate all user-defined functions.

     The Lisp translations are not evaluated, nor is the output file
     processed by the Lisp compiler.  `translate' creates and evaluates
     Lisp translations.  `compile_file' translates Maxima into Lisp,
     and then executes the Lisp compiler.

     See also `translate', `translate_file', and `compile_file'.


 -- Function: compile (<f_1>, ..., <f_n>)
 -- Function: compile (functions)
 -- Function: compile (all)
     Translates Maxima functions <f_1>, ..., <f_n> into Lisp, evaluates
     the Lisp translations, and calls the Lisp function `COMPILE' on
     each translated function.  `compile' returns a list of the names
     of the compiled functions.

     `compile (all)' or `compile (functions)' compiles all user-defined
     functions.

     `compile' quotes its arguments; the quote-quote operator `'''
     defeats quotation.


 -- Function: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Function: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Function: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Function: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Function: define (ev (<expr_1>), <expr_2>)
     Defines a function named <f> with arguments <x_1>, ..., <x_n> and
     function body <expr>.  `define' always evaluates its second
     argument (unless explicitly quoted).  The function so defined may
     be an ordinary Maxima function (with arguments enclosed in
     parentheses) or an array function (with arguments enclosed in
     square brackets).

     When the last or only function argument <x_n> is a list of one
     element, the function defined by `define' accepts a variable
     number of arguments.  Actual arguments are assigned one-to-one to
     formal arguments <x_1>, ..., <x_(n - 1)>, and any further actual
     arguments, if present, are assigned to <x_n> as a list.

     When the first argument of `define' is an expression of the form
     `<f>(<x_1>, ..., <x_n>)' or `<f>[<x_1>, ..., <x_n>]', the function
     arguments are evaluated but <f> is not evaluated, even if there is
     already a function or variable by that name.

     When the first argument is an expression with operator `funmake',
     `arraymake', or `ev', the first argument is evaluated; this allows
     for the function name to be computed, as well as the body.

     All function definitions appear in the same namespace; defining a
     function `f' within another function `g' does not automatically
     limit the scope of `f' to `g'.  However, `local(f)' makes the
     definition of function `f' effective only within the block or
     other compound expression in which `local' appears.

     If some formal argument <x_k> is a quoted symbol (after
     evaluation), the function defined by `define' does not evaluate
     the corresponding actual argument.  Otherwise all actual arguments
     are evaluated.

     See also `:=' and `::='.

     Examples:

     `define' always evaluates its second argument (unless explicitly
     quoted).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     The function defined by `define' may be an ordinary Maxima
     function or an array function.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     When the last or only function argument <x_n> is a list of one
     element, the function defined by `define' accepts a variable
     number of arguments.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     When the first argument is an expression with operator `funmake',
     `arraymake', or `ev', the first argument is evaluated.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)


 -- Function: define_variable (<name>, <default_value>, <mode>)
     Introduces a global variable into the Maxima environment.
     `define_variable' is useful in user-written packages, which are
     often translated or compiled.

     `define_variable' carries out the following steps:

       1. `mode_declare (<name>, <mode>)' declares the mode of <name>
          to the translator.  See `mode_declare' for a list of the
          possible modes.

       2. If the variable is unbound, <default_value> is assigned to
          <name>.

       3. `declare (<name>, special)' declares it special.

       4. Associates <name> with a test function to ensure that <name>
          is only assigned values of the declared mode.

     The `value_check' property can be assigned to any variable which
     has been defined via `define_variable' with a mode other than
     `any'.  The `value_check' property is a lambda expression or the
     name of a function of one variable, which is called when an
     attempt is made to assign a value to the variable.  The argument
     of the `value_check' function is the would-be assigned value.

     `define_variable' evaluates `default_value', and quotes `name' and
     `mode'.  `define_variable' returns the current value of `name',
     which is `default_value' if `name' was unbound before, and
     otherwise it is the previous value of `name'.

     Examples:

     `foo' is a Boolean variable, with the initial value `true'.
          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' is an integer variable, which must be prime.
          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then
                                     error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 is not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' is a variable which cannot be assigned a value.  The
     mode `any_check' is like `any', but `any_check' enables the
     `value_check' mechanism, and `any' does not.
          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then
                           error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then
                           error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux


 -- Function: dispfun (<f_1>, ..., <f_n>)
 -- Function: dispfun (all)
     Displays the definition of the user-defined functions <f_1>, ...,
     <f_n>.  Each argument may be the name of a macro (defined with
     `::='), an ordinary function (defined with `:=' or `define'), an
     array function (defined with `:=' or `define', but enclosing
     arguments in square brackets `[ ]'), a subscripted function,
     (defined with `:=' or `define', but enclosing some arguments in
     square brackets and others in parentheses `( )') one of a family
     of subscripted functions selected by a particular subscript value,
     or a subscripted function defined with a constant subscript.

     `dispfun (all)' displays all user-defined functions as given by
     the `functions', `arrays', and `macros' lists, omitting
     subscripted functions defined with constant subscripts.

     `dispfun' creates an intermediate expression label (`%t1', `%t2',
     etc.)  for each displayed function, and assigns the function
     definition to the label.  In contrast, `fundef' returns the
     function definition.

     `dispfun' quotes its arguments; the quote-quote operator `'''
     defeats quotation.  `dispfun' returns the list of intermediate
     expression labels corresponding to the displayed functions.

     Examples:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- Systemvariable: functions
     Standardwert: `[]'

     `functions' ist eine Informationsliste, die die vom Benutzer mit
     dem Operator <:=> oder der Funktion `define' definierten Funktionen
     enthlt. Siehe `infolists'.

     Array-Funktionen und indizierte Funktionen werden nicht in die
     Informationsliste `functions', sondern in die Informationsliste
     `arrays' eingetragen.  Siehe `arrays'.

     Beispiele:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]


 -- Function: fundef (<f>)
     Returns the definition of the function <f>.

     The argument may be the name of a macro (defined with `::='), an
     ordinary function (defined with `:=' or `define'), an array
     function (defined with `:=' or `define', but enclosing arguments
     in square brackets `[ ]'), a subscripted function, (defined with
     `:=' or `define', but enclosing some arguments in square brackets
     and others in parentheses `( )') one of a family of subscripted
     functions selected by a particular subscript value, or a
     subscripted function defined with a constant subscript.

     `fundef' quotes its argument; the quote-quote operator `'''
     defeats quotation.

     `fundef (<f>)' returns the definition of <f>.  In contrast,
     `dispfun (<f>)' creates an intermediate expression label and
     assigns the definition to the label.


 -- Function: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Returns an expression `<F>(<arg_1>, ..., <arg_n>)'.  The return
     value is simplified, but not evaluated, so the function <F> is not
     called, even if it exists.

     `funmake' does not attempt to distinguish array functions from
     ordinary functions; when <F> is the name of an array function,
     `funmake' returns `<F>(...)' (that is, a function call with
     parentheses instead of square brackets).  `arraymake' returns a
     function call with square brackets in this case.

     `funmake' evaluates its arguments.

     Examples:

     `funmake' applied to an ordinary Maxima function.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     `funmake' applied to a macro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     `funmake' applied to a subscripted function.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     `funmake' applied to a symbol which is not a defined function of
     any kind.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     `funmake' evaluates its arguments, but not the return value.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maxima simplifies `funmake''s return value.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1


 -- Function: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ...,
          <expr_n>)
     Defines and returns a lambda expression (that is, an anonymous
     function).  The function may have required arguments <x_1>, ...,
     <x_m> and/or optional arguments <L>, which appear within the
     function body as a list.  The return value of the function is
     <expr_n>.  A lambda expression can be assigned to a variable and
     evaluated like an ordinary function.  A lambda expression may
     appear in some contexts in which a function name is expected.

     When the function is evaluated, unbound local variables <x_1>,
     ..., <x_m> are created.  `lambda' may appear within `block' or
     another `lambda'; local variables are established each time
     another `block' or `lambda' is evaluated.  Local variables appear
     to be global to any enclosed `block' or `lambda'.  If a variable
     is not local, its value is the value most recently assigned in an
     enclosing `block' or `lambda', if any, otherwise, it is the value
     of the variable in the global environment.  This policy may
     coincide with the usual understanding of "dynamic scope".

     After local variables are established, <expr_1> through <expr_n>
     are evaluated in turn.  The special variable `%%', representing
     the value of the preceding expression, is recognized.  `throw' and
     `catch' may also appear in the list of expressions.

     `return' cannot appear in a lambda expression unless enclosed by
     `block', in which case `return' defines the return value of the
     block and not of the lambda expression, unless the block happens
     to be <expr_n>.  Likewise, `go' cannot appear in a lambda
     expression unless enclosed by `block'.

     `lambda' quotes its arguments; the quote-quote operator `'''
     defeats quotation.

     Examples:

        * A lambda expression can be assigned to a variable and
          evaluated like an ordinary function.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * A lambda expression may appear in contexts in which a
          function evaluation is expected.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Argument variables are local variables.  Other variables
          appear to be global variables.  Global variables are
          evaluated at the time the lambda expression is evaluated,
          unless some special evaluation is forced by some means, such
          as `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Lambda expressions may be nested.  Local variables within the
          outer lambda expression appear to be global to the inner
          expression unless masked by local variables of the same names.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Since `lambda' quotes its arguments, lambda expression `i'
          below does not define a "multiply by `a'" function.  Such a
          function can be defined via `buildq', as in lambda expression
          `i2' below.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * A lambda expression may take a variable number of arguments,
          which are indicated by `[<L>]' as the sole or final argument.
          The arguments appear within the function body as a list.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46


 -- Function: local (<v_1>, ..., <v_n>)
     Saves the properties associated with the symbols <v_1>, ..., <v_n>,
     removes any properties before evaluating other expressions, and
     restores any saved properties on exit from the block or other
     compound expression in which `local' appears.

     Some declarations are implemented as properties of a symbol,
     including `:=', `array', `dependencies', `atvalue', `matchdeclare',
     `atomgrad', `constant', `nonscalar', `assume', and some others.
     The effect of `local' is to make such declarations effective only
     within the block or other compound expression in which `local'
     appears; otherwise such declarations are global declarations.

     `local' can only appear in `block' or in the body of a function
     definition or `lambda' expression, and only one occurrence is
     permitted in each.

     `local' quotes its arguments.  `local' returns `done'.

     Example:

     A local function definition.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99


 -- Option variable: macroexpansion
     Default value: `false'

     `macroexpansion' controls whether the expansion (that is, the
     return value) of a macro function is substituted for the macro
     function call.  A substitution may speed up subsequent expression
     evaluations, at the cost of storing the expansion.

    `false'
          The expansion of a macro function is not substituted for the
          macro function call.

    `expand'
          The first time a macro function call is evaluated, the
          expansion is stored.  The expansion is not recomputed on
          subsequent calls; any side effects (such as `print' or
          assignment to global variables) happen only when the macro
          function call is first evaluated.  Expansion in an expression
          does not affect other expressions which have the same macro
          function call.

    `displace'
          The first time a macro function call is evaluated, the
          expansion is substituted for the call, thus modifying the
          expression from which the macro function was called.  The
          expansion is not recomputed on subsequent calls; any side
          effects happen only when the macro function call is first
          evaluated.  Expansion in an expression does not affect other
          expressions which have the same macro function call.

     Examples

     When `macroexpansion' is `false', a macro function is called every
     time the calling expression is evaluated, and the calling
     expression is not modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     When `macroexpansion' is `expand', a macro function is called once,
     and the calling expression is not modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     When `macroexpansion' is `expand', a macro function is called once,
     and the calling expression is modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99


 -- Option variable: mode_checkp
     Default value: `true'

     When `mode_checkp' is `true', `mode_declare' checks the modes of
     bound variables.


 -- Option variable: mode_check_errorp
     Default value: `false'

     When `mode_check_errorp' is `true', `mode_declare' calls error.


 -- Option variable: mode_check_warnp
     Default value: `true'

     When `mode_check_warnp' is `true', mode errors are described.


 -- Function: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' is used to declare the modes of variables and
     functions for subsequent translation or compilation of functions.
     `mode_declare' is typically placed at the beginning of a function
     definition, at the beginning of a Maxima script, or executed at
     the interactive prompt.

     The arguments of `mode_declare' are pairs consisting of a variable
     and a mode which is one of `boolean', `fixnum', `number',
     `rational', or `float'.  Each variable may also be a list of
     variables all of which are declared to have the same mode.

     If a variable is an array, and if every element of the array which
     is referenced has a value then `array (yi, complete, dim1, dim2,
     ...)' rather than
          array(yi, dim1, dim2, ...)
     should be used when first declaring the bounds of the array.  If
     all the elements of the array are of mode `fixnum' (`float'), use
     `fixnum' (`float') instead of `complete'.  Also if every element
     of the array is of the same mode, say `m', then

          mode_declare (completearray (yi), m))

     should be used for efficient translation.

     Numeric code using arrays might run faster by declaring the
     expected size of the array, as in:

          mode_declare (completearray (a [10, 10]), float)

     for a floating point number array which is 10 x 10.

     One may declare the mode of the result of a function by using
     `function (f_1, f_2, ...)' as an argument; here `f_1', `f_2', ...
     are the names of functions.  For example the expression,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declares that the values returned by `f_1', `f_2', ... are
     single-word integers.

     `modedeclare' is a synonym for `mode_declare'.


 -- Function: mode_identity (<arg_1>, <arg_2>)
     A special form used with `mode_declare' and `macros' to declare,
     e.g., a list of lists of flonums, or other compound data object.
     The first argument to `mode_identity' is a primitive value mode
     name as given to `mode_declare' (i.e., one of `float', `fixnum',
     `number', `list', or `any'), and the second argument is an
     expression which is evaluated and returned as the value of
     `mode_identity'.  However, if the return value is not allowed by
     the mode declared in the first argument, an error or warning is
     signalled.  The important thing is that the mode of the expression
     as determined by the Maxima to Lisp translator, will be that given
     as the first argument, independent of anything that goes on in the
     second argument.  E.g., `x: 3.3; mode_identity (fixnum, x);'
     yields an error. `mode_identity (flonum, x)' returns 3.3 .  This
     has a number of uses, e.g., if you knew that `first (l)' returned a
     number then you might write `mode_identity (number, first (l))'.
     However, a more efficient way to do it would be to define a new
     primitive,

          firstnumb (x) ::= buildq ([x], mode_identity (number, x));

     and use `firstnumb' every time you take the first of a list of
     numbers.


 -- Option variable: packagefile
     Default value: `false'

     Package designers who use `save' or `translate' to create packages
     (files) for others to use may want to set `packagefile: true' to
     prevent information from being added to Maxima's information-lists
     (e.g. `values', `functions') except where necessary when the file
     is loaded in. In this way, the contents of the package will not
     get in the user's way when he adds his own data.  Note that this
     will not solve the problem of possible name conflicts.  Also note
     that the flag simply affects what is output to the package file.
     Setting the flag to `true' is also useful for creating Maxima init
     files.


 -- Option variable: savedef
     Default value: `true'

     When `savedef' is `true', the Maxima version of a user function is
     preserved when the function is translated. This permits the
     definition to be displayed by `dispfun' and allows the function to
     be edited.

     When `savedef' is `false', the names of translated functions are
     removed from the `functions' list.


 -- Option variable: transcompile
     Default value: `true'

     When `transcompile' is `true', `translate' and `translate_file'
     generate declarations to make the translated code more suitable
     for compilation.

     `compfile' sets `transcompile: true' for the duration.


 -- Function: translate (<f_1>, ..., <f_n>)
 -- Function: translate (functions)
 -- Function: translate (all)
     Translates the user-defined functions <f_1>, ..., <f_n> from the
     Maxima language into Lisp and evaluates the Lisp translations.
     Typically the translated functions run faster than the originals.

     `translate (all)' or `translate (functions)' translates all
     user-defined functions.

     Functions to be translated should include a call to `mode_declare'
     at the beginning when possible in order to produce more efficient
     code.  For example:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     where the <x_1>, <x_2>, ...  are the parameters to the function
     and the <v_1>, <v_2>, ... are the local variables.

     The names of translated functions are removed from the `functions'
     list if `savedef' is `false' (see below) and are added to the
     `props' lists.

     Functions should not be translated unless they are fully debugged.

     Expressions are assumed simplified; if they are not, correct but
     non-optimal code gets generated.  Thus, the user should not set
     the `simp' switch to `false' which inhibits simplification of the
     expressions to be translated.

     The switch `translate', if `true', causes automatic translation of
     a user's function to Lisp.

     Note that translated functions may not run identically to the way
     they did before translation as certain incompatabilities may exist
     between the Lisp and Maxima versions.  Principally, the `rat'
     function with more than one argument and the `ratvars' function
     should not be used if any variables are `mode_declare''d canonical
     rational expressions (CRE).  Also the `prederror: false' setting
     will not translate.

     `savedef' - if `true' will cause the Maxima version of a user
     function to remain when the function is `translate''d.  This
     permits the definition to be displayed by `dispfun' and allows the
     function to be edited.

     `transrun' - if `false' will cause the interpreted version of all
     functions to be run (provided they are still around) rather than
     the translated version.

     The result returned by `translate' is a list of the names of the
     functions translated.


 -- Function: translate_file (<maxima_filename>)
 -- Function: translate_file (<maxima_filename>, <lisp_filename>)
     Translates a file of Maxima code into a file of Lisp code.
     `translate_file' returns a list of three filenames: the name of
     the Maxima file, the name of the Lisp file, and the name of file
     containing additional information about the translation.
     `translate_file' evaluates its arguments.

     `translate_file ("foo.mac"); load("foo.LISP")' is the same as
     `batch ("foo.mac")' except for certain restrictions, the use of
     `''' and `%', for example.

     `translate_file (<maxima_filename>)' translates a Maxima file
     <maxima_filename> into a similarly-named Lisp file.  For example,
     `foo.mac' is translated into `foo.LISP'.  The Maxima filename may
     include a directory name or names, in which case the Lisp output
     file is written to the same directory from which the Maxima input
     comes.

     `translate_file (<maxima_filename>, <lisp_filename>)' translates a
     Maxima file <maxima_filename> into a Lisp file <lisp_filename>.
     `translate_file' ignores the filename extension, if any, of
     `lisp_filename'; the filename extension of the Lisp output file is
     always `LISP'.  The Lisp filename may include a directory name or
     names, in which case the Lisp output file is written to the
     specified directory.

     `translate_file' also writes a file of translator warning messages
     of various degrees of severity.  The filename extension of this
     file is `UNLISP'.  This file may contain valuable information,
     though possibly obscure, for tracking down bugs in translated code.
     The `UNLISP' file is always written to the same directory from
     which the Maxima input comes.

     `translate_file' emits Lisp code which causes some declarations
     and definitions to take effect as soon as the Lisp code is
     compiled.  See `compile_file' for more on this topic.

     See also `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', `tr_warn_undefined_variable', and `tr_windy'.


 -- Option variable: transrun
     Default value: `true'

     When `transrun' is `false' will cause the interpreted version of
     all functions to be run (provided they are still around) rather
     than the translated version.


 -- Option variable: tr_array_as_ref
     Default value: `true'

     If `translate_fast_arrays' is `false', array references in Lisp
     code emitted by `translate_file' are affected by `tr_array_as_ref'.
     When `tr_array_as_ref' is `true', array names are evaluated,
     otherwise array names appear as literal symbols in translated code.

     `tr_array_as_ref' has no effect if `translate_fast_arrays' is
     `true'.


 -- Option variable: tr_bound_function_applyp
     Default value: `true'

     When `tr_bound_function_applyp' is `true', Maxima gives a warning
     if a bound variable (such as a function argument) is found being
     used as a function.  `tr_bound_function_applyp' does not affect
     the code generated in such cases.

     For example, an expression such as `g (f, x) := f (x+1)' will
     trigger the warning message.


 -- Option variable: tr_file_tty_messagesp
     Default value: `false'

     When `tr_file_tty_messagesp' is `true', messages generated by
     `translate_file' during translation of a file are displayed on the
     console and inserted into the UNLISP file.  When `false', messages
     about translation of the file are only inserted into the UNLISP
     file.


 -- Option variable: tr_float_can_branch_complex
     Default value: `true'

     Tells the Maxima-to-Lisp translator to assume that the functions
     `acos', `asin', `asec', and `acsc' can return complex results.

     The ostensible effect of `tr_float_can_branch_complex' is the
     following.  However, it appears that this flag has no effect on
     the translator output.

     When it is `true' then `acos(x)' is of mode `any' even if `x' is
     of mode `float' (as set by `mode_declare').  When `false' then
     `acos(x)' is of mode `float' if and only if `x' is of mode `float'.


 -- Option variable: tr_function_call_default
     Default value: `general'

     `false' means give up and call `meval', `expr' means assume Lisp
     fixed arg function.  `general', the default gives code good for
     `mexprs' and `mlexprs' but not `macros'.  `general' assures
     variable bindings are correct in compiled code.  In `general'
     mode, when translating F(X), if F is a bound variable, then it
     assumes that `apply (f, [x])' is meant, and translates a such, with
     apropriate warning. There is no need to turn this off.  With the
     default settings, no warning messages implies full compatibility of
     translated and compiled code with the Maxima interpreter.


 -- Option variable: tr_numer
     Default value: `false'

     When `tr_numer' is `true', `numer' properties are used for atoms
     which have them, e.g. `%pi'.


 -- Option variable: tr_optimize_max_loop
     Default value: 100

     `tr_optimize_max_loop' is the maximum number of times the
     macro-expansion and optimization pass of the translator will loop
     in considering a form.  This is to catch macro expansion errors,
     and non-terminating optimization properties.


 -- Option variable: tr_semicompile
     Default value: `false'

     When `tr_semicompile' is `true', `translate_file' and `compfile'
     output forms which will be macroexpanded but not compiled into
     machine code by the Lisp compiler.


 -- System variable: tr_state_vars
     Default value:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     The list of the switches that affect the form of the translated
     output.  This information is useful to system people when trying
     to debug the translator.  By comparing the translated product to
     what should have been produced for a given state, it is possible to
     track down bugs.


 -- Function: tr_warnings_get ()
     Prints a list of warnings which have been given by the translator
     during the current translation.


 -- Option variable: tr_warn_bad_function_calls
     Default value: `true'

     - Gives a warning when when function calls are being made which
     may not be correct due to improper declarations that were made at
     translate time.


 -- Option variable: tr_warn_fexpr
     Default value: `compfile'

     - Gives a warning if any FEXPRs are encountered.  FEXPRs should
     not normally be output in translated code, all legitimate special
     program forms are translated.


 -- Option variable: tr_warn_meval
     Default value: `compfile'

     - Gives a warning if the function `meval' gets called.  If `meval'
     is called that indicates problems in the translation.


 -- Option variable: tr_warn_mode
     Default value: `all'

     - Gives a warning when variables are assigned values inappropriate
     for their mode.


 -- Option variable: tr_warn_undeclared
     Default value: `compile'

     - Determines when to send warnings about undeclared variables to
     the TTY.


 -- Option variable: tr_warn_undefined_variable
     Default value: `all'

     - Gives a warning when undefined global variables are seen.


 -- Option variable: tr_windy
     Default value: `true'

     - Generate helpful comments and programming hints.


 -- Function: compile_file (<filename>)
 -- Function: compile_file (<filename>, <compiled_filename>)
 -- Function: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)
     Translates the Maxima file <filename> into Lisp, executes the Lisp
     compiler, and, if the translation and compilation succeed, loads
     the compiled code into Maxima.

     `compile_file' returns a list of the names of four files: the
     original Maxima file, the Lisp translation, notes on translation,
     and the compiled code.  If the compilation fails, the fourth item
     is `false'.

     Some declarations and definitions take effect as soon as the Lisp
     code is compiled (without loading the compiled code).  These
     include functions defined with the `:=' operator, macros define
     with the `::=' operator, `alias', `declare', `define_variable',
     `mode_declare', and `infix', `matchfix', `nofix', `postfix',
     `prefix', and `compfile'.

     Assignments and function calls are not evaluated until the
     compiled code is loaded.  In particular, within the Maxima file,
     assignments to the translation flags (`tr_numer', etc.) have no
     effect on the translation.

     <filename> may not contain `:lisp' statements.

     `compile_file' evaluates its arguments.


 -- Function: declare_translated (<f_1>, <f_2>, ...)
     When translating a file of Maxima code to Lisp, it is important
     for the translator to know which functions it sees in the file are
     to be called as translated or compiled functions, and which ones
     are just Maxima functions or undefined.  Putting this declaration
     at the top of the file, lets it know that although a symbol does
     which does not yet have a Lisp function value, will have one at
     call time. `(MFUNCTION-CALL fn arg1 arg2 ...)' is generated when
     the translator does not know `fn' is going to be a Lisp function.




Local Variables:
coding: utf-8
End:
