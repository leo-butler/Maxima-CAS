This is maxima.info, produced by makeinfo version 4.13 from
/home/work/maxima/sandbox/maxima/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Integration,  Next: Differentialgleichungen,  Prev: Funktionen und Variablen der Differentiation,  Up: Analysis

16.3 Integration
================

* Menu:

* EinfÃ¼hrung in die Integration::
* Funktionen und Variablen der Integration::
* EinfÃ¼hrung in QUADPACK::
* Funktionen und Variablen fÃ¼r QUADPACK::


File: maxima.info,  Node: EinfÃ¼hrung in die Integration,  Next: Funktionen und Variablen der Integration,  Prev: Integration,  Up: Integration

   Integration

16.3.1 EinfÃ¼hrung in die Integration
-------------------------------------

Maxima hat verschiedene Routinen um Integrale zu behandeln. Die Funktion
`integrate' nutzt diese. Maxima hat ein Packet `antid', welches
Integrale mit einer unbekannten Funktion, deren Ableitung bekannt ist,
integrieren kann. FÃ¼r die numerische Berechnung von Integralen hat
Maxima das Packet `QUADPACK' mit Funktionen wie `quad_qag' oder
`quad_qags'. Die Funktionen `laplace' und `specint' finden die
Laplacetransformation.


File: maxima.info,  Node: Funktionen und Variablen der Integration,  Next: EinfÃ¼hrung in QUADPACK,  Prev: EinfÃ¼hrung in die Integration,  Up: Integration

16.3.2 Funktionen und Variablen der Integration
-----------------------------------------------

 -- Funktion: changevar (<expr>, <f(x,y)>, <y>, <x>)
     FÃ¼hrt eine Substitution der Integrationsvariablen, die als
     <f(x,y)=0> angegeben wird, fÃ¼r die Variable <x> in allen
     Integralen durch, die in <expr> enthalten sind. Die neue Variable
     ist <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Ein Ausdruck mit einem Integral in einer Substantivform
     `'integrate' wie im obigen Beispiel kann mit der Funktion `ev' und
     dem Auswertungsschalter `nouns' ausgewertet werden. Das Beispiel
     von oben kann zum Beispiel mit `ev(%o3, nouns)' ausgewertet werden.

     Mit `changevar' kÃ¶nnen auch die Indizes einer Summe oder eines
     Produktes substituiert werden. Dabei muss beachtet werden, dass
     nur lineare Verschiebungen, wie zum Beispiel `i = j + ...', eine
     korrekte Substitution fÃ¼r Summen und Produkte sind.

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Funktion: dblint (<f>, <r>, <s>, <a>, <b>)
     Eine Routine, um ein bestimmtes doppeltes Integral mit der
     Simpsonschen Regel numerisch zu berechnen.

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     Die Funktion <f> muss eine Funktion von zwei Variablen sein. <r>
     und <s> mÃ¼ssen Funktionen einer Variablen sein. <a> und <b> sind
     Gleitkommazahlen. Die Optionsvariablen `dblint_x' und `dblint_y'
     kontrollieren die Anzahl der Unterteilungen des
     Integrationsintervalls fÃ¼r den Simpsonschen Algorithmus. Der
     Standardwert ist jeweils 10.

     Das Kommando `demo(dblint)' zeigt ein Beispiel.

     Die numerischen Funktionen des Packets `QUADPACK' sind gegenÃ¼ber
     `dblint' zu bevorzugen.


 -- Funktion: defint (<expr>, <x>, <a>, <b>)
     Sucht das bestimmte Integral eines Ausdrucks <expr> fÃ¼r die
     Integrationsvariable <x> in den Grenzen <a> und <b>. Diese Funktion
     wird ausgefÃ¼hrt, wenn ein bestimmtes Integral mit der Funktion
     `integrate' gesucht wird.

     `defint' gibt einen symbolischen Ausdruck als Ergebnis zurÃ¼ck. Ist
     das Integral divergent generiert Maxima eine Fehlermeldung. Kann
     `defint' keine LÃ¶sung finden, wird eine Substantivform
     zurÃ¼ckgegeben.


 -- Option variable: erfflag
     Standardwert: `true'

     Hat `erfflag' den Wert `false', werden von der Funktion `risch'
     keine Fehlerfunktion `erf' in die LÃ¶sung eingefÃ¼hrt.


 -- Funktion: ilt (<expr>, <s>, <t>)
     Berechnet die Inverse Laplace-Transformation des Ausdrucks <expr>
     fÃ¼r die Variable <s> und den Parameter <t>. <expr> muss eine
     rationale Funktion sein, in deren Nenner nur lineare und
     quadratische Faktoren auftreten.  Mit den Funktionen `laplace' und
     `ilt' sowie den Funktionen `solve' oder `linsolve' kÃ¶nnen lineare
     Differentialgleichungen oder Systeme von linearen
     Differentialgleichungen gelÃ¶st werden.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Optionsvariable: intanalysis
     Standardwert: `true'

     Hat `intanalysis' den Wert `true', sucht Maxima nach Polen in einem
     Integranden. Existieren solche, wird der Cauchysche Hauptwert des
     Integrals bestimmt. Hat `intanalysis' den Wert `false', wird die
     Integration unter der Annahme ausgefÃ¼hrt, dass das Integral keine
     Pole im Integrationsbereich hat.

     Siehe auch `ldefint'.

     Beispiele:

     Maxima kann die folgende Integral lÃ¶sen, wenn `intanalysis' den
     Wert `false' hat.

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2


 -- Funktion: integrate (<expr>, <x>)
 -- Funktion: integrate (<expr>, <x>, <a>, <b>)
     Sucht die symbolische LÃ¶sung des Integrals fÃ¼r den Ausdruck <expr>
     fÃ¼r die Integrationsvariable <x>. `integrate(<expr>, <x>' ist das
     unbestimmte Integral. `integrate (<expr>, <x>, <a>, <b>)' sucht
     die LÃ¶sung des bestimmten Integrals in den Integrationsgrenzen <a>
     und <b>. Die Integrationsgrenzen sollten die Integrationsvariable
     <x> nicht enthalten. FÃ¼r die Integrationsgrenzen muss nicht gelten
     <a> < <b>. Sind die Integrationsgrenzen gleich, dann ist das
     Ergebnis der Integration Null.

     FÃ¼r die numerische LÃ¶sung von Integrale siehe die Funktion
     `quad_gag' und verwandte Funktionen. Residuen eines Integranden
     kÃ¶nnen mit der Funktion `residue' berechnet werden. Einen
     alternativen Algorithmus fÃ¼r das Berechnen von Integralen mit
     einer unbekannten Funktion bietet die Funktion `antid'.

     Findet `integrate' keine LÃ¶sung wird eine Substantivform oder ein
     Ausdruck mit einer oder mehreren Substantivformen zurÃ¼ckgegeben.

     Soll das Integral nicht sofort berechnet werden, kann die
     Substantivform des Integrals angegeben werden, zum Beispiel
     `'integrate(<expr>, <x>)'.  Die Berechnung des Integrals ist dann
     mit Funktion `ev' und dem Auswertungsschalter `nouns' mÃ¶glich.

     Die AbhÃ¤ngigkeit der Funktionen im Integranden von Parametern im
     Integranden muss explizit zum Beispiel mit `f(x)' angegeben
     werden. `integrate' beachtet keine AbhÃ¤ngigkeit der mit den
     Funktion `depends' definiert werden.

     BenÃ¶tigt `integrate' Informationen zu einem Parameter, die nicht
     aus Maximas Datenbank abgeleitet werden kÃ¶nnen, wird der Nutzer
     nach den fehlenden Informationen gefragt.

     `integrate' ist standardmÃ¤Ãig nicht als linear deklariert. Siehe
     `declare'  und `linear'.

     Nur in einigen speziellen FÃ¤llen versucht `integrate' eine
     partielle Integration anzuwenden.

     Beispiele:

        * Elementare unbestimmte und bestimme Integrale.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Gebrauch von `assume' und interaktive Fragen.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Substitution der Integrationsvariable. In diesem Beispiel
          werden zwei verschiedene Substitutionen vorgenommen. Zuerst
          wird eine Ableitung der Funktion mit der Funktion `gradef'
          definiert. Die andere nutzt die Ableitung `diff(r(x))' einer
          unbekannten Funktion `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * Die LÃ¶sung enthÃ¤lt eine Substantivform fÃ¼r das Integral einer
          rationalen Funktion. Siehe auch `integrate_use_rootsof' fÃ¼r
          Informationen zu Integralen von rationalen Funktionen.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definition einer Funktion als ein Integral. Die rechte Seite
          einer Funktionsdefinition wird nicht ausgewertet. Daher
          enthÃ¤lt die Funktionsdefinition das Integral in einer
          Substantivform. Der Quote-Quote-Operator `''' erzwingt die
          Auswertung der Substantivform.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Optionsvariable: integration_constant
     Standardwert: `%c'

     Wird eine symbolische Integrationskonstante fÃ¼r die LÃ¶sung eines
     Integrals benÃ¶tigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen `integration_counter' ist.

     Der Optionsvariablen `integration_constant' kann ein beliebiges
     Symbol zugewiesen werden.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3


 -- Systemvariable: integration_constant_counter
     Standardwert: 0

     Wird eine symbolische Integrationskonstante fÃ¼r die LÃ¶sung eines
     Integrals benÃ¶tigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen `integration_counter' ist.

     Der Wert der Systemvariablen `integration_constant_counter' wird
     vor der Erzeugung der Integrationskonstanten erhÃ¶ht.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o3)                     -- = x + %c3
                                    3
          (%i4) reset (integration_constant_counter);
          (%o4)            [integration_constant_counter]
          (%i5) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o5)                     -- = x + %c1
                                    3


 -- Optionsvariable: integrate_use_rootsof
     Standardwert: `false'

     Hat `integrate_use_rootsof' den Wert `true' und der Nenner einer
     rationalen Funktion kann nicht faktorisiert werden, dann gibt
     `integrate' ein Integral zurÃ¼ck, das eine Summe Ã¼ber die
     unbekannten Wurzeln des Nenners enthÃ¤lt.

     Hat zum Beispiel `integrate_use_rootsof' den Wert `false', gibt
     `integrate' im Folgenden ein LÃ¶sung zurÃ¼ck, die eine Substantivform
     enthÃ¤lt.

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Mit dem Wert `true' fÃ¼r die Optionsvariable `integrate_use_rootsof'
     wird das ungelÃ¶ste Integral als eine Summe Ã¼ber die Wurzeln des
     Nenners der rationalen Funktion zurÃ¼ckgegeben.

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternativ kann der Nutzer die Wurzeln des Nenners separat
     berechnen und den Integranden mit Hilfe der Wurzeln ausdrÃ¼cken.
     Zum Beispiel als `1/((x - a)*(x - b)*(x - c))' oder
     `1/((x^2-(a+b)*x + a*b)*(x - c))' ein kubisches Polynom mit drei
     Nullstellen im Nenner. Auf diese Weise kann Maxima in einigen
     FÃ¤llen eine LÃ¶sung fÃ¼r ein Integral finden.


 -- Funktion: laplace (<expr>, <t>, <s>)
     Sucht die Laplace-Transformation des Ausdrucks <expr> fÃ¼r die
     Integrationsvariable <x> und den Parameter <s>.

     `laplace' findet die Laplace-Transformation fÃ¼r AusdrÃ¼cke, die die
     Funktionen `delta', `exp', `log', `sin', `cos', `sinh', `cosh' und
     `erf' enthalten. Weiterhin kÃ¶nnen auch `derivative', `integrate',
     `sum' und `ilt' enthalten sein.  Kann `laplace' die
     Laplace-Transformation nicht finden, wird die Funktion `specint'
     aufgerufen. `specint' kann die Laplace-Transformation fÃ¼r eine
     Vielzahl von speziellen Funktion berechnen.

     Findet auch `specint' keine LÃ¶sung ist das Ergebnis eine
     Substantivform.

     `laplace' erkennt die Faltung von Funktionen der Form `integrate
     (f(x) * g(t - x), x, 0, t)'. Andere Faltungen werden nicht erkannt.

     Funktionale AbhÃ¤ngigkeiten von Variablen mÃ¼ssen explizit angegeben
     werden.  `laplace' erkennt keine AbhÃ¤ngigkeiten die mit der
     Funktion `depends' definiert wurden. Eine Funktion, die von den
     Variablen <x> abhÃ¤ngt, muss als `f(x)' im Ausdruck <expr>
     auftreten.

     Siehe auch `ilt',  fÃ¼r die Inverse Laplace-Transformation.

     Beispiele:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s)
                  ,simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)


 -- Funktion: ldefint (<expr>, <x>, <a>, <b>)
     Sucht die LÃ¶sung des bestimmten Integrals fÃ¼r den Integranden
     <expr>.  `ldefinit' bestimmt die Stammfunktion und sucht die
     Grenzwerte mit der Funktion `limit' an den Integrationsgrenzen <a>
     und <b>. Kann ein Grenzwert nicht ermittelt werden, enthÃ¤lt das
     Ergebnis die Substantivform des Grenzwertes.

     `ldefint' wird nicht von der Funktion `integrate' aufgerufen. Daher
     kann `ldefint' ein von `integrate' verschiedenes Ergebnis haben.
     `ldefint' verwendet immer denselben Algorithmus um eine LÃ¶sung zu
     finden.  Dagegen wendet `integrate' verschiedene Algorithmen an,
     um nach einer LÃ¶sung zu suchen.


 -- Funktion: residue (<expr>, <z>, <z_0>)
     Berechnet das Residuum fÃ¼r den Ausdruck <expr>, wenn die Variable
     <z> gegen den Wert <z_0> geht.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Function: risch (<expr>, <x>)
     Nutzt den transzendenten Risch-Algorithmus fÃ¼r die Integration des
     Ausdruck <expr> und der Integrationsvariable <x>. Der algebraische
     Risch-Algorithmus ist nicht implementiert. Der transzendente
     Risch-Algorithmus behandelt Integranden mit Exponential- und
     Logarithmusfunktionen. Der Risch-Algorithmus wird von `integrate'
     aufgerufen, wenn `integrate' keine Stammfunktion finden kann.

     Hat `erfflag' den Wert `false', werden von der Funktion `risch'
     keine Fehlerfunktionen `erf' in die LÃ¶sung eingefÃ¼hrt.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Funktion: tldefint (<expr>, <x>, <a>, <b>)
     Entspricht der Funktion `ldefint' mit dem Wert `true' fÃ¼r die
     Optionsvariable `tlimswitch'.



File: maxima.info,  Node: EinfÃ¼hrung in QUADPACK,  Next: Funktionen und Variablen fÃ¼r QUADPACK,  Prev: Funktionen und Variablen der Integration,  Up: Integration

16.3.3 EinfÃ¼hrung in QUADPACK
------------------------------

QUADPACK is a collection of functions for the numerical computation of
one-dimensional definite integrals.  It originated from a joint project
of R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), and D.
Kahaner (4).

   The QUADPACK library included in Maxima is an automatic translation
(via the program `f2cl') of the Fortran source code of QUADPACK as it
appears in the SLATEC Common Mathematical Library, Version 4.1 (5).
The SLATEC library is dated July 1993, but the QUADPACK functions were
written some years before.  There is another version of QUADPACK at
Netlib (6); it is not clear how that version differs from the SLATEC
version.

   The QUADPACK functions included in Maxima are all automatic, in the
sense that these functions attempt to compute a result to a specified
accuracy, requiring an unspecified number of function evaluations.
Maxima's Lisp translation of QUADPACK also includes some non-automatic
functions, but they are not exposed at the Maxima level.

   Further information about QUADPACK can be found in the QUADPACK book
(7).

Overview
........

`quad_qag'
     Integration of a general function over a finite interval.
     `quad_qag' implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose
     among 6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

`quad_qags'
     Integration of a general function over a finite interval.
     `quad_qags' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

`quad_qagi'
     Integration of a general function over an infinite or
     semi-infinite interval.  The interval is mapped onto a finite
     interval and then the same strategy as in `quad_qags' is applied.

`quad_qawo'
     Integration of cos(omega x) f(x) or sin(omega x) f(x) over a
     finite interval, where omega is a constant.  The rule evaluation
     component is based on the modified Clenshaw-Curtis technique.
     `quad_qawo' applies adaptive subdivision with extrapolation,
     similar to `quad_qags'.

`quad_qawf'
     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval.  The same approach as in `quad_qawo' is
     applied on successive finite intervals, and convergence
     acceleration by means of the Epsilon algorithm (Wynn, 1956) is
     applied to the series of the integral contributions.

`quad_qaws'
     Integration of w(x) f(x) over a finite interval [a, b], where w is
     a function of the form (x - a)^alpha (b - x)^beta v(x) and v(x) is
     1 or log(x - a) or log(b - x) or log(x - a) log(b - x), and alpha
     > -1 and beta > -1.

     A globally adaptive subdivision strategy is applied, with modified
     Clenshaw-Curtis integration on the subintervals which contain a or
     b.

`quad_qawc'
     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval (a, b) and specified c.  The strategy is globally
     adaptive, and modified Clenshaw-Curtis integration is used on the
     subranges which contain the point x = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut fÃ¼r Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) `http://www.netlib.org/slatec'

   (6) `http://www.netlib.org/quadpack'

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r QUADPACK,  Prev: EinfÃ¼hrung in QUADPACK,  Up: Integration

16.3.4 Funktionen und Variablen fÃ¼r QUADPACK
---------------------------------------------

 -- Function: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>,
          <epsabs>, <limit>])
 -- Function: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
     Integration of a general function over a finite interval.
     `quad_qag' implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose
     among 6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

     `quad_qag' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.  <key> is the integrator to be used and should be an
     integer between 1 and 6, inclusive.  The value of <key> selects
     the order of the Gauss-Kronrod integration rule.  High-order rules
     are suitable for strongly oscillating integrands.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The numerical integration is done adaptively by subdividing the
     integration region into sub-intervals until the desired accuracy is
     achieved.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit> is the maximum number
          of subintervals to use.  Default is 200.

     `quad_qag' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          if no problems were encountered;

    `1'
          if too many sub-intervals were done;

    `2'
          if excessive roundoff error is detected;

    `3'
          if extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9


 -- Function: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Function: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integration of a general function over a finite interval.
     `quad_qags' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     `quad_qags' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit> is the maximum number
          of subintervals to use.  Default is 200.

     `quad_qags' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.

     Examples:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note that `quad_qags' is more accurate and efficient than
     `quad_qag' for this integrand.


 -- Function: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Function: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integration of a general function over an infinite or
     semi-infinite interval.  The interval is mapped onto a finite
     interval and then the same strategy as in `quad_qags' is applied.

     `quad_qagi' evaluates one of the following integrals

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     using the Quadpack QAGI routine.  The function to be integrated is
     <f(x)>, with dependent variable <x>, and the function is to be
     integrated over an infinite range.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     One of the limits of integration must be infinity.  If not, then
     `quad_qagi' will just return the noun form.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit> is the maximum number
          of subintervals to use.  Default is 200.

     `quad_qagi' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Function: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>,
          <epsabs>, <limit>])
 -- Function: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval.  The strategy is globally adaptive, and modified
     Clenshaw-Curtis integration is used on the subranges which contain
     the point x = c.

     `quad_qawc' computes the Cauchy principal value of

     integrate (f(x)/(x - c), x, a, b)

     using the Quadpack QAWC routine.  The function to be integrated is
     `<f(x)>/(<x> - <c>)', with dependent variable <x>, and the function
     is to be integrated over the interval <a> to <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit> is the maximum number
          of subintervals to use.  Default is 200.

     `quad_qawc' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Function: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- Function: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval using the Quadpack QAWF function.  The same
     approach as in `quad_qawo' is applied on successive finite
     intervals, and convergence acceleration by means of the Epsilon
     algorithm (Wynn, 1956) is applied to the series of the integral
     contributions.

     `quad_qawf' computes the integral

     integrate (f(x)*w(x), x, a, inf)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     `quad_qawf' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Function: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
 -- Function: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
     Integration of cos (omega x) f(x) or sin (omega x) f(x) over a
     finite interval, where omega is a constant.  The rule evaluation
     component is based on the modified Clenshaw-Curtis technique.
     `quad_qawo' applies adaptive subdivision with extrapolation,
     similar to `quad_qags'.

     `quad_qawo' computes the integral using the Quadpack QAWO routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit>/2 is the maximum number
          of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     `quad_qawo' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Function: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>,
          <wfun>, [<epsrel>, <epsabs>, <limit>])
 -- Function: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
     Integration of w(x) f(x) over a finite interval, where w(x) is a
     certain algebraic or logarithmic function.  A globally adaptive
     subdivision strategy is applied, with modified Clenshaw-Curtis
     integration on the subintervals which contain the endpoints of the
     interval of integration.

     `quad_qaws' computes the integral using the Quadpack QAWS routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <wfun>:

    `1'
          w(x) = (x - a)^alpha (b - x)^beta

    `2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form `key=val'.  The keyword arguments
     are:

    <epsrel>
          Desired relative error of approximation.  Default is 1d-8.

    <epsabs>
          Desired absolute error of approximation.  Default is 0.

    <limit>
          Size of internal work array.  <limit>is the maximum number of
          subintervals to use.  Default is 200.

     `quad_qaws' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Differentialgleichungen,  Next: EinfÃ¼hrung in Differentialgleichungen,  Prev: Integration,  Up: Analysis

16.4 Differentialgleichungen
============================

* Menu:

* EinfÃ¼hrung in Differentialgleichungen::
* Funktionen und Variablen fÃ¼r Differentialgleichungen::


File: maxima.info,  Node: EinfÃ¼hrung in Differentialgleichungen,  Next: Funktionen und Variablen fÃ¼r Differentialgleichungen,  Prev: Differentialgleichungen,  Up: Differentialgleichungen

16.4.1 EinfÃ¼hrung in Differentialgleichungen
---------------------------------------------

This section describes the functions available in Maxima to obtain
analytic solutions for some specific types of first and second-order
equations. To obtain a numerical solution for a system of differential
equations, see the additional package `dynamics'. For graphical
representations in phase space, see the additional package `plotdf'.


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Differentialgleichungen,  Prev: EinfÃ¼hrung in Differentialgleichungen,  Up: Differentialgleichungen

16.4.2 Funktionen und Variablen fÃ¼r Differentialgleichungen
------------------------------------------------------------

 -- Function: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)
     Solves a boundary value problem for a second order differential
     equation.  Here: <solution> is a general solution to the equation,
     as found by `ode2'; <xval1> specifies the value of the independent
     variable in a first point, in the form `<x> = <x1>', and <yval1>
     gives the value of the dependent variable in that point, in the
     form `<y> = <y1>'. The expressions <xval2> and <yval2> give the
     values for these variables at a second point, using the same form.

     See `ode2' for an example of its usage.


 -- Function: desolve (<eqn>, <x>)
 -- Function: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     The function `desolve' solves systems of linear ordinary
     differential equations using Laplace transform.  Here the <eqn>'s
     are differential equations in the dependent variables <x_1>, ...,
     <x_n>.  The functional dependence of <x_1>, ..., <x_n> on an
     independent variable, for instance <x>, must be explicitly
     indicated in the variables and its derivatives. For example, this
     would not be the correct way to define two equations:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     The correct way would be:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     The call to the function `desolve' would then be
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     If initial conditions at `x=0' are known, they can be supplied
     before calling `desolve' by using `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     If `desolve' cannot obtain a solution, it returns `false'.


 -- Function: ic1 (<solution>, <xval>, <yval>)
     Solves initial value problems for first order differential
     equations.  Here <solution> is a general solution to the equation,
     as found by `ode2', <xval> gives an initial value for the
     independent variable in the form `<x> = <x0>', and <yval> gives the
     initial value for the dependent variable in the form `<y> = <y0>'.

     See `ode2' for an example of its usage.


 -- Function: ic2 (<solution>, <xval>, <yval>, <dval>)
     Solves initial value problems for second-order differential
     equations.  Here <solution> is a general solution to the equation,
     as found by `ode2', <xval> gives the initial value for the
     independent variable in the form `<x> = <x0>', <yval> gives the
     initial value of the dependent variable in the form `<y> = <y0>',
     and <dval> gives the initial value for the first derivative of the
     dependent variable with respect to independent variable, in the
     form `diff(<y>,<x>) = <dy0>' (`diff' does not have to be quoted).

     See `ode2' for an example of its usage.


 -- Function: ode2 (<eqn>, <dvar>, <ivar>)
     The function `ode2' solves an ordinary differential equation (ODE)
     of first or second order. It takes three arguments: an ODE given by
     <eqn>, the dependent variable <dvar>, and the independent variable
     <ivar>. When successful, it returns either an explicit or implicit
     solution for the dependent variable. `%c' is used to represent the
     integration constant in the case of first-order equations, and
     `%k1' and `%k2' the constants for second-order equations. The
     dependence of the dependent variable on the independent variable
     does not have to be written explicitly, as in the case of
     `desolve', but the independent variable must always be given as the
     third argument.

     If `ode2' cannot obtain a solution for whatever reason, it returns
     `false', after perhaps printing out an error message. The methods
     implemented for first order equations in the order in which they
     are tested are: linear, separable, exact - perhaps requiring an
     integrating factor, homogeneous, Bernoulli's equation, and a
     generalized homogeneous method. The types of second-order
     equations which can be solved are: constant coefficients, exact,
     linear homogeneous with non-constant coefficients which can be
     transformed to constant coefficients, the Euler or
     equi-dimensional equation, equations solvable by the method of
     variation of parameters, and equations which are free of either the
     independent or of the dependent variable so that they can be
     reduced to two first order linear equations to be solved
     sequentially.

     In the course of solving ODE's, several variables are set purely
     for informational purposes: `method' denotes the method of solution
     used (e.g., `linear'), `intfactor' denotes any integrating factor
     used, `odeindex' denotes the index for Bernoulli's method or for
     the generalized homogeneous method, and `yp' denotes the
     particular solution for the variation of parameters technique.

     In order to solve initial value problems (IVP) functions `ic1' and
     `ic2' are available for first and second order equations, and to
     solve second-order boundary value problems (BVP) the function `bc2'
     can be used.

     Example:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Polynome,  Next: Gleichungen,  Prev: Analysis,  Up: Top

17 Polynome
***********

* Menu:

* Introduction to Polynomials::
* Functions and Variables for Polynomials::


File: maxima.info,  Node: Introduction to Polynomials,  Next: Functions and Variables for Polynomials,  Prev: Polynome,  Up: Polynome

17.1 Introduction to Polynomials
================================

Polynomials are stored in Maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

   Canonical Rational Expressions constitute a kind of representation
which is especially suitable forexpanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC is set to `true').  In this CRE form an ordering
of variables (from most to least main) is assumed for each expression.
Polynomials are represented recursively by a list consisting of the
main variable followed by a series of pairs of expressions, one for
each term of the polynomial.  The first member of each pair is the
exponent of the main variable in that term and the second member is the
coefficient of that term which could be a number or a polynomial in
another variable again represented in this form.  Thus the principal
part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that of 2*X*Y+X-3
is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main variable, and is
(X 1 (Y 1 2 0 1) 0 -3) assuming X is the main variable. "Main"-ness is
usually determined by reverse alphabetical order.  The "variables" of a
CRE expression needn't be atomic.  In fact any subexpression whose main
operator is not + - * / or ^ with integer power will be considered a
"variable" of the expression (in CRE form) in which it occurs.  For
example the CRE variables of the expression X+SIN(X+1)+2*SQRT(X)+1 are
X, SQRT(X), and SIN(X+1).  If the user does not specify an ordering of
variables by using the RATVARS function Maxima will choose an
alphabetic one.  In general, CRE's represent rational expressions, that
is, ratios of polynomials, where the numerator and denominator have no
common factors, and the denominator is positive.  The internal form is
essentially a pair of polynomials (the numerator and denominator)
preceded by the variable ordering list.  If an expression to be
displayed is in CRE form or if it contains any subexpressions in CRE
form, the symbol /R/ will follow the line label.  See the RAT function
for converting an expression to CRE form.  An extended CRE form is used
for the representation of Taylor series.  The notion of a rational
expression is extended so that the exponents of the variables can be
positive or negative rational numbers rather than just positive
integers and the coefficients can themselves be rational expressions as
described above rather than just polynomials.  These are represented
internally by a recursive polynomial form which is similar to and is a
generalization of CRE form, but carries additional information such as
the degree of truncation.  As with CRE form, the symbol /T/ follows the
line label of such expressions.


File: maxima.info,  Node: Functions and Variables for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynome

17.2 Functions and Variables for Polynomials
============================================

 -- Funktion: lopow (<expr>, <x>)
     gibt den kleinsten Exponenten von <x> zurÃ¼ck, der im Ausdruck
     <expr> auftritt. Treten symbolische Exponententen auf, wird ein
     Ausdruck mit `min' zurÃ¼ckgegeben.

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Funktion: polymod (<p>)
 -- Function: polymod (<p>, <m>)
     Konvertiert das Polynom <p> in eine modulare Darstellung bezÃ¼glich
     dem aktuellen Modul. Das Modul ist der Wert der Variablen
     `modulus'.

     `polymod(<p>, <m>' konvertiert das Polynom bezÃ¼glich dem Modul
     <m>, anstatt dem aktuellen Modul `modulus'.

     Siehe `modulus'.


 -- Function: powers (<expr>, <x>)
     Gives the powers of <x> occuring in <expr>.

     `load (powers)' loads this function.


 -- Option variable: algebraic
     Default value: `false'

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.


 -- Option variable: berlefact
     Default value: `true'

     When `berlefact' is `false' then the Kronecker factoring algorithm
     will be used otherwise the Berlekamp algorithm, which is the
     default, will be used.


 -- Function: bezout (<p1>, <p2>, <x>)
     an alternative to the `resultant' command.  It returns a matrix.
     `determinant' of this matrix is the desired resultant.


 -- Function: bothcoef (<expr>, <x>)
     Returns a list whose first member is the coefficient of <x> in
     <expr> (as found by `ratcoef' if <expr> is in CRE form otherwise
     by `coeff') and whose second member is the remaining part of
     <expr>.  That is, `[A, B]' where `<expr> = A*<x> + B'.

     Example:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Function: coeff (<expr>, <x>, <n>)
 -- Function: coeff (<expr>, <x>)
     Returns the coefficient of `<x>^<n>' in <expr>, where <expr> is a
     polynomial or a monomial term in <x>.

     `coeff(<expr>, <x>^<n>)' is equivalent to `coeff(<expr>, <x>,
     <n>)'.  `coeff(<expr>, <x>, 0)' returns the remainder of <expr>
     which is free of <x>.  If omitted, <n> is assumed to be 1.

     <x> may be a simple variable or a subscripted variable, or a
     subexpression of <expr> which comprises an operator and all of its
     arguments.

     It may be possible to compute coefficients of expressions which
     are equivalent to <expr> by applying `expand' or `factor'.
     `coeff' itself does not apply `expand' or `factor' or any other
     function.

     `coeff' distributes over lists, matrices, and equations.

     Examples:

     `coeff' returns the coefficient `<x>^<n>' in <expr>.

          (%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     `coeff(<expr>, <x>^<n>)' is equivalent to `coeff(<expr>, <x>,
     <n>)'.

          (%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     `coeff(<expr>, <x>, 0)' returns the remainder of <expr> which is
     free of <x>.

          (%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x> may be a simple variable or a subscripted variable, or a
     subexpression of <expr> which comprises an operator and all of its
     arguments.

          (%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     `coeff' itself does not apply `expand' or `factor' or any other
     function.

          (%i1) coeff (c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand (c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff (%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff (%, (a + b)^3);
          (%o6)                           c

     `coeff' distributes over lists, matrices, and equations.

          (%i1) coeff ([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff (a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7


 -- Function: combine (<expr>)
     Simplifies the sum <expr> by combining terms with the same
     denominator into a single term.


 -- Function: content (<p_1>, <x_1>, ..., <x_n>)
     Returns a list whose first element is the greatest common divisor
     of the coefficients of the terms of the polynomial <p_1> in the
     variable <x_n> (this is the content) and whose second element is
     the polynomial <p_1> divided by the content.

     Examples:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Function: denom (<expr>)
     Returns the denominator of the rational expression <expr>.


 -- Function: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     computes the quotient and remainder of the polynomial <p_1>
     divided by the polynomial <p_2>, in a main polynomial variable,
     <x_n>.  The other variables are as in the `ratvars' function.  The
     result is a list whose first element is the quotient and whose
     second element is the remainder.

     Examples:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note that `y' is the main variable in the second example.


 -- Function: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Eliminates variables from equations (or expressions assumed equal
     to zero) by taking successive resultants. This returns a list of
     `<n> - <k>' expressions with the <k> variables <x_1>, ..., <x_k>
     eliminated.  First <x_1> is eliminated yielding `<n> - 1'
     expressions, then `x_2' is eliminated, etc.  If `<k> = <n>' then a
     single expression in a list is returned free of the variables
     <x_1>, ..., <x_k>.  In this case `solve' is called to solve the
     last resultant for the last variable.

     Example:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Function: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Returns a list whose first element is the g.c.d of the polynomials
     <p_1>, <p_2>, <p_3>, ...  and whose remaining elements are the
     polynomials divided by the g.c.d.  This always uses the `ezgcd'
     algorithm.


 -- Option variable: facexpand
     Default value: `true'

     `facexpand' controls whether the irreducible factors returned by
     `factor' are in expanded (the default) or recursive (normal CRE)
     form.


 -- Function: factor (<expr>)
 -- Function: factor (<expr>, <p>)
     Factors the expression <expr>, containing any number of variables
     or functions, into factors irreducible over the integers.  `factor
     (<expr>, <p>)' factors <expr> over the field of rationals with an
     element adjoined whose minimum polynomial is <p>.

     `factor' uses `ifactors' function for factoring integers.

     `factorflag' if `false' suppresses the factoring of integer factors
     of rational expressions.

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the `dontfactor' list.

     `savefactors' if `true' causes the factors of an expression which
     is a product of factors to be saved by certain functions in order
     to speed up later factorizations of expressions containing some of
     the same factors.

     `berlefact' if `false' then the Kronecker factoring algorithm will
     be used otherwise the Berlekamp algorithm, which is the default,
     will be used.

     `intfaclim' if `true' maxima will give up factorization of
     integers if no factor is found after trial divisions and Pollard's
     rho method.  If set to `false' (this is the case when the user
     calls `factor' explicitly), complete factorization of the integer
     will be attempted.  The user's setting of `intfaclim' is used for
     internal calls to `factor'. Thus, `intfaclim' may be reset to
     prevent Maxima from taking an inordinately long time factoring
     large integers.

     Examples:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Option variable: factorflag
     Default value: `false'

     When `factorflag' is `false', suppresses the factoring of integer
     factors of rational expressions.


 -- Function: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranges the sum <expr> into a sum of terms of the form `f
     (<x_1>, <x_2>, ...)*g' where `g' is a product of expressions not
     containing any <x_i> and `f' is factored.


 -- Function: factorsum (<expr>)
     Tries to group terms in factors of <expr> which are sums into
     groups of terms such that their sum is factorable.  `factorsum' can
     recover the result of `expand ((x + y)^2 + (z + w)^2)' but it
     can't recover `expand ((x + 1)^2 + (x + y)^2)' because the terms
     have variables in common.

     Example:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Function: fasttimes (<p_1>, <p_2>)
     Returns the product of the polynomials <p_1> and <p_2> by using a
     special algorithm for multiplication of polynomials.  `p_1' and
     `p_2' should be multivariate, dense, and nearly the same size.
     Classical multiplication is of order `n_1 n_2' where `n_1' is the
     degree of `p_1' and `n_2' is the degree of `p_2'.  `fasttimes' is
     of order `max (n_1, n_2)^1.585'.


 -- Function: fullratsimp (<expr>)
     `fullratsimp' repeatedly applies `ratsimp' followed by
     non-rational simplification to an expression until no further
     change occurs, and returns the result.

     When non-rational expressions are involved, one call to `ratsimp'
     followed as is usual by non-rational ("general") simplification
     may not be sufficient to return a simplified result.  Sometimes,
     more than one such call may be necessary.  `fullratsimp' makes
     this process convenient.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' takes one or more
     arguments similar to `ratsimp' and `rat'.

     Example:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Function: fullratsubst (<a>, <b>, <c>)
     is the same as `ratsubst' except that it calls itself recursively
     on its result until that result stops changing.  This function is
     useful when the replacement expression and the replaced expression
     have one or more variables in common.

     `fullratsubst' will also accept its arguments in the format of
     `lratsubst'.  That is, the first argument may be a single
     substitution equation or a list of such equations, while the
     second argument is the expression being processed.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' is equivalent to `ratsubst' except that it
          recurses until its result stops changing.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' also accepts a list of equations or a single
          equation as first argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' may cause an indefinite recursion.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
     Returns the greatest common divisor of <p_1> and <p_2>.  The flag
     `gcd' determines which algorithm is employed.  Setting `gcd' to
     `ez', `subres', `red', or `spmod' selects the `ezgcd',
     subresultant `prs', reduced, or modular algorithm, respectively.
     If `gcd' `false' then `gcd (<p_1>, <p_2>, <x>)' always returns 1
     for all <x>.  Many functions (e.g.  `ratsimp', `factor', etc.)
     cause gcd's to be taken implicitly.  For homogeneous polynomials
     it is recommended that `gcd' equal to `subres' be used.  To take
     the gcd when an algebraic is present, e.g., `gcd (<x>^2 -
     2*sqrt(2)*<x> + 2, <x> - sqrt(2))', `algebraic' must be `true' and
     `gcd' must not be `ez'.

     The `gcd' flag, default: `spmod', if `false' will also prevent the
     greatest common divisor from being taken when expressions are
     converted to canonical rational expression (CRE) form.  This will
     sometimes speed the calculation if gcds are not required.


 -- Function: gcdex (<f>, <g>)
 -- Function: gcdex (<f>, <g>, <x>)
     Returns a list `[<a>, <b>, <u>]' where <u> is the greatest common
     divisor (gcd) of <f> and <g>, and <u> is equal to `<a> <f> + <b>
     <g>'.  The arguments <f> and <g> should be univariate polynomials,
     or else polynomials in <x> a supplied main variable since we need
     to be in a principal ideal domain for this to work.  The gcd means
     the gcd regarding <f> and <g> as univariate polynomials with
     coefficients being rational functions in the other variables.

     `gcdex' implements the Euclidean algorithm, where we have a
     sequence of `L[i]: [a[i], b[i], r[i]]' which are all perpendicular
     to `[f, g, -1]' and the next one is built as if `q =
     quotient(r[i]/r[i+1])' then `L[i+2]: L[i] - q L[i+1]', and it
     terminates at `L[i+1]' when the remainder `r[i+2]' is zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note that the gcd in the following is `1' since we work in
     `k(y)[x]', not the  `y+1' we would expect in `k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1


 -- Function: gcfactor (<n>)
     Factors the Gaussian integer <n> over the Gaussian integers, i.e.,
     numbers of the form `<a> + <b> `%i'' where <a> and <b> are
     rational integers (i.e.,  ordinary integers).  Factors are
     normalized by making <a> and <b> non-negative.


 -- Function: gfactor (<expr>)
     Factors the polynomial <expr> over the Gaussian integers (that is,
     the integers with the imaginary unit `%i' adjoined).  This is like
     `factor (<expr>, <a>^2+1)' where <a> is `%i'.

     Example:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Function: gfactorsum (<expr>)
     is similar to `factorsum' but applies `gfactor' instead of
     `factor'.


 -- Function: hipow (<expr>, <x>)
     Returns the highest explicit exponent of <x> in <expr>.  <x> may
     be a variable or a general expression.  If <x> does not appear in
     <expr>, `hipow' returns `0'.

     `hipow' does not consider expressions equivalent to `expr'.  In
     particular, `hipow' does not expand `expr', so `hipow (<expr>,
     <x>)' and `hipow (expand (<expr>, <x>))' may yield different
     results.

     Examples:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Option variable: intfaclim
     Default value: true

     If `true', maxima will give up factorization of integers if no
     factor is found after trial divisions and Pollard's rho method and
     factorization will not be complete.

     When `intfaclim' is `false' (this is the case when the user calls
     `factor' explicitly), complete factorization will be attempted.
     `intfaclim' is set to `false' when factors are computed in
     `divisors', `divsum' and `totient'.

     Internal calls to `factor' respect the user-specified value of
     `intfaclim'.  Setting `intfaclim' to `true' may reduce the time
     spent factoring large integers.


 -- Option variable: keepfloat
     Default value: `false'

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Note that the function `solve' and those functions calling it
     (`eigenvalues', for example) currently ignore this flag, converting
     floating point numbers anyway.

     Examples:

          (%i1) rat(x/2.0);

          `rat' replaced 0.5 by 1/2 = 0.5
                                                 x
          (%o1)/R/                               -
                                                 2
          (%i2) rat(x/2.0), keepfloat;

          (%o2)/R/                             0.5 x

     `solve' ignores `keepfloat':

          (%i3) solve(1.0-x,x), keepfloat;

          `rat' replaced 1.0 by 1/1 = 1.0
          (%o3)                               [x = 1]


 -- Function: lratsubst (<L>, <expr>)
     is analogous to `subst (<L>, <expr>)' except that it uses
     `ratsubst' instead of `subst'.

     The first argument of `lratsubst' is an equation or a list of
     equations identical in format to that accepted by `subst'.  The
     substitutions are made in the order given by the list of equations,
     that is, from left to right.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Option variable: modulus
     Default value: `false'

     When `modulus' is a positive number <p>, operations on rational
     numbers (as returned by `rat' and related functions) are carried
     out modulo <p>, using the so-called "balanced" modulus system in
     which `<n> modulo <p>' is defined as an integer <k> in
     `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' when <p> is odd, or
     `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' when <p> is even, such that
     `<a> <p> + <k>' equals <n> for some integer <a>.

     If <expr> is already in canonical rational expression (CRE) form
     when `modulus' is reset, then you may need to re-rat <expr>, e.g.,
     `expr: rat (ratdisrep (expr))', in order to get correct results.

     Typically `modulus' is set to a prime number.  If `modulus' is set
     to a positive non-prime integer, this setting is accepted, but a
     warning message is displayed.  Maxima will allow zero or a
     negative integer to be assigned to `modulus', although it is not
     clear if that has any useful consequences.


 -- Function: num (<expr>)
     Returns the numerator of <expr> if it is a ratio.  If <expr> is
     not a ratio, <expr> is returned.

     `num' evaluates its argument.


 -- Function: partfrac (<expr>, <var>)
     Expands the expression <expr> in partial fractions with respect to
     the main variable <var>.  `partfrac' does a complete partial
     fraction decomposition.  The algorithm employed is based on the
     fact that the denominators of the partial fraction expansion (the
     factors of the original denominator) are relatively prime.  The
     numerators can be written as linear combinations of denominators,
     and the expansion falls out.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Function: polydecomp (<p>, <x>)
     Decomposes the polynomial <p> in the variable <x> into the
     functional composition of polynomials in <x>.  `polydecomp'
     returns a list `[<p_1>, ..., <p_n>]' such that

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     is equal to <p>.  The degree of <p_i> is greater than 1 for <i>
     less than <n>.

     Such a decomposition is not unique.

     Examples:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     The following function composes `L = [e_1, ..., e_n]' as functions
     in `x'; it is the inverse of polydecomp:

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-express above example using `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note that though `compose (polydecomp (<p>, <x>), <x>)' always
     returns <p> (unexpanded), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' does not necessarily return `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Function: quotient (<p_1>, <p_2>)
 -- Function: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the polynomial <p_1> divided by the polynomial <p_2>.  The
     arguments <x_1>, ..., <x_n> are interpreted as in `ratvars'.

     `quotient' returns the first element of the two-element list
     returned by `divide'.


 -- Function: rat (<expr>)
 -- Function: rat (<expr>, <x_1>, ..., <x_n>)
     Converts <expr> to canonical rational expression (CRE) form by
     expanding and combining all terms over a common denominator and
     cancelling out the greatest common divisor of the numerator and
     denominator, as well as converting floating point numbers to
     rational numbers within a tolerance of `ratepsilon'.  The
     variables are ordered according to the <x_1>, ..., <x_n>, if
     specified, as in `ratvars'.

     `rat' does not generally simplify functions other than addition
     `+', subtraction `-', multiplication `*', division `/', and
     exponentiation to an integer power, whereas `ratsimp' does handle
     those cases.  Note that atoms (numbers and variables) in CRE form
     are not the same as they are in the general form.  For example,
     `rat(x)- x' yields `rat(0)' which has a different internal
     representation than 0.

     When `ratfac' is `true', `rat' yields a partially factored form
     for CRE.  During rational operations the expression is maintained
     as fully factored as possible without an actual call to the factor
     package.  This should always save space and may save some time in
     some computations.  The numerator and denominator are still made
     relatively prime (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' yields `(x -
     1)^4 (x + 1)^2)', but the factors within each part may not be
     relatively prime.

     `ratprint' if `false' suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.

     `keepfloat' if `true' prevents floating point numbers from being
     converted to rational numbers.

     See also `ratexpand' and  `ratsimp'.

     Examples:
          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Option variable: ratalgdenom
     Default value: `true'

     When `ratalgdenom' is `true', allows rationalization of
     denominators with respect to radicals to take effect.
     `ratalgdenom' has an effect only when canonical rational
     expressions (CRE) are used in algebraic mode.


 -- Function: ratcoef (<expr>, <x>, <n>)
 -- Function: ratcoef (<expr>, <x>)
     Returns the coefficient of the expression `<x>^<n>' in the
     expression <expr>.  If omitted, <n> is assumed to be 1.

     The return value is free (except possibly in a non-rational sense)
     of the variables in <x>.  If no coefficient of this type exists, 0
     is returned.

     `ratcoef' expands and rationally simplifies its first argument and
     thus it may produce answers different from those of `coeff' which
     is purely syntactic.  Thus `ratcoef ((x + 1)/y + x, x)' returns
     `(y + 1)/y' whereas `coeff' returns 1.

     `ratcoef (<expr>, <x>, 0)', viewing <expr> as a sum, returns a sum
     of those terms which do not contain <x>.  Therefore if <x> occurs
     to any negative powers, `ratcoef' should not be used.

     Since <expr> is rationally simplified before it is examined,
     coefficients may not appear quite the way they were envisioned.

     Example:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Function: ratdenom (<expr>)
     Returns the denominator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `denom' is similar, but returns an ordinary expression instead of
     a CRE.  Also, `denom' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratdenom' are not considered ratios by `denom'.


 -- Option variable: ratdenomdivide
     Default value: `true'

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     Examples:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Function: ratdiff (<expr>, <x>)
     Differentiates the rational expression <expr> with respect to <x>.
     <expr> must be a ratio of polynomials or a polynomial in <x>.  The
     argument <x> may be a variable or a subexpression of <expr>.

     The result is equivalent to `diff', although perhaps in a
     different form.  `ratdiff' may be faster than `diff', for rational
     expressions.

     `ratdiff' returns a canonical rational expression (CRE) if `expr'
     is a CRE.  Otherwise, `ratdiff' returns a general expression.

     `ratdiff' considers only the dependence of <expr> on <x>, and
     ignores any dependencies established by `depends'.

     Example:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Function: ratdisrep (<expr>)
     Returns its argument as a general expression.  If <expr> is a
     general expression, it is returned unchanged.

     Typically `ratdisrep' is called to convert a canonical rational
     expression (CRE) into a general expression.  This is sometimes
     convenient if one wishes to stop the "contagion", or use rational
     functions in non-rational contexts.

     See also `totaldisrep'.


 -- Function: ratexpand (<expr>)
 -- Option variable: ratexpand
     Expands <expr> by multiplying out products of sums and
     exponentiated sums, combining fractions over a common denominator,
     cancelling the greatest common divisor of the numerator and
     denominator, then splitting the numerator (if a sum) into its
     respective terms divided by the denominator.

     The return value of `ratexpand' is a general expression, even if
     <expr> is a canonical rational expression (CRE).

     The switch `ratexpand' if `true' will cause CRE expressions to be
     fully expanded when they are converted back to general form or
     displayed, while if it is `false' then they will be put into a
     recursive form.  See also `ratsimp'.

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Examples:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Option variable: ratfac
     Default value: `false'

     When `ratfac' is `true', canonical rational expressions (CRE) are
     manipulated in a partially factored form.

     During rational operations the expression is maintained as fully
     factored as possible without calling `factor'.  This should always
     save space and may save time in some computations.  The numerator
     and denominator are made relatively prime, for example `rat ((x^2
     - 1)^4/(x + 1)^2)' yields `(x - 1)^4 (x + 1)^2)', but the factors
     within each part may not be relatively prime.

     In the `ctensr' (Component Tensor Manipulation) package, Ricci,
     Einstein, Riemann, and Weyl tensors and the scalar curvature are
     factored automatically when `ratfac' is `true'.  `ratfac' should
     only be set for cases where the tensorial components are known to
     consist of few terms.

     The `ratfac' and `ratweight' schemes are incompatible and may not
     both be used at the same time.


 -- Function: ratnumer (<expr>)
     Returns the numerator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `num' is similar, but returns an ordinary expression instead of a
     CRE.  Also, `num' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratnumer' are not considered ratios by `num'.


 -- Function: ratnump (<expr>)
     Returns `true' if <expr> is a literal integer or ratio of literal
     integers, otherwise `false'.


 -- Function: ratp (<expr>)
     Returns `true' if <expr> is a canonical rational expression (CRE)
     or extended CRE, otherwise `false'.

     CRE are created by `rat' and related functions.  Extended CRE are
     created by `taylor' and related functions.


 -- Option variable: ratprint
     Default value: `true'

     When `ratprint' is `true', a message informing the user of the
     conversion of floating point numbers to rational numbers is
     displayed.


 -- Function: ratsimp (<expr>)
 -- Function: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifies the expression <expr> and all of its subexpressions,
     including the arguments to non-rational functions.  The result is
     returned as the quotient of two polynomials in a recursive form,
     that is, the coefficients of the main variable are polynomials in
     the other variables.  Variables may include non-rational functions
     (e.g., `sin (x^2 + 1)') and the arguments to any such functions
     are also rationally simplified.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' enables rational
     simplification with the specification of variable ordering as in
     `ratvars'.

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.

     See also `ratexpand'.  Note that `ratsimp' is affected by some of
     the flags which affect `ratexpand'.

     Examples:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Option variable: ratsimpexpons
     Default value: `false'

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.


 -- Optionsvariable: radsubstflag
     Standardwert: `false'

     Hat `radsubstflag' den Wert `true', wird verhindert, dass die
     Funktion `ratsubst' z. B. `u' fÃ¼r `sqrt(x)' in `x' substituiert.


 -- Function: ratsubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c> and returns the resulting
     expression.  <b> may be a sum, product, power, etc.

     `ratsubst' knows something of the meaning of expressions whereas
     `subst' does a purely syntactic substitution.  Thus `subst (a, x +
     y, x + y + z)' returns `x + y + z' whereas `ratsubst' returns `z +
     a'.

     When `radsubstflag' is `true', `ratsubst' makes substitutions for
     radicals in expressions which don't explicitly contain them.

     Examples:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Function: ratvars (<x_1>, ..., <x_n>)
 -- Function: ratvars ()
 -- System variable: ratvars
     Declares main variables <x_1>, ..., <x_n> for rational expressions.
     <x_n>, if present in a rational expression, is considered the main
     variable.  Otherwise, <x_[n-1]> is considered the main variable if
     present, and so on through the preceding variables to <x_1>, which
     is considered the main variable only if none of the succeeding
     variables are present.

     If a variable in a rational expression is not present in the
     `ratvars' list, it is given a lower priority than <x_1>.

     The arguments to `ratvars' can be either variables or non-rational
     functions such as `sin(x)'.

     The variable `ratvars' is a list of the arguments of the function
     `ratvars' when it was called most recently.  Each call to the
     function `ratvars' resets the list.  `ratvars ()' clears the list.


 -- Function: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Function: ratweight ()
     Assigns a weight <w_i> to the variable <x_i>.  This causes a term
     to be replaced by 0 if its weight exceeds the value of the
     variable `ratwtlvl' (default yields no truncation).  The weight of
     a term is the sum of the products of the weight of a variable in
     the term times its power.  For example, the weight of `3 x_1^2
     x_2' is `2 w_1 + w_2'.  Truncation according to `ratwtlvl' is
     carried out only when multiplying or exponentiating canonical
     rational expressions (CRE).

     `ratweight ()' returns the cumulative list of weight assignments.

     Note: The `ratfac' and `ratweight' schemes are incompatible and
     may not both be used at the same time.

     Examples:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- System variable: ratweights
     Default value: `[]'

     `ratweights' is the list of weights assigned by `ratweight'.  The
     list is cumulative: each call to `ratweight' places additional
     items in the list.

     `kill (ratweights)' and `save (ratweights)' both work as expected.


 -- Option variable: ratwtlvl
     Default value: `false'

     `ratwtlvl' is used in combination with the `ratweight' function to
     control the truncation of canonical rational expressions (CRE).
     For the default value of `false', no truncation occurs.


 -- Function: remainder (<p_1>, <p_2>)
 -- Function: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the remainder of the polynomial <p_1> divided by the
     polynomial <p_2>.  The arguments <x_1>, ..., <x_n> are interpreted
     as in `ratvars'.

     `remainder' returns the second element of the two-element list
     returned by `divide'.


 -- Function: resultant (<p_1>, <p_2>, <x>)
 -- Variable: resultant
     Computes the resultant of the two polynomials <p_1> and <p_2>,
     eliminating the variable <x>.  The resultant is a determinant of
     the coefficients of <x> in <p_1> and <p_2>, which equals zero if
     and only if <p_1> and <p_2> have a non-constant factor in common.

     If <p_1> or <p_2> can be factored, it may be desirable to call
     `factor' before calling `resultant'.

     The variable `resultant' controls which algorithm will be used to
     compute the resultant.  `subres' for subresultant prs, `mod' for
     modular resultant algorithm, and `red' for reduced prs.  On most
     problems `subres' should be best.  On some large degree univariate
     or bivariate problems `mod' may be better.

     The function `bezout' takes the same arguments as `resultant' and
     returns a matrix.  The determinant of the return value is the
     desired resultant.


 -- Option variable: savefactors
     Default value: `false'

     When `savefactors' is `true', causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.


 -- Function: showratvars (<expr>)
     Returns a list of the canonical rational expression (CRE)
     variables in expression `expr'.

     See also `ratvars'.


 -- Function: sqfr (<expr>)
     is similar to `factor' except that the polynomial factors are
     "square-free."  That is, they have factors only of degree one.
     This algorithm, which is also used by the first stage of `factor',
     utilizes the fact that a polynomial has in common with its n'th
     derivative all its factors of degree greater than n.  Thus by
     taking greatest common divisors with the polynomial of the
     derivatives with respect to each variable in the polynomial, all
     factors of degree greater than 1 can be found.

     Example:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)


 -- Function: tellrat (<p_1>, ..., <p_n>)
 -- Function: tellrat ()
     Adds to the ring of algebraic integers known to Maxima the
     elements which are the solutions of the polynomials <p_1>, ...,
     <p_n>.  Each argument <p_i> is a polynomial with integer
     coefficients.

     `tellrat (<x>)' effectively means substitute 0 for <x> in rational
     functions.

     `tellrat ()' returns a list of the current substitutions.

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.

     Maxima initially knows about the imaginary unit `%i' and all roots
     of integers.

     There is a command `untellrat' which takes kernels and removes
     `tellrat' properties.

     When `tellrat''ing a multivariate polynomial, e.g., `tellrat (x^2
     - y^2)', there would be an ambiguity as to whether to substitute
     `<y>^2' for `<x>^2' or vice versa.  Maxima picks a particular
     ordering, but if the user wants to specify which, e.g.  `tellrat
     (y^2 = x^2)' provides a syntax which says replace `<y>^2' by
     `<x>^2'.

     Examples:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Function: totaldisrep (<expr>)
     Converts every subexpression of <expr> from canonical rational
     expressions (CRE) to general form and returns the result.  If
     <expr> is itself in CRE form then `totaldisrep' is identical to
     `ratdisrep'.

     `totaldisrep' may be useful for ratdisrepping expressions such as
     equations, lists, matrices, etc., which have some subexpressions
     in CRE form.


 -- Function: untellrat (<x_1>, ..., <x_n>)
     Removes `tellrat' properties from <x_1>, ..., <x_n>.



File: maxima.info,  Node: Gleichungen,  Next: Lineare Algebra,  Prev: Polynome,  Up: Top

18 Gleichungen
**************

* Menu:

* Funktionen und Variablen fÃ¼r Gleichungen::


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Gleichungen,  Prev: Gleichungen,  Up: Gleichungen

18.1 Funktionen und Variablen fÃ¼r Gleichungen
==============================================

 -- Optionsvariable: %rnum
     Standwert: 0

     Wenn notwendig, erzeugen die Funktionen `solve' und `algsys'
     Parameter, die in die LÃ¶sungen eingesetzt werden. Die Parameter
     haben den Namen `%r<<num>>'. `%rnum' enthÃ¤lt die Nummer <num>, die
     an den PrÃ¤fix `%r' angehÃ¤ngt wird. Maxima erhÃ¶ht `%rnum'
     automatisch. Siehe auch die Systemvariable `%rnum_list'  fÃ¼r eine
     Liste der Parameter einer LÃ¶sung.

 -- Systemvariable: %rnum_list
     Standardwert: `[]'

     `%rnum_list' ist die Liste der Parameter, die von `solve' und
     `algsys' in LÃ¶sungen eingesetzt werden. Die Parameter werden der
     Liste `%rnum_list' hinzugefÃ¼gt, in der Reihenfolge in der sie
     erzeugt werden.

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1


 -- Optionsvariable: algexact
     Standardwert: `false'

     `algexact' kontrolliert die Funktion `algsys' folgendermaÃen:

        * Hat `algexact' den Wert `true', wird von der Funktion `algsys'
          stets `solve' aufgerufen. Findet `solve' keine LÃ¶sung, wird
          die Funktion `realroots' aufgerufen.

        * Hat `algexact' den Wert `false', wird die Funktion `solve' fÃ¼r
          Gleichungen aufgerufen, die von mehr als einer Variablen
          abhÃ¤ngen oder fÃ¼r quadratische oder kubische Gleichungen.

     Der Wert `true' fÃ¼r `algexact' garantiert nicht, dass `algsys' nur
     exakte LÃ¶sungen findet. Findet `algsys' keine exakten LÃ¶sungen,
     versucht die Funktion NÃ¤herungslÃ¶sungen zu finden.


 -- Optionsvariable: algepsilon
     Standardwert: 10^8

     Kontrolliert die Genauigkeit einer numerischen LÃ¶sung der Funktion
     `algsys'.


 -- Funktion: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Funktion: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     LÃ¶st ein Gleichungsystem mit den Polynomen <expr_1>, ..., <expr_m>
     oder den Gleichungen <eqn_1>, ..., <eqn_m> fÃ¼r die Variablen
     <x_1>, ..., <x_n>. Werden Polynome <expr_i> als Argument
     Ã¼bergeben, werden diese als Gleichungen <x_i = 0> interpretiert.
     Die Anzahl der Gleichungen und Variablen kann verschieden sein.

     `algsys' gibt eine Liste mit den LÃ¶sungen zurÃ¼ck. Jede LÃ¶sung ist
     wiederum eine Liste mit den LÃ¶sungen fÃ¼r die einzelnen Variablen
     <x_i>.  Kann `algsys' keine LÃ¶sung finden, wird eine leere Liste
     `[]' zurÃ¼ckgegeben.

     Haben die LÃ¶sungen freie Parameter setzt `algsys' die Symbole
     `%r1', `%r2', ... in die LÃ¶sungen ein. Die Parameter werden der
     Liste `%rnum_list' hinzugefÃ¼gt. Siehe `%rnum_list'.

     Die Funktion `algsys' verwendet die folgenden Schritte, um
     LÃ¶sungen eines Gleichungsystems zu finden:

       1. Die Gleichungen werden faktorisiert und in Teilsysteme
          aufgeteilt.

       2. FÃ¼r jedes Teilsystem <S_i> werden eine Gleichung <E> und eine
          Variable <x> ausgewÃ¤hlt, die den niedrigsten von Null
          verschiedenen Grad hat. Dann wird die Resultante der
          Gleichungen <E> und <E_j> fÃ¼r die Variable <x> sowie allen
          verbleibenden Gleichungen <E_j> des Teilsystems <S_i>
          berechnet. Dieses Verfahren eliminiert die Variable <x> und
          hat ein neues Teilsystem <S_i'> als Ergebnis. Der Algorithmus
          wiederholt nun den 1. Schritt.

       3. Besteht das Teilsystem nur noch aus einer Gleichung, hat
          diese Gleichung mehrere Variablen und enthÃ¤lt diese keine
          Gleitkommazahlen, dann wird `solve' aufgerufen, um eine
          exakte LÃ¶sung zu finden.

          Es kann sein, dass `solve' keine LÃ¶sung oder einen sehr groÃen
          Ausdruck als LÃ¶sung findet.

          Auch fÃ¼r Gleichungen, die nur eine Variable enthalten und die
          entweder linear, quadratisch oder quartisch sind sowie keine
          Gleitkommazahlen enthalten, wird `solve' aufgerufen, um eine
          exakte LÃ¶sung zu finden. Trifft dies nicht zu, wird die
          Funktion `realroots' aufgerufen, wenn der Schalter `realonly'
          den Wert `true' hat. Ansonsten wird die Funktion `allroots'
          aufgerufen. Die Funktion `realroots' sucht reelle LÃ¶sung der
          Gleichung, wÃ¤hrend die Funktion `allroots' auch komplex
          LÃ¶sungen sucht.

          Die Genauigkeit einer numerischen LÃ¶sung wird von der
          Optionsvariablen `algepsilon' kontrolliert.

          Hat die Optionsvariable `algexact' den Wert `true', wird
          immer die Funktion `solve' aufgerufen.

       4. Zuletzt werden die erhaltenen LÃ¶sungen in das betrachtete
          Teilsystem eingesetzt und der LÃ¶sungsalgorithmus mit dem 1.
          Schritt fortgesetzt.


     Tritt beim LÃ¶sen des Gleichungssystems eine Gleichung auf, die von
     mehreren Variablen abhÃ¤ngt und Gleitkommazahlen enthÃ¤lt, dann wird
     der Algorithmus mit der Meldung "`algsys' cannot solve - system
     too complicated."  abgebrochen. Ein NÃ¤herung mit Gleitkommazahlen
     kann in vorgehenden Schritten auftreten, wenn keine exakten
     LÃ¶sungen auffindbar sind.

     Ist das Argument der Funktion `allroots' kein Polynom, gibt Maxima
     eine Fehlermeldung. Die LÃ¶sungen eines Gleichungssystems kÃ¶nnen
     sehr groÃe AusdrÃ¼cke sein. Obwohl die LÃ¶sung reell ist, kann die
     imaginÃ¤re Einheit `%i' in den LÃ¶sungen enthalten sein. FÃ¼r die
     weitere Bearbeitung der LÃ¶sungen kÃ¶nnen die Funktionen `pickapart'
     oder `reval' nÃ¼tzlich sein.

     Beispiele:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Funktion: allroots (<expr>)
 -- Funktion: allroots (<eqn>)
     Berechnet numerische NÃ¤herungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> mit einer
     Variable.

     Hat der Schalter `polyfactor' den Wert `true', wird das Polynom
     Ã¼ber die reellen oder komplexen Zahlen faktorisiert.

     FÃ¼r den Fall mehrfacher Wurzeln kann `allroots' ungenaue Ergebnisse
     liefern. Ist das Polynom reell, kann `allroots (%i*<p>)') genauere
     Approximationen liefern als `allroots (<p>)', da `allroots' in
     diesem Fall einen anderen Algorithmus verwendet.

     Der ZÃ¤hler des Arguments der Funktion `allroots' muss nach
     Anwendung der Funktion `rat' ein Polynom sein und darf im Nenner
     hÃ¶chstens eine komplexe Zahl enthalten. Ist das Argument der
     Funktion `allroots' kein Polynom, gibt Maxima eine Fehlermeldung.
     Hat die Optionsvariable `polyfactor' den Wert `true', wird ein
     Ã¤quivalenter, faktorisierter Ausdruck zurÃ¼ckgegeben, der die
     NÃ¤herungen fÃ¼r die Nullstellen enthÃ¤lt.

     FÃ¼r komplexe Polynome wird ein Algorithmus von Jenkins und Traub
     verwendet (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  FÃ¼r
     reelle Polynome wird ein Algorithmus von Jenkins verwendet
     (Algorithm 493, ACM TOMS,vol. 1, (1975), p.178).

     Beispiele:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Funktion: bfallroots (<expr>)
 -- Funktion: bfallroots (<eqn>)
     Berechnet numerische NÃ¤herungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> mit einer
     Variable.

     `bfallroots' entspricht in jeder Hinsicht der Funktion `allroots'
     mit dem Unterschied, dass `bfallroots' die NÃ¤herungen mit groÃen
     Gleitkommazahlen berechnet. Siehe `allroots'.


 -- Optionsvariable: backsubst
     Standardwert: `true'

     Hat `backsubst' den Wert `false', werden die LÃ¶sungen der Funktion
     `linsolve' nicht rÃ¼cksubstituiert. Dies kann hilfreich sein, wenn
     die RÃ¼cksubstitution zu sehr groÃen AusdrÃ¼cken fÃ¼hrt.

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]


 -- Optionsvariable: breakup
     Standardwert: `true'

     Haben die Optionsvariablen `programmode' und `breakup' den Wert
     `true', werden Zwischenmarken fÃ¼r gemeinsame Terme in LÃ¶sungen von
     kubischen und quartischen Gleichungen erzeugt.

     Beispiele:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Funktion: dimension (<eqn>)
 -- Funktion: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' ist ein Paket fÃ¼r die Dimensionsanalysis. `load(dimen)'
     lÃ¤dt dieses Paket. `demo(dimen)' zeigt eine kleine Demonstration.


 -- Optionsvariable: dispflag
     Standardwert: `true'

     Hat `dispflag' den Wert `false', werden Ausgaben der Funktion
     `solve' unterdrÃ¼ckt, die erzeugt werden, wenn die Optionsvariable
     `programmmode' den Wert `false' hat.


 -- Funktion: funcsolve (<eqn>, <g>(<t>))
     Das Argument ist eine Gleichung <eqn>, die ein Polynom erster
     Ordnung in den Funktionen `<g>(<t>)' und `<g>(<t+1>)' ist.
     `funcsolve' sucht die rationale Funktion `<g>(<t>)', die LÃ¶sung
     der Gleichung <eqn> ist.

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Warnung: Die Funktion ist nur sehr rudimentÃ¤r implementiert.
     Offensichtliche Verallgemeinerungen fehlen.


 -- Optionsvariable: globalsolve
     Standardwert: `false'

     Hat `globalsolve' den Wert `true', werden den unbekannten Variablen
     eines linearen Gleichungssystems die Werte der LÃ¶sung der
     Funktionen `linsolve' und `solve' zugewiesen.

     Hat `globalsolve' den Wert `false', werden den unbekannten
     Variablen eines linearen Gleichungssystems keine Werte zugewiesen.
     Die LÃ¶sungen werden als Gleichungen mit den unbekannten Variablen
     ausgedrÃ¼ckt.

     FÃ¼r andere als lineare Gleichungssysteme wird der Wert von
     `globalsolve' ignoriert. `algsys' ignoriert `globalsolve' immer.

     Beispiele:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Funktion: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' ist ein Paket zur LÃ¶sung von Integralgleichungen der Form
     `p(x) = q( x, p(x), 'integrate(w(x,u,p(x),p(u)),u,a(x),b(x)) )'
     (zweiter Art, `secondkind') und
     `'integrate(w(x,u,p(u)),u,a(x),b(x)) = f(x)' (erster Art,
     `firstkind'). `load ("inteqn")' lÃ¤dt dieses Paket.

     <ie> ist die Integralgleichung; <unk> ist die unbekannte Funktion
     einschlieÃlich angegebener AbhÃ¤ngigkeit; <tech> ist die Technik,
     die zur LÃ¶sung angewendet werden soll (<tech> = `first' bedeutet,
     dass die verfÃ¼gbaren LÃ¶sungstechniken der Reihe nach angewandt
     werden und das Ergebnis der ersten erfolgreichen LÃ¶sung wird
     zurÃ¼ckgegeben; <tech> = `all' bedeutet, dass alle Techniken
     angewandt werden); <n> ist die maximale Anzahl an Termen, die fÃ¼r
     `taylor', `neumann', `firstkindseries' oder `fredseries' verwendet
     werden (es ist ebenso die maximale Tiefe der Rekursion fÃ¼r die
     Differentiationsmethode); <guess> ist der Startwert fÃ¼r `neumann'
     oder `firstkindseries'.

     Standardwerte fÃ¼r den 2ten bis 5ten Parameter sind:

     <unk>: `<p>(<x>)', wobei <p> die als erste im Integranden
     aufgefundene Funktion ist, die fÃ¼r Maxima unbekannt ist, und <x>
     ist die Variable, die im Falle einer `secondkind'-Gleichung als
     Argument des ersten <p> auÃerhalb des Integrals vorgefunden wird,
     oder im Falle einer `firstkind'-Gleichung die einzige andere
     Variable neben der Integrationsvariable. Wenn der Versuch, <x> zu
     finden, fehlschlÃ¤gt, wird der Benutzer gefragt, eine unabhÃ¤ngige
     Variable anzugeben.

     <tech>: `first'

     <n>: 1

     <guess>: `none', was bewirkt, dass `neumann' und `firstkindseries'
     `<f>(<x>)' als Startwert verwenden.

     Siehe share/integequations/inteqn.usg fÃ¼r weitere Informationen.


 -- Optionsvariable: ieqnprint
     Standardwert: `true'

     `ieqnprint' regelt die Darstellung des Ergebnisses, das durch den
     Befehl `ieqn' zurÃ¼ck gegeben wird. Wenn `ieqnprint' `true' ist,
     ist die von der `ieqn'-Funktion zurÃ¼ckgegebene Liste von der Form

     [<solution>, <technique used>, <nterms>, <flag>]

     wobei <flag> nicht vorkommt, wenn die LÃ¶sung exakt ist.

     Andernfalls ist `approximate' bzw. `incomplete' das Wort, das sich
     auf eine nicht exakte bzw. nicht geschlossene Form der LÃ¶sung
     bezieht. Wird eine Reihenmethode angewandt, gibt <nterms> die
     Anzahl der verwendeten Terme (die kleiner als das in `ieqn'
     angegebene <n> sein kann, wenn ein Fehler die Erzeugung weiterer
     Terme verhindert).


 -- Funktion: lhs (<expr>)
     Gibt die linke Seite, das ist das erste Argument, des Ausdrucks
     <expr> zurÃ¼ck, wenn der Operator von <expr> einer der relationalen
     Operatoren `< <= = # equal notequal >= >', einer der
     Zuweisungsoperatoren `:= ::= : ::' oder ein benutzerdefinierter
     binÃ¤rer Infixoperator ist, der mit der Funktion deklariert durch
     `infix' deklariert wurde.

     Wenn <expr> ein Atom ist oder sein Operator ein anderer als oben
     aufgelistet, gibt `lhs' den Ausdruck <expr> zurÃ¼ck. Siehe auch
     `rhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Funktion: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     LÃ¶st das Gleichungssystem mit den Gleichungen oder Polynomen
     [<expr_1>, ..., <expr_m>] und den Variablen [<x_1>, ..., <x_n>].
     Jede Gleichung muss ein Polynom in den angegebenen Variablen sein.

     Hat `globalsolve' den Wert `true', werden die LÃ¶sungen des
     Gleichungssystems den angegebenen Variablen zugewiesen.

     Hat `backsubst' den Wert `false', fÃ¼hrt `linsolve' keine
     RÃ¼cksubstitutionen aus. Dies kann hilfreich sein, wenn die
     RÃ¼cksubstitution zu sehr groÃen AusdrÃ¼cken fÃ¼hrt.

     Hat `linsolve_params' den Wert `true', setzt `linsolve' fÃ¼r ein
     unterbestimmtes Gleichungssystem freie Parameter in die LÃ¶sungen
     ein, die mit `%r'-Symbolen bezeichnet werden. Siehe auch `%rnum'
     und `%rnum_list'.

     Hat `programmode' den Wert `false', gibt `linsolve' die LÃ¶sungen
     mit Hilfe von Zwischenmarken `%t' aus. Die Zwischenmarken werden
     als Liste zurÃ¼ckgegeben.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Optionsvariable: linsolvewarn
     Standardwert: `true'

     Hat `linsolvewarn' den Wert `true', gibt `linsolve' gegebenenfalls
     die Meldung "Dependent equations eliminated" aus.


 -- Optionsvariable: linsolve_params
     Standardwert: `true'

     Hat `linsolve_params' den Wert `true', setzt `linsolve' fÃ¼r ein
     unterbestimmtes Gleichungssystem freie Parameter in die LÃ¶sungen
     ein, die mit `%r'-Symbolen bezeichnet werden. Siehe auch `%rnum'
     und `%rnum_list'.


 -- Systemvariable: multiplicities
     Standardwert: `not_set_yet'

     `multiplicities' ist die Liste der Vielfachheiten der LÃ¶sungen,
     die von `solve', `realroots' oder `allroots' zurÃ¼ckgegeben werden.


 -- Funktion: nroots (<p>, <low>, <high>)
     Gibt die Anzahl der reellen Wurzeln des reellen univariaten
     Polynoms <p> im halboffenen Intervall `(<low>, <high>]' zurÃ¼ck.
     Die Grenzen des Intervalls kÃ¶nnen auch negativ unendlich `minf'
     oder positiv unendlich `inf' sein.

     `nroots' verwendet die Methode der Sturm-Sequenzen.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Funktion: nthroot (<p>, <n>)
     Das Argument <p> ist ein Polynom mit ganzzahligen Koeffizienten
     und das Argument <n> eine positive ganze Zahl. `nthroot' gibt ein
     Polynom q Ã¼ber den ganzen Zahlen zurÃ¼ck, so dass q^n = p gilt.
     Existiert kein derartiges Polynom <q> gibt Maxima eine
     Fehlermeldung. Diese Funktion ist wesentlich schneller als
     `factor' oder `sqfr'.


 -- Optionsvariable: polyfactor
     Standardwert: `false'

     Hat die Optionsvariable `polyfactor' den Wert `true', werden die
     LÃ¶sungen der Funktionen `allroots' und `bfallroots' Ã¼ber die
     reellen Zahlen, fÃ¼r reelle Polynome, und die komplexen Zahlen, fÃ¼r
     komplexe Polynome, faktorisiert.

     Siehe `allroots'  fÃ¼r ein Beispiel.


 -- Optionsvariable: programmode
     Standardwert: `true'

     Hat `programmode' den Wert `true', geben die Funktionen `solve',
     `realroots', `allroots', `bfallroots' und `linsolve' die LÃ¶sungen
     als Elemente einer Liste zurÃ¼ck.

     Hat `programmode' den Wert `false', werden die LÃ¶sungen der oben
     genannten Funktionen Zwischenmarken `%t' zugewiesen. Die RÃ¼ckgabe
     der Funktionen ist in diesem Fall eine Liste der Zwischenmarken.


 -- Optionsvariable: realonly
     Standardwert: `false'

     Hat `realonly' den Wert `true', gibt `algsys' nur LÃ¶sungen zurÃ¼ck,
     die nicht die imaginÃ¤re Einheit `%i' enthalten.


 -- Funktion: realroots (<expr>, <bound>)
 -- Funktion: realroots (<eqn>, <bound>)
 -- Funktion: realroots (<expr>)
 -- Funktion: realroots (<eqn>)
     Computes rational approximations of the real roots of the
     polynomial <expr> or polynomial equation <eqn> of one variable, to
     within a tolerance of <bound>. Coefficients of <expr> or <eqn>
     must be literal numbers; symbol constants such as `%pi' are
     rejected.

     `realroots' assigns the multiplicities of the roots it finds to
     the global variable `multiplicities'.

     `realroots' constructs a Sturm sequence to bracket each root, and
     then applies bisection to refine the approximations. All
     coefficients are converted to rational equivalents before
     searching for roots, and computations are carried out by exact
     rational arithmetic. Even if some coefficients are floating-point
     numbers, the results are rational (unless coerced to floats by the
     `float' or `numer' flags).

     When <bound> is less than 1, all integer roots are found exactly.
     When <bound> is unspecified, it is assumed equal to the global
     variable `rootsepsilon'.

     When the global variable `programmode' is `true', `realroots'
     returns a list of the form `[x = <x_1>, x = <x_2>, ...]'. When
     `programmode' is `false', `realroots' creates intermediate
     expression labels `%t1', `%t2', ..., assigns the results to them,
     and returns the list of labels.

     Examples:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]


 -- Funktion: rhs (<expr>)
     Gibt die rechte Seite, das ist das zweite Argument, des Ausdrucks
     <expr> zurÃ¼ck, wenn der Operator von <expr> einer der relationalen
     Operatoren `< <= = # equal notequal >= >', einer der
     Zuweisungsoperatoren `:= ::= : ::' oder ein benutzerdefinierter
     binÃ¤rer Infixoperator ist, der mit der Funktion `infix' deklariert
     wurde.

     Wenn <expr> ein Atom ist oder sein Operator ein anderer als oben
     aufgelistet, hat `rhs' das Ergebnis 0. Siehe auch `lhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Optionsvariable: rootsconmode
     Standardwert: `true'

     `rootsconmode' kontrolliert das Verhalten der Funktion
     `rootscontract'. Siehe `rootscontract' fÃ¼r Details.


 -- Funktion: rootscontract (<expr>)
     Konvertiert Produkte von Wurzeln in Wurzeln von Produkten. Zum
     Beispiel hat `rootscontract(sqrt(x)*y^(3/2))' das Ergebnis
     `sqrt(x*y^3)'.

     Hat `radexpand' den Wert `true' und `domain' den Wert `real', das
     sind die Standardwerte, wird `abs(x)' zu `sqrt(x^2)'.  Zum
     Beispiel hat `rootscontract(abs(x)*sqrt(y))' das Ergebnis
     `sqrt(x^2*y)'.

     Die Optionsvariable `rootsconmode' kontrolliert das Ergebnis
     folgendermaÃen:

          Problem             Wert             Ergebnis
                              rootsconmode     rootscontract

          x^(1/2)*y^(3/2)     false            sqrt(x*y^3)
          x^(1/2)*y^(1/4)     false            sqrt(x)*y^(1/4)
          x^(1/2)*y^(1/4)     true             sqrt(x*sqrt(y))
          x^(1/2)*y^(1/3)     true             sqrt(x)*y^(1/3)
          x^(1/2)*y^(1/4)     all              (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)     all              (x^3*y^2)^(1/6)

     Hat `rootsconmode' den Wert `false', kontrahiert `rootscontract'
     nur Faktoren mit rationalen Exponenten, die den gleichen Nenner
     haben. Hat `rootsconmode' den Wert `all', wird das kleinste
     gemeinsame Vielfache des Nenners der Faktoren verwendet, um die
     Faktoren zusammenzufassen.

     Ãhnlich wie bei der Funktion `logcontract' werden von
     `rootscontract' die Argumente unter der Wurzel mit der Funktion
     `ratsimp' vereinfacht.

     Beispiele:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0


 -- Optionsvariable: rootsepsilon
     Standardwert: 1.0e-7

     `rootsepsilon' ist die Toleranz, die den Vertrauensbereich fÃ¼r die
     von der Funktion `realroots' gefundenen Wurzeln festsetzt.


 -- Funktion: solve (<expr>, <x>)
 -- Funktion: solve (<expr>)
 -- Funktion: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     LÃ¶st eine algebraische Gleichung <expr> nach der Variable <x> auf.
     Wenn <expr> keine Gleichung ist, wird die Gleichung `<expr> = 0'
     angenommen. <x> kann eine Funktion wie zum Beispiel `f(x)') sein
     oder ein allgemeiner Ausdruck. Ausgenommen sind Summen und
     Produkte. Hat die Gleichung nur eine Variable, braucht diese nicht
     angegeben zu werden. <expr> kann ein rationaler Ausdruck sein und
     trigonometrische Funktionen, Exponentialfunktionen und andre
     Funktionen enthalten. Zur LÃ¶sung wird die folgende Methode
     verwendet:

     Sei <E> ein Ausdruck und <X> die Variable. Ist <E> linear in <X>,
     dann kann die Gleichung sofort nach der Variablen `X' aufgelÃ¶st
     werden. Hat <E> die Form `A*X^N + B', dann ist das Ergebnis
     `(-B/A)^1/N)' mal die `N'-te Einheitswurzel.

     Ist <E> nicht linear in <X>, wird der grÃ¶Ãte gemeinsame Teiler <N>
     der Exponenten der Variable <X> bestimmt. Die Exponenten der
     Variablen werden durch <N> dividiert und die MultiplizitÃ¤t der
     LÃ¶sungen mit <N> multipliziert. `solve' wird erneut fÃ¼r den
     Ausdruck aufgerufen. Kann <E> faktorisiert werden, wird `solve'
     fÃ¼r jeden Faktor aufgerufen.  Zuletzt prÃ¼ft `solve', ob einer der
     Algorithmen fÃ¼r quadratische, kubische oder quartische Gleichungen
     angewendet werden kann.

     Ist <E> ein Polynom in einer Funktion `F(X)' mit <X> als der
     Variablen, wird zunÃ¤chst die LÃ¶sung des Polynoms fÃ¼r `F(X)'
     gesucht.  Ist <C> eine solche LÃ¶sung, kann die Gleichung `F(X)=C'
     gelÃ¶st werden, wenn die Umkehrfunktion zu `F(X)' bekannt ist.

     Haben die Optionsvariablen `programmode' und `breakup' den Wert
     `true', werden Zwischenmarken fÃ¼r gemeinsame Terme in LÃ¶sungen von
     kubischen und quartischen Gleichungen erzeugt.

     `multiplicities' ist eine Liste mit den Vielfachheiten der
     einzelnen LÃ¶sungen.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' lÃ¶st ein
     Gleichungssystem mit den Polynomen <eqn_1>, ..., <eqn_n> fÃ¼r die
     Variablen <x_1>, ..., <x_n>. Die Polynome kÃ¶nnen linear oder
     nichtlinear sein. Um das System zu lÃ¶sen, werden die Funktionen
     `linsolve' oder `algsys' aufgerufen. Das Ergebnis ist eine Liste
     mit den LÃ¶sungen.  Ist die Anzahl der Gleichungen gleich der
     Anzahl der Variablen des Systems, kann die Liste mit den Variablen
     entfallen.

     Wenn `programmode' `false' ist, zeigt `solve' die LÃ¶sungen mit
     Hilfe von Zwischenmarken (`%t') an und gibt die Liste der Marken
     zurÃ¼ck.

     Hat `programmode' den Wert `false', werden die LÃ¶sungen
     Zwischenmarken `%t' zugewiesen. Die RÃ¼ckgabe ist in diesem Fall
     eine Liste der Zwischenmarken.

     Hat `globalsolve' den Wert `true', werden den unbekannten Variablen
     eines linearen Gleichungssystems die Werte der LÃ¶sung der
     Funktionen `linsolve' und `solve' zugewiesen.

     Beispiele:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

     Die Symbole `%r' bezeichnen freie Konstanten einer LÃ¶sung.

          (%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

          solve: dependent equations eliminated: (2)
          (%o1)                      [[x = 1 - %r1, y = %r1]]

     Siehe `algsys'  and `%rnum_list'  fÃ¼r mehr Informationen.


 -- Optionsvariable: solvedecomposes
     Standardwert: `true'

     Hat `solvedecomposes' den Wert `true', ruft `solve' die Funktion
     `polydecomp' auf, um Polynome zu lÃ¶sen.


 -- Optionsvariable: solveexplicit
     Standardwert: `false'

     Hat `solveexplicit' den Wert `true', gibt `solve' keine impliziten
     LÃ¶sungen der Form `F(x) = 0' zurÃ¼ck.


 -- Optionsvariable: solvefactors
     Standardwert: `true'

     Hat `solvefactors' den Wert `false', versucht `solve' nicht, den
     Ausdruck zu faktorisieren.


 -- Optionsvariable: solvenullwarn
     Standardwert: `true'

     Hat `solvenullwarn' den Wert `true', gibt `solve' eine Warnmeldung
     aus, wenn keine Gleichungen oder keine Variablen als Argument
     Ã¼bergeben wurden.


 -- Optionsvariable: solveradcan
     Standardwert: `false'

     Hat `solveradcan' den Wert `true', ruft `solve' die Funktion
     `radcan' auf, um AusdrÃ¼cke zu vereinfachen.


 -- Optionsvariable: solvetrigwarn
     Standardwert: `true'

     Hat `solvetrigwarn' den Wert `true', gibt `solve' eine Warnung
     aus, wenn inverse trigonometrische Funktionen genutzt werden, um
     LÃ¶sungen zu finden. In diesem Fall kÃ¶nnen LÃ¶sungen verloren gehen.



File: maxima.info,  Node: Lineare Algebra,  Next: Tensoren,  Prev: Gleichungen,  Up: Top

19 Lineare Algebra
******************

* Menu:

* Introduction to Matrices and Linear Algebra::
* Functions and Variables for Matrices and Linear Algebra::


File: maxima.info,  Node: Introduction to Matrices and Linear Algebra,  Next: Functions and Variables for Matrices and Linear Algebra,  Prev: Lineare Algebra,  Up: Lineare Algebra

19.1 Introduction to Matrices and Linear Algebra
================================================

* Menu:

* Dot::
* Vectors::
* eigen::


File: maxima.info,  Node: Dot,  Next: Vectors,  Prev: Introduction to Matrices and Linear Algebra,  Up: Introduction to Matrices and Linear Algebra

19.1.1 Dot
----------

The operator `.' represents noncommutative multiplication and scalar
product.  When the operands are 1-column or 1-row matrices `a' and `b',
the expression `a.b' is equivalent to `sum (a[i]*b[i], i, 1,
length(a))'.  If `a' and `b' are not complex, this is the scalar
product, also called the inner product or dot product, of `a' and `b'.
The scalar product is defined as `conjugate(a).b' when `a' and `b' are
complex; `innerproduct' in the `eigen' package provides the complex
scalar product.

   When the operands are more general matrices, the product is the
matrix product `a' and `b'.  The number of rows of `b' must equal the
number of columns of `a', and the result has number of rows equal to
the number of rows of `a' and number of columns equal to the number of
columns of `b'.

   To distinguish `.' as an arithmetic operator from the decimal point
in a floating point number, it may be necessary to leave spaces on
either side.  For example, `5.e3' is `5000.0' but `5 . e3' is `5' times
`e3'.

   There are several flags which govern the simplification of
expressions involving `.', namely `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', and `dotscrules'.


File: maxima.info,  Node: Vectors,  Next: eigen,  Prev: Dot,  Up: Introduction to Matrices and Linear Algebra

19.1.2 Vectors
--------------

`vect' is a package of functions for vector analysis.  `load ("vect")'
loads this package, and `demo ("vect")' displays a demonstration.

   The vector analysis package can combine and simplify symbolic
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is governed by
several flags, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.  There
are also functions for deriving the scalar or vector potential of a
field.

   The `vect' package contains these functions: `vectorsimp',
`scalefactors', `express', `potential', and `vectorpotential'.

   Warning: the `vect' package declares the dot operator `.' to be a
commutative operator.


File: maxima.info,  Node: eigen,  Prev: Vectors,  Up: Introduction to Matrices and Linear Algebra

19.1.3 eigen
------------

The package `eigen' contains several functions devoted to the symbolic
computation of eigenvalues and eigenvectors.  Maxima loads the package
automatically if one of the functions `eigenvalues' or `eigenvectors'
is invoked.  The package may be loaded explicitly as `load ("eigen")'.

   `demo ("eigen")' displays a demonstration of the capabilities of
this package.  `batch ("eigen")' executes the same demonstration, but
without the user prompt between successive computations.

   The functions in the `eigen' package are `innerproduct',
`unitvector', `columnvector', `gramschmidt', `eigenvalues',
`eigenvectors', `uniteigenvectors', and `similaritytransform'.


File: maxima.info,  Node: Functions and Variables for Matrices and Linear Algebra,  Prev: Introduction to Matrices and Linear Algebra,  Up: Lineare Algebra

19.2 Functions and Variables for Matrices and Linear Algebra
============================================================

 -- Function: addcol (<M>, <list_1>, ..., <list_n>)
     Appends the column(s) given by the one or more lists (or matrices)
     onto the matrix <M>.


 -- Function: addrow (<M>, <list_1>, ..., <list_n>)
     Appends the row(s) given by the one or more lists (or matrices)
     onto the matrix <M>.


 -- Function: adjoint (<M>)
     Returns the adjoint of the matrix <M>.  The adjoint matrix is the
     transpose of the matrix of cofactors of <M>.


 -- Function: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ...,
          <x_n>])
     Returns the augmented coefficient matrix for the variables <x_1>,
     ..., <x_n> of the system of linear equations <eqn_1>, ...,
     <eqn_m>.  This is the coefficient matrix with a column adjoined for
     the constant terms in each equation (i.e., those terms not
     dependent upon <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Function: charpoly (<M>, <x>)
     Returns the characteristic polynomial for the matrix <M> with
     respect to variable <x>.  That is, `determinant (<M> - diagmatrix
     (length (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Function: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Returns the coefficient matrix for the variables <x_1>, ..., <x_n>
     of the system of linear equations <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Function: col (<M>, <i>)
     Returns the <i>'th column of the matrix <M>.  The return value is
     a matrix.


 -- Function: columnvector (<L>)
 -- Function: covect (<L>)
     Returns a matrix of one column and `length (<L>)' rows, containing
     the elements of the list <L>.

     `covect' is a synonym for `columnvector'.

     `load ("eigen")' loads this function.

     This is useful if you want to use parts of the outputs of the
     functions in this package in matrix calculations.

     Example:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Function: copymatrix (<M>)
     Returns a copy of the matrix <M>.  This is the only way to make a
     copy aside from copying <M> element by element.

     Note that an assignment of one matrix to another, as in `m2: m1',
     does not copy `m1'.  An assignment `m2 [i,j]: x' or `setelmx (x,
     i, j, m2' also modifies `m1 [i,j]'.  Creating a copy with
     `copymatrix' and then using assignment creates a separate,
     modified copy.


 -- Function: determinant (<M>)
     Computes the determinant of <M> by a method similar to Gaussian
     elimination.

     The form of the result depends upon the setting of the switch
     `ratmx'.

     There is a special routine for computing sparse determinants which
     is called when the switches `ratmx' and `sparse' are both `true'.


 -- Option variable: detout
     Default value: `false'

     When `detout' is `true', the determinant of a matrix whose inverse
     is computed is factored out of the inverse.

     For this switch to have an effect `doallmxops' and `doscmxops'
     should be `false' (see their descriptions).  Alternatively this
     switch can be given to `ev' which causes the other two to be set
     correctly.

     Example:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Function: diagmatrix (<n>, <x>)
     Returns a diagonal matrix of size <n> by <n> with the diagonal
     elements all equal to <x>.  `diagmatrix (<n>, 1)' returns an
     identity matrix (same as `ident (<n>)').

     <n> must evaluate to an integer, otherwise `diagmatrix' complains
     with an error message.

     <x> can be any kind of expression, including another matrix.  If
     <x> is a matrix, it is not copied; all diagonal elements refer to
     the same instance, <x>.


 -- Option variable: doallmxops
     Default value: `true'

     When `doallmxops' is `true', all operations relating to matrices
     are carried out.  When it is `false' then the setting of the
     individual `dot' switches govern which operations are performed.


 -- Option variable: domxexpt
     Default value: `true'

     When `domxexpt' is `true', a matrix exponential, `exp (<M>)' where
     <M> is a matrix, is interpreted as a matrix with element `[i,j'
     equal to `exp (m[i,j])'.  Otherwise `exp (<M>)' evaluates to `exp
     (<ev(M)>'.

     `domxexpt' affects all expressions of the form `<base>^<power>'
     where <base> is an expression assumed scalar or constant, and
     <power> is a list or matrix.

     Example:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Option variable: domxmxops
     Default value: `true'

     When `domxmxops' is `true', all matrix-matrix or matrix-list
     operations are carried out (but not scalar-matrix operations); if
     this switch is `false' such operations are not carried out.


 -- Option variable: domxnctimes
     Default value: `false'

     When `domxnctimes' is `true', non-commutative products of matrices
     are carried out.


 -- Option variable: dontfactor
     Default value: `[]'

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (The list is initially empty.)
     Factoring also will not take place with respect to any variables
     which are less important, according the variable ordering assumed
     for canonical rational expression (CRE) form, than those on the
     `dontfactor' list.


 -- Option variable: doscmxops
     Default value: `false'

     When `doscmxops' is `true', scalar-matrix operations are carried
     out.


 -- Option variable: doscmxplus
     Default value: `false'

     When `doscmxplus' is `true', scalar-matrix operations yield a
     matrix result.  This switch is not subsumed under `doallmxops'.


 -- Option variable: dot0nscsimp
     Default value: `true'

     When `dot0nscsimp' is `true', a non-commutative product of zero
     and a nonscalar term is simplified to a commutative product.


 -- Option variable: dot0simp
     Default value: `true'

     When `dot0simp' is `true', a non-commutative product of zero and a
     scalar term is simplified to a commutative product.


 -- Option variable: dot1simp
     Default value: `true'

     When `dot1simp' is `true', a non-commutative product of one and
     another term is simplified to a commutative product.


 -- Option variable: dotassoc
     Default value: `true'

     When `dotassoc' is `true', an expression `(A.B).C' simplifies to
     `A.(B.C)'.


 -- Option variable: dotconstrules
     Default value: `true'

     When `dotconstrules' is `true', a non-commutative product of a
     constant and another term is simplified to a commutative product.
     Turning on this flag effectively turns on `dot0simp',
     `dot0nscsimp', and `dot1simp' as well.


 -- Option variable: dotdistrib
     Default value: `false'

     When `dotdistrib' is `true', an expression `A.(B + C)' simplifies
     to `A.B + A.C'.


 -- Option variable: dotexptsimp
     Default value: `true'

     When `dotexptsimp' is `true', an expression `A.A' simplifies to
     `A^^2'.


 -- Option variable: dotident
     Default value: 1

     `dotident' is the value returned by `X^^0'.


 -- Option variable: dotscrules
     Default value: `false'

     When `dotscrules' is `true', an expression `A.SC' or `SC.A'
     simplifies to `SC*A' and `A.(SC*B)' simplifies to `SC*(A.B)'.


 -- Function: echelon (<M>)
     Returns the echelon form of the matrix <M>, as produced by
     Gaussian elimination.  The echelon form is computed from <M> by
     elementary row operations such that the first non-zero element in
     each row in the resulting matrix is one and the column elements
     under the first one in each row are all zero.

     `triangularize' also carries out Gaussian elimination, but it does
     not normalize the leading non-zero element in each row.

     `lu_factor' and `cholesky' are other functions which yield
     triangularized matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Function: eigenvalues (<M>)
 -- Function: eivals (<M>)
     Returns a list of two lists containing the eigenvalues of the
     matrix <M>.  The first sublist of the return value is the list of
     eigenvalues of the matrix, and the second sublist is the list of
     the multiplicities of the eigenvalues in the corresponding order.

     `eivals' is a synonym for `eigenvalues'.

     `eigenvalues' calls the function `solve' to find the roots of the
     characteristic polynomial of the matrix.  Sometimes `solve' may
     not be able to find the roots of the polynomial; in that case some
     other functions in this package (except `innerproduct',
     `unitvector', `columnvector' and `gramschmidt') will not work.

     In some cases the eigenvalues found by `solve' may be complicated
     expressions.  (This may happen when `solve' returns a
     not-so-obviously real expression for an eigenvalue which is known
     to be real.)  It may be possible to simplify the eigenvalues using
     some other functions.

     The package `eigen.mac' is loaded automatically when `eigenvalues'
     or `eigenvectors' is referenced.  If `eigen.mac' is not already
     loaded, `load ("eigen")' loads it.  After loading, all functions
     and variables in the package are available.


 -- Function: eigenvectors (<M>)
 -- Function: eivects (<M>)
     Computes eigenvectors of the matrix <M>.  The return value is a
     list of two elements.  The first is a list of the eigenvalues of
     <M> and a list of the multiplicities of the eigenvalues.  The
     second is a list of lists of eigenvectors.  There is one list of
     eigenvectors for each eigenvalue.  There may be one or more
     eigenvectors in each list.

     `eivects' is a synonym for `eigenvectors'.

     The package `eigen.mac' is loaded automatically when `eigenvalues'
     or `eigenvectors' is referenced.  If `eigen.mac' is not already
     loaded, `load ("eigen")' loads it.  After loading, all functions
     and variables in the package are available.

     The flags that affect this function are:

     `nondiagonalizable' is set to `true' or `false' depending on
     whether the matrix is nondiagonalizable or diagonalizable after
     `eigenvectors' returns.

     `hermitianmatrix' when `true', causes the degenerate eigenvectors
     of the Hermitian matrix to be orthogonalized using the
     Gram-Schmidt algorithm.

     `knowneigvals' when `true' causes the `eigen' package to assume the
     eigenvalues of the matrix are known to the user and stored under
     the global name `listeigvals'.  `listeigvals' should be set to a
     list similar to the output `eigenvalues'.

     The function `algsys' is used here to solve for the eigenvectors.
     Sometimes if the eigenvalues are messy, `algsys' may not be able
     to find a solution.  In some cases, it may be possible to simplify
     the eigenvalues by first finding them using `eigenvalues' command
     and then using other functions to reduce them to something simpler.
     Following simplification, `eigenvectors' can be called again with
     the `knowneigvals' flag set to `true'.

     See also `eigenvalues'.

     Examples:

     A matrix which has just one eigenvector per eigenvalue.

          (%i1) M1 : matrix ([11, -1], [1, 7]);
                                     [ 11  - 1 ]
          (%o1)                      [         ]
                                     [ 1    7  ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]],
                                  [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                 val  = 9 - sqrt(3)
                                    1

                                      mult  = 1
                                          1

                              vec  = [[1, sqrt(3) + 2]]
                                 1

                                 val  = sqrt(3) + 9
                                    2

                                      mult  = 1
                                          2

                              vec  = [[1, 2 - sqrt(3)]]
                                 2

          (%o3)                         done

     A matrix which has two eigenvectors for one eigenvalue (namely 2).

          (%i1) M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]);
                                   [ 0  1  0  0 ]
                                   [            ]
                                   [ 0  0  0  0 ]
          (%o1)                    [            ]
                                   [ 0  0  2  0 ]
                                   [            ]
                                   [ 0  0  0  2 ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                             [[0, 0, 1, 0], [0, 0, 0, 1]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                      val  = 0
                                         1

                                      mult  = 2
                                          1

                                vec  = [[1, 0, 0, 0]]
                                   1

                                      val  = 2
                                         2

                                      mult  = 2
                                          2

                         vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                            2

          (%o3)                         done


 -- Function: ematrix (<m>, <n>, <x>, <i>, <j>)
     Returns an <m> by <n> matrix, all elements of which are zero
     except for the `[<i>, <j>]' element which is <x>.


 -- Function: entermatrix (<m>, <n>)
     Returns an <m> by <n> matrix, reading the elements interactively.

     If <n> is equal to <m>, Maxima prompts for the type of the matrix
     (diagonal, symmetric, antisymmetric, or general) and for each
     element.  Each response is terminated by a semicolon `;' or dollar
     sign `$'.

     If <n> is not equal to <m>, Maxima prompts for each element.

     The elements may be any expressions, which are evaluated.
     `entermatrix' evaluates its arguments.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
          4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Funktion: express (<expr>)
     Expands differential operator nouns into expressions in terms of
     partial derivatives. `express' recognizes the operators `grad',
     `div', `curl', `laplacian'. `express' also expands the cross
     product `~'.

     Symbolic derivatives (that is, `diff' nouns) in the return value
     of express may be evaluated by including `diff' in the `ev'
     function call or command line. In this context, `diff' acts as an
     `evfun'.

     `load ("vect")' loads this function.

     Beispiele:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Function: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Function: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Function: genmatrix (<a>, <i_2>, <j_2>)
     Returns a matrix generated from <a>, taking element
     `<a>[<i_1>,<j_1>]' as the upper-left element and `<a>[<i_2>,<j_2>]'
     as the lower-right element of the matrix.  Here <a> is a declared
     array (created by `array' but not by `make_array') or an
     undeclared array, or an array function, or a lambda expression of
     two arguments.  (An array function is created like other functions
     with `:=' or `define', but arguments are enclosed in square
     brackets instead of parentheses.)

     If <j_1> is omitted, it is assumed equal to <i_1>.  If both <j_1>
     and <i_1> are omitted, both are assumed equal to 1.

     If a selected element `i,j' of the array is undefined, the matrix
     will contain a symbolic element `<a>[i,j]'.

     Examples:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Function: gramschmidt (<x>)
 -- Function: gramschmidt (<x>, <F>)
     Carries out the Gram-Schmidt orthogonalization algorithm on <x>,
     which is either a matrix or a list of lists.  <x> is not modified
     by `gramschmidt'.  The inner product employed by `gramschmidt' is
     <F>, if present, otherwise the inner product is the function
     `innerproduct'.

     If <x> is a matrix, the algorithm is applied to the rows of <x>.
     If <x> is a list of lists, the algorithm is applied to the
     sublists, which must have equal numbers of elements.  In either
     case, the return value is a list of lists, the sublists of which
     are orthogonal and span the same space as <x>.  If the dimension
     of the span of <x> is less than the number of rows or sublists,
     some sublists of the return value are zero.

     `factor' is called at each stage of the algorithm to simplify
     intermediate results.  As a consequence, the return value may
     contain factored integers.

     `load(eigen)' loads this function.

     Example:

     Gram-Schmidt algorithm using default inner product function.

          (%i1) load (eigen)$
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
          (%o4)                       [0, 0, 0]

     Gram-Schmidt algorithm using a specified inner product function.

          (%i1) load (eigen)$
          (%i2) ip (f, g) := integrate (f * g, u, a, b);
          (%o2)          ip(f, g) := integrate(f g, u, a, b)
          (%i3) y : gramschmidt ([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
                                         %pi cos(u) - 2
          (%o3)              [1, sin(u), --------------]
                                              %pi
          (%i4) map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]), a= -%pi/2, b=%pi/2;
          (%o4)                       [0, 0, 0]


 -- Function: ident (<n>)
     Returns an <n> by <n> identity matrix.


 -- Function: innerproduct (<x>, <y>)
 -- Function: inprod (<x>, <y>)
     Returns the inner product (also called the scalar product or dot
     product) of <x> and <y>, which are lists of equal length, or both
     1-column or 1-row matrices of equal length.  The return value is
     `conjugate (x) . y', where `.' is the noncommutative
     multiplication operator.

     `load ("eigen")' loads this function.

     `inprod' is a synonym for `innerproduct'.


 -- Function: invert (<M>)
     Returns the inverse of the matrix <M>.  The inverse is computed by
     the adjoint method.

     This allows a user to compute the inverse of a matrix with bfloat
     entries or polynomials with floating pt. coefficients without
     converting to cre-form.

     Cofactors are computed by the `determinant' function, so if
     `ratmx' is `false' the inverse is computed without changing the
     representation of the elements.

     The current implementation is inefficient for matrices of high
     order.

     When `detout' is `true', the determinant is factored out of the
     inverse.

     The elements of the inverse are not automatically expanded.  If
     <M> has polynomial elements, better appearing output can be
     generated by `expand (invert (m)), detout'.  If it is desirable to
     then divide through by the determinant this can be accomplished by
     `xthru (%)' or alternatively from scratch by

          expand (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     See `^^' (noncommutative exponent) for another method of inverting
     a matrix.


 -- Optionsvariable: lmxchar
     Standardwert: `['

     `lmxchar' ist das Zeichen, das fÃ¼r die linke Seite einer Matrix
     ausgegeben wird. Siehe auch `rmxchar'.

     Beispiel:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Function: matrix (<row_1>, ..., <row_n>)
     Returns a rectangular matrix which has the rows <row_1>, ...,
     <row_n>.  Each row is a list of expressions.  All rows must be the
     same length.

     The operations `+' (addition), `-' (subtraction), `*'
     (multiplication), and `/' (division), are carried out element by
     element when the operands are two matrices, a scalar and a matrix,
     or a matrix and a scalar.  The operation `^' (exponentiation,
     equivalently `**') is carried out element by element if the
     operands are a scalar and a matrix or a matrix and a scalar, but
     not if the operands are two matrices.  All operations are normally
     carried out in full, including `.' (noncommutative multiplication).

     Matrix multiplication is represented by the noncommutative
     multiplication operator `.'.  The corresponding noncommutative
     exponentiation operator is `^^'.  For a matrix `<A>', `<A>.<A> =
     <A>^^2' and `<A>^^-1' is the inverse of <A>, if it exists.

     There are switches for controlling simplification of expressions
     involving dot and matrix-list operations.  These are `doallmxops',
     `domxexpt' `domxmxops', `doscmxops', and `doscmxplus'.

     There are additional options which are related to matrices. These
     are: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', and `sparse'.

     There are a number of functions which take matrices as arguments
     or yield matrices as return values.  See `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', and `rank'.

     Examples:

        * Construction of matrices from lists.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Addition, element by element.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtraction, element by element.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplication, element by element.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Division, element by element.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matrix to a scalar exponent, element by element.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Scalar base to a matrix exponent, element by element.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Matrix base to a matrix exponent. This is not carried out
          element by element.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Noncommutative matrix multiplication.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Noncommutative matrix exponentiation.  A scalar base <b> to a
          matrix power <M> is carried out element by element and so
          `b^^m' is the same as `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matrix raised to a -1 exponent with noncommutative
          exponentiation is the matrix inverse, if it exists.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Function: matrixmap (<f>, <M>)
     Returns a matrix with element `i,j' equal to `<f>(<M>[i,j])'.

     See also `map', `fullmap', `fullmapl', and `apply'.


 -- Function: matrixp (<expr>)
     Returns `true' if <expr> is a matrix, otherwise `false'.


 -- Option variable: matrix_element_add
     Default value: `+'

     `matrix_element_add' is the operation invoked in place of addition
     in a matrix multiplication.  `matrix_element_add' can be assigned
     any n-ary operator (that is, a function which handles any number
     of arguments).  The assigned value may be the name of an operator
     enclosed in quote marks, the name of a function, or a lambda
     expression.

     See also `matrix_element_mult' and `matrix_element_transpose'.

     Example:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Option variable: matrix_element_mult
     Default value: `*'

     `matrix_element_mult' is the operation invoked in place of
     multiplication in a matrix multiplication.  `matrix_element_mult'
     can be assigned any binary operator.  The assigned value may be
     the name of an operator enclosed in quote marks, the name of a
     function, or a lambda expression.

     The dot operator `.' is a useful choice in some contexts.

     See also `matrix_element_add' and `matrix_element_transpose'.

     Example:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Option variable: matrix_element_transpose
     Default value: `false'

     `matrix_element_transpose' is the operation applied to each
     element of a matrix when it is transposed.  `matrix_element_mult'
     can be assigned any unary operator.  The assigned value may be the
     name of an operator enclosed in quote marks, the name of a
     function, or a lambda expression.

     When `matrix_element_transpose' equals `transpose', the
     `transpose' function is applied to every element.  When
     `matrix_element_transpose' equals `nonscalars', the `transpose'
     function is applied to every nonscalar element.  If some element
     is an atom, the `nonscalars' option applies `transpose' only if
     the atom is declared nonscalar, while the `transpose' option
     always applies `transpose'.

     The default value, `false', means no operation is applied.

     See also `matrix_element_add' and `matrix_element_mult'.

     Examples:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x)
                - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Function: mattrace (<M>)
     Returns the trace (that is, the sum of the elements on the main
     diagonal) of the square matrix <M>.

     `mattrace' is called by `ncharpoly', an alternative to Maxima's
     `charpoly'.

     `load ("nchrpl")' loads this function.


 -- Function: minor (<M>, <i>, <j>)
     Returns the <i>, <j> minor of the matrix <M>.  That is, <M> with
     row <i> and column <j> removed.


 -- Function: ncexpt (<a>, <b>)
     If a non-commutative exponential expression is too wide to be
     displayed as `<a>^^<b>' it appears as `ncexpt (<a>,<b>)'.

     `ncexpt' is not the name of a function or operator; the name only
     appears in output, and is not recognized in input.


 -- Function: ncharpoly (<M>, <x>)
     Returns the characteristic polynomial of the matrix <M> with
     respect to <x>.  This is an alternative to Maxima's `charpoly'.

     `ncharpoly' works by computing traces of powers of the given
     matrix, which are known to be equal to sums of powers of the roots
     of the characteristic polynomial.  From these quantities the
     symmetric functions of the roots can be calculated, which are
     nothing more than the coefficients of the characteristic
     polynomial.  `charpoly' works by forming the determinant of `<x> *
     ident [n] - a'.  Thus `ncharpoly' wins, for example, in the case
     of large dense matrices filled with integers, since it avoids
     polynomial arithmetic altogether.

     `load ("nchrpl")' loads this file.


 -- Function: newdet (<M>, <n>)
     Computes the determinant of the matrix or array <M> by the
     Johnson-Gentleman tree minor algorithm.  The argument <n> is the
     order; it is optional if <M> is a matrix.


 -- Function: permanent (<M>, <n>)
     Computes the permanent of the matrix <M>.  A permanent is like a
     determinant but with no sign changes.


 -- Function: rank (<M>)
     Computes the rank of the matrix <M>.  That is, the order of the
     largest non-singular subdeterminant of <M>.

     <rank> may return the wrong answer if it cannot determine that a
     matrix element that is equivalent to zero is indeed so.


 -- Function: potential (<givengradient>)
     The calculation makes use of the global variable
     `potentialzeroloc[0]' which must be `nonlist' or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]

     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides
     are used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     `potentialzeroloc' is initially set to 0.


 -- Option variable: ratmx
     Default value: `false'

     When `ratmx' is `false', determinant and matrix addition,
     subtraction, and multiplication are performed in the
     representation of the matrix elements and cause the result of
     matrix inversion to be left in general representation.

     When `ratmx' is `true', the 4 operations mentioned above are
     performed in CRE form and the result of matrix inverse is in CRE
     form.  Note that this may cause the elements to be expanded
     (depending on the setting of `ratfac') which might not always be
     desired.


 -- Optionsvariable: rmxchar
     Standardwert: `]'

     `rmxchar' ist das Zeichen, das fÃ¼r die rechte Seite einer Matrix
     ausgegeben wird. Siehe auch `lmxchar'.


 -- Function: row (<M>, <i>)
     Returns the <i>'th row of the matrix <M>.  The return value is a
     matrix.


 -- Option variable: scalarmatrixp
     Default value: `true'

     When `scalarmatrixp' is `true', then whenever a 1 x 1 matrix is
     produced as a result of computing the dot product of matrices it
     is simplified to a scalar, namely the sole element of the matrix.

     When `scalarmatrixp' is `all', then all 1 x 1 matrices are
     simplified to scalars.

     When `scalarmatrixp' is `false', 1 x 1 matrices are not simplified
     to scalars.


 -- Function: scalefactors (<coordinatetransform>)
     Here coordinatetransform evaluates to the form [[expression1,
     expression2, ...], indeterminate1, indeterminat2, ...], where
     indeterminate1, indeterminate2, etc. are the curvilinear
     coordinate variables and where a set of rectangular Cartesian
     components is given in terms of the curvilinear coordinates by
     [expression1, expression2, ...].  `coordinates' is set to the
     vector [indeterminate1, indeterminate2,...], and `dimension' is
     set to the length of this vector.  SF[1], SF[2], ...,
     SF[DIMENSION] are set to the coordinate scale factors, and `sfprod'
     is set to the product of these scale factors.  Initially,
     `coordinates' is [X, Y, Z], `dimension' is 3, and
     SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 3-dimensional
     rectangular Cartesian coordinates.  To expand an expression into
     physical components in the current coordinate system, there is a
     function with usage of the form


 -- Function: setelmx (<x>, <i>, <j>, <M>)
     Assigns <x> to the (<i>, <j>)'th element of the matrix <M>, and
     returns the altered matrix.

     `<M> [<i>, <j>]: <x>' has the same effect, but returns <x> instead
     of <M>.


 -- Function: similaritytransform (<M>)
 -- Function: simtran (<M>)
     `similaritytransform' computes a similarity transform of the
     matrix `M'.  It returns a list which is the output of the
     `uniteigenvectors' command.  In addition if the flag
     `nondiagonalizable' is `false' two global matrices `leftmatrix'
     and `rightmatrix' are computed.  These matrices have the property
     that `leftmatrix . <M> . rightmatrix' is a diagonal matrix with
     the eigenvalues of <M> on the diagonal.  If `nondiagonalizable' is
     `true' the left and right matrices are not computed.

     If the flag `hermitianmatrix' is `true' then `leftmatrix' is the
     complex conjugate of the transpose of `rightmatrix'.  Otherwise
     `leftmatrix' is the inverse of `rightmatrix'.

     `rightmatrix' is the matrix the columns of which are the unit
     eigenvectors of <M>.  The other flags (see `eigenvalues' and
     `eigenvectors') have the same effects since `similaritytransform'
     calls the other functions in the package in order to be able to
     form `rightmatrix'.

     `load ("eigen")' loads this function.

     `simtran' is a synonym for `similaritytransform'.


 -- Option variable: sparse
     Default value: `false'

     When `sparse' is `true', and if `ratmx' is `true', then
     `determinant' will use special routines for computing sparse
     determinants.


 -- Function: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Function: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Function: submatrix (<M>, <j_1>, ..., <j_n>)
     Returns a new matrix composed of the matrix <M> with rows <i_1>,
     ..., <i_m> deleted, and columns <j_1>, ..., <j_n> deleted.


 -- Function: transpose (<M>)
     Returns the transpose of <M>.

     If <M> is a matrix, the return value is another matrix <N> such
     that `N[i,j] = M[j,i]'.

     If <M> is a list, the return value is a matrix <N> of `length (m)'
     rows and 1 column, such that `N[i,1] = M[i]'.

     Otherwise <M> is a symbol, and the return value is a noun
     expression `'transpose (<M>)'.


 -- Function: triangularize (<M>)
     Returns the upper triangular form of the matrix `M', as produced
     by Gaussian elimination.  The return value is the same as
     `echelon', except that the leading nonzero coefficient in each row
     is not normalized to 1.

     `lu_factor' and `cholesky' are other functions which yield
     triangularized matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Function: uniteigenvectors (<M>)
 -- Function: ueivects (<M>)
     Computes unit eigenvectors of the matrix <M>.  The return value is
     a list of lists, the first sublist of which is the output of the
     `eigenvalues' command, and the other sublists of which are the
     unit eigenvectors of the matrix corresponding to those eigenvalues
     respectively.

     The flags mentioned in the description of the `eigenvectors'
     command have the same effects in this one as well.

     When `knowneigvects' is `true', the `eigen' package assumes that
     the eigenvectors of the matrix are known to the user and are
     stored under the global name `listeigvects'.  `listeigvects'
     should be set to a list similar to the output of the
     `eigenvectors' command.

     If `knowneigvects' is set to `true' and the list of eigenvectors
     is given the setting of the flag `nondiagonalizable' may not be
     correct.  If that is the case please set it to the correct value.
     The author assumes that the user knows what he is doing and will
     not try to diagonalize a matrix the eigenvectors of which do not
     span the vector space of the appropriate dimension.

     `load ("eigen")' loads this function.

     `ueivects' is a synonym for `uniteigenvectors'.


 -- Function: unitvector (<x>)
 -- Function: uvect (<x>)
     Returns <x>/norm(<x>); this is a unit vector in the same direction
     as <x>.

     `load ("eigen")' loads this function.

     `uvect' is a synonym for `unitvector'.


 -- Function: vectorpotential (<givencurl>)
     Returns the vector potential of a given curl vector, in the current
     coordinate system. `potentialzeroloc' has a similar role as for
     `potential', but the order of the left-hand sides of the equations
     must be a cyclic permutation of the coordinate variables.


 -- Function: vectorsimp (<expr>)
     Applies simplifications and expansions according to the following
     global flags:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', and
     `expandlaplacianprod'.

     All these flags have default value `false'. The `plus' suffix
     refers to employing additivity or distributivity.  The `prod'
     suffix refers to the expansion for an operand that is any kind of
     product.

    `expandcrosscross'
          Simplifies p ~ (q ~ r) to (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifies curl curl p to grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifies laplacian p to div grad p.

    `expandcross'
          Enables `expandcrossplus' and `expandcrosscross'.

    `expandplus'
          Enables `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', and `expandlaplacianplus'.

    `expandprod'
          Enables `expandgradprod', `expanddivprod', and
          `expandlaplacianprod'.

     These flags have all been declared `evflag'.


 -- Option variable: vect_cross
     Default value: `false'

     When `vect_cross' is `true', it allows DIFF(X~Y,T) to work where ~
     is defined in SHARE;VECT (where VECT_CROSS is set to `true',
     anyway.)


 -- Function: zeromatrix (<m>, <n>)
     Returns an <m> by <n> matrix, all elements of which are zero.


 -- Special symbol: [
 -- Special symbol: ]
     `[' and `]' mark the beginning and end, respectively, of a list.

     `[' and `]' also enclose the subscripts of a list, array, hash
     array, or array function.

     Examples:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Tensoren,  Next: Spezielle Funktionen,  Prev: Lineare Algebra,  Up: Top

20 Tensoren
***********

* Menu:

* Introduction to itensor::
* Functions and Variables for itensor::
* Introduction to ctensor::
* Functions and Variables for ctensor::
* Introduction to atensor::
* Functions and Variables for atensor::


File: maxima.info,  Node: Introduction to itensor,  Next: Functions and Variables for itensor,  Prev: Tensoren,  Up: Tensoren

20.1 Introduction to itensor
============================

Maxima implements symbolic tensor manipulation of two distinct types:
component tensor manipulation (`ctensor' package) and indicial tensor
manipulation (`itensor' package).

   Nota bene: Please see the note on 'new tensor notation' below.

   Component tensor manipulation means that geometrical tensor objects
are represented as arrays or matrices. Tensor operations such as
contraction or covariant differentiation are carried out by actually
summing over repeated (dummy) indices with `do' statements.  That is,
one explicitly performs operations on the appropriate tensor components
stored in an array or matrix.

   Indicial tensor manipulation is implemented by representing tensors
as functions of their covariant, contravariant and derivative indices.
Tensor operations such as contraction or covariant differentiation are
performed by manipulating the indices themselves rather than the
components to which they correspond.

   These two approaches to the treatment of differential, algebraic and
analytic processes in the context of Riemannian geometry have various
advantages and disadvantages which reveal themselves only through the
particular nature and difficulty of the user's problem.  However, one
should keep in mind the following characteristics of the two
implementations:

   The representation of tensors and tensor operations explicitly in
terms of their components makes `ctensor' easy to use. Specification of
the metric and the computation of the induced tensors and invariants is
straightforward. Although all of Maxima's powerful simplification
capacity is at hand, a complex metric with intricate functional and
coordinate dependencies can easily lead to expressions whose size is
excessive and whose structure is hidden. In addition, many calculations
involve intermediate expressions which swell causing programs to
terminate before completion. Through experience, a user can avoid many
of these difficulties.

   Because of the special way in which tensors and tensor operations
are represented in terms of symbolic operations on their indices,
expressions which in the component representation would be unmanageable
can sometimes be greatly simplified by using the special routines for
symmetrical objects in `itensor'. In this way the structure of a large
expression may be more transparent. On the other hand, because of the
the special indicial representation in `itensor', in some cases the
user may find difficulty with the specification of the metric, function
definition, and the evaluation of differentiated "indexed" objects.

   The `itensor' package can carry out differentiation with respect to
an indexed variable, which allows one to use the package when dealing
with Lagrangian and Hamiltonian formalisms. As it is possible to
differentiate a field Lagrangian with respect to an (indexed) field
variable, one can use Maxima to derive the corresponding Euler-Lagrange
equations in indicial form. These equations can be translated into
component tensor (`ctensor') programs using the `ic_convert' function,
allowing us to solve the field equations in a particular coordinate
representation, or to recast the equations of motion in Hamiltonian
form. See `einhil.dem' and `bradic.dem' for two comprehensive examples.
The first, `einhil.dem', uses the Einstein-Hilbert action to derive the
Einstein field tensor in the homogeneous and isotropic case (Friedmann
equations) and the spherically symmetric, static case (Schwarzschild
solution.) The second, `bradic.dem', demonstrates how to compute the
Friedmann equations from the action of Brans-Dicke gravity theory, and
also derives the Hamiltonian associated with the theory's scalar field.

20.1.1 New tensor notation
--------------------------

Earlier versions of the `itensor' package in Maxima used a notation
that sometimes led to incorrect index ordering. Consider the following,
for instance:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   This result is incorrect unless `a' happens to be a symmetric tensor.
The reason why this happens is that although `itensor' correctly
maintains the order within the set of covariant and contravariant
indices, once an index is raised or lowered, its position relative to
the other set of indices is lost.

   To avoid this problem, a new notation has been developed that
remains fully compatible with the existing notation and can be used
interchangeably. In this notation, contravariant indices are inserted
in the appropriate positions in the covariant index list, but with a
minus sign prepended.  Functions like `contract' and `ishow' are now
aware of this new index notation and can process tensors appropriately.

   In this new notation, the previous example yields a correct result:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presently, the only code that makes use of this notation is the
`lc2kdt' function. Through this notation, it achieves consistent
results as it applies the metric tensor to resolve Levi-Civita symbols
without resorting to numeric indices.

   Since this code is brand new, it probably contains bugs. While it
has been tested to make sure that it doesn't break anything using the
"old" tensor notation, there is a considerable chance that "new"
tensors will fail to interoperate with certain functions or features.
These bugs will be fixed as they are encountered... until then, caveat
emptor!

20.1.2 Indicial tensor manipulation
-----------------------------------

The indicial tensor manipulation package may be loaded by
`load(itensor)'. Demos are also available: try `demo(tensor)'.

   In `itensor' a tensor is represented as an "indexed object" .  This
is a function of 3 groups of indices which represent the covariant,
contravariant and derivative indices.  The covariant indices are
specified by a list as the first argument to the indexed object, and
the contravariant indices by a list as the second argument. If the
indexed object lacks either of these groups of indices then the empty
list `[]' is given as the corresponding argument.  Thus, `g([a,b],[c])'
represents an indexed object called `g' which has two covariant indices
`(a,b)', one contravariant index (`c') and no derivative indices.

   The derivative indices, if they are present, are appended as
additional arguments to the symbolic function representing the tensor.
They can be explicitly specified by the user or be created in the
process of differentiation with respect to some coordinate variable.
Since ordinary differentiation is commutative, the derivative indices
are sorted alphanumerically, unless `iframe_flag' is set to `true',
indicating that a frame metric is being used. This canonical ordering
makes it possible for Maxima to recognize that, for example,
`t([a],[b],i,j)' is the same as `t([a],[b],j,i)'.  Differentiation of
an indexed object with respect to some coordinate whose index does not
appear as an argument to the indexed object would normally yield zero.
This is because Maxima would not know that the tensor represented by
the indexed object might depend implicitly on the corresponding
coordinate.  By modifying the existing Maxima function `diff' in
`itensor', Maxima now assumes that all indexed objects depend on any
variable of differentiation unless otherwise stated.  This makes it
possible for the summation convention to be extended to derivative
indices. It should be noted that `itensor' does not possess the
capabilities of raising derivative indices, and so they are always
treated as covariant.

   The following functions are available in the tensor package for
manipulating indexed objects.  At present, with respect to the
simplification routines, it is assumed that indexed objects do not by
default possess symmetry properties. This can be overridden by setting
the variable `allsym[false]' to `true', which will result in treating
all indexed objects completely symmetric in their lists of covariant
indices and symmetric in their lists of contravariant indices.

   The `itensor' package generally treats tensors as opaque objects.
Tensorial equations are manipulated based on algebraic rules,
specifically symmetry and contraction rules. In addition, the `itensor'
package understands covariant differentiation, curvature, and torsion.
Calculations can be performed relative to a metric of moving frame,
depending on the setting of the `iframe_flag' variable.

   A sample session below demonstrates how to load the `itensor'
package, specify the name of the metric, and perform some simple
calculations.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                     %4 %5
     (%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
             i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                              + e p       + e   p    ))/2
                                                   i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %7                    %6 %7
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %7 i             %6    i j %7      i,j

                                                  %6 %7
                                             - ifg      v   ifb      )/2
                                                         %6    %7 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0



Local Variables:
coding: utf-8
End:
