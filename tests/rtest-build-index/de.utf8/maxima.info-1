This is maxima.info, produced by makeinfo version 4.13 from
/home/work/maxima/sandbox/maxima/doc/info/de.utf8//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: EinfÃ¼hrung in Maxima,  Prev: (dir),  Up: (dir)

Maxima Manual
*************

Maxima ist ein Computer Algebra System, das in Lisp programmiert ist.

   Maxima basiert auf Macsyma, das am MIT (Massachusetts Institute of
Technology) in den Jahren 1968 bis 1982 als Teil des Projektes MAC
entwickelt wurde. Das Department of Energy (DOE) erhielt im Jahr 1982
den Quellcode vom MIT; diese Version ist als DOE Macsyma bekannt.
Professor William F. Schelter von der University of Texas hat von 1982
bis zu seinem Tod im Jahr 2001 eine Kopie von DOE Macsyma gepflegt. Im
Jahr 1998 erhielt Schelter vom Department of Energy die Erlaubnis, den
Quellcode von DOE Macsyma unter der GNU Public Lizenz zu
verÃ¶ffentlichen. Im Jahr 2000 initiierte Schelter das Maxima Projekt bei
SourceForge, um DOE Macsyma, heute Maxima genannt, weiter zu entwickeln.


   Dieses Dokument ist eine Ãbersetzung des englischen Maxima Manuals in
die deutsche Sprache. Das Manual ist noch nicht vollstÃ¤ndig Ã¼bersetzt.
Damit keine Inhalte fehlen, sind die nicht Ã¼bersetzten Teile in der
englischen Sprache eingefÃ¼gt. Bis auf wenige Ausnahmen sind die Kapitel
1 bis 13 vollstÃ¤ndig und Teile der Kapitel 15, 16 und 18 Ã¼bersetzt.

   Dieses Manual ist nicht nur eine Ãbersetzung, sondern auch der
Versuch, die Inhalte neu zu organisieren und zu Ã¼berarbeiten. Ziel ist
ein besser lesbares und Ã¼bersichtlicheres Manual zu erhalten. Diese
Arbeit soll auch in das englische Original einflieÃen.

   Die Arbeit an dem Manual ist noch nicht abgeschlossen. Die jeweils
aktuelle Version ist unter
`http://crategus.users.sourceforge.net/maxima.html' verfÃ¼gbar.

   Dr. Dieter Kaiser, 28.11.2010


* Menu:


Maxima Grundlagen

* EinfÃ¼hrung in Maxima::      Erste Beispiele mit Maxima.
* Programmfehler::              Programmfehler finden und berichten.
* Hilfe::                       Hilfe in einer Maxima-Sitzung erhalten.
* Kommandozeile::               Syntax der Kommandozeile.
* Datentypen und -strukturen::  Ganze, rationale und Gleitkommazahlen, Konstante,
                                Zeichenketten, Arrays, Listen ...
* AusdrÃ¼cke::                 AusdrÃ¼cke in Maxima.
* Operatoren::                  Operatoren in Maxima.
* Auswertung::                  Auswertung von AusdrÃ¼cken.
* Vereinfachung::               Vereinfachung von AusdrÃ¼cken.
* Mathematische Funktionen::    Mathematische Funktionen in Maxima.
* Maximas Datenbank::           Deklarationen, Kontexte, Fakten, Eigenschaften.
* Grafische Darstellung::       2D and 3D grafische Ausgabe.
* Eingabe und Ausgabe::         Lesen und schreiben von Dateien mit Maxima.


Spezifische Gebiete der Mathematik

* Mengen::                      Mengen.
* Summen Produkte und Reihen::  Summen, Produkte, Tayolorreihen, Poisson Reihen.
* Analysis::                    Grenzwerte, Differentiation, Integration,
                                Differentialgleichungen.
* Polynome::                    Standard forms for polynomials, and
                                functions operating on them.
* Gleichungen::                 LÃ¶sen von Gleichungen.
* Lineare Algebra::             Matrizen und Vektoren.
* Tensoren::                    Methoden der Tensorrechnung.
* Spezielle Funktionen::        Spezielle Mathematische Funktionen.
* Fouriertransformationen::     Fouriertransformationen und -reihen.


Fortgeschrittene MÃ¶glichkeiten und Programmierung

* Regeln und Muster::           User defined pattern matching and
                                simplification rules.
* Funktionsdefinitionen::       Defining functions.
* Laufzeitumgebung::            Customization of the Maxima environment.
* Programmierung::              Defining Maxima programs.
* Fehlersuche::                 Fehlersuche in Programmen.
* Verschiedene Optionen::       Options with a global effect on Maxima.


ZusÃ¤tzliche Packete

* affine::
* asympa::                      Asymptotic analysis package
* augmented_lagrangian::        augmented_lagrangian package.
* bode::                        Bode gain and phase plots.
* cobyla::                      Nonlinear optimization with inequality
                                constraints.
* contrib_ode::                 Additional routines for ODEs
* Package descriptive::         Descriptive statistics.
* diag::                        Jordan matrices.
* Package distrib::             Probability distributions.
* draw::                        A Maxima-Gnuplot interface.
* drawdf::                      Direction fields with Gnuplot.
* dynamics::                    Graphics for dynamical systems and fractals.
* ezunits::                     Dimensional quantities.
* f90::                         Maxima to fortran translator.
* ggf::                         Generating function of sequences.
* graphs::                      Graph theory package.
* grobner::                     Functions for working with Groebner bases.
* groups::                      Abstract algebra.
* impdiff::                     Implicit derivatives.
* interpol::                    Interpolation package.
* lapack::                      LAPACK functions for linear algebra.
* lbfgs::                       L-BFGS unconstrained minimization package.
* lindstedt::                   Lindstedt package.
* linearalgebra::               Functions for linear algebra.
* lsquares::                    Least squares.
* makeOrders::                  Polynomial utility.
* minpack::                     MINPACK functions for minimization and roots
* mnewton::                     Newton's method.
* numericalio::                 Reading and writing files.
* opsubst::                     Substitutions utility.
* orthopoly::                   Orthogonal polynomials.
* plotdf::                      Direction fields plots.
* romberg::                     Romberg method for numerical integration.
* simplex::                     Linear programming.
* simplification::              Simplification rules and functions.
* solve_rec::                   Linear recurrences.
* stats::                       Statistical inference package.
* stirling::                    Stirling formula.
* stringproc::                  String processing.
* symmetries::
* unit::                        Units and dimensions package.
* zeilberger::                  Functions for hypergeometric summation.


Glossar
* Glossar::                     ErlÃ¤uterung von Begriffen.


Index
* Index der Variablen und Funktionen::

AusfÃ¼hrliches Inhaltsverzeichnis

EinfÃ¼hrung
* EinfÃ¼hrung in Maxima::

Programmfehler
* EinfÃ¼hrung in Programmfehler::
* Funktionen und Variablen fÃ¼r Programmfehler::

Hilfe
* Dokumentation::
* Funktionen und Variablen der Hilfe::

Kommandozeile
* EinfÃ¼hrung in die Kommandozeile::
* Funktionen und Variablen der Eingabe::
* Funktionen und Variablen der Ausgabe::

Datentypen und -strukturen
* EinfÃ¼hrung in Maxima Zahlen::
* Zeichenketten::
* Funktionen und Variablen fÃ¼r Zahlen::
* Funktionen und Variablen fÃ¼r Zeichenketten::
* Funktionen und Variablen fÃ¼r Konstante::
* Funktionen und Variablen fÃ¼r Arrays::
* EinfÃ¼hrung in Listen::
* Funktionen und Variablen fÃ¼r Listen::

AusdrÃ¼cke
* EinfÃ¼hrung in AusdrÃ¼cke::
* Substantive und Verben::
* Bezeichner::
* Funktionen und Variablen fÃ¼r AusdrÃ¼cke::

Operatoren
* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren fÃ¼r Gleichungen::
* Zuweisungsoperatoren::
* Benutzerdefinierte Operatoren::

Auswertung
* Funktionen und Variablen fÃ¼r die Auswertung::

Vereinfachung
* EinfÃ¼hrung in die Vereinfachung::
* Funktionen und Variablen fÃ¼r die Vereinfachung::

Mathematische Funktionen
* Funktionen fÃ¼r Zahlen::
* Funktionen fÃ¼r komplexe Zahlen::
* Funktionen der Kombinatorik::
* Algebraische Funktionen::
* Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* EinfÃ¼hrung in Winkelfunktionen::
* Funktionen und Variablen fÃ¼r Winkelfunktionen::
* Hyperbelfunktionen::
* EinfÃ¼hrung in Hyperbelfunktionen::
* Funktionen und Variablen fÃ¼r Hyperbelfunktionen::

Maximas Datenbank
* EinfÃ¼hrung in Maximas Datenbank::
* Funktionen und Variablen fÃ¼r Eigenschaften::
* Funktionen und Variablen fÃ¼r Fakten::
* Funktionen und Variablen fÃ¼r Aussagen::

Grafische Darstellung
* EinfÃ¼hrung in die grafische Darstellung::
* Grafikformate::
* Funktionen und Variablen fÃ¼r die grafische Darstellung::
* Grafikoptionen::
* Gnuplot Optionen::
* Gnuplot_pipes Formatfunktionen::

Eingabe und Ausgabe
* Kommentare::
* Dateien::
* Funktionen und Variablen fÃ¼r die Eingabe und Ausgabe::
* Funktionen und Variablen fÃ¼r die Tex-Ausgabe::

Mengen
* Introduction to Sets::
* Functions and Variables for Sets::

Summen, Produkte und Reihen
* Summen und Produkte::
* EinfÃ¼hrung in Reihen::
* Funktionen und Variablen fÃ¼r Reihen::
* Poisson Reihen::
* KettenbrÃ¼che::

Analysis
* Funktionen und Variablen fÃ¼r Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::

Polynome
* Introduction to Polynomials::
* Functions and Variables for Polynomials::

Gleichungen
* Funktionen und Variablen fÃ¼r Gleichungen::

Lineare Algebra
* Introduction to Matrices and Linear Algebra::
* Dot::
* Vectors::
* eigen::
* Functions and Variables for Matrices and Linear Algebra::

Tensoren
* Introduction to itensor::
* Functions and Variables for itensor::
* Introduction to ctensor::
* Functions and Variables for ctensor::
* Introduction to atensor::
* Functions and Variables for atensor::

Spezielle Funktionen
* EinfÃ¼hrung fÃ¼r spezielle Funktionen::
* Besselfunktionen::
* Airyfunktionen::
* Struvefunktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Funktionen und Variablen fÃ¼r spezielle Funktionen::

Fouriertransformationen
* Introduction to fast Fourier transform::
* Functions and Variables for fast Fourier transform::
* Introduction to Fourier series::
* Functions and Variables for Fourier series::

Laufzeitumgebung
* Introduction for Runtime Environment::
* Interrupts::
* Functions and Variables for Runtime Environment::

Regeln und Muster
* Introduction to Rules and Patterns::
* Functions and Variables for Rules and Patterns::

Funktionsdefinitionen
* EinfÃ¼hrung in Funktionsdefinitionen::
* Funktionen::
* Makros::
* Funktionen und Variablen fÃ¼r Funktionsdefinitionen::

Programmierung
* Lisp und Maxima::
* Introduction to Program Flow::
* Functions and Variables for Program Flow::

Fehlersuche
* Source Level Debugging::
* Keyword Commands::
* Functions and Variables for Debugging::

Verschiedene Optionen
* Introduction to Miscellaneous Options::
* Share::
* Functions and Variables for Miscellaneous Options::

affine
* Introduction to Affine::
* Functions and Variables for Affine::

asympa
* Introduction to asympa::
* Functions and variables for asympa::

augmented_lagrangian
* Functions and Variables for augmented_lagrangian::

bode
* Functions and Variables for bode::

cobyla
* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::

contrib_ode
* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::

Package descriptive
* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for specific multivariate descriptive statistics::
* Functions and Variables for statistical graphs::

diag
* Functions and Variables for diag::

Package distrib
* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::

draw
* Introduction to draw::
* Functions and Variables for draw::
* Functions and Variables for pictures::
* Functions and Variables for worldmap::

drawdf
* Introduction to drawdf::
* Functions and Variables for drawdf::

dynamics
* Introduction to dynamics::
* Functions and Variables for dynamics::

ezunits
* Introduction to ezunits::
* Introduction to physical_constants::
* Functions and Variables for ezunits::

f90
* Functions and Variables for f90::

ggf
* Functions and Variables for ggf::

graphs
* Introduction to graphs::
* Functions and Variables for graphs::

grobner
* Introduction to grobner::
* Functions and Variables for grobner::

groups
* Functions and Variables for Groups::

impdiff
* Functions and Variables for impdiff::

interpol
* Introduction to interpol::
* Functions and Variables for interpol::

lapack
* Introduction to lapack::
* Functions and Variables for lapack::

lbfgs
* Introduction to lbfgs::
* Functions and Variables for lbfgs::

lindstedt
* Functions and Variables for lindstedt::

linearalgebra
* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::

lsquares
* Introduction to lsquares::
* Functions and Variables for lsquares::

makeOrders
* Functions and Variables for makeOrders::

mnewton
* Introduction to mnewton::
* Functions and Variables for mnewton::

numericalio
* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::

opsubst
* Functions and Variables for opsubst::

orthopoly
* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::

plotdf
* Introduction to plotdf::
* Functions and Variables for plotdf::

romberg
* Functions and Variables for romberg::

simplex
* Introduction to simplex::
* Functions and Variables for simplex::

simplification
* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::
* Package sqdnst::

solve_rec
* Introduction to solve_rec::
* Functions and Variables for solve_rec::

stats
* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::

stirling
* Functions and Variables for stirling::

stringproc
* Introduction to string processing::
* Functions and Variables for input and output::
* Functions and Variables for characters::
* Functions and Variables for strings::

symmetries
* Introduction to Symmetries::
* Functions and Variables for Symmetries::

unit
* Introduction to Units::
* Functions and Variables for Units::

zeilberger
* Introduction to zeilberger::
* Functions and Variables for zeilberger::

Glossar
* Glossar::


File: maxima.info,  Node: EinfÃ¼hrung in Maxima,  Next: Programmfehler,  Prev: Top,  Up: Top

1 EinfÃ¼hrung in Maxima
***********************

Von einer Kommandozeile wird Maxima mit dem Kommando `maxima' gestartet.
Maxima zeigt die aktuelle Version an und gibt einen Prompt fÃ¼r die
Eingabe aus. Ein Maxima-Kommando wird mit einem Semikolon
abgeschlossen. Eine Maxima-Sitzung wird mit dem Kommando `quit();'
beendet. Es folgt ein Beispiel fÃ¼r eine Sitzung:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

Maxima kann GNU Infotext anzeigen. Das Kommando `describe(text)' zeigt
alle Inhalte an, die die Zeichenkette `text' enthalten. Das Fragezeichen
`?' (exakte Suche) und zwei Fragezeichen `??' (ungenaue Suche) sind
abkÃ¼rzende Schreibweisen fÃ¼r `describe':

     (%i1) ?? integrat

      0: Functions and Variables for Integration
      1: Introduction to Integration
      2: integrate (Functions and Variables for Integration)
      3: integrate_use_rootsof (Functions and Variables for Integration)
      4: integration_constant (Functions and Variables for Integration)
      5: integration_constant_counter (Functions and Variables for
         Integration)
     Enter space-separated numbers, `all' or `none': 4

      -- System variable: integration_constant
          Default value: `%c'

          When a constant of integration is introduced by indefinite
          integration of an equation, the name of the constant is
          constructed by concatenating `integration_constant' and
          `integration_constant_counter'.

          `integration_constant' may be assigned any symbol.

          Examples:

               (%i1) integrate (x^2 = 1, x);
                                          3
                                         x
               (%o1)                     -- = x + %c1
                                         3
               (%i2) integration_constant : 'k;
               (%o2)                           k
               (%i3) integrate (x^2 = 1, x);
                                           3
                                          x
               (%o3)                      -- = x + k2
                                          3


     (%o1)                                true

Das Ergebnis einer Rechnung wird mit dem Operator `:' einer Variablen
zugewiesen. Weiterhin speichert Maxima die Eingaben unter den Marken
`(%i)' und die Ausgaben unter den Marken `(%o)' ab. Die Marken erhalten
eine fortlaufende Nummerierung. Mit diesen Marken kann auf frÃ¼here
Eingaben und Ausgaben zurÃ¼ckgegriffen werden. Auf die letzte Ausgabe
kann mit `%' zurÃ¼ckgegriffen werden.

     (%i1) u: expand ((x + y)^6);
                6        5       2  4       3  3       4  2      5      6
     (%o1)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff(u,x);
                     5         4       2  3       3  2       4        5
     (%o2)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor(%o2);
                                                5
     (%o3)                             6 (y + x)
     (%i4) %/6;
                                               5
     (%o4)                              (y + x)

Maxima kennt numerische Konstanten und kann mit komplexen Zahlen
rechnen:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

Maxima kann differenzieren und integrieren:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

Maxima kann lineare Gleichungssysteme und kubische Gleichungen lÃ¶sen:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

Maxima kann nichtlineare Gleichungssysteme lÃ¶sen. Wird eine Eingabe mit
`$' anstatt `;' abgeschlossen, wird keine Ausgabe erzeugt:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

Maxima kann Funktionsgraphen mit einer oder mehreren Funktionen
zeichnen:

     (%i1) plot2d(sin(x)/x, [x, -20, 20])$

     (%i2) plot2d([atan(x), erf(x), tanh(x)], [x, -5, 5], [y, -1.5, 2])$

     (%i3) plot3d(sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2),
              [x, -12, 12], [y, -12, 12])$


File: maxima.info,  Node: Programmfehler,  Next: Hilfe,  Prev: EinfÃ¼hrung in Maxima,  Up: Top

2 Programmfehler
****************

* Menu:

* EinfÃ¼hrung in Programmfehler::
* Funktionen und Variablen fÃ¼r Programmfehler::


File: maxima.info,  Node: EinfÃ¼hrung in Programmfehler,  Next: Funktionen und Variablen fÃ¼r Programmfehler,  Prev: Programmfehler,  Up: Programmfehler

2.1 EinfÃ¼hrung in Programmfehler
=================================

Maxima wird stÃ¤ndig weiterentwickelt. Der Funktionsumfang wird
erweitert und Fehler, die bei einem Programm dieser KomplexitÃ¤t kaum zu
vermeiden sind, werden korrigiert. Fehler kÃ¶nnen berichtet werden.
Werden ausreichend Informationen mitgeteilt, kÃ¶nnen die Entwickler
Maxima weiter verbessern.  Ein aktueller Link zur Website zum Berichten
von Fehlern sowie die notwendigen Informationen Ã¼ber die
Maxima-Installation werden mit dem Befehl `bug_report()' angezeigt. Um
die Installation auf dem Rechner zu testen, kann die Maxima-Testsuite
ausgefÃ¼hrt werden. Die folgende Ãbersicht zeigt die Funktionen und
Variablen fÃ¼r das Testen der Installation und das Berichten von Fehlern:

     run_testsuite     testsuite_files     bug_report     build_info


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Programmfehler,  Prev: EinfÃ¼hrung in Programmfehler,  Up: Programmfehler

2.2 Funktionen und Variablen fÃ¼r Programmfehler
================================================

 -- Funktion: run_testsuite ([<options>])
     Die Funktion `run_testsuite' fÃ¼hrt die Maxima-Testsuite aus.
     Erfolgreiche Tests und Tests, die zwar nicht erfolgreich, aber als
     ein bekannter Fehler gekennzeichnet sind, geben die Meldung
     "passed". `run_testsuite' akzeptiert die folgenden optionalen
     SchlÃ¼sselworte als Argumente:

    `display_all'
          Hat das SchlÃ¼sselwort `display_all' den Wert `true', werden
          alle Tests angezeigt. Der Standardwert ist `false'. In diesem
          Fall werden nur die Tests angezeigt, die fehlschlagen.

    `display_known_bugs'
          Hat das SchlÃ¼sselwort `display_known_bugs' den Wert `true',
          werden alle Tests angezeigt, die als fehlerhaft
          gekennzeichnet sind. Der Standardwert ist `false'.

    `tests'
          Das SchlÃ¼sselwort `tests' erhÃ¤lt eine Liste mit den
          Testdateien, die ausgefÃ¼hrt werden sollen. Eine Testdatei
          kann durch eine Zeichenkette oder ein Symbol angegeben
          werden. Der Standard ist, dass alle Testdateien ausgefÃ¼hrt
          werden, die in der Optionsvariablen `testsuite_files'
          enthalten sind.

    `time'
          Hat das SchlÃ¼sselwort `time' den Wert `true', werden die
          Laufzeiten der einzelnen Testdateien angezeigt. Hat `time'
          den Wert `all' und `display_all' den Wert `true', wird die
          Laufzeit jedes einzelnen Tests angezeigt. Der Standardwert
          ist `false'.

     Zum Beispiel fÃ¼hrt `run_testsuite(display_known_bugs = true, tests
     = [rtest5])' die Testdatei `rtest5' aus und zeigt die Tests an,
     die als fehlerhaft gekennzeichnet sind.
     `run_testsuite(display_all = true, tests = ["rtest1", rtest2])'
     fÃ¼hrt die Testdateien `rtest1' und `rtest2' aus und zeigt jeden
     einzelnen Test an.

     Das AusfÃ¼hren einer Testdatei kann die Maxima-Umgebung Ã¤ndern.
     Typischerweise fÃ¼hrt eine Testdatei zuerst das Kommando
     `kill(all)' aus, um eine definierte Umgebung herzustellen, in der
     keine benutzerdefinierten Funktionen und Variablen vorhanden sind.

     `run_testsuite' hat den RÃ¼ckgabewert `done'.


 -- Optionsvariable: testsuite_files
     Die Optionsvariable `testsuite_files' enthÃ¤lt die Liste der
     Testdateien, die von `run_testsuite'  standardmÃ¤Ãig ausgefÃ¼hrt
     werden. Wenn bekannt ist, dass einzelne Tests einer Testdatei
     fehlschlagen werden, dann wird anstatt dem Namen der Datei eine
     Liste eingefÃ¼gt, die den Namen und die Nummern der fehlerhaften
     Tests enthÃ¤lt. Das folgende Beispiel zeigt, wie fehlerhafte Tests
     gekennzeichnet werden:

           ["rtest13s", ["rtest14", 57, 63]]

     Die EintrÃ¤ge der Liste bedeuten, dass die Dateien "rtest13s" und
     "rtest14" ausgefÃ¼hrt werden sollen und das bekannt ist, dass die
     Tests mit den Nummern 57 und 63 der Testdatei "rtest14"
     fehlschlagen werden.


 -- Funktion: bug_report ()
     Zeigt die Maxima- und Lisp-Version sowie einen Link zur
     Maxima-Projekt-Webseite.  Die Informationen zur Version werden
     auch von `build_info'  angezeigt. Wenn ein Programmfehler
     berichtet wird, ist es hilfreich, die Maxima- und Lisp-Version in
     den Fehlerbericht aufzunehmen. `bug_report' gibt eine leere
     Zeichenkette `""' zurÃ¼ck.

     Beispiel:

          (%i1) bug_report();
          The Maxima bug database is available at
              http://sourceforge.net/tracker/?atid=104933&group_id=4933
          Submit bug reports by following the 'Add new' link on that page.
          Please include the following information with your bug report:
          -------------------------------------------------------------
          Maxima version: 5.20post
          Maxima build date: 19:59 5/10/2010
          Host type: i686-pc-linux-gnu
          Lisp implementation type: SBCL
          Lisp implementation version: 1.0.29.11.debian
          -------------------------------------------------------------
          The above information is also reported by the function 'build_info'


 -- Funktion: build_info ()
     Zeigt eine Ã¼bersicht mit Angaben zur installierten Version von
     Maxima.  `build_info' gibt eine leere Zeichenkette `""' zurÃ¼ck.

     Beispiel:

          (%i1) build_info();
          Maxima version: 5.20post
          Maxima build date: 19:59 5/10/2010
          Host type: i686-pc-linux-gnu
          Lisp implementation type: SBCL
          Lisp implementation version: 1.0.29.11.debian



File: maxima.info,  Node: Hilfe,  Next: Kommandozeile,  Prev: Programmfehler,  Up: Top

3 Hilfe
*******

* Menu:

* Dokumentation::
* Funktionen und Variablen der Hilfe::


File: maxima.info,  Node: Dokumentation,  Next: Funktionen und Variablen der Hilfe,  Prev: Hilfe,  Up: Hilfe

3.1 Dokumentation
=================

Die Maxima-Dokumentation ist in Texinfo geschrieben und wird in
verschiedenen Formaten zur VerfÃ¼gung gestellt. Von der
Maxima-Kommandozeile kann die Dokumentation mit den Kommandos `?', `??'
oder `describe' aufgerufen werden. Weiterhin kann die Dokumentation als
GNU Infotext mit dem GNU Programm `info', in einem Browser oder als
PDF-Datei gelesen werden.  Sowohl unter Windows als auch unter Linux
kann die Dokumentation als Hilfedatei gelesen werden.


File: maxima.info,  Node: Funktionen und Variablen der Hilfe,  Prev: Dokumentation,  Up: Hilfe

3.2 Funktionen und Variablen der Hilfe
======================================

 -- Funktion: apropos (<string>)
     Gibt eine Liste der Maxima-Symbole zurÃ¼ck, die <string> im Namen
     enthalten. <string> ist eine Zeichenkette. `apropos("")' gibt eine
     Liste mit allen Maxima-Symbolen zurÃ¼ck. `apropos' gibt eine leere
     Liste `[]' zurÃ¼ck, wenn kein Maxima-Symbol gefunden wurde, das
     <string> im Namen enthÃ¤lt.

     Beispiel:

     Zeige alle Maxima-Symbole, die `"gamma"' im Namen enthalten:

          (%i1) apropos("gamma");
          (%o1) [%gamma, gamma, gammalim, gamma_expand, gamma_greek,
          gamma_incomplete, gamma_incomplete_generalized,
          gamma_incomplete_regularized, Gamma, log_gamma, makegamma,
          prefer_gamma_incomplete,
          gamma_incomplete_generalized_regularized]


 -- Funktion: demo (<filename>)
     FÃ¼hrt die Beispiele der Demo-Datei <filename> aus. <filename> kann
     ein Symbol oder eine Zeichenkette sein. `demo' macht nach jeder
     Ausgabe eine Pause und wartet auf eine Eingabe. `demo' sucht in
     den Ordnern, die in der Optionsvariablen `file_search_demo'
     enthalten sind, nach der Datei <filename>. Die Dateiendung <.dem>
     muÃ nicht angegeben werden.  Siehe auch die Funktion `file_search'
     und die Optionsvariable `file_search_demo'.

     `demo' wertet das Argument aus. `demo' gibt den Namen der
     Demo-Datei zurÃ¼ck, die ausgefÃ¼hrt wird.

     Beispiel:

          (%i1) demo ("disol");
          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)
          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))
          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)
          _


 -- Funktion: describe (<topic>)
 -- Funktion: describe (<topic>, exact)
 -- Funktion: describe (<topic>, inexact)
     `describe(<topic>)' entspricht dem Kommando `describe(<topic>,
     exact)'. <topic> ist eine Zeichenkette oder ein Symbol. Wenn
     <topic> ein Operator wie zum Beispiel `+', `*', `do' oder `if'
     ist, muss der Name des Operators als eine Zeichenkette angegeben
     werden.

     `describe(<topic>, exact)' findet EintrÃ¤ge, die mit <topic>
     Ã¼bereinstimmen. Bei der Suche nach einer Ãbereinstimmung werden
     Klein- und GroÃschreibung nicht voneinander unterschieden.
     `describe(<topic>, inexact)' findet EintrÃ¤ge, die <topic>
     enthalten. Sind mehrere EintrÃ¤ge vorhanden, fragt Maxima, welcher
     der EintrÃ¤ge angezeigt werden soll.

     `? foo' (mit einem Leerzeichen zwischen `?' und `foo') entspricht
     `describe("foo", exact)' und `?? foo' entspricht `describe("foo",
     inexact)'. In der Kurzschreibweise muss das Argument ein Symbol
     sein.

     `describe("", inexact)' gibt alle Themen aus, die in der
     Dokumentation enthalten sind.

     `describe' wertet das Argument nicht aus. `describe' gibt `true'
     zurÃ¼ck, wenn EintrÃ¤ge gefunden wurden, ansonsten `false'.

     Beispiel:

     Im folgenden Beispiel werden die EintrÃ¤ge 2 und 3 ausgewÃ¤hlt (Die
     Ausgabe ist verkÃ¼rzt wiedergeben). Alle oder keiner der EintrÃ¤ge
     werden mit `all' oder `none' ausgewÃ¤hlt. Die Eingabe kann mit `a'
     oder `n' abgekÃ¼rzt werden.

          (%i1) ?? integrat
           0: Functions and Variables for Integration
           1: Introduction to Integration
           2: integrate (Functions and Variables for Integration)
           3: integrate_use_rootsof (Functions and Variables for Integration)
           4: integration_constant (Functions and Variables for Integration)
           5: integration_constant_counter (Functions and Variables for
              Integration)
          Enter space-separated numbers, `all' or `none': 2 3

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, with limits of integration <a> and <b>.
               The limits should not contain <x>, although `integrate' does
               not enforce this restriction.  <a> need not be less than <b>.
               If <b> is equal to <a>, `integrate' returns zero.
               [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]


 -- Funktion: example (<topic>)
 -- Funktion: example ()
     `example(<topic>)' zeigt Beispiele fÃ¼r das Argument <topic>.
     <topic> ist ein Symbol oder eine Zeichenkette. Ist das Argument ein
     Operator, wie zum Beispiel `+', `*' oder `do', muss das Argument
     <topic> eine Zeichenkette sein. GroÃ- und Kleinschreibung werden
     nicht unterschieden.

     `example()' zeigt eine Liste aller Themen, fÃ¼r die Beispiele
     vorhanden sind.

     Die Optionsvariable `manual_demo'  enthÃ¤lt den Namen der Datei,
     die die Beispiele enthÃ¤lt. Der Standardwert ist `"manual.demo"'.

     `example' wertet das Argument nicht aus. `example' gibt `done'
     zurÃ¼ck, auÃer wenn kein Argument angeben ist oder wenn kein
     Beispiel gefunden wurde. In diesen FÃ¤llen wird eine Liste mit
     allen Themen ausgegeben, zu denen Beispiele vorhanden sind.

     Beispiele:

          (%i1) example(append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)                    [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                                done
          (%i3) example("lambda");
          (%i4) lambda([x,y,z],z^2+y^2+x^2)
                                                     2    2    2
          (%o4)                   lambda([x, y, z], z  + y  + x )
          (%i5) %(1,2,a)
                                               2
          (%o5)                               a  + 5
          (%i6) a+2+1
          (%o6)                                a + 3
          (%o6)                                done


 -- Optionsvariable: manual_demo
     Standardwert: `"manual.demo"'

     Die Optionsvariable `manual_demo' enthÃ¤lt den Namen der Datei, die
     die Beispiele fÃ¼r die Funktion `example' enthÃ¤lt. Siehe `example'.



File: maxima.info,  Node: Kommandozeile,  Next: Datentypen und -strukturen,  Prev: Hilfe,  Up: Top

4 Kommandozeile
***************

* Menu:

* EinfÃ¼hrung in die Kommandozeile::
* Funktionen und Variablen der Eingabe::
* Funktionen und Variablen der Ausgabe::


File: maxima.info,  Node: EinfÃ¼hrung in die Kommandozeile,  Next: Funktionen und Variablen der Eingabe,  Prev: Kommandozeile,  Up: Kommandozeile

4.1 EinfÃ¼hrung in die Kommandozeile
====================================

Konsole
-------

FÃ¼r Maxima sind verschiedene BenutzeroberflÃ¤chen erhÃ¤ltlich.
OberflÃ¤chen, die je nach Betriebssystem bereits nach der Installation
von Maxima zur VerfÃ¼gung stehen, sind wxMaxima, Xmaxima, Imaxima und
die Konsole.

   Die Konsole (oder das Terminal) arbeitet in einem Textmodus. FÃ¼r die
Ausgabe in einem grafischen Modus mit einer menÃ¼gesteuerten Eingabe
mÃ¼ssen andere BenutzeroberflÃ¤chen genutzt werden.

   In dieser Dokumentation wird ausschlieÃlich die Konsole eingesetzt,
die unter allen Betriebsystemen zur VerfÃ¼gung steht. Der Nutzer kann
alle Maxima Befehle und Funktionen in einer Konsole nutzen. Im
Textmodus der Konsole erfolgen die Ausgaben in der Regel in einem
2D-Modus. FÃ¼r die Ausgabe von Funktionsgraphen werden von Maxima
Hilfsprogramme wie GNUPlot aufgerufen.

Eingabe, Auswertung, Vereinfachung und Anzeige
----------------------------------------------

Jede Eingabe des Nutzers in einer Konsole bis zur Ausgabe eines
Ergebnisses auf der Konsole kann in vier Phasen eingeteilt werden:

  1. Von der Tastatur oder aus einer Datei wird ein Ausdruck eingelesen
     und vom Parser in eine interne Darstellung umgewandelt. In dieser
     1. Phase werden inbesondere Operatoren wie "+", "/" oder "do"
     behandelt.

  2. Der vom Parser eingelesene Ausdruck wird von Maxima in der 2. Phase
     ausgewertet. Dabei werden Variablen durch ihren Wert ersetzt und
     Funktionen ausgefÃ¼hrt. Das Ergebnis dieser Phase ist ein
     ausgewerteter Ausdruck.

  3. Der ausgewertete Ausdruck wird in der 3. Phase von Maxima
     vereinfacht.  Dabei werden AusdrÃ¼cke wie `a+a' zu `2*a' oder
     `sin(%pi/2)' zu `1' vereinfacht.

  4. Das Ergebnis ist ein ausgewerteter und vereinfachter Ausdruck.
     Zuletzt wird dieses Ergebnis in der 4. Phase fÃ¼r die Anzeige
     vorbereitet und auf der Konsole ausgegeben.

   Der Nutzer kann auf jede einzelne Phase EinfluÃ nehmen. Verschiedene
Kapitel der Dokumentation befassen sich mit diesen MÃ¶glichkeiten. In
diesem Kapitel werden die Kommandos und MÃ¶glichkeiten zusammengestellt,
die sich mit der Eingabe und Ausgabe auf der Konsole befassen.

Marken
------

Maxima speichert alle Eingaben in den Marken `%i' und die Ausgaben in
den Marken `%o' ab. Die Marken erhalten eine laufende Nummer. Weiterhin
erzeugen einige Funktionen Zwischenmarken `%t'. Andere Systemvariablen
speichern das letzte Ergebnis oder die letzte Eingabe ab. Folgende
Symbole bezeichnen Variablen und Funktionen fÃ¼r die Verwaltung der
Marken:

   __          _
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels

Informationslisten
------------------

Maxima verwaltet Informationslisten. Die verfÃ¼gbaren Informationslisten
sind in der Systemvariablen `infolists' enthalten. In diesem Kapitel
werden die Informationslisten `labels', `values' und `myoptions'
erlÃ¤utert. Wird eine Optionsvariable vom Nutzer gesetzt, kontrolliert
die Optionsvariable `optionset' die Ausgabe weiterer Informationen.
Folgende Symbole bezeichnen Variablen und Funktionen fÃ¼r
Informationslisten und Optionsvariablen:

   infolists     labels        values
   myoptions     optionset

Weitere Informationslisten, die in anderen Kapiteln erlÃ¤utert werden,
sind:

   functions      arrays         macros
   rules          aliases        dependencies
   gradefs        props          let_rule_packages
   structures     namespaces

LÃ¶schen und RÃ¼cksetzen
------------------------

Um einen definierten Anfangszustand herzustellen oder um einzelne
Zuweisungen, Eigenschaften oder Definitionen zu entfernen, kennt Maxima
die folgenden Funktionen:

   kill     reset     reset_verbosely

Weitere Kommandos der Kommandozeile
-----------------------------------

Mit den Symbolen `?' und `??' kann Dokumentation abgerufen werden.
Wird `?' einem Bezeichner als PrÃ¤fix vorangestellt, wird der Bezeichner
als Lisp-Symbol interpretiert. Mit weiteren Kommandos kann eine
Maxima-Sitzung beendet oder zu einer Lisp-Sitzung gewechselt werden.
Das Zeichen fÃ¼r die Eingabeaufforderung einer Unterbrechung kann
geÃ¤ndert werden. Die Zeit fÃ¼r jede einzelne Berechnung kann angezeigt
werden und die Ergebnisse einer Sitzung kÃ¶nnen wiederholt ausgegeben
werden. Maxima kennt hierfÃ¼r die folgenden Symbole:

   ?            ??
   playback     prompt     showtime
   quit         system     to_lisp

Ausgabe auf der Konsole
-----------------------

Verschiedene Schalter und Optionsvariablen kontrollieren die Anzeige.
Maxima kennt hierfÃ¼r die folgenden Symbole:

   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        sqrtdispflag
   stardisp           ttyoff

Mit folgenden Funktionen kann die Ausgabe auf der Konsole formatiert
werden:

   disp               display          dispform
   dispterms          grind            ldisp
   ldisplay           print

Die Funktionen `read' und `readonly' geben AusdrÃ¼cke auf der Konsole
aus und lesen dann die Eingabe eines Nutzers ein:

   read               readonly


File: maxima.info,  Node: Funktionen und Variablen der Eingabe,  Next: Funktionen und Variablen der Ausgabe,  Prev: EinfÃ¼hrung in die Kommandozeile,  Up: Kommandozeile

4.2 Funktionen und Variablen der Eingabe
========================================

 -- Systemvariable: __
     WÃ¤hrend einer laufenden Auswertung enthÃ¤lt die Systemvariable `__'
     den zuletzt vom Parser eingelesenen Ausdruck <expr>. Der Ausdruck
     <expr> wird der Systemvariablen `__' vor der Auswertung und
     Vereinfachung zugewiesen. FÃ¼r die Ausgabe wird `__'  vereinfacht,
     aber nicht ausgewertet.

     Die Systemvariable `__' wird von den Funktionen `batch' und `load'
     erkannt. Wird eine Datei mit der Funktion `batch' ausgefÃ¼hrt, hat
     `__' dieselbe Bedeutung wie bei der Eingabe in einer Kommandozeile.
     Wird eine Datei mit dem Namen `filename' mit der Funktion `load'
     geladen, enthÃ¤lt `__' den Ausdruck `load(<filename>)'. Das ist die
     letzte Eingabe in der Kommandozeile.

     Siehe auch die Systemvariablen `_'  und `%'.

     Beispiele:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Systemvariable: _
     Die Systemvariable `_' enthÃ¤lt den zuletzt eingebenen Ausdruck
     <expr>. Der Ausdruck <expr> wird der Systemvariablen `_' vor der
     Auswertung und Vereinfachung zugewiesen. FÃ¼r die Ausgabe wird `_'
     vereinfacht, aber nicht ausgewertet.

     Die Systemvariable `_' wird von den Funktionen `batch' und `load'
     erkannt. Wird eine Datei mit der Funktion `batch' ausgefÃ¼hrt, hat
     `_' dieselbe Bedeutung wie bei der Eingabe in einer Kommandozeile.
     Wird eine Datei mit der Funktion `load' geladen, enthÃ¤lt `_' das
     zuletzt in der Kommandozeile eingegebene Kommando.

     Siehe auch die Systemvariablen `__'  und `%'.

     Beispiele:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Systemvariable: %
     Die Systemvariable `%' enthÃ¤lt das Ergebnis des zuletzt von Maxima
     ausgewerteten und vereinfachten Ausdrucks. `%' enhÃ¤lt das letzte
     Ergebnis auch dann, wenn die Ausgabe des Ergebnisses unterdrÃ¼ckt
     wurde.

     Die Systemvariable `%' wird von den Funktionen `batch' und `load'
     erkannt. Wird eine Datei mit der Funktion `batch' ausgefÃ¼hrt, hat
     `%' dieselbe Bedeutung wie bei der Eingabe in einer Kommandozeile.
     Wird eine Datei mit der Funktion `load' geladen, enthÃ¤lt `%' das
     letzte Ergebnis des Ausdrucks, der auf der Konsole eingegeben
     wurde.

     Siehe auch die Systemvariablen `_',  `__'  und `%th'.


 -- Systemvariable: %%
     In zusammengesetzten AusdrÃ¼cken, wie in AusdrÃ¼cken mit `block' oder
     `lambda' oder in AusdrÃ¼cken der Gestalt `(<s_1>, ..., <s_n>)',
     enthÃ¤lt die Systemvariable `%%' das Ergebnis des vorhergehenden
     Ausdrucks. Zum Beispiel haben die folgenden AusdrÃ¼cke jeweils
     dasselbe Ergebnis:

          (%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                                         21
          (%o1)                          --
                                         2
          (%i2) block ([prev], prev: integrate (x^5, x),
                         ev (prev, x=2) - ev (prev, x=1));
                                         21
          (%o2)                          --
                                         2

     Ein zusammengesetzter Ausdruck kann weitere zusammengesetzte
     AusdrÃ¼cke enthalten. `%%' enthÃ¤lt dabei jeweils das Ergebnis des
     letzten Ausdrucks.  So hat das folgende Beispiel das Ergebnis
     `7*a^n':

          (%i3) block (block (a^n, %%*42), %%/6);
                                           n
          (%o3)                         7 a

     Der Wert der Systemvariablen `%%' kann nach einer Unterbrechung
     mit dem Kommando `break' inspeziert werden. Dies wird im folgenden
     Beispiel genutzt, um den Wert 42 auszugeben:

          (%i4) block (a: 42, break ())$
          Entering a Maxima break point. Type 'exit;' to resume.
          _%%;
          42
          _

     FÃ¼r den ersten Ausdruck oder auÃerhalb eines zusammengesetzten
     Ausdrucks ist `%%' nicht definiert.

     Die Systemvariable `%%' wird von `batch' und `load' erkannt und
     hat dieselbe Bedeutung wie bei der Eingabe in der Konsole.

     Siehe auch die Systemvariable `%'  und die Funktion `%th'.


 -- Funktion: %th (<n>)
     Die Funktion `%th' liefert das n-te vorhergehende Ergebnis.

     `%th' ist zum Beispiel in `batch'-Dateien nÃ¼tzlich. Das folgende
     Beispiel zeigt, wie die letzten 5 eingegebenen Werte mit der
     Funktion `%th' aufsummiert werden kÃ¶nnen:

          (%i1) 1;2;3;4;5;
          (%o1)                           1
          (%o2)                           2
          (%o3)                           3
          (%o4)                           4
          (%o5)                           5
          (%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
          (%o6)                          15

     Die Funktion `%th' wird von den Funktionen `batch' und `load'
     erkannt. Wird eine Datei mit `batch' ausgefÃ¼hrt, hat `%th' dieselbe
     Bedeutung wie bei der Eingabe in der Konsole. Wird eine Datei mit
     der Funktion `load' geladen, enthÃ¤lt `%th' das letzte Ergebnis der
     Eingabe in der Konsole.

     Siehe auch `%'  und `%%'.


 -- Spezielles Symbol: ?
     Wird dem Namen einer Funktion oder Variablen ein `?' als PrÃ¤fix
     vorangestellt, wird der Name als ein Lisp-Symbol interpretiert.
     Zum Beispiel bedeutet `?round' die Lisp-Funktion `ROUND'. Siehe
     auch das Kapitel Lisp und Maxima  fÃ¼r weitere AusfÃ¼hrungen zu
     diesem Thema.

     Die Eingabe `? word' ist eine Kurzschreibweise fÃ¼r das Kommando
     `describe("word")'. Das Fragezeichen muss am Anfang einer
     Eingabezeile stehen, damit Maxima die Eingabe als eine Anfrage
     nach der Dokumentation interpretiert.


 -- Spezielles Symbol: ??
     Die Eingabe `?? word' ist eine Kurzschreibweise fÃ¼r das Kommando
     `describe("word", inexact)'. Die Fragezeichen mÃ¼ssen am Anfang
     einer Eingabezeile stehen, damit Maxima die Eingabe als eine
     Anfrage nach der Dokumentation interpretiert.


 -- Optionsvariable: inchar
     Standardwert: `%i'

     Die Optionsvariable `inchar' enthÃ¤lt den PrÃ¤fix der Eingabemarken.
     Maxima erzeugt die Eingabemarken automatisch aus dem PrÃ¤fix
     `inchar' und der Zeilennummer `linenum'.

     Der Optionsvariablen `inchar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     kÃ¶nnen. Da Maxima intern nur das erste Zeichen berÃ¼cksichtigt,
     sollten sich die PrÃ¤fixe `inchar', `outchar' und `linechar' im
     ersten Zeichen voneinander unterscheiden. Ansonsten funktionieren
     einige Kommandos wie zum Beispiel `kill(inlabels)' nicht wie
     erwartet.

     Siehe auch die Funktion und Optionsvariable `labels'  sowie die
     Systemvariablen `outchar'  und `linechar'.

     Beispiele:

          (%i1) inchar: "input";
          (%o1)                         input
          (input2) expand((a+b)^3);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (input3)


 -- Systemvariable: infolists
     Standardwert: `[]'

     `infolists' ist eine Liste der Informationslisten, die Maxima zur
     VerfÃ¼gung stellt. Diese sind:

    `labels'
          EnthÃ¤lt die Marken `%i', `%o' und `%t', denen bisher ein
          Ausdruck zugewiesen wurde.

    `values'
          EnthÃ¤lt die vom Benutzer mit den Operatoren `:' oder `::'
          definierten Variablen.

    `functions'
          EnthÃ¤lt die vom Benutzer mit dem Operator `:=' oder der
          Funktion `define' definierten Funktionen.

    `arrays'
          EnthÃ¤lt die mit den Operatoren `:', `::' oder `:=' definierten
          Arrays oder Array-Funktionen.

    `macros'
          EnthÃ¤lt die vom Benutzer mit dem Operator `::=' definierten
          Makros.

    `myoptions'
          EnthÃ¤lt die Liste der Optionsvariablen, die vom Benutzer
          bisher einen neuen Wert erhalten haben.

    `rules'
          EnthÃ¤lt die vom Benutzer mit den Funktionen `tellsimp',
          `tellsimpafter', `defmatch' oder `defrule' definierten Regeln.

    `aliases'
          EnthÃ¤lt die Liste der Symbole, die einen vom Benutzer
          definierten Alias-Namen mit der Funktion `alias' erhalten
          haben. Weiterhin erzeugen die Funktionen `ordergreat' und
          `orderless' sowie eine Deklaration als `noun' mit der
          Funktion `declare' Alias-Namen, die in die Liste eingetragen
          werden.

    `dependencies'
          EnthÃ¤lt alle Symbole, fÃ¼r die mit den Funktionen `depends'
          oder `gradef' eine AbhÃ¤ngigkeit definiert ist.

    `gradefs'
          EnthÃ¤lt die Funktionen, fÃ¼r die der Benutzer mit der Funktion
          `gradef' eine Ableitung definiert hat.

    `props'
          EnthÃ¤lt die Symbole, die eine Eigenschaft mit der Funktion
          `declare' erhalten haben.

    `let_rule_packages'
          EnthÃ¤lt die vom Benutzer definierten `let'-Regeln.



 -- Funktion: kill (<a_1>, ..., <a_n>)
 -- Funktion: kill (labels)
 -- Funktion: kill (inlabels, outlabels, linelabels)
 -- Funktion: kill (<n>)
 -- Funktion: kill ([<m>, <n>])
 -- Funktion: kill (values, functions, arrays, ...)
 -- Funktion: kill (all)
 -- Funktion: kill (allbut (<a_1>, ..., <a_n>))
     Die Funktion `kill' entfernt alle Zuweisungen (Werte, Funktionen,
     Arrays oder Regeln) und Eigenschaften von den Argumenten <a_1>,
     ..., <a_n>.  Ein Argument <a_k> kann ein Symbol oder ein einzelnes
     Arrayelement sein.  Ist <a_k> ein einzelnes Arrayelement, entfernt
     `kill' die Zuweisungen an dieses Element, ohne die anderen
     Elemente des Arrays zu beeinflussen.

     `kill' kennt verschiedene spezielle Argumente, die auch kombiniert
     werden kÃ¶nnen wie zum Beispiel `kill(inlabels, functions,
     allbut(foo, bar))'.

     `kill(labels)' entfernt alle Zuweisungen an Eingabe-, Ausgabe- und
     Zwischenmarken. `kill(inlabels)' entfernt nur die Zuweisungen an
     Eingabemarken, die mit dem aktuellen Wert von `inchar' beginnen.
     Entsprechend entfernt `kill(outlabels)' die Zuweisungen an die
     Ausgabemarken, die mit dem aktuellen Wert von `outchar' beginnen
     und `kill(linelabels)' die Zuweisungen an die Zwischenmarken, die
     mit dem aktuellen Wert von `linechar' beginnen.

     `kill(<n>)', wobei <n> eine ganze Zahl ist, entfernt die
     Zuweisungen an die <n> letzten Eingabe- und Ausgabemarken.
     `kill([<m>, <n>])' entfernt die Zuweisungen an die Eingabe- und
     Ausgabemarken mit den Nummern von <m> bis <n>.

     `kill(<infolist>)', wobei <infolist> eine Informationsliste wie zum
     Beispiel `values', `functions' oder `arrays' ist, entfernt die
     Zuweisungen an allen EintrÃ¤gen der Liste <infolist>. Siehe auch
     `infolists'.

     `kill(all)' entfernt die Zuweisungen an die EintrÃ¤ge in sÃ¤mtlichen
     Informationslisten. `kill(all)' setzt keine Optionsvariablen auf
     ihre Standardwerte zurÃ¼ck. Siehe die Funktion `reset',  um
     Optionsvariablen auf ihre Standwerte zurÃ¼ckzusetzen.

     `kill(allbut(<a_1>, ..., <a_n>))' entfernt alle Zuweisungen bis
     auf Zuweisungen an die Variablen <a_1>, ..., <a_n>.
     `kill(allbut(<infolist>))' entfernt alle Zuweisungen bis auf denen
     in der Informationsliste <infolist>.

     `kill(<symbol>)' entfernt sÃ¤mtliche Zuweisungen und Eigenschaften
     des Symbols <symbol>. Im Gegensatz dazu entfernen `remvalue',
     `remfunction', `remarray' und `remrule' jeweils eine spezielle
     Eigenschaft eines Symbols.

     `kill' wertet die Argumente nicht aus. Der Quote-Quote-Operator
     kann die Auswertung erzwingen. `kill' gibt immer `done' zurÃ¼ck.


 -- Funktion: labels (<symbol>)
 -- Systemvariable: labels
     Die Funktion `labels' gibt eine Liste der Eingabe-, Ausgabe- und
     Zwischenmarken zurÃ¼ck, die mit <symbol> beginnen. Typischerweise
     ist <symbol> der Wert von `inchar', `outchar' oder `linechar'.
     Dabei kann das Prozentzeichen fortgelassen werden. So ergeben zum
     Beispiel `labels(i)' und `labels(%i)' dasselbe Ergebnis.

     Wenn keine Marke mit <symbol> beginnt, gibt `labels' eine leere
     Liste zurÃ¼ck.

     Die Funktion `labels' wertet ihre Argument nicht aus. Mit dem
     Quote-Quote-Operator `''' kann die Auswertung erzwungen werden. Zum
     Beispiel gibt das Kommando `labels (''inchar)' die Eingabemarken
     zurÃ¼ck, die mit dem aktuellen Buchstaben fÃ¼r die Eingabemarken
     beginnen.

     Die Systemvariable `labels' ist eine Informationsliste, die die
     Eingabe-, Ausgabe- und Zwischenmarken enthÃ¤lt. In der Liste sind
     auch die Marken enthalten, die vor einer Ãnderung von `inchar',
     `outchar' oder `linechar' erzeugt wurden.

     StandardmÃ¤Ãig zeigt Maxima das Ergebnis jeder Benutzereingabe an,
     wobei dem Ergebnis eine Ausgabemarke hinzugefÃ¼gt wird. Die Anzeige
     der Ausgabe wird durch die Eingabe eines abschlieÃenden `$'
     (Dollarzeichen) statt eines `;' (Semikolon) unterdrÃ¼ckt. Dabei
     wird eine Ausgabemarke erzeugt und das Ergebnis zugewiesen, jedoch
     nicht angezeigt. Die Marke kann aber in der gleichen Art und Weise
     wie bei angezeigten Ausgabemarken referenziert werden. Siehe auch
     `%',  `%%'  und `%th'.

     Einige Funktionen erzeugen Zwischenmarken. Die Optionsvariable
     `programmode' kontrolliert, ob zum Beispiel `solve' und einige
     andere Funktionen Zwischenmarken erzeugen, anstatt eine Liste von
     AusdrÃ¼cken zurÃ¼ckzugeben. Andere Funktionen wie zum Beispiel
     `ldisplay' erzeugen stets Zwischenmarken.

     Siehe auch `inchar',  `outchar',  `linechar'  und `infolists'.


 -- Optionsvariable: linechar
     Standardwert: `%t'

     Die Optionsvariable `linechar' enthÃ¤lt den PrÃ¤fix der
     Zwischenmarken.  Maxima generiert die Zwischenmarken automatisch
     aus `linechar'.

     Der Optionsvariablen `linechar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     kÃ¶nnen. Da Maxima intern nur das erste Zeichen berÃ¼cksichtigt,
     sollten sich die PrÃ¤fixe `inchar', `outchar' und `linechar' im
     ersten Zeichen voneinander unterscheiden. Ansonsten funktionieren
     einige Kommandos wie `kill(inlabels)' nicht wie erwartet.

     Die Ausgabe von Zwischenmarken kann mit verschiedenen
     Optionsvariablen kontrolliert werden. Siehe `programmode'  und
     `labels'.


 -- Systemvariable: linenum
     Die Zeilennummer der aktuellen Ein- und Ausgabemarken.


 -- Systemvariable: myoptions
     Standardwert: `[]'

     `myoptions' ist eine Informationsliste, die die Optionsvariablen
     enthÃ¤lt, die vom Benutzer wÃ¤hrend einer Sitzung geÃ¤ndert wurden.
     Die Variable verbleibt in der Liste, auch wenn sie wieder auf den
     Standwert zurÃ¼ckgesetzt wird.


 -- Optionsvariable: nolabels
     Standardwert: `false'

     Hat `nolabels' den Wert `true', werden die Eingabe- und
     Ausgabemarken zwar angezeigt, ihnen werden aber keine Eingaben und
     Ergebnisse zugewiesen und sie werden nicht der Liste `labels'
     hinzugefÃ¼gt. Andernfalls werden den Marken die Eingabe und die
     Ergebnisse zugewiesen und in die Informationsliste `labels'
     eingetragen.

     Zwischenmarken `%t' werden durch `nolabels' nicht beeinflusst. Den
     Marken werden unabhÃ¤ngig vom Wert, den `nolables' hat,
     Zwischenergebnisse zugewiesen und sie werden in die
     Informationsliste `labels' eingetragen.

     Siehe auch `batch',  `load'  und `labels'.


 -- Optionsvariable: optionset
     Standardwert: `false'

     Hat `optionset' den Wert `true', gibt Maxima eine Meldung aus, wenn
     eine Optionsvariable einen neuen Wert erhÃ¤lt.


 -- Optionsvariable: outchar
     Standardwert: `%o'

     Die Optionsvariable `outchar' enthÃ¤lt den PrÃ¤fix der Ausgabemarken.
     Maxima generiert die Ausgabemarken automatisch aus `outchar' und
     `linenum'.

     Der Optionsvariablen `outchar' kann eine Zeichenkette oder ein
     Symbol zugewiesen werden, die auch mehr als ein Zeichen haben
     kÃ¶nnen. Da Maxima intern nur das erste Zeichen berÃ¼cksichtigt,
     sollten sich die PrÃ¤fixe `inchar', `outchar' und `linechar' im
     ersten Zeichen voneinander unterscheiden. Ansonsten funktionieren
     einige Kommandos wie `kill(inlabels)' nicht wie erwartet.

     Siehe auch `inchar',  `linechar'  und `labels'.

     Beispiele:

          (%i1) outchar: "output";
          (output1)                    output
          (%i2) expand((a+b)^3);
                               3        2      2      3
          (output2)           b  + 3 a b  + 3 a  b + a
          (%i3)


 -- Funktion: playback ()
 -- Funktion: playback (<n>)
 -- Funktion: playback ([<m>, <n>])
 -- Funktion: playback ([<m>])
 -- Funktion: playback (input)
 -- Funktion: playback (slow)
 -- Funktion: playback (time)
 -- Funktion: playback (grind)
     Zeigt Eingaben, Ergebnisse und Zwischenergebnisse an, ohne diese
     neu zu berechnen. `playback' zeigt nur die Eingaben und Ergebnisse
     an, die Marken zugewiesen wurden. Andere Ausgaben, wie zum
     Beispiel durch `print', `describe' oder Fehlermeldungen, werden
     nicht angezeigt. Siehe auch `labels'.

     `playback()' zeigt sÃ¤mtliche Eingaben und Ergebnisse an, die bis
     dahin erzeugt wurden. Ein Ergebnis wird auch dann angezeigt, wenn
     die Ausgabe mit `$' unterdrÃ¼ckt war.

     `playback(<n>)' zeigt die letzten <n> AusdrÃ¼cke an. Jeder
     Eingabe-, Ausgabe- und Zwischenausdruck zÃ¤hlt dabei als ein
     Ausdruck.  `playback([<m>, <n>])' zeigt die Eingabe-, Ausgabe- und
     ZwischenausdrÃ¼cke mit den Zahlen von <m> bis einschlieÃlich <n> an.
     `playback([<m>])' ist Ã¤quivalent zu `playback([<m>, <m>])'. Die
     Ausgabe ist ein Paar von Ein- und AusgabeausdrÃ¼cken.

     `playback(input)' zeigt sÃ¤mtliche EingabeausdrÃ¼cke an, die bis
     dahin erzeugt wurden.

     `playback(slow)' macht nach jeder Ausgabe eine Pause und wartet
     auf eine Eingabe. Dieses Verhalten ist vergleichbar mit `demo'.

     `playback(time)' zeigt fÃ¼r jeden Ausdruck die fÃ¼r die Berechnung
     benÃ¶tigte Zeit an.

     `playback(grind)' zeigt die EingabeausdrÃ¼cke in dem gleichen
     Format an wie die Funktion `grind'. AusgabeausdrÃ¼cke werden von
     der Option `grind' nicht beeinflusst. Siehe `grind'.

     Die Argumente kÃ¶nnen kombiniert werden, wie zum Beispiel im
     folgendenen Kommando `playback([5, 10], grind, time, slow)'.

     `playback' wertet die Argumente nicht aus. `playback' gibt stets
     `done' zurÃ¼ck.


 -- Optionsvariable: prompt
     Standardwert: `_'

     Die Optionsvariable `prompt' enthÃ¤lt das Zeichen fÃ¼r die
     Eingabeaufforderung der Funktionen `demo' und `playback' sowie
     nach einer Unterbrechung, wie zum Beispiel durch das Kommando
     `break'.


 -- Funktion: quit ()
     Das Kommando `quit()' beendet eine Maxima-Sitzung.

     Mit `control-C' kann in der Konsole die Verarbeitung abgebrochen
     werden.  StandardmÃ¤Ãig wird die Maxima-Sitzung fortgesetzt. Hat
     die globale Lisp-Variable `*debugger-hook*' den Wert `nil', wird
     der Lisp-Debugger gestartet. Siehe das Kapitel `Fehlersuche'.


 -- Funktion: reset ()
     `reset()' setzt globale Maxima- und Lisp-Variablen und Optionen
     auf ihre Standardwerte zurÃ¼ck. Maxima legt eine interne Liste mit
     den Standardwerten von globalen Variablen an. Alle Variablen, die
     in dieser Liste enthalten sind, werden auf ihre Standardwerte
     zurÃ¼ckgesetzt. Nicht alle globalen Variablen sind mit ihren
     Standwerten in diese Liste eingetragen. Daher kann `reset' die
     Anfangswerte stets nur unvollstÃ¤ndig wiederherstellen.

     `reset(<arg_1, ..., arg_n>)' setzt die Variablen <arg_1>, ...,
     <arg_n> auf ihren Standardwert zurÃ¼ck.

     `reset' gibt eine Liste mit den Variablen zurÃ¼ck, die auf ihren
     Standardwert zurÃ¼ckgesetzt wurden. Ist die Liste leer, wurden
     keine Variablen zurÃ¼ckgesetzt.

     Siehe auch `reset_verbosely'.


 -- Funktion: reset_verbosely ()
 -- Funktion: reset_verbosely (<arg_1>, ..., <arg_n>)
     Entspricht der Funktion `reset'. Im Unterschied zu `reset' wird zu
     jeder Variable, die zurÃ¼ckgesetzt wird, zusÃ¤tzlich der Standwert
     angezeigt.

     Siehe `reset'.


 -- Optionsvariable: showtime
     Standardwert: `false'

     Hat `showtime' den Wert `true', werden die interne Rechenzeit und
     die gesamte verstrichene Zeit zu jeder Ausgabe angezeigt.

     Die Rechenzeit wird unabhÃ¤ngig vom Wert der Optionsvariable
     `showtime' nach jeder Auswertung eines Ausdruckes in den
     Ausgabemarken abgespeichert.  Daher kÃ¶nnen die Funktionen `time'
     und `playback' die Rechenzeit auch dann anzeigen, wenn `showtime'
     den Wert `false' hat.

     Siehe auch `timer'.


 -- Funktion: system (<command>)
     `system(command)' fÃ¼hrt das Kommando <command> in einem eigenen
     Prozess aus. Das Kommando wird an die Standard-Shell Ã¼bergeben.
     `system' wird nicht von allen Betriebssystemen unterstÃ¼tzt, steht
     aber im Allgemeinen unter Unix oder Unix Ã¤hnlichen
     Betriebssystemen zur VerfÃ¼gung.


 -- Funktion: to_lisp ()
     Wechselt zu einer Lisp-Sitzung. `(to-maxima)' wechselt von der
     Lisp-Sitzung zurÃ¼ck in die Maxima-Sitzung.

     Beispiel:

     Definiere eine Funktion und wechsle zu Lisp. Die Definition wird
     von der Eigenschaftsliste gelesen. Dann wird die Defintion der
     Funktion geholt, faktorisiert und in der Variablen `$result'
     gespeichert. Die Variable kann nach der RÃ¼ckkehr in Maxima genutzt
     werden.

          (%i1) f(x):=x^2+x;
                                            2
          (%o1)                    f(x) := x  + x
          (%i2) to_lisp();
          Type (to-maxima) to restart, ($quit) to quit Maxima.
          MAXIMA> (symbol-plist '$f)
          (MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X)
                                       ((MPLUS) ((MEXPT) $X 2) $X))))
          MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
          ((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
          MAXIMA> (to-maxima)
          Returning to Maxima
          (%o2)                         true
          (%i3) result;
          (%o3)                       x (x + 1)


 -- Systemvariable: values
     Anfangswert: `[]'

     `values' ist eine Informationsliste, die die Variablen enthÃ¤lt,
     die vom Benutzer mit den Operatoren `:' oder `::' einen Wert
     erhalten haben.  Wird der Wert einer Variablen mit den Kommandos
     `kill', `remove' oder `remvalue' entfernt, wird die Variable von
     der Liste `values' entfernt.

     Siehe auch `functions'  fÃ¼r die Informationsliste mit den vom
     Benutzer definierten Funktionen sowie `infolists'.

     Beispiele:

          (%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                            2
          (%o1)                     [99, 9, 90, d, f(x) := x ]
          (%i2) values;
          (%o2)                              [a, b, c]
          (%i3) [kill(a), remove(b,value), remvalue(c)];
          (%o3)                          [done, done, [c]]
          (%i4) values;
          (%o4)                                 []



File: maxima.info,  Node: Funktionen und Variablen der Ausgabe,  Prev: Funktionen und Variablen der Eingabe,  Up: Kommandozeile

4.3 Funktionen und Variablen der Ausgabe
========================================

 -- Optionsvariable: %edispflag
     Standardwert: `false'

     Hat `%edispflag' den Wert `true', zeigt Maxima die Exponentiation
     von `%e' mit einen negativen Exponenten als Quotienten an.

     Beispiel:

          (%i1) %e^-10;
                                         - 10
          (%o1)                        %e
          (%i2) %edispflag:true$
          (%i3) %e^-10;
                                         1
          (%o3)                         ----
                                          10
                                        %e


 -- Optionsvariable: absboxchar
     Standardwert: `!'

     Die Optionsvariable `absboxchar' enthÃ¤lt das Zeichen, das benutzt
     wird, um den Betrag eines Ausdruckes anzuzeigen, der mehr als eine
     Zeile benÃ¶tigt.

     Beispiel:

          (%i1) abs((x^3+1));
                                      ! 3    !
          (%o1)                       !x  + 1!


 -- Funktion: disp (<expr_1>, <expr_2>, ...)
     Ist Ã¤hnlich wie die Funktion `display'. `disp' zeigt jedoch keine
     Gleichungen sondern nur die Ergebnisse der AusdrÃ¼cke <expr_1>,
     <expr_2>, ... an.

     Beispiele:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) disp(x, b[1,2], sin(1.0));
                                         123

                                            2
                                       x - x

                                  .8414709848078965

          (%o3)                         done


 -- Funktion: dispform (<expr>)
 -- Funktion: dispform (<expr>, all)
     `dispform' formatiert den Ausdruck <expr> von der internen
     Darstellung in eine externe Darstellung, wie sie fÃ¼r die Anzeige
     des Ausdrucks benÃ¶tigt wird. Bei der Formatierung sind
     Optionsvariablen wie `dispflag' und `powerdisp' wirksam.

     Beispiele fÃ¼r die interne und externe Darstellung von AusdrÃ¼cken
     sind:

                    Interne Darstellung            Externe Darstellung
          ------------------------------------------------------------
          -x      : ((MTIMES) -1 $x)               ((MMINUS) $x)
          sqrt(x) : ((MEXPT) $x ((RAT) 1 2))       ((%SQRT) $X)
          a/b     : ((MTIMES) $A ((MEXPT) $B -1))  ((MQUOTIENT) $A $B)

     `dispform(<expr>)' gibt die externe Darstellung nur fÃ¼r den ersten
     Operator im Ausdruck zurÃ¼ck. `dispform(<expr>, all)' gibt die
     externe Darstellung aller Operatoren im Ausdruck <expr> zurÃ¼ck.

     Siehe auch `part',  `inpart'  und `inflag'.

     Beispiel:

     Die Funktion `dispform' kann genutzt werden, um die Wurzelfunktion
     in einem Ausdruck zu substituieren. Die Wurzelfunktion ist nur in
     der externen Darstellung eines Ausdruckes vorhanden:

          (%i1) expr: sqrt(5)/(5+sqrt(2));
                                       sqrt(5)
          (%o1)                      -----------
                                     sqrt(2) + 5
          (%i2) subst(f,sqrt,expr);
                                       sqrt(5)
          (%o2)                      -----------
                                     sqrt(2) + 5
          (%i3) subst(f,sqrt,dispform(expr));
                                        f(5)
          (%o3)                      -----------
                                     sqrt(2) + 5
          (%i4) subst(f,sqrt,dispform(expr,all));
                                        f(5)
          (%o4)                       --------
                                      f(2) + 5


 -- Funktion: display (<expr_1>, <expr_2>, ...)
     Die Variablen oder AusdrÃ¼cke <expr_i> werden als eine Gleichung
     ausgegeben.  Die linke Seite der Gleichung ist die Variable oder
     der Ausdruck <expr_i> und die rechte Seite der Wert der Variablen
     oder das Ergebnis des Ausdrucks. Die Argumente kÃ¶nnen Variable,
     indizierte Variable oder Funktionen sein.

     Beispiele:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) display(x, b[1,2], sin(1.0));
                                       x = 123

                                                2
                                   b     = x - x
                                    1, 2

                            sin(1.0) = .8414709848078965

          (%o3)                         done


 -- Optionsvariable: display2d
     Standardwert: `true'

     Hat `display2d' den Wert `false', werden AusdrÃ¼cke auf der Konsole
     linear und nicht zweidimensional angezeigt.

     Beispiel:

          (%i1) x/(x^2+1);
                                         x
          (%o1)                        ------
                                        2
                                       x  + 1
          (%i2) display2d:false$
          (%i3) x/(x^2+1);
          (%o3) x/(x^2+1)


 -- Optionsvariable: display_format_internal
     Standardwert: `false'

     Hat `display_format_internal' den Wert `true', werden AusdrÃ¼cke fÃ¼r
     die Anzeige nicht in die externe Darstellung transformiert. Die
     Ausgabe erfolgt wie in der internen Darstellung. Das entspricht
     der RÃ¼ckgabe der Funktion `inpart'.

     Siehe die Funktion `dispform'  fÃ¼r Beispiele, die den Unterschied
     zwischen der internen und der externen Darstellung zeigen.


 -- Funktion: dispterms (<expr>)
     Der Ausdruck <expr> wird zeilenweise ausgegeben. Auf der ersten
     Zeile wird der Operator des Ausdrucks <expr> ausgegeben. Dann
     werden die Argumente des Operators zeilenweise ausgegeben. Dies
     kann nÃ¼tzlich sein, wenn ein Ausdruck sehr lang ist.

     Beispiel:

          (%i1) dispterms(2*a*sin(x)+%e^x);

          +

          2 a sin(x)

            x
          %e

          (%o1)                         done


 -- Spezielles Symbol: expt (<a>, <b>)
 -- Spezielles Symbol: ncexpt (<a>, <b>)
     Ist ein Exponentialausdruck zu lang, um ihn als `<a>^<b>'
     anzuzeigen, wird stattdessen `expt(<a>, <b>)' angezeigt.
     Entsprechend wird statt `<a>^^<b>', `ncexpt(<a>, <b>)' angezeigt.
     `expt' und `ncexpt' sind keine Funktionen und erscheinen nur in
     der Ausgabe.


 -- Optionsvariable: exptdispflag
     Standardwert: `true'

     Hat die Optionsvariable `exptdispflag' den Wert `true', werden
     AusdrÃ¼cke mit einem negativen Exponenten als Quotient angezeigt.

     Beispiele:

          (%i1) exptdispflag:true;
          (%o1)                         true
          (%i2) 10^-x;
                                          1
          (%o2)                          ---
                                           x
                                         10
          (%i3) exptdispflag:false;
          (%o3)                         false
          (%i4) 10^-x;
                                          - x
          (%o4)                         10


 -- Funktion: grind (<expr>)
 -- Optionsvariable: grind
     Die Funktion `grind' gibt den Ausdruck <expr> auf der Konsole in
     einer Form aus, die fÃ¼r die Eingabe in Maxima geeignet ist.
     `grind' gibt `done' zurÃ¼ck.

     Ist <expr> der Name einer Funktion oder eines Makros, gibt `grind'
     die Definition der Funktion oder des Makros aus.

     Siehe auch die Funktion `string',  die eine Zeichenkette
     zurÃ¼ckgibt, anstatt das Ergebnis auszugeben.

     Hat die Optionsvariable `grind' den Wert `true', haben die
     Ergebnisse der Funktionen `stringout' und `string' dasselbe Format
     wie die Funktion `grind'. Ansonsten werden keine spezielle
     Formatierungen von dieser Funktionen vorgenommen. Der Standardwert
     der Optionsvariablen `grind' ist `false.'

     `grind' kann auch ein Argument der Funktion `playback' sein. In
     diesem Fall gibt `playback' die Eingabe im gleichen Format wie die
     Funktion `grind' aus.

     `grind' wertet seine Argumente aus.

     Beispiele:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10


 -- Optionsvariable: ibase
     Standardwert: 10

     `ibase' ist die Basis der ganzen Zahlen, welche von Maxima
     eingelesen werden.

     `ibase' kann eine ganze Zahl zwischen 2 und einschlieÃlich 36
     zugewiesen werden. Ist `ibase' grÃ¶Ãer als 10, werden die Zahlen 0
     bis 9 und die Buchstaben A, B, C, ... fÃ¼r die Darstellung der Zahl
     in der Basis `ibase' herangezogen. GroÃe und kleine Buchstaben
     werden nicht unterschieden. Die erste Stelle muss immer eine
     Ziffer sein, damit Maxima den eingelesenen Ausdruck als eine Zahl
     interpretiert.

     Gleitkommazahlen werden immer zur Basis 10 interpretiert.

     Siehe auch `obase'.

     Beispiele:

     `ibase' ist kleiner als 10.

          (%i1) ibase : 2 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1111111111111111;
          (%o3)                         65535

     `ibase' ist grÃ¶Ãer als 10. Die erste Stelle muss eine Ziffer sein.

          (%i1) ibase : 16 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1000;
          (%o3)                         4096
          (%i4) abcd;
          (%o4)                         abcd
          (%i5) symbolp (abcd);
          (%o5)                         true
          (%i6) 0abcd;
          (%o6)                         43981
          (%i7) symbolp (0abcd);
          (%o7)                         false

     Wird eine ganze Zahl mit einer Dezimalpunkt beendet, wird die Zahl
     als Gleitkommazahl interpretiert.

          (%i1) ibase : 36 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1234;
          (%o3)                         49360
          (%i4) 1234.;
          (%o4)                         1234


 -- Funktion: ldisp (<expr_1>, ..., <expr_n>)
     Die AusdrÃ¼cke <expr_1>, ..., <expr_n> werden auf der Konsole
     ausgegeben. Dabei wird jedem Ausdruck eine Zwischenmarke
     zugewiesen. Die Liste der Zwischenmarken wird als Ergebnis
     zurÃ¼ckgegeben.

     Siehe auch `disp'  und `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Funktion: ldisplay (<expr_1>, ..., <expr_n>)
     Die AusdrÃ¼cke <expr_1>, ..., <expr_n> werden als eine Gleichung
     der Form `lhs = rhs' ausgegeben. `lhs' ist eines der Argumente der
     Funktion `ldisplay' und `rhs' ist der Wert oder das Ergebis des
     Argumentes. Im Unterschied zur Funktion `display' wird jeder
     Gleichung eine Zwischenmarke zugewiesen, die als Liste
     zurÃ¼ckgegeben werden.

     Siehe auch `display',  `disp'  und `ldisp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Optionsvariable: linel
     Standardwert: 79

     Die Optionsvariable `linel' enthÃ¤lt die Anzahl der Zeichen einer
     Zeile der Ausgabe. `linel' kÃ¶nnen beliebige positive ganze Zahlen
     zugewiesen werden, wobei sehr kleine oder groÃe Werte unpraktisch
     sein kÃ¶nnen. Text, der von internen Funktionen ausgegeben wird,
     wie Fehlermeldungen oder Ausgaben der Hilfe, werden von `linel'
     nicht beeinflusst.


 -- Optionsvariable: lispdisp
     Standardwert: `false'

     Hat die Optionsvariable `lispdisp' den Wert `true', werden
     Lisp-Symbole mit einem vorangestelltem Fragezeichen `?' angezeigt.

     Beispiele:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Optionsvariable: negsumdispflag
     Standardwert: `true'

     Hat `negsumdispflag' den Wert `true', wird eine Differenz mit zwei
     Argumenten `x - y' als `x - y' und nicht als `-y + x' angezeigt.
     Ist das Flag `false' wird die Differenz als `-y + x' angezeigt.


 -- Optionsvariable: obase
     Standardwert: 10

     `obase' ist die Basis fÃ¼r ganze Zahlen fÃ¼r die Ausgabe von Maxima.

     `obase' kann eine ganze Zahl zwischen 2 und einschlieÃlich 36
     zugewiesen werden. Ist `obase' grÃ¶Ãer als 10, werden die Zahlen 0
     bis 9 und die Buchstaben A, B, C, ... fÃ¼r die Darstellung der Zahl
     in der Basis `obase' herangezogen. GroÃe und kleine Buchstaben
     werden nicht unterschieden. Die erste Stelle muss immer eine
     Ziffer sein, damit Maxima den eingelesenen Ausdruck als eine Zahl
     interpretiert.

     Siehe auch `ibase'.

     Beispiele:

          (%i1) obase : 2;
          (%o1)                          10
          (%i2) 2^8 - 1;
          (%o10)                      11111111
          (%i3) obase : 8;
          (%o3)                          10
          (%i4) 8^8 - 1;
          (%o4)                       77777777
          (%i5) obase : 16;
          (%o5)                          10
          (%i6) 16^8 - 1;
          (%o6)                       0FFFFFFFF
          (%i7) obase : 36;
          (%o7)                          10
          (%i8) 36^8 - 1;
          (%o8)                       0ZZZZZZZZ


 -- Optionsvariable: pfeformat
     Standardwert: `false'

     Hat die Optionsvariable `pfeformat' den Wert `true', werden BrÃ¼che
     mit ganzen Zahlen auf einer Zeile mit dem Zeichen `/' dargestellt.
     Ist der Nenner eine ganze Zahl, wird dieser als `1/n' vor den
     Ausdruck gestellt.

     Beispiele:

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Funktion: print (<expr_1>, ..., <expr_n>)
     Wertet die Argumente <expr_1>, ..., <expr_n> nacheinander von
     links nach rechts aus und zeigt die Ergebnisse an. `print' gibt
     das Ergebnis des letzten Arguments als Ergebnis zurÃ¼ck. `print'
     erzeugt keine Zwischenmarken.

     Siehe auch `display',  `disp',  `ldisplay'  und `ldisp'.   Siehe
     `printfile',  um den Inhalt einer Datei anzuzeigen.

     Beispiele:

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Funktion: read (<expr_1>, ..., <expr_n>)
     Gibt die AusdrÃ¼cke <expr_1>, ... <expr_n> auf der Konsole aus,
     liest sodann einen Ausdruck von der Konsole ein und wertet diesen
     aus. Die Eingabe des Ausdrucks wird mit den Zeichen `;' oder `$'
     beendet.

     Siehe auch `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Funktion: readonly (<expr_1>, ..., <expr_n>)
     Gibt die AusdrÃ¼cke <expr_1>, ... <expr_n> auf der Konsole aus,
     liest sodann einen Ausdruck von der Konsole ein und gibt den
     eingelesenen Ausdruck zurÃ¼ck ohne diesen auszuwerten. Die Eingabe
     des Ausdrucks wird mit den Zeichen `;' oder `$' beendet.

     Siehe auch `read'.

          (%i1) aa: 7$
          (%i2) foo: readonly ("Enter an expression:");
          Enter an expression:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Enter an expression:");
          Enter an expression:
          2^aa;
          (%o3)                            128


 -- Optionsvariable: sqrtdispflag
     Standardwert: `true'

     Hat die Optionsvariable den Wert `false', wird die Wurzelfunktion
     als Exponentation mit dem Exponenten 1/2 angezeigt.


 -- Optionsvariable: stardisp
     Standardwert: `false'

     Hat die Optionsvariable `stardisp' den Wert `true', wird die
     Multiplikation mit einem Stern `*' angezeigt.


 -- Optionsvariable: ttyoff
     Standardwert: `false'

     Hat die Optionsvariable `ttyoff' den Wert `true', werden Ergebnisse
     nicht angezeigt. Die Ergebnisse werden weiter berechnet und sie
     werden Marken zugewiesen. Siehe `labels'.

     Textausgaben von internen Funktionen, wie Fehlermeldungen und
     Ausgaben der Hilfe mit `describe' werden nicht beeinflusst.



File: maxima.info,  Node: Datentypen und -strukturen,  Next: AusdrÃ¼cke,  Prev: Kommandozeile,  Up: Top

5 Datentypen und -strukturen
****************************

* Menu:

* EinfÃ¼hrung in Maxima Zahlen::
* Zeichenketten::
* Funktionen und Variablen fÃ¼r Zahlen::
* Funktionen und Variablen fÃ¼r Zeichenketten::
* Funktionen und Variablen fÃ¼r Konstante::
* Funktionen und Variablen fÃ¼r Arrays::
* EinfÃ¼hrung in Listen::
* Funktionen und Variablen fÃ¼r Listen::


File: maxima.info,  Node: EinfÃ¼hrung in Maxima Zahlen,  Next: Zeichenketten,  Prev: Datentypen und -strukturen,  Up: Datentypen und -strukturen

5.1 EinfÃ¼hrung in Maxima Zahlen
================================

Ganze und rationale Zahlen
--------------------------

Arithmetische Rechnungen mit ganzen oder rationalen Zahlen sind exakt.
Prinzipell kÃ¶nnen die ganzen und rationalen Zahlen eine beliebige
Anzahl an Stellen haben. Eine Obergrenze ist allein der zur VerfÃ¼gung
stehende Speicherplatz.

     (%i1) 1/3+5/4+3;
                                    55
     (%o1)                          --
                                    12
     (%i2) 100!;
     (%o2) 9332621544394415268169923885626670049071596826438162146859\
     2963895217599993229915608941463976156518286253697920827223758251\
     185210916864000000000000000000000000
     (%i3) 100!/101!;
                                     1
     (%o3)                          ---
                                    101

   Funktionen fÃ¼r ganze und rationale Zahlen:

   integerp       numberp       nonnegintegerp
   oddp           evenp
   ratnump        rationalize

Gleitkommazahlen
----------------

Maxima rechnet mit Gleitkommazahlen in doppelter Genauigkeit. Weiterhin
kann Maxima mit groÃen Gleitkommazahlen rechnen, die prinzipell eine
beliebige Genauigkeit haben.

   Gleitkommazahlen werden mit einem Dezimalpunkt eingegeben. Der
Exponent kann mit "f", "e" oder "d" angegeben werden. Intern rechnet
Maxima ausschlieÃlich mit Gleitkommazahlen in doppelter Genauigkeit,
die immer mit "e" fÃ¼r den Exponenten angezeigt werden. GroÃe
Gleitkommazahlen werden mit dem Exponenten "b" bezeichnet. GroÃ- und
Kleinschreibung werden bei der Schreibweise des Exponenten nicht
unterschieden.

     (%i1) [2.0,1f10,1,e10,1d10,1d300];
     (%o1)        [2.0, 1.e+10, 1, e10, 1.e+10, 1.e+300]
     (%i2) [2.0b0,1b10,1b300];
     (%o2)               [2.0b0, 1.0b10, 1.0b300]

Ist mindestens eine Zahl in einer Rechnung eine Gleitkommazahl, werden
die Argumente in Gleitkommazahlen umgewandelt und eine Gleitkommazahl
als Ergebnis zurÃ¼ckgegeben. Dies wird auch fÃ¼r groÃe Gleitkommazahlen
ausgefÃ¼hrt.

     (%i1) 2.0+1/2+3;
     (%o1)                                 5.5
     (%i2) 2.0b0+1/2+3;
     (%o2)                                5.5b0

Mit den Funktionen `float' und `bfloat' werden Zahlen in
Gleitkommazahlen und groÃe Gleitkommazahlen umgewandelt:

     (%i1) float([2,1/2,1/3,2.0b0]);
     (%o1)          [2.0, 0.5, .3333333333333333, 2.0]
     (%i2) bfloat([2,1/2,1/3,2.0b0]);
     (%o2)     [2.0b0, 5.0b-1, 3.333333333333333b-1, 2.0b0]

Funktionen und Variablen fÃ¼r Gleitkommazahlen:

   float        floatnump
   bfloat       bfloatp       fpprec
   float2bf     bftorat       ratepsilon

   number_pbranch
   m1pbranch

Komplexe Zahlen
---------------

Maxima kennt keinen eigenen Typ fÃ¼r komplexe Zahlen. Komplexe Zahlen
werden von Maxima intern als die Addition von Realteil und dem mit der
ImaginÃ¤ren Einheit `%i' multiplizierten ImaginÃ¤rteil dargestellt. Zum
Beispiel sind die komplexen Zahlen `2 + 3*%i' und `2 - 3*%i' die
Wurzeln der Gleichung `x^2 - 4*x + 13 = 0'.

   Maxima vereinfacht Produkte, Quotienten, Wurzel und andere AusdrÃ¼cke
mit komplexen Zahlen nicht automatisch zu einer komplexen Zahl. Um
Produkte mit komplexen Zahlen zu vereinfachen, kann der Ausdruck mit
der Funktion `expand' expandiert werden.

   Funktionen fÃ¼r komplexe Zahlen:

   realpart     imagpart      rectform     polarform
   cabs         carg          conjugate    csign


File: maxima.info,  Node: Zeichenketten,  Next: Funktionen und Variablen fÃ¼r Zahlen,  Prev: EinfÃ¼hrung in Maxima Zahlen,  Up: Datentypen und -strukturen

5.2 Zeichenketten
=================

Zeichenketten werden bei der Eingabe in AnfÃ¼hrungszeichen gesetzt. Sie
werden standardmÃ¤Ãig ohne AnfÃ¼hrungszeichen ausgegeben. Hat die
Optionsvariable `stringdisp' den Wert `true', werden Zeichenketten mit
AnfÃ¼hrungszeichen dargestellt.

   Zeichenketten kÃ¶nnen jedes Zeichen einschlieÃlich Tabulator-,
Zeilenvorschub- oder WagenrÃ¼cklauf-Zeichen enthalten. Das
AnfÃ¼hrungszeichen wird innerhalb einer Zeichenkette durch `\"' und der
Backslash durch `\\' dargestellt. Ein Backslash am Ende einer
Eingabezeile erlaubt die Fortsetzung einer Zeichenkette in der nÃ¤chsten
Zeile. Maxima kennt keine weiteren Kombinationen mit einem Backslash.
Daher wird der Backslash an anderer Stelle ignoriert. Maxima kennt
keine andere MÃ¶glichkeit, als spezielle Zeichen wie ein Tabulator-,
Zeilenvorschub- oder WagenrÃ¼cklaufzeichen in einer Zeichenkette
darzustellen.

   Maxima hat keinen Typ fÃ¼r ein einzelnes Zeichen. Einzelne Zeichen
werden daher als eine Zeichenkette mit einem Zeichen dargestellt.
Folgende Funktionen und Variablen arbeiten mit Zeichenketten:

   concat   sconcat   string   stringdisp

Das Zusatzpaket `stringproc' enthÃ¤lt eine umfangreiche Bibliothek an
Funktionen fÃ¼r Zeichenketten.

   Beispiele:

     (%i1) s_1 : "This is a string.";
     (%o1)               This is a string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)                   This is a string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)                  "This is a string."


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Zahlen,  Next: Funktionen und Variablen fÃ¼r Zeichenketten,  Prev: Zeichenketten,  Up: Datentypen und -strukturen

5.3 Funktionen und Variablen fÃ¼r Zahlen
========================================

 -- Funktion: bfloat (<expr>)
     Konvertiert alle Zahlen im Ausdruck <expr> in groÃe
     Gleitkommazahlen.  Die Anzahl der Stellen wird durch die
     Optionsvariable `fpprec'  spezifiziert.

     Hat die Optionsvariable `float2bf'  den Wert `false', gibt Maxima
     eine Warnung aus, wenn eine Gleitkommazahl mit doppelter
     Genauigkeit in eine groÃe Gleitkommazahl umgewandelt wird.


 -- Funktion: bfloatp (<expr>)
     Gibt den Wert `true' zurÃ¼ck, wenn <expr> eine groÃe Gleitkommazahl
     ist, ansonsten den Wert `false'.


 -- Optionsvariable: bftorat
     Standartwert: `false'

     Die Optionsvariable `bftorat' kontrolliert die Umwandlung von
     groÃen Gleitkommazahlen in rationale Zahlen. Hat `bftorat' den
     Wert `true', wird die Genauigkeit der Umwandlung von der
     Optionsvariablen `ratepsilon'   kontrolliert. In diesem Fall ist
     das Ergebnis der Umwandlung eine relativ kleine rationale Zahl.
     Hat dagegen `bftorat' den Wert `false', wird die groÃe
     Gleitkommazahl exakt durch die rationale Zahl reprÃ¤sentiert.


 -- Optionsvariable: bftrunc
     Standardwert: `true'

     Hat die Optionsvariable `bftrunc' den Wert `true', werden bei der
     Ausgabe einer groÃen Gleitkommazahl nachfolgende Nullen nicht
     angezeigt. So wird `bfloat(1)' als `1.000000000000000b0'
     angezeigt, wenn `bftrunc' den Wert `false' hat, ansonsten wird
     `1.0b0' angezeigt.


 -- Funktion: evenp (<expr>)
     Ist <expr> eine gerade ganze Zahl, wird `true' zurÃ¼ckgegeben. In
     allen anderen FÃ¤llen wird `false' zurÃ¼ckgegeben.

     `evenp' gibt fÃ¼r Symbole oder AusdrÃ¼cke immer den Wert `false'
     zurÃ¼ck, auch wenn das Symbol als gerade ganze Zahl deklariert ist
     oder der Ausdruck eine gerade ganze Zahl reprÃ¤sentiert.

     Siehe die Funktion `featurep',  um zu testen, ob ein Symbol oder
     Ausdruck eine gerade ganze Zahl reprÃ¤sentiert.


 -- Funktion: float (<expr>)
 -- Auswertungsschalter: float
     Konvertiert ganze, rationale und groÃe Gleitkommazahlen im Ausdruck
     <expr> in Gleitkommazahlen mit doppelter Genauigkeit.

     `float' ist auch ein Auswertungsschalter fÃ¼r die Funktion `ev'. In
     diesem Fall werden rationale Zahlen und groÃe Gleitkommazahlen,
     aber keine ganzen Zahlen in Gleitkommazahlen umgewandelt. Daher
     haben die beiden Kommandos `ev(expr),float' und `float(expr)' ein
     unterschiedliches Ergebnis.

     Beispiele:

     In den ersten zwei Beispielen werden die Zahlen `1/2' und `1' in
     eine Gleitkommazahl umgewandelt. Die Sinusfunktion vereinfacht
     sodann zu einem numerischen Wert. Das Auswertungsflag `float'
     wandelt ganze Zahlen nicht in eine Gleitkommazahl um. Daher wird
     `sin(1)' nicht zu einem numerischen Wert vereinfacht.

          (%i1) float(sin(1/2));
          (%o1)                   0.479425538604203
          (%i2) float(sin(1));
          (%o2)                   .8414709848078965
          (%i3) sin(1/2),float;
          (%o3)                   0.479425538604203
          (%i4) sin(1),float;
          (%o4)                        sin(1)


 -- Optionsvariable: float2bf
     Standardwert: `true'

     Hat die Optionsvariable `float2bf' den Wert `false', wird eine
     Warnung ausgegeben, wenn eine Gleitkommazahl in eine groÃe
     Gleitkommazahl umgewandelt wird, da die Umwandlung zu einem
     Verlust an Genauigkeit fÃ¼hren kann.


 -- Funktion: floatnump (<number>)
     Gibt den Wert `true' zurÃ¼ck, wenn das Argument <number> eine
     Gleitkommazahl ist. Ansonsten wird `false' zurÃ¼ckgegeben. Auch wenn
     <number> eine groÃe Gleitkommazahl ist, ist das Ergebnis `false'.


 -- Optionsvariable: fpprec
     Standardwert: 16

     `ffprec' ist die Zahl der Stellen fÃ¼r das Rechnen mit groÃen
     Gleitkommazahlen. `ffprec' hat keinen EinfluÃ auf das Rechnen mit
     Gleitkommazahlen in doppelter Genauigkeit. Siehe auch `bfloat'  und
     `fpprintprec'.


 -- Optionsvariable: fpprintprec
     Standardwert: 0

     `fpprintprec' ist die Anzahl der Stellen, die angezeigt wird, wenn
     eine Gleitkommazahl ausgegeben wird.

     Hat `fpprintprec' einen Wert zwischen 2 und 16, ist die Anzahl der
     angezeigten Stellen fÃ¼r einfache Gleitkommazahlen gleich dem Wert
     von `fpprintprec'. Hat `fpprintprec' den Wert 0 oder ist grÃ¶Ãer als
     16 werden 16 Stellen angezeigt.

     FÃ¼r groÃe Gleitkommazahlen ist die Anzahl der angezeigten Stellen
     gleich `fpprintprec', wenn `fpprintprec' einen Wert zwischen 2 und
     `fpprec' hat. Ist der Wert von `fpprintprec' gleich 0 oder grÃ¶Ãer
     als `fpprec' werden `fpprec' Stellen angezeigt.

     `fpprintprec' kann nicht den Wert 1 erhalten.


 -- Funktion: integerp (<number>)
     Hat den RÃ¼ckgabewert `true', wenn das Argument <number> eine ganze
     Zahl ist. In allen anderen FÃ¤llen gibt `integerp' den Wert `false'
     zurÃ¼ck.

     `integerp' gibt fÃ¼r Symbole oder AusdrÃ¼cke immer den Wert `false'
     zurÃ¼ck, auch wenn das Symbol als ganze Zahl deklariert ist oder
     der Ausdruck eine ganze Zahl reprÃ¤sentiert. Siehe die Funktion
     `featurep',  um zu testen, ob ein Symbol oder Ausdruck eine ganze
     Zahl reprÃ¤sentiert.

     Beispiele:

          (%i1) integerp (1);
          (%o1)                         true
          (%i2) integerp (1.0);
          (%o2)                         false
          (%i3) integerp (%pi);
          (%o3)                         false
          (%i4) declare (n, integer)$
          (%i5) integerp (n);
          (%o5)                         false


 -- Optionsvariable: m1pbranch
     Standardwert: `false'

     Die Optionsvariable `m1branch' kontrolliert die Vereinfachung der
     Exponentiation von `-1' fÃ¼r den Fall, dass die Optionsvariable
     `domain' den Wert `complex' hat. Hat `m1pbranch' fÃ¼r diesen Fall
     den Wert `true', wird die Exponentiation von `-1' zu einem
     Ausdruck vereinfacht, der dem Hauptwert entspricht. Die Auswirkung
     der Optionsvariable `m1pbranch' ist in der folgenden Tabelle
     gezeigt.

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

     Siehe auch die Optionsvariable `number_pbranch'.


 -- Funktion: nonnegintegerp (<number>)
     Gibt den Wert `true' zurÃ¼ck, wenn `var' eine ganze positive Zahl
     oder Null ist. Siehe auch `integerp'.


 -- Funktion: numberp (<expr>)
     Hat das Ergebnis `true', wenn <expr> eine ganze, rationale, eine
     Gleitkommazahl oder eine groÃe Gleitkommazahl ist. Ansonsten ist
     das Ergebnis `false'.

     `numberp' gibt fÃ¼r ein Symbol immer das Ergebnis `false' zurÃ¼ck.
     Dies ist auch dann der Fall, wenn das Symbol eine numerische
     Konstante wie `%pi' ist oder wenn das Symbol eine Deklaration wie
     `integer', `real' oder `complex' erhalten hat.

     Beispiele:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare(a,even,b,odd,c,integer,d,rational,e,real);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e]);
          (%o7) [false, false, false, false, false]


 -- Optionsvariable: numer_pbranch
     Standardwert: `false'

     Die Optionsvariable `numer_pbranch' kontrolliert die Vereinfachung
     der Exponentiation einer negativen ganzen, rationalen oder
     Gleitkommazahl.  Hat `numer_pbranch' den Wert `true' und ist der
     Exponent eine Gleitkommazahl oder hat die Optionsvariable `numer'
     den Wert `true', dann berechnet Maxima den Hauptwert der
     Exponentiation. Ansonsten wird ein vereinfachter Ausdruck, aber
     nicht numerischer Wert zurÃ¼ckgegeben. Siehe auch die
     Optionsvariable `m1pbranch'.

     Beispiele:

          (%i1) (-2)^0.75;
          (%o1) (-2)^0.75

          (%i2) (-2)^0.75,numer_pbranch:true;
          (%o2) 1.189207115002721*%i-1.189207115002721

          (%i3) (-2)^(3/4);
          (%o3) (-1)^(3/4)*2^(3/4)

          (%i4) (-2)^(3/4),numer;
          (%o4) 1.681792830507429*(-1)^0.75

          (%i5) (-2)^(3/4),numer,numer_pbranch:true;
          (%o5) 1.189207115002721*%i-1.189207115002721


 -- Funktion: oddp (<expr>)
     Gibt `true' zurÃ¼ck, wenn <expr> eine ungerade ganze Zahl ist. In
     allen anderen FÃ¤llen wird `false' zurÃ¼ckgegeben.

     `oddp' gibt fÃ¼r Symbole oder AusdrÃ¼cke immer den Wert `false'
     zurÃ¼ck, auch wenn das Symbol als ungerade ganze Zahl deklariert
     ist oder der Ausdruck eine ungerade ganze Zahl reprÃ¤sentiert.
     Siehe die Funktion `featurep',  um zu testen, ob ein Symbol oder
     Ausdruck eine ungerade ganze Zahl reprÃ¤sentiert.


 -- Optionsvariable: ratepsilon
     Standardwert: 2.0e-8

     `ratepsilon' kontrolliert die Genauigkeit, mit der
     Gleitkommazahlen in rationale Zahlen umgewandelt werden. Siehe
     auch `bftorat'.


 -- Funktion: rationalize (<expr>)
     Konvertiert alle Gleitkommazahlen einschlieÃlich groÃer
     Gleitkommazahlen, die in dem Ausdruck <expr> auftreten, in
     rationale Zahlen.

     Es mag Ã¼berraschend sein, dass `rationalize(0.1)' nicht 1/10
     ergibt. Dies ist nicht speziell fÃ¼r Maxima. Ursache ist, dass die
     gebrochene Zahl 1/10 in der internen Darstellung als binÃ¤re Zahl
     keine endliche Darstellung hat.

     Siehe auch die Funktion `float'  und den Auswertungsschalter
     `numer',  um eine rationale Zahl in eine Gleitkommazahl
     umzuwandeln.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                  3602879701896397
          (%o2)                   -----------------
                                  36028797018963968
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                         3602879701896397 x   3152519739159347
          (%o7)      sin(------------------ + ----------------)
                         36028797018963968    562949953421312

          (%i8) float(%);
          (%o8)                          sin(0.1 x + 5.6)


 -- Funktion: ratnump (<number>)
     Gibt `true' zurÃ¼ck, wenn <number> eine ganze oder rationale Zahl
     ist.  In allen anderen FÃ¤llen ist das Ergebnis `false'.

     Beispiele:

          (%i1) ratnump(1/2);
          (%o1)                         true
          (%i2) ratnump(3);
          (%o2)                         true
          (%i3) ratnump(3.0);
          (%o3)                         false



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Zeichenketten,  Next: Funktionen und Variablen fÃ¼r Konstante,  Prev: Funktionen und Variablen fÃ¼r Zahlen,  Up: Datentypen und -strukturen

5.4 Funktionen und Variablen fÃ¼r Zeichenketten
===============================================

 -- Funktion: concat (<arg_1>, <arg_2>, ...)
     Verkettet die Argumente <arg_1>, <arg_2>, ... zu einer
     Zeichenkette oder einem Symbol. Die Argumente mÃ¼ssen sich zu einem
     Atom auswerten lassen. Der RÃ¼ckgabewert ist ein Symbol, wenn das
     erste Argument ein Symbol ist. Ansonsten wird eine Zeichenkette
     zurÃ¼ckgegeben.

     `concat' wertet seine Argumente aus. Der Quote-Operator verhindert
     die Auswertung. Siehe auch die Funktion `sconcat'.

     Beispiele:

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) stringdisp:true$
          (%i4) concat(y, z/2);
          (%o4)                         "744"
          (%i5) concat('y, z/2);
          (%o5)                          y44

     Einem Symbol, das mit `concat' konstruiert wird, kann ein Wert
     zugewiesen werden und es kann in AusdrÃ¼cken auftreten.

          (%i6) a: concat ('y, z/2);
          (%o6)                          y44
          (%i7) a:: 123;
          (%o7)                          123
          (%i8) y44;
          (%o8)                          123
          (%i9) b^a;
                                         y44
          (%o9)                         b
          (%i10) %, numer;
                                          123
          (%o11)                         b

     `concat(1, 2)' gibt eine Zeichenkette als Ergebnis zurÃ¼ck.

          (%i12) concat (1, 2) + 3;
          (%o12)                       "12" + 3


 -- Funktion: sconcat (<arg_1>, <arg_2>, ...)
     Verkettet die Argumente zu einer Zeichenkette. Im Unterschied zu
     der Funktion `concat'  mÃ¼ssen die Argumente nicht Atome sein. Der
     RÃ¼ckgabewert ist eine Zeichenkette.

     Beispiel:

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Funktion: string (<expr>)
     Konvertiert `expr' in eine linearer Darstellung, wie sie auch vom
     Parser von der Eingabe eingelesen wird. Die RÃ¼ckgabe von `string'
     ist eine Zeichenkette. Diese kann nicht fÃ¼r eine Berechnung
     genutzt werden.


 -- Optionsvariable: stringdisp
     Standardwert: `false'

     Hat `stringdisp' den Wert `true', werden Zeichenketten mit
     AnfÃ¼hrungszeichen ausgegeben. Ansonsten werden keine
     AnfÃ¼hrungszeichen ausgegeben.

     Wird die Definition einer Funktion ausgegeben, werden enthaltene
     Zeichenketten unabhÃ¤ngig vom Wert der Optionsvariablen
     `stringdisp' immer in AnfÃ¼hrungszeichen ausgegeben.

     Beispiele:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Konstante,  Next: Funktionen und Variablen fÃ¼r Arrays,  Prev: Funktionen und Variablen fÃ¼r Zeichenketten,  Up: Datentypen und -strukturen

5.5 Funktionen und Variablen fÃ¼r Konstante
===========================================

 -- Konstante: %e
     `%e' ist die Basis des natÃ¼rlichen Logarithmus, auch Eulersche Zahl
     genannt. Der numerische Wert der Konstanten als Gleitkommazahl mit
     doppelter Genauigkeit ist 2.718281828459045d0.

     Die Funktion `bfloat'  kann `%e' mit einer beliebigen Genauigkeit
     berechnen.

     Beispiel:

          (%i1) fpprec:48$
          (%i2) bfloat(%e);
          (%o2)  2.7182818284590452353602874713526624977572470937b0


 -- Konstante: %i
     `%i' ist die imaginÃ¤re Einheit.


 -- Konstante: false
     ReprÃ¤sentiert den Logischen Wert `falsch'. `false' wird intern von
     Maxima durch die Lisp-Konstante `NIL' dargestellt.


 -- Konstante: %gamma
     Die Euler-Mascheroni-Konstante mit dem Wert `0.5772156649015329'
     als Gleitkommazahl in doppelter Genauigkeit.

     Die Funktion `bfloat'  kann `%gamma' mit einer beliebigen
     Genauigkeit berechnen.


 -- Konstante: ind
     `ind' reprÃ¤sentiert ein unbestimmtes Ergebnis. Siehe auch `limit'.

     Beispiel:

          (%i1) limit (sin(1/x), x, 0);
          (%o1)                          ind


 -- Konstante: inf
     `inf' reprÃ¤sentiert einen positiven unendlich groÃen Wert.


 -- Konstante: infinity
     `infinity' reprÃ¤sentiert einen komplexen unendlichen Wert.


 -- Konstante: minf
     `minf' reprÃ¤sentiert einen negativen unendlichen Wert.


 -- Konstante: %phi
     `%phi' reprÃ¤sentiert die Golde Zahl (1 + sqrt(5))/2. Der
     Gleitkommawert in doppelter Genauigkeit ist 1.618033988749895d0.

     Die Funktion `fibtophi' drÃ¼ckt Fibonacci-Zahlen `fib(n)' durch
     `%phi' aus. StandardmÃ¤Ãig kennt Maxima keine algebraischen
     Eigenschaften der Konstanten `%phi'. Mit den Eingaben
     `tellrat(%phi^2-%phi-1)' und `algebraic: true' kann die Funktion
     `ratsimp' einige Vereinfachungen ausfÃ¼hren.

     Beispiele:

     `fibtophi' drÃ¼ckt Fibonacci-Zahlen `fib(n)' durch `%phi' aus.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Mit den Eingaben `tellrat(%phi^2-%phi-1)' und `algebraic: true'
     kann die Funktion `ratsimp' einige Vereinfachungen fÃ¼r AusdrÃ¼cke
     ausfÃ¼hren, die `%phi' enthalten.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0


 -- Konstante: %pi
     `%pi' reprÃ¤sentiert die Kreiszahl. Der numerische Wert in doppelter
     Gleitkommagenauigkeit ist `3.141592653589793d0'.

     Die Funktion `bfloat'  kann `%pi' mit einer beliebigen Genauigkeit
     berechnen.


 -- Konstante: true
     `true' reprÃ¤sentiert den logischen Wert `wahr'. Intern ist `true'
     als die Lisp-Konstante `T' implementiert.


 -- Konstante: und
     `und' reprÃ¤sentiert ein nicht definiertes Ergebnis. Siehe auch
     `limit'.

     Beispiel:

          (%i1) limit (x*sin(x), x, inf);
          (%o1)                          und


 -- Konstante: zeroa
     `zeroa' reprÃ¤sentiert eine positive unendlich kleine Zahl. `zeroa'
     kann in AusdrÃ¼cken benutzt werden. Die Funktion `limit' vereinfacht
     AusdrÃ¼cke, die infinitesimale GrÃ¶Ãen enthalten.

     Siehe auch `zerob'  und `limit'.

     Beispiele:

     `limit' vereinfacht AusdrÃ¼cke, die infinitesimale GrÃ¶Ãen enthalten:

          (%i1) limit(zeroa);
          (%o1)                           0
          (%i2) limit(x+zeroa);
          (%o2)                           x


 -- Konstante: zerob
     `zerob' reprÃ¤sentiert eine negative unendlich kleine Zahl. `zerob'
     kann in AusdrÃ¼cken benutzt werden. Die Funktion `limit' vereinfacht
     AusdrÃ¼cke, die infinitesimale GrÃ¶Ãen enthalten.

     Siehe auch `zeroa'  und `limit'.



File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Arrays,  Next: EinfÃ¼hrung in Listen,  Prev: Funktionen und Variablen fÃ¼r Konstante,  Up: Datentypen und -strukturen

5.6 Funktionen und Variablen fÃ¼r Arrays
========================================

 -- Funktion: array (<name>, <dim_1>, ..., <dim_n>)
 -- Funktion: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Funktion: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)
     Erzeugt ein n-dimensionales Array. n kann kleiner oder gleich 5
     Dimensionen sein. Die Indizes der i-ten Dimension sind ganze Zahlen
     in einem Bereich von 0 bis <dim_i>.

     `array(<name>, <dim_1>, ... <dim_n>)' erzeugt ein allgemeines
     Array.

     `array(<name>, <type>, <dim_1>, ..., <dim_n>)' erzeugt ein Array
     mit Elementen, die vom Typ <type> sind. <type> kann `fixnum' fÃ¼r
     ganze Zahlen oder `flonum' fÃ¼r Gleitkommazahlen sein.

     `array([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)' erzeugt
     m Arrays, die alle die gleiche Dimension haben.

     Wird einer indizierten Variablen ein Wert zugewiesen, bevor das
     entsprechende Array definiert wird, so wird ein undeklariertes
     Array erzeugt. Undeklarierte Arrays, auch Hashed-Arrays genannt,
     sind allgemeiner als deklarierte Arrays.  Diese Arrays haben keine
     feste GrÃ¶Ãe und wachsen dynamisch mit der Zuweisung von Werten.
     Der Indizes eines undeklarierten Arrays mÃ¼ssen keine ganze Zahlen
     sein. Jedoch sind deklarierte Arrays im Allgemeinen effizienter,
     so dass Arrays falls mÃ¶glich deklariert werden sollten. Die
     Funktion `array' kann genutzt werden, um ein undeklariertes Array
     in ein deklariertes Array umzuwandeln.


 -- Funktion: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Wertet `<A> [<i_1>, ..., <i_n>]' aus, wobei <A> ein Array ist und
     <i_1>, ..., <i_n> sind ganze Zahlen.

     `arrayapply' entspricht der Funktion `apply', wobei in diesem Fall
     das Argument ein Array und keine Funktion ist.


 -- Funktion: arrayinfo (<A>)
     Gibt Information Ã¼ber das Array <A> zurÃ¼ck. Das Argument <A> kann
     ein deklariertes oder ein undeklariertes Array sowie eine
     Array-Funktion oder eine indizierte Funktion sein.

     FÃ¼r ein deklarierte Array gibt `arryinfo' eine Liste zurÃ¼ck, die
     `declared', die Zahl der Dimensionen und die GrÃ¶Ãe der Dimensionen
     enhÃ¤lt. Die Elemente des Arrays werden von der Funktion `listarray'
     zurÃ¼ckgegeben.

     FÃ¼r ein undeklariertes Array (Hashed-Array) gibt `arrayinfo' eine
     Liste zurÃ¼ck, die `hashed', die Zahl der Indizes und die Indizes
     enthÃ¤lt, deren Elemente einen Wert haben. Die Werte der Elemente
     werden mit der Funktion `listarray' zurÃ¼ckgegeben.

     FÃ¼r Array-Funktionen gibt `arrayinfo' eine Liste zurÃ¼ck, die
     `hashed' die Zahl der Indizes und die Indizes enthÃ¤lt, fÃ¼r die
     Funktionen im Array enthalten sind. Die Funktionen werden mit der
     Funktion `listarray' angezeigt.

     FÃ¼r indizierte Funktionen gibt `arrayinfo' eine Liste zurÃ¼ck, die
     `hashed', die Zahl der Indizes und die Indizies enthÃ¤lt, fÃ¼r die
     Lambda-AusdrÃ¼cke vorhanden sind. Die Lambda-AusdrÃ¼cke werden von
     der Funktion `listarray' angezeigt.

     Beispiele:

     `arrayinfo' und `listarray' angewendet auf ein deklariertes Array.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' und `listarray' angewendet auf ein undeklariertes
     Array.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' und `listarray' angewendet auf eine Array-Funktion.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' und `listarray' angewendet auf eine indizierte
     Funktion.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]


 -- Funktion: arraymake (<A>, [<i_1>, ..., <i_n>])
     Gibt eine nicht ausgewertete Referenz `<A>[<i_1>, ..., <i_n>]' auf
     das Array <A> zurÃ¼ck.

     `arraymake' entspricht der Funktion `funmake', wobei in diesem Fall
     das Argument eine nicht ausgewerte Referenz auf ein Array und kein
     nicht ausgewerteter Funktionsaufruf ist.

     Beispiele:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9


 -- Systemvariable: arrays
     Standardwert: `[]'

     `arrays' ist eine Informationsliste `infolists' der Arrays, die
     definiert sind. Die Liste enthÃ¤ltdeklarierte Arrays,
     undedeklarierte Arrays und Array-Funktionen, die mit `:=' oder
     `define' definiert sind.  Arrays die mit `make_array' definiert
     sind, sind nicht in der Liste enthalten.

     Siehe auch `array',  `arrayapply',  `arrayinfo',   `arraymake',
     `fillarray',  `listarray'  und `rearray'.

     Beispiele:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Function: fillarray (<A>, <B>)
     FÃ¼llt das Array <A> mit den Werten aus <B>. Das Argument <B> ist
     eine Liste oder ein Array.

     Ist das Array <A> mit einem Typ deklariert, dann kann es nur mit
     Elementen gefÃ¼llt werden, die den gleichen Typ haben.

     Sind die Dimensionen von <A> und <B> verschieden, werden in <A>
     zunÃ¤chst die Zeilen aufgefÃ¼llt. Hat <B> nicht genÃ¼gend Elemente um
     das Array <A> aufzufÃ¼llen, werden die restlichen Elemente mit dem
     letzten Wert von <B> aufgefÃ¼llt. ÃberzÃ¤hlige Elemente in <B>
     werden ignoriert.

     `fillarray' gibt sein erstes Argument zurÃ¼ck.

     Beispiele:

     Erzeuge ein Array mit 9 Elementen und fÃ¼lle es mit den Elementen
     einer Liste.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Sind zu wenige Elemente vorhanden, um das Array aufzufÃ¼llen, wird
     das Array mit dem letzten Element aufgefÃ¼llt. ÃberzÃ¤hlige Elemente
     werden ignoriert.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays werden zeilenweise aufgefÃ¼lllt.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}


 -- Function: listarray (<A>)
     Gibt eine Liste mit den Elementen des Arrays <A> zurÃ¼ck. Das
     Argument <A> kann ein deklariertes, undeklariertes, eine
     Array-Funktion oder eine indizierte Funktion sein.

     Die Elemente werden zeilenweise ausgegeben. FÃ¼r Hashed-Arrays mit
     Indizes, die keine ganze Zahlen sind, wird die Sortierung von der
     Funktion `orderless' bestimmt.

     FÃ¼r undeklarierte Arrays, Array-Funktionen und indizierte
     Funktionen werden die Elemente in der Reihenfolge wie von der
     Funktion `arrayinfo' zurÃ¼ckgegeben.

     Elemente von deklarierten Arrays, denen noch kein Wert zugewiesen
     wurde und die keinen Typ haben, werden als `#####' zurÃ¼ckgegeben.
     Elemente von deklarierten Arrays mit einem Typ, geben den Wert 0
     fÃ¼r den Typ `fixnum' und 0.0 fÃ¼r den Typ `flonum' zurÃ¼ck.

     Beispiele:

     Anwendung der Funktionen `listarray' und `arryinfo' fÃ¼r ein
     deklariertes Array.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     Anwendung der Funktionen `listarray' und `arryinfo' fÃ¼r ein
     undeklariertes Array.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     Anwendung der Funktionen `listarray' und `arryinfo' fÃ¼r eine
     Array-Funktion.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     Anwendung der Funktionen `listarray' und `arryinfo' fÃ¼r ein
     indizierte Funktion.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Funktion: make_array (<type>, <dim_1>, ..., <dim_n>)
     Erzeugt ein Lisp-Array. Das Argument <type> kann die Werte `any',
     `flonum', `fixnum', `hashed' oder `functional' haben.  Das Array
     hat i Dimensionionen und der Index i lÃ¤uft von 0 bis <dim_i>-1.

     Beispiele:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12


 -- Funktion: rearray (<A>, <dim_1>, ..., <dim_n>)
     Ãndert die Dimension eines Arrays. Das neue Array wird zeilenweise
     mit den Werten des alten Arrays aufgefÃ¼llt. Hat das alte nicht
     genÃ¼gend Elemente werden die restlichen Elemente entsprechend dem
     Typ des Arrays mit `false', `0.0' oder `0' aufgefÃ¼llt. Der Typ des
     Arrays kann nicht geÃ¤ndert werden.


 -- Funktion: remarray (<A_1>, ..., <A_n>)
 -- Funktion: remarray (all)
     Entfernt Arrays und Array-Funktionen. Der vom Array belegte
     Speicher wird freigegeben. Die Argumente kÃ¶nnen deklarierte,
     undeklarierte, Array-Funktionen und indizierte Funktionen sein.

     `remarry(all)' entfernt alle Arrays, die in der Informationsliste
     `arrays' enthalten sind.

     `remarry' gibt eine Liste der Arrays zurÃ¼ck, die entfernt wurden.


 -- Funktion: subvar (<x>, <i>)
     Wertet den indizierten Ausdruck `<x>[<i>]' aus. `subvar' wertet
     seine Argumente aus.

     `arraymake (<x>, [<i>]' generiert den Ausdruck `<x>[<i>]', ohne
     diesen auszuwerten.

     Beispiele:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Funktion: subvarp (<expr>)
     Gibt `true' zurÃ¼ck, wenn <expr> eine indizierte Variable wie zum
     Beispiel `a[i]' ist.


 -- Optionsvariable: use_fast_arrays
     Hat die Optionsvariable `use_fast_arrays' den Wert `true', werden
     nur die folgenden zwei Typen von Arrays erkannt:

       1. Ein Array, das mehrere Dimensionen haben kann und
          ganzzahligen Indizes. Den Elementen kann jedes Lisp oder
          Maxima-Objekt zugewiesen werden. Zum Beispiel weist das
          Kommando `a:make_array(any,3,4)' der Variablen <a> ein Array
          zu, das 12 Elemente hat.

       2. Ein undeklariertes Array, welches standardmÃ¤Ãig erzeugt wird,
          wenn zum Beispiel einer indizierten Variablen `b[x+1]:y^2'
          ein Wert zugewiesen wird und `b' nicht bereits ein
          deklariertes Array oder eine Liste ist. Ist <b> bereits
          deklariert, wird eine Fehlermeldung ausgeben, da der Index
          <x+1> keine ganze Zahl ist. Der Index eines undeklarierten
          Arrays kann ein beliebiger Ausdruck sein.




File: maxima.info,  Node: EinfÃ¼hrung in Listen,  Next: Funktionen und Variablen fÃ¼r Listen,  Prev: Funktionen und Variablen fÃ¼r Arrays,  Up: Datentypen und -strukturen

5.7 EinfÃ¼hrung in Listen
=========================

Listen sind die grundlegenden Bausteine fÃ¼r Maxima und Lisp. Alle
Datentypen, bis auf Arrays und Zahlen, und AusdrÃ¼cke werden als
Lisp-Listen dargestellt.  So wird ein Ausdruck `a+2' folgendermaÃen
intern als Liste dargestellt:

     ((MPLUS) $A 2)

Maxima selbst kennt den Typ einer Liste. Eine Liste mit 4 Elementen
wird zum Beispiel wie folgt dargestellt:

     [1, 2, 7, x+y]

Intern ist die Darstellung der obigen Liste wie folgt:

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

Das erste Element der internen Darstellung ist selbst eine Liste und
bezeichnet einen Operator oder eine Funktion. Wird der Ausdruck
vereinfacht wird dem ersten Element ein `simp'-Schalter hinzugefÃ¼gt:

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r Listen,  Prev: EinfÃ¼hrung in Listen,  Up: Datentypen und -strukturen

5.8 Funktionen und Variablen fÃ¼r Listen
========================================

 -- Funktion: append (<list_1>, ..., <list_n>)
     Gibt eine Liste mit den Elementen der Listen <list_1>, ... <list_n>
     zurÃ¼ck. `append' kann auch fÃ¼r allgemeine AusdrÃ¼cke genutzt werden.
     So hat zum Beispiel `append(f(a,b), f(c,d,e))' das Ergebnis
     `f(a,b,c,d,e)'.

     Mit `example(append)' wird ein Beispiel angezeigt.


 -- Funktion: assoc (<key>, <list>, <default>)
 -- Funktion: assoc (<key>, <list>)
     Die Funktion `assoc' sucht den SchlÃ¼ssel <key> in der Liste
     <list>. Die Liste hat die Form <[x, y, z, ...]>. Jedes Element der
     Liste ist ein Ausdruck mit 2 Argumenten wie zum Beispiel `x=1',
     `2^3' oder `[a,b]'. Der SchlÃ¼ssel <key> wird im ersten Argument
     gesucht.  `assoc' gibt, wenn der SchlÃ¼ssel gefunden wurde, das
     zweite Argument als Ergebnis zurÃ¼ck. Wird der SchlÃ¼ssel nicht
     gefunden, gibt `asscoc' den Wert des Arguments `default' oder
     `false' zurÃ¼ck. Das Argument <default> ist optional und hat den
     Standardwert `false'.


 -- Funktion: atom (<expr>)
     Gibt den Wert `true' zurÃ¼ck, wenn der Ausdruck <expr> ein Atom ist.
     Atome sind ganze Zahlen, Gleitkommazahlen, Zeichenketten und
     Symbole. So hat `atom(5)' das Ergebnis `true', wÃ¤hrend die
     AusdrÃ¼cke `atom(a[1])' oder `atom(sin(x))' das Ergebnis `false'
     haben.


 -- Funktion: cons (<expr>, <list>)
     Gibt eine Liste zurÃ¼ck, deren erstes Element der Ausdruck <expr>
     ist, dem die weiteren Elemente der Liste <list> folgen. `cons'
     arbeitet auch mit allgemeinen AusdrÃ¼cken. Zum Beispiel hat
     `cons(x, f(a,b,c))' das Ergebnis `f(x,a,b,c)'.


 -- Funktion: copylist (<list>)
     Gibt eine Kopie der Liste <list> zurÃ¼ck.


 -- Funktion: create_list (<form>, <x_1>, <list_1>, ..., <x_n>,
          <list_n>)
     Erzeugt eine Liste indem der Ausdruck <form> zunÃ¤chst fÃ¼r die
     Variable <x_1> ausgewertet wird. Der Variablen <x_1> werden fÃ¼r
     die Auswertung nacheinander die Werte der Liste <list_1>
     zugewiesen. Dann wird der Ausdruck <form> fÃ¼r die Variable <x_2>
     mit den Werten der Liste <list_2> ausgewertet u.s.w. Die Anzahl
     der Elemente der Ergebnisliste ist das Produkt der Anzahl der
     Elemente der einzelnen Listen <list_i>. Jede Variable <x_i> muss
     ein Symbol sein, das nicht ausgewertet wird. Die Elemente der
     Listen <x_i> werden einmal vor der Iteration ausgewertet.

     Beispiele:

          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     In diesem Beispiel wird fÃ¼r zwei Listen iteriert.

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     Anstatt einer Liste <list_i> kÃ¶nnen auch zwei Argumente Ã¼bergeben
     werden, die jedes zu einer Nummer auswerten. Diese Werte sind die
     untere und die obere Grenze fÃ¼r die Iteration.

          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]


 -- Funktion: delete (<expr_1>, <expr_2>)
 -- Funktion: delete (<expr_1>, <expr_2>, <n>)
     `delete(<expr_1>, <expr_2>)' entfernt vom Ausdruck <expr_2> jedes
     Argument des Hauptoperators, welches gleich dem Ausdruck <expr_1>
     ist.  Die Gleichheit wird mit dem Operator "=" festgestellt, der
     keine Ã¤quivalenten AusdrÃ¼cke erkennt. TeilausdrÃ¼cke eines
     Arguments werden von `delete' nicht entfernt.

     <expr_1> kann ein beliebiger Ausdruck sein, der kein Atom sein
     muss.  `delete' erzeugt einen neuen Ausdruck. Der Ausdruck
     <expr_2> wird nicht modifiziert.

     `delete(<expr_1>, <expr_2>, <n>)' entfernt vom Ausdruck <expr_2>
     die ersten <n> Argumente des Hauptoperators, die gleich dem
     Ausdruck <expr_1> sind. Hat der Ausdruck <expr_2> weniger
     Argumente als <n>, dann werden alle gleichen Argumente entfernt.

     Beispiele:

     Entferne Elemente von einer Liste.

          (%i1) delete (y, [w, x, y, z, z, y, x, w]);
          (%o1)                  [w, x, z, z, x, w]

     Entferne Terme einer Summe.

          (%i1) delete (sin(x), x + sin(x) + y);
          (%o1)                         y + x

     Entferne Faktoren eines Produkts.

          (%i1) delete (u - x, (u - w)*(u - x)*(u - y)*(u - z));
          (%o1)                (u - w) (u - y) (u - z)

     Entferne Argumente von einem beliebigen Ausdruck.

          (%i1) delete (a, foo (a, b, c, d, a));
          (%o1)                     foo(b, c, d)

     Die Anzahl der Elemente, die entfernt werden, wird begrenzt.

          (%i1) delete (a, foo (a, b, a, c, d, a), 2);
          (%o1)                    foo(b, c, d, a)

     Argumente die `equal' aber nicht "=" sind werden nicht entfernt.

          (%i1) [is(equal (0, 0)), is(equal (0, 0.0)), is(equal (0, 0b0))];

          `rat' replaced 0.0 by 0/1 = 0.0
          `rat' replaced 0.0B0 by 0/1 = 0.0B0
          (%o1)                  [true, true, true]
          (%i2) [is (0 = 0), is (0 = 0.0), is (0 = 0b0)];
          (%o2)                 [true, false, false]
          (%i3) delete (0, [0, 0.0, 0b0]);
          (%o3)                     [0.0, 0.0b0]
          (%i4) is (equal ((x + y)*(x - y), x^2 - y^2));
          (%o4)                         true
          (%i5) is ((x + y)*(x - y) = x^2 - y^2);
          (%o5)                         false
          (%i6) delete ((x + y)*(x - y), [(x + y)*(x - y), x^2 - y^2]);
                                        2    2
          (%o6)                       [x  - y ]


 -- Funktion: eighth (<expr>)
     Gibt das 8. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: endcons (<expr>, <list>)
     Gibt eine neue Liste zurÃ¼ck, die die Elemente der <list> enthÃ¤lt
     und an der das Element <expr> angehÃ¤ngt wird. `endcons' kann auch
     fÃ¼r allgemeine AusdrÃ¼cke genutzt werden. So hat zum Beispiel der
     Ausdruck `endcons(x, f(a,b,c))' das Ergebnis `f(a,b,c,x)'.


 -- Funktion: fifth (<expr>)
     Gibt das 5. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: first (<expr>)
     Gibt das erste Element des Ausdrucks <expr> zurÃ¼ck. Dies kann zum
     Beispiel das erste Elemente einer Liste, die erste Spalte einer
     Matrix oder der erste Term einer Summe sein. Die Funktion `first'
     und verwandte Funktionen wie `last' oder `rest' arbeiten mit der
     externen Darstellung eines Ausdrucks wie er in der Anzeige
     erscheint. Hat die Optionsvariable `inflag' den Wert `true', wird
     von diesen Funktionen die interne Darstellung betrachtet. Siehe
     dazu auch `inflag'.  .

     Die Funktionen `second' bis `tenth' geben jeweils das 2. bis 10.
     Element zurÃ¼ck.


 -- Funktion: fourth (<expr>)
     Gibt das 4. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: get (<a>, <i>)
     Gibt die Eigenschaft <i> des Symbols <a> zurÃ¼ck. Hat das Symbol
     <a> die Eigenschaft <i> nicht, wird `false' zurÃ¼ckgegeben.

     `get' wertet seine Argumente aus.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Funktion: join (<l>, <m>)
     Erzeugt eine neue Liste aus den Elementen der Listen <l> und <m>,
     wobei die Elemente abwechselnd Ã¼bernommen werden. Das Ergebnis hat
     die Form `[<l>[1], <m>[1], <l>[2], <m>[2], ...]'.

     Haben die Listen verschiedene LÃ¤ngen, werden die zusÃ¤tzlichen
     Elemente der lÃ¤ngeren Liste ignoriert.

     Sind <l> oder <m> keine Liste, gibt Maxima einen Fehler aus.

     Beispiele:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Funktion: last (<expr>)
     Gibt das letzte Element des Ausdrucks <expr> zurÃ¼ck. Siehe `first'

     fÃ¼r weitere ErlÃ¤uterungen.


 -- Funktion: length (<expr>)
     Gibt die Anzahl der Elemente eines Ausdrucks <expr> zurÃ¼ck, wie er
     in der externen Darstellung erscheint. Dies kÃ¶nnen zum Beispiel
     die Elemente einer Liste, die Spalten einer Matrix oder die Terme
     einer Summe sein.

     Die Optionsvariable `inflag' hat Einfluss auf das Ergebnis der
     Funktion `length'. So hat zum Beispiel das Kommando
     `length(a/(b*c));' das Ergebnis 2, wenn `inflag' den Wert `false'
     hat, und das Ergebnis 3, wenn `inflag' den Wert `true' hat. Siehe
     `inflag'  fÃ¼r AusfÃ¼hrungen zur internen und externen Darstellung
     von AusdrÃ¼cken.


 -- Optionsvariable: listarith
     Standardwert: `true'

     Hat die Optionsvariable `listarith' den Wert `true', werden
     Rechenoperationen mit Matrizen und Listen elementweise ausgefÃ¼hrt.
     Das Ergebnis von Rechnungen mit Listen und Matrizen sind wieder
     Listen und Matrizen.  Hat die Optionsvariable `listarith' den Wert
     `false' wird die elementweise AusfÃ¼hrung der Rechenoperationen
     unterdrÃ¼ckt.


 -- Funktion: listp (<expr>)
     Gibt `true' zurÃ¼ck, wenn <expr> eine Liste ist. Ansonsten ist der
     RÃ¼ckgabewert `false'.


 -- Funktion: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Funktion: makelist (<expr>, <x>, <list>)
     Erzeugt eine Liste, deren Elemente aus dem Ausdruck <expr>
     generiert werden.

     `makelist(<expr>, <i>, <i_0>, <i_1>)' gibt eine Liste zurÃ¼ck,
     deren <j>-tes Element der Auswertung `ev(<expr>, <i>=j)'
     entspricht. <j> nimmt die Werte von <i_0> bis <i_1> an.

     `makelist(<expr>, <x>, <list>)' gibt eine Liste zurÃ¼ck, deren
     <j>-tes Element der Auswertung `ev(<expr>, <i>=j)' entspricht. <j>
     nimmt in diesem Fall die Werte der Liste <list> an.

     Beispiele:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Funktion: member (<expr_1>, <expr_2>)
     Gibt `true' zurÃ¼ck, wenn fÃ¼r eines der Elemente in <expr_2> gilt
     das `is(<expr_1> = <a>)'. Ansonsten ist der RÃ¼ckgabewert `false'.

     `expr_2' ist typischerweise eine Liste, so dass fÃ¼r diesen Fall
     `args(<expr_2>) = <expr_2>' und `is(<expr_1> = <a>)' fÃ¼r ein
     Element der Liste <a> der Test ist.

     `member' betrachtet keine TeilausdrÃ¼cke der Argument des Ausdrucks
     <expr_2>.

     Siehe auch `elementp'.

     Beispiele:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true


 -- Funktion: ninth (<expr>)
     Gibt das 9. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: rest (<expr>, <n>)
 -- Funktion: rest (<expr>)
     Gibt den Ausdruck <expr> zurÃ¼ck, wobei die erste <n> Elemente
     entfernt sind, wenn <n> positive ist. Ist <n> negative werden die
     letzten <n> Elemente entfernt. Der Wert 1 fÃ¼r <n> muss nicht als
     Argument angegeben werden. <expr> kann eine Liste, eine Matrix
     oder irgendein anderer Ausdruck sein.


 -- Funktion: reverse (<list>)
     Kehrt die Anordnung der Elemente einer Liste <list> um. `reverse'
     kann auch fÃ¼r allgemeine AusdrÃ¼cke verwendet werden. So hat zum
     Beispiel `reverse(a=b)' das Ergebnis `b=a'.


 -- Funktion: sort (<L>, <P>)
 -- Funktion: sort (<L>)
     Sortiert eine Liste <L> mit einer Aussage `P', die zwei Argumente
     hat, so dass `<P>(<L>[k], <L>[k + 1])' `true' fÃ¼r zwei beliebige
     aufeinander folgende Elemente ist. Die Aussage kann durch eine
     Funktion, einen binÃ¤ren Operator oder einen Lambda-Ausdruck
     gegeben werden.  Wird der Name eines Operators angegeben, wird der
     Name in AnfÃ¼hrungszeichen gesetzt.

     Die sortierte List wird als ein neues Objekt zurÃ¼ckgegeben. Das
     Argument `L' wird nicht modifiziert.

     Ist die Aussage <P> keine totale Ordnung der Elemente der Liste
     <L>, kann `sort' ohne einen Fehler enden, ohne das das Ergebnis
     definiert ist.  `sort' gibt einen Fehler, wenn die Aussage nicht
     zu `true' oder `false' ausgewertet werden kann.

     `sort(<L>)' ist Ã¤quivalent zu `sort(<L>, orderlessp)'.  Damit ist
     die Standardordnung aufsteigend, wie sie von `orderlessp'
     definiert wird. Alle Maxima Atome und AusdrÃ¼cke kÃ¶nnen mit
     `orderlessp' verglichen werden.

     Beispiele:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c,
                19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9*c, 19 - 3*x],
                ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list: [[aa,hh,uu], [ee,cc], [zz,xx,mm,cc], [%pi,%e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a),
                reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]


 -- Funktion: second (<expr>)
     Gibt das 2. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: seventh (<expr>)
     Gibt das 7. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: sixth (<expr>)
     Gibt das 6. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: sublist (<list>, <p>)
     Gibt die Elemente der Liste <list> zurÃ¼ck, fÃ¼r die die Aussage `p'
     den Wert `true' hat.

     Beispiele:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Funktion: sublist_indices (<L>, <P>)
     Gibt die Indizes der Elemente <x> der Liste <L> zurÃ¼ck, fÃ¼r die die
     Aussage `maybe(<P>(x))' das Ergebnis `true' hat. <P> kann der Name
     einer Funktion oder ein Lambda-Ausdruck sein. <L> muss eine
     explizit angegebene Liste sein.

     Beispiele:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                                 lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                                 identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]


 -- Funktion: tenth (<expr>)
     Gibt das 10. Element eines Ausdrucks oder einer Liste <expr>
     zurÃ¼ck.  Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: third (<expr>)
     Gibt das 3. Element eines Ausdrucks oder einer Liste <expr> zurÃ¼ck.
     Siehe `first'  fÃ¼r mehr Informationen.


 -- Funktion: unique (<L>)
     Gibt eine Liste mit den Elementen von <L> zurÃ¼ck, die sich
     voneinander unterscheiden.

     Sind alle Elemente der Liste <L> verschieden, gibt `unique' eine
     Kopie der Liste <L> und nicht die Liste selbst zurÃ¼ck.

     Ist <L> keine Liste, gibt `unique' den Ausdruck <L> zurÃ¼ck.

     Beispiel:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]


File: maxima.info,  Node: AusdrÃ¼cke,  Next: Operatoren,  Prev: Datentypen und -strukturen,  Up: Top

6 AusdrÃ¼cke
************

* Menu:

* EinfÃ¼hrung in AusdrÃ¼cke::
* Substantive und Verben::
* Bezeichner::
* Funktionen und Variablen fÃ¼r AusdrÃ¼cke::


File: maxima.info,  Node: EinfÃ¼hrung in AusdrÃ¼cke,  Next: Substantive und Verben,  Prev: AusdrÃ¼cke,  Up: AusdrÃ¼cke

6.1 EinfÃ¼hrung in AusdrÃ¼cke
=============================

Alles in Maxima, bis auf wenige Ausnahmen, sind AusdrÃ¼cke. Dazu gehÃ¶ren
mathematische AusdrÃ¼cke wie `sqrt(2*a+b)', Kommandos wie
`subst(a^2,b,sin(b+1)'. Auch Maxima-Programme sind AusdrÃ¼cke. AusdrÃ¼cke
bestehen aus einem Atom oder einem Operator mit seinen Argumenten.

   Ein Atom kann ein Symbol (ein Name), eine Zeichenkette, eine ganze
Zahl oder eine Gleitkommazahl sein. Jeder Ausdruck, der nicht ein Atom
ist, hat die Darstellung `op(a_1, a_2, ..., a_n)'. `op' ist der
Operator und `a_1', ..., `a_n' sind die Argumente des Operators. Die
Argumente des Operators kÃ¶nnen Atome oder wiederum Operatoren mit
Argumenten sein.

   Da Maxima in Lisp programmiert ist, wird ein Ausdruck intern als
eine Liste dargestellt, die die Gestalt `((op) a_1 a_2 ... a_n)' hat.
Die arithmetischen Operatoren "+" und "*" haben zum Beispiel die
interne Darstellung:

     x+y+10  -> ((mplus) 10 $x $y)
     2*x*x   -> ((mtimes) 2 $x $y)
     2*(x+y) -> ((mtimes) 2 ((mplus) $x $y)

   Mathematische Funktionen wie die trigonometischen Funktionen oder die
Logarithmusfunktion werden von Maxima intern analog dargestellt:

     sin(x)          -> ((%sin) $x)
     log(y)          -> ((%log) $y)
     2*sin(x)+log(y) -> ((mplus) ((mtimes) 2 ((%sin) $x)) ((%log) $y))

   Mehrere AusdrÃ¼cke kÃ¶nnen zusammengefaÃt werden, indem die AusdrÃ¼cke
durch Kommata getrennt und mit runden Klammern umgeben werden.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Auch Programmschleifen sind in Maxima AusdrÃ¼cke. Der RÃ¼ckgabewert
einer Programmschleife ist `done'.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   Um einen anderen RÃ¼ckgabewert als `done' zu erhalten, kann zum
Beispiel der Wert der Variablen <x> nach dem Ende der Programmschleife
ausgegeben werden.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800

   Es gibt eine Anzahl an reservierten Namen, die nicht als
Variablennamen verwendet werden sollten. Ihre Verwendung kann
mÃ¶glicherweise kryptische Fehlermeldungen erzeugen. Dazu gehÃ¶ren zum
Beispiel die folgenden Namen:

   integrate            next           from                 diff
   in                   at             limit                sum
   for                  and            elseif               then
   else                 do             or                   if
   unless               product        while                thru
   step

Funktionen und Variablen um einen Teilausdruck zu isolieren:

   isolate     disolate  isolate_wrt_times   expisolate
   part        inpart    substpart           substinpart
   inflag      piece     partswitch
   pickapart

Funktionen und Variablen fÃ¼r Substantive und Verben:

   nounify   verbify     alias     aliases

Funktionen und Variablen, um zu prÃ¼fen, ob ein Teilausdruck enthalten
ist und um eine Liste der Variablen eines Ausdrucks zu erstellen:

   freeof       lfreeof
   listofvars   listconstvars    listdummyvars

Funktionen und Variablen fÃ¼r Operatoren und Argumente:

   args    op    operatorp

Funktionen und Variablen fÃ¼r Substitutionen in AusdrÃ¼cke:

   subst psubst sublis exptsubst opsubst

Funktionen und Variablen fÃ¼r die kanonische Ordnung der Argumente eines
Ausdrucks:

   ordergreat    orderless    unorder
   ordergreatp   orderlessp

Weitere Funktionen und Variablen:

   nterms   optimize   optimprefix   partition


File: maxima.info,  Node: Substantive und Verben,  Next: Bezeichner,  Prev: EinfÃ¼hrung in AusdrÃ¼cke,  Up: AusdrÃ¼cke

6.2 Substantive und Verben
==========================

Operatoren und Funktionen kÃ¶nnen als Substantiv oder Verb vorliegen.
Verben werden von Maxima ausgewertet. Substantive, die in einem
Ausdruck auftreten, werden dagegen nicht ausgewertet, sondern
vereinfacht. Die meisten mathematischen Funktionen sind Substantive.
Funktionen wie `limit', `diff' oder `integrate' sind standardmÃ¤Ãig
Verben, die jedoch in ein Substantiv umgewandelt werden kÃ¶nnen. Ein
Verb kann durch den Quote-Operator `'' oder mit der Funktion `nounify'
in ein Substantiv umgewandelt werden. Der Auswertungsschalter `nouns'
bewirkt, dass Substantive von der Funktion `ev' ausgewertet werden.

   In der internen Darstellung von Maxima erhalten Lisp-Symbole, die
ein Verb darstellen, ein fÃ¼hrendes Dollarzeichen `$'. Lisp-Symbole, die
ein Substantiv darstellen, erhalten ein fÃ¼hrendes Prozentzeichen `%'.
Einige Substantive wie `'integrate' oder `'derivative' haben eine
spezielle Darstellung fÃ¼r die Ausgabe. StandardmÃ¤Ãig werden jedoch
Substantive und Verben identisch dargestellt. Hat die Optionsvariable
`noundisp' den Wert `true', werden Substantive mit einem fÃ¼hrenden
Hochkommata angezeigt.

   Siehe auch `noun',  `nouns',  `nounify'  und `verbify'.

   Beispiele:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Bezeichner,  Next: Funktionen und Variablen fÃ¼r AusdrÃ¼cke,  Prev: Substantive und Verben,  Up: AusdrÃ¼cke

6.3 Bezeichner
==============

Maxima Bezeichner bestehen aus den Buchstaben des Alphabets und den
Zahlzeichen 0 bis 9. Sonderzeichen kÃ¶nnen in einem Bezeichner mit einem
vorangestellten Backslash `\' verwendet werden, zum Beispiel `a\&b'.

   Ein Zahlzeichen kann der erste Buchstabe eines Bezeichners sein,
wenn ihm ein Backslash vorangestellt ist, zum Beispiel `\2and3'.
Zahlzeichen, die an anderen Stellen auftreten, muss kein Backslash
vorangestellt werden, zum Beispiel `is5'.

   Sonderzeichen kÃ¶nnen mit der Funktion `declare' als alphabetisch
erklÃ¤rt werden. In diesem Fall muss dem Sonderzeichen kein Backslash
vorangestellt werden, wenn es in einem Bezeichner genutzt wird. Die
Zeichen `A' bis `Z', `a' bis `z' und `0' bis `9' sowie die Zeichen `%'
und `_' haben bereits die Eigenschaft alphabetisch.

   Maxima unterscheidet GroÃ- und Kleinschreibung. So werden von Maxima
`foo', `FOO' oder `Foo' unterschieden. Ein Maxima-Bezeichner ist ein
Lisp-Symbol, dem ein Dollarzeichen `$' vorangestellt ist. Lisp-Symbolen,
die in Maxima verwendet werden sollen, ist ein Fragezeichen `?'
vorangestellt. Siehe *note Lisp und Maxima:: fÃ¼r eine ausfÃ¼hrlichere
Beschreibung.

   Beispiele:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r AusdrÃ¼cke,  Prev: Bezeichner,  Up: AusdrÃ¼cke

6.4 Funktionen und Variablen fÃ¼r AusdrÃ¼cke
============================================

 -- Funktion: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     Die Funktion `alias' ermÃ¶glicht einen alternativen Alias-Namen fÃ¼r
     eine Maxima-Funktion, einer Variablen oder einem Array. Der
     Funktion `alias' kann eine beliebige Anzahl von paarweisen Namen
     und Alias-Namen Ã¼bergeben werden.

     `alias' gibt eine Liste mit den Symbolen zurÃ¼ck, denen ein
     Alias-Name zugewiesen werden konnte. Wurde einem Symbol bereits
     derselbe Alias-Name gegeben, enthÃ¤lt die Liste den Wert `false'.
     Wird versucht einem Symbol, das bereits einen Alias-Namen hat,
     einen neuen Alias-Namen zu geben, bricht `alias' mit einer
     Fehlermeldung ab.

     Symbole, die einen Alias-Namen erhalten haben, werden in die
     Systemvariable `aliases' eingetragen. Siehe die Systemvariable
     `aliases'.

     Der Alias-Name kann mit der Funktion `kill' entfernt werden.

     Beispiel:

          (%i1) alias(mysqrt,sqrt);
          (%o1)                        [sqrt]
          (%i2) aliases;
          (%o2)                        [sqrt]
          (%i3) mysqrt(4);
          (%o3)                           2
          (%i4) kill(mysqrt);
          (%o4)                         done
          (%i5) mysqrt(4);
          (%o5)                       mysqrt(4)
          (%i6) aliases;
          (%o6)                          []


 -- Systemvariable: aliases
     Anfangswert: `[]'

     Die Systemvariable `aliases' ist eine Informationsliste der
     Symbole, die einen vom Benutzer definierten Alias-Namen mit dem
     Kommando `alias' erhalten haben. Weiterhin werden von den
     Funktionen `ordergreat' und `orderless' sowie bei der Deklaration
     eines Symbols als ein `noun' mit der Funktion `declare'
     Alias-Namen generiert, die in die Liste `aliases' eingetragen
     werden.

     Siehe auch die Funktion `alias'  fÃ¼r ein Beispiel.


 -- SchlÃ¼sselwort: allbut
     Das SchlÃ¼sselwort `allbut' wird bei `part'-Befehlen wie `part',
     `inpart', `substpart', `substinpart', `dpart' und `lpart' genutzt,
     um Indizes bei der Auswahl von TeilausdrÃ¼cken auszuschlieÃen. Das
     SchlÃ¼sselwort `allbut' kann auch zusammen mit dem Kommando `kill'
     verwendet werden. Siehe die Funktion `kill'.

     `kill(allbut(<a_1>, <a_2>, ...))' hat denselben Effekt wie
     `kill(all)' mit der Ausnahme, dass die Symbole <a_1>, <a_2>, ...
     von `kill' ausgenommen werden.

     Beispiele:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

          (%i3) expr : e + d + c + b + a;
          (%o3)                   e + d + c + b + a
          (%i4) part (expr, allbut (2, 5));
          (%o4)                       e + c + b

     Das SchlÃ¼sselwort `allbut' kann zusammen mit dem Kommando `kill'
     verwendet werden.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]


 -- Funktion: args (<expr>)
     Die Funktion `args' gibt eine Liste mit den Argumenten des
     Hauptoperators des Ausdrucks <expr> zurÃ¼ck.

     Die Anordnung der Argumente der Ergebnisliste wird von der
     Optionsvariablen `inflag' beeinfluÃt. Hat `inflag' den Wert
     `true', ist die Anordnung entsprechend der internen Darstellung
     des Ausdrucks <expr>.  Ansonsten ist die Andordnung wie in der
     externen Darstellung fÃ¼r die Anzeige.  Siehe die Optionsvariable
     `inflag'.

     `args(<expr>)' ist Ã¤quivalent zu `substpart("[", <expr>, 0)'.
     Siehe auch `substpart'  und `op'.

     Beispiele:

          (%i1) args(gamma_incomplete(a,x));
          (%o1)                        [a, x]
          (%i2) args(x+y+z);
          (%o2)                       [z, y, x]
          (%i3) args(x+y+z),inflag:true;
          (%o3)                       [x, y, z]
          (%i4) args(x+2*a);
          (%o4)                       [x, 2 a]


 -- Funktion: box (<expr>)
 -- Funktion: box (<expr>, <a>)
     Die Funktion `box(<expr>)' umschlieÃt den Ausdruck <expr> in der
     Ausgabe mit einem Rahmen, wenn `display2d' den Wert `true' hat.
     Ansonsten ist der RÃ¼ckgabewert ein Ausdruck mit `box' als Operator
     und <expr> als Argument.

     `box(<expr>, <a>)' umschlieÃt <expr> mit einem Rahmen, der mit
     einer Marke <a> bezeichnet ist. Ist die Marke lÃ¤nger als der
     Rahmen, werden Zeichen abgeschnitten.

     Die Funktion `box' wertet ihre Argumente aus. Die eingerahmten
     AusdrÃ¼cke werden dagegen nicht mehr ausgewertet.

     Die Optionsvariable `boxchar' enthÃ¤lt das Zeichen, das von den
     Funktionen `box' sowie `dpart' und `lpart' verwendet wird, um den
     Rahmen auszugeben.

     Beispiele:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""


 -- Optionsvariable: boxchar
     Standardwert: `"'

     Die Optionsvariable `boxchar' enthÃ¤lt das Zeichen, welches von den
     Funktionen `box' sowie `dpart' und `lpart' genutzt wird, um einen
     Rahmen auszugeben.

     Die Rahmen werden immer mit dem aktuellen Wert von `boxchar'
     ausgegeben.  Das Zeichen `boxchar' wird nicht zusammen mit dem
     eingerahmten Ausdruck gespeichert.


 -- Funktion: collapse (<expr>)
 -- Funktion: collapse ([<expr_1>, <expr_2>, ...])
     Kompremiert einen Ausdruck <expr>, indem gemeinsame TeilausdrÃ¼cke
     denselben Speicher nutzen. `collapse' wird von der Funktion
     `optimize' aufgerufen. `collapse' kann auch mit einer Liste
     aufgerufen werden, die mehrere Argumente enthÃ¤lt.

     Siehe auch die Funktion `optimize'.


 -- Funktion: disolate (<expr>, <x_1>, ..., <x_n>)
     Die Funktion `disolate' arbeitet Ã¤hnlich wie die Funktion
     `isolate'.  Im Unterschied zu der Funktion `isolate' kann die
     Funktion `disolate' TeilausdrÃ¼cke zu mehr als einer Variablen aus
     einem Ausdruck isolieren.

     Die Ersetzung von TeilausdrÃ¼cken durch Zwischenmarken kann mit der
     Optionsvariable `isolate_wrt_times' kontrolliert werden. Hat die
     Optionsvariable `isolate_wrt_times' den Wert `true', werden
     Ersetzungen in Produkten ausgefÃ¼hrt. Der Standardwert ist `false'.
     Siehe `isolate_wrt_times' fÃ¼r Beispiele.

     Die Optionsvariable `expisolate' hat im Unterschied zur Funktion
     `isolate' keinen Einfluss auf die Ersetzung von TeilausdrÃ¼cken
     durch Zwischenmarken.

     `disolate' wird automatisch aus der Datei
     `share/simplification/disol.mac' geladen. Das Kommando
     `demo("disol")$' zeigt Beispiele.

     Siehe auch die Funktion `isolate'.

     Beispiel:

          (%i1) expr:a*(e*(g+f)+b*(d+c));
          (%o1)               a (e (g + f) + b (d + c))
          (%i2) disolate(expr,a,b,e);
          (%t2)                         d + c

          (%t3)                         g + f

          (%o3)                   a (%t3 e + %t2 b)


 -- Funktion: dpart (<expr>, <n_1>, ..., <n_k>)
     WÃ¤hlt wie die Funktion `part' einen Teilausdruck aus, gibt aber den
     vollstÃ¤ndigen Ausdruck zurÃ¼ck, wobei der ausgewÃ¤hlte Teilausdruck
     eingerahmt ist. Der Rahmen ist Teil des zurÃ¼ckgegebenen Ausdrucks.

     Siehe auch `part',  `inpart'  und `lpart'.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Optionsvariable: exptisolate
     Standardwert: `false'

     Hat `exptisolate' den Wert `true', dann sucht die Funktion
     `isolate' auch in den Exponenten von Zahlen oder Symbolen nach
     TeilausdrÃ¼cken zu einer Variablen.

     Siehe die Funktion `isolate'  fÃ¼r Beispiele.


 -- Optionsvariable: exptsubst
     Standardwert: `false'

     Die Optionsvariable `exptsubst' kontrolliert die Substitution von
     AusdrÃ¼cken mit der Exponentialfunktion durch die Funktionen
     `subst' und `psubst'.

     Beispiele:

          (%i1) subst(y,%e^x,%e^(a*x)),exptsubst:false;
                                          a x
          (%o1)                         %e
          (%i2) subst(y,%e^x,%e^(a*x)),exptsubst:true;
                                          a
          (%o2)                          y


 -- Funktion: freeof (<x>, <expr>)
 -- Funktion: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof(<x>, <expr>)' gibt das Ergebnis `true' zurÃ¼ck, wenn das
     Argument <x> nicht im Ausdruck <expr> enthalten ist. Ansonsten ist
     der RÃ¼ckgabewert `false'.

     `freeof(<x_1>, ..., <x_n>, <expr>)' gibt das Ergebnis `true'
     zurÃ¼ck, wenn keines der Argumente <x_1>, <x_2>, ...  im Ausdruck
     <expr> enthalten ist.

     Die Argumente <x_1>, ..., <x_n> kÃ¶nnen die Namen von Funktionen und
     Variablen sein, indizierte Namen, die Namen von Operatoren oder
     allgemeine AusdrÃ¼cke. Die Funktion `freeof' wertet ihre Argumente
     aus.

     Bei der PrÃ¼fung, ob ein Teilausdruck <x> im Ausdruck <expr>
     enthalten ist, untersucht die Funktion `freeof' den Ausdruck
     <expr> in der vorliegenden Form (nach Auswertung und
     Vereinfachung) und versucht nicht herauszufinden, ob der
     Teilausdruck in einem Ã¤quivalenten Ausdruck enthÃ¤lten wÃ¤re.

     `freeof' ignoriert Dummy-Variablen. Dummy-Variablen sind
     Variablen, die auÃerhalb eines Ausdrucks nicht in Erscheinung
     treten. Folgende Dummy-Variablen werden von `freeof' ignoriert:
     der Index einer Summe oder eines Produktes, die unabhÃ¤ngige
     Variable in einem Grenzwert, die Integrationsvariable eines
     bestimmten Integrals oder einer Laplacetransformation, formale
     Variablen in `at'- oder `lambda'-AusdrÃ¼cke, lokale Variablen eines
     Blocks oder einer `do'-Schleife.

     Das unbestimmte Integral ist nicht frei von seinen
     Integrationsvariablen.

     Beispiele:

     Argumente sind Namen von Funktionen, Variablen, indizierten
     Variablen, Operatoren und AusdrÃ¼cke. `freeof(a, b, expr)' ist
     Ã¤quivaent zu `freeof(a, expr) and freeof(b, expr)'.

          (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                           d + c  3
          (%o1)                   cos(a ) b      z
                                       1
          (%i2) freeof(z, expr);
          (%o2)                         false
          (%i3) freeof(cos, expr);
          (%o3)                         false
          (%i4) freeof(a[1], expr);
          (%o4)                         false
          (%i5) freeof(cos (a[1]), expr);
          (%o5)                         false
          (%i6) freeof(b^(c+d), expr);
          (%o6)                         false
          (%i7) freeof("^", expr);
          (%o7)                         false
          (%i8) freeof(w, sin, a[2], sin (a[2]), b*(c+d), expr);
          (%o8)                         true

     Die Funktion `freeof' wertet ihre Argumente aus.

          (%i1) expr: (a+b)^5$
          (%i2) c: a$
          (%i3) freeof(c, expr);
          (%o3)                         false

     `freeof' betrachtet keine Ã¤quivalenten AusdrÃ¼cke. Vereinfachungen
     kÃ¶nnen einen Ã¤quivalenten Ausdruck liefern, der jedoch den
     Teilausdruck nicht mehr enthÃ¤lt.

          (%i1) expr: (a+b)^5$
          (%i2) expand(expr);
                    5        4       2  3       3  2      4      5
          (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
          (%i3) freeof(a+b, %);
          (%o3)                         true
          (%i4) freeof(a+b, expr);
          (%o4)                         false

     Die Exponentialfunktion `exp(x)' wird von Maxima sofort zu `%e^x'
     vereinfacht. Der Name der Exponentialfunktion ist daher nicht in
     einem Ausdruck enthalten.

          (%i5) exp(x);
                                           x
          (%o5)                          %e
          (%i6) freeof(exp, exp (x));
          (%o6)                         true

     Eine Summe ist frei von dem Index und ein bestimmtes Integral ist
     frei von der Integrationsvariablen. Ein unbestimmtes Integral ist
     nicht frei von der Integrationsvariablen.

          (%i1) freeof(i, 'sum (f(i), i, 0, n));
          (%o1)                         true
          (%i2) freeof(x, 'integrate (x^2, x, 0, 1));
          (%o2)                         true
          (%i3) freeof(x, 'integrate (x^2, x));
          (%o3)                         false


 -- Funktion: fullmap (<f>, <expr_1>, ...)
     Die Funktion `fullmap' ist vergleichbar mit der Funktion `map'. Im
     Unterschied zu der Funktion `map' kann `fullmap' auf verschachtelte
     AudrÃ¼cke angewendet werden.

     Intern wird `fullmap' von Maxima fÃ¼r die Vereinfachung von Matrizen
     aufgerufen. Daher kÃ¶nnen bei der Vereinfachung von Matrizen
     Fehlermeldungen im Zusammenhang mit `fullmap' auftreten, ohne dass
     die Funktion direkt aufgerufen wurde.

     Beispiele:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Funktion: fullmapl (<f>, <list_1>, ...)
     Die Funktion `fullmapl' ist vergleichbar mit `fullmap'.
     `fullmapl' kann jedoch nur auf Matrizen und Listen angewendet
     werden kann.

     Beispiele:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Optionsvariable: inflag
     Standardwert: `false'

     Hat die Optionsvariable `inflag' den Wert `true', wird von
     Funktionen, die Teile eines Ausdrucks extrahieren, die interne
     Form des Ausdrucks `expr' betrachtet.

     Die Anordnung der Argumente der internen Darstellung unterscheidet
     sich zum Beispiel fÃ¼r die Addition von der externen Darstellung
     fÃ¼r die Anzeige. Daher hat `first(x+y)' das Ergebnis `x', wenn
     `inflag' den Wert `true' hat, und `y', wenn `inflag' den Wert
     `false' hat. Der Ausdruck `first(y+x)' gibt in beiden FÃ¤llen
     dasselbe Ergebnis.

     Hat `inflag' den Wert `true', entsprechen die Funktionen `part'
     und `substpart' den Funktionen `inpart' und `substinpart'.

     Folgende Funktionen werden von der Optionsvariablen `inflag'
     beeinflusst: `part', `substpart', `first', `rest', `last',
     `length', die Konstruktion `for' ... `in', `map', `fullmap',
     `maplist', `reveal', `pickapart', `args' und `op'.


 -- Funktion: inpart (<expr>, <n_1>, ..., <n_k>)
     Die Funktion `inpart' ist Ã¤hnlich wie `part', arbeitet aber mit der
     internen Darstellung eines Ausdruckes und nicht mit der externen
     Darstellung fÃ¼r die Anzeige. Da keine Formatierung vorgenommen
     wird, ist die Funktion `inpart' schneller als `part'.

     Immer dann, wenn sich die interne und die externe Darstellung
     eines Ausdrucks voneinander unterscheiden, haben die Funktionen
     `inpart' und `part' verschiedene Ergebnisse. Dies trifft zu fÃ¼r
     die Anordung der Argumente einer Addition, der Subtraktion und
     Division sowie zum Beispiel fÃ¼r die Wurzelfunktion.

     Ist das letzte Argument einer `part'-Funktion eine Liste mit
     Indizes, werden mehrere TeilausdrÃ¼cke herausgepickt. So hat
     `inpart(x + y + z, [1, 3])' das Ergebnis `z+x'.

     Siehe auch `part',  `dpart',  und `lpart'.

     Beispiele:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Funktion: isolate (<expr>, <x>)
     TeilausdrÃ¼cke im Ausdruck <expr>, die die Variable <x> nicht
     enthalten, werden durch Zwischenmarken `%t1', `%t2', ... ersetzt.
     Dies kann genutzt werden, um die weitere Auswertung und
     Vereinfachung dieser TeilausdrÃ¼cke zu verhindern. Die Ersetzung
     der TeilausdrÃ¼cke kann durch eine Auswertung des Ausdrucks
     rÃ¼ckgÃ¤ngig gemacht werden.

     Die Ersetzung von TeilausdrÃ¼cken kann mit den Optionsvariablen
     `expisolate' und `isolate_wrt_times' kontrolliert werden. Hat die
     Optionsvariable `exptisolate' den Wert `true', werden Ersetzungen
     auch fÃ¼r die Exponentiaton ausgefÃ¼hrt. Die Basis muss dabei eine
     Zahl oder ein Symbol wie `%e' sein. Hat die Optionsvariable
     `isolate_wrt_times' den Wert `true', werden Ersetzungen in
     Produkten ausgefÃ¼hrt. Siehe `isolate_wrt_times' fÃ¼r Beispiele.

     Die Ersetzung von TeilausdrÃ¼cken fÃ¼r mehrere Variable kann mit der
     Funktion `disolate' ausgefÃ¼hrt werden. Siehe `disolate'.

     Beispiele:

          (%i1) (b+a)^4*(x*((d+c)^2+2*x)+1);
                                 4                  2
          (%o1)           (b + a)  (x (2 x + (d + c) ) + 1)
          (%i2) isolate(%,x);

                                             2
          (%t2)                       (d + c)


                                             4
          (%t3)                       (b + a)

          (%o3)                %t3 (x (2 x + %t2) + 1)
          (%i4) ratexpand(%);
                                    2
          (%o4)              2 %t3 x  + %t2 %t3 x + %t3
          (%i5) ev(%);
                            4  2          4        2            4
          (%o5)    2 (b + a)  x  + (b + a)  (d + c)  x + (b + a)
          (%i6) (b+a)*(b+a+x)^2*%e^(b+a*x+x^2);
                                                 2
                                            2   x  + a x + b
          (%o6)          (b + a) (x + b + a)  %e
          (%i7) ev(isolate(%,x),exptisolate:true);

          (%t7)                         b + a


                                           b
          (%t8)                          %e

                                                  2
                                             2   x  + a x
          (%o8)             %t7 %t8 (x + %t7)  %e


 -- Optionsvariable: isolate_wrt_times
     Standardwert: `false'

     Hat die Optionsvariable `isolate_wrt_times' den Wert `true', fÃ¼hren
     die Funktionen `isolate' und `disolate' auch Ersetzungen in
     Produkten aus.

     Siehe auch die Funktionen `isolate'  und `disolate'.

     Beispiele:

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Optionsvariable: listconstvars
     Standardwert: `false'

     Hat die Optionsvariable `listconstvars' den Wert `true', werden
     Konstante wie `%e', `%pi' und Variablen, die als konstant
     deklariert sind, von der Funktion `listofvars' in die
     Ergebnisliste aufgenommen. Der Standardwert von `listconstvars'
     ist `false' und Konstante werden ignoriert.


 -- Optionsvariable: listdummyvars
     Standardwert: `true'

     Hat `listdummyvars' den Wert `false', werden die Dummy-Variablen
     eines Ausdrucks von der Funktion `listofvars' ignoriert.
     Dummy-Variablen sind zum Beispiel der Index einer Summe, die
     Grenzwertvariable oder die Integrationsvariable eines bestimmten
     Integrals.

     Beispiele:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Funktion: listofvars (<expr>)
     Die Funktion `listofvars' gibt eine Liste der Variablen zurÃ¼ck,
     die im Ausdruck <expr> enthalten sind.

     Hat die Optionsvariable `listconstvars' den Wert `true', werden
     auch Konstante wie `%e', `%pi', `%i' und als konstant deklarierte
     Variable in die Liste aufgenommen. Der Standwert von
     `listconstvars' ist `false'.

     Siehe entsprechend die Optionsvariable `listdummyvars'  fÃ¼r
     Dummy-Variablen.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Funktion: lfreeof (<list>, <expr>)
     FÃ¼r jedes Element <m> der Liste <list> wird die Funktion `freeof'
     aufgerufen. `lfreeof' hat den RÃ¼ckgabewert `true', wenn keines der
     Elemente der Liste <list> im Ausdruck `expr' enthalten ist.
     Ansonsten ist der RÃ¼ckgabewert `false'.

     Siehe auch die Funktion `freeof'.


 -- Funktion: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Die Funktion `lpart' ist Ã¤hnlich zu `dpart', verwendet aber einen
     Rahmen, der mit einer Marke gekennzeichnet ist.

     Siehe auch `part',  `inpart'  und `dpart'.


 -- Eigenschaft: mainvar
     Die Deklaration einer Variablen als eine Hauptvariable Ã¤ndert
     deren Anordnung in einem Ausdruck der kanonisch geordnet ist.
     Hauptvariable sind bezÃ¼glich der Funktionen `ordergreatp' und
     `orderlessp' stets grÃ¶Ãer als alle anderen Symbole, Konstanten und
     Zahlen.

     Beispiel:

          (%i1) sort([9,1,%pi,g,t,a]);
          (%o1)                 [1, 9, %pi, a, g, t]

          (%i2) declare(a,mainvar)$
          (%i3) sort([9,1,%pi,g,t,a]);
          (%o3)                 [1, 9, %pi, g, t, a]


 -- Eigenschaft: noun
     `noun' ist eine der Optionen des Kommandos `declare'. Wird eine
     Funktion als `noun' deklariert, wird diese als Substantivform
     behandelt und nicht ausgewertet.


 -- Optionsvariable: noundisp
     Standardwert: `false'

     Hat `noundisp' den Wert `true', werden Substantivformen mit einem
     vorangestelltem Hochkomma angezeigt. Diese Optionsvariable hat
     immer den Wert `true', wenn die Definition von Funktionen
     angezeigt wird.


 -- Funktion: nounify (<f>)
     Die Funktion `nounify' gibt den Namen einer Funktion <f> in einer
     Substantivform zurÃ¼ck. Der Name <f> ist ein Symbol oder eine
     Zeichenkette.

     Einige Funktionen geben eine Sustantivform zurÃ¼ck, wenn die
     Funktion nicht ausgewertet werden kann. Wird einem Funktionsaufruf
     wie zum Beispiel `'f(x)' oder `'(f(x))' ein Hochkomma
     vorangestellt, wird ebenfalls eine Substantivform zurÃ¼ckgegeben.


 -- Funktion: nterms (<expr>)
     Die Funktion `nterms' gibt die Anzahl der Terme des Ausdrucks
     <expr> zurÃ¼ck, wobei der Ausdruck als vollstÃ¤ndig expandiert
     angenommen wird, ohne dass Terme gekÃ¼rzt oder zusammengefasst
     werden.

     AusdrÃ¼cke wie `sin(<expr>)', `sqrt(<expr>)' oder `exp(<expr>)'
     werden dabei als ein Term gezÃ¤hlt.


 -- Funktion: op (<expr>)
     Die Funktion `op' gibt den Hauptoperator des Ausdrucks <expr>
     zurÃ¼ck.  `op(<expr>)' ist Ã¤quivalent zu `part(<expr>, 0)'.

     Ist der Hauptoperator des Ausdrucks <expr> ein Operator wie "+",
     "*" oder "/" wird der Name des Operators als Zeichenkette
     zurÃ¼ckgegeben. Andernfalls wird ein Symbol zurÃ¼ckgegeben.

     `op' beachtet den Wert der Optionsvariablen `inflag'. `op' wertet
     seine Argumente aus. Siehe auch `args'.

     Beispiele:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Funktion: operatorp (<expr>, <op>)
 -- Funktion: operatorp (<expr>, [<op_1>, ..., <op_n>])
     Die Funktion `operatorp(<expr>, <op>)' gibt `true' zurÃ¼ck, wenn
     <op> der Hauptoperator des Ausdrucks <expr> ist.

     `operatorp(<expr>, [<op_1>, ..., <op_n>])' gibt `true' zurÃ¼ck,
     wenn einer der Operatoren <op_1>, ..., <op_n> der Hauptoperator
     des Ausdrucks <expr> ist.


 -- Optionsvariable: opsubst
     Hat die Optionsvariable `opsubst' den Wert `false', fÃ¼hrt die
     Funktion `subst' keine Substitution in einen Operator eines
     Ausdrucks aus.  Zum Beispiel hat `(opsubst: false, subst(x^2, r,
     r+r[0]))' das Ergebnis `x^2+r[0]'.


 -- Funktion: optimize (<expr>)
     Die Funktion `optimize' gibt einen Ausdruck zurÃ¼ck, der dasselbe
     Ergebnis und dieselben Seiteneffekte wie <expr> hat, der jedoch
     effizienter ausgewertet werden kann. Im neuen Ausdruck wird die
     mehrfache Berechnung gleicher TeilausdrÃ¼cke vermieden und gleiche
     TeilausdrÃ¼cke werden zusammengefasst.

     Siehe auch die Funktion `collapse'.

     `example(optimize)' zeigt ein Beispiel.


 -- Optionsvariable: optimprefix
     Standardwert: `%'

     Die Optionsvariable `optimprefix' enthÃ¤lt den PrÃ¤fix, der von der
     Funktion `optimize' benutzt wird, um einen Teilausdruck zu
     benennen.


 -- Funktion: ordergreat (<v_1>, ..., <v_n>)
 -- Funktion: orderless (<v_1>, ..., <v_n>)
     Die Funktion `ordergreat' Ã¤ndert die kanonische Anordnung der
     Symbole so, dass <v_1> > <v_2> > ... > <v_n>. Weiterhin ist <v_n>
     grÃ¶Ãer als jedes andere Symbol, das nicht in der Liste enthalten
     ist.

     `orderless' Ã¤ndert die kanonische Anordnung der Symbole so, dass
     <v_1> < <v_2> < ... < <v_n>. Weiterhin ist <v_n> kleiner als jedes
     andere Symbol, das nicht in der Liste enthalten ist.

     Die durch `ordergreat' und `orderless' definierte Ordnung wird
     durch `unorder' wieder aufgehoben. `ordergreat' und `orderless'
     kÃ¶nnen jeweils nur einmal aufgerufen werden, solange nicht mit
     `unorder' zuvor die definierte Ordnung aufgehoben wird.

     Siehe auch `ordergreatp',  `orderlessp'  und `mainvar'.


 -- Funktion: ordergreatp (<expr_1>, <expr_2>)
 -- Funktion: orderlessp (<expr_1>, <expr_2>)
     Die Funktion `ordergreatp' gibt `true' zurÃ¼ck, wenn in der
     kanonischen Ordnung von Maxima <expr_1> grÃ¶Ãer als <expr_2> ist.
     Ansonsten ist das Ergebnis `false'.

     Die Funktion `orderlessp' gibt `true' zurÃ¼ck, wenn in der
     kanonischen Ordnung von Maxima <expr_1> kleiner als <expr_2> ist.
     Ansonsten ist das Ergebnis `false'.

     Alle Maxima-Atome und AusdrÃ¼cke sind vergleichbar unter
     `ordergreatp' und `orderlessp'. Die kanonische Ordnung von Atomen
     ist folgendermaÃen:

     Numerische Konstanten < deklarierte Konstanten < deklarierte
     Skalare < erstes Argument von `orderless' < ...  letztes Argument
     von `orderless' < Variablen beginnend mit a < ... < Variablen
     beginnend mit Z < letztes Argument von `ordergreat' < ...  erstes
     Argument von `ordergreat' < deklarierte Hauptvariablen.

     Die Ordnung fÃ¼r AusdrÃ¼cke, die keine Atome sind, wird von der fÃ¼r
     Atome abgeleitet. FÃ¼r die Operatoren `"+"', `"*"' und `"^"' kann
     die Ordnung nicht einfach beschrieben werden. Andere Operatoren,
     Funktionen und AusdrÃ¼cke werden angeordnet nach den Argumenten,
     dann nach den Namen.  Bei AusdrÃ¼cken mit Indizes wird der Name des
     Symbols als Operator und der Index als Argument betrachtet.

     Die kanonische Ordnung der AusdrÃ¼cke wird modifiziert durch die
     Funktionen `ordergreat' und `orderless' sowie der Deklarationen
     `mainvar', `constant' und `scalar'.

     Siehe auch `sort'.

     Beispiele:

     Ordne Symbole und Konstanten. Beachte, dass `%pi' nicht nach dem
     numerischen Wert sortiert wird.

          (%i1) stringdisp : true;
          (%o1)                         true
          (%i2) sort ([%pi, 3b0, 3.0, x, X, "foo", 3, a, "bar", 4.0, 4b0]);
          (%o2) [3, 3.0, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]

     Anwendung der Funktionen `ordergreat' und `orderless'.

          (%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o1)           [A, E, G, H, J, K, M, P, S, T, W]
          (%i2) ordergreat (S, J);
          (%o2)                         done
          (%i3) orderless (M, H);
          (%o3)                         done
          (%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o4)           [M, H, A, E, G, K, P, T, W, J, S]

     Anwendung der Deklarationen `mainvar', `constant', und `scalar'.

          (%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
          (%i2) declare (aa, mainvar);
          (%o2)                         done
          (%i3) declare ([baz, quux], constant);
          (%o3)                         done
          (%i4) declare ([A1, B1], scalar);
          (%o4)                         done
          (%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]

     Ordne nicht atomare AusdrÃ¼cke.

          (%i1) sort ([f(1), f(2), f(2, 1), g(1), g(1, 2), g(n), f(n, 1)]);
          (%o1) [f(1), g(1), g(1, 2), f(2), f(2, 1), g(n), f(n, 1)]
          (%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
          (%o2)            [1, foo(1), X , k, foo(k), X ]
                                        1              k


 -- Funktion: part (<expr>, <n_1>, ..., <n_k>)
     Die Funktion `part' gibt einen Teilausdruck von <expr> zurÃ¼ck. Der
     Ausdruck <expr> wird zuvor in das Format fÃ¼r die Anzeige
     umgewandelt.

     Der Teilausdruck wird durch die Indizes <n_1>, ..., <n_k>
     ausgewÃ¤hlt.  Zuerst wird der Teilausdruck <n_1> ermittelt, von
     diesem der Teilausdruck <n_2>, u.s.w. Der zum Index <n_k> zuletzt
     gewonnene Teilausdruck ist dann das Ergebnis.

     `part' kann auch verwendet werden, um ein Element einer Liste, der
     Zeile einer Matrix und anderer Objekte zu erhalten.

     Das letzte Argument einer `part'-Funktion kann eine Liste mit
     Indizes sein.  In diesem Fall werden alle angebenen TeilausdrÃ¼cke
     als Ergebnis zurÃ¼ck gegeben. So erhÃ¤lt man zum Beispiel mit dem
     Kommando `part(x + y + z, [1, 3])' das Ergebnis `z+x'.

     Die Systemvariable `piece' enthÃ¤lt den letzten Ausdruck, der bei
     der Verwendung einer `part'-Funktion ausgewÃ¤hlt wurde.

     Hat die Optionsvariable `partswitch' den Wert `true' wird `end'
     zurÃ¼ckgegeben, wenn versucht wurde, einen Teilausdruck zu bilden,
     der nicht existiert, andernfalls wird eine Fehlermeldung
     ausgegeben.

     Siehe auch `inpart',  `substpart',  `substinpart',  `dpart'  und
     `lpart'.

     Beispiele:

          (%i1) part(z+2*y+a,2);
          (%o1)                                 2 y
          (%i2) part(z+2*y+a,[1,3]);
          (%o2)                                z + a
          (%i3) part(z+2*y+a,2,1);
          (%o3)                                  2

     `example(part)' zeigt weitere Beispiele.


 -- Funktion: partition (<expr>, <var>)
     Die Funktion `partition' gibt eine Liste mit zwei AusdrÃ¼cken
     zurÃ¼ck.  Ist <expr> ein Produkt enthÃ¤lt der erste Ausdruck die
     Faktoren, die die Variable `var' enthalten und der zweite Ausdruck
     enthÃ¤lt die Ã¼brigen Faktoren. Entsprechend enthÃ¤lt der erste
     Ausdruck die Terme oder Elemente einer Summe oder einer Liste, die
     <var> enthalten.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Optionsvariable: partswitch
     Standardwert: `false'

     Hat die Optionsvariable `partswitch' den Wert `true', wird `end'
     zurÃ¼ckgegeben, wenn versucht wird, einen Teilausdruck zu bilden,
     der nicht existiert, andernfalls wird eine Fehlermeldung
     ausgegeben.


 -- Funktion: pickapart (<expr>, <n>)
     Den TeilausdrÃ¼cken in einer Tiefe <n> eines verschachtelten
     Ausdrucks werden Zwischenmarken zugewiesen. <n> ist eine ganze
     positive Zahl. Die RÃ¼ckgabe von `pickapart' ist ein Ã¤quivalenter
     Ausdruck, der die Zwischenmarken enthÃ¤lt.

     Siehe auch `part',  `dpart',  `lpart',  `inpart'  und `reveal'.

     Beispiele:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- Systemvariable: piece
     Die Systemvariable `piece' enthÃ¤lt den letzten Ausdruck, der bei
     der Verwendung einer `part'-Funktion ausgewÃ¤hlt wurde.

     Siehe auch `part'  und `inpart'.


 -- Funktion: psubst (<list>, <expr>)
 -- Funktion: psubst (<a>, <b>, <expr>)
     `psubst(<a>, <b>, <expr>)' ist identisch mit `subst'.  Siehe
     `subst'.

     Im Unterschied zu `subst' fÃ¼hrt die Funktion `psubst'
     Substitutionen parallel aus, wenn das erste Argument <list> eine
     Liste mit Gleichungen ist.

     Siehe auch `sublis'  um Substitutionen parallel auszufÃ¼hren.

     Beispiel:

     Das erste Beispiel zeigt die parallele Substitution mit `psubst'.
     Das zweite Beispiel zeigt das Ergebnis fÃ¼r die Funktion `subst'.
     In diesem Fall werden die Substitutionen nacheinander ausgefÃ¼hrt.

          (%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o4)                           sin(b) + sin(a)
          (%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o5)                              2 sin(a)


 -- Funktion: rembox (<expr>, unlabelled)
 -- Funktion: rembox (<expr>, <label>)
 -- Funktion: rembox (<expr>)
     Die Funktion `rembox' entfernt Rahmen aus dem Ausdruck <expr>.
     `rembox(<expr>, unlabelled)' entfernt alle Rahmen, die keine Marke
     haben. `rembox(<expr>, <label>)' entfernt nur Rahmen, die mit der
     Marke <label> gekennzeichnet sind. `rembox(<expr>)' entfernt alle
     Rahmen.

     Rahmen werden von den Funktionen `box', `dpart' und `lpart' einem
     Ausdruck hinzugefÃ¼gt.

     Beispiele:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Funktion: reveal (<expr>, <depth>)
     Ersetzt Teile des Ausdrucks <expr> in der ganzzahligen Tiefe
     <depth> durch eine beschreibende Zusammenfassung.

        * Summen und Differenzen werden durch `Sum(<n>)' ersetzt, wobei
          <n> die Anzahl der Terme der Summe ist.

        * Produkte werden durch `Product(<n>)' ersetzt, wobei <n> die
          Anzahl der Faktoren des Produktes ist.

        * Exponentiationen werden durch `Expt' ersetzt.

        * Quotienten werden durch `Quotient' ersetzt.

        * Die Negation wird durch `Negterm' ersetzt.

        * Listen werden durch `List(<n>)' ersetzt, wobei <n> die Anzahl
          der Elemente der Liste ist.


     Ist <depth> grÃ¶Ãer oder gleich der maximalen Tiefe des Ausdrucks
     <expr>, gibt `reveal' den Ausdruck <expr> unverÃ¤ndert zurÃ¼ck.

     `reveal' wertet seine Argumente aus. `reveal' gibt die
     Zusammenfassung zurÃ¼ck.

     Beispiele:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       Quotient
          (%i3) reveal (e, 2);
                                       Sum(3)
          (%o3)                        ------
                                       Sum(3)
          (%i4) reveal (e, 3);
                               Expt + Negterm + Expt
          (%o4)               ------------------------
                              Product(2) + Expt + Expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - Product(3) + a
          (%o5)         ------------------------------------
                                   Product(2)     Product(2)
                        2 Expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 Sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Funktion: sublis (<list>, <expr>)
     FÃ¼hrt im Unterschied zu der Funktion `subst' die Substitutionen
     der Liste <list> parallel und nicht nacheinander aus.

     Die Optionsvariable `sublis_apply_lambda' kontrolliert die
     Vereinfachung von Lamda-AusdrÃ¼cken nachdem die Substitution
     ausgefÃ¼hrt wurde.

     Beispiele:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Optionsvariable: sublis_apply_lambda
     Standardwert: `true'

     Kontrolliert, ob Lambda-AusdrÃ¼cke nach einer Substitution
     ausgewertet werden.  Hat `sublis_apply_lambda' den Wert `true'
     werden Lambda-AusdrÃ¼cke ausgewertet. Ansonsten verbleiben diese
     nach der Substitution im Ausdruck.


 -- Funktion: subst (<a>, <b>, <c>)
     Substituiert <a> fÃ¼r <b> in den Ausdruck <c>. <b> muss ein Atom
     oder ein vollstÃ¤ndiger Teilausdruck von <c> sein. Zum Beispiel ist
     `x+y+z' ist ein vollstÃ¤ndiger Teilausdruck von `2*(x+y+z)/w', nicht
     aber `x+y'. Hat <b> nicht diese Eigenschaft, dann kÃ¶nnen
     mÃ¶glicherweise die Funktionen `substpart' oder `ratsubst'
     angewendet werden. Hat <b> die Form `e/f', dann kann man
     `subst(a*f, e, c)' nutzen. Ist `b' von der Form `e^(1/f)', dann
     kann man `subst(a^f, e, c)' nutzen. Die Funktion `subst' erkennt
     auch den Ausdruck `x^y' in `x^-y', so dass `subst (a, sqrt(x),
     1/sqrt(x))' das Ergebnis `1/a' hat. <a> und <b> kÃ¶nnen auch die
     Namen von Operatoren oder Funktionen sein. Soll die unabhÃ¤ngige
     Variable in AbleitungsausrÃ¼cken substituiert werden, sollte die
     Funktion `at' genutzt werden.

     `subst' ist der Alias-Name fÃ¼r `substitute'.

     `subst(<eq_1>, <expr>)' und `subst([<eq_1>, ..., <eq_k>], <expr>)'
     sind weitere mÃ¶gliche Formen. <eq_i> sind Gleichungen, die
     angeben, welche Substitutionen durchzufÃ¼hren sind. FÃ¼r jede
     Gleichung wird die rechte Seite der Gleichung fÃ¼r die linke Seite
     in den Ausdruck <expr> substituiert.

     Hat die Optionsvariable `exptsubst' den Wert `true', wird eine
     Substitution wie `y' fÃ¼r `%e^x' in einem Ausdruck der Form
     `%e^(a*x)' nicht ausgefÃ¼hrt.

     Hat die Optionsvariable `opsubst' den Wert `false', wird die
     Funktion `subst' keine Substitution in einen Operator eines
     Ausdrucks ausfÃ¼hren.  Zum Beispiel hat `(opsubst: false,
     subst(x^2, r, r+r[0]))' das Ergebnis `x^2+r[0]'.

     Beispiele:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Weitere Beispiele werden mit `example(subst)' angezeigt.


 -- Funktion: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Die Funktion `substinpart' ist vergleichbar mit `substpart'.
     `substinpart' wirkt jedoch auf die interne Darstellung des
     Ausdrucks <expr>.

     Beispiele:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)


 -- Funktion: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substituiert <x> fÃ¼r den Teilausdruck, der mit den restlichen
     Argumenten der Funktion `substpart' ausgewÃ¤hlt wird. Es wird der
     neue Ausdruck <expr> zurÃ¼ckgegeben. <x> kann auch der Name eines
     Operators sein, der fÃ¼r einen Operator im Ausdruck <expr>
     substituiert wird. Zum Beispiel gibt `substpart("+", a*b, 0)' den
     Ausdruck `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Mit dem Wert `true' fÃ¼r die Optionsvariable `inflag', verhÃ¤lt sich
     die Funktion `substpart' wie `substinpart'.


 -- Funktion: symbolp (<expr>)
     Gibt `true' zurÃ¼ck, wenn <expr> ein Symbol ist, ansonsten `false'.
     `symbolp(x)' ist Ã¤quivalent zu `atom(x) and not numberp(x)'.

     Siehe auch Bezeichner.


 -- Funktion: unorder ()
     LÃ¶scht die Ordnung, die mit dem letzten Aufruf der Funktionen
     `ordergreat' oder `orderless' erzeugt wurde.

     Siehe auch `ordergreat'  und `orderless'.

     Beispiele:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a


 -- Funktion: verbify (<f>)
     Gibt das Verb des Symbols <f> zurÃ¼ck. Siehe auch `verb', `noun'
     und `nounify'.

     Beispiele:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Operatoren,  Next: Auswertung,  Prev: AusdrÃ¼cke,  Up: Top

7 Operatoren
************

* Menu:

* Arithmetische Operatoren::
* Relationale Operatoren::
* Logische Operatoren::
* Operatoren fÃ¼r Gleichungen::
* Zuweisungsoperatoren::
* Benutzerdefinierte Operatoren::


File: maxima.info,  Node: Arithmetische Operatoren,  Next: Relationale Operatoren,  Prev: Operatoren,  Up: Operatoren

7.1 Arithmetische Operatoren
============================

 -- Operator: +
 -- Operator: -
 -- Operator: *
 -- Operator: /
 -- Operator: ^
     Sind die Operatoren der Addition, Multiplikation, Division und
     Exponentiation.  Wird der Name eines Operators in einem Ausdruck
     benÃ¶tigt, kÃ¶nnen die Bezeichnungen `"+"', `"*"', `"/"' und `"^"'
     verwendet werden.

     Die Symbole `+' und `-' reprÃ¤sentieren die unÃ¤re Addition and
     Negation. Die Namen der Operatoren sind `"+"' und `"-"'.

     Die Subtraktion `a - b' wird von Maxima intern als Addition `a +
     (- b)' dargestellt. In der Ausgabe werden die AusdrÃ¼cke `a + (-
     b)' als Subtraktion `a - b' angezeigt. Maxima erkennt `"-"' nur
     als den Namen der unÃ¤ren Negation, nicht jedoch als den binÃ¤ren
     Operator der Subtraktion.

     Die Division `a / b' wird von Maxima intern als Multiplikation `a
     * b^(- 1)' dargestellt. In der Ausgabe werden die AusdrÃ¼cke `a *
     b^(- 1)' als Division `a / b' angezeigt. Der Name des Operators
     fÃ¼r die Division ist `"/"'.

     Die Addition und Multiplikation sind kommutative N-ary-Operatoren.
     Die Division und Exponentiation sind nicht-kommutative binÃ¤re
     Operatoren.

     Maxima sortiert die Argumente eines kommutativen Operators und
     konstruiert eine kanonische Darstellung. FÃ¼r die interne
     Darstellung wird die Ordnung durch `orderlessp' bestimmt. FÃ¼r die
     externe Darstellung der Anzeige wird die Ordnung mit `ordergreatp'
     festgelegt. Ausnahme ist die Multiplikaton.  FÃ¼r diese sind die
     interne und die externe Darstellung identisch. Siehe auch
     `orderlessp'  und `ordergreatp'.

     Arithmetische Rechnungen werden mit Zahlen (ganzen Zahlen,
     rationale Zahlen, Gleitkommazahlen und groÃen Gleitkommazahlen)
     durchgefÃ¼hrt. Mit Ausnahme der Exponentiation werden alle
     arithmetischen Operationen mit Zahlen zu Zahlen vereinfacht. Die
     Exponentiation vereinfacht zu einer Zahl, wenn eines der Argumente
     eine Gleikommazahl ist, oder wenn das Ergebnis eine ganze oder
     rationale Zahl ist. In anderen FÃ¤llen kann die Exponentiation zum
     Beispiel zu einer Wurzelfunktion `sqrt' oder wiederum zu einer
     Exponentiation vereinfachen.

     Bei einer arithmetische Rechnung kann es zur Umwandlung in
     Gleitkommazahlen kommen. Ist eines der Argumente eine groÃe
     Gleitkommazahl, so ist auch das Ergebnis eine groÃe
     Gleitkommazahl. Entsprechend ist das Ergebnis eine einfache
     Gleitkommazahl, sofern mindestens eines der Argumente eine einfache
     Gleitkommazahl ist. Treten nur ganze oder rationale Zahlen auf,
     ist das Ergebnis wieder eine ganze oder rationale Zahl.

     Arithmetische Rechnungen sind Vereinfachungen und keine
     Auswertungen. Daher werden arithmetische Rechnungen auch dann
     ausgefÃ¼hrt, wenn die Auswertung des Ausdrucks durch den
     Quote-Operator verhindert wird.

     Arithmetische Operatoren werden elementweise auf Listen
     angewendet, wenn die Optionsvariable `listarith' den Wert `true'
     hat. Auf Matrizen werden die arithmetischen Operatoren immer
     elementweise angewendet. Ist eines der Argumente eine Liste oder
     Matrix und das andere Argument hat einen anderen Typ, dann wird
     dieses Argument mit jedem Element der Liste oder Matrix kombiniert.

     Beispiele:

     Addition und Multiplikation sind kommutative N-ary-Operatoren.
     Maxima sortiert die Operanden und konstruiert eine kanonische
     Darstellung. Die Namen der Operatoren sind `"+"' und `"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Die Division und Exponentiation sind nicht-kommutative binÃ¤re
     Operatoren. Die Namen der Operatoren sind `"/"' und `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtraktion and Divison werden intern als Addition und
     Multiplikation dargestellt.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Rechnungen werden fÃ¼r Zahlen ausgefÃ¼hrt. Die Umwandlung in
     Gleitkommazahlen wird angewendet.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Arithmetische Rechnungen sind Vereinfachungen und keine Auswertung.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Arithmetische Rechnungen werden elementweise fÃ¼r Listen und
     Matrizen ausgefÃ¼hrt. Bei Listen wird dies mit der Optionsvariablen
     `listarith' kontrolliert.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operator: **
     Ist eine alternative Schreibweise fÃ¼r den Operator `^' der
     Exponentiation. In der Ausgabe wird entweder `^' angezeigt oder der
     Exponent hochgestellt. Siehe `^'.

     Die Funktion `fortran' zeigt den Operator der Exponentiation immer
     als `**' an, unabhÃ¤ngig davon ob `**' oder `^' eingegeben wird.

     Beispiele:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done


 -- Operator: ^^
     Ist der Operator der nicht-kommutativen Exponentiation von
     Matrizen. In der linearen Ausgabe wird der nicht-kommutative
     Operator als `^^' angezeigt.  In der zweidimensionalen Ausgabe
     wird der hochgestellte Exponent von spitzen Klammern `< >'
     eingeschlossen.

     Beispiele:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3


 -- Operator: .
     Ist der Operator fÃ¼r die nicht-kommutative Multiplikation von
     Matrizen.

     Siehe auch `dot',  `dot0nscsimp',  `dot0simp',    `dot1simp',
     `dotassoc',  `dotconstrules',    `dotdistrib',  `dotexptsimp',
     `dotident'    und `dotscrules'.



File: maxima.info,  Node: Relationale Operatoren,  Next: Logische Operatoren,  Prev: Arithmetische Operatoren,  Up: Operatoren

7.2 Relationale Operatoren
==========================

 -- Operator: <
 -- Operator: <=
 -- Operator: >=
 -- Operator: >
     Die Symbole `<', `<=', `>=' und `>' reprÃ¤sentieren die Operatoren
     "kleiner als", "kleiner als oder gleich", "grÃ¶Ãer als oder gleich"
     und "grÃ¶Ãer als". Die Namen dieser Operatoren sind jeweils: `"<"',
     `"<="', `">="' und `">"'. Diese kÃ¶nnen dort eingesetzt werden, wo
     der Name des Operators benÃ¶tigt wird.

     Die relationalen Operatoren sind binÃ¤re Operatoren. AusdrÃ¼cke wie
     `a < b < c' werden von Maxima nicht erkannt.

     Relationale AusdrÃ¼cke werden von den Funktionen `is' und `maybe'
     sowie den Programmbefehlen `if', `while' und `unless' zu boolschen
     Werten ausgewertet. Relationale AusdrÃ¼cke werden ansonsten nicht zu
     boolschen Werten ausgewertet oder vereinfacht. Jedoch werden die
     Argumente eines boolschen Ausdruckes ausgewertet, wenn die
     Auswertung nicht auf andere Weise unterdrÃ¼ckt ist.

     Wenn ein relationaler Ausdruck nicht zu `true' oder `false'
     ausgewertet werden kann, wird das Verhalten von `is' and `if' mit
     der Optionsvariable `prederror' kontrolliert. Hat `prederror' den
     Wert `true', wird von `is' and `if' ein Fehler erzeugt. Hat
     `prederror' den Wert `false', hat `is' den RÃ¼ckgabewert `unknown'
     und `if' gibt einen konditionalen Ausdruck zurÃ¼ck, der teilweise
     ausgewertet ist.

     Die Funktion `maybe' verhÃ¤lt sich immer so, als ob `prederror' den
     Wert `false' hat, und `while' sowie `unless' verhalten sich immer
     so, als ob `prederror' den Wert `true' hat.

     Relationale Operatoren werden nicht auf die Elemente von Listen
     oder Matrizen sowie auf die beiden Seiten einer Gleichung
     angewendet.

     Siehe auch `=',  `#',  `equal'  und `notequal'.

     Beispiele:

     Relationale AusdrÃ¼cke werden von einigen Funktionen zu boolschen
     Werten ausgewertet.

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) is (x < y);
          (%o2)                         true
          (%i3) maybe (y > z);
          (%o3)                         false
          (%i4) if x >= z then 1 else 0;
          (%o4)                           0
          (%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i,
                       return (S));
          (%o5)                         5050

     Relationale AusdrÃ¼cke werden ansonsten nicht zu boolschen Werten
     ausgewertet oder vereinfacht, auch wenn die Argumente eines
     relationalen Ausdruckes ausgewertet werden.

          (%o1)                    [123, 456, 789]
          (%i2) [x < y, y <= z, z >= y, y > z];
          (%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
          (%i3) map (is, %);
          (%o3)               [true, true, true, false]



File: maxima.info,  Node: Logische Operatoren,  Next: Operatoren fÃ¼r Gleichungen,  Prev: Relationale Operatoren,  Up: Operatoren

7.3 Logische Operatoren
=======================

 -- Operator: and
     Ist der logische Operator der Konjunktion. `and' ist ein N-ary
     Infix Operator. Seine Argumente sind boolsche AusdrÃ¼cke und sein
     Ergebnis ist ein boolscher Wert.

     Wie `is' erzwingt `and' die Auswertung aller oder einen Teil seiner
     Argumente.

     Die Argumente werden in der Reihenfolge ausgewertet, in der sie
     auftreten.  `and' wertet nur soviele Argumente aus, wie nÃ¶tig
     sind, um das Ergebnis des Ausdrucks zu bestimmen. Hat irgendein
     Argument den Wert `false', ist das Ergebnis `false' und die
     weiteren Argumente werden nicht ausgewertet.

     Die Optionsvariable `prederror' kontrolliert das Verhalten von
     `and' fÃ¼r den Fall, dass ein Argument nicht zu `true' oder `false'
     ausgewertet werden kann. `and' gibt eine Fehlermeldung, wenn
     `prederror' den Wert `true' hat. Andernfalls werden Argumente, die
     nicht zu `true' oder `false' ausgewertet werden kÃ¶nnen, akzeptiert
     und das Ergebnis ist ein boolscher Ausdruck.

     `and' ist nicht kommutativ, da aufgrund von nicht ausgewerteten
     Argumenten die AusdrÃ¼cke `a and b' und `b and a' ein
     unterschiedliches Ergebnis haben kÃ¶nnen.


 -- Operator: or
     Ist der logische Operator der Disjunktion. `or' ist ein N-ary Infix
     Operator. Seine Argumente sind boolsche AusdrÃ¼cke und sein
     Ergebnis ist ein boolscher Wert.

     Wie `is' erzwingt der Operator `or' die Auswertung aller oder einen
     Teil seiner Argumente.

     Die Argumente werden in der Reihenfolge ausgewertet, in der sie
     auftreten.  `or' wertet nur soviele Argumente aus, wie nÃ¶tig sind,
     um das Ergebnis des Ausdrucks zu bestimmen. Hat irgendein Argument
     den Wert `true', ist das Ergebnis `true' und die weiteren
     Argumente werden nicht ausgewertet.

     Die Optionsvariable `prederror' kontrolliert das Verhalten von
     `or', fÃ¼r den Fall, das ein Argument nicht zu `true' oder `false'
     ausgewertet werden kann. `and' gibt eine Fehlermeldung, wenn
     `prederror' den Wert `true' hat. Andernfalls, werden Argumente, die
     nicht zu `true' oder `false' ausgewertet werden kÃ¶nnen, akzeptiert
     und das Ergebnis ist ein boolscher Ausdruck.

     `or' ist nicht kommutativ, da aufgrund von nicht ausgewerteten
     Argumenten die AusdrÃ¼cke `a or b' und `b or a' ein
     unterschiedliches Ergebnis haben kÃ¶nnen.


 -- Operator: not
     Ist die logische Negation. `not' ist ein Prefix-Operator. Sein
     Argument ist ein boolscher Ausdruck und sein Ergebnis ein
     boolscher Wert.

     Wie `is' erzwingt `not' die Auswertung seiner Argumente.

     Die Optionsvariable `prederror' kontrolliert das Verhalten von
     `not', fÃ¼r den Fall, dass das Argument nicht zu `true' oder `false'
     ausgewertet werden kann. `not' gibt eine Fehlermeldung, wenn
     `prederror' den Wert `true' hat. Andernfalls wird ein Argument, das
     nicht zu `true' oder `false' ausgewertet werden kann, akzeptiert
     und das Ergebnis ist ein boolscher Ausdruck.



File: maxima.info,  Node: Operatoren fÃ¼r Gleichungen,  Next: Zuweisungsoperatoren,  Prev: Logische Operatoren,  Up: Operatoren

7.4 Operatoren fÃ¼r Gleichungen
===============================

 -- Operator: #
     Ist der Operator fÃ¼r eine Ungleichung.

     Wegen der Regeln fÃ¼r die Auswertung von Aussagen und weil `not
     <expr>' die Auswertung des Argumentes <expr> bewirkt, ist der
     Ausdruck `not <a> = <b>' Ã¤quivalent zu `is(<a> # <b>)' und nicht
     zu `<a> # <b>'.

     Beispiele:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operator: =
     Der Operator fÃ¼r Gleichungen.

     Ein Ausdruck `<a> = <b>' reprÃ¤sentiert eine nicht ausgewertete
     Gleichung, welche zutreffen kann oder auch nicht. Nicht
     ausgewertete Gleichungen kÃ¶nnen zum Beispiel als Argument der
     Funktionen `solve' und `algsys' auftreten.

     Die Funktion `is' wertet `=' zu einem boolschen Wert aus.  `is(<a>
     = <b>)' wertet die Gleichung `<a> = <b>' zum Wert `true' aus, wenn
     <a> and <b> identische AusdrÃ¼cke sind. Das trifft zu, wenn <a> und
     <b> identische Atome sind, oder wenn ihre Operatoren sowie die
     Argumente identisch sind. In jedem anderen Fall ist das Ergebnis
     `false'. Das Ergebnis der Auswertung ist nie `unkown'. Hat `is(<a>
     = <b>)' das Ergebnis `true', werden `a' und `b' als syntaktisch
     gleich bezeichnet. Im Unterschied dazu gilt fÃ¼r Ã¤quivalente
     AusdrÃ¼cke, das `is(equal(<a>, <b>))' den Wert `true' hat.
     AusdrÃ¼cke kÃ¶nnen Ã¤quivalent, aber syntaktisch verschieden sein.

     Die Negation von `=' wird durch `#' reprÃ¤sentiert. Wie bei `='
     wird ein Ausdruck `<a> # <b>' nicht ausgewertet. Eine Auswertung
     erfolgt mit `is(<a> # <b>)', welche die Werte `true' oder `false'
     liefert.

     Neben `is' werten auch die Operatoren `if', `and', `or' und `not'
     die Operatoren `=' und `#' zu den Werten `true' oder `false' aus.

     Wegen der Regeln fÃ¼r die Auswertung von Aussagen und weil im
     Ausdruck `not <expr>' das Argument <expr> ausgewertet wird, ist
     `not <a> = <b>' Ã¤quivalent zu `is(<a> # <b>)' und nicht zu `<a> #
     <b>'.

     Die Funktionen `rhs' und `lhs' geben die rechte und die linke einer
     Gleichung oder Ungleichung zurÃ¼ck.

     Siehe auch `equal' und `notequal'.

     Beispiele:

     Ein Ausdruck `<a> = <b>' reprÃ¤sentiert eine nicht ausgewertete
     Gleichung. Diese kann zutreffen oder nicht.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' wertet `<a> = <b>' zu `true' aus, wenn <a> und <b>
     syntaktisch gleich sind. AusdrÃ¼cke kÃ¶nnen Ã¤quivalent sein, ohne
     syntaktisch gleich zu sein.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Einige Operatoren werten `=' und `#' zu `true' oder `false' aus.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
                BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Da `not <expr>' die Auswertung des Ausdrucks <expr> bewirkt, ist
     `not <a> = <b>' Ã¤quivalent zu `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true



File: maxima.info,  Node: Zuweisungsoperatoren,  Next: Benutzerdefinierte Operatoren,  Prev: Operatoren fÃ¼r Gleichungen,  Up: Operatoren

7.5 Zuweisungsoperatoren
========================

 -- Operator: :
     Ist der Operator fÃ¼r die Zuweisung eines Wertes an eine Variable.

     Ist die linke Seite eine Variable (ohne Index), wertet der
     Operator `:' die rechte Seite aus und weist den Wert der Variablen
     auf der linken Seite zu.

     Ist die linke Seite ein Element einer Liste, Matrix oder ein
     deklariertes Maxima- oder Lisp-Array, wird die rechte Seite diesem
     Element zugewiesen. Der Index muss ein existierendes Element
     bezeichnen.

     Ist die linke Seite ein Element eines nicht deklarierten
     Maxima-Array, dann wird die rechte Seite diesem Element
     zugewiesen, falls dieses existiert. Existiert das Element noch
     nicht, wird ein neues Element erzeugt.

     Ist die linke Seite eine Liste mit Variablen (ohne Index), muss
     die rechte Seite zu einer Liste auswerten. Die Elemente der Liste
     auf der rechten Seite werden den Elementen auf der linken Seite
     parallel zugewiesen.

     Siehe auch `kill' und `remvalue' fÃ¼r die Aufhebung der Zuweisung
     eines Wertes an die linke Seite.

     Beispiele:

     Zuweisung an eine einfache Variable.

          (%i1) a;
          (%o1)                           a
          (%i2) a : 123;
          (%o2)                          123
          (%i3) a;
          (%o3)                          123

     Zuweisung an ein Element einer Liste.

          (%i1) b : [1, 2, 3];
          (%o1)                       [1, 2, 3]
          (%i2) b[3] : 456;
          (%o2)                          456
          (%i3) b;
          (%o3)                      [1, 2, 456]

     Die Zuweisung erzeugt ein nicht deklariertes Array.

          (%i1) c[99] : 789;
          (%o1)                          789
          (%i2) c[99];
          (%o2)                          789
          (%i3) c;
          (%o3)                           c
          (%i4) arrayinfo (c);
          (%o4)                   [hashed, 1, [99]]
          (%i5) listarray (c);
          (%o5)                         [789]

     Mehrfache Zuweisung.

          (%i1) [a, b, c] : [45, 67, 89];
          (%o1)                     [45, 67, 89]
          (%i2) a;
          (%o2)                          45
          (%i3) b;
          (%o3)                          67
          (%i4) c;
          (%o4)                          89

     Die mehrfache Zuweisung wird parallel ausgefÃ¼hrt. Die Werte von
     `a' und `b' werden in diesem Beispiel ausgetauscht.

          (%i1) [a, b] : [33, 55];
          (%o1)                       [33, 55]
          (%i2) [a, b] : [b, a];
          (%o2)                       [55, 33]
          (%i3) a;
          (%o3)                          55
          (%i4) b;
          (%o4)                          33


 -- Operator: ::
     Ist der Operator fÃ¼r die Zuweisung eines Wertes an eine Variable.

     `::' ist wie `:' mit der Ausnahme, dass `::' sowohl die rechte als
     auch die linke Seite auswertet.

     Beispiele:

          (%i1) x : 'foo;
          (%o1)                          foo
          (%i2) x :: 123;
          (%o2)                          123
          (%i3) foo;
          (%o3)                          123
          (%i4) x : '[a, b, c];
          (%o4)                       [a, b, c]
          (%i5) x :: [11, 22, 33];
          (%o5)                     [11, 22, 33]
          (%i6) a;
          (%o6)                          11
          (%i7) b;
          (%o7)                          22
          (%i8) c;
          (%o8)                          33


 -- Operator: ::=
     Ist der Operator fÃ¼r die Definition von Makro-Funktionen. `::='
     definiert eine Funktion (aus historischen GrÃ¼nden Makro genannt),
     welche ihre Argumenente nicht auswertet. Der Ausdruck, welcher
     zurÃ¼ckgegeben wird, wird in dem Kontext ausgewertet, in dem das
     Makro aufgerufen wurde. Ansonsten verhÃ¤lt sich eine Makro-Funktion
     wie eine gewÃ¶hnliche Funktion.

     `macroexpand' expandiert ein Makro ohne es auszuwerten.
     `macroexpand(foo(x)' dem `''%' folgt, ist Ã¤quivalent zu `foo (x)',
     wenn `foo' eine Makro-Funktion ist.

     `::=' fÃ¼gt den Namen der neuen Makro-Funktion der Informationsliste
     `macros' hinzu. Die Funktionen `kill', `remove' und `remfunction'
     heben die Zuweisung der Makro-Funktion an ein Symbol auf und
     entfernen die Makro-Funktion von der Informationsliste `macros'.

     `fundef' oder `dispfun' geben die Definition einer Makro-Funktion
     zurÃ¼ck oder weisen die Makro-Funktion einer Marke zu.

     Makro-Funktionen enthalten hÃ¤ufig AusdrÃ¼cke mit den Funktionen
     `buildq' und `splice'. Mit diesen werden AusdrÃ¼cke konstruiert,
     die dann ausgewertet werden.

     Beispiele:

     Eine Makro-Funktion wertet ihre Argumente nicht aus. Daher zeigt
     Beispiel (1) `y - z' und nicht den Wert von `y - z'. Das Makro
     wird in dem Kontext ausgewertet, in dem das Makro aufgerufen wird.
     Dies zeigt (2).

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$

          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                                 %pi

     Eine gewÃ¶hnliche Funktion wertet ihre Argumente aus. Daher zeigt
     (1) den Wert von `y - z'. Der RÃ¼ckgabewert wird nicht ausgewertet
     und gibt (2). Mit `''%' wird die Auswertung erzwungen.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) printe1 (x) := block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$

          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)                     print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                                 %pi

     `macroexpand' gibt die Expansion des Makros zurÃ¼ck.
     `macroexpand(foo(x)' dem `''%' folgt, ist Ã¤quivalent zu `foo (x)',
     wenn `foo' eine Makro-Funktion ist.

          (%i1) x: %pi$

          (%i2) y: 1234$

          (%i3) z: 1729 * w$

          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$

          (%i5) macroexpand (g (y - z));
          (%o5)                     print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                            1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                            1234 - 1729 w


 -- Operator: :=
     Operator fÃ¼r Funktions-Definitionen.  `<f>(<x_1>, ..., <x_n>)' :=
     <expr> definiert eine Funktion mit dem Namen <f>, den Argumenten
     <x_1>, ..., <x_n> und der Funktionsdefinition <expr>. `:=' wertet
     die Funktionsdefinition nie aus (auÃer, bei Anwendung des
     Quote-Quote-Operators `'''). Die definierte Funktion kann eine
     gewÃ¶hnliche Maxima-Funktion sein, deren Argumente in runden
     Klammern eingeschlossen sind, oder eine Array-Funktion mit
     Argumenten, die in eckigen Klammern eingeschlossen sind.

     Ist das letzte oder das einzige Argument der Funktion <x_n> eine
     Liste mit einem Element, dann akzeptiert die mit `:=' definierte
     Funktion eine variable Anzahl an Argumenten. Die Argumente werden
     zunÃ¤chst eins-zu-eins den Argumenten <x_1>, ..., <x_(n - 1)>
     zugewiesen, sind weitere Argumente vorhanden, werden diese <x_n>
     als Liste zugewiesen.

     Funktionsdefinitionen erscheinen in demselben Namensraum. Wird
     eine Funktion `f' innerhalb einer Funktion `g' definiert, wird die
     Reichweite der Funktion nicht automatisch auf `g' beschrÃ¤nkt.
     Dagegen fÃ¼hrt `local(f)' zu einer Definition, die nur innerhalb
     eines Blockes oder einem anderen zusammengesetzten AusdrÃ¼ck
     erscheint.

     Ist eines der Argumente ein Symbol auf das der Quote-Operator
     angewendet wurde, wird dieses Argument nicht ausgewertet.
     Ansonsten werden alle Argumente ausgewertet.

     Siehe auch `define' und `::='.

     Beispiele:

     `:=' wertet die Funktions-Definition nie aus, auÃer wenn der
     Quote-Quote-Operator angewendet wird.

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     Die durch den Operaor `:=' definierte Funktion kann ein gewÃ¶hnliche
     Maxima-Funktion oder eine Array-Funktion sein.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     Ist das letzte oder einzige Argument <x_n> eine Liste mit einem
     Element, akzepiert die Funktion eine variable Anzahl an Argumenten.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     `local' erzeugt eine lokale Funktionsdefinition.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99



File: maxima.info,  Node: Benutzerdefinierte Operatoren,  Prev: Zuweisungsoperatoren,  Up: Operatoren

7.6 EinfÃ¼hrung in benutzerdefinierte Operatoren
================================================

Es ist mÃ¶glich neue Operatoren zu definieren, vorhandene Operatoren zu
entfernen oder deren Eigenschaften zu Ã¤ndern. Es kÃ¶nnen Operatoren mit
den folgenden Eigenschaften definiert werden:

"unÃ¤r Prefix"
     Negation `- a'

"unÃ¤r Postfix"
     FakultÃ¤t `a!'

"binÃ¤r Infix"
     Exponentiation `a^b'

"N-ary Infix"
     Addition `a + b'

"Matchfix"
     Liste `[a,b]'

   Maxima hat keinen implementierten Nofix-Operator, fÃ¼r ein Beispiel
siehe `nofix'.

   Jede Funktion kann als ein Operator definiert werden, die Funktion
kann, muss aber nicht definiert sein.

   Im Folgenden werden die Operatoren `dd' und `"<-"' definiert. Nach
der Definition als Operatoren ist `dd a' gleichbedeutend mit `"dd"(a)'
und `a <- b' entspricht dem Funktionsaufruf `"<-"(a,b)'. In diesem
Beispiel sind die Funktionen `"dd"' und `"<-"' nicht definiert.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   Die Maxima-Funktionen, um Operatoren zu definieren, sind in der
folgenden Tabelle zusammengefasst. Weiterhin sind die Standardvorgaben
fÃ¼r die links- und rechtsseitige Bindungskraft der Operatoren (lbp und
rbp) angegeben. Die BindungskrÃ¤fte bestimmen den Vorrang der Operatoren.

`Prefix'
     rbp=180

`Postfix'
     lbp=180

`Infix'
     lbp=180, rbp=180

`N-ary'
     lbp=180, rbp=180

`Matchfix'
     (Bindungskraft nicht anwendbar)

`Nofix'
     (Bindungskraft nicht anwendbar)

   Die folgende Tabelle enthÃ¤lt die Maxima-Operatoren und deren links-
und rechtsseitigen BindungskrÃ¤fte.

     Operator   lbp     rbp     lpos     rpos     pos

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120             expr              expr
       /        120     120     expr     expr     expr
       +        100     134              expr     expr
       -        100     134              expr     expr
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70      clause   clause   clause
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   Mit den Befehlen `remove' und `kill' kÃ¶nnen Operatoreigenschaften
von einem Symbol entfernt werden. `remove("<a>", op)' entfernt die
Operator-Eigenschaften des Symbols <a>. `kill("<a>")' entfernt alle
Eigenschaften einschlieÃich der Operator-Eigenschaften des Symbols <a>.
In diesem Fall steht der Name des Symbols in AnfÃ¼hrungszeichen.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)

7.7 Funktionen und Variable fÃ¼r benutzerdefinierte Operatoren
==============================================================

 -- Funktion: infix (<op>)
 -- Funktion: infix (<op>, <lbp>, <rbp>)
 -- Funktion: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Deklariert <op> als einen Infix-Operator. Ein Infix-Operator hat
     eine Funktionsdefinition mit zwei Argumenten. Der Infix-Operator
     steht zwischen den Argumenten. Zum Beispiel ist die Subtraktion
     `-' ein Infix-Operator.

     `infix(<op>)' deklariert <op> als einen Infix-Operator mit einer
     links- und rechtsseitigen Bindungskraft von jeweils 180.

     `infix (<op>, <lbp>, <rbp>)' deklariert <op> als einen
     Infix-Operator mit den angegebenen Werten fÃ¼r die links- und
     rechtsseitige Bindungskraft.

     `infix(<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' deklariert <op>
     als einen Infix-Operator mit den angegebenen BindungskrÃ¤ften sowie
     den Wortarten <lpos>, <rpos> und <pos> fÃ¼r den linken und den
     rechten Operanden sowie das Ergebnis des Operators.

     Wortart bedeutet hier, den Type eines Operanden. Maxima kennt die
     drei Typen `expr', `clause' und `any'. Diese stehen fÃ¼r einen
     algebraischen Ausdruck, einen logischen Ausdruck und einen
     beliebigen Ausdruck.  Mit Hilfe der fÃ¼r einen Operator definierten
     Wortart kann der Parser beim Einlesen eines Ausdrucks Syntaxfehler
     feststellen.

     Der Vorrang eines Operators <op> vor anderen Operatoren leitet
     sich aus den links- und rechtsseitigen BindungskrÃ¤ften ab. Sind
     die links- und rechtsseitigen BindungskrÃ¤fte von <op> beide grÃ¶Ãer
     als die links- und rechtsseitige Bindungskraft eines anderen
     Operators, dann hat <op> Vorrang vor dem anderen Operator. Sind
     die BindungskrÃ¤fte nicht beide grÃ¶Ãer oder kleiner, werden weitere
     Regeln zur Bestimmung des Vorrangs herangezogen.

     Die AssoziativitÃ¤t eines Operators <op> hÃ¤ngt ab von seiner
     Bindungskraft. Eine grÃ¶Ãere linksseitige Bindungskraft hat zur
     Folge, dass der Operator <op> vor einem anderen Operator auf
     seiner linken Seite ausgewertet wird. WÃ¤hrend eine grÃ¶Ãere
     rechtsseitige Bindungskraft zur Folge hat, dass der Operator vor
     anderen Operaroten auf der rechten Seite ausgewertet wird. Daraus
     folgt, dass eine grÃ¶Ãere linksseitige Bindungskraft <lbp> einen
     Operator <op> rechts-assoziativ und eine grÃ¶Ãere rechtsseitige
     Bindungskraft <rbp> den Operator links-assoziativ macht. Sind die
     links- und rechtsseitigen BindungskrÃ¤fte gleich groÃ, ist der
     Operator <op> links-assoziativ.

     Siehe auch `Synax'.

     Beispiele:

     Sind die rechtsseitigen und linksseitigen BindungskrÃ¤fte eines
     Operators <op> grÃ¶Ãer als die entsprechenden BindungskrÃ¤fte eines
     anderen Operatores, dann hat der Operator <op> Vorrang.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     Eine grÃ¶Ãere linksseitige Bindungskraft <lbp> bewirkt, dass der
     Operator <op> rechts-assoziativ ist. Eine grÃ¶Ãere rechtsseitige
     Bindungskraft macht dagegen den Operator <op> links-assoziativ.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

     Maxima kann Syntaxfehler beim Einlesen eines Ausdrucks
     feststellen, wenn der eingelesene Operand nicht die fÃ¼r den
     Operator definierte Wortart hat.

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where
          logical expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0


 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>)
 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Deklariert einen Matchfix-Operator mit dem linksseitigen
     Begrenzungszeichen <ldelimiter> und dem rechtsseitigen
     Begrenzungszeichen <rdelimiter>.

     Ein Matchfix-Operator hat eine beliebige Anzahl an Argumenten, die
     zwischen dem linksseitigen und dem rechtsseitigen
     Begrenzungszeichen stehen. Das Begrenzungszeichen kann eine
     beliebige Zeichenkette sein. Einige Zeichen wie `%', `,', `$' und
     `;' kÃ¶nnen nicht als Begrenzungszeichen definiert werden.

     Ein linksseitiges Begrenzungszeichen kann nicht verschiedene
     rechtsseitige Begrenzungszeichen haben.

     Maxima-Operatoren kÃ¶nnen als Matchfix-Operatoren definiert werden,
     ohne dass sich die sonstigen Operatoreigenschaften Ã¤ndern. So kann
     zum Beispiel der Operator `+' als Matchfix-Operator definiert
     werden.

     `matchfix(<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)' definiert
     die Wortarten fÃ¼r die Argumente <arg_pos> und das Ergebnis <pos>
     sowie das linksseitige <ldelimiter> und rechtsseitige <rdelimiter>
     Begrenzungszeichen.

     Wortart bedeutet hier, den Type eines Operanden. Maxima kennt die
     drei Typen `expr', `clause' und `any'. Diese stehen fÃ¼r einen
     algebraischen Ausdruck, einen logischen Ausdruck und einen
     beliebigen Ausdruck.  Mit Hilfe der fÃ¼r einen Operator definierten
     Wortart kann der Parser beim Einlesen eines Ausdrucks Syntaxfehler
     feststellen.

     Die zu einem Matchfix-Operator zugehÃ¶rige Funktion kann jede
     benutzerdefinierte Funktion sein, die mit `:=' oder `define'
     definiert wird. Die Definition der Funktion kann mit
     `dispfun(<ldelimiter>)' ausgegeben werden.

     Der einzige eingebaute Matchfix-Operator ist der Operator fÃ¼r das
     Erzeugen von Listen `[ ]'. Klammern `( )' und AnfÃ¼hrungszeichen
     `" "' arbeiten wie Matchfix-Operatoren, werden aber vom Parser
     nicht als Matchfix-Operatoren behandelt.

     `matchfix' wertet seine Argumente aus. `matchfix' gibt das erste
     Argument <ldelimiter> als Ergebnis zurÃ¼ck.

     Beispiele:

     Begrenzungszeichen kÃ¶nnen eine beliebige Zeichenkette sein.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

     Matchfix-Operatoren kÃ¶nnen fÃ¼r benutzerdefinierte Funktionen
     definiert werden.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Funktion: nary (<x>)
     Ein `N-ary'-Operator ist ein Operator, der eine beliebige Anzahl an
     Argumenten haben kann. Die Argumente werden durch den Operator
     voneinander getrennt, so ist zum Beispiel `+' ein `N-ary'-Operator
     und `A+B+C'. Die Funktion `nary("x")' ermÃ¶glicht die Erweiterung
     der Maxima-Syntax um einen N-ary-Operator `x'. Funktionen kÃ¶nnen
     als N-ary-Operator deklariert werden. `declare(j,nary)' deklariert
     den Operator `j' zu einem N-ary-Operator. Ein Ausdruck
     `j(j(a,b),j(c,d)' wird in diesem Fall zu `j(a,b,c,d)' vereinfacht.

     Siehe auch `Syntax'.


 -- Funktion: nofix (<x>)
     Nofix-Operatoren sind Operatoren, die kein Argument haben. Tritt
     ein solcher Operator allein auf, wird die dazugehÃ¶rige Funktion
     ausgewertet. Zum Beispiel beendet die Funktion `quit()' eine
     Maxima-Sitzung. Wird diese Funktion mit `nofix("quit")' zu einen
     Nofix-Operator deklariert, genÃ¼gt die Eingabe von `quit;', um eine
     Maxima-Sitzung zu beenden. Die Funktion `nofix("x")' erweitert die
     Maxima-Syntax um den Nofix-Operator `x'.

     Siehe auch `Syntax'.


 -- Funktion: postfix (<x>)
     Postfix-Operatoren und Prefix-Operatoren bezeichnen Operatoren mit
     einem Argument, wobei fÃ¼r Postfix-Operatoren der Operator dem
     Argument direkt nachfolgt. Ein Beispiel ist der `!'-Operator mit
     `3!'. Die Funktion `postfix("x")' erweitert die Maxima-Syntax um
     den Postfix-Operator `x'.

     Siehe auch `Syntax'.


 -- Funktion: prefix (<x>)
     Ein Prefix-Operator ist ein Operator mit einem Argument, das dem
     Operator nachfolgt. Mit `prefix("x")' wird die Maxima-Syntax um
     einen Prefix-Operator `x' erweitert.

     Siehe auch `Syntax'.



File: maxima.info,  Node: Auswertung,  Next: Vereinfachung,  Prev: Operatoren,  Up: Top

8 Auswertung
************

* Menu:

* Funktionen und Variablen fÃ¼r die Auswertung::


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r die Auswertung,  Prev: Auswertung,  Up: Auswertung

8.1 Funktionen und Variablen fÃ¼r die Auswertung
================================================

 -- Operator: '
     Der Quote-Operator `'' verhindert die Auswertung eines Ausdrucks.

     Auf ein Symbol angewendet, verhindert der Quote-Operator die
     Auswertung des Symbols.

     Auf eine Funktion angewendet, verhindert der Quote-Operator die
     Auswertung der Funktion. Die Auswertung der Argumente der Funktion
     wird nicht verhindert, falls diese nicht auf andere Weise
     unterdrÃ¼ckt ist. Das Ergebnis ist die Substantivform der Funktion.

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen des
     Ausdrucks innerhalb der Klammern unterdrÃ¼ckt. `'(f(x))' bedeutet,
     dass der Ausdruck `f(x)' nicht ausgewertet werden soll. `'f(x)'
     bedeutet, dass die Substantivform von `f' auf das ausgewertete
     Argument <x> angewendet wird.

     Der Quote-Operator verhindert nur die Auswertung, aber nicht die
     Vereinfachung von AusdrÃ¼cken.

     Substantivformen werden mit einem Hochkomma angezeigt, wenn die
     Optionsvariable `noundisp' den Wert `true' hat.

     Siehe auch den Quote-Quote-Operator `'''  und das Auswertungsflag
     `nouns'.

     Beispiele:

     Auf ein Symbol angewendet, verhindert der Quote-Operator die
     Auswertung des Symbols.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Auf eine Funktion angewendet, verhindert der Quote-Operator die
     Auswertung der Funktion. Das Ergebnis ist die Substantivform der
     Funktion.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen
     innerhalb der Klammern verhindert.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     Der Quot-Operator verhindert nicht die Vereinfachung von
     AusdrÃ¼cken.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

     Maxima fÃ¼hrt Gleitkommarechnungen als eine Vereinfachung aus.

          (%i1) sin(1.0);
          (%o1)                          .8414709848078965
          (%i2) '(sin(1.0));
          (%o2)                          .8414709848078965


 -- Operator: "
     Der Quote-Quote-Operator `''' (zwei Hochkommata) modifiziert die
     Auswertung von AusdrÃ¼cken, die von der Eingabe gelesen werden.

     Wird der Quote-Quote-Operator auf einen allgemeinen Ausdruck <expr>
     angewendet, wird der Ausdruck <expr> durch seinen Wert ersetzt.

     Wird der Quote-Quote-Operator auf den Operator eines Ausdruckes
     angewendet, Ã¤ndert sich der Operator, wenn er in seiner
     Substantivform vorliegt, in die Verbform.

     Der Quote-Quote-Operator wird vom Parser, der die Eingabe liest,
     sofort angewendet und nicht im eingelesen Ausdruck gespeichert.
     Daher kann die Auswertung des Quote-Quote-Operators nicht durch
     einen weiteren Quote-Operator verhindert werden. Der
     Quote-Quote-Operator fÃ¼hrt zur Auswertung von AusdrÃ¼cken, deren
     Auswertung unterdrÃ¼ckt ist. Das ist der Fall fÃ¼r
     Funktionsdefinitionen, Lambda-AusdrÃ¼cke und AusdrÃ¼cke, deren
     Auswertung durch den Quote-Operator verhindert wurde.

     Der Quote-Quote-Operator wird von den Befehlen `batch' und `load'
     erkannt.

     Siehe auch den Quote-Operator `''  und das Auswertungsflag `nouns'.

     Beispiele:

     Wird der Quote-Quote-Operator auf einen Ausdruck <expr>
     angewendet, wird der Wert von <expr> in den Ausdruck eingesetzt.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Wird der Quote-Quote-Operator auf den Operator in einem Ausdruck
     angewendet, Ã¤ndert sich der Operator von seiner Substantivform in
     die Verbform.

          (%i1) declare (foo, noun);
          (%o1)                         done
          (%i2) foo (x) := x - 1729;
          (%o2)                 ''foo(x) := x - 1729
          (%i3) foo (100);
          (%o3)                       foo(100)
          (%i4) ''foo (100);
          (%o4)                        - 1629

     Der Quote-Quote-Operator wird vom Parser sofort auf den
     eingelesenen Ausdruck angewendet und ist nicht Teil eines
     Maxima-Ausdrucks.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Der Quote-Quote-Operator verursacht die Auswertung von AusdrÃ¼cken,
     deren Auswertung auf andere Art unterdrÃ¼ckt ist wie in
     Funktionsdefinitionen, Lambda-AusdrÃ¼cken und AusdrÃ¼cken, auf die
     der Quote-Operator angewendet wurde.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1


 -- Funktion: ev (<expr>, <arg_1>, ..., <arg_n>)
     Wertet den Ausdruck <expr> in einer Umgebung aus, die durch die
     Argumente <arg_1>, ..., <arg_n> spezifiert wird. Die Argumente sind
     Optionsvariablen (Boolsche Variablen), Zuweisungen, Gleichungen
     und Funktionen.  `ev' gibt das Ergebnis der Auswertung zurÃ¼ck.

     Die Auswertung wird in den folgenden Schritten durchgefÃ¼hrt:

       1. Zuerst wird die Umgebung gesetzt. Dazu werden die Argumente
          <arg_1>, ..., <arg_n> ausgewertet. Folgende Argumente sind
          mÃ¶glich:

             * `simp' bewirkt, dass der Ausdruck <expr> vereinfacht
               wird. Der Wert der globalen Optionsvariablen <simp> wird
               dabei ignoriert. Der Ausdruck wird also auch
               vereinfacht, wenn das globale Flag <simp> den Wert
               `false' hat.

             * `noeval' unterdrÃ¼ckt die Auswertungphase der Funktion
               `ev' (siehe Schritt (4) unten). Dies ist nÃ¼tzlich im
               Zusammenhang mit anderen Flags und um einen Ausdruck
               <expr> erneuert zu vereinfachen, ohne dass dieser
               ausgewertet wird.

             * `nouns' bewirkt die Auswertung von Substantivformen.
               Solche Substantivformen sind typischerweise nicht
               ausgewertete Funktionen wie `'integrate' oder `'diff',
               die im Ausdruck <expr> enthalten sind.

             * `expand' bewirkt die Expansion des Ausdruckes.

             * `expand' (<m>, <n>) bewirkt die Expansion, wobei den
               Optionsvariablen `maxposex' und `maxnegex' die Werte der
               Argumente <m> und <n> zugewiesen werden.

             * `detout' bewirkt, dass bei der Berechnung von Inversen
               von Matrizen, die im Ausdruck <expr> enthalten sind,
               Determinaten den Matrizen vorangestellt und nicht
               elementweise in die Matrize herein multipliziert werden.

             * `diff' bewirkt, dass alle Ableitungen ausgefÃ¼hrt werden,
               die im Ausdruck <expr> enhalten sind.

             * `derivlist (<x>, <y>, <z>, ...)' bewirkt, dass nur die
               Ableitungen bezÃ¼glich der angegebenen Variablen <x>,
               <y>, <z>, ...  ausgefÃ¼hrt werden.

             * `risch' bewirkt das Integral in <expr> mit dem
               Risch-Algorithmus berechnet werden. Siehe `risch'. Wird
               `nouns' benutzt, wird der Standardalgorithmus fÃ¼r
               Integrale verwendet.

             * `float' bewirkt, dass rationale Zahlen in
               Gleitkommazahlen konvertiert werden.

             * `numer' bewirkt, dass mathematische Funktionen mit
               numerischen Argumenten ein Ergebnis in Gleitkommazahlen
               liefern. Variable in `expr', denen numerische Werte
               zugewiesen wurden, werden durch diese ersetzt. Die Option
               `float' wird zusÃ¤tzlich wirksam.

             * `pred' bewirkt, dass Aussagen zu `true' oder `false'
               ausgewertet werden.

             * `eval' bewirkt eine zusÃ¤tzliche Auswertung des Ausdrucks
               <expr>.  (Siehe Schritt (5) unten). `eval' kann mehrfach
               angewendet werden. Jedes Auftreten von `eval' fÃ¼hrt zu
               einer weiteren Auswertung.

             * `A', wobei `A' ein Atom ist, das als ein Auswertungsflag
               (siehe `evflag') definiert wurde. WÃ¤hrend der Auswertung
               des Ausdrucks <expr> erhÃ¤lt `A' den Wert `true'.

             * `V: expression' (oder alternativ `V=expression')
               bewirkt, dass `V' wÃ¤hrend der Auswertung des Ausdrucks
               <expr> den Wert `expression' erhÃ¤lt. `V' kann auch eine
               Optionsvariable sein, die fÃ¼r die Auswertung den Wert
               `expression' erhÃ¤lt. Wenn mehr als ein Argument der
               Funktion `ev' Ã¼bergeben wird, wird die Zuweisung der
               Werte parallel ausgefÃ¼hrt. Wenn `V' kein Atom ist, wird
               anstatt einer Zuweisung eine Substitution ausgefÃ¼hrt.

             * `F', wobei `F' der Name einer Funktion ist, die als eine
               Auswertungsfunktion (siehe `evfun') definiert wurde. `F'
               bewirkt, dass die Auswertungsfunktion auf den Ausdruck
               <expr> angewendet wird.

             * Jeder andere Funktionsname (z. B. `sum') bewirkt, dass
               jedes Auftreten dieser Funktion im Ausdruck <expr>
               ausgewertet wird.

             * ZusÃ¤tzlich kann fÃ¼r die Auswertung von <expr> eine
               lokale Funktion `F(x) := expression' definiert werden.

             * Wird ein Atom, eine indizierte Variable oder ein
               indizierter Ausdruck, der oben nicht genannt wurde, als
               Argument Ã¼bergeben, wird das Argument ausgewertet.  Wenn
               das Ergebnis eine Gleichung oder eine Zuweisung ist,
               werden die entsprechenden Zuweisungen und Substitutionen
               ausgefÃ¼hrt. Wenn das Ergebnis eine Liste ist, werden die
               Elemente der Liste als zusÃ¤tzliche Argumente von `ev'
               betrachtet. Dies erlaubt, das eine Liste mit Gleichungen
               (zum Beispiel `[%t1, %t2]', wobei `%t1' und `%t2'
               Gleichungen sind) wie sie zum Beispiel von der Funktion
               `solve' erzeugt wird, als Argument verwendet werden kann.

          Die Argumente der Funktion `ev' kÃ¶nnen in einer beliebigen
          Reihenfolge Ã¼bergeben werden. Ausgenommen sind Gleichungen
          mit Substitutionen, die nacheinander von links nach rechts
          ausgewertet werden, sowie Auswertungsfunktionen, die
          verkettet werden. So wird z. B.  `ev (<expr>, ratsimp,
          realpart)' zu `realpart (ratsimp (<expr>))'.

          Die Flags `simp', `numer', `float' und `pred' kÃ¶nnen
          weiterhin lokal in einem Block oder global in Maxima gesetzt
          werden.

          Ist <expr> ein kanonischer rationaler Ausdruck (CRE =
          canonical rational expression), ist auch das Ergebnis der
          Funktion `ev' ein CRE-Ausdruck, falls nicht die beiden Flags
          `float' und `numer' den Wert `true' haben.

       2. WÃ¤hrend des Schritts (1) wird eine Liste der nicht
          indizierten Variablen erstellt, die auf der linken Seite von
          Gleichungen auftreten. Die Gleichungen kÃ¶nnen dabei entweder
          als Argument oder als Wert eines Argumentes vorliegen.
          Variablen, die nicht in dieser Liste enthalten sind, werden
          durch ihre globalen Werte ersetzt. Davon ausgenommen sind
          Variable, die eine Array-Funktion reprÃ¤sentieren. Ist z. B.
          <expr> eine Marke wie `%i2' im Beispiel unten oder die letzte
          Ausgabe `%', so wird in diesem Schritt der globale Wert
          dieser Marke eingesetzt und die Bearbeitung durch `ev'
          fortgesetzt.

       3. Wenn in den Argumenten Substitutionen aufgefÃ¼hrt sind, werden
          diese nun ausgefÃ¼hrt.

       4. Der resultierende Ausdruck wird erneut ausgewertet, auÃer
          wenn `noeval' unter den Argumente ist, und vereinfacht. Die
          Funktionsaufrufe in <expr> werden erst ausgefÃ¼hrt, wenn die
          enthaltenden Variablen ausgewertet sind.  Dadurch verhÃ¤lt
          sich `ev(F(x))' wie `F(ev(x))'.

       5. Bei jedem Vorkommen von `eval' in den Argumenten werden die
          Schritte (3) und (4) wiederholt.

     Beispiele:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, numer, expand, diff, x=2, y=1);
                                         2
          (%o2)                cos(w) + w  + 2 w + 2.449599732693821

     Anstatt der Anwendung der Funktion `ev' kÃ¶nnen alternativ der
     Ausdruck und die Argumente durch Kommata getrennt eingegeben werden

          <expr>, <arg_1>, ..., <arg_n>

     Diese Kurzschreibweise ist jedoch als Teil eines anderen
     Ausdrucks, zum Beispiel in Funktionen, BlÃ¶cken, usw., nicht
     gestattet.

     Im folgenden Beispiel werden die Zuweisungen parallel durchgefÃ¼hrt.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Spezielles Symbol: eval
     Als Argument des Kommandos `ev(expr),eval' bewirkt `eval' eine
     weitere Auswertung des Ausdrucks `expr'.

     Beispiele:

          (%i1) [a:b,b:c,c:d,d:e];
          (%o1)                            [b, c, d, e]
          (%i2) a;
          (%o2)                                  b
          (%i3) ev(a);
          (%o3)                                  c
          (%i4) ev(a),eval;
          (%o4)                                  e
          (%i5) a,eval,eval;
          (%o5)                                  e


 -- Eigenschaft: evflag
     Wenn ein Symbol <x> die Eigenschaft eines Auswertungsflags
     besitzt, sind die AusdrÃ¼cke `ev(<expr>, <x>)' und `<expr>, <x>'
     Ã¤quivalent zu `ev(<expr>, <x> = true)'. WÃ¤hrend der Auswertung von
     <expr> erhÃ¤lt also <x> den Wert `true'.

     Mit `declare(<x>, evflag)' wird der Variablen <x> die
     `evflag'-Eigenschaft gegeben. Mit `kill' oder `remove' kann diese
     Eigenschaft wieder entfernt werden. Siehe auch `properties' fÃ¼r die
     Anzeige von Eigenschaften.

     Folgende Optionsvariablen haben standardmÃ¤Ãig die
     `evflag'-Eigenschaft:

     `algebraic', `cauchysum', `demoivre', `dotscrules', `%emode',
     `%enumer', `exponentialize', `exptisolate', `factorflag', `float',
     `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpproduct', `simpsum', `sumexpand', und
     `trigexpand'.

     Beispiele:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES


 -- Eigenschaft: evfun
     Wenn eine Funktion <F> die Eigenschaft `evfun' besitzt, sind die
     AusdrÃ¼cke `ev(<expr>, <F>)' und `<expr>, <F>' Ã¤quivalent zu
     `<F>(ev(<expr>))'.

     Zwei oder mehr `evfun'-Funktionen <F>, <G>, ... werden in der
     aufgefÃ¼hrten Reihenfolge angewendet.

     Mit `declare(<F>, evfun)' wird der Funktion <F> die
     `evfun'-Eigenschaft gegeben. Mit `kill' oder `remove' kann diese
     Eigenschaft wieder entfernt werden. Siehe auch `properties' fÃ¼r die
     Anzeige von Eigenschaften.

     Funktionen, die standardmÃ¤Ãig die `evfun'-Eigenschaft besitzen,
     sind:

     `bfloat', `factor', `fullratsimp', `logcontract', `polarform',
     `radcan', `ratexpand', `ratsimp', `rectform', `rootscontract',
     `trigexpand' und `trigreduce'.

     Beispiele:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Optionsvariable: infeval
     Standardwert: `false'

     `infeval' bewirkt, dass `ev' die Auswertung eines Ausdrucks solange
     wiederholt, bis dieser sich nicht mehr Ã¤ndert. Um zu verhindern,
     dass eine Variable in diesem Modus durch die Auswertung
     verschwindet, kann z. B. fÃ¼r eine Variable `x' der Ausdruck `x='x'
     als Argument von `ev' einfÃ¼gt werden. AusdrÃ¼cke wie `ev(x, x=x+1,
     infeval)' fÃ¼hren in diesem Modus zu Endlosschleifen.


 -- Spezielles Symbol: noeval
     `noeval' unterdrÃ¼ckt die Auswertungsphase der Funktion `ev'. Dies
     kann im Zusammenhang mit anderen Auswertungsflags genutzt werden,
     um einen Ausdruck erneut zu vereinfachen, ohne diesen auszuwerten.


 -- Spezielles Symbol: nouns
     `nouns' ist ein Auswertungsflag `evflag'. Wird dieses Flag als eine
     Option der Funktion `ev' genutzt, werden alle Substantivformen,
     die in dem Ausdruck enthalten sind, in Verbformen umgewandelt und
     ausgewertet. Siehe auch `noun',  `nounify',  `verb'  und `verbify'.


 -- Spezielles Symbol: numer
     `numer' bewirkt, dass mathematische Funktionen mit numerischen
     Argumenten als Gleitkommazahlen ausgewertet werden. Variable in
     einem Ausdruck `expr', die numerische Werte erhalten haben, werden
     durch diese ersetzt. ZusÃ¤tzlich wird das Flag `float' gesetzt.

     Siehe auch `%enumer'.

     Beispiele:

          (%i1) [sqrt(2), sin(1), 1/(1+sqrt(3))];
                                                  1
          (%o1)            [sqrt(2), sin(1), -----------]
                                             sqrt(3) + 1

          (%i2) [sqrt(2), sin(1), 1/(1+sqrt(3))],numer;
          (%o2) [1.414213562373095, .8414709848078965, .3660254037844387]


 -- Funktion: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Die Variablen `x_1', ..., `x_n' erhalten die numerischen Werte
     `expr_1', ..., `expr_n'. Die numerischen Werte werden immer dann
     fÃ¼r die Variablen in AusdrÃ¼cke eingesetzt, wenn das Flag `numer'
     den Wert `true' hat. Siehe auch `ev'.

     Die AusdrÃ¼cke `expr1_1', ..., `expr_n' kÃ¶nnen auch AusdrÃ¼cke sein
     und mÃ¼ssen nicht numerische Werte sein.


 -- Spezielles Symbol: pred
     Wird `pred' als ein Argument der Funktion `ev' eingesetzt, werden
     Aussagen zu `true' oder `false' ausgewertet. Siehe `ev'.

     Beispiel:

          (%i1) 1<2;
          (%o1)                                1 < 2
          (%i2) 1<2,pred;
          (%o2)                                true



File: maxima.info,  Node: Vereinfachung,  Next: Mathematische Funktionen,  Prev: Auswertung,  Up: Top

9 Vereinfachung
***************

* Menu:

* EinfÃ¼hrung in die Vereinfachung::
* Funktionen und Variablen fÃ¼r die Vereinfachung::


File: maxima.info,  Node: EinfÃ¼hrung in die Vereinfachung,  Next: Funktionen und Variablen fÃ¼r die Vereinfachung,  Prev: Vereinfachung,  Up: Vereinfachung

9.1 EinfÃ¼hrung in die Vereinfachung
====================================

Einem Operator oder einer Funktion kÃ¶nnen Eigenschaften wie linear,
symmetrisch gegeben werden. Maxima berÃ¼cksichtigt diese Eigenschaften
bei der Vereinfachung eines Ausdrucks. Zum Beispiel wird mit dem
Kommando `declare(f, oddfun)' eine Funktion als ungerade definiert.
Maxima vereinfacht dann jedes Auftreten eines Ausdrucks `f(-x)' zu
`-f(x)'.  Ensprechend vereinfacht Maxima `f(-x)' zu `f(x)', wenn die
Funktion als gerade definiert wurde.

   Maxima kennt die folgenden Eigenschaften, die Operatoren und
Funktionen erhalten kÃ¶nnen:

   linear          additive        multiplicative
   outative        commutative     symmetric
   antisymmetric   nary            lassociativ
   rassociative    evenfun         oddfun


File: maxima.info,  Node: Funktionen und Variablen fÃ¼r die Vereinfachung,  Prev: EinfÃ¼hrung in die Vereinfachung,  Up: Vereinfachung

9.2 Funktionen und Variablen fÃ¼r die Vereinfachung
===================================================

 -- Deklaration: additive
     `declare(f, additive)' deklariert eine Funktion `f' als additiv.

     Hat die Funktion `f' ein Argument, dann wird `f(x + y)' zu `f(x) +
     f(y)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     AdditivitÃ¤t fÃ¼r das erste Argument definiert. Zum Beispiel wird
     `f(x + y,a + b)' zu `f(y, b + a) + f(x, b + a)' vereinfacht.


 -- Deklaration: antisymmetric
     `declare(f, antisymmetric)' deklariert die Funktion `f' als
     antisymmetrisch. Zum Beispiel wird `f(y, x)' zu `- f(x, y)'
     vereinfacht.


 -- Deklaration: commutative
     `declare(f, commutative)' deklariert die Funktion `f' als
     kommutativ.  Zum Beispiel wird `f(x, z, y)' zu `f(x, y, z)'
     vereinfacht.  Dies hat denselben Effekt wie die Deklaration
     `symmetric'.


 -- Funktion: demoivre (<expr>)
 -- Optionsvariable: demoivre
     Die Funktion `demoivre(expr)' konvertiert den Ausdruck <expr>, ohne
     die Optionsvariable `demoivre' zu setzen.

     Hat die Optionsvariable `demoivre' den Wert `true', werden komplexe
     Exponentialfunktionen in Ã¤quivalente Kreisfunktionen umgewandelt.
     `exp(a + b*%i)' wird zu `%e^a*(cos(b)+%i*sin(b))' vereinfacht,
     wenn `b' frei von der imaginÃ¤ren Einheit `%i' ist. `a' und `b'
     werden nicht expandiert.

     Der Standardwert von `demoivre' ist `false'.

     `exponentialize' konvertiert trigonometrische und hyperbolische
     Funktionen in eine Exponentialform. `demoivre' und
     `exponentialize' kÃ¶nnen nicht gleichzeitig den Wert `true' haben.


 -- Funktion: distrib (<expr>)
     Summen werden ausmultipliziert. Im Unterschied zu `expand' wird
     `distrib' nur auf der obersten Ebene eines Ausdruckes angewendet
     und ist daher schneller als `expand'. Im Unterschied zu `multthru'
     werden die Summen der obersten Ebenen vollstÃ¤ndig ausmultipliziert.

     Beispiele:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Optionsvariable: distribute_over
     Standardwert: `true'

     Die Optionsvariable `distribute_over' kontrolliert die Anwendung
     von Funktionen auf Listen, Matrizen oder Gleichungen.

     Diese Eigenschaft wird nicht angewendet, wenn `distribute_over'
     den Wert `false' hat.

     Beispiele:

     Die Funktion `sin' wird auf eine Liste angewendet:

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     Die Funktion `mod' hat zwei Argumente, die auf Listen angewendet
     werden kann. Die Funktion kann auch auf verschachtelte Listen
     angewendet werden:

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     Anwendung der Funktion `floor' auf eine Matrix und eine Gleichung:

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     Funktionen mit mehreren Argumenten kÃ¶nnen auf Listen fÃ¼r eines der
     Argumente oder alle Argumente angewendet werden:

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]


 -- Optionsvariable: domain
     Standardwert: `real'

     Hat `domain' den Wert `complex', wird `sqrt(x^2)' nicht zu
     `abs(x)' vereinfacht.


 -- Funktion: expand (<expr>)
 -- Funktion: expand (<expr>, <p>, <n>)
     Expandiert den Ausdruck <expr>. Produkte von Summen und Potenzen
     von Summen werden ausmultipliziert. Die Nenner von rationalen
     AusdrÃ¼cken, die Summen sind, werden in ihre Terme aufgespalten.
     Produkte (kommutative und nicht-kommutative) werden in Summen
     herein multipliziert.

     FÃ¼r Polynome ist es besser, die Funktion `ratexpand' zu verwenden,
     welche einen effizienteren Algorithmus hat.

     `magnegex' und `maxposex' kontrollieren den maximalen negativen und
     positiven Exponenten, fÃ¼r die ein Ausdruck expandiert wird.

     `expand(<expr>, <p>, <n>)' expandiert <expr>, wobei `maxposex' den
     Wert <p> und `maxnegex' den Wert <n> erhalten.

     `expon' ist der grÃ¶Ãte negative Exponent, fÃ¼r den ein Ausdruck
     automatisch expandiert wird. Hat zum Beispiel `expon' den Wert 4,
     wird `(x+1)^(-5)' nicht automatisch expandiert.

     `expop' ist der grÃ¶Ãte positive Exponent, fÃ¼r den ein Ausdruck
     automatisch expandiert wird. So wird `(x+1)^3' dann automatisch
     expandiert, wenn `expop' grÃ¶Ãer oder gleich 3 ist. Soll `(x+1)^n'
     mit der Funktion `expand' expandiert werden, weil `n' grÃ¶Ãer als
     `expop' ist, dann ist dies nur mÃ¶glich, wenn `n' kleiner als
     `maxposex' ist.

     `expand(expr, 0, 0)' bewirkt eine erneuerte vollstÃ¤ndige
     Vereinfachung des Ausdrucks <expr>. Der Ausdruck wird nicht
     erneuert ausgewertet. Im Unterschied zum Kommando `ev(expr,
     noeval)' wird eine spezielle Darstellung (zum Beispiel eine
     CRE-Form) nicht entfernt. Siehe auch `ev'.

     Das `expand'-Flag wird mit `ev' verwendet, um einen Ausdruck zu
     expandieren.

     Die Datei `simplification/facexp.mac' enthÃ¤lt weitere Funktionen
     wie `facsum', `factorfacsum' und `collectterms' und Variablen wie
     `nextlayerfactor' und `facsum_combine', um AusdrÃ¼cke zu
     vereinfachen. Diese Funktionen werden automatisch geladen und
     erlauben spezielle Expansionen von AusdrÃ¼cken. Eine kurze
     Beschreibung ist in der Datei `simplification/facexp.usg'
     enthalten. Eine Demo kann mit `demo(facexp)' ausgefÃ¼hrt werden.

     Beispiele:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                                2        3
          (%o1)                          (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                           2
                                          + 6 x y + 3 y + x  + 2 x + 1
          (%i3) expand(expr,2);
                                2        3              3          3
          (%o3)                x  (y + 1)  + 2 x (y + 1)  + (y + 1)

          (%i4) expr:(x+1)^-2*(y+1)^3;
                                                    3
                                             (y + 1)
          (%o4)                              --------
                                                    2
                                             (x + 1)
          (%i5) expand(expr);
                         3               2
                        y             3 y            3 y             1
          (%o5)    ------------ + ------------ + ------------ + ------------
                    2              2              2              2
                   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1

          (%i6) expand(expr,2,2);
                                                    3
                                             (y + 1)
          (%o6)                            ------------
                                            2
                                           x  + 2 x + 1

     Vereinfache einen Ausdruck erneut:

          (%i7) expr:(1+x)^2*sin(x);
                                                 2
          (%o7)                           (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                                true
          (%i9) expand(expr,0,0);
                                             2    %i x     - %i x
                                   %i (x + 1)  (%e     - %e      )
          (%o9)                  - -------------------------------
                                                  2


 -- Funktion: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expandiert den Ausdruck `expr' in Bezug auf die Variablen <x_1>,
     ..., <x_n>. Alle Produkte, die die Variablen enthalten, werden
     ausmultipliziert.  Das Ergebnis ist frei von Produkten von Summen,
     die nicht frei von den Variablen sind. <x_1>, ..., <x_n> kÃ¶nnen
     Variable, Operatoren oder AusdrÃ¼cke sein.

     StandardmÃ¤Ãig wird der Nenner eines rationalen Ausdrucks nicht
     expandiert.  Dies kann mit dem Flag `expandwrt_denom' kontrolliert
     werden.

     Die Funktion wird automatisch aus der Datei
     `simplification/stopex.mac' geladen.


 -- Optionsvariable: expandwrt_denom
     Standardwert: `false'

     `expandwrt_denom' kontrolliert die Behandlung von rationalen
     AusdrÃ¼cken durch die Funktion `expandwrt'. Ist der Wert `true',
     werden der ZÃ¤hler und der Nenner eines rationalen Ausdrucks
     expandiert. Ist der Wert `false', wird allein der ZÃ¤hler
     expandiert.


 -- Funktion: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Ist vergleichbar mit `expandwrt', behandelt aber AusdrÃ¼cke
     verschieden, die Produkte enthalten. `expandwrt_factored'
     expandiert nur die Faktoren im Ausdruck `expr', die die Variablen
     <x_1>, ..., <x_n> enthalten.


 -- Optionsvariable: expon
     Standardwert: 0

     `expon' ist der grÃ¶Ãte negative Exponent fÃ¼r den ein Ausdruck
     automatisch expandiert wird. Hat zum Beispiel `expon' den Wert 4,
     wird `(x+1)^(-5)' nicht automatisch expandiert.


 -- Funktion: exponentialize (<expr>)
 -- Optionsvariable: exponentialize
     Die Funktion `exponentialize' konvertiert trigonometrische und
     hyperbolische Funktion in <expr> in Exponentialfunktionen, ohne
     dass die Optionsvariable `exponentialize' gesetzt wird.

     Hat die Optionsvariable `exponentialize' den Wert `true', werden
     trigonometrische und hyperbolischen Funktionen in eine
     Exponentialform konvertiert. Der Standardwert ist `false'.

     `demoivre' konvertiert komplexe Exponentialfunktionen in
     trigonometrische und hyperbolische Funktionen. `exponentialize'
     und `demoivre' kÃ¶nnen nicht gleichzeitig den Wert `true' haben.


 -- Optionsvariable: expop
     Standardwert: 0

     `expop' ist der grÃ¶Ãte positive Exponent, fÃ¼r den ein Ausdruck
     automatisch expandiert wird. So wird `(x+1)^3' dann automatisch
     expandiert, wenn `expop' grÃ¶Ãer oder gleich 3 ist. Soll `(x+1)^n'
     mit der Funktion `expand' expandiert werden, weil `n' grÃ¶Ãer als
     `expop' ist, dann ist dies nur mÃ¶glich, wenn `n' kleiner als
     `maxposex' ist.


 -- Deklaration: lassociative
     `declare(f, lassociative)' deklariert `f' als eine
     links-assoziative Funktion. Zum Beispiel wird `f (f (a,b), f (c,
     d))' zu `f (f (f (a, b), c), d)' vereinfacht.


 -- Deklaration: linear
     `declare(f, linear)' deklariert die Funktion `f' als linear.

     Hat die Funktion `f' ein Argument, dann wird `f(x + y)' zu `f(x) +
     f(y)' und `f(a*x)' zu `a*f(x)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     LinearitÃ¤t fÃ¼r das erste Argument definiert. Zum Beispiel wird
     `f(a*x + b, x)' zu `a f(x, x) + f(1, x) b' vereinfacht.

     `linear' ist Ã¤quivalent zu `additive' und `outative'. Siehe auch
     `opproperties'.


 -- Optionsvariable: maxnegex
     Standardwert: 1000

     `maxnegex' ist der grÃ¶Ãte negative Exponent, der von der Funktion
     `expand' exandieren wird. Siehe auch `maxposex'.


 -- Optionsvariable: maxposex
     Standardwert: 1000

     `maxposex' ist der grÃ¶Ãte positive Exponent, der von der Funktion
     `expand' expandiert wird. Siehe auch `maxnegex'.


 -- Deklaration: multiplicative
     `declare(f, multiplicative)' deklariert die Funktion `f' als
     multiplikativ.

     Hat die Funktion `f' ein Argument, dann wird `f(x*y)' zu
     `f(x)*f(y)' vereinfacht.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     MultiplikativitÃ¤t fÃ¼r das erste Argument definiert. Zum Beispiel
     wird `f(a*x + b, x)' zu `f(g(x), x)*f(h(x), x)' vereinfacht.

     Diese Vereinfachung werden nicht fÃ¼r AusdrÃ¼cke der Form
     `product(x[i], i, m, n)' ausgefÃ¼hrt.


 -- Funktion: multthru (<expr>)
 -- Funktion: multthru (<expr_1>, <expr_2>)
     Multipliziert einen oder mehrere Faktoren in eine Summe herein.
     `multthru' expandiert keine Potenzen von Summen. `multthru' ist
     die effizienteste Methode, um Produkte von Summen
     auszumultiplizieren. Da Maxima intern die Division als ein Produkt
     darstellt, kann `multthru' auch angewendet werden, um einen Nenner
     in eine Summe hereinzumultiplizieren.

     `multthru(<expr_1>, <expr_2>)' multipliziert jeden Term des
     Ausdrucks <expr_2> mit <expr_1>. Der Ausdruck <expr_2> kann dabei
     eine Summe oder eine Gleichung sein.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Optionsvariable: negdistrib
     Standardwert: `true'

     Hat `negdistrib' den Wert `true', wird die Zahl -1 in eine Summe
     hereinmultipliziert. Zum Beispiel wird `-(x + y)' zu `- y - x'
     vereinfacht. `true' ist der Standardwert von `negdistrib'.

     ErhÃ¤lt `negdistrib' den Wert `false' wird `-(x + y)' nicht
     vereinfacht. `negdistrib' sollte sehr umsichtig und nur in
     speziellen FÃ¤llen fÃ¼r lokale Vereinfachungen genutzt werden.


 -- Systemvariable: opproperties
     `opproperties' ist eine Liste mit den Eigenschaften, die eine
     Funktion oder ein Operator erhalten kann.

     MÃ¶gliche Eigenschaften sind:

        linear          additive        multiplicative
        outative        commutative     symmetric
        antisymmetric   nary            lassociativ
        rassociative    evenfun         oddfun


 -- Deklaration: outative
     `declare(f, outative)' deklariert eine Funktion `f' als outative.
     Hat der Operator oder die Funktion Argumente mit konstanten
     Faktoren, so werden diese konstanten Faktoren herausgezogen.

     Hat die Funktion `f' ein Argument, dann wird `f(a*x)' zu `a*f(x)'
     vereinfacht, wenn `a' ein konstanter Faktor ist.

     Ist `f' eine Funktion mit zwei oder mehr Argumenten, ist die
     OutativitÃ¤t fÃ¼r das erste Argument definiert. Zum Beispiel wird
     `f(a*g(x), x)' zu `a*f(g(x),x)' vereinfacht, wenn `a' ein
     konstanter Faktor ist.

     Die Funktionen `sum', `integrate' und `limit' haben die
     Eigenschaft `outative'.


 -- Funktion: radcan (<expr>)
     Simplifies <expr>, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, `radcan'
     produces a regular form. Two equivalent expressions in this class
     do not necessarily have the same appearance, but their difference
     can be simplified by `radcan' to zero.

     For some expressions `radcan' is quite time consuming.  This is
     the cost of exploring certain relationships among the components
     of the expression for simplifications based on factoring and
     partial-fraction expansions of exponents.

     Beispiele:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1


 -- Optionsvariable: radexpand
     Standardwert: `true'

     `radexpand' kontrolliert die Vereinfachung von Wurzeln.

     Hat `radexpand' den Wert `all', werden die nten-Wurzeln der
     Faktoren eines Produktes, die eine n-te Potenz sind, aus der
     Wurzel herausgezogen. Zum Beispiel vereinfacht `sqrt(16*x^2' zu
     `4*x'.

     Inbesondere vereinfacht der Ausdruck `sqrt(x^2)' folgendermaÃen:

        * Hat `radexpand' den Wert `all' oder wurde `assume(x>0)'
          ausgefÃ¼hrt, dann vereinfacht `sqrt(x^2)' zu `x'.

        * Hat `radexpand' den Wert `true' und `domain' ist `real', dann
          vereinfacht `sqrt(x^2)' zu `abs(x)'.

        * Hat `radexpand' den Wert `false' oder hat `radexpand' den Wert
          `true' und `domain' ist `complex', dann wird `sqrt(x^2)'
          nicht vereinfacht.



 -- Deklaration: rassociative
     `declare(f, rassociative)' deklariert die Funktion `f' als
     rechts-assioziativ. Zum Beispiel wird `f(f(a, b), f(c, d))' zu
     `f(a, f(b, f(c, d)))' vereinfacht.


 -- Funktion: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Sequential Comparative Simplification (Methode nach Stoute).

     `scsimp' versucht den Ausdruck <expr> mit Hilfe der Regeln
     <rule_1>, ..., <rule_n> zu vereinfachen. Die Regeln werden
     nacheinander solange angewendet, bis sich der Ausdruck nicht
     weiter vereinfacht. FÃ¼hrt keine der Regeln zu einem Erfolg, wird
     der ursprÃ¼ngliche Ausdruck zurÃ¼ckgegeben.

     `example(scsimp)' zeigt einige Beispiele.


 -- Optionsvariable: simp
     Standardwert: `true'

     `simp' kontrolliert die Vereinfachung von AusdrÃ¼cken. Der
     Standardwert von `simp' ist `true' und AusdrÃ¼cke werden
     vereinfacht. `simp' ist auch ein Auswertungsschalter fÃ¼r die
     Funktion `ev'. Siehe `ev'.

     Wird `simp' als ein Auswertungschalter mit dem Wert `false'
     genutzt, dann wird die Vereinfachung nur wÃ¤hrend der
     Auswertungsphase unterdrÃ¼ckt.  `simp' kann nicht die Vereinfachung
     unterdrÃ¼cken, die sich der Auswertung anschlieÃt.

     Beispiele:

     Die Vereinfachung wird ausgeschaltet. Der Ausdruck `sin(1.0)' wird
     nicht zu einem numerischen Wert vereinfacht. Der
     Auswertungsschalter `simp' schaltet die Vereinfachung ein.

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     Die Vereinfachung wird wieder eingeschaltet. Der
     Auswertungsschalter `simp' kann die Vereinfachung nicht
     vollstÃ¤ndig unterdrÃ¼cken. In der Ausgabe ist der Ausdruck
     vereinfacht, aber die Variable `x' enthÃ¤lt einen nicht
     vereinfachten Ausdruck, da die Zuweisung noch wÃ¤hrend der
     Auswertungsphase des Ausdrucks vorgenommen wurde.

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)


 -- Deklaration: symmetric
     `declare(f, symmetric)' deklariert die Funktion `f' als
     symmetrisch.  Zum Beispiel wird `f(x, z, y)' zu `f(x, y, z)'
     vereinfacht.

     `commutative' entspricht `symmetric'.


 -- Funktion: xthru (<expr>)
     Die Terme einer Summe des Ausdrucks <expr> werden so
     zusammengefasst, dass sie einen gemeinsamen Nenner haben. Produkte
     und Potenzen von Summen werden dabei nicht expandiert. Gemeinsame
     Faktoren im ZÃ¤hler und Nenner werden gekÃ¼rzt.

     Es kann vorteilhaft sein, vor dem AusfÃ¼hren von `ratsimp' zunÃ¤chst
     mit `xthru' die gemeinsamen Faktoren eines rationalen Ausdrucks zu
     kÃ¼rzen.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)




Local Variables:
coding: utf-8
End:
