/* This file contains tests added since April 2002 */

kill(all);
done$

/* apropos function added 7 april 2002 */
apropos('tr_optimize_max_loop);
[tr_optimize_max_loop]$

/* test introduced 7 april 2002. bug fix incorporated 9 june 2002 */
integrate(3^log(x),x);
3^((1/log(3)+1)*log(x))/((1/log(3)+1)*log(3))$

/* wester[1995] problem 84 
   Bug 541030 fixed 2006-02-27, rev 1.14 of src/sin.lisp */
integrate(sqrt(x+1/x-2),x,0,1);
4/3$

/* bug reported by kevin ellwood.  fixed mar 11 2004 */
integrate(exp(-k*t)/sqrt(k*t),t);
sqrt(%pi)*erf(sqrt(k*t))/k$

/* a bug in chebyf.  fixed 20 apr 2004. */

kill(t,k);
done$
integrate(sqrt(k*t)*t,t);
2*t^2*sqrt(k*t)/5$
integrate(sqrt(k*t)*t^(1/3),t);
6*t^(4/3)*sqrt(k*t)/11$
integrate(sqrt(k*t)/t^(3/2),t);
sqrt(k*t)*log(t)/sqrt(t)$
integrate(sqrt(k*t)/sqrt(t),t);
sqrt(t)*sqrt(k*t)$
kill(t,k);
done$

/* lisp error observed by stavros macrakis (#956730).  fixed 2004-05-20. */

block([context:'foobar],
  assume(n+1<0),
  declare(n,integer),
  errcatch(integrate(x^n,x,0,inf)));
[]$

error;
''([sconcat("Integral is divergent")])$

killcontext('foobar);
done$

/* second thru tenth code added 9 june 2002 */
l : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$
first(l);
1$ 
second(l);
2$
third(l);
3$
fourth(l);
4$
fifth(l);
5$
sixth(l);
6$
seventh(l);
7$
eighth(l);
8$
ninth(l);
9$
tenth(l);
10$

/* assoc tests */
assoc(1,[x=2]);
false$
assoc(x,[x=2]);
2$
assoc(1,[x=2],foobar);
foobar$

/* some older versions of gcl had a bug that resulted in a failure of the */
/* following. */
primep(80630964769);
true$


/* maxima has a bug causing an incorrect answer for the second integral. */
integrate(diff(f(x,y),x,1,y,1),x);
'diff(f(x,y),y,1)$
integrate(diff(f(x,y),x,1,y,1),y);
'diff(f(x,y),x,1)$
/* the same bug causes a bug with the second integral in this set. */
h(x,y):=x*y*diff(f(x,y),x,1,y,1);
h(x,y):=x*y*diff(f(x,y),x,1,y,1)$
integrate(h(x,y),x);
'integrate(x*'diff(f(x,y),x,1,y,1)*y,x)$
integrate(h(x,y),y);
'integrate(x*'diff(f(x,y),x,1,y,1)*y,y)$

/* trigrat example from manual - fixed june 2002 */
trigrat(sin(3*a)/sin(a+%pi/3));
sqrt(3)*sin(2*a)+cos(2*a)-1;

/* another trigrat from manual
 * call ratsimp because result is not simplified same as expected result ... strange
 */

(sin(a)^2*sin(3*b+3*a)^2/sin(b+a)^2
    -2*sin(a)*sin(3*a)*cos(b)*sin(b+a-%pi/3)*sin(3*b+3*a)
    /(sin(a-%pi/3)*sin(b+a))
    +sin(3*a)^2*sin(b+a-%pi/3)^2/sin(a-%pi/3)^2,
 result : trigrat (%%),
 expected :
     (- (sqrt(3)*sin(4*b + 4*a) - cos(4*b + 4*a)
      - 2*sqrt(3)*sin(4*b + 2*a) + 2*cos(4*b + 2*a)
      - 2*sqrt(3)*sin(2*b + 4*a) + 2*cos(2*b + 4*a)
      + 4*sqrt(3)*sin(2*b + 2*a) - 8*cos(2*b + 2*a) - 4*cos(2*b - 2*a)
      + sqrt(3)*sin(4*b) - cos(4*b) - 2*sqrt(3)*sin(2*b) + 10*cos(2*b)
      + sqrt(3)*sin(4*a) - cos(4*a) - 2*sqrt(3)*sin(2*a) + 10*cos(2*a)
      - 9)/4),
 ratsimp (result - expected));
0;

/* verify that trigrat distributes over composite objects
 * resolves SF bug reports # 1732315 and 1562340.
 */

trigrat (matrix ([1, 2], [3, 4]));
''(matrix ([trigrat(1), trigrat(2)], [trigrat(3), trigrat(4)]));

trigrat ({1, 2, 3});
''({trigrat(1), trigrat(2), trigrat(3)});

trigrat ([1, 2, 3]);
''([trigrat(1), trigrat(2), trigrat(3)]);

(kill (a, b), trigrat ([a < b, a <= b, a = b, a # b, a >= b, a > b]));
''([trigrat(a) < trigrat(b),
    trigrat(a) <= trigrat(b),
    trigrat(a) = trigrat(b),
    trigrat(a) # trigrat(b),
    trigrat(a) >= trigrat(b),
    trigrat(a) > trigrat(b)]);

/* compile() will fail with gcl if gcc not installed */
f(x):=x+2;
f(x):=x+2;
f(2);
4;
compile(f);
[f];
f(2);
4;
/* some tests for lambda expressions.
  we test for both translate and compile because there are some compiler
  macros for translated code (defined via defopt) */
define_variable(qwerty,1,fixnum);
1;
/* m-tlambda */
f():=apply(lambda([u],u+qwerty),[1]);
f():=apply(lambda([u],u+qwerty),[1]);
f();
2;
translate(f);
[f];
f();
2;
compile(f);
[f];
f();
2;
/* m-tlambda&env */
f(x):=apply(lambda([u],u+x),[1]);
f(x):=apply(lambda([u],u+x),[1]);
f(1);
2;
translate(f);
[f];
f(1);
2;
compile(f);
[f];
f(1);
2;
/* m-tlambda&env */
f(x,qwerty):=apply(lambda([u],u+x+qwerty),[1]);
f(x,qwerty):=apply(lambda([u],u+x+qwerty),[1]);
f(1,0);
2;
translate(f);
[f];
f(1,0);
2;
compile(f);
[f];
f(1,0);
2;
/* m-tlambda&env (outer) and m-tlambda (inner) */
f(x):=apply(lambda([u],x+apply(lambda([v],v+qwerty),[u])),[-1]);
f(x):=apply(lambda([u],x+apply(lambda([v],v+qwerty),[u])),[-1]);
f(2);
2;
translate(f);
[f];
f(2);
2;
compile(f);
[f];
f(2);
2;
/* m-tlambda& */
f():=apply(lambda([u,[v]],[u+qwerty,v]),[0,2,3]);
f():=apply(lambda([u,[v]],[u+qwerty,v]),[0,2,3]);
f();
[1,[2,3]];
translate(f);
[f];
f();
[1,[2,3]];
compile(f);
[f];
f();
[1,[2,3]];
/* m-tlambda&env& */
f(x):=apply(lambda([u,[v]],[u+x,v]),[0,2,3]);
f(x):=apply(lambda([u,[v]],[u+x,v]),[0,2,3]);
f(1);
[1,[2,3]];
translate(f);
[f];
f(1);
[1,[2,3]];
compile(f);
[f];
f(1);
[1,[2,3]];
/* m-tlambda&env (from the sum), the inner lambda currently remains
  untranslated.  this is really a test for fungen&env-for-mevalsumarg. */
f(n):=sum(apply(lambda([x],i+x),[i]),i,1,n);
f(n):=sum(apply(lambda([x],i+x),[i]),i,1,n);
f(3);
12;
translate(f);
[f];
f(3);
12;
compile(f);
[f];
f(3);
12;
kill(qwerty,f);
done;
/* this should kill f, but doesn't which upsets subsequent tests
   redefining it then killing it does the right thing */
f(x):=x+3;
f(x):=x+3;
kill(f);
done;

/* trignometric and hyperbolic functions of complex arguments */
sin(%i*z);
%i*sinh(z);
cos(%i*z);
cosh(z);
tan(%i*z);
%i*tanh(z);
csc(%i*z);
-%i*csch(z);
sec(%i*z);
sech(z);
cot(%i*z);
-%i*coth(z);
sinh(%i*z);
%i*sin(z);
cosh(%i*z);
cos(z);
tanh(%i*z);
%i*tan(z);
csch(%i*z);
-%i*csc(z);
sech(%i*z);
sec(z);
coth(%i*z);
-%i*cot(z);

/* trigreduce(sinh(x)^n)) wrong for some cases.  fixed 4 oct 2003 */
trigreduce(sin(x)^2);
(1-cos(2*x))/2;
trigreduce(sin(x)^3);
(3*sin(x)-sin(3*x))/4;
trigreduce(sin(x)^4);
(cos(4*x)-4*cos(2*x)+3)/8;
trigreduce(sin(x)^5);
(sin(5*x)-5*sin(3*x)+10*sin(x))/16;
trigreduce(cos(x)^2);
(cos(2*x)+1)/2;
trigreduce(cos(x)^3);
(cos(3*x)+3*cos(x))/4;
trigreduce(cos(x)^4);
(cos(4*x)+4*cos(2*x)+3)/8;
trigreduce(cos(x)^5);
(cos(5*x)+5*cos(3*x)+10*cos(x))/16;
trigreduce(sinh(x)^2);
(cosh(2*x)-1)/2;
trigreduce(sinh(x)^3);
(sinh(3*x)-3*sinh(x))/4;
trigreduce(sinh(x)^4);
(cosh(4*x)-4*cosh(2*x)+3)/8;
trigreduce(sinh(x)^5);
(sinh(5*x)-5*sinh(3*x)+10*sinh(x))/16;
trigreduce(cosh(x)^2);
(cosh(2*x)+1)/2;
trigreduce(cosh(x)^3);
(cosh(3*x)+3*cosh(x))/4;
trigreduce(cosh(x)^4);
(cosh(4*x)+4*cosh(2*x)+3)/8;
trigreduce(cosh(x)^5);
(cosh(5*x)+5*cosh(3*x)+10*cosh(x))/16;

/* de moivre's theorem - abramowitz & stegun 4.3.48, 4.5.53 */
expand(trigreduce(expand((cos(x)+%i*sin(x))^2)));
%i*sin(2*x)+cos(2*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^3)));
%i*sin(3*x)+cos(3*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^4)));
%i*sin(4*x)+cos(4*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^5)));
%i*sin(5*x)+cos(5*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^6)));
%i*sin(6*x)+cos(6*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^7)));
%i*sin(7*x)+cos(7*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^8)));
%i*sin(8*x)+cos(8*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^9)));
%i*sin(9*x)+cos(9*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^2)));
sinh(2*x)+cosh(2*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^3)));
sinh(3*x)+cosh(3*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^4)));
sinh(4*x)+cosh(4*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^5)));
sinh(5*x)+cosh(5*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^6)));
sinh(6*x)+cosh(6*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^7)));
sinh(7*x)+cosh(7*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^8)));
sinh(8*x)+cosh(8*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^9)));
sinh(9*x)+cosh(9*x);

/* bug 835287 */
solve('diff(y,x),'diff(y,x));
['diff(y,x,1)=0];

/* multiplicity bug in solve.lisp 1.3 - 13 may 2004 */
eigenvalues(matrix([3,1,0,0],[-4,-1,0,0],[7,1,2,1],[-17,-6,-1,0]));
[[1],[4]];

/* Bug 1369669 */
trigexpand(csc(3*x));
csc(x)^3*sec(x)^3/(3*csc(x)^2*sec(x)-sec(x)^3);

/* Bug 1369451 */
trigexpand(sec(x+y));
csc(x)*sec(x)*csc(y)*sec(y)/(csc(x)*csc(y)-sec(x)*sec(y));

/* Bug 1309377 */
(fpred(x) := (prederror:'false, is(x <= -1)),0);
0$

fpred(xyzzy);
unknown$
translate(fpred);
[fpred]$
fpred(xyzzy);
unknown$

/* Bug 1281737 */
limit(atan(x)/(1/exp(1)-exp(-(1+x)^2)),x,inf,'plus);
%e*%pi/2;

/* Bug 1363411 */
'sum(1+f(k),k,1,2),simpsum;
f(2) + f(1) + 2;

/* Bug 1403415, fixed in clmacs.lisp rev 1.20 */
float(0.0b0);
0.0;

/* Bug 1404754, fixed in float.lisp rev 1.23 */
1.0b0*x;
1.0b0*x;

/* Bug 1374704.  See also 1418010 because result isn't simplified. */
(assume(cos(x)>0),0);
0;
integrate(sin(x)/cos(x)^2,x,0,%pi/3);
1$

/*
 * Test compiled array access
 */
use_fast_arrays:false;
false;

(ar:make_array('fixnum,3,2),0);
0;
(aref(array,row,col):=array[row,col],0);
0;
ar[2,1]:1;
1;
aref(ar,2,1);
1;
compile(aref);
[aref];
aref(ar,2,1);
1;
/* A old-style maxima hashed array */
har[2,1]:1;
1;
aref(har,2,1);
1;

use_fast_arrays:true;
true;
har2[3,4]:12;
12;
aref(har2,3,4);
12;

/*
 * This test from Fabrizio Caruso, maxima list, 2006/02/14 
 *
 * We're basically trying to test that the compiled version of foo
 * returns a fixnum array, just like the interpreted one.
 */
(foo(x) := block([r], r : make_array('fixnum,2), r[0]:x,r[1]:x+1, return(r)),0);
0$

(expr : foo(7), arrayinfo(expr));
[declared,1,[1]]$

compile(foo);
[foo];

(expr : foo(7), arrayinfo(expr));
[declared,1,[1]]$

use_fast_arrays:false;
false;

/* Bug 1405931: integrate(log(x)/(x^2+1)^2,x,0,inf)
 */
integrate(log(x)/(x^2+1)^2,x,0,inf);
-%pi/4;

/*
 * Bug 941457: integrate(1/x^5,x,1,2^(1/78))
 * Fixed 2006/03/13.  Solution needs work, though.
 */
integrate(1/x^5,x,1,2^(1/78));
1/4-1/(4*2^(2/39));

/*
 * Bug 938235: integrate((1/2)*u^2-1/u^5,u,1,sqrt(2))
 * Fixed 2006/03/13.  Solution needs work, though.
 */
integrate((1/2)*u^2-1/u^5,u,1,sqrt(2));
sqrt(2)/3-17/48;

/*
 * These next two cases are regression tests.  Rev 1.11 of sin.lisp
 * caused different (much messier) results to be returned.
 */
integrate(sin(2*x)/sec(x),x);
-2*cos(x)^3/3;

integrate(-a*sin(2*x)/(a*sin(x)^2+b),x);
-log(a*sin(x)^2+b);

/*
 * Bug 1471861: limit(abs(sin(x)/x),x,0);
 * Fixed 2006/05/05, limit.lisp, rev 1.20.
 */
limit(abs(sin(x)/x),x,0);
1;

/* 
 * Bug 1482843: subscripted variable causes trouble in integrate
 *
 * Fixed in defint.lisp, rev 1.25, 2006/05/06.
 */
integrate(exp(-(x-mu[1])^2),x,0,inf);
sqrt(%pi)*erf(mu[1])/2+sqrt(%pi)/2;

/*
 * Bug 1487703: integrate((sqrt(x^4-6*x^2+1)-x^2+1)/(2*x),x) fails
 *
 * Fixed in sin.lisp, 2006/05/14.  We don't loop forever anymore.
 */
integrate((sqrt(x^4-6*x^2+1)-x^2+1)/(2*x),x);
('integrate((sqrt(x^2+2*x-1)*sqrt(x^2-2*x-1))/x,x)+log(x)-x^2/2)/2;

/*
 * Bug mentioned in mailing-list, 2006-05-31, "problem with bigfloats"
 */
exp(1.0b-1);
1.105170918075648b0;

/* sqrt(0b0) loops endlessly (bug report # 1515703)
 * asin(1b0) triggers same bug (it eventually calls sqrt(0b0))
 * Problem was in FPROOT.
 */

sqrt(0b0);
0b0;

/* 0b0^(1/n) is not routed through FPROOT. Test it anyway. */
[0b0^(1/2), 0b0^(1/3), 0b0^(1/17)];
[0b0, 0b0, 0b0];

asin(1b0);
''(bfloat(%pi/2));

asin(-1b0);
''(-bfloat(%pi/2));

/* li[2](1.0) stack overflow (bug report # 1514861)
 */

li[2](1.0);
''(ev (%pi^2/6, numer));

/* bug report [ 782046 ] limit(abs(x),x,0) fails
 * appears to be fixed in 5.9.3cvs -- verify
 */

limit (abs(x), x, 0);
0;

/* Related to Bug [1044318] defint(1/(sin(x)^2+1),x,0,3*%pi)
 *
 * integrate(1/(sin(x)^2+1),x,0,n*2*%pi) should be
 * n*integrate(1/(sin(x)^2+1),x,0,2*%pi), for positive integer n.  We
 * were just returning the same value.  
 */
integrate(1/(sin(x)^2+1),x,0,2*%pi);
sqrt(2)*%pi;

integrate(1/(sin(x)^2+1),x,0,4*%pi);
2*sqrt(2)*%pi;

integrate(1/(sin(x)^2+1),x,0,20*%pi);
10*sqrt(2)*%pi;

/*
 * Bug  1547769:  integrate(sqrt(x^3/(2*a-x)),x,0,2*a);
 *
 * We don't get an internal error, and we should be able to evaluate
 * this.  defint.lisp, rev 1.27
 */
(assume(a > 0), 0);
0;

integrate(sqrt(x^3/(2*a-x)),x,0,2*a);
3*%pi*a^2/2;

/*
 * Bug [ 1548643 ] limit with abs: tag LIMIT is undefined
 */
limit(abs(sqrt(1-1/x)-1),x,0);
und;

/*
 * Bug [1044318] defint(1/(sin(x)^2+1),x,0,3*%pi)
 *
 * But there are other bugs related to this one.
 */
integrate(1/(sin(x)^2+1),x,0,3*%pi);
(3 / 2) * sqrt(2)*%pi;

/*
 * Bug [1504505] integrate( 1/(x^8-1),x,0,1/2) => internal error
 *
 * Fixed in residu.lisp, 1.5.
 *
 * The call to factor is to get rid of some numerical factors.
 */
ratsimp(ev(logcontract((integrate(1/(x^8-1),x,0,1/2))),algebraic) + 
(sqrt(2)*log((20*sqrt(2)+33)/17)+2*sqrt(2)*atan((sqrt(2)+2)/2)
                                 +2*sqrt(2)*atan((sqrt(2)-2)/2)+log(9)
                                 +4*atan(1/2))
 /16);
0;

/*
 * Bug [ 1582625 ] integrate(t^2*log(t)/((t^2-1)*(t^4+1)), t, 0, 1) wrong?
 *
 * Fixed in defint.lisp
 *
 */
integrate(t^2*log(t)/((t^2-1)*(t^4+1)), t, 0, 1);
-((sqrt(2)-2)*%pi^2/32);

/*
 * Bug [ 1073338 ] integrate yields incorrect result on rational function
 *
 * Here's one of the tests listed in that bug report.
 */
logcontract(ratsimp(factor(integrate (1/((x-3)^4+1), x,0,1)))),algebraic;
(sqrt(2)*log(-((190*sqrt(2)-747)/697))+2*sqrt(2)*atan((7*sqrt(2)+5)/73)
				    +2*sqrt(2)*atan((7*sqrt(2)-5)/73))
 /8$
/*
 * Work around in residu.lisp, rev 1.9
 *
 * To make the answer shorter and easier to read, we need sqrtdenest,
 * so load it up.
 *
 */
(load(sqdnst), true);
true;
factor(expand(sqrtdenest(integrate (1/((x-3)^4+1/2), x,0,1))));
(2*atan((sqrt(2)-4*2^(1/4)+8)/(49*2^(3/4)+sqrt(2)-8))
 -log((2^(3/4)+12*sqrt(2)+73*2^(1/4)-2)/(33*2^(1/4)))
 +log((2^(3/4)-12*sqrt(2)+73*2^(1/4)+2)/(33*2^(1/4)))
 -2*atan((sqrt(2)+4*2^(1/4)+8)/(-49*2^(3/4)+sqrt(2)-8)))
 /(2*2^(3/4))$

/*
 * Bug [ 1607567 ] trigreduce([atan(sin(a)/cos(a))]) => [ atan(tan(a)) ] (FIX)
 */
trigreduce(atan(sin(a)/cos(a)));
a;
trigreduce([atan(sin(a)/cos(a))]);
[a];
trigreduce([sin(x)^2]);
[(1-cos(2*x))/2];

/*
 * Bug [ 1620977 ] limit(5^n/(2^n*3^n),n,inf) is wrong
 */
limit(5^n/(2^n*3^n),n,inf);
0;

/*
 * Bug [ 1370433 ] trigsimp(sqrt(%i2)) != sqrt(trigsimp(%i2))
 */
trigsimp(sqrt(2*(cos(x)^2-sin(x)^2)+2));
''(sqrt(trigsimp(2*(cos(x)^2-sin(x)^2)+2)));

/* Tests for COERCE-FLOAT-FUN via QUADPACK functions.
 * COERCE-FLOAT-FUN is also an important element in plotting.
 *
 * Following cases are tested here:
 *  EXPR is a symbol
 *    name of a Lisp function
 *    name of a Maxima function
 *    name of a Maxima macro
 *    a string which is the name of a Maxima operator (e.g., "!")
 *    name of a simplifying function
 *  EXPR is a Maxima lambda expression
 *  EXPR is a general Maxima expression with atomic variable
 *  EXPR is a general Maxima expression with subscripted variable
 *
 * The one case not tested: EXPR is the name of a DEFMSPEC function
 */

(kill(F1, F2, F3),
 F1(foo) := sin(foo),
 F2(bar) ::= sin(bar),
 F3 : lambda([baz], sin(baz)),
 postfix ("F4"),
 "F4"(zorg) := sin(zorg),
 0);
0;

(tol : 1e-8,
 expected : quad_qags (sin(quux), quux, 0, %pi, tol),
 [first (expected),
  is (second (expected) < tol * first (expected)),
  is (abs (first (expected) - 2.0) < tol * 2.0),
  last (expected)]);
[2.0, true, true, 0];

quad_qags (F1, blurf, 0, %pi, tol);
''(expected);

quad_qags (F2, mumble, 0, %pi, tol);
''(expected);

quad_qags (F3, gronk, 0, %pi, tol);
''(expected);

quad_qags ("F4", flopt, 0, %pi, tol);
''(expected);

quad_qags (sin, foobar, 0, %pi, tol);
''(expected);

(translate (F1), ?not(?null(?fboundp (F1))));
true;

quad_qags (F1, glump, 0, %pi, tol);
''(expected);

quad_qags (sin(y[1]), y[1], 0, %pi, tol);
''(expected);

/*
 * [ 1654183 ] integrate(x^2 / (1+x^6)^(3/2),x);
 */
integrate(x^2/(1+x^6)^(3/2),x);
x^3/(3*sqrt(x^6+1));

integrate(x^2/(1+x^6)^(3/2),x,-1,1);
sqrt(2)/3;

/*
 * A few more tests of CHEBYF that handles integrals of the form
 *
 * x^r1*(c1+c2*x^q)^r2
 */
/* (r1-q+1)/q a positive integer */
integrate(x^7/(1+x^4)^(3/2),x);
sqrt(x^4+1)/2+1/(2*sqrt(x^4+1));

/* r2 an integer */
integrate(sqrt(x)/(1+x^(3/2))^2,x);
-2/(3*(x^(3/2)+1));

/* (r1-q+1)/q a negative integer */
integrate(x^(-1)/(1+x^4)^(3/2),x);
-log(sqrt(x^4+1)+1)/4+log(sqrt(x^4+1)-1)/4+1/(2*sqrt(x^4+1));

/* (r1-q+1)/q + r2 an integer */
integrate(sqrt(x)*(1+x^2)^(1/4),x);
log((x^2+1)^(1/4)/sqrt(x)+1)/8-log((x^2+1)^(1/4)/sqrt(x)-1)/8
			      +atan((x^2+1)^(1/4)/sqrt(x))/4
			      +(x^2+1)^(1/4)/(sqrt(x)*(2*(x^2+1)/x^2-2))$

/*
 * Bug [ 1552789 ] integrate(1/(sin(x)^2+1),x,1,1+%pi)
 *
 * This bug said it was slow.  That's no longer true, but the result
 * was wrong.
 * 
 * This has been fixed for this particular case.
 */
integrate(1/(sin(x)^2+1),x,1,1+%pi);
%pi/sqrt(2);

/* A few more related tests.  I think these are right */
integrate(1/(sin(x)^2+1),x,1,1+4*%pi);
2*sqrt(2)*%pi;

/*
 * Bug [ 1690374 ] asin(1 / sqrt(2))
 *
 * We return %pi/4 now.
 */
asin(1/sqrt(2)),%piargs;
%pi/4;
asin(-1/sqrt(2)),%piargs;
-%pi/4;
acos(1/sqrt(2)),%piargs;
%pi/4;
acos(-1/sqrt(2)),%piargs;
3*%pi/4;

/* Bug [ 1045287 ] */
floatnump(float(exp(exp(2))));
true$

/*
 * Bug [ 1778796 ] integrate( (x^3+1)/(x^4 + 4*x + 1), 0, 1) 
 *
 * Not really a bug, but maxima takes way to long to compute the 
 * integral, and the result is extremely long.  The fix is it try 
 * the antiderivative first before trying the keyhole contour.
 */
integrate( (x^3+1)/(x^4 + 4*x + 1), x, 0, 1);
log(6)/4;
