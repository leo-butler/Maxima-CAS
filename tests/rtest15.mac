/* This file contains tests added since April 2002 */

kill(all);
done$

/* apropos function added 7 april 2002 */
apropos('tr_optimize_max_loop);
[tr_optimize_max_loop]$

/* test introduced 7 april 2002. bug fix incorporated 9 june 2002 */
integrate(3^log(x),x);
3^((1/log(3)+1)*log(x))/((1/log(3)+1)*log(3))$

/* wester[1995] problem 84 
   Bug 541030 fixed 2006-02-27, rev 1.14 of src/sin.lisp */
integrate(sqrt(x+1/x-2),x,0,1);
4/3$

/* bug reported by kevin ellwood.  fixed mar 11 2004 */
integrate(exp(-k*t)/sqrt(k*t),t);
sqrt(%pi)*erf(sqrt(k*t))/k$

/* a bug in chebyf.  fixed 20 apr 2004. */

kill(t,k);
done$
integrate(sqrt(k*t)*t,t);
2*t^2*sqrt(k*t)/5$
integrate(sqrt(k*t)*t^(1/3),t);
6*t^(4/3)*sqrt(k*t)/11$
integrate(sqrt(k*t)/t^(3/2),t);
sqrt(k*t)*log(t)/sqrt(t)$
integrate(sqrt(k*t)/sqrt(t),t);
sqrt(t)*sqrt(k*t)$
kill(t,k);
done$

/* lisp error observed by stavros macrakis (#956730).  fixed 2004-05-20. */

block([context:'foobar],
  assume(n+1<0),
  declare(n,integer),
  errcatch(integrate(x^n,x,0,inf)));
[]$

error;
[sconcat("Integral is divergent")]$

killcontext('foobar);
done$

/* second thru tenth code added 9 june 2002 */
l : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$
first(l);
1$ 
second(l);
2$
third(l);
3$
fourth(l);
4$
fifth(l);
5$
sixth(l);
6$
seventh(l);
7$
eighth(l);
8$
ninth(l);
9$
tenth(l);
10$

/* assoc tests */
assoc(1,[x=2]);
false$
assoc(x,[x=2]);
2$
assoc(1,[x=2],foobar);
foobar$

/* some older versions of gcl had a bug that resulted in a failure of the */
/* following. */
primep(80630964769);
true$


/* maxima has a bug causing an incorrect answer for the second integral. */
integrate(diff(f(x,y),x,1,y,1),x);
'diff(f(x,y),y,1)$
integrate(diff(f(x,y),x,1,y,1),y);
'diff(f(x,y),x,1)$
/* the same bug causes a bug with the second integral in this set. */
h(x,y):=x*y*diff(f(x,y),x,1,y,1);
h(x,y):=x*y*diff(f(x,y),x,1,y,1)$
integrate(h(x,y),x);
'integrate(x*'diff(f(x,y),x,1,y,1)*y,x)$
integrate(h(x,y),y);
'integrate(x*'diff(f(x,y),x,1,y,1)*y,y)$

/* trigrat example from manual - fixed june 2002 */
trigrat(sin(3*a)/sin(a+%pi/3));
sqrt(3)*sin(2*a)+cos(2*a)-1;

/* compile() will fail with gcl if gcc not installed */
f(x):=x+2;
f(x):=x+2;
f(2);
4;
compile(f);
[f];
f(2);
4;
/* some tests for lambda expressions.
  we test for both translate and compile because there are some compiler
  macros for translated code (defined via defopt) */
define_variable(qwerty,1,fixnum);
1;
/* m-tlambda */
f():=apply(lambda([u],u+qwerty),[1]);
f():=apply(lambda([u],u+qwerty),[1]);
f();
2;
translate(f);
[f];
f();
2;
compile(f);
[f];
f();
2;
/* m-tlambda&env */
f(x):=apply(lambda([u],u+x),[1]);
f(x):=apply(lambda([u],u+x),[1]);
f(1);
2;
translate(f);
[f];
f(1);
2;
compile(f);
[f];
f(1);
2;
/* m-tlambda&env */
f(x,qwerty):=apply(lambda([u],u+x+qwerty),[1]);
f(x,qwerty):=apply(lambda([u],u+x+qwerty),[1]);
f(1,0);
2;
translate(f);
[f];
f(1,0);
2;
compile(f);
[f];
f(1,0);
2;
/* m-tlambda&env (outer) and m-tlambda (inner) */
f(x):=apply(lambda([u],x+apply(lambda([v],v+qwerty),[u])),[-1]);
f(x):=apply(lambda([u],x+apply(lambda([v],v+qwerty),[u])),[-1]);
f(2);
2;
translate(f);
[f];
f(2);
2;
compile(f);
[f];
f(2);
2;
/* m-tlambda& */
f():=apply(lambda([u,[v]],[u+qwerty,v]),[0,2,3]);
f():=apply(lambda([u,[v]],[u+qwerty,v]),[0,2,3]);
f();
[1,[2,3]];
translate(f);
[f];
f();
[1,[2,3]];
compile(f);
[f];
f();
[1,[2,3]];
/* m-tlambda&env& */
f(x):=apply(lambda([u,[v]],[u+x,v]),[0,2,3]);
f(x):=apply(lambda([u,[v]],[u+x,v]),[0,2,3]);
f(1);
[1,[2,3]];
translate(f);
[f];
f(1);
[1,[2,3]];
compile(f);
[f];
f(1);
[1,[2,3]];
/* m-tlambda&env (from the sum), the inner lambda currently remains
  untranslated.  this is really a test for fungen&env-for-mevalsumarg. */
f(n):=sum(apply(lambda([x],i+x),[i]),i,1,n);
f(n):=sum(apply(lambda([x],i+x),[i]),i,1,n);
f(3);
12;
translate(f);
[f];
f(3);
12;
compile(f);
[f];
f(3);
12;
kill(qwerty,f);
done;
/* this should kill f, but doesn't which upsets subsequent tests
   redefining it then killing it does the right thing */
f(x):=x+3;
f(x):=x+3;
kill(f);
done;

/* trignometric and hyperbolic functions of complex arguments */
sin(%i*z);
%i*sinh(z);
cos(%i*z);
cosh(z);
tan(%i*z);
%i*tanh(z);
csc(%i*z);
-%i*csch(z);
sec(%i*z);
sech(z);
cot(%i*z);
-%i*coth(z);
sinh(%i*z);
%i*sin(z);
cosh(%i*z);
cos(z);
tanh(%i*z);
%i*tan(z);
csch(%i*z);
-%i*csc(z);
sech(%i*z);
sec(z);
coth(%i*z);
-%i*cot(z);

/* trigreduce(sinh(x)^n)) wrong for some cases.  fixed 4 oct 2003 */
trigreduce(sin(x)^2);
(1-cos(2*x))/2;
trigreduce(sin(x)^3);
(3*sin(x)-sin(3*x))/4;
trigreduce(sin(x)^4);
(cos(4*x)-4*cos(2*x)+3)/8;
trigreduce(sin(x)^5);
(sin(5*x)-5*sin(3*x)+10*sin(x))/16;
trigreduce(cos(x)^2);
(cos(2*x)+1)/2;
trigreduce(cos(x)^3);
(cos(3*x)+3*cos(x))/4;
trigreduce(cos(x)^4);
(cos(4*x)+4*cos(2*x)+3)/8;
trigreduce(cos(x)^5);
(cos(5*x)+5*cos(3*x)+10*cos(x))/16;
trigreduce(sinh(x)^2);
(cosh(2*x)-1)/2;
trigreduce(sinh(x)^3);
(sinh(3*x)-3*sinh(x))/4;
trigreduce(sinh(x)^4);
(cosh(4*x)-4*cosh(2*x)+3)/8;
trigreduce(sinh(x)^5);
(sinh(5*x)-5*sinh(3*x)+10*sinh(x))/16;
trigreduce(cosh(x)^2);
(cosh(2*x)+1)/2;
trigreduce(cosh(x)^3);
(cosh(3*x)+3*cosh(x))/4;
trigreduce(cosh(x)^4);
(cosh(4*x)+4*cosh(2*x)+3)/8;
trigreduce(cosh(x)^5);
(cosh(5*x)+5*cosh(3*x)+10*cosh(x))/16;

/* de moivre's theorem - abramowitz & stegun 4.3.48, 4.5.53 */
expand(trigreduce(expand((cos(x)+%i*sin(x))^2)));
%i*sin(2*x)+cos(2*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^3)));
%i*sin(3*x)+cos(3*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^4)));
%i*sin(4*x)+cos(4*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^5)));
%i*sin(5*x)+cos(5*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^6)));
%i*sin(6*x)+cos(6*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^7)));
%i*sin(7*x)+cos(7*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^8)));
%i*sin(8*x)+cos(8*x);
expand(trigreduce(expand((cos(x)+%i*sin(x))^9)));
%i*sin(9*x)+cos(9*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^2)));
sinh(2*x)+cosh(2*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^3)));
sinh(3*x)+cosh(3*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^4)));
sinh(4*x)+cosh(4*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^5)));
sinh(5*x)+cosh(5*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^6)));
sinh(6*x)+cosh(6*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^7)));
sinh(7*x)+cosh(7*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^8)));
sinh(8*x)+cosh(8*x);
expand(trigreduce(expand((cosh(x)+sinh(x))^9)));
sinh(9*x)+cosh(9*x);

/* bug 835287 */
solve('diff(y,x),'diff(y,x));
['diff(y,x,1)=0];

/* multiplicity bug in solve.lisp 1.3 - 13 may 2004 */
eigenvalues(matrix([3,1,0,0],[-4,-1,0,0],[7,1,2,1],[-17,-6,-1,0]));
[[1],[4]];

/* Bug 1369669 */
trigexpand(csc(3*x));
csc(x)^3*sec(x)^3/(3*csc(x)^2*sec(x)-sec(x)^3);

/* Bug 1369451 */
trigexpand(sec(x+y));
csc(x)*sec(x)*csc(y)*sec(y)/(csc(x)*csc(y)-sec(x)*sec(y));

/* Bug 1309377 */
fpred(x) := (prederror:'false, is(x <= -1));
fpred(x):=(prederror:'false,is(x <= -1))$
fpred(xyzzy);
unknown$
translate(fpred);
[fpred]$
fpred(xyzzy);
unknown$

/* Bug 1281737 */
limit(atan(x)/(1/exp(1)-exp(-(1+x)^2)),x,inf,'plus);
%e*%pi/2;

/* Bug 1363411 */
'sum(1+f(k),k,1,2),simpsum;
f(2) + f(1) + 2;

/* Bug 1403415, fixed in clmacs.lisp rev 1.20 */
float(0.0b0);
0.0;

/* Bug 1404754, fixed in float.lisp rev 1.23 */
1.0b0*x;
1.0b0*x;

/* Bug 1374704.  See also 1418010 because result isn't simplified. */
(assume(cos(x)>0),0);
0;
integrate(sin(x)/cos(x)^2,x,0,%pi/3);
1/cos(%pi/3)-1/cos(0);

/*
 * Test compiled array access
 */
use_fast_arrays:false;
false;

(ar:make_array('fixnum,3,2),0);
0;
(aref(array,row,col):=array[row,col],0);
0;
ar[2,1]:1;
1;
aref(ar,2,1);
1;
compile(aref);
[aref];
aref(ar,2,1);
1;
/* A old-style maxima hashed array */
har[2,1]:1;
1;
aref(har,2,1);
1;

use_fast_arrays:true;
true;
har2[3,4]:12;
12;
aref(har2,3,4);
12;

/*
 * This test from Fabrizio Caruso, maxima list, 2006/02/14 
 *
 * We're basically trying to test that the compiled version of foo
 * returns a fixnum array, just like the interpreted one.
 */
foo(x) := block([r], r : make_array('fixnum,2), r[0]:x,r[1]:x+1, return(r));
foo(x) := block([r], r : make_array('fixnum,2), r[0]:x,r[1]:x+1, return(r))$
foo(7);
foo(7)$
compile(foo);
[foo];
foo(7);
foo(7)$

use_fast_arrays:false;
false;

/* Bug 1405931: integrate(log(x)/(x^2+1)^2,x,0,inf)
 */
integrate(log(x)/(x^2+1)^2,x,0,inf);
-%pi/4;

/*
 * Bug 941457: integrate(1/x^5,x,1,2^(1/78))
 * Fixed 2006/03/13.  Solution needs work, though.
 */
multthru(factor(integrate(1/x^5,x,1,2^(1/78))));
1/4-2^(37/39)/8;

/*
 * Bug 938235: integrate((1/2)*u^2-1/u^5,u,1,sqrt(2))
 * Fixed 2006/03/13.  Solution needs work, though.
 */
integrate((1/2)*u^2-1/u^5,u,1,sqrt(2));
sqrt(2)/3-17/48;

/*
 * These next two cases are regression tests.  Rev 1.11 of sin.lisp
 * caused different (much messier) results to be returned.
 */
integrate(sin(2*x)/sec(x),x);
-2*cos(x)^3/3;

integrate(-a*sin(2*x)/(a*sin(x)^2+b),x);
-log(a*sin(x)^2+b);

/*
 * Bug 1471861: limit(abs(sin(x)/x),x,0);
 * Fixed 2006/05/05, limit.lisp, rev 1.20.
 */
limit(abs(sin(x)/x),x,0);
1;

/* 
 * Bug 1482843: subscripted variable causes trouble in integrate
 *
 * Fixed 
 */
integrate(exp(-(x-mu[1])^2),x,0,inf);
sqrt(%pi)*erf(mu[1])/2+sqrt(%pi)/2;