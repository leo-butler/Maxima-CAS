/*************** -*- Mode: MACSYMA; Package: MAXIMA -*-  ******************/
/***************************************************************************
***                                                                    *****
***     Copyright (c) 1984 by William Schelter,University of Texas     *****
***     All rights reserved                                            *****
***************************************************************************/


/* -*- Package: CL-MAXIMA; Mode: MACSYMA -*-*/
kill(allbut(props));
done;
DISPLAY(B[1,2]);
DONE$
EXP1:INTEGRATE(1/(X^3+2),X);  
-LOG(X^2-2^(1/3)*X+2^(2/3))/(6*2^(2/3))+ATAN((2*X-2^(1/3))/(2^(1/3)*SQRT(3)))
					/(2^(2/3)*SQRT(3))
				       +LOG(X+2^(1/3))/(3*2^(2/3));
/* tops 20 got exp1 below but exp2 is also ok.*/
/* lispm got
-2^(1/3)*LOG(2^(2/3)*X^2-2*X+2*2^(1/3))/12
 +2^(1/3)*ATAN((2*2^(2/3)*X-2)/(2*SQRT(3)))/(2*SQRT(3))
 +2^(1/3)*LOG(X+2^(1/3))/6$ */
EXP2:diff(EXP1,X);
1/(3*((2*X-2^(1/3))^2/(3*2^(2/3))+1))-(2*X-2^(1/3))
                               /(6*2^(2/3)*(X^2-2^(1/3)*X+2^(2/3)))
                              +1/(3*2^(2/3)*(X+2^(1/3)))$  
				
/* was 1/(3*((2*2^(2/3)*X-2)^2/12+1))-2^(1/3)*(2*2^(2/3)*X-2)
			       /(12*(2^(2/3)*X^2-2*X+2*2^(1/3)))
			      +2^(1/3)/(6*(X+2^(1/3)))$
				which is equal
*/				
radcan(EXP2);
1/(X^3+2)$
reveal(EXP1:-LOG(X^2-2^(1/3)*X+2^(2/3))/(6*2^(2/3))+ATAN((2*X-2^(1/3))/(2^(1/3)*SQRT(3)))
					/(2^(2/3)*SQRT(3))
				       +LOG(X+2^(1/3))/(3*2^(2/3)),2);
"Negterm"+"Quotient"+"Quotient"$
/* REVEAL(EXP1,3); Answers ok but the check program doesn't like "product"(2)
-"Quotient"+ATAN/"Product"(2)+LOG/"Product"(2))$ */
G(L):=CATCH(MAP(LAMBDA([X],IF X < 0 THEN THROW(X) ELSE F(X)),L));
G(L):=CATCH(MAP(LAMBDA([X],IF X < 0 THEN THROW(X) ELSE F(X)),L))$
G([1,2,3,7]);
[F(1),F(2),F(3),F(7)]$
G([1,2,-3,7]);
-3$
EXP1:Y^2+B*X;
Y^2+B*X$
ORDERLESS(Y);
DONE$
Y^2+B*X;
B*X+Y^2$
%-EXP1;
Y^2-Y^2$
UNORDER();
[Y]$
EXP:A^2+B*X;
B*X+A^2$
ORDERGREAT(A);
DONE$
A^2+B*X;
A^2+B*X$
%-EXP;
A^2-A^2$
UNORDER();
[A]$
EXP:A^2+B*X;
B*X+A^2$
ORDERGREAT(A);
DONE$
A^2+B*X;
A^2+B*X$
%-EXP;
A^2-A^2$
UNORDER();
[A]$
DECLARE(F,LINEAR);
DONE$
F(2*A+3*B);
3*F(B)+2*F(A)$
F(2*X+Y,X);
F(1,X)*Y+2*F(X,X)$
DECLARE(F,ADDITIVE);
DONE$
F(2*A+3*B);
3*F(B)+2*F(A)$
DECLARE(F,OUTATIVE);
DONE$
F(2*A);
2*F(A)$
DECLARE(F,MULTIPLICATIVE);
DONE$
F(2*A*B);
2*F(A)*F(B)$
(KILL(FUNCTIONS),DECLARE(G,LASSOCIATIVE));
DONE$
G(G(A,B),G(C,D));
G(G(G(A,B),C),D)$
G(G(A,B),G(C,D))-G(A,G(B,G(C,D)));
0$
DECLARE(G,RASSOCIATIVE);
DONE$
G(G(A,B),G(C,D));
G(G(G(A,B),C),D)$
G(G(A,B),G(C,D))-G(A,G(B,G(C,D)));
0$
(KILL(H),DECLARE(H,COMMUTATIVE));
DONE$
H(X,Z,Y);
H(X,Y,Z)$
(KILL(H),DECLARE(H,SYMMETRIC));
DONE$
H(X,Z,Y);
H(X,Y,Z)$
(KILL(H),DECLARE(H,ANTISYMMETRIC));
DONE$
H(X,Z,Y);
-H(X,Y,Z)$
(KILL(ALLBUT(PROPS)),DECLARE(J,NARY));
DONE$
J(J(A,B),J(C,D));
J(A,B,C,D)$
DECLARE(F,ODDFUN);
DONE$
F(-X);
-F(X)$
DECLARE(G,EVENFUN);
DONE$
G(-X);
G(X)$
(KILL(ALLBUT(PROPS)),KILL(G),DECLARE(F,POSFUN));
DONE$
IS(F(X) > 0);
TRUE$
(KILL(ALLBUT(PROPS)),B[1,X]:1);
1$
ARRAY(F,2,3);
F$
ARRAYINFO(B);
[HASH_TABLE, TRUE, [1, X]]$
/* tops 20:  this is incompatible difference [HASHED,2,[1,X]]$ */
ARRAYINFO(F);
[DECLARED,2,[2,3]]$
block([use_fast_arrays:false],kill(bb),bb[1,x]:7,arrayinfo(bb));
[HASHED, 2, [1, x]];
block([use_fast_arrays:TRUE],kill(bb),bb[1,x]:7,arrayinfo(bb));
[HASH_TABLE, TRUE, [1, x]]$
PROPERTIES(?CONS);
["System Function"]$
ASSUME(VAR1 > 0);
[VAR1 > 0]$
PROPERTIES(VAR1);
["Database Info",VAR1 > 0]$
VAR2:2;
2$
PROPERTIES(VAR2);
[VALUE]$
GRADEF(R,X,X/R);
R$
GRADEF(R,Y,Y/R);
R$
PRINTPROPS(R,ATOMGRAD);
DONE$
PROPVARS(ATOMGRAD);
[R]$
GRADEF(R,X,X/R);
R$
GRADEF(R,Y,Y/R);
R$
PRINTPROPS(R,ATOMGRAD);
DONE$
PROPVARS(ATOMGRAD);
[R]$
PUT(%E,TRANSCENDENTAL,TYPE);
TRANSCENDENTAL$
PUT(%PI,TRANSCENDENTAL,TYPE);
TRANSCENDENTAL$
block([algebraic:false],PUT(%I,ALGEBRAIC,TYPE));
FALSE$
TYPEOF(X):=BLOCK([Q],IF NUMBERP(X) THEN RETURN(ALGEBRAIC),
       IF NOT ATOM(X) THEN RETURN(MAPLIST(TYPEOF,X)),Q:GET(X,TYPE),
       IF Q = FALSE THEN ERROR("NOT NUMERIC") ELSE Q);
TYPEOF(X):=BLOCK([Q],IF NUMBERP(X) THEN RETURN(ALGEBRAIC),
       IF NOT ATOM(X) THEN RETURN(MAPLIST(TYPEOF,X)),Q:GET(X,TYPE),
       IF Q = FALSE THEN ERROR("NOT NUMERIC") ELSE Q)$
block([algebraic:false],ERRCATCH(TYPEOF(2*%E+X*%PI)));
[]$
block([algebraic:false],TYPEOF(2*%E+%PI));
[TRANSCENDENTAL,[FALSE,TRANSCENDENTAL]]$
IS(X^2 >= 2*X-1);
TRUE$
ASSUME(A > 1);
[A > 1]$
IS(LOG(LOG(A+1)+1) > 0 AND A^2+1 > 2*A);
TRUE$
FREEOF(Y,SIN(X+2*Y));
FALSE$
FREEOF(COS(Y),"*",SIN(Y)+COS(X));
TRUE$
LFREEOF([X],Y);
TRUE$
LFREEOF([X],Y+Z);
TRUE$
LFREEOF([X,Y],Y+Z);
FALSE$
