<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from orthopoly_doc.texi on 30 August 2003 -->

<TITLE>Untitled Document</TITLE>

</HEAD>
<BODY>
<H1>Untitled Document</H1>
<P>
<P><HR><P>



<H1><A NAME="SEC1" HREF="orthopoly_doc_toc.html#TOC1">Orthogonal Polynomials</A></H1>



<H2><A NAME="SEC2" HREF="orthopoly_doc_toc.html#TOC2">Introduction to Orthogonal Polynomials</A></H2>

<P>
Maxima includes support for symbolic and numerical evaluation of
most of the orthogonal polynomials listed in Chapter 
22 of Abramowitz and Stegun; these functions include the Chebyshev, 
Laguerre, Hermite, Jacobi, Legendre, and  ultraspherical (Gegenbauer) 
polynomials.  Additionally, Maxima includes support for the spherical Bessel, 
spherical Hankel, and spherical harmonic functions.

</P>
<P>
For the most part, orthopoly follows the conventions of Abramowitz and Stegun 
(A &#38; S) <EM>Handbook of Mathematical Functions</EM> (10th printing, December 1972);
additionally, we use Gradshteyn and Ryzhik (G &#38; R), 
<EM>Table of Integrals, Series, and Products</EM> (1980 corrected and 
enlarged edition), and Eugen Merzbacher <EM>Quantum Mechanics</EM> (2 ed, 1970).  

</P>


<H4><A NAME="SEC3" HREF="orthopoly_doc_toc.html#TOC3">Installation</A></H4>

<P>
Download the archive orthopoly_x.tar.gz, where x is the release identifier,
from http://www.unk.edu/acad/math/people/willisb.  Under Linux, unpack it using

</P>
<P>
   gzip -d orthopoly_x.tar.gz

</P>
<P>
   tar -xvf orthopoly_x.tar 

</P>
<P>
This will create a directory <EM>orthopoly_x</EM> (again x is the release 
identifier) that contains the source file <EM>orthopoly.lisp</EM>, user 
documentation in html and texi formats, a sample maxima initialization file 
<EM>orthopoly-init.lisp</EM>, a README file, a testing routine 
<EM>test_orthopoly.mac</EM>, and two demonstration files.

</P>
<P>
Start Maxima and compile orthopoly. To do this, use the command

</P>
<P>
(c1) compile_file("orthopoly.lisp");

</P>
<P>
If Maxima is unable to find orthopoly, use the full pathname.
Compiling  will create a file orthopoly.x, where the file extension "x" 
depends on which 
version of Lisp your Maxima uses; under GCL, the extension is "o",
and under cmucl, most likely it is "x86f".

</P>
<P>
Copy the source file "orthopoly.lisp" and its compiled version to 
a directory that Maxima can find.  Since version 0.93 is a 
preliminary version, you may want to keep orthopoly in the 
orthopoly_0.93 directory and add this directory to file_search_lisp. 
The file <EM>orthopoly_init.lisp</EM> shows how to append a directory
to file_search_lisp. For a permanent  installation, copy the files to 
Maxima's /share/specfunctions/ directory.

</P>
<P>
Add the contents of "orthopoly-init.lisp" to your maxima-init.lisp file.
Some code in orthopoly-init.lisp is marked as optional; you needn't add
it to your maxima-init.lisp file. The orthopoly-init.lisp 
file contains autoload statements for user-level functions in orthopoly 
and it contains  fixes for bugs in  the functions $setup_autoload and 
generic-autoload.  Additionally, "orthopoly-init.lisp" contains an
extended version of the function <EM>makegamma</EM>.

</P>
<P>
To test orthopoly, load("test-orthopoly.mac"). You may need to give
the full pathname for the file. Report errors. 

</P>
</OL>



<H4><A NAME="SEC4" HREF="orthopoly_doc_toc.html#TOC4">Getting Started with Orthopoly</A></H4>

<P>
Assuming you've placed appropriate autoload statements in your 
<EM>maxima-init.lisp</EM> file, you needn't manually load <B>orthopoly</B>
to start using it; otherwise, load it with the command

<PRE>
(C1) load("orthopoly")$
</PRE>

<P>
If Maxima isn't able to find the file, use a full pathname. Without
autoloading user-level orthopoly functions,  you'll need to be careful to 
load orthopoly <EM>before</EM> using any user-level functions from orthopoly; 
otherwise, you'll need to use upper-case function names. 

</P>
<P>
To find the third order Legendre polynomial, use the command

<PRE>
(C2) legendre_p(3,x);
			     3		   2
		    5 (1 - x)	 15 (1 - x)
(D2) 		  - ---------- + ----------- - 6 (1 - x) + 1
			2	      2
</PRE>

<P>
To express this as a sum of powers of x, apply ratsimp or rat
or to the result

<PRE>
(C3) [ratsimp(%),rat(%)];
			       3	   3
			    5 x  - 3 x  5 x  - 3 x
(D3)/R/ 		   [----------, ----------]
				2	    2
</PRE>

<P>
Alternatively, make the second argument to legendre_p (its "main" variable) 
a CRE expression

<PRE>
(C4) legendre_p(3,rat(x));
				     3
				  5 x  - 3 x
(D4)/R/ 			  ----------
				      2 
</PRE>

<P>
For floating point evaluation, orthopoly uses a running error analysis
to <EM>estimate</EM> an upper bound for the error. An example

<PRE>
(C1) jacobi_p(150,2,3,0.2);
(D1) 	      interval(- .0620170379367145, 2.04311850697459e-11)
</PRE>

<P>
Intervals have the form interval(c, r), where c is the
center and r is the radius of the interval.  Since Maxima
does not support arithmetic on intervals, in some situations, such
as graphics, you want to supress the error and output only the 
center of the interval.  To do this, set the option
variable <EM>orthopoly_returns_intervals</EM> to false

<PRE>
(C2) orthopoly_returns_intervals : false;
(D2) 				     FALSE
(C3) jacobi_p(150,2,3,0.2);
(D3) 			      - .0620170379367145
</PRE>

<P>
Refer to the section <EM> Floating point Evaluation</EM> for more information.

</P>
<P>
Most functions in orthopoly have a <EM>gradef</EM> property; thus

<PRE>
(C1) diff(hermite(n,x),x);

(D1) 				 2 n H	   (x)
				      n - 1
(C2) diff(gen_laguerre(n,a,x),x);

		     (a)	       (a)
		  n L   (x) - (n + a) L	    (x) UNIT_STEP(n)
		     n		       n - 1
(D2) 		  ------------------------------------------
				      x
</PRE>

<P>
The unit step function in the second example prevents an error that would
otherwise arise by evaluating with n = 0.

<PRE>
(C3) ev(%,n=0);

(D3) 				       0
</PRE>

<P>
The gradef property only applies to the "main" variable; derivatives with 
respect other arguments usually result in an error message; for example

<PRE>
(C1) diff(hermite(n,x),x);

(D1) 				 2 n H	   (x)
				      n - 1
(C2) diff(hermite(n,x),n);
Maxima doesn't know the derivative of hermite with respect the first argument
 -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)
</PRE>

<P>
Generally, functions in orthopoly map over lists and matrices.  For
the mapping to fully evaluate,  the option variables 
<EM>doallmxops</EM> and <EM>listarith</EM> both must assume their default 
values (true).  To illustrate the mapping over matrices, consider

<PRE>
(C1) hermite(2,x);

					    2
(D1) 			        - 2 (1 - 2 x )
(C2) m : matrix([0,x],[y,0]);

				   [ 0  x ]
(D2) 				   [ 	  ]
				   [ y  0 ]
(C3) hermite(2,m);

		      [				    2  ]
		      [	     - 2        - 2 (1 - 2 x ) ]
(D3) 		      [ 			       ]
		      [		    2		       ]
		      [ - 2 (1 - 2 y )	     - 2       ]
</PRE>

<P>
In the second example, understand that <EM>i,j</EM> element of the value
is <EM>hermite(2,m[i,j])</EM>; this is not the same as computing
<EM>-2 + 4 m . m</EM>

<PRE>
(C4) -2 * matrix([1,0],[0,1]) + 4 * m.m;

			   [ 4 x y - 2	    0	  ]
(D4) 			   [ 			  ]
			   [	 0      4 x y - 2 ]
</PRE>

<P>
If you evaluate a function at a point outside its domain, generally
orthopoly will return the function unevaluated; an example

<PRE>
(C1) legendre_p(2/3,x);

(D1) 				    P   (x)
				     2/3
</PRE>

<P>
Orthopoly supports translation into TeX; it also does two-dimensional
output on a terminal

<PRE>
(C1) spherical_harmonic(l,m,theta,phi);

				 m
(D1) 			        Y (THETA, PHI)
				 l
(C2) tex(%);
$$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
(D2) 				     FALSE

(C3) jacobi_p(n,a,a-b,x/2);

				 (a, a - b) x
(D3) 			        P	   (-)
				 n	    2
(C4) tex(%);
$$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
(D4) 				     FALSE
</PRE>



<H4><A NAME="SEC5" HREF="orthopoly_doc_toc.html#TOC5">Caveats</A></H4>

<P>
When an expression involves several orthogonal polynomials with
<EM>symbolic</EM> orders, it's possible that the expression actually
vanishes, yet Maxima is unable to simplify it to zero.  If you
divide by such a quantity, you'll be in trouble.  For example,
the following expression vanishes for integers <EM>n&#62;1</EM>, yet Maxima
is unable to simplify it to zero.

<PRE>
(D5) 		     (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
				n - 1	        n	        n - 2
</PRE>

<P>
For a specific <EM>n</EM>, we can reduce the expression to zero

<PRE>
(C6) ev(%,n=10,ratsimp);
(D6) 					      0
</PRE>

<P>
<EM>Be careful.</EM>  

</P>
<P>
Generally, the polynomial form of an orthogonal polynomial is ill-suited
for floating point evaluation.  Here's an example

<PRE>
(C1) p : jacobi_p(150,2,3,x)$
(C2) subst(0.2,x,p);
(D2) 			    - 9.470489909945016e+60
</PRE>

<P>
The true value is about -0.06; this calculation suffers from extreme
subtractive cancellation error.  Expanding the polynomial and then
evaluating, gives a better result

<PRE>
(C3) p : expand(p)$
(C4) subst(0.2,x,p);
(D4) 			    - 0.062128442689779795
</PRE>

<P>
This isn't a general rule; expanding the polynomial does not always
result in an expression that is better suited for numerical evaluation.
By far, the best way to do numerical evaluation is to make one or more
of the function arguments floating point numbers. By doing that, 
specialized floating point algorithms are used for evaluation.

</P>
<P>
Maxima's float function is somewhat indiscriminant; if you apply 
float to an an expression involving an orthogonal polynomial with a
symbolic degree or order parameter, these parameters may be 
converted into floats; after that, the expression will not evaluate 
fully. Consider

<PRE>
(C1) assoc_legendre_p(n,1,x);
				      1
(D1) 				     P (x)
				      n
(C2) float(%);
				     1.0
(D2) 				    P   (x)
				     n
(C3) ev(%,n=2,x=0.9);
				    1.0
(D3) 				   P   (0.9)
				    2
(C4) 
</PRE>

<P>
The expression in (D3) will not evaluate to a float; orthopoly doesn't
recognize floating point values where it requires an integer. Similarly, 
numerical evaluation of the pochhammer function for orders that
exceed pochhammer_max_index can be troublesome; consider

<PRE>
(C1) x :  pochhammer(1,10), pochhammer_max_index : 5;

(D1) 				     (1)
					10
</PRE>

<P>
Applying float doesn't evaluate x to a float

<PRE>
(C2) float(x);

(D2) 				   (1.0)
					10.0
</PRE>

<P>
To evaluate x to a float. you'll need to bind  
pochhammer_max_index to 11 or greater and apply float to x

<PRE>
(C3)  float(x), pochhammer_max_index : 11;

(D3) 				   3628800.0
(C4) 
</PRE>

<P>
The default value of pochhammer_max_index is 100; to change
its value, first load orthopoly.

</P>
<P>
Finally, be aware that reference books vary on the definitions of the 
orthogonal polynomials; we've generally used the conventions 
of  conventions of Abramowitz and Stegun  (A &#38; S) 
<EM>Handbook of Mathematical Functions</EM> (10th printing, December 1972).

</P>
<P>
Before you suspect a bug in orthopoly, check some special cases 
to determine if your definitions match those used by orthonormal. 
Definitions often differ by a normalization; occasionally, authors
use "shifted" versions of the functions that makes the family
orthogonal on an interval other than <EM>(-1,1)</EM>. To define, for example,
a legendre polynomial that is orthogonal on <EM>(0,1)</EM>, define

<PRE>
(C1) shifted_legendre_p(n,x) := legendre_p(n,2*x-1)$

(C2) shifted_legendre_p(2,rat(x));

				   2
(D2)/R/ 		        6 x  - 6 x + 1
(C3) legendre_p(2,rat(x));

				      2
				   3 x  - 1
(D3)/R/ 			   --------
				      2
</PRE>



<H4><A NAME="SEC6" HREF="orthopoly_doc_toc.html#TOC6">Floating point Evaluation</A></H4>

<P>
Most functions in orthopoly use a running error analysis to 
<EM>estimate</EM> the error in floating point evaluation; the 
exceptions are the spherical Bessel functions and the associated Legendre 
polynomials of the second kind. For numerical evaluation, the spherical 
Bessel functions call slatec functions. No specialized method is used
for numerical evaluation of the associated Legendre polynomials of the
second kind.

</P>
<P>
The running error analysis ignores errors that are second or higher order
in the machine epsilon (also known as unit roundoff). It also
ignores a few other errors. <EM>It's possible (although unlikely) 
that the  actual error exceeds the estimate.</EM>

</P>
<P>
Intervals have the form <EM>interval(c,r)</EM>, where <EM>c</EM> is the 
<EM>center</EM> of the interval and <EM>r</EM> is its <EM>radius</EM>. The 
center of an interval can be a complex number, but it's a bug if the
radius isn't a positive real number.  

</P>
<P>
Here is an an example

<PRE>
(C1)  fpprec : 50$
(C2) y0 : jacobi_p(150,2,3,0.2);
(D2) 	    interval(- 0.06201703793671447, 1.0217141721600247e-11)
(C3) y1 : bfloat(jacobi_p(150,2,3,1/5));
(D3) 	    - 6.201703793671628761993584658478664938137943464587B-2
</PRE>

<P>
Let's test that the actual error is smaller than the error estimate

<PRE>
(C4) is(abs(part(y0,1) - y1) &#60; part(y0,2));
(D4) 				     TRUE
</PRE>

<P>
Indeed, for this example the error estimate is an upper bound for the
true error.

</P>
<P>
Maxima does not support arithmetic on intervals

<PRE>
(C1) legendre_p(7,0.1) + legendre_p(8,0.1);
(D1) interval(0.18032072148437508, 2.1508371989568562e-15)
    + interval(- 0.19949294375000004, 2.301870533171531e-15)
</PRE>

<P>
A user could define arithmetic operators that do interval math. To
define interval addition, we can define

<PRE>
(C9)  infix("@+")$
(C10) "@+"(x,y) := interval(part(x,1) + part(y,1),part(x,2) + part(y,2))$
(C11)  legendre_p(7,0.1) @+ legendre_p(8,0.1);
(D11) 	    INTERVAL(- 0.019172222265624955, 4.452707732128387e-15)
</PRE>

<P>
The special floating point routines get called when the arguments
are complex.  For example

<PRE>
(C1)  legendre_p(10,2 + 3.0*%i);
(D1) interval(- 3.8763788250000003e+7 %I - 6.0787748e+7, 8.322322816893654e-7)
</PRE>

<P>
Let's compare this to the true value

<PRE>
(C2) float(expand(legendre_p(10,2+3*%i)));
(D2) 		   - 3.8763788250000003e+7 %I - 6.0787748e+7
</PRE>

<P>
Additionally, when the arguments are big floats, the special floating point
routines get called; however, the big floats are converted into double floats
and the final result is a double

<PRE>
(C3) ultraspherical(150,0.5b0,0.9b0);
(D3) 	  interval(- 0.0430094812572654, 2.2727803799647722e-14)
</PRE>



<H4><A NAME="SEC7" HREF="orthopoly_doc_toc.html#TOC7">Graphics and Orthopoly</A></H4>

<P>
To plot expressions that involve the orthogonal polynomials, you 
must do two things:

<OL>
<LI>

set the option variable <EM>orthopoly_returns_intervals</EM> to false,
<LI>

fully quote any calls to orthopoly functions.
</OL>

<P>
If function calls aren't quoted, Maxima evaluates them to polynomials before 
plotting; consequently, the specialized floating point code doesn't get called.
Here is an example of how to plot an expression that involves
a legendre polynomial.

<PRE>
(C1) plot2d('(legendre_p(5,x)),[x,0,1]), orthopoly_returns_intervals : false;
</PRE>

<P>
The <EM>entire</EM> expression legendre_p(5,x) is quoted; this is 
different than just quoting the function name using 'legendre_p(5,x).

</P>


<H4><A NAME="SEC8" HREF="orthopoly_doc_toc.html#TOC8">Miscellaneous Functions</A></H4>

<P>
The orthopoly package defines the Kronecker delta function, the
pochhammer symbol, and a unit step function. Orthopoly uses 
the Kronecker delta function and the unit step function in
gradef statements.

</P>
<P>
To convert pochhammer symbols into quotients of gamma functions,
use makegamma

<PRE>
(C1) makegamma(pochhammer(x,n));

				 GAMMA(x + n)
(D1) 				 ------------
				   GAMMA(x)
(C2) makegamma(pochhammer(1/2,1/2));

				       1
(D2) 				   ---------
				   SQRT(%PI)
</PRE>

<P>
Derivatives of the pochhammer symbol are given in terms of the psi
function

<PRE>
(C3) diff(pochhammer(x,n),x);

(D3) 			 (x)  (PSI (x + n) - PSI (x))
			    n	  0	        0
(C4) diff(pochhammer(x,n),n);

(D4) 			       (x)  PSI (x + n)
				  n    0
</PRE>

<P>
You need to be careful with the expression in (D3); the difference of the
psi functions has poles when x = -1,-2,..,-n. These poles
cancel with factors in (x)_n making the derivative a degree
n-1 polynomial when n is a positive integer.

</P>
<P>
The pochhammer symbol is defined for negative orders through its
representation as a quotient of gamma functions. Consider

<PRE>
(C1) q : makegamma(pochhammer(x,n));

				 GAMMA(x + n)
(D1) 				 ------------
				   GAMMA(x)
(C2) sublis([x=11/3,n=-6],q);

				      729
(D2) 				    - ----
				      2240
</PRE>

<P>
Alternatively, we can get this result directly

<PRE>
(C3) pochhammer(11/3,-6);

				      729
(D3) 				    - ----
				      2240
(C4) 
</PRE>

<P>
The unit step function is <EM>left-continuous</EM>; thus

<PRE>
(C1) [unit_step(-1/10),unit_step(0),unit_step(1/10)];
(D1)                              [0, 0, 1]
</PRE>

<P>
If you need a unit step function that is neither left or right continuous
at zero, define your own using signum; for example,

<PRE>
(C2) xunit_step(x) := (1 + signum(x))/2$

(C3) [xunit_step(-1/10),xunit_step(0),xunit_step(1/10)];

				       1
(D3) 				   [0, -, 1]
				       2
</PRE>

<P>
Do not re-define Maxima's unit step function; some code in orthopoly
requires that the unit step function is left-continuous.

</P>


<H4><A NAME="SEC9" HREF="orthopoly_doc_toc.html#TOC9">Algorithms</A></H4>

<P>
Generally, orthopoly does symbolic evaluation by using a hypergeometic 
representation of the various orthogonal polynomials. The hypergeometic 
functions are evaluated using the  (undocumented)  functions hypergeo11 
and hypergeo21.  The exceptions are the half-integer Bessel functions 
and the associated Legendre function of the second kind.  The Bessel functions are
evaluated using an explicit representation, while the associated Legendre 
function of the second kind is evaluated using recursion.

</P>
<P>
For floating point evaluation, we again convert most functions into
a hypergeometic form;  we evaluate the hypergeometic functions using 
forward recursion. Again, the exceptions are the  half-integer Bessel functions 
and the associated Legendre function of the second kind.   Numerically, 
the half-integer Bessel functions are evaluated using the slatec code, and the 
associated Legendre functions of the second kind is numerically evaluated using 
the same algorithm as its symbolic evaluation uses.

</P>


<H4><A NAME="SEC10" HREF="orthopoly_doc_toc.html#TOC10">Author, License, and History</A></H4>

<P>
Barton Willis of the University of Nebraska at Kearney (aka UNK) wrote
and maintains the orthopoly package and its documentation. The package 
is released under the GNU General Public License (GPL).

</P>
<P>
The first two releases, specfun version 110 and specfun version 111,
were released in April 2001 and May 2002.  These versions were included
in Maxima versions starting with 5.5.  An preliminary third release, 
renamed  orthopoly, was announced in May 2003.  The third version
adds TeX and display support, improved  numerical floating point 
accuracy, and new user documentation.

</P>


<H2><A NAME="SEC11" HREF="orthopoly_doc_toc.html#TOC11">Definitions for Orthogonal Polynomials</A></H2>

<P>
<DL>
<DT><U>Function:</U> <B>assoc_legendre_p</B> <I>(n, m, x)</I>
<DD><A NAME="IDX1"></A>
The associated Legendre function of the first kind. 
Reference: A &#38; S  equation 22.5.37, page  779,  A &#38; S equation 8.6.6  
(second equation), page 334, and A &#38; S equation 8.2.5, page 333.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>assoc_legendre_q</B> <I>(n, m, x)</I>
<DD><A NAME="IDX2"></A>
The associated Legendre function of the second kind. Reference:
A &#38; S 8.5.3 and 8.1.8.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>chebyshev_t</B> <I>(n, x)</I>
<DD><A NAME="IDX3"></A>
The Chebyshev function of the first kind.  Reference: A &#38; S 22.5.47, page 779.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>chebyshev_u</B> <I>(n, x)</I>
<DD><A NAME="IDX4"></A>
The Chebyshev function of the second kind. Reference: A &#38; S, 22.5.48, page 779.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>gen_laguerre</B> <I>(n, a, x)</I>
<DD><A NAME="IDX5"></A>
The generalized Laguerre polynomial. Reference:  A &#38; S 22.5.54, page 780.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>hermite</B> <I>(n,x)</I>
<DD><A NAME="IDX6"></A>
The Hermite polynomial. Reference:  See A&#38;S 22.5.55, page 780.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>intervalp(e)</B>
<DD><A NAME="IDX7"></A>
Return true if the input is an interval and return false if it isn't. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>jacobi_p</B> <I>(n, a, b, x)</I>
<DD><A NAME="IDX8"></A>
The Jacobi polynomial. Reference: A &#38; S. 22.5.42, page 779.

</P>
<P>
The Jacobi polynomials are actually defined for all
<EM> a </EM> and <EM> b </EM>; however, the Jacobi polynomial
weight <EM> (1-x)^a(1+x)^b</EM> isn't integrable for <EM> a &#60;= -1</EM> or  
<EM> b &#60;= -1</EM>. ) 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>kron_delta</B> <I>(i, j)</I>
<DD><A NAME="IDX9"></A>
The Kronecker delta function; <EM>kron_delta(i,j)</EM> evaluates to
1 if and only if <EM>?csign(i-j)</EM> evaluates to <EM>zero</EM>; 
it evaluates to 0 if and only if <EM>?csign(i-j)</EM> does not 
evaluate to <EM>pnz</EM> (positive, negative, or zero).  Additionally,
<EM>kron_delta</EM> is declared to be symmetric; thus, for example,
<EM>kron_delta(i,j) - kron_delta(j,i)</EM> evaluates to zero.
</DL>
 
<DL>
<DT><U>Function:</U> <B>laguerre</B> <I>(n, x)</I>
<DD><A NAME="IDX10"></A>
The Laguerre polynomial. Reference: A &#38; S 22.5.16 and 22.5.54, page 780.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>legendre_p</B> <I>(n, x)</I>
<DD><A NAME="IDX11"></A>
The Legendre polynomial of the first kind. Reference A &#38; S 22.5.50 and
22.5.51, page 779.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>legendre_q</B> <I>(n, x)</I>
<DD><A NAME="IDX12"></A>
The Legendre polynomial of the first kind. Reference A &#38; S 8.5.3 and 8.1.8.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>orthopoly_recur</B> <I>(fn, args)</I>
<DD><A NAME="IDX13"></A>
Returns a recursion relation for the orthogonal function family
fn with arguments args.  The recursion is with 
respect to the polynomial degree.

<PRE>
(C1) orthopoly_recur(legendre_p, [n,x]);

		       (2 n - 1) P     (x) x + (1 - n) P     (x)
				  n - 1		        n - 2
(D1) 	       P (x) = -----------------------------------------
		n			   n
</PRE>

<P>
The second argument to orthopoly_recur must be a list with the 
correct number of arguments for the function fn; if it isn't, 
Maxima signals an error

<PRE>
(C2) orthopoly_recur(jacobi_p,[n,x]);

Function JACOBI_P needs 4 arguments, instead it received 2
 -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)

</PRE>

<P>
Additionally, when fn isn't the name of one of the 
families of orthogonal polynomials, an error is signalled

<PRE>
(C3) orthopoly_recur(unk,[n,x]);

A recursion relation for unk isn't known to Maxima
 -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)
(C4) 
</PRE>

</DL>

<P>
<DL>
<DT><U>Variable:</U> <B>orthopoly_returns_intervals</B>
<DD><A NAME="IDX14"></A>
When this option variable is true, floating point results are returned in
the form <EM>interval(c,r)</EM>, where <EM>c</EM> is the center of an interval
and <EM>r</EM> is its radius.  The center can be a complex number; in this
case, the interval is a disk in the complex plane. The default value
for <EM>orthopoly_returns_intervals</EM> is true.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>orthopoly_weight</B> <I>(fn args)</I>
<DD><A NAME="IDX15"></A>

</P>
<P>
This function returns a three element list; the first element is 
the formula of the weight for the orthogonal polynomial family
fn with arguments given by the list args; the 
second and third elements give the lower and upper endpoints
of the interval of orthogonality.  For example

<PRE>
(C1) w : orthopoly_weight(hermite,[n,x]);

				   2
				- x
(D1) 			     [%E    , - INF, INF]
(C2) integrate(w[1] * hermite(3,x) * hermite(2,x),x,w[2],w[3]);

(D2) 				       0
</PRE>

<P>
The main variable of fn must be a symbol; if it isn't, Maxima
signals an error. 

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>pochhammer</B> <I>(n,x)</I>
<DD><A NAME="IDX16"></A>
The pochhammer symbol. For nonnegative integers n with
n&#60;=pochhammer_max_index, the expression pochhammer(x,n) 
evaluates to the product x(x+1)(x+2)...(x+n-1) when n &#62; 0 and
to 1 when n = 0. For  negative n, we use 
pochhammer(x,n) = (-1)^n / pochhammer(1-x,-n).
Thus

<PRE>
(C1) pochhammer(x,3);

(D1) 			       x (x + 1) (x + 2)
(C2) pochhammer(x,-3);

					1
(D2) 			   - -----------------------
			     (1 - x) (2 - x) (3 - x)
</PRE>

<P>
To convert a pochhammer symbol into a quotient of gamma functions,
(see A &#38; S 6.1.22) use makegamma; for example 

<PRE>
(C3) makegamma(pochhammer(x,n));

				 GAMMA(x + n)
(D2) 				 ------------
				   GAMMA(x)
</PRE>

<P>
When n exceeds <EM>pochhammer_max_index</EM> (default 100) or when n 
is symbolic, the pochhammer function evaluates to itself

<PRE>
(C4) pochhammer(x,n);

(D4) 				     (x)
					n
</PRE>

</DL>

<P>
<DL>
<DT><U>Variable:</U> <B>pochhammer_max_index</B>
<DD><A NAME="IDX17"></A>
pochhammer(n,x) expands to a product if and only if
n &#60;= pochhammer_max_index. For example

<PRE>
(C1) pochhammer(x,3), pochhammer_max_index : 3;
(D1) 			       x (x + 1) (x + 2)
(C2)  pochhammer(x,4), pochhammer_max_index : 3;

(D2) 				     (x)
					4
</PRE>

<P>
The default value of pochhammer_max_index is 100. Reference A &#38; S 6.1.16, page 
256.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>spherical_bessel_j</B> <I>(n, x)</I>
<DD><A NAME="IDX18"></A>
The spherical Bessel function of the first kind. Reference: A &#38; S 10.1.8, page 
437 and A &#38; S 10.1.15, page 439.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>spherical_bessel_y</B> <I>(n, x)</I>
<DD><A NAME="IDX19"></A>
The spherical Bessel function of the second kind.  Reference: A &#38; S 10.1.9, 
page 437 and 10.1.15, page 439.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>spherical_hankel1</B> <I>(n,x)</I>
<DD><A NAME="IDX20"></A>
The spherical hankel function of the
first kind. Reference: A &#38; S 10.1.36, page 439.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>spherical_hankel2</B> <I>(n,x)</I>
<DD><A NAME="IDX21"></A>
The spherical hankel function  of the second kind. Reference  
A &#38; S 10.1.17, page 439.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>spherical_harmonic</B> <I>(n, m, x, y)</I>
<DD><A NAME="IDX22"></A>
The spherical harmonic function. Reference:  Merzbacher 9.64.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>unit_step</B> <I>(x)</I>
<DD><A NAME="IDX23"></A>
The <EM>left continuous</EM> unit step function; thus
<EM>unit_step(x)</EM> vanishes for <EM>x &#60;= 0</EM> and equals
1 for <EM>x &#62; 0</EM>. If you want a unit step function that
takes on the value 1/2 at zero, use <EM> (1 + signum(x))/2</EM>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>ultraspherical</B> <I>(n,a,x)</I>
<DD><A NAME="IDX24"></A>
The ultraspherical polynomial (also known the Gegenbauer polynomial).
Reference A &#38; S 22.5.46, page 779.
</DL>

</P>
<P><HR><P>
This document was generated on 30 August 2003 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51a.</P>
</BODY>
</HTML>
