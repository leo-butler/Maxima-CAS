/* Plotting examples -- try these by hand.
plot2d (if x > 1 then log(x) else exp(x), [x, -1, 3]);
f(x) := if x < 0 then -x else sqrt(x);
plot2d (f(x), [x, -2, 2]);
 */

(kill (all), 0);
0;

/* Test simplification of boolean expressions.
 * '(...) expressions are simplified but not evaluated.
 */

['("and" ()), '("or" ())];      /* analogous to * and + with no arguments */
[true, false];

/* These values are supposed to be ignored in quoted expressions '(...).
 */
(a : true, b : false, c : true, 0);
0;

('(a and b), [op (%%), args (%%)]);
["and", '[a, b]];

('(a or b), [op (%%), args (%%)]);
["or", '[a, b]];

('(not a), [op (%%), args (%%)]);
["not", '[a]];

('(a and b or c and d), [op (%%), args (%%)]);
["or", ['(a and b), '(c and d)]];

('((a or b) and (c or d)), [op (%%), args (%%)]);
["and", ['(a or b), '(c or d)]];

'(a and true);
'a;

'(a and false);
false;

'(a or true);
true;

'(a or false);
'a;

'[true and true, true and false, true or true, true or false, false and true, false and false, false or true, false or false];
[true, false, true, true, false, false, true, false];

'((a or true) and (b or true));
true;

'(a and true or b and true);
'(a or b);

'(a or b or c or false);
'(a or b or c);

'(a and b and c and true);
'(a and b and c);

'(not (a and b));
'((not a) or (not b));

'(not a and b);
'((not a) and b);

'(not (a or b));
'((not a) and (not b));

'(not (a or b or c or d or e));
'((not a) and (not b) and (not c) and (not d) and (not e));

'(not (a and b and c and d and e));
'((not a) or (not b) or (not c) or (not d) or (not e));

'(not (a or b and c or d and e));
'((not a) and ((not b) or (not c)) and ((not d) or (not e)));

'(not (a and not b or c and not d and not e));
'(((not a) or b) and ((not c) or d or e));

'(not a or b);
'((not a) or b);

'(not not a);
'a;

'(not not not a);
'(not a);

'(not not not not a);
'a;

/* Flattening nested expressions.
 * Maxima "and" and "or" are not commutative, so order of arguments should be preserved.
 * Flattening is a simplification => should happen in both simplification and evaluation.
 */

kill (all);
done;

('(x and b and ((h and d) and c) and y), [op (%%), args (%%)]);
["and", [x, b, h, d, c, y]];

('(x or b or ((h or d) or c) or y), [op (%%), args (%%)]);
["or", [x, b, h, d, c, y]];

'(x and b and ((h or d) or c) and (y and q and e));
x and b and (h or d or c) and y and q and e;

(x and b and ((h and d) and c) and y, [op (%%), args (%%)]);
["and", [x, b, h, d, c, y]];

(x or b or ((h or d) or c) or y, [op (%%), args (%%)]);
["or", [x, b, h, d, c, y]];

x and b and ((h or d) or c) and (y and q and e);
x and b and (h or d or c) and y and q and e;

/* Side-effects shouldn't happen in simplification (since arguments are not evaluated).
 */

(kill (a, b, c), 0);
0;

('((a : true) and (b : false) and (c : foo ())), [op (%%), args (%%), a, b, c]);
["and", '[a : true, b : false, c : foo ()], 'a, 'b, 'c];

('(not (a : true)), [op (%%), args (%%), a]);
["not", '[a : true], 'a];

/* Miscellaneous tests.
 */
expr: '(a > b and (equal (c, d) or e = 1) and not f <= g or notequal (h, %pi));
'(a > b and (equal (c, d) or e = 1) and f > g or notequal (h, %pi));

'(a > b and b > c and true or a < b and b < c and true or false or not true);
'((a > b and b > c) or (a < b and b < c));

'(not not not not a > b);
'(a > b);

'(not not not not not a > b);
'(a <= b);

'(not not not false and not not not not true);
true;

'(not foo (a));
funmake ("not", '[foo (a)]);

'[is (not a > b or false), is (not a > b or true), is (not a > b and false)];
'[is (a <= b), true, false];

'['is (not a > b or false), 'is (not a > b or true), 'is (not a > b and false)];
'['is (a <= b), true, false];

'[maybe (not a > b or false), maybe (not a > b or true), maybe (not a > b and false)];
'[maybe (a <= b), true, false];

'['maybe (not a > b or false), 'maybe (not a > b or true), 'maybe (not a > b and false)];
'['maybe (a <= b), true, false];

/* Test evaluation of boolean expressions.
 * Evaluate the arguments and simplify.
 */

["and" (), "or" ()];      /* analogous to * and + with no arguments */
[true, false];

(a and b, [op (%%), args (%%)]);
["and", '[a, b]];

(a or b, [op (%%), args (%%)]);
["or", '[a, b]];

(not a, [op (%%), args (%%)]);
["not", '[a]];

(a and b or c and d, [op (%%), args (%%)]);
["or", ['(a and b), '(c and d)]];

((a or b) and (c or d), [op (%%), args (%%)]);
["and", ['(a or b), '(c or d)]];

a and true;
'a;

a and false;
false;

a or true;
true;

a or false;
'a;

(a or true) and (b or true);
true;

a and true or b and true;
'(a or b);

a or b or c or false;
'(a or b or c);

a and b and c and true;
'(a and b and c);

not (a and b);
'((not a) or (not b));

not a and b;
'((not a) and b);

not (a or b);
'((not a) and (not b));

not (a or b or c or d or e);
'((not a) and (not b) and (not c) and (not d) and (not e));

not (a and b and c and d and e);
'((not a) or (not b) or (not c) or (not d) or (not e));

not (a or b and c or d and e);
'((not a) and ((not b) or (not c)) and ((not d) or (not e)));

not (a and not b or c and not d and not e);
'(((not a) or b) and ((not c) or d or e));

not a or b;
'((not a) or b);

not not a;
'a;

not not not a;
'(not a);

not not not not a;
'a;

/* Side-effects should happen in evaluation.
 */

((a : true) and (b : true) and (c : foo ()), [%%, a, b, c]);
[foo (), true, true, foo ()];

(not (a : bar ()), [%%, a]);
['(not bar ()), bar ()];

(kill (a, b, c), 0);
0;

/* Miscellaneous tests.
 */
expr: a > b and (equal (c, d) or e = 1) and not f <= g or notequal (h, %pi);
'(a > b and equal (c, d) and f > g or notequal (h, %pi));

''expr, e=1;
'(a > b and equal (c, d) and f > g or notequal (h, %pi));

''expr, e=1, h=%e;
true;

''expr, e=1, h=%pi;
'(a > b and equal (c, d) and f > g);

''expr, e=89, f = g + 1;
'(a > b and equal (c, d) or notequal (h, %pi));

(assume (notequal (c, d), equal (f, 100), g < 0), 0);
0;

''expr, e = 1;
'(notequal (h, %pi));

a > b and b > c and true or a < b and b < c and true or false or not true;
'((a > b and b > c) or (a < b and b < c));

not not not not a > b;
'(a > b);

not not not not not a > b;
'(a <= b);

not not not false and not not not not true;
true;

/* is-evaluation of conditionals.
 * is(foo) => true, false, and unknown or error (depending on prederror flag).
 */

ev (is (a > b or a > c), prederror=false);
unknown;

errcatch (ev (is (a > b or a > c), prederror=true));
[];

[is (not a > b or true), is (not a > b and false), 'is (not a > b or true), 'is (not a > b and false)];
[true, false, true, false];

[maybe (not a > b or false), maybe (not a > b or true), maybe (not a > b and false)];
[unknown, true, false];

['maybe (not a > b or false), 'maybe (not a > b or true), 'maybe (not a > b and false)];
['maybe (a <= b), true, false];

is (not a > b or true);
true;

is (not a > b and false);
false;

ev (maybe (not a > b or false), prederror=false);
unknown;

ev (maybe (not a > b or false), prederror=true);
unknown;

ev (maybe (not a > b), a = 100.0, b = 1000/3);
true;

ev (maybe (not a > b), b = 100.0, a = 1000/3);
false;

/* Test 'if (noun).
 */
(expr: if a > b then if a > c then a else d else if b > c then b else c, 0);
0;

(assume (a > b), ev (expr));
'(if a > c then a else d);

(forget (a > b), assume (a > c), ev (expr));
'(if a > b then if a > c then a else d else if b > c then b else c);

block ([x : 17, y : 29], block ([a : 100, b : 'x + 'y, c : x, d : y], ev (expr)));
'(if 100 > x + y then if 100 > 17 then 100 else 29 else if x + y > 17 then x + y else 17);

(forget (a > c), ev (expr));
'(if a > b then (if a > c then a else d) else (if b > c then b else c));

(assume (b < c), ev (expr));
'(if a > b then (if a > c then a else d) else (if b > c then b else c));

(assume (a > c), ev (expr));
a;

(apply (forget, facts ()), []);
[];

(foo (x) := if numberp (x) then if oddp (x) and x > 100 then 'foop (x) else 'nofoop (x)
  else 'if 'oddp (x) and x > 100 then 'foop (x) else 'nofoop (x), 0);
0;

foo (17);
'nofoop (17);

foo (117);
'foop (117);

foo (x + y);
'if 'oddp (x + y) and x + y > 100 then 'foop (x + y) else 'nofoop (x + y);

(assume (x < 0, y < 0), foo (x + y));
'nofoop (x + y);

/* assume fails to deduce x + y > 100 given x + y > 1000, oh well.
 * (forget (x < 0, y < 0), assume (x + y > 1000), foo (x + y));
 */
(forget (x < 0, y < 0), assume (x > 200), foo (x - 50));
'if 'oddp (x - 50) then 'foop (x - 50) else 'nofoop (x - 50);

/* Some examples devised by Stavros Macrakis */

(apply (forget, facts ()), kill (all), 0);
0;

pp: if x > 0 then print(1) else print(2);
'(if x > 0 then print(1) else print(2));

''pp, x=1;
1;

''pp, x= -1;
2;

(f (x, y) := if equal (y, 0) then 0 else 1/x, [f (8, n), f (m, 7)]);
[if equal (n, 0) then 0 else 1/8, 1/m];

/* if equal (y, 0) then 0 else 1/0; => division by zero in simplification */
errcatch (f (0, y));
[];

(f(x) := if x <= 0 then 1 else x*f(x - 1), fy : f(y));
'(if y <= 0 then 1 else y*f(y - 1));

''fy, y=8;
40320;

if equal (x, 0) then 1 else 1/x, x=0;
1;

/* Further examples in the same vein */

pp: if x > 0 then qq1: 1 else qq2: 2;
'(if x > 0 then qq1: 1 else qq2: 2);

(kill (qq1, qq2), ev (pp, x=1));
1;

[qq1, qq2];
[1, 'qq2];

(kill (qq1, qq2), ev (pp, x= -1));
2;

[qq1, qq2];
['qq1, 2];

block ([aa : 2, bb : 3, cc], if cc > 1 then if aa > 0 then 10*aa else -10*aa else if bb > 0 then bb^2 else -bb^2);
'(if cc > 1 then (if 2 > 0 then 20 else -20) else (if 3 > 0 then 9 else -9));

block ([aa : 2, bb : 3, cc], if cc > 1 and aa > 0 then 10*aa elseif cc > 1 and not aa > 0 then -10*aa elseif  not cc > 1 and  bb > 0 then bb^2 elseif not cc > 1 and not bb > 0 then -bb^2);
'(if cc > 1 then 20 elseif cc <= 1 then 9);

print(FOO) or print(BAR); /* should print "FOO" and "BAR" on successive lines */
FOO or BAR;

print(true) or print(false); /* should print "true" */
true;

(push (a, L) ::= buildq ([a, L], L : cons (a, L)), 0);
0;

(L : [], push (FOO, L) or push (BAR, L));
[FOO] or [BAR, FOO];

L;
[BAR, FOO];

(L : [], '(push (FOO, L) or push (BAR, L)), [op(%%), op(first(%%)), args(first(%%)), op(second(%%)), args(second(%%))]);
["or", push, '[FOO, L], push, '[BAR, L]];

L;
[];

/* Should find that aa or bb or cc ... is equivalent to
 * (is(aa), if %% then %% else (is(bb), if %% then %% else (is(cc), if %% then %% else ...)))
 * when all aa, bb, cc, ... evaluate to true or false.
 */

(L : [], first (push (false, L)) or first (push (true, L)) or first (push (true, L)), [%%, L]);
[true, [true, false]];

(L : [], (is(first (push (false, L))), if %% then %% else (is(first (push (true, L))), if %% then %% else (is(first (push (true, L))), if %% then %%))), [%%, L]);
[true, [true, false]];

/* Translation of conditionals and boolean expressions.
 * Translating this file (rtest_boolsimp.mac) would be a good test,
 * but the translator is too broken to translate all of the file.
 */

/* Leave this mode_declare for later.
 * The effect which would be observable here would be
 * to trigger an error if some argument is not true or false.
 * But as it stands, the translation code doesn't exploit
 * the boolean mode_declare in any way.
mode_declare ([a%, b%, c%, d%], boolean);
[[a%, b%, c%, d%]];
 */

/* Example from mailing list 2006/05/04, tnx Barton */

(kill(f), f(x) := if x < 0 then -1 else 1, 0);
0;

f(a);
'if a < 0 then -1 else 1;

(translate(f), f(a));
'if a < 0 then -1 else 1;

/* Other examples of translated functions */

(my_max (x, y, z) := if x > y and x > z then x elseif y > z then y else z, translate (my_max));
[my_max];

my_max (11, 33, 22);
33;

my_max (a + b, c, 1);
'if a + b > c and a + b > 1 then a + b elseif c > 1 then c else 1;

[assume (c < 1), my_max (a + b, c, 1), forget (c < 1)];
[[c < 1], 'if a + b > c and a + b > 1 then a + b else 1, [c < 1]];

(kill (aa, bb, cc, dd),
 implies (a%, b%) := (not a%) or b%,
 equivalent (a%, b%) := implies (a%, b%) and implies (b%, a%),
 translate (implies, equivalent));
[implies, equivalent];

implies (aa and bb, cc or dd);
not aa or not bb or cc or dd;

implies (aa and bb, aa);
not aa or not bb or aa;

equivalent (aa, aa);
(not aa or aa) and (not aa or aa);

/* crime scene example from mailing list 2006/05/06 tnx Mario */

(kill (all),
 "=>" (r, s) := not r or s,
 infix ("=>"),
 implies (ante, conse, listvar) := block ([expr, npos, maxn, combis:[], bits, quot, div],
    npos: length(listvar),
    maxn: 2^npos - 1,
    expr: not ante or conse,
    for i:0 thru maxn do
       (bits: [],
        quot: i,
        for j: 1 thru npos do
           (div: divide (quot, 2),
            quot: div[1],
            bits: cons (listvar[j]=div[2], bits)),
        combis: cons (subst ([1=true, 0=false], bits), combis)),
    apply ("and", makelist (subst (k, expr), k, combis))), 0);
0;

implies ((p or q) and (q => r) and (p => s) and not r, s, [p, q, r, s]);
true;

