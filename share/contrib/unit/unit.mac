/* Filename unit.mac

       ***************************************************************
       *            Unit Conversion and Definition Package           *
       *							     *
       *                                                             *
       *         This package gives one the ability to convert 	     *
       *         between units, define globally all units of a       *
       *         given property (mass, for example) in terms of	     *
       *	 a base unit, and various other abilities. 	     *
       *         						     *
       *         	       Version 0.10			     *
       *                       March 9, 2005			     *
       *		       License:  GPL			     *
       *							     *
       *          ------------------------------------------         *
       *          Programmed by Cliff Yapp and Barton Willis         *
       *            	     					     *
       ***************************************************************
       
       
    General Design Notes:
    
       The variables current_let_rule_package and letrat are set on a
       per function level in order to cause the minimum of disruption
       to the default system behavior.

     Changes:

       0.10  -  total rewrite using more advanced rule based
                techniques for handling units has begun.
       0.03  -  fixed unitfactor so it would work on standard unit
		names even if setunits had already defined them. Added
		command findnonpivotunit which will return if defined
		the non pivot unit corresponding to a given conversion 
		factor times a given pivot unit.
       0.02  -  added ability to control how many metric prefixes are
		used to generate the meta list, and a killunits function
		to undo what setunits does.
       0.01  -  first development version - metalist generateable,
        	unitfactor and setunits operational.  Only basic Mass
		and Time arrays present.  Metric prefixes entered.
============================================================================*/ 

ttyoff: nolabels, true$

/*
Metric prefixes
*/
metricprefull : [[yotta,10^24,4],[zetta,10^21,4],[exa,10^18,4],[peta,10^15,3],
		[tera,10^12,3],[giga,10^9,2],[mega,10^6,2],[kilo,10^3,1],
		[hecto,10^2,2],[deka,10^1,2],[deci,10^-1,2],[centi,10^-2,1],
		[milli,10^-3,1],[micro,10^-6,2],[nano,10^-9,2],[pico,10^-12,3],
		[femto,10^-15,3],[atto,10^-18,4],[zepto,10^-21,4],
		[yocto,10^-24,4]];
metricpre : 	[[Y,10^24,4],[Z,10^21,4],[E,10^18,4],[P,10^15,3],[T,10^12,3],
		[G,10^9,2],[M,10^6,2],[k,10^3,1],[h,10^2,2],[da,10^1,2],
		[d,10^-1,2],[c,10^-2,1],[%%m,10^-3,1],[%mu,10^-6,2],[n,10^-9,2],
		[p,10^-12,3],[f,10^-15,3],[a,10^-18,4],[z,10^-21,4],
		[y,10^-24,4]];

/*============================ Unit Information ============================*/ 

/* Seven Mutually Independent Base Quantities 

  The globalbaseunitlisting maintains a list of all quantities considered to be
  Base Quantities.  This means all other units result from combinations of 
  these units.  The list associated with each quantity is named %quantitylisting
  and is structured as follows:
   
   -  The first unit in each list is called the pivot unit. All other units
      for this quantity, and all derived units using this quantity, will be 
      defined in terms of this unit.  The pivot unit is also the standard SI
      unit in the case of Base Quantities
      
   -  Each entry in the top level list is itself a list, containing as its 
      first entry a list of the names to be associated with this unit.  The 
      second position contains the conversion factor between the unit in 
      question and the pivot unit.  In the case of a pivot unit, this value
      is 1.  The third position is a flag which tells Maxima whether this 
      unit is metric or not.  Metric units can be automatically generated
      using the base name and the metric prefix lists, which contain both the
      prefix and the power of ten associated with it.  These definitions will
      make the following assumptions:
      	- The first unit name is the abbreviation of the unit's full name, 
	  and will append the metric abbreviation prefix.  In the case of a 
	  % at the beginning of the name, this is moved to the beginning of 
	  the new metric quantity's name.	
	- All other unit names in the list are assumed to be full names, and 
	  will have the full metric prefix appended to them.

*/

globalbaseunitlisting : [%length,%mass,%time,%current,%temperature,
%amount_of_substance,%luminous_intensity];

/*Length */
%lengthlisting : [[[m,meter,meters],1,m],[[%in,inch,inches],0.0254,e]];

/*Mass*/
%masslisting : [[[kg,kilogram,kilograms],1,0],[[g,gram,grams],1/1000,m],
[[gr,grain,grains],0.06479891,e]];

/*Time*/
%timelisting : [[[s,second,seconds],1,m],[[%min,minute,minutes],1/60,e]];

/*Electric Current*/
%current : [[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Thermodynamic Temperature*/
%temperature : [[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Amount of Substance*/
%amount_of_substance : [[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Luminous Intensity*/
%luminous_intensity : [[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];


/* Derived Units
 
   The structure of these lists is slightly different from the Base
   Quantities.  The first entry in eacy list describes the Derived Quantity 
   in terms of the relevant Base Quantities, using the pivot unit of the
   Base Quantities. It is a list of two entries, the definition in abbreviated
   units and fullnames. After that, the structure is the same as Base Quantity
   lists. globalderivedunitslisting lists all derived quantities known to
   Maxima.  A second global listing, called globalderivedunitlisting_use, is
   defined using the following structure:  [rank,quanitiy].  rank is
   a numerical value which allows globalderivedunitlisting to be sorted. This
   is necessary in order to ensure that the simplification rules are defined
   in the correct order.  This list is created automatically on package
   load, and updated if a user defines a new quantity.*/

globalderivedunitlisting:[%volume,%frequency,%force,%pressure,
%energy,%power,%electric_charge,%electric_potential_difference,
%capacitance,%resistance,%conductance,%magnetic_flux,
%magnetic_flux_%density,%inductance,%luminous_flux,%illuminance,
%radionuclide_activity,%absorbed_dose,%dose_equivalent,
%catalytic_activity];

/*Volume*/
%volumelisting : [m^3,[[L,liter,liters],1,m]];


/* Derived Units with Special SI Names and Symbols 

   These are similar in structure to the Derived Unit lists above, but
   because they have a unique name associated with them in SI the policy
   is to have the first entry after the base quantity definition be the
   SI unit.  Overall structure is the same.  These are listed in the same
   globalderivedunitslisting as the previous Derived Units.
   
   Note - depending on circumstances, it is sometimes of interest to
          have energy reported as work or heat in dimensional analysis.
	  Need to work on this.*/

/*Frequency*/
%frequencylisting : [1/s,[[Hz,hertz],1,m]];

/*Force*/
%forcelisting : [kg*m/s^2,[[N,%Newton,Newtons],1,d],
[[dyn,dyne,dynes],1*10^-5,d]];

/*Pressure*/
%pressurelisting : [kg/(m*s^2),[[Pa,pascal,pascals],1,d],[[torr],133.32239,d]];

/*Energy, Work, Quantity of Heat */
%energylisting : [kg*m^2/s^2,[[J,joule,joules],1,m],
[[eV,electron_volt,electron_volts],1.6021765*10^-19,m]];

/*Power, Radiant */
%powerlisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Electric Charge, Quantity of Electricity*/
%electric_chargelisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Electric Potential Difference, Electromotive Force */	
%electric_potential_differencelisting : [baseunitexpr,[[a,aa,aaa],0,eee],
[[b,bb,bbb],0,eee]];

/*Capacitance*/
%capacitancelisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Electric Resistance*/
%resistancelisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Electric Conductance*/
%conductancelisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Magnetic Flux*/
%magnetic_fluxlisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Magnetic Flux Density*/
%magnetic_flux_densitylisting : [baseunitexpr,[[a,aa,aaa],0,eee],
[[b,bb,bbb],0,eee]];

/*Inductance*/
%inductancelisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Luminous Flux*/
%luminous_fluxlisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Illuminance */
%illuminance_listing : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Activity (of a radionuclide)*/
%radionuclide_activitylisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Absorbed Dose, Specific Energy (imparted), Kerma */
%absorbed_doselisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Dose Equivalent*/
%dose_equivalentlisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];

/*Catalytic Activity */
%catalytic_activitylisting : [baseunitexpr,[[a,aa,aaa],0,eee],[[b,bb,bbb],0,eee]];


/*===================== Package Functions ====================*/ 

/*The default behavior of let doesn't work for the purposes of this
  package, so we define unitlet here using Jeff Golden's trick of
  having apply evaluate the inputs.  (Thanks to Barton Willis
  for an elegant solution.) A source level fix to let is also
  possible but does cause a default behavior change in let:
  
  nisimp.lisp, line 66
  <              (setq replacement (cdr l))
  >              (setq replacement (list (meval(cadr l))))
  
  if it is ever applied we can convert back to the default let, but
  it shouldn't matter one way or the other*/

unitlet(expression,ruleset) := apply('let,[expression,ruleset]);

/* Something similar to unitlet is needed to kill rulesets */
killruleset(ruleset) := apply('kill,[ruleset]);

/* Tool to check for duplicates in a list - returns false if found,
   true otherwise */
   
checkforuniqueness(list1) := block([i,j,return],
   return : true,
   for i : 1 thru length(list1) do (
      for j : i+1 thru length(list1) do (
        if ?equal(list1[i],list1[j]) then (
	   return : false)
	 )),
   return);

/* Add all desired metric quantities into %quantitylisting_use lists.  
   %quantitylisting_use lists are the one actually used in functions.  This allows
   the program to regenerate a new metric list from "original" package lists
   in order to avoid multiple definitons of metric prefix quantities.  An
   exception is made for kg, kilogram, and kilograms becasue they are defined
   already as the pivot unit for mass.  This is a consequence of the nature of
   the SI system.*/

metricexpandall(%limit) := block([i,j,k,l,unitlistname,
				  unitlistusename,tempentry],
   modedeclare([i,j,k,l], fixnum),
   for i : 1 thru length(globalbaseunitlisting) do  (
     unitlistname : concat(globalbaseunitlisting[i],listing),
     unitlistusename : concat(globalbaseunitlisting[i],listing_use),
     unitlistusename :: ev(unitlistname),
     for j : 1 thru length(ev(unitlistname)) do  (
        if (?equal(unitlistname[j][3],m)) then (
	  for k : 1 thru length(metricpre) do (
	  tempentry : [[0],0,expanded],
	  if is(metricpre[k][3] <= %limit) then (
	    if (not(?equal(metricpre[k][1],'k) and 
	        ?equal(unitlistname[j][1][1],g))) then (
	      tempentry[1][1] : concat(metricpre[k][1],unitlistname[j][1][1]),
	      tempentry[2] : metricpre[k][2]*unitlistname[j][2])),
	    if is(metricprefull[k][3] <= %limit) then (
	      for l : 2 thru length(unitlistname[j][1]) do(
	      if (not(?equal(metricprefull[k][1],kilo) and 
	             (?equal(unitlistname[j][1][l],gram) or
		      ?equal(unitlistname[j][1][l],grams)))) then (
	      tempentry[1] : append(tempentry[1],[concat(metricprefull[k][1],
		                      unitlistname[j][1][l])])
	      ))),
	  if not(?equal(tempentry[1][1],0)) then (    
	  unitlistusename :: append(ev(unitlistusename),[tempentry])))))),
	  
   for i : 1 thru length(globalderivedunitlisting) do  (
     unitlistname : concat(globalderivedunitlisting[i],listing),
     unitlistusename : concat(globalderivedunitlisting[i],listing_use),
     unitlistusename :: ev(unitlistname),
     for j : 2 thru length(ev(unitlistname)) do  (
        if (?equal(unitlistname[j][3],m)) then (
	  for k : 1 thru length(metricpre) do (
	  tempentry : [[0],0,expanded],
	  if is(metricpre[k][3] <= %limit) then (
	      tempentry[1][1] : concat(metricpre[k][1],unitlistname[j][1][1]),
	      tempentry[2] : metricpre[k][2]*unitlistname[j][2]),
	    if is(metricprefull[k][3] <= %limit) then (
	      for l : 2 thru length(unitlistname[j][1]) do(
	        tempentry[1] : append(tempentry[1],[concat(metricprefull[k][1],
		                      unitlistname[j][1][l])])),
		unitlistusename :: append(ev(unitlistusename),[tempentry]))))))
   );
	  
/* Create unitsimplify ruleset

   This ruleset is used to simplify unit processing.  When a unit is processed
   a simplification of that unit using toquantities will return the 
   quantity it represents.  This enables subsequent operations on the unit to 
   know what list to look at for conversions and at the same time simplifies 
   the programming of dimensional analysis functionality.  The addunit command
   will automatically add on information to this list in order to maintain the 
   validity of the operation.  The metricexpandall function must be called 
   before this command is run.*/
   
maketoquantitiesruleset() := block([i,j,k,b,unitlistname],
    modedeclare([i,j,k], fixnum),
    for i : 1 thru length(globalbaseunitlisting) do  (
     unitlistname : concat(globalbaseunitlisting[i],listing_use),
     for j : 1 thru length(ev(unitlistname)) do  (
       for k : 1 thru length(unitlistname[j][1]) do (
         unitlet([unitlistname[j][1][k],globalbaseunitlisting[i]],
	         toquantities)
    ))),
    
    /* j needs to start at the second entry for Derived Quantity Arrays */
    for i : 1 thru length(globalderivedunitlisting_use) do  (
     unitlistname : concat(globalderivedunitlisting_use[i][2],listing_use),
     for j : 2 thru length(ev(unitlistname)) do  (
       for k : 1 thru length(unitlistname[j][1]) do (
         unitlet([unitlistname[j][1][k],globalderivedunitlisting_use[i][2]],
	         toquantities)
    )))
    );

/* Determines if an input is a Unit.  Note that units must be
   atoms for this test to work, so this package will adopt a
   policy of unit names being atoms only. */

isunit(candidate) := block([letrat:true,result],
	if not(?atom(candidate)) then (
           /*Error message if argument to isunit isn't an atom*/
	   (error ("Argument to isunit was not an atom.  Maxima requires units to be atoms.  Erroneous input: ",candidate))
	) else (
	/* This test simply checks if the candidate will return
	   a quantity under the previously defined rules.  If it
	   does, then it is a unit.  If it does not, then it will
	   not be impacted by those simplification rules and the
	   condition of equality will be satisfied.  In such a
	   case the result is that candidate is not a unit. */
	if ?equal(candidate,letsimp(candidate,toquantities)) then (
	     /*Error if input isn't a unit - mentions the addunit command.*/
	   (error ("Input is not a unit.  To define your own unit, use the addunit command."),candidate)) 
	else (
	true)));

/* Determines if a unit is a Base Quantity */
isbase(unit) :=  block([letrat:true,result,quantity],
	/*Uses the simplify to quantity ruleset and checks if the quantity
	  is present in the base list.*/
	if not(lfreeof(globalbaseunitlisting,
	                       letsimp(unit,toquantities))) then (
		result : true)
	else (
	if isunit(unit) then (result : false)),
	result);

/* Returns the definition of a unit in terms of the seven base quantities.*/
base(unit):= block([letrat:true,result,i,j,listname],
  	modedeclare([i,j], fixnum),
	if not(isbase(unit)) then (
	   listname:concat(letsimp(unit,toquantities),listing_use),
	   for i:1 thru length(ev(listname)) do (
	     for j:1 thru length(listname[i][1]) do (
	        if (?equal(unit,listname[i][1][j])) then (
	            result : listname[1]*listname[i][2] )		    
		    )))
	else (
	result : unit),
	result);

/* Returns the mks base units for a quantity.*/
quanttomks(quantity):= block([letrat:true,result,listname],
	listname:concat(quantity,listing_use),
	if not(lfreeof(globalbaseunitlisting,quantity)) then (
            result : listname[1][1])
	else (
	if not(lfreeof(globalderivedunitlisting,quantity)) then (
	    result : listname[1])
	else (
	error ("Quantity not found"))),
	result);

/* This utility makes a list of quantities from a list of units.  It is
   used to validate input for setunits, and also in the derived quantity
   ruleset process. */
makequantlist(unitlist) := block([current_let_rule_package : toquantities, 
                                  return1], 
         return1 : map('letsimp,unitlist));


/* Handles creation of rules for base units */
baserules(currentunitlist,unitlistname,baseunitrules):= 
 block([letrat:true,i,j,a,b,fakerule],
   killruleset(baseunitrules),
   unitlet([fakerule,fakerule],baseunitrules),
   for i : 1 thru length(ev(unitlistname)) do (
     if lfreeof(unitlistname[i][1],currentunitlist[1]) then (
       for j : 1 thru length(unitlistname[i][1]) do (
         if ?equal(abbrevsimp,1) then (
	     unitlet([unitlistname[i][1][j],
	        unitlistname[i][2]/currentunitlist[2]*
		first(currentunitlist[1])],baseunitrules)
	 )else(
	 if ?equal(abbrevsimp,1) then (
	     unitlet([unitlistname[i][1][j],
	        unitlistname[i][2]/currentunitlist[2]*
		last(currentunitlist[1])],baseunitrules)
	 )else(
	     a : length(unitlistname[i][1]),
	     b : length(currentlistname[1]),
	     
	     if (?equal(a,b) or ?equal(j,1)) then (
	         unitlet([unitlistname[i][1][j],
		    unitlistname[i][2]/currentunitlist[2]*
		    currentunitlist[1][j]],baseunitrules)
	     )else(
		 unitlet([unitlistname[i][1][j],
		    unitlistname[i][2]/currentunitlist[2]*
		    last(currentunitlist[1])],baseunitrules)
	     ))
	))))
);

/*--------------------Derived Quantity rank assignment ----------------------*/

/* This set of functions assigns ranks to all derived quantities, with higher
rankings corresponding to more complex quantities.  This is essential in order
to ensure that the simplification rules check for quantities in the
proper order.  For example, if the rules do not recognize J before N, J
will never be resolved unless the rules know to look for an expression
containing N.  This can be done, but the cleaner way (particularly in
the case of user defined quantities) is to assign rank numbers in such
a way that the check for each is done in the proper order.  This is
accomplished by checking each new quantity's MKS definition to see what
units contain it.  If a quantity of a given rank DOES contain the new quanity
as part of its definiton, simplification of the higher rank unit using the
simprule for the new unit will result in a changed expression.  So for each
new quantity this check is performed until a rank is found where this does
not happen.  In that case, the new quantity is assigned the rank at which
no changes occurred due to substitution.  If the highest ranking quantity in the
array is contained in the new quantity, the new quantity is assigned rank+1 and
becomes the new highest ranking unit.  Call metricexpandall first.*/

rankquant(newquantity, listsanshighranks) := block([letrat : true,
   i,j,highnum,lower,lowerin,return1,lowerpart,higherpart,
   highestrank],
   kill(testfornew),
   unitlet([quanttomks(newquantity),newquantity],testfornew),
   listsanshighranks : reverse(sort(listsanshighranks)),
   highestrank : listsanshighranks[1][1],
   i : 1,
   highnum : 0,
   lower : true,
   while (?is(i<=length(listsanshighranks)) and 
          ?equal(listsanshighranks[i][1],highestrank)) do (
      highnum : highnum + 1,
      i : i + 1),
   for i : 1 thru highnum do (
     if (?equal(ratsimp(letsimp(quanttomks(listsanshighranks[i][2]),testfornew)/
                        quanttomks(listsanshighranks[i][2])),1)) then (
         lower : false)
   ),
   if (lower and ?equal(highestrank,1)) then (
     for i : 1 thru length(listsanshighranks) do(
        listsanshighranks[i][1] : listsanshighranks[i][1] + 1),
      return1 : append(listsanshighranks,[[1,newquantity]])
   ) else (
   if lower then (
      lowerpart : rankquant(newquantity,rest(listsanshighranks,highnum)),
      higherpart : rest(listsanshighranks,highnum-length(listsanshighranks)),
      if ?equal(lowerpart[1][1],last(higherpart)[1]) then (
        for i : 1 thru length(higherpart) do (
	  higherpart[i][1] : higherpart[i][1] + 1)),
      return1 : append(higherpart,lowerpart)
   ) else (
   if not(lower) then (
      i : 1,
      lowerin : true,
      for i : 1 thru highnum do (
          if (?equal(ratsimp(ratsubst('test,quanttomks(listsanshighranks[i][2]),quanttomks(newquantity))/
	           quanttomks(newquantity)),1)) then (
           lowerin : false)),
      if lowerin then (
         return1 : append([[highestrank+1,newquantity]],listsanshighranks)
      ) else (
         return1 : append([[highestrank,newquantity]],listsanshighranks))
    ))),
    return1);
    
      
rankquants(quantityarray) := block([letrat : true, ranknew, rankmax, 
                                   currentrank,i,j,returna],
   returna : [[1,quantityarray[1]]],
   quantityarray : rest(quantityarray,1),
   while ?is(length(quantityarray) > 0) do (
      returna : rankquant(quantityarray[1],returna),
      quantityarray : rest(quantityarray,1)),
   returna);
	


/* Creates rule sets for derived units  - depends on the existance
of a properly ranked global derived quantity list.  For the purpose
of preserving fullname vs. abbr information, each quantity will be
assigned two unique multiplicative factors which will be added to the mks
simp rules to preserve this information.  They will be removed in the
de-simplification back to end user units, and in the process allow proper
preservation of the choice of short vs. long names.  baserules might
be needed for this to work, but probably not.*/

derivedrules(currentunitlist):= block([letrat:true,i,j,a,b,fakerule],
   killruleset(derivedsimpunitrules),
   killruleset(derivedexpandunitrules),
   unitlet([fakerule,fakerule],derivedsimpunitrules),
   unitlet([fakerule,fakerule],derivedexpandunitrules),
   quantlist1 : makequantlist(unitlist),
   for a : 1 thru length(globalderivedunitlisting_use) do (
    unitlistname : concat(globalderivedunitlisting_use[a][2],listing_use),
    for i : 2 thru length(ev(unitlistname)) do (
      for j : 1 thru length(unitlistname[i][1]) do (
      unitlet([unitlistname[i][1][j], base(unitlistname[i][1][j])],derivedsimpunitrules)
	   ))),
   for a : 1 thru length(globalderivedunitlisting_use) do (
    if lfreeof(dontuselist,globalderivedunitlisting_use[a][2]) then (
      unitlistname : concat(globalderivedunitlisting_use[a][2],listing_use),
      found : 0,
      i : 1,
      while not(?equal(found,0)) and ?is( i <= length(quantlist1)) do (
	  if ?equal(globalderivedunitlisting_use[a][2],quantlist1[i]) then (found : i)),
      if not(?equal(found,0)) then (
        for i : 2 thru length(ev(unitlistname)) do (
         if not(lfreeof(unitlist[found],unitlistname[i][1])) then (
         unitlet([unitlistname[1][1],unitlistname[i][1][1]/unitlistname[i][2]],derivedexpandunitrules)))
      ) else (
      error("Could not find unit definition."))
   ) else (
   unitlet([unitlistname[1][1],unitlistname[2][1][1]],derivedexpandunitrules))
   )
);



/*====================== User Functions ======================*/ 

/* Returns the Maxima abbreviation used for fullunitname */
showabbr(fullunitname):= block([letrat:true,i,j,unittype,unitlistname,
                         currentunitlist,flag,return1],
   if not(isunit(fullunitname)) then (
     (error ("Input is not a unit.  To define your own unit, use the addunit command."),unit)
   ) else (
      unittype : letsimp(fullunitname,toquantities),
      unitlistname : concat(unittype,listing_use),
      flag : 0, i:0,
      if not(isbase(fullunitname)) then (i : i+1),
      while ?equal(flag,0) do(
        i : i+1,
        if not(lfreeof(unitlistname[i][1],fullunitname)) then (
           return1 : unitlistname[i][1][1],
	   flag : 1),
	if ?equal(i, length(ev(unitlistname))) then (flag : 1)
      )),
   return1);

/* Returns all the full names of the unit abbr */
showfullname(abbr):= block([letrat:true,i,j,unittype,unitlistname,
                         currentunitlist,flag,return1],
   if not(isunit(abbr)) then (
     (error ("Input is not a unit.  To define your own unit, use the addunit command."),unit)
   ) else (
      unittype : letsimp(abbr,toquantities),
      unitlistname : concat(unittype,listing_use),
      flag : 0, i:0,
      if not(isbase(abbr)) then (i : i+1),
      while ?equal(flag,0) do(
        i : i+1,
        if not(lfreeof(unitlistname[i][1],fullunitname)) then (
           return1 : rest(unitlistname[i][1],1),
	   flag : 1),
	if ?equal(i, length(ev(unitlistname))) then (flag : 1)
      )),
   return1);

/* Prints out information about a unit */
unitinfo(unit):= block([letrat:true,result,quantity],

/* Sets the units used in the global tellsimpafter evaluation.  Takes
as its arguments either a single unit or a list of units.  Checks to
make sure the list contains only one unit per quantity.  Will need to
update to handle derived quantities - map won't work.*/
setunits(units):= block([letrat:true,i,j,unittype,unitlistname,
                         unitrules,currentunitlist, flag],
  modedeclare([i,j], fixnum),
  if listp(units) then (
     if (is(length(units) > 1) and not(?equal(length(units),0))) then (
        if (checkforuniqueness(makequantlist(units))) then (             
              map ('setunits, units))
        else (
          (error ("Error - two or more of these units describe the same quantity."))
     ))
     else (
     	if ?equal(length(units),1) then (map ('setunits, units))
     ))
  else (
  if (isunit(units)) then (
      unittype : letsimp(units,toquantities),
      unitlistname : concat(unittype,listing_use),
      unitrules : concat(unittype,'rules),
      flag : 0, i:0,
      while ?equal(flag,0) do(
        i : i+1,
        if not(lfreeof(unitlistname[i][1],units)) then (
           currentunitlist : unitlistname[i],
	   flag : 1),
	if ?equal(i, length(ev(unitlistname))) then (flag : 1)
      ),
      if isbase(units) then (
         baserules(currentunitlist,unitlistname,unitrules)
      ) else (
         derivedrules(currentunitlist)
      )
   )));

/*  Allows the user to create their own units */
addunits([[unitname(s)],definition,0]):=

/*  Converts an expression into one using the specified units */
convert(expression,desiredunits):=

/*====================== Initilization =======================*/

/* This variable controls how many of the metric prefixes are added
   on to the default lists*/
%unitexpand : 2;

/* Places all relevant metric definitons into the %quantitylist lists.*/
metricexpandall(%unitexpand);

/* Creates global list of derived quantities with rank assigned to each
quantity to allow for proper simplification.  Remember for addunit command
and any similar commands to add a new quantity to the globalderivedunitlist,
then recreate the use list. */
globalderivedunitlisting_use : rankquants(globalderivedunitlisting);


/* Variable to control how simplification behaves with respect to 
   fullnames and abbreviations.  The default, 0, simplifies abbrev. to
   abbrev. and fullnames to fullnames, also preserving plurals when
   possible.  There are two other possible settings:
      1 : fullname -> abbreviation (singular and plural fullnames -> abbrev.)
      2 : abbreviation -> fullname (will use plural form) */
abbrevsimp : 0;
      
/* Create default toquantities ruleset*/
maketoquantitiesruleset();

/* Instruct the global simplification routines to call the simplification
   function defined in this package, to allow automatic unit conversion
   without the user having to explicitly call a function.*/
freeofunitsp([x]) := lfreeof(nonfinalunitslist,x);
notfreeofunitsp([x]) := not(freeofunitsp(x));
matchdeclare(a,freeofunitsp(a),b,notfreeofunitsp(b));
processunits(x) := letsimp(x,currentunitsimprules);
tellsimpafter(a*b,a*processunits(b));


ttyoff: nolabels, false$
