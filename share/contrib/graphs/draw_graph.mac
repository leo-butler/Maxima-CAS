/*  
  GRAPHS - graph theory package for Maxima
  Copyright (C) 2007 Andrej Vodopivec <andrej.vodopivec@gmail.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or	 
  (at your option) any later version. 

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

*/

define_variable(gp_file_out, "out.txt", any)$
define_variable(gp_file_in, "in.txt", any)$
define_variable(draw_graph_program, 'spring_embedding, any)$

if draw_loaded#true then load("draw")$

circular_positions(G) := block(
  [v_list, numer : true, n : graph_size(G)],
  v_list : vertices(G),
  makelist(
    [v_list[i+1],
    [2+cos(2*i*%pi/n), 2+sin(2*i*%pi/n)]],
    i, 0, graph_size(G)-1))$

write_file(G) := block(
  [display2d:false, file, e],
  file : openw(gp_file_in),
  printf(file, "graph {"),
  for e in edges(G) do (
    printf(file, "~s -- ~s~%", e[1], e[2])),
  printf(file, "}"),
  close(file),
  'done)$

read_file() := block(
  [lst : read_list(gp_file_out),
   v_pos : [], v, x, y],
  while length(lst)>0 do (
    v : first(lst), lst : rest(lst),
    if v = 'node then (
      v : first(lst), lst : rest(lst),
      x : first(lst), lst : rest(lst),
      y : first(lst), lst : rest(lst),
      v_pos : cons([v, [x, y]], v_pos))),
  v_pos)$

graphviz_positions(G, program) := block(
  [command],
  write_file(G),
  if program = 'dot then
    command : concat("dot -Tplain \"",
      gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'twopi then
    command : concat("twopi -Tplain \"",
      gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'circo then
    command : concat("circo -Tplain \"",
      gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'fdp then
    command : concat("fdp -Tplain \"",
      gp_file_in, "\" > \"", gp_file_out, "\"")
  else
    command : concat("neato -Tplain \"",
      gp_file_in, "\" > \"", gp_file_out, "\""),
  system(command),
  read_file())$


/* taken from augmented_lagrangian */
with_parameters ([L]) ::= buildq (
  [a : subst (":", "=",  ev (L [1])), e : rest (L)],
  block (a, splice (e)) );

draw_graph(G, [options]) := block(
  [
   wxplot_size : [300,300],
   program : draw_graph_program, 
   show_id : false, show_label : false, show_weight : false,
   vertex_color : 'red, text_color : 'blue, edge_color : 'black,
   show_vertex_color : 'blue, show_edge_color : 'blue,
   vertex_type : 7, show_vertex_type : 7,
   edge_type : solid, show_edge_type : solid,
   head_length : 0.1, head_angle : 15,
   vertices:[], edges:[], v_pos, vertex_labels:[], edge_weights:[],
   show_vertices : [], vertices1 : [],
   vertex_size : 2, show_vertex_size : 2,
   show_edges : [], edges1 : [],
   edge_width : 1, show_edge_width : 2,
   command, x_max, y_max, gp_options,
   terminal : 'screen, file_name : "graph",
   gp_file_in : temp_filename(gp_file_in),
   gp_file_out : temp_filename(gp_file_out),
   redraw : false, directed : false,
   label_alignment : 'left, label_padding: "  ",
   fixed_vertices : [],
   spring_embedding_depth : 50
  ],

  if not(is_graph(G)) and not(is_digraph(G)) then
    error("First argument to `draw_graph' is not a graph:", G),

  if get('wxmaxima, 'version)#false then (
    terminal : 'wxmaxima,
    if (assoc('terminal, options))=false then (
      vertex_size : 1.2,
      show_vertex_size : 1.2)),
  if is_digraph(G) then directed : true,
  
  with_parameters(options,

    /* Get vertex positions */
    v_pos : get_positions(G),
    if redraw=true or v_pos=false then (
      if member(program, ['neato, 'dot, 'twopi, 'fdp, 'circo]) then
        v_pos : graphviz_positions(G, program)
      else if program = 'spring_embedding then
        v_pos : spring_embedding(G, spring_embedding_depth, fixed_vertices)
      else if program = 'planar_embedding then block(
        [embedding : planar_embedding(G), c],
        if embedding=false then
          error("The graph is not a 2-connected planar graph")
        else (
          c : embedding[1],
          for i:2 thru length(embedding) do (
            if length(embedding[i])>length(c) then c:embedding[i]),
          v_pos : spring_embedding(G, spring_embedding_depth, c)))
      else
        v_pos : circular_positions(G),
      set_positions(v_pos, G)),

    /* Normalize positions into [-1,1]x[-1,1] */
    x_max : lmax(map(lambda([u], part(u, 2, 1)), v_pos)),
    x_min : lmin(map(lambda([u], part(u, 2, 1)), v_pos)),
    y_max : lmax(map(lambda([u], part(u, 2, 2)), v_pos)),
    y_min : lmin(map(lambda([u], part(u, 2, 2)), v_pos)),
    v_pos : map(
      lambda([u],
        [part(u, 1),
         [2*(part(u, 2, 1) - (x_min+x_max)/2)/(x_max-x_min),
          2*(part(u, 2, 2) - (y_min+y_max)/2)/(y_max-y_min)]]),
      v_pos),

    /* Setup edge positions */
    for e in edges(G) do (
      if directed=true then block(
        [p1 : assoc(e[1], v_pos), p2 : assoc(e[2], v_pos)],
        edges : cons(vector(p1, p2-p1), edges))
      else
        edges : cons(points([assoc(e[1], v_pos), assoc(e[2], v_pos)]), edges)),
    for e in show_edges do (
      if directed=true then block(
        [p1 : assoc(e[1], v_pos), p2 : assoc(e[2], v_pos)],
        edges1 : cons(vector(p1, p2-p1), edges1))
      else
        edges1: cons(points([assoc(e[1], v_pos), assoc(e[2], v_pos)]), edges1)),


    /* Setup vertex positions */
    for v in vertices(G) do
      if not(member(v, show_vertices)) then
        vertices : cons(assoc(v, v_pos), vertices),
    if length(vertices) > 0 then vertices : [points(vertices)],
    for v in show_vertices do (
      vertices1 : cons(assoc(v, v_pos), vertices1)),
    if length(vertices1) > 0 then vertices1 : [points(vertices1)],

    /* Setup vertex labels or ids */
    if show_id=true then (
      for v in vertices(G) do block(
        [p : assoc(v, v_pos)],
        vertex_labels : cons([concat(label_padding, v, label_padding), p[1], p[2]], vertex_labels)))
    else if show_label=true then (
      for v in vertices(G) do block(
        [p : assoc(v, v_pos)],
        vertex_labels : cons([concat(label_padding,
            string(get_vertex_label(v, G)), label_padding), p[1], p[2]],
          vertex_labels))),
    if length(vertex_labels) > 0 then
      vertex_labels : [apply(label, vertex_labels)],

    /* Setup edge wieghts */
    if show_weight=true then (
      for e in edges(G) do block(
        [p1 : assoc(e[1], v_pos), p2 : assoc(e[2], v_pos)],
        edge_weights : cons([concat(get_edge_weight(e, G)),
          (2*p1[1]+p2[1])/3, (2*p1[2]+p2[2])/3], edge_weights))),
    if length(edge_weights) > 0 then
      edge_weights : [apply(label, edge_weights)],

    /* Check if we are in wxmaxima */
    if terminal='wxmaxima then command : wxdraw2d else command : draw2d,
    
    if terminal#'wxmaxima then
      gp_options : ['terminal = terminal, 'file_name = file_name]
    else gp_options : [],

    /* plot the graph */
    apply(command, append(
       [
        'color = edge_color,
        'point_type = 0,
        'line_type = edge_type,
        'line_width = edge_width,
        'points_joined = true,
        'head_length = head_length,
        'head_angle = head_angle
       ],
        edges,
       [
        'color = show_edge_color,
        'line_width = show_edge_width,
        'line_type = show_edge_type
       ],
        edges1,
       [
        'points_joined = false,
        'point_size = vertex_size,
        'point_type = vertex_type,
        'color = vertex_color
       ],
        vertices,
       [
        'color = show_vertex_color,
        'point_size = show_vertex_size,
        'point_type = show_vertex_type
       ],
        vertices1,
       [
        'color = text_color,
        'label_alignment = label_alignment
       ],
        vertex_labels,
        edge_weights,
       [
        'axis_top = false,
        'axis_bottom = false,
        'axis_left = false,
        'axis_right = false,
        'ytics = false,
        'xtics = false
       ],
        gp_options)
      )),
    'done)$

vertices_to_path(lst) := block(
  [path : []],

  while length(lst)>1 do (
    path : cons([lst[1], lst[2]], path),
    lst : rest(lst)),
  
  path)$

vertices_to_cycle(lst) := vertices_to_path(append(lst, [first(lst)]))$
