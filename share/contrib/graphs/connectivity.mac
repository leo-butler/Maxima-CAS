/*  
  GRAPHS - graph theory package for Maxima
  Copyright (C) 2008 Andrej Vodopivec <andrej.vodopivec@gmail.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or	 
  (at your option) any later version. 

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

*/


edge_connectivity_graph(g) := block(
  [edges : edges(g), vertices : vertices(g), dg, dedges],
  dedges : append(edges, map(reverse, edges)),
  dedges : map(lambda([u], [u, 1]), dedges),
  create_graph(vertices, dedges, directed=true))$

edge_connectivity(g) := block(
  [vertices, dg],
  if not is_graph(g) then error("Argument to `edge_connectivity' is not a graph."),
  if not is_connected(g) then error("Argument to `edge_connectivity' is not a connected graph."),
  vertices : vertices(g),
  dg : edge_connectivity_graph(g),
  lmin(makelist(first(max_flow(dg, first(vertices), u)), u, rest(vertices))))$

min_edge_cut(g) := block(
  [vertices, dg, v, mf : [inf, false], mf1, g1, edges:[], s, t, tr],
  if not is_graph(g) then error("Argument to `min_edge_cut' is not a graph."),
  if not is_connected(g) then error("Argument to `min_edge_cut' is not a connected graph."),
  vertices : vertices(g),
  v : first(vertices),
  s : v,
  dg : edge_connectivity_graph(g),
  for u in rest(vertices) do (
    mf1 : max_flow(dg, v, u),
    if mf1[1]<mf[1] then (
      mf:mf1,
      t : u)),
  for e in edges(g) do
    if assoc(e, mf[2])=0 and assoc(reverse(e), mf[2])=0 then edges : cons(e, edges),
  g1 : create_graph(vertices, edges),
  tr : reachable_vertices(t, g1),
  sublist(edges(g), lambda([e], is(member(e[1], tr) and not member(e[2], tr)) or
                                is(member(e[2], tr) and not member(e[1], tr)))))$
