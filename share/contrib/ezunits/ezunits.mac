infix ("`", 118, 118);
/* Hold off on this display symbol business.
 * :lisp (put '$\` '(#\space #\space) 'dissym)
 */

declare (dimensional, feature);

declare_units (a%, u%) :=
  block (local (a%, u%), 
  if listp(a%)
    then map (lambda ([a1%], local(a1%), declare1_units (a1%, u%)), a%)
    else declare1_units (a%, u%), u%);

declare1_units (a%, u%) :=
  block (local (a%, u%),
  apply ('define_variable, [a%, a%, any_check]),
  put (a%, units_check (a%), value_check),
  put (a%, u%, units),
  if featurep (a%, 'dimensional) = false
    then apply (declare, [a%, 'dimensional]));

declare_qty (a%, q%) :=
  block (local (a%, q%),
  if listp(a%)
    then map (lambda ([a1%], local(a1%), declare1_qty (a1%, q%)), a%)
    else declare1_qty (a%, q%), q%);

/* Maybe we want to work with numerval in declare1_qty
 * (instead of the indicator qty).
 */
declare1_qty (a%, q%) :=
  block (local (a%, q%),
  if featurep (a%, 'dimensional) = false
    then apply (declare, [a%, 'dimensional]), put (a%, q%, qty));

units_check (zz%) :=
  block (local (zz%),
  buildq ([zz%: zz%], lambda([yy%],
    if units('zz%) # 1 and units(yy%) # 1 and units(yy%) # units('zz%)
    then throw (oops ('zz%, yy%)))));

qty(e%) :=
  block (local (e%),
  if atom(e%) then
    if featurep (e%, 'dimensional) then
      if get (e%, qty) = false then 'qty(e%) else get (e%, qty)
    else e%
  else if unitop_p(e%) then first(e%)
  else if featurep (op(e%), 'dimensional) then 'qty(e%)
  else apply (op(e%), map (qty, args(e%))));

units(e%) :=
  block (local (e%),
  if atom(e%) then 
    if featurep (e%, 'dimensional) then
      if get (e%, units) = false then 'units(e%) else get (e%, units)
    else 1
  else if mapatom (e%) then units (op (e%))  /* mapatom but not atom => subscripted */
  else if unitop_p(e%) then second(e%)
  else if featurep (op(e%), 'dimensional) then units(op(e%))
  else apply (op(e%), map (units, args(e%))));

d(e%) := dimension (units (e%));

matchdeclare
  ([aa%, bb%], true,
    cc%, constantp,
    ccn0%, constantp_not0,
    ccn1%, constantp_not1,
    mm%, mult_expr_nontrivialconstfactorsp,
    nd%, nondimensional,
    uu%, unitp,
    xx%, nonconstantp);

simp: false$
tellsimpafter (uu% ` nd%, convert_units [units(uu%), nd%] (qty(uu%)) ` nd%);
tellsimpafter (uu%^ccn1%, (qty(uu%)^ccn1%) ` simplify_units (units(uu%)^ccn1%));
tellsimpafter (nd% * uu%, multiply_with_units (nd%, uu%));
tellsimpafter (nd% + uu%, add_with_units (nd%, uu%));

/* The first ` rule here is a work-around for the behavior of the function 
 * automatically generated by tellsimpafter: in a pure simplification 
 * environment (i.e. no evaluation, e.g. expected result in test scripts)
 * the arguments are never simplified if they do not match any rule.
 * That is unlike simplification in general, in which the arguments are
 * simplified even if there is no rule for the operator and the arguments together.
 */
tellsimpafter (aa% ` bb%, ?resimplify (aa%) ` ?resimplify (bb%));

tellsimpafter (aa% ` (xx% + ccn0%), (aa% - ccn0%)`xx%);
tellsimpafter (aa% ` mm%, (constant_factors(mm%) * aa%) ` everything_else(mm%));
tellsimpafter (aa% ` cc%, aa%*cc%);
simp: true$

unitop_p (e%) := atom (op(e%)) and is (nounify (op(e%)) = nounify ("`"));
unitp (e%) :=
  if atom(e%) then featurep (e%, 'dimensional)
  else if unitop_p (e%) then true
  else featurep (op(e%), 'dimensional);

constantp_not1 (x%) := constantp(x%) and x% # 1;
constantp_not0 (x%) := constantp(x%) and x% # 0;
nonconstantp (x%) := not constantp (x%);
mult_exprp (e%) := not atom(e%) and atom (op(e%)) and (nounify (op(e%)) = nounify ("*") or nounify (op(e%)) = nounify ("/"));
mult_expr_nontrivialconstfactorsp (e%) := mult_exprp (e%) and constant_factors (e%) # 1;
nondimensional (e%) := atom(e%) or (op(e%) # "`" and apply ("and", map (nondimensional, args(e%))));
nondimensional_not1 (e%) := e% # 1 and nondimensional (e%);
nondimensional_not0 (e%) := e% # 0 and nondimensional (e%);

add_with_units (x%, u%) :=
  if unitp (u%) then
    x% + u%
  else
    /* identify terms with like units and add them up. */
    block ([r%: [], a%: args(u%)],
    while a% # [] do
      block ([s%: qty(a%[1]), b%: []],
      for i%:2 thru length(a%) do
        if units (a%[i%]) = units (a%[1]) then
          s%: s% + qty (a%[i%])
        else
          b%: cons (a%[i%], b%),
      r%: cons (s%`units(a%[1]), r%),
      a%: b%),
    if length (r%) = 1 then
      x% + r%[1]
    else
      cons (x%, apply ("+", r%)));
      
multiply_with_units(x%, u%) :=
  if unitp (u%) then
    (x%*qty(u%))`units(u%)
  else
    (x%*apply ("*", map (qty, args (u%)))) ` simplify_units (apply ("*", map (units, args (u%))));

constant_factors (e%) := block ([L%, eqns%], L%: listofvars(e%), eqns%: map ("=", L%, L%*0+1), subst (eqns%, e%));

everything_else(e%) := e%/constant_factors(e%);

simplify_units (e%) := block
  ([L% : listofvars (e%)],
    L% : makelist (x% > 0, x%, L%),
    apply (assume, L%),
    e% : expand (e%, 0, 0),
    apply (forget, L%),
    e%);

/* Compile matchdeclare predicate functions in hopes of greater speed */
compile (constantp_not0, constantp_not1, mult_expr_nontrivialconstfactorsp, nondimensional, unitp, nonconstantp);

/* A small database of elementary unit conversions */

/* Undefined and therefore treated as basic units:
 *
 * m kg s A K mol
 *
 */

known_unit_conversions : 
   [

    /* SI derived units */

    km = 1000*m,
    cm = m/100,
    mm = m/1000,
    micron = m/1000000,

    kg = 1000*g,

    l = m^3/1000,

    Hz = 1/s,           /* hertz:   Frequency            */
    N = kg*m/s^2,       /* newton:  Force                */
    Pa = N/m^2,         /* pascal:  Pressure             */
    J = N*m,            /* joule:   Work, energy         */
    W = J/s,            /* watt:    Power                */
    C = s*A,            /* coulomb: Electric charge      */
    V = J/C,            /* volt:    Electromotive force  */
    F = C^2/J,          /* farad:   Electric capacitance */
    Ohm = J*s/C^2,      /* ohm:     Electric resistance  */
    S = 1/Ohm,          /* siemens: Electric conductance */
    Wb = J/A,           /* weber:   Magnetic flux        */
    T = J/m^2/A,        /* tesla:   Magnetic flux density*/
    H = J/A^2,          /* henry:   Inductance           */

    /* "English" units --> SI */

    ft = m/(328083/100000),
    lbm = kg/(2205/1000),
    min = 60*s,
    Btu = 1055*J,
    R = 5/9*K,
    gallon = (3785/1000)*l,

    /* "English" --> "English" */

    in = ft/12,
    yd = 3*ft,
    mi = 5280*ft,
    /* slug = ???, */
    oz = lbm/16,
    /* grain = ???, */
    h = 60*min,
    d = 24*h,
    lbf = lbm*32*ft/s^2,
    acre = 55*88*yd^2,
    psi = lbf/in^2,
    cfm = ft^3/min

   ];

declare_unit_conversion ([L]) := (known_unit_conversions : append (known_unit_conversions, L), done);

compute_conversion_factor (u1%, u2%) := block ([e%],
  e% : cons (%%a = u1% / u2%, known_unit_conversions),
  block ([logexpand : all], map (lambda ([e], map (log, e)), e%)),
  linsolve (%%, map (lhs, %%)),
  exp (rhs (first (%%))));
  
convert_units [u1%, u2%] := block ([a%],
  a% : compute_conversion_factor (u1%, u2%),
  if constantp (a%)
    then buildq ([a%], lambda ([x], a% * x))
    else buildq ([u1%], lambda ([x], x ` u1%)));

convert_units [degF, degC] : lambda ([x], 5/9*(x - 32));
convert_units [degC, degF] : lambda ([x], 32 + 9/5*x);
convert_units [degC, K] : lambda ([x], 27315/100 + x);
convert_units [degF, R] : lambda ([x], 45967/100 + x);
convert_units [K, degC] : lambda ([x], x - 27315/100);
convert_units [R, degF] : lambda ([x], x - 45967/100);
