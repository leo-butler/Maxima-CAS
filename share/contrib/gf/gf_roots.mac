 /* ------------------------ */ 
 /* Roots in finite fields   */
 /* Coded by Jacopo Daurizio */

/* Released under terms of the GNU General Public License, version 2,
 * by permission of the author to Robert Dodier 2007-12-02.
 */

 /* ------------------------------------------- */
 /*  Some number theoretic subroutines for F_p  */
 /* ------------------------------------------- */
 
 
 /* Fast exponentiation in F_p                   */
 /* Returns an integer t in [0,p-1] such that    */
 /* t = a^m (mod p)                              */
 
 fastpower(a,m,p):=block([i,j,k,t:1,index],
 if m=0 then return(1),
 if m=1 then return(polymod(a,p)),
 j:?integer\-length(m), 
 for i:1 thru j do (if ?logbitp(j-i,m) then t:polymod(a*polymod(t*t,p),p) else t:polymod(t*t,p)),
 return(mod(t,p))
 )$ 
 
 /* Fast polynomial powers in F_char/(q)         */
 /* Implicit use of Karatsuba algorithm          */
 /* through "fasttimes"                          */ 
 
 polypower(p,n,q,char):=block([b,t:rat(1),i],
  b:?integer\-length(n), p:rat(p), q:rat(q),
  modulus:char,
  for i:1 thru b do (
    t:remainder(fasttimes(t,t),q),
    if ?logbitp(b-i,n) then t:remainder(fasttimes(p,t),q)
    ),
  modulus:false,
  return(t)
  )$
 
  /* Fast exponentiation of the Frobenius (companion) matrix       */
  /*     (0  0  -a)   corresponding to the linear map              */
  /* F = (1  0  -b)   p(x) -> x*p(x) (mod x^3+bx+a)                */
  /*     (0  1   0)   It uses only 3 parameters (F_22,F_23,F_32)   */
  /* that are sufficient to completely describe F^j for any j;     */
  /* it returns (F^m)_22, corresponding to the evaluation of       */
  /*                  x^m (mod x^3+bx+a)                           */
  /* in x=0.                                                       */
 
  f3power(a,b,p,m):=block([v_22:1,v_23:0,v_32:0,
                          w_22:1,w_23:0,w_32:0,
                          c,i,j,k,l,n,index],
  if m=0 then return(1),
  b:polymod(b,p),a:polymod(a,p),c:inv_mod(-a,p),
  j:?integer\-length(m),
  for i:1 thru j do (
    k:polymod(v_23+b*v_32,p), l:polymod(?ash(v_22,1),p), 
    if ?logbitp(j-i,m)  then (
                                 n : polymod(a*v_32,p),
                                 w_22 : polymod(l*v_23-n*v_32,p),
                                 w_32 : polymod(v_32*(k+v_23)+v_22*v_22,p),
                                 w_23 : polymod(k*k-l*n-b*w_32,p)
                              )
    else (
           w_22 : polymod(v_32*(k+v_23)+v_22*v_22,p),
           w_23 : polymod(l*v_23-a*v_32*v_32,p),
           w_32 : polymod(l*v_32+c*k*k,p)
          ),
    v_22:w_22,
    v_23:w_23,
    v_32:w_32
    ),
  return(v_22)
  )$ 
 
  
  /* This subroutine returns (1 0) A^(m) (1 0) mod p, where     */
  /*          ( 0  -a )                                         */
  /*     A =  ( 1  -b )                                         */
  /* i.e the m-th term of the recurrence                        */
  /* A_0 = 1, A_1 = 0, A_{n+2} = -b A_{n+1} - a A_{n}           */
  /* with characteristic polynomial x^2 + b x + a               */
  
  f2power(a,b,p,m):=block([v_11:0,v_21:1,w_11,w_21,u,v,i,index],
   /* if m<2 then return(1-m),       */
   /* b:polymod(b,p),a:polymod(a,p), */
   index:?integer\-length(m),
   for i:2 thru index do (
    if  ?logbitp(index-i,m) then ( u:-a*v_21, v:v_11-b*v_21,
                                   w_11: polymod(u*(v+v_11),p),
                                   w_21: polymod(v*v+v_21*u,p)
                        )    
    else (u:v_11*v_11, v:v_21*v_21,
          w_11: polymod(u-a*v,p),
          w_21: polymod((v_11+v_21)^2-(u+(b+1)*v),p)
          ),
    v_11:w_11,
    v_21:w_21
    ),
   return(mod(v_11,p))
   )$
 
 /* Stickelberger-Redei irreducibility test for cubic polynomial f(x)=x^3+bx+a        */
 /* f(x) is irreducible over F_p iff its discriminant D=-4b^3-27a^2                   */
 /* is a quadratic residue AND 2*(sqrt(D)+sqrt(-27a^2))^2 is NOT a cubic residue.     */
 
 redei(a,b,p,ome,p3):=block([d,g,y,r],
 d:polymod(-4*b^3-27*a^2,p),
 if jacobi(d,p)#1 then return(false),
 g:polymod(msqrt(d,p)[1]+3*a*ome,p),
 y:polymod(?ash(g*g,1),p),
 r:fastpower(y,p3,p),
 if mod(r,p)=1 then return(false) else return(true)                         
 )$
 
 /* For VERY large p, it might be useful to factor (p-1) into prime factors */
 /* (p-1) = 2^(a_1) 3^(a_2) ... q_l^(a_l)                                   */
 /* then use a factor-addition-chain instead of the binary one:             */
 /* r:y, for i:l downto 1 do (                                              */
 /*                   r:polymod(fastpower(r,q_l^(a_l),p),p),                */
 /*                   if r=1 then return(false)                             */
 /*                        ), if r=1 then return(true) else return(false)   */
 /* to have great chances to shorten the cubic-residue test.                */




 /* If a is a quadratic residue in F_p, this routine returns    */
 /* two integers in [0, p-1] such that their squares            */
 /* are congruent to a (mod p).                                 */
 /*                                                             */
 /* If b^2-4a is a quadratic non-residue mod p, the polynomial  */
 /* x^2 - bx + a                                                */
 /* has two roots in F_(p^2) = (Z/pZ[x])/(x^2-bx+a)             */
 /* the former being the Frobenius conjugate of the latter      */
 /* y = y^p                                                     */
 /* so that sqrt(a)=y^((p+1)/2) for Viete's theorem.            */
 /* The point is to compute                                     */
 /* mu = (b/2 + sqrt(b^2-4a)/2)^((p+1)/2) = J + K sqrt(b^2-4a)  */
 /* in a fast way. We notes that if a is a quadratic residue    */
 /* mu can't be a proper element of the field extension         */
 /* F_p (sqrt(b^2-4a))                                          */
 /* so we must have K=0, or, in the same way,                   */
 /* mu = (1/2) { (b/2 + sqrt(delta)/2)^((p+1)/2)                */
 /*             +(b/2 - sqrt(delta)/2)^((p+1)/2 }               */
 /* that is the (p+1)/2-th term of the sequence                 */
 /* A_0 = 1,  A_1 = b/2,  A_{n+2}=b*A_{n+1}-a*A_{n}             */
 /* All we need is the (p+1)/2-power of the matrix              */
 /*       ( b  -a )                                             */
 /*   A = ( 1   0 )    over Z/pZ                                */
 /* The subroutine "mpower" returns it with about 8 log(p)      */
 /* multiplications and 4 log(p) mod-reductions in Z/pZ,        */
 /* using the standard "repeat-squaring" algorithm.             */
 
 /* Field extension algorithm for square-root extraction through companion matrix powers */
 /* returns two integers in [0,p-1] whose square are congruent to a (mod p)              */
 
 msqrt(a,p):=block([b:0,term,nrflag:false],
 if (mod(a,p)=0) then return([0,0]),
 /*    if not(primep(p)) then error("ERROR: Second argument must be a prime number."),   */
 if jacobi(a,p)#1 then error("ERROR: First argument must be a quadratic residue."),
 if p=2 then return(mod(a,2)),
 while not(nrflag) do (b:b+1, if jacobi(b*b-4*a,p)=-1 then nrflag:true),
 /*print(b,"^2 - 4*",a," is a quadratic non-residue"),*/
 term:mod(f2power(a,b,p,?ash(p+1,-1)),p),
 return([term,p-term]) 
 )$
 
 /* Shank's algorithm for square-root extraction                                         */
 /* returns two integers in [0,p-1] whose square are congruent to a (mod p)              */
 
 ssqrt(a,p):=block([i,j,nrflag:false,b:0,s:0,t,q:p-1,alpha,r,d],
 if (mod(a,p)=0) then return([0,0]),
 /*    if not(primep(p)) then error("ERROR: Second argument must be a prime number."),   */
 if jacobi(a,p)#1 then error("ERROR: First argument must be a quadratic residue."),
 if p=2 then return(mod(a,2)),
 while not(nrflag) do (b:b+1, if jacobi(b,p)=-1 then nrflag:true),
 while not(?logbitp(0,q)) do (s:s+1, q:?ash(q,-1)),
 t:q, alpha:inv_mod(a,p), c:fastpower(b,t,p), r:fastpower(a,?ash((t+1),-1),p),
 for i:1 thru s-1 do (
 d:polymod(polymod(r*r,p)*alpha,p), for j:1 thru (s-i-1) do d:polymod(d*d,p),
 if polymod(d+1,p)=0 then r:polymod(r*c,p),
 c:polymod(c*c,p) 
 ),
 r:mod(r,p),
 return([r,p-r])
 )$
 
 /* Field extension algorithm for cubic-root extraction        */
 /* For a cubic residue a and a prime p=1(mod 3) mcbrt finds   */
 /* an irreducible polynomial of the form x^3+bx+a over F_p    */
 /* so that -a=x^(p^2+p+1) and returns x^((p^2+p+1)/3)         */
 /* computed over F_(p^3) = (F_p)/(x^3+bx+a)                   */
 /* This subroutine returns three integers in [0,p-1]          */
 /* whose third-power are congruent to a (mod p)               */
 
 scbrt(a,p):=block([b:1,term,h1,h2,h3,q,c,c_1,c_2,om,omega_1,p3],
 if (mod(a,p)=0) then return(0),
 /*if not(primep(p)) then error("ERROR: Second argument must be a prime number."),*/
 if p=2 then return(mod(a,2)),
 if mod(p,3)=2 then return(fastpower(a,(?ash(p,1)-1)/3,p)),
 om:msqrt(-3,p), p3:(p-1)/3,
 if fastpower(a,p3,p)#1 then error("ERROR: First argument must be a cubic residue."),
 while not(redei(a,b,p,om[1],p3)) do b:b+1,
 q:x^3+b*x+a,
 h1:polypower(x,p,q,p),
 h2:polypower(h1,p3,q,p),
 h3:polypower(x,(?ash(p,1)+1)/3,q,p),
 c:polymod(-remainder(h2*h3,q),p),
 c:mod(c,p),
 omega_1:mod((-1+om[1])*(?ash(p+1,-1)),p),
 c_1:mod(omega_1*c,p),
 c_2:mod(-c-c_1,p),
 return([c,c_1,c_2])
 )$

 /* Field extension algorithm for cubic-root extraction                     */
 /* through companion matrix powers. This subroutine returns three integers */
 /* in [0,p-1] whose third-power are congruent to a (mod p)                 */
 
 mcbrt(a,p):=block([b:1,c,c_1,c_2,om,omega_1,p3],
 if (mod(a,p)=0) then return(0),
 /*if not(primep(p)) then error("ERROR: Second argument must be a prime number."),*/
 if p=2 then return(mod(a,2)),
 if mod(p,3)=2 then return(fastpower(a,(?ash(p,1)-1)/3,p)),
 om:msqrt(-3,p), p3:(p-1)/3,
 if fastpower(a,p3,p)#1 then error("ERROR: First argument must be a cubic residue."),
 while not(redei(a,b,p,om[1],p3)) do b:b+1,
 c:mod(-f3power(a,b,p,(1+p*(p+1))/3),p),
 omega_1:mod((-1+om[1])*(?ash(p+1,-1)),p),
 c_1:mod(omega_1*c,p),
 c_2:mod(-c-c_1,p),
 return([c,c_1,c_2])
 )$
 
 /* For each prime p in the form 4k+1 we find two positive integers  */
 /* a and b such that p=a^2+b^2. Useful to extend a Z-factorization  */
 /* into a Z[i]-factorization (order of Gaussian integers)           */
 
 qsplit(p):=block([m,a,b:1,c,d,e,f,k,j],
 if (p=2) then return([1,1]),
 m:msqrt(-1,p),
 if (m[1] < m[2]) then a:m[1] else a:m[2],
 k:(a^2+1)/p,
 while (k>1) do (
                 k:(a^2+b^2)/p,   
                 c:polymod(a,k),
                 d:polymod(b,k),
                 j:(c^2+d^2)/k,
                 e:(a*c+b*d)/k,
                 f:(b*c-a*d)/k,
                 a:abs(e),
                 b:abs(f),
                 k:j
                 ),
 return([a,b])
 )$         
 
 
 /* For each prime p in the form 3k+1 we find two positive integers     */
 /* a and b such that p=a^2+ab+b^2. Useful to extend a Z-factorization  */
 /* into a Z[omega]-factorization (order of Eisenstein integers)        */
 
 csplit(p):=block([m,a,b,c,d,t,x,y],
 if (p=3) then return([1,1]),
 m:msqrt(-3,p),
 if (mod(m[1],2)=0) then b:m[2] else b:m[1],
 a:(b^2+3)/(4*p), c:p, x:0, y:1,
 while (b#1) do (
                 if (a>c) then (d:a, a:c, c:d, b:-b, d:x, x:-y, y:d),
                 t:floor(b/?ash(a,1)), b:b-?ash(a*t,1), c:c-t*(b+a*t), x:x+t*y
                 ),
  if (x<0) then if (y<-x) then x:-(x+y) else (x:-x,y:y-x), 
  if (y<0) then if (x<-y) then y:-(x+y) else (y:-y,x:x-y), 
 return([x,y])
 );
