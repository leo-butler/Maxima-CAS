/*               COPYRIGHT NOTICE

Copyright (C) 2005-2006 Mario Rodriguez Riotorto

This program is free software; you can redistribute
it and/or modify it under the terms of the
GNU General Public License as published by
the Free Software Foundation; either version 2 
of the License, or (at your option) any later version. 

This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details at
http://www.gnu.org/copyleft/gpl.html
*/


/*             INTRODUCTION

This is a set of Maxima functions for univariate probability distributions,
both continuous and discrete.

Continuous distributions:                Discrete distributions:
   Normal              (*normal)            Binomial             (*binomial)
   Student             (*student)           Poisson              (*poisson)
   Chi^2               (*chi2)              Bernoulli            (*bernoulli)
   F                   (*f)                 Geometric            (*geo)
   Exponential         (*exp)               Discrete uniform     (*discu)
   Lognormal           (*logn)              Hypergeometric       (*hypergeo)
   Gamma               (*gamma)             Negative binomial    (*negbinom)
   Beta                (*beta)
   Continuous uniform  (*contu)
   Logistic            (*log)
   Pareto              (*pareto)
   Weibull             (*weibull)
   Rayleigh            (*rayleigh)
   Laplace             (*laplace)
   Cauchy              (*cauchy)
   Gumbel              (*gumbel)

Functions:
   Density function            (den*)
   Distribution function       (dis*)
   Quantile                    (q*)
   Mean                        (mean*)
   Variance                    (var*)
   Standard deviation          (std*)
   Skewness coefficient        (skw*)
   Kurtosis coefficient        (kur*)
   Random variate              (r*)

For example,
   denstudent(x,n) is the density function of the Student distribution
                   with n degrees of freedom
   stdpareto(a,b)  is the standard deviation of the Pareto distribution
                   with parameters a and b
   kurpoisson(m)   is the kurtosis coefficient of the Poisson distribution
                   with mean m

Note: the Cauchy model has no moments, in this case only the density and
      the distribution functions, 'dencauchy' and 'discauchy', are defined.

   
Code tested with Maxima 5.9.2

For questions, suggestions, bugs and the like, feel free
to contact me at

mario @@@ edu DOT xunta DOT es
www.biomates.net

2005, march: first release
2005, july: minor corrections
2005, august: more minor corrections; denhypergeo, which was not in previous versions;
      documentation in english (distrib_en.tex).
2005, september: quantile functions.
2005, november: functions 'floor' and 'ceiling' removed.
2006, january: numerical algorithms ported to lisp (numdistrib.lisp); added random generators;
      bug fixing in meanpareto, varpareto, stdpareto, skwpareto, kurpareto and some others. 
      The documentation has been rewritten in texi format (distrib.texi)
2006, january: some code cleaning in rcauchy (compiling problems with tan(3.1415), now tan(float(%pi))),
      denlogn, dislogn, dencontu and rdiscu.
2006, january: some corrections so that with float arguments functions give float results
*/

/* Sets the random state according to the computer clock time */
set_random_state(make_random_state(true))$


/* Loads numerical routines */
load("numdistrib.lisp")$


/*         SOME AUXILIARY FUNCTIONS          */


/* If a is positive, the function returns 1. If it is zero or
   negative, it returns -1. If there is not enough information, 
   the output is 0 */
control1(a):=
   if member(sign(a), ['nz,'neg,'zero])
      then -1
      else if sign(a)='pos
              then 1
              else 0 $

/* If both a and b are positive, the function returns 1. If one
   of them is zero or negative, it returns -1. If there is not enough
   information, the output is 0 */
control2(a,b):=
   if member(sign(a), ['nz,'neg,'zero]) or member(sign(b), ['nz,'neg,'zero])
      then -1
      else if sign(a)='pos and sign(b)='pos
              then 1
              else 0 $

/* If 0<p<1 the function returns 1. If p is outside this interval,
   it returns -1. If there is not enough information, the output is 0 */
controlp(p):=
   if member(sign(p), ['nz,'neg,'zero]) or member(sign(1-p), ['nz,'neg,'zero])
      then -1
      else if sign(p)='pos and sign(1-p)='pos
              then 1
              else 0 $

/* If 0<=p<=1 the function returns 1. If p is outside this interval,
   it returns -1. If there is not enough information, the output is 0 */
controlq(p):=
   if member(sign(p), ['nz,'neg]) or member(sign(1-p), ['nz,'neg])
      then -1
      else if member(sign(p), ['zero,'pos,'pz]) and member(sign(1-p), ['zero,'pos,'pz])
              then 1
              else 0 $

/* If 0<p<1 and n is a positive integer the function returns 1. If p is
   outside this interval or n is not a positive integer, it returns -1.
   If there is not enough information, the output is 0 */
controlip(n,p):=
   if sign(p)='pos and sign(1-p)='pos and
      integerp(n) and sign(n)='pos
      then 1
      else if member(sign(n), ['nz,'neg,'zero]) or
              numberp(n) and not integerp(n) or
              member(sign(p), ['nz,'neg,'zero]) or
              member(sign(1-p), ['nz,'neg,'zero])
              then -1
              else 0  $

/* If n is a positive integer the function returns 1. If n is non 
   positive or non integer, it returns -1. If there is not enough
   information, the output is 0*/
controli(n):=
   if integerp(n) and sign(n-1)='pos
      then 1
      else if member(sign(n-1), ['nz,'neg,'zero]) or
              numberp(n) and not integerp(n)
              then -1
              else 0 $

/* If n is a non negative integer the function returns 1. If n is
   negative or non integer, it returns -1. If there is not enough
   information, the output is 0*/
controlib(n):=
   if integerp(n) and member(sign(n),['pos,'zero])
      then 1
      else if member(sign(n), ['nz,'neg]) or
              numberp(n) and not integerp(n)
              then -1
              else 0 $

/* If n1, n2 and n are all three positive integers, it returns 1.
   It at least one of them is not a positive integer, the 
   function returns -1. If there is not enough informations, the
   output is 0 */
controliii(n1,n2,n):=block([t:n1+n2],
   if integerp(n1) and sign(n1)='pos and
      integerp(n2) and sign(n2)='pos and
      integerp(n) and sign(n)='pos and
      member(sign(t-n),['pos,'zero,'pz])
      then 1
      else if numberp(n1) and not integerp(n1) or
              numberp(n2) and not integerp(n2) or
              numberp(n) and not integerp(n) or 
              member(sign(n),['neg,'zero,'nz]) or sign(t-n)='neg
              then -1
              else 0  )$


/*         NORMAL (OR GAUSSIAN) DISTRIBUTION          */



dennormal(x,m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dennormal,[x,m,s])),
   exp(-(x-m)^2/(2*s^2))/(sqrt(2*%pi)*s)  )$

disnormal(x,m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disnormal,[x,m,s])),
   1/2+erf((x-m)/(s*sqrt(2)))/2  )$

qnormal(q,m,s):=block([cp:control1(s), fq:float(q), cq:controlq(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qnormal,[q,m,s])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   if numberp(q) and numberp(m) and numberp(s) and
      (numer or ?floatp(q) or ?floatp(m) or ?floatp(s))
      then return(m + s * ?ppnd16(fq)),
   funmake('qnormal,[q,m,s]))$

meannormal(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meannormal,[m,s])),
   m  )$

varnormal(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varnormal,[m,s])),
   s^2  )$

stdnormal(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdnormal,[m,s])),
   s  )$

skwnormal(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwnormal,[m,s])),
   0  )$

kurnormal(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurnormal,[m,s])),
   0  )$

/* Implemented algorithms: box_mueller, inverse.
   More info in numdistrib.lisp */
rnormal(m,s,[num]):=block([cp:control1(s),cn,no],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rnormal,append([m,s],num))),
   m + s * ?rndnormal(no) )$



/*         STUDENT DISTRIBUTION          */



denstudent(x,n):=block([cp:control1(n),fn,fx],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denstudent,[x,n])),
   gamma((n+1)/2) * (1+x*x/n)^(-(n+1)/2) / (sqrt(n*%pi) * gamma(n/2)) )$

/* R: pt(x,n) */
disstudent(x,n):=block([cp:control1(n),fn,fx],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disstudent,[x,n])),
   if sign(x)='zero then return(1/2),
   if numberp(x) and numberp(n) and 
      (numer or ?floatp(x) or ?floatp(n))
      then (fn: float(n),
            fx: float(x),
            if x>0
              then return(1.0 - ?ibeta(fn/(fn+fx*fx),fn/2,0.5) / 2)
              else return(?ibeta(fn/(fn+fx*fx),fn/2,0.5) / 2)  ),
   funmake('disstudent,[x,n]) )$

/* R: qt(q,n) */
qstudent(q,n):=block([cp:control1(n), cq:controlq(q), fq:float(q), aux, sgn],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qstudent,[q,n])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   if fq=0.5 then return(0),
   if numberp(q) and numberp(n) and
      (numer or ?floatp(q) or ?floatp(n))
      then(if fq<0.5
              then (aux : 2*fq,
                    sgn : -1)
              else (aux : 2*(1-fq),
                    sgn : 1),
           sgn*sqrt(n*(1 / ?iibeta(aux,float(n/2),0.5)-1))  )
      else funmake('qstudent,[q,n]) )$

meanstudent(n):=block([cp:control1(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanstudent,[n])),
   0  )$

varstudent(n):=block([cp:control1(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varstudent,[n])),
   if sign(n-2)='pos
      then return(n / (n-2))
      else if member(sign(n-2),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('varstudent,[n])  )$

stdstudent(n):=block([cp:control1(n-2)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdstudent,[n])),
   sqrt(n / (n-2))  )$

skwstudent(n):=block([cp:control1(n-3)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwstudent,[n])),
   0  )$

kurstudent(n):=block([cp:control1(n-4)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurstudent,[n])),
   6/(n-4)  )$

/* Implemented algorithms: ratio, inverse.
   More info in numdistrib.lisp */
rstudent(n,[num]):=block([cp:control1(n),cn,no,fn],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rstudent,append([n],num))),
   fn: float(n),
   if numberp(fn)
      then return(?rndstudent(fn,no)),
   funmake('rstudent,append([n],num)) )$


/*         CHI-SQUARE (OR PEARSON'S)  DISTRIBUTION          */
/*          chi2(n) is equivalent to gamma(n/2,2)           */



denchi2(x,n):=dengamma(x,n/2,2)$

dischi2(x,n):=disgamma(x,n/2,2)$

qchi2(q,n):=qgamma(q,n/2,2)$

meanchi2(n):=meangamma(n/2,2)$

varchi2(n):=vargamma(n/2,2)$

stdchi2(n):=stdgamma(n/2,2)$

skwchi2(n):=skwgamma(n/2,2)$

kurchi2(n):=kurgamma(n/2,2)$

/* Implemented algorithms: ahrens_cheng, inverse.
   More info in numdistrib.lisp */
rchi2(n,[num]):=block([cp:control1(n),cn,no,fn],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rchi2,append([n],num))),
   fn: float(n),
   if numberp(fn)
      then return(?rndchi2(fn,no)),
   funmake('rchi2,append([n],num)) )$



/*         F DISTRIBUTION          */



denf(x,m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denf,[x,m,n])),
   if member(sign(x), ['nz,'neg,'zero])
      then 0
      else if sign(x)='pos
              then gamma((m+n)/2)*(m/n)^(m/2)*x^(m/2-1)*(1+m*x/n)^(-(m+n)/2) /
                    (gamma(m/2)*gamma(n/2))
              else funmake('denf,[x,m,n]) )$

disf(x,m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disf,[x,m,n])),
   if member(sign(x), ['nz,'neg,'zero])
      then return(0)
      else if numberp(x) and x>0 and numberp(m) and numberp(n) and 
              (numer or ?floatp(x) or ?floatp(m) or ?floatp(n))
              then return(1-?ibeta(float(n/(n+m*x)),float(n/2),float(m/2))),
   funmake('disf,[x,m,n]) )$

/* R: qf(q,m,n) */
qf(q,m,n):=block([cp:control2(m,n), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qf,[q,m,n])),
   if fq=0.0 then return(0),
   if fq=1.0 then return('inf),
   if numberp(q) and numberp(m) and numberp(n) and
      (numer or ?floatp(q) or ?floatp(m) or ?floatp(n))
      then n * (1 / ?iibeta(1-fq, float(n/2), float(m/2)) - 1) / m
      else funmake('qf,[q,m,n]) )$

meanf(m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanf,[m,n])),
   if sign(n-2)='pos
      then return(n/(n-2))
      else if member(sign(n-2),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('meanf,[m,n])  )$

varf(m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varf,[m,n])),
   if sign(n-4)='pos
      then return(2*n*n*(m+n-2)/(m*(n-2)*(n-2)*(n-4)))
      else if member(sign(n-4),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('varf,[m,n])  )$

stdf(m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdf,[m,n])),
   if sign(n-4)='pos
      then return(sqrt(2*n*n*(m+n-2)/(m*(n-2)*(n-2)*(n-4))))
      else if member(sign(n-4),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('stdf,[m,n])  )$

skwf(m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwf,[m,n])),
   if sign(n-6)='pos
      then return((2*m+n-2)*sqrt(8*(n-4))/(sqrt(m*(m+n-2))*(n-6)))
      else if member(sign(n-6),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('skwf,[m,n])  )$

kurf(m,n):=block([cp:control2(m,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurf,[m,n])),
   if sign(n-8)='pos
      then return(12*((n-2)*(n-2)*(n-4)+m*(m+n-2)*(5*n-22)) /
                  (m*(n-6)*(n-8)*(m+n-2)))
      else if member(sign(n-8),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('kurf,[m,n])  )$


/* Implemented algorithms: ratio, inverse.
   More info in numdistrib.lisp */
rf(m,n,[num]):=block([cp:control2(m,n),cn,no,fm,fn],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rf,append([m,n],num))),
   fm: float(m),
   fn: float(n),
   if numberp(fm) and numberp(fn)
      then return(?rndf(fm,fn,no)),
   funmake('rf,append([m,n],num)) )$



/*         EXPONENTIAL DISTRIBUTION          */
/*   exp(m) equivalent to Weibull(1,1/m)     */



denexp(x,m):=denweibull(x,1,1/m)$

disexp(x,m):=disweibull(x,1,1/m)$

qexp(q,m):=qweibull(q,1,1/m)$

meanexp(m):=meanweibull(1,1/m)$

varexp(m):=varweibull(1,1/m)$

stdexp(m):=stdweibull(1,1/m)$

skwexp(m):=skwweibull(1,1/m)$

kurexp(m):=kurweibull(1,1/m)$

/* Implemented algorithms: ahrens_cheng, ahrens_dieter, inverse.
   More info in numdistrib.lisp */
rexp(m,[num]):=block([cp:control1(m),cn,no,fm],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rexp,append([m],num))),
   fm: float(m),
   if numberp(fm)
      then return(?rndexp(fm,no)),
   funmake('rexp,append([m],num)) )$



/*         LOGNORMAL DISTRIBUTION          */



denlogn(x,m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denlogn,[x,m,s])),
   if member(sign(x), ['nz,'neg,'zero])
      then 0
      else if sign(x)='pos
              then exp(-(log(x)-m)^2/(2*s^2))/(sqrt(2*%pi)*s*x)
              else funmake('denlogn,[x,m,s]) )$

dislogn(x,m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dislogn,[x,m,s])),
   if member(sign(x), ['nz,'neg,'zero])
      then 0
      else if sign(x)='pos
              then 1/2+erf((log(x)-m)/(s*sqrt(2)))/2
              else funmake('dislogn,[x,m,s])  )$

/* R: qlnorm(p,m,s)*/
qlogn(q,m,s):=block([cp:control1(s), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qlogn,[q,m,s])),
   if fq=0.0 then return(0),
   if fq=1.0 then return('inf),
   if numberp(q) and numberp(m) and numberp(s) and
      (numer or ?floatp(q) or ?floatp(m) or ?floatp(s))
      then return(exp(m + s * ?ppnd16(float(q)))),
   funmake('qlogn,[q,m,s]))$

meanlogn(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanlogn,[m,s])),
   exp(m+s^2/2)  )$

varlogn(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varlogn,[m,s])),
   exp(2*m+s^2)*(exp(s^2)-1)  )$

stdlogn(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdlogn,[m,s])),
   exp(m+s^2/2)*sqrt(exp(s^2)-1)  )$

skwlogn(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwlogn,[m,s])),
   (exp(s^2)+2)*sqrt(exp(s^2)-1)  )$

kurlogn(m,s):=block([cp:control1(s)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurlogn,[m,s])),
   exp(4*s^2)+2*exp(3*s^2)+3*exp(2*s^2)-3  )$

/* Implemented algorithms: box_mueller, inverse.
   To select the algorithm, use the global variable
   'rnormal_algorithm'.
   More info in numdistrib.lisp */
rlogn(m,s,[num]):=block([cp:control1(s),cn,no],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rlogn,append([m,s],num))),
   exp(m + s * ?rndnormal(no)) )$



/*         GAMMA DISTRIBUTION          */



dengamma(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dengamma,[x,a,b])),
   if member(sign(x), ['nz,'neg,'zero])
      then return(0)
      else if sign(x)='pos
              then return(x^(a-1)*exp(-x/b)/(b^a*gamma(a))),
   funmake('dengamma,[x,a,b]) )$

/* R: pgamma(x,a,1/b) */
disgamma(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disgamma,[x,a,b])),
   if member(sign(x), ['nz,'neg,'zero])
      then return(0)
      else if numberp(x) and numberp(a) and numberp(b) and
              (numer or ?floatp(x) or ?floatp(a) or ?floatp(b))
              then return(?igamma(float(x/b),float(a))),
   funmake('disgamma,[x,a,b])  )$

/* R: qgamma(q,a,1/b) */
qgamma(q,a,b):=block([cp:control2(a,b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qgamma,[q,a,b])),
   if fq=0.0 then return(0),
   if fq=1.0 then return('inf),
   if numberp(q) and numberp(a) and numberp(b) and
      (numer or ?floatp(q) or ?floatp(a) or ?floatp(b))
      then return(b * ?iigamma(fq, float(a))),
   funmake('qgamma,[q,a,b])  )$

meangamma(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meangamma,[a,b])),
   a*b  )$

vargamma(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('vargamma,[a,b])),
   a*b*b  )$

stdgamma(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdgamma,[a,b])),
   sqrt(a*b*b)  )$

skwgamma(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwgamma,[a,b])),
   2/sqrt(a)  )$

kurgamma(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurgamma,[a,b])),
   6/a  )$

/* Implemented algorithms: ahrens_cheng, inverse.
   More info in numdistrib.lisp */
rgamma(a,b,[num]):=block([cp:control2(a,b),cn,no,fa,fb],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rgamma,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then return(?rndgamma(fa,fb,no)),
   funmake('rgamma,append([a,b],num)) )$



/*         BETA DISTRIBUTION          */



denbeta(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denbeta,[x,a,b])),
   if member(sign(x), ['nz,'neg,'zero]) or member(sign(x-1), ['pos,'pz,'zero])
      then return(0)
      else if sign(x)='pos and sign(x-1)='neg
              then return(x^(a-1)*(1-x)^(b-1)/beta(a,b)),
   funmake('denbeta,[x,a,b]) )$

/* R: pbeta(x,a,b) */
disbeta(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disbeta,[x,a,b])),
   if member(sign(x-1), ['pos,'pz,'zero])
      then return(1)
      else if member(sign(x), ['nz,'neg,'zero])
              then return(0)
              else if numberp(x) and numberp(a) and numberp(b) and
                      (numer or ?floatp(x) or ?floatp(a) or ?floatp(b))
                      then return(?ibeta(float(x),float(a),float(b))),
   funmake('disbeta,[x,a,b])  )$

/* R: qbeta(q,a,b) */
qbeta(q,a,b):=block([cp:control2(a,b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qbeta,[q,a,b])),
   if fq=0.0 then return(0),
   if fq=1.0 then return(1),
   if numberp(q) and numberp(a) and numberp(b) and
      (numer or ?floatp(q) or ?floatp(a) or ?floatp(b))
      then return(?iibeta(fq, float(a), float(b))),
   funmake('qbeta,[q,a,b])  )$

meanbeta(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanbeta,[a,b])),
   a/(a+b)  )$

varbeta(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varbeta,[a,b])),
   a*b/((a+b)^2*(a+b+1))  )$

stdbeta(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdbeta,[a,b])),
   sqrt(a*b/((a+b)^2*(a+b+1)))  )$

skwbeta(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwbeta,[a,b])),
   2*(b-a)*sqrt(a+b+1)/(sqrt(a*b)*(a+b+2))  )$

kurbeta(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurbeta,[a,b])),
   3*(a+b+1)*(2*(a+b)^2+a*b*(a+b-6)) / (a*b*(a+b+2)*(a+b+3)) - 3  )$

/* Implemented algorithms: cheng, ratio, inverse.
   More info in numdistrib.lisp */
rbeta(a,b,[num]):=block([cp:control2(a,b),cn,no,fa,fb],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rbeta,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then return(?rndbeta(fa,fb,no)),
   funmake('rbeta,append([a,b],num)) )$



/*         CONTINUOUS UNIFORM DISTRIBUTION          */



dencontu(x,a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 or sign(x-a)='pnz or sign(x-b)='pnz
      then return(funmake('dencontu,[x,a,b])),
   if member(sign(x-a), ['nz,'neg,'zero]) or member(sign(x-b), ['pos,'pz,'zero])
      then 0
      else if sign(x-a) = 'pos and sign(x-b) = 'pos
              then 1/(b-a)
              else funmake('dencontu,[x,a,b]) )$

discontu(x,a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 or sign(x-a)='pnz or sign(x-b)='pnz
      then return(funmake('discontu,[x,a,b])),
   if member(sign(x-a), ['neg,'nz,'zero])
      then return(0)
      else if member(sign(x-b), ['neg,'nz,'zero])
              then return((x-a)/(b-a))
              else if sign(x-b)='pos
                      then return(1),
   funmake('discontu,[x,a,b])  )$

qcontu(q,a,b):=block([cp:control1(b-a), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qcontu,[q,a,b])),
   a + q * (b-a)  )$

meancontu(a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meancontu,[a,b])),
   (a+b)/2  )$

varcontu(a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varcontu,[a,b])),
   (b-a)^2/12  )$

stdcontu(a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdcontu,[a,b])),
   (b-a)/(2*sqrt(3))  )$

skwcontu(a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwcontu,[a,b])),
   0  )$

kurcontu(a,b):=block([cp:control1(b-a)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurcontu,[a,b])),
   -6/5  )$

/* This is a direct application of the maxima
   random function. Make describe(random) for details */
rcontu(a,b,[num]):=block([cp:control1(b-a),cn,no,f,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rcontu,append([a,b],num))),
   f: float(b-a),
   if numberp(f)
      then if no=0
              then return(a + random(f))
              else return(a + makelist(random(f),k,1,no)),
   funmake('rcontu,append([a,b],num)) )$


/*         LOGISTIC DISTRIBUTION          */



denlog(x,a,b):=block([cp:control1(b),y],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denlog,[x,a,b])),
   y:exp((a-x)/b),
   y/(b*(1+y)^2) )$

dislog(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dislog,[x,a,b])),
   1/(1+exp((a-x)/b))  )$

qlog(q,a,b):=block([cp:control1(b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qlog,[q,a,b])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   a - b * log(1/q-1)  )$

meanlog(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanlog,[a,b])),
   a  )$

varlog(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varlog,[a,b])),
   b*b*%pi*%pi/3  )$

stdlog(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdlog,[a,b])),
   b*%pi/sqrt(3)  )$

skwlog(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwlog,[a,b])),
   0  )$

kurlog(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurlog,[a,b])),
   6/5  )$

/* Only the inverse method is implemented; there
   is no global variable */
rlog(a,b,[num]):=block([cp:control1(b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rlog,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return(a - b * log(1/random(1.0) - 1.0))
              else return(a - b * map('log,1/makelist(random(1.0),k,1,no) - 1.0)),
   funmake('rlog,append([a,b],num)) )$


/*         PARETO DISTRIBUTION          */



denpareto(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denpareto,[x,a,b])),
   if sign(x-b)='pos
      then return(a*b^a*x^(-a-1))
      else if member(sign(x-b), ['nz,'neg,'zero])
              then return(0),
   funmake('denpareto,[x,a,b]) )$

dispareto(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dispareto,[x,a,b])),
   if sign(x-b)='pos
      then return(1-(b/x)^a)
      else if member(sign(x-b), ['nz,'neg,'zero])
              then return(0),
   funmake('dispareto,[x,a,b])  )$

qpareto(q,a,b):=block([cp:control2(a,b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qpareto,[q,a,b])),
   if fq=0.0 then return(b),
   if fq=1.0 then return('inf),
   b / (1-q)^(1/a)  )$

meanpareto(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanpareto,[a,b])),
   if sign(a-1)='pos
      then return(a*b/(a-1))
      else if member(sign(a-1),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('meanpareto,[a,b]) )$

varpareto(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varpareto,[a,b])),
   if sign(a-2)='pos
      then return(a*b*b/((a-2)*(a-1)^2))
      else if member(sign(a-2),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('varpareto,[a,b]) )$

stdpareto(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdpareto,[a,b])),
   if sign(a-2)='pos
      then return(b*sqrt(a/(a-2))/(a-1))
      else if member(sign(a-2),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('stdpareto,[a,b]) )$

skwpareto(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwpareto,[a,b])),
   if sign(a-3)='pos
      then return(2*(a+1)*sqrt(a-2)/((a-3)*sqrt(a)))
      else if member(sign(a-3),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('skwpareto,[a,b]) )$

kurpareto(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurpareto,[a,b])),
   if sign(a-4)='pos
      then return((6*(a^3+a^2-6*a-2)) / (a*(a^2-7*a+12)) - 3)
      else if member(sign(a-4),['nz,'neg,'zero])
              then error("Illegal parameter"),
   funmake('kurpareto,[a,b]) )$

/* Only the inverse method is implemented; there
   is no global variable */
rpareto(a,b,[num]):=block([cp:control2(a,b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rpareto,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return(b / (1-random(1.0))^(1.0/a))
              else return(b / (1-makelist(random(1.0),k,1,no))^(1.0/a)),
   funmake('rpareto,append([a,b],num)) )$



/*         WEIBULL DISTRIBUTION          */



denweibull(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denweibull,[x,a,b])),
   if member(sign(x), ['nz,'neg,'zero])
      then return(0)
      else if sign(x)='pos
              then return(a/b*(x/b)^(a-1)*exp(-(x/b)^a)),
   funmake('denweibull,[x,a,b])  )$

disweibull(x,a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disweibull,[x,a,b])),
   if member(sign(x), ['nz,'neg,'zero])
      then return(0)
      else if sign(x)='pos
              then return(1-exp(-(x/b)^a)),
   funmake('disweibull,[x,a,b]) )$

/* R: qweibull(q,a,b) */
qweibull(q,a,b):=block([cp:control2(a,b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0 then return(funmake('qweibull,[q,a,b])),
   if fq=0.0 then return(0),
   if fq=1.0 then return('inf),
   b * (-log(1-q))^(1/a))$

meanweibull(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanweibull,[a,b])),
   gamma(1/a+1)*b   )$

varweibull(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varweibull,[a,b])),
   (gamma(2/a+1)-gamma(1/a+1)^2)*b^2   )$

stdweibull(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdweibull,[a,b])),
   sqrt((gamma(2/a+1)-gamma(1/a+1)^2))*b  )$

skwweibull(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwweibull,[a,b])),
   (gamma(3/a+1)-3*gamma(1/a+1)*gamma(2/a+1)+2*gamma(1/a+1)^3)  /
        (gamma(2/a+1)-gamma(1/a+1)^2)^(3/2)  )$

kurweibull(a,b):=block([cp:control2(a,b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurweibull,[a,b])),
   (gamma(4/a+1)-4*gamma(1/a+1)*gamma(3/a+1)+
                       6*gamma(1/a+1)^2*gamma(2/a+1)-3*gamma(1/a+1)^4) /
          (gamma(2/a+1)-gamma(1/a+1)^2)^2 - 3  )$

/* Only the inverse method is implemented; there
   is no global variable */
rweibull(a,b,[num]):=block([cp:control2(a,b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rweibull,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return(b * (-log(random(1.0)))^(1.0/a))
              else return(b * (-map('log,makelist(random(1.0),k,1,no)))^(1.0/a)),
   funmake('rweibull,append([a,b],num)) )$



/*          RAYLEIGH DISTRIBUTION              */
/* Rayleigh(b) is equivalent to Weibull(2,1/b) */



denrayleigh(x,b):=denweibull(x,2,1/b)$

disrayleigh(x,b):=disweibull(x,2,1/b)$

qrayleigh(q,b):=qweibull(q,2,1/b)$

meanrayleigh(b):=meanweibull(2,1/b)$

varrayleigh(b):=varweibull(2,1/b)$

stdrayleigh(b):=stdweibull(2,1/b)$

skwrayleigh(b):=skwweibull(2,1/b)$

kurrayleigh(b):=kurweibull(2,1/b)$

/* Only the inverse method is implemented; there
   is no global variable */
rrayleigh(b,[num]):=block([cp:control1(b),cn,no,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rrayleigh,append([b],num))),
   fb: float(b),
   if numberp(fb)
      then if no=0
              then return(sqrt(-log(random(1.0))) / b)
              else return(sqrt(-map('log,makelist(random(1.0),k,1,no))) / b),
   funmake('rrayleigh,append([b],num)) )$



/*         LAPLACE DISTRIBUTION          */



denlaplace(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denlaplace,[x,a,b])),
   exp(-abs(x-a)/b)/(2*b)  )$

dislaplace(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dislaplace,[x,a,b])),
   if member(sign(x-a), ['nz,'neg,'zero])
      then return(1/2*exp((x-a)/b))
      else if sign(x-a)='pos
              then return(1-1/2*exp((a-x)/b)),
   funmake('dislaplace,[x,a,b]) )$

qlaplace(q,a,b):=block([cp:control1(b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qlaplace,[q,a,b])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   a - b * signum(2*q-1) * log(1 - signum(2*q-1) * (2*q-1)))$

meanlaplace(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanlaplace,[a,b])),
   a   )$

varlaplace(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varlaplace,[a,b])),
   2*b*b   )$

stdlaplace(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdlaplace,[a,b])),
   sqrt(2)*b  )$

skwlaplace(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwlaplace,[a,b])),
   0  )$

kurlaplace(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurlaplace,[a,b])),
   3  )$

/* Only the inverse method is implemented; there
   is no global variable */
rlaplace(a,b,[num]):=block([cp:control1(b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rlaplace,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return(qlaplace(random(1.0),a,b))
              else return(makelist(qlaplace(random(1.0),a,b),k,1,no)),
   funmake('rlaplace,append([a,b],num)) )$



/*         CAUCHY (OR LORENTZ) DISTRIBUTION          */



dencauchy(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dencauchy,[x,a,b])),
   b/(%pi*((x-a)^2+b^2))  )$

discauchy(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('discauchy,[x,a,b])),
   1/2+atan((x-a)/b)/%pi )$

qcauchy(q,a,b):=block([cp:control1(b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qcauchy,[q,a,b])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   a + b * tan(%pi * (q - 1/2)) )$

/* Note: integrals for Cauchy moments are divergent */

/* Only the inverse method is implemented; there
   is no global variable */
rcauchy(a,b,[num]):=block([cp:control1(b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rcauchy,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return( tan (float(%pi) * (random(1.0)-0.5))*fb+fa)
              else return(fa + fb * map('tan, 3.141592653589793 * (makelist(random(1.0),k,1,no)-0.5))),
   funmake('rcauchy,append([a,b],num)) )$



/*         GUMBEL (OR EXTREME VALUE) DISTRIBUTION          */



dengumbel(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dengumbel,[x,a,b])),
   exp((a-x)/b-exp((a-x)/b))/b  )$

disgumbel(x,a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disgumbel,[x,a,b])),
   exp(-exp((a-x)/b)) )$

qgumbel(q,a,b):=block([cp:control1(b), cq:controlq(q), fq:float(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qgumbel,[q,a,b])),
   if fq=0.0 then return('minf),
   if fq=1.0 then return('inf),
   a - b * log(-log(q)) )$

meangumbel(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meangumbel,[a,b])),
   a+b*%gamma  /* %gamma=Euler-Mascheroni constant */  )$

vargumbel(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('vargumbel,[a,b])),
   b*b*%pi*%pi/6   )$

stdgumbel(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdgumbel,[a,b])),
   b*%pi/sqrt(6)  )$

skwgumbel(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwgumbel,[a,b])),
   if numer
      then 1.139547099404649
      else 12*sqrt(6)*zeta(3)/%pi^3 )$

kurgumbel(a,b):=block([cp:control1(b)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurgumbel,[a,b])),
   12/5  )$

/* Only the inverse method is implemented; there
   is no global variable */
rgumbel(a,b,[num]):=block([cp:control1(b),cn,no,fa,fb,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rgumbel,append([a,b],num))),
   fa: float(a),
   fb: float(b),
   if numberp(fa) and numberp(fb)
      then if no=0
              then return(a - b * log(-log(random(1.0))))
              else return(a - b * map('log,-map('log,makelist(random(1.0),k,1,no)))),
   funmake('rgumbel,append([a,b],num)) )$



/*         BINOMIAL DISTRIBUTION          */



denbinomial(x,n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denbinomial,[x,n,p])),
   if sign(n)='pos and integerp(n) and sign(p)='pos and sign(1-p)='pos
      then if sign(x)='neg or numberp(x) and not integerp(x) or sign(x-n)='pos
              then return(0)
              else if integerp(x)
                      then return(binomial(n,x)*p^x*(1-p)^(n-x)),
   funmake('denbinomial,[x,n,p]) )$

disbinomial(x,n,p):=block([cp:controlip(n,p),xx],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disbinomial,[x,n,p])),
   if sign(n)='pos and integerp(n) and sign(p)='pos and sign(1-p)='pos
      then if sign(x)='neg
              then return(0)
              else if member(sign(x-n),['pos,'pz,'zero])
                      then return(1)
                      else if numberp(x) and numberp(p) and numberp(n) and 
                              (numer or ?floatp(x) or ?floatp(p) or ?floatp(n))
                              then (xx: floor(x),
                                    return(?ibeta(float(1-p),float(n-xx),float(xx+1)))),
   funmake('disbinomial,[x,n,p])  )$

/* R: qbinom(q,n,p) */
qbinomial(q,n,p):=block([cp:controlip(n,p), cq:controlq(q), fq:float(q),
                         a, b, m],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qbinomial,[q,n,p])),
   if fq <= float((1-p)^n) then return(0),
   if fq=1.0 then return(n),
   if not numberp(q) or not numberp(n) or not numberp(p)
      then return(funmake('qbinomial,[q,n,p])),
   /* let's use the partition method */
   a:0, b:n,
   while (b-a>1) do(
      m: 0.5*(a+b),
      if disbinomial(m,n,p) < q
         then a: m
         else b: m ),
   floor(b) )$

meanbinomial(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanbinomial,[n,p])),
   n*p  )$

varbinomial(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varbinomial,[n,p])),
   n*p*(1-p)  )$

stdbinomial(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdbinomial,[n,p])),
   sqrt(n*p*(1-p))  )$

skwbinomial(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwbinomial,[n,p])),
   return((1-2*p)/sqrt(n*p*(1-p)))  )$

kurbinomial(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurbinomial,[n,p])),
   (1-6*p*(1-p))/(n*p*(1-p))  )$

/* Implemented algorithms: kachit, bernoulli, inverse.
   More info in numdistrib.lisp */
rbinomial(n,p,[num]):=block([cp:controlip(n,p),cn,no,fp],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rbinomial,append([n,p],num))),
   fp: float(p),
   if integerp(n) and numberp(fp)
      then return(?rndbinomial(n,fp,no)),
   funmake('rbinomial,append([n,p],num)) )$



/*         POISSON DISTRIBUTION          */



/* R: dpois(x,m) */
denpoisson(x,m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denpoisson,[x,m])),
   if sign(m)='pos
      then if sign(x)='neg or numberp(x) and not integerp(x)
              then return(0)
              else if integerp(x)
                      then return(exp(-m)*m^x/x!),
   funmake('denpoisson,[x,m]) )$

/* R: ppois(q,m) */
dispoisson(x,m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dispoisson,[x,m])),
   if sign(m)='pos
      then if sign(x)='neg
              then return(0)
              else if numberp(x) and numberp(m) and
                      (numer or ?floatp(x) or ?floatp(m))
                      then return(1-?igamma(float(m), float(floor(x)+1))),
   funmake('dispoisson,[x,m])  )$

/* R: qpois(q,m) */
qpoisson(q,m):=block([cp:control1(m), cq:controlq(q), fq:float(q),
                         a, b, mm],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qpoisson,[q,m])),
   if fq <= float(exp(-m)) then return(0),
   if fq=1.0 then return('inf),
   if not numberp(q) or not numberp(m)
      then return(funmake('qpoisson,[q,m])),
   /* let's use the partition method */
   b:1.0,
   while (dispoisson(b,m) < q) do b : 2.0*b,
   a: b/2.0,
   while (b-a>1) do(
      mm: 0.5*(a+b),
      if dispoisson(mm,m) < q
         then a: mm
         else b: mm ),
   floor(b) )$

meanpoisson(m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanpoisson,[m])),
   m  )$

varpoisson(m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varpoisson,[m])),
   m  )$

stdpoisson(m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdpoisson,[m])),
   sqrt(m)  )$

skwpoisson(m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwpoisson,[m])),
   1/sqrt(m)  )$

kurpoisson(m):=block([cp:control1(m)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurpoisson,[m])),
   1/m  )$

/* Implemented algorithms: ahrens_dieter, inverse.
   More info in numdistrib.lisp */
rpoisson(m,[num]):=block([cp:control1(m),cn,no,fm],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rpoisson,append([m],num))),
   fm: float(m),
   if numberp(fm)
      then return(?rndpoisson(fm,no)),
   funmake('rpoisson,append([m],num)) )$



/*           BERNOULLI DISTRIBUTION            */
/* Bernoulli(p) is equivalent to binomial(1,p) */



denbernoulli(x,p):=denbinomial(x,1,p)$

disbernoulli(x,p):=block([cp:controlip(1,p),xx],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disbernoulli,[x,p])),
   if sign(x)='neg
      then return(0)
      else if member(sign(x-1),['pos,'pz,'zero])
              then return(1)
              else if not sign(x)='pnz
                      then return(1-p),
   funmake('disbernoulli,[x,p])  )$

qbernoulli(q,p):=block([cp:controlip(1,p), cq:controlq(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qbernoulli,[q,p])),
   if member(sign(1-p-q),['pos,'zero])
      then return(0)
      else return(1) )$

meanbernoulli(p):=meanbinomial(1,p)$

varbernoulli(p):=varbinomial(1,p)$

stdbernoulli(p):=stdbinomial(1,p)$

skwbernoulli(p):=skwbinomial(1,p)$

kurbernoulli(p):=kurbinomial(1,p)$

/* This is a direct application of the maxima
   random function. Make describe(random) for details */
rbernoulli(p,[num]):=block([cp:controlq(p),cn,no,f,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rbernoulli,append([p],num))),
   f: float(p),
   if numberp(f)
      then if no=0
              then return(if random(1.0)<=f then 1 else 0)
              else return(makelist(if random(1.0)<=f then 1 else 0,k,1,no)),
   funmake('rbernoulli,append([p],num)) )$



/*         GEOMETRIC (OR PASCAL) DISTRIBUTION          */



dengeo(x,p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dengeo,[x,p])),
   if sign(p)='pos and sign(1-p)='pos
      then if sign(x)='neg or numberp(x) and not integerp(x)
              then return(0)
              else if numberp(x)
                      then return(p*(1-p)^x),
   funmake('dengeo,[x,p]) )$

disgeo(x,p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disgeo,[x,p])),
   if sign(p)='pos and sign(1-p)='pos
      then if sign(x)='neg
              then return(0)
              else if member(sign(x),['pos,'zero,'pz])
                      then return(1-(1-p)^(floor(x)+1)),
   funmake('disgeo,[x,p])  )$

/* R: pgeom(q,p) */
qgeo(q,p):=block([cp:controlp(p), cq:controlq(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qgeo,[q,p])),
   ceiling(log(1-q)/log(1-p)-1) )$

meangeo(p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meangeo,[p])),
   1/p-1  )$

vargeo(p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('vargeo,[p])),
   (1-p)/p^2  )$

stdgeo(p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdgeo,[p])),
   sqrt(1-p)/p  )$

skwgeo(p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwgeo,[p])),
   (2-p)/sqrt(1-p)  )$

kurgeo(p):=block([cp:controlp(p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurgeo,[p])),
   (p^2+6-6*p)/(1-p)  )$

/* Implemented algorithms: bernoulli, devroye, inverse.
   More info in numdistrib.lisp */
rgeo(p,[num]):=block([cp:controlp(p),cn,no,fp],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rgeo,append([p],num))),
   fp: float(p),
   if numberp(fp)
      then return(?rndgeo(fp,no)),
   funmake('rgeo,append([p],num)) )$



/*         DISCRETE UNIFORM DISTRIBUTION          */



dendiscu(x,n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dendiscu,[x,n])),
   if sign(n)='pos and integerp(n)
      then if sign(x-1)='neg or sign(x-n)='pos or
              numberp(x) and not integerp(x)
              then return(0)
              else return(1/n),
   funmake('dendiscu,[x,n]) )$

disdiscu(x,n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disdiscu,[x,n])),
   if sign(n)='pos and integerp(n)
      then if sign(x-1)='neg
              then return(0)
              else if sign(x-n)='pos
                      then return(1)
                      else if member(sign(x-1),['pos,'pz,'zero]) and
                              member(sign(n-x),['pos,'pz,'zero])
                              then return(floor(x)/n),
   funmake('disdiscu,[x,n])   )$

qdiscu(q,n):=block([cp:controli(n), cq:controlq(q)],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qdiscu,[q,n])),
   max(ceiling(q*n), 1) )$

meandiscu(n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meandiscu,[n])),
   (1+n)/2  )$

vardiscu(n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('vardiscu,[n])),
   (n^2-1)/12  )$

stddiscu(n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stddiscu,[n])),
   sqrt((n^2-1)/12)  )$

skwdiscu(n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwdiscu,[n])),
   0  )$

kurdiscu(n):=block([cp:controli(n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurdiscu,[n])),
   -6/5-12/(5*(n^2-1)))$

/* This is a direct application of the maxima
   random function. Make describe(random) for details */
rdiscu(n,[num]):=block([cp:controli(n),cn,no,listarith:true],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rdiscu,append([n],num))),
   if integerp(n)
      then if no=0 
              then 1+random(n)
              else 1+makelist(random(n),k,1,no)
      else funmake('rdiscu,append([n],num)) )$


/*         HYPERGEOMETRIC DISTRIBUTION          */


denhypergeo(x,n1,n2,n):=block([cp:controliii(n1,n2,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('denhypergeo,[x,n1,n2,n])),
   if sign(x-max(0,n-n2))='neg or
      sign(min(n1,n)-x)='neg or
      numberp(x) and not integerp(x)
      then return(0)
      else if numberp(x)
              then return(binomial(n1,x)*binomial(n2,n-x)/binomial(n1+n2,n))
              else return(funmake('denhypergeo,[x,n1,n2,n])) )$

dishypergeo(x,n1,n2,n):=block([cp:controliii(n1,n2,n),listarith:true],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dishypergeo,[x,n1,n2,n])),
   if sign(x-max(0,n-n2))='neg
      then return(0)
      else if member(sign(min(n1,n)-x),['neg,'zero,'nz])
           then return(1)
           else if numberp(x)
                   then return(apply("+",
                                   makelist(binomial(n1,k)*binomial(n2,n-k) / 
                                            binomial(n1+n2,n),k,0,floor(x))))
                   else return(funmake('dishypergeo,[x,n1,n2,n])) )$

/* R: qhyper(q,n1,n2,n) */
qhypergeo(q,n1,n2,n):=block([cp:controliii(n1,n2,n), cq:controlq(q), fq:float(q),
                         rmin, rmax, aux, a, b, m],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qhypergeo,[q,n1,n2,n])),
   rmin: max(0, n-n2),
   rmax: min(n1,n),
   aux: denhypergeo(rmin,n1,n2,n),
   if fq <= float(aux) then return(rmin),
   if fq=1.0 then return(rmax),
   if not numberp(q) or not numberp(n1) or not numberp(n2) or not numberp(n)
      then return(funmake('qhypergeo,[q,n1,n2,n])),
   /* let's use the partition method */
   a: rmin,
   b: rmax,
   while (b-a > 1) do(
      m: floor(0.5*(a+b)),
      if dishypergeo(m,n1,n2,n) < q
         then a: m
         else b: m ),
   b )$

meanhypergeo(n1,n2,n):=block([cp:controliii(n1,n2,n)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meanhypergeo,[n1,n2,n])),
   n*n1/(n1+n2)  )$

varhypergeo(n1,n2,n):=block([cp:controliii(n1,n2,n),t],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varhypergeo,[n1,n2,n])),
   t:n1+n2,
   n*n1*n2*(t-n)/(t*t*(t-1))  )$

stdhypergeo(n1,n2,n):=block([cp:controliii(n1,n2,n),t],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdhypergeo,[n1,n2,n])),
   t:n1+n2,
   sqrt(n*n1*n2*(t-n)/(t-1))/t  )$

skwhypergeo(n1,n2,n):=block([cp:controliii(n1,n2,n),t],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwhypergeo,[n1,n2,n])),
   t:n1+n2,
   (n2-n1)*(t-2*n)*sqrt((t-1)/(n*n1*n2*(t-n)))/(t-2)  )$

kurhypergeo(n1,n2,n):=block([cp:controliii(n1,n2,n),t],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurhypergeo,[n1,n2,n])),
   t:n1+n2,
   t*t*(t-1)/((t-2)*(t-3)*n*n1*n2*(t-n)) * 
     (t*(t+1)-6*n*(t-n)+3*n1*n2*(t*t*(n-2)-t*n*n+6*n*(t-n))/t^2) - 3  )$

/* Implemented algorithms: kachit, inverse.
   More info in numdistrib.lisp */
rhypergeo(n1,n2,n,[num]):=block([cp:controliii(n1,n2,n),cn,no],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rhypergeo,append([n1,n2,n],num))),
   if numberp(n1) and numberp(n2) and numberp(n)
      then return(?rndhypergeo(n1,n2,n,no)),
   funmake('rhypergeo,append([n1,n2,n],num)) )$


/*         NEGATIVE BINOMIAL DISTRIBUTION          */



dennegbinom(x,n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('dennegbinom,[x,n,p])),
   if sign(x)='neg or numberp(x) and not integerp(x)
      then return(0)
      else if numberp(x) and integerp(x)
              then binomial(x+n-1,x)*p^n*(1-p)^x
              else funmake('dennegbinom,[x,n,p]) )$

disnegbinom(x,n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('disnegbinom,[x,n,p])),
   if sign(x)='neg
      then return(0)
      else if numberp(x) and numberp(n) and numberp(p) and
              (numer or ?floatp(x) or ?floatp(n) or ?floatp(p))
              then ?ibeta(float(p),float(n),float(floor(x)+1))
              else funmake('disnegbinom,[x,n,p]) )$

/* R: qnbinom(q,n,p) */
qnegbinom(q,n,p):=block([cp:controlip(n,p), cq:controlq(q), fq:float(q),
                         a, b, m],
   if cp=-1 or cq=-1 then error("Illegal parameter"),
   if cp=0 or cq=0
      then return(funmake('qnegbinom,[q,n,p])),
   if fq <= float(p^n) then return(0),
   if fq=1.0 then return('inf),
   if not numberp(q) or not numberp(n) or not numberp(p)
      then return(funmake('qnegbinom,[q,n,p])),
   /* let's use the partition method */
   b: 1,
   while (disnegbinom(b,n,p) < q) do b: b*2,
   a: b/2,
   while (b-a > 1) do(
      m: floor(0.5*(a+b)),
      if disnegbinom(m,n,p) < q
         then a: m
         else b: m ),
   b )$

meannegbinom(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('meannegbinom,[n,p])),
   n*(1-p)/p )$

varnegbinom(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('varnegbinom,[n,p])),
   n*(1-p)/p^2 )$

stdnegbinom(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('stdnegbinom,[n,p])),
   sqrt(n*(1-p))/p )$

skwnegbinom(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('skwnegbinom,[n,p])),
   (2-p)/sqrt(n*(1-p)) )$

kurnegbinom(n,p):=block([cp:controlip(n,p)],
   if cp=-1 then error("Illegal parameter"),
   if cp=0 then return(funmake('kurnegbinom,[n,p])),
   (p*p+6-6*p)/(n*(1-p)) )$

/* Implemented algorithms: devroye, bernoulli, inverse.
   More info in numdistrib.lisp */
rnegbinom(n,p,[num]):=block([cp:controlip(n,p),cn,no,fp],
   if length(num) = 0 then no: 0 else no: num[1],
   cn: controlib(no),
   if cp=-1 or cn=-1 then error("Illegal parameter"),
   if cp=0 or cn=0 then return(funmake('rnegbinom,append([n,p],num))),
   fp: float(p),
   if integerp(n) and numberp(fp)
      then return(?rndnegbinom(n,fp,no)),
   funmake('rnegbinom,append([n,p],num)) )$
