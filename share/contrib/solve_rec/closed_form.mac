/*****************************************************************************
 *                                                                           *
 * ************************************************************************* *
 * ***                                                                   *** *
 * ***                       * closed_form *                             *** *
 * ***                                                                   *** *
 * ***   This file implements closed_form function for simplification    *** *
 * ***     of sums (with finite support) which include binomials. It     *** *
 * ***             uses Zeilberger and solve_rec packages.               *** *
 * ***                                                                   *** *
 * ***   Author:  Andrej Vodopivec <andrejv@users.sourceforge.net>       *** *
 * ***   Licence: GPL2                                                   *** *
 * ***                                                                   *** *
 * ************************************************************************* *
 *                                                                           *
 *                                                                           *
 * Demo:                                                                     *
 *                                                                           *
 * (%i6) s : closed_form(sum(((-1)^k*x*binom(n,k))/(x+k),k,0,n))$            *
 * (%i7) factcomb(s);                                                        *
 * (%o7) (n!*x!)/(x+n)!                                                      *
 *                                                                           *
 * (%i8) closed_form(sum((-1)^k*binom(x-2*k,n-k)*binom(x-k+1,k),k,0,n));     *
 * Is  x - 2 * n   positive, negative, or zero?  pos;                        *
 * Is  x - n + 1   positive, negative, or zero?  pos;                        *
 * (%o8) ((-1)^n+1)/2                                                        *
 *                                                                           *
 * (%i9) closed_form(sum(binom(n,k)/(k+1),k,0,n));                           *
 * (%o9) (2*2^n-1)/(n+1)                                                     *
 *                                                                           *
 * More examples with load("closed_form_test");                              *
 *                                                                           *
 *****************************************************************************/

load("zeilberger")$
load("solve_rec/solve_rec")$

eval_when(batch,
          ttyoff : true,
          nolabels : true)$

put('closed_form, 1.0, 'version)$

define_variable(zeilberger_check, true, boolean)$
define_variable(check_start, 1, fixnum)$

/*******************
 *
 * Debugging.
 *
 *******************/

define_variable(verbose_level, 0, fixnum)$

cf_print_message(level, [mess]) :=
  if verbose_level>=level then (
    apply(print, mess)
  )$

/*******************
 *
 * closed_form(expr) : tries to simplify all sums in expr.
 *
 *******************/

closed_form(expr) :=
  /* Check if we have a sum - if not then simplify all arguments.       */
  if atom(expr) then expr
  else if part(expr, 0)#nounify(sum) then map(closed_form, expr)

  else block(
    [lo : part(expr, 3), hi : part(expr, 4), sm1, linsolvewarn:false],

    /* Let's see if default maxima simplifications can handle this sum. */
    cf_print_message(1, "Trying with simpsum=true ..."),
    if errcatch(
      sm1 : ev(expr, simpsum = true)
    ) = [] then sm1 : expr,
    cf_print_message(1, "sum with simpsum=true returns:", sm1),

    /* Now let's try the Gosper algorithm                               */
    if errcatch(
      if not(atom(sm1)) and not freeof_sum(sm1) then block(
        [lo1: ?gensym(), hi1: ?gensym()],
        cf_print_message(1, "Trying with Gosper ..."),
        sm1 : nusum(part(expr, 1), part(expr, 2), lo1, hi1),
        cf_print_message(1, "Gosper returns:", sm1),
        if lo=minf or lo=-inf then
          sm1 : limit(sm1, lo1, lo)
        else
          sm1 : subst(lo1=lo, sm1),
        if hi=inf then
          sm1 : limit(sm1, hi1, hi)
        else
          sm1 : subst(hi1=hi, sm1)
      )
    ) = [] then sm1 : expr,

    /* Try converting the sum to finite sum of psi functions            */
    if errcatch(
      if not(atom(sm1)) and not( freeof_sum(sm1) ) and
         ?ratp(ratsimp(part(expr, 1)), part(expr, 2))
      then (
        if part(expr, 4) = inf then block(
          [lo1: part(expr, 3), hi1, ratfun, old_var: part(expr, 2),
           var, expr1],
          cf_print_message(1, "Trying ratfun -> psi ..."),
          expr1 : intosum(changevar(expr, var=old_var-lo+1, var, old_var)),
          ratfun : part(expr1, 1),
          lo1 : part(expr1, 3),
          hi1 : part(expr1, 4),
          if hipow(num(ratfun), var) <= hipow(denom(ratfun), var)-2 then (
            cf_print_message(2, "calling ratfun_to_psi"),
            sm1 : ratfun_to_psi(ratfun, var),
            cf_print_message(2, "ratfun -> psi returns", sm1)
          )
        )
        else (
          cf_print_message(2, "Splitting sum"),
          sm1 : closed_form(
            apply(sum, [part(expr, 1), part(expr, 2), lo, inf]) -
            apply(sum, [part(expr, 1), part(expr, 2), hi+1, inf])
          )
        )
      )
    ) = [] then sm1 : expr,

    supcontext("cf_context"),
    
    /* If everything else fails let's try the Zeilberger algorithm .    */
    if errcatch(
      if not(atom(sm1)) and not freeof_sum(sm1) then (
        cf_print_message(1, "Trying with Zeilberger ..."),
        sm1 : cf_zeilb(part(expr, 1), part(expr, 2), part(expr, 3), part(expr, 4)),
        cf_print_message(1, "Zeilberger method returns:", sm1)
      )
    ) = [] then sm1 : expr,

    /* :(                                                                */
    if sm1=false then
      sm1 : apply(sum, [part(expr, 1), part(expr, 2), part(expr, 3), part(expr, 4)]),

    killcontext("cf_context"),

    sm1
  )$

/*******************
 *
 * Check if we still have some sums in expr.
 *
 *******************/

freeof_sum(expr) :=
  if atom(expr) then true
  else if part(expr, 0)=nounify(sum) then false
  else if expr=[] then true
  else lreduce("and", map(freeof_sum, args(expr)))$

/*******************
 *
 * This simplifies the sum using Zeilberger
 *
 *******************/

cf_zeilb(expr, %k%, lo, hi, [in_zr]) := block(
  [vars : delete(%k%, listofvars(expr)), %n%, eq, sm, zb, deg,
   cond, eq_rhs, cert, %i%, expr1, ihom,
   upper_bound_implicit : false, lower_bound_implicit : false,
   solve_rec_warn : false],

  /* Convert binomials to factorials.                                   */
  expr1 : factor(minfactorial(factcomb(makefact(expr)))),
  cf_print_message(2, "Summand:", expr),
  cf_print_message(2, "Changed to:", expr1),

  /* We need expr to be hypergeometric in at least two variables.       */
  /* We prefer the second variable to appear in bounds.                 */
  if length(in_zr)=0 then (
    if length(vars)<1 then return(false),
    if length(listofvars(hi))>0 then %n% : first(listofvars(hi))
    else if length(listofvars(lo))>0 then %n% : first(listofvars(hi))
    else %n% : vars[1]
  )
  else
    %n% : in_zr[1],


  /*  Find support.                                                      */
  assume(%k%>lo), assume(%k%<hi),
  support : cf_support(expr1, %k%),
  support : [if numberp(support[1]) then ceiling(support[1]) else support[1],
             if numberp(support[2]) then floor(support[2])   else support[2]],

  /* Let's check if bounds are implicit.                                 */
  if cf_max(lo, support[1])=support[1] then lower_bound_implicit : true,
  if cf_min(hi, support[2])=support[2] then upper_bound_implicit : true,

  if lo=-inf then lo : support[1],
  if hi=inf then hi : support[2],

  cf_print_message(2, "Found support:", support),

  /* We don't handle sums over infinite support yet!                     */
  if (support[1]=-inf and lower_bound_implicit) or
     (support[2]=inf and upper_bound_implicit) then (
    cf_print_message(3, "Support not finite!"),
    return(false)
  ),

  zb : Zeilberger(expr1, %k%, %n%),
  cf_print_message(3, "Zeilberger returns:", zb),
  if not(listp(zb[1])) then error(),
  deg : length(part(zb, 1, 2)),
  cert : part(zb, 1, 1),
  eq : part(zb, 1, 2) . makelist(sm[%n%+%i%], %i%, 0, deg-1),

  cond : makelist(sm[%i%]=subst(%n%=%i%,
                                apply(sum, [
                                              minfactorial(expr),
                                              %k%,
                                              ceiling(lo),
                                              floor(hi)
                                            ]
                                      )
                                ),
                  %i%, 1, deg-1),
  cond : factor(minfactorial(cond)),

  if not freeof_sum(cond) then (
    cf_print_message(3, "Wrong initial conditions:", cond),
    return(false)
  ),

  ihom : minfactorial(makefact(cert*expr)),
  eq_rhs : 0,
  for %i%:0 thru deg-1 do (
    if not(upper_bound_implicit) then (
      eq_rhs : eq_rhs + part(zb, 1, 2, %i%+1)*apply(sum,
                        [subst(%n%=%n%+%i%, expr), %k%, hi+1, subst(%n%=%n%+%i%, hi)])
    ),
    if not(lower_bound_implicit) then (
      eq_rhs : eq_rhs + part(zb, 1, 2, %i%+1)*apply(sum,
                        [subst(%n%=%n%+%i%, expr), %k%, subst(%n%=%n%+%i%, lo), lo-1])
    )
  ),
  eq_rhs : minfactorial(factcomb(makefact(eq_rhs))),
  if not(upper_bound_implicit) then
    eq_rhs : eq_rhs + minfactorial(makefact(subst(%k%=hi+1, ihom))),
  if not(lower_bound_implicit) then
    eq_rhs : eq_rhs - minfactorial(makefact(subst(%k%=lo, ihom))),
  eq_rhs : factor(minfactorial(factcomb((eq_rhs)))),

  if not freeof_sum(eq_rhs) then (
    cf_print_message(3, "Recurrence contains sums!", eq_rhs),
    return(false)
  ),

  eq : eq = eq_rhs,
  cf_print_message(2, "Degree of recurrence:", deg-1),
  cf_print_message(2, "Zeilberger recurrence:", eq),
  cf_print_message(2, "Initial conditions:", cond),

  if length(in_zr)>0 then return(eq),

  /* Solve the recurrence                                             */
  eq : apply(solve_rec, append([eq, sm[%n%]], cond)),
  cf_print_message(2, "Solving recurrence returns:", eq),
  if eq=false then return(false),
  if not freeof_sum(eq) then return(false),

  eq : ratsimp(minfactorial(makefact(rhs(eq)))),
  cf_print_message(4, "Simplifies solution:", eq),

  /* Check the solution                                               */
  if check_sum(expr, %k%, %n%, lo, hi, deg, eq) then eq
  else false
)$

/*******************
 *
 * This returns the recurrence for the sum.
 *
 *******************/

summand_to_rec(expr, k, n) := block(
  [zr, linsolvewarn:false, lo:-inf, hi:inf],
  
  if listp(k) then (
    lo : k[2],
    hi : k[3],
    k : k[1]
  ),

  supcontext("cf_context"),

  if errcatch(
    zr : cf_zeilb(expr, k, lo, hi, n)
  ) = [] then zr : 'failed,

  killcontext("cf_context"),

  zr
)$

/*******************
 *
 * Check the result - we may get something wrong!
 *
 *******************/

check_sum(expr, %k%, %n%, lo, hi, deg, sm) :=
  if not zeilberger_check then true
  else catch(
    block(
      [%i%, tmp_sum, real_sum],
      for %i%:check_start thru deg+check_start do(
        real_sum : minfactorial(factcomb(makefact(subst(%n%=%i%, apply(sum,
           [expr, %k%, ceiling(lo) , floor(hi)]))))),
        tmp_sum  : minfactorial(factcomb(makefact(subst(%n%=%i%, sm)))),
        dif : factor(minfactorial(factcomb(real_sum - tmp_sum))),
        if freeof_sum(tmp_sum) and dif#0
        then (
          cf_print_message(2, "Sum check failed with: ", 'i=%i%, 'tmp_sum=tmp_sum, 'dif=dif),
          throw(false)
        )
      )
    ),
    true
  )$

/*******************
 *
 * This part checks for the support of expr in %k%
 *
 *******************/

cf_support(expr, %k%) := block(
  if freeof(%k%, expr) or expr=%k% then [-inf, inf]
  else if member(part(expr, 0), ["+", "-"]) then
    lreduce(cf_union, map(lambda([u], cf_support(u,%k%)), args(expr)))
  else if member(part(expr, 0), ["*", "//"]) then
    lreduce(cf_intersection, map(lambda([u], cf_support(u,%k%)), args(expr)))
  else if member(part(expr, 0), ["^"]) then cf_support(part(expr, 1), %k%)
  else if part(expr, 0)=binomial then cf_support_binomial(expr, %k%)
  else if part(expr, 0)="!" then cf_support_factorial(expr, %k%)
  else [-inf, inf]
)$

/* we assume here that k!=0 if k<0 */
cf_support_factorial(expr, %k%) :=
  solve_lin_ineq(part(expr,1)>0, %k%)$

cf_support_binomial(expr, %k%) := block(
  [s1, s2],
  s1 : solve_lin_ineq(part(expr, 2)>0, %k%),
  s2 : solve_lin_ineq(part(expr, 2)<part(expr, 1), %k%),
  cf_intersection(s1, s2)
)$

/*******************
 *
 * solves inequality which is linear in k
 *
 *******************/

solve_lin_ineq(eq, k) := block(
  [eq1, bc, a, b],

  if op(eq)=">" then eq1 : lhs(eq) - rhs(eq)
  else eq1 : rhs(eq) - lhs(eq),

  bc : bothcoef(expand(eq1), k), a:bc[1], b:bc[2],

  if a=0 then [-inf, inf]
  else if not freeof(k, b) then [-inf, inf]
  else if not numberp(a) then [-inf, inf]
  else if a>0 then [-b/a, inf]
  else [-inf, -b/a]
)$

cf_union(l1, l2) := [cf_min(first(l1), first(l2)), cf_max(second(l1), second(l2))]$
cf_intersection(l1, l2) := [cf_max(first(l1), first(l2)), cf_min(second(l1), second(l2))]$

cf_max(e1, e2) := block(
  [pnz : asksign(e1-e2)],
  if pnz='pos or pnz='zero then e1
  else e2
)$

cf_min(e1, e2) := block(
  [pnz : asksign(e1-e2)],
  if pnz='neg or pnz='zero then e1
  else e2
)$

eval_when(batch,
          ttyoff : false,
          nolabels : false)$

/********************
 *
 * splits sum
 *
 ********************/

expand_sum(expr, k, lo, hi) :=
  if not(atom(expr)) and part(expr, 0)="+" then
    map(lambda([u], apply(sum, [u, k, lo, hi])), expr)
  else
    apply(sum, [expr, k, lo, hi]);

split_sum(expr) := block(
  [opsubst:true, s],
  s: subst(nounify(sum)=expand_sum, expr),
  ev(s, expand_sum)
)$

/*******************
 *
 * converts sum(ratfun, var, 1, inf) to psi functions when denom(ratfun)
 * can be completely factored.
 *
 *******************/

ratfun_to_psi(ratfun, var) := block(
  [pf, sum: 0, denom_f : factor_with_solve(denom(ratfun), var)],

  pf : partfrac(num(ratfun)/denom_f, var),
  
  if inpart(pf, 0)="+" then pf: args(pf)
  else pf: [pf],

  cf_print_message(2, "Partial fractions", pf),

  for prt in pf do block(
    [term: numfactor(prt), exponent, a, b],
    
    cf_print_message(3, "Working on term", prt),
    
    prt : prt/term,
    term : term*num(prt),
    prt : denom(prt),

    if not(atom(prt)) and part(prt,0)="^" then (
      exponent: part(prt, 2),
      prt: part(prt, 1)
    )
    else
      exponent: 1,

    cf_print_message(3, "Linear part", prt),
    
    a: ratsimp(bothcoef(expand(prt), var)),
    b: a[2], a: a[1],

    if not( freeof(var, a) and freeof(var, b) ) then error()
    else term:
      (-1)^exponent/(exponent-1)!*term*psi[exponent-1](1+b/a)/a^exponent,

    cf_print_message(3, "Corresponding term in sum", term),
    
    sum: sum+term
  ),
  
  sum
)$

factor_with_solve(expr, n) := block(
  [sol, fac, expr1],
  sol : solve(expr, n),
  expr : ratexpand(expr),
  fac : ratcoef(expr, n, hipow(expr, n)),
  for i:1 thru length(sol) do (
    if not(freeof(n, rhs(sol[i]))) then error(),
    fac : fac * (n - rhs(sol[i]))^multiplicities[i]
  ),
  fac
)$
