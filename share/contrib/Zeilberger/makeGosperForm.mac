/*
       ***************************************************************
       *                    Zeilberger Package                       *
       *                                                             *
       *      Zeilberger is a Maxima implementation of Gosper's      *
       *      and Zeilberger's algorithm for proving and finding     *
       *      indefinite and definite hypergeometric summation       *
       *      identities, implementing Axel Riese's filtering        *
       *      optimization. This is the code discussed in:           *
       *      F. Caruso, A Macsyma Implementation of Zeilberger's    *
       *      Fast Algorithm, RISC-Linz Report Series n. 99-21, J.   *
       *      Kepler University, Linz, 1999.                         *
       *                                                             *
       *                 					     *
       *                                                             *
       *                        Version 2.0                          *
       *                       March 15, 2004                        *
       *             License:  GPL (version 2 or later)              *
       *                                                             *
       *                 --------------------------                  *
       *   Copyright (C) Fabrizio Caruso and the RISC Combinatorics  *
       *   Group, Johannes Kepler Universitaet, Linz, Austria        *
       *                                                             *
       *   Filename: makeGosperForm.mac                              *
       *                                                             *
       ***************************************************************
*/

/* Gosper form routine    */
/* by Fabrizio Caruso     */
                                                                                                                             
/* Copyrighted to Fabrizio Caruso and to the RISC Combinatorics Group */
/* Johannes Kepler Universitaet, Linz, Austria                        */


/* List select wrt a criterion */
select(list,crit) := 
  if list = [] then
    []
  else
     if crit(first(list)) then
       cons(first(list),select(rest(list),crit))
     else
       select(rest(list),crit);

/* List split wrt a criterion */
splitList(list,crit) := 
  block([trueList,falseList,i],
   trueList : [],
   falseList : [],
   unless list = [] do 
      (
      if crit(first(list)) then
         trueList : endcons(first(list),trueList)
      else
         falseList : endcons(first(list),falseList),
      list : rest(list)
      ),
   return([trueList,falseList])
   );

/* true if a given expr has a given degree */
degreeSelect(expr,var,deg) := is(degree(expr,var)=deg);
   

/* integer distance */
intDistance(expr1,expr2) := integerp(expr1-expr2);


/* It splits a list into a part with a given coefficient and the rest */
candSplit(list,coef,constCoef) :=
  block([candRes,restRes],
  candRes : [],
  restRes : [],
  unless (list = []) do
    (
    if (first(first(list))=coef) and integerp(second(first(list))-constCoef) then
       candRes : endcons(first(list),candRes)
    else
       restRes : endcons(first(list),restRes),
    list : rest(list)
    ),
  return([candRes, restRes])
  );



/* It checks whether a factored expression is linear */
/* with integer coefficients */
integerLinear(expr,var) :=
  if not(operatorp(expr,"^")) then
   (degree(expr,var) < 2) and
   (integerp(coeff(expr,var,1)))
  else
   integerLinear(first(expr),var); 
 

/* Separate the constant and the normalized part of an integer linear*/
intLinConstSep(intLin) :=
  block([i,intLinRes,constRes],
   intLinRes : [],
   constRes : 1,
   for i : 1 thru length(intLin) do
      (      
      intLinRes : endcons(first(part(intLin,i)),intLinRes),
      constRes : constRes * second(part(intLin,i))
      ),
   return([intLinRes, constRes])
  );


constSep(intLin) :=
  block([i,intLinRes,constRes],
   intLinRes : [],
   constRes : 1,
   for i : 1 thru length(intLin) do
      (      
      intLinRes : endcons(first(part(intLin,i)),intLinRes),
      constRes : constRes * second(part(intLin,i))
      ),
   return([intLinRes, constRes])
  );


/* Check Gosper's condition */
/* We are assuming that the input is factored */
/* into irreducible factors */
/* */
/* The numerator is q(k) and the denominator is r(k) */
makeGosperFormVerbose(expr,k) :=
  block(
  /* Local variables */
  [num,den,numList,denList,lengthNumList,lengthDenList,
   test,
   i,j,h,minExp,pulledPoly,pPoly,curExp,compPoly,formSign,
   p,q,r,pList,qList,rList,
   negNumFlag,negDenFlag,
   intLinNum,nonIntLinNum,intLinDen,nonIntLinDen,
   sepNumList,sepDenList,
   constIntLinNum, constIntLinDen, constSep, 
   normIntLinNum, normNonIntLinNum, normIntLinDen, normNonIntLinDen,
   numItem, denItem,
   numExp,denExp,minExp,diff,candListSplit,item],
  
if(expr=1) then 
  return([1,1,1]),

  num:factor(num(expr)),
  den:factor(denom(expr)),

print("STARTING WITH : "),
print(num),
print(den),

negNumFlag : operatorp(num,"-"),
negDenFlag : operatorp(den,"-"),

if (negNumFlag) then
  num : -1 * num,
if (negDenFlag) then   
  den : -1 * den,

if (negNumFlag and not(negDenFlag))or(not(negNumFlag) and negDenFlag) then
   (
   formSign : -1
   )
else
   formSign : 1,

pPoly : 1,


sepNumList:intLinSep(num,k),
sepDenList:intLinSep(den,k),


print("sepNumList : ", sepNumList),
print("sepDenList : ", sepDenList),  

nonIntLinNum : first(sepNumList),
intLinNum : second(sepNumList),
nonIntLinDen : first(sepDenList),
intLinDen : second(sepDenList),

p:1,
q:1,
r:1,
pList:[],
qList:[],
rList:[],

/* Non-integer linear computation */

print("NON-INTEGER LINEAR COMPUTTATION"),

numList : normList(nonIntLinNum,k),
denList : normList(nonIntLinDen,k),

print("numList : ", numList),
print("denList : ", denList),

constSep : constSep(numList),
normNonIntLinNum : constSep[1],
nonIntLinNumConst : constSep[2],
print("normIntLinNum : ", normNonIntLinNum),
print("intLinNumConst : ", nonIntLinNumConst),

constSep : constSep(denList),
normNonIntLinDen : constSep[1],
nonIntLinDenConst : constSep[2],
print("normIntLinDen : ", normNonIntLinDen),
print("nonIntLinDenConst : ", nonIntLinDenConst),

q : q * nonIntLinNumConst,
r : r * nonIntLinDenConst,

numList : normNonIntLinNum,
denList : normNonIntLinDen,


print("-----------------------------------------------------------------"),
print("entering outer loop"),
print("-----------------------------------------------------------------"),


unless ((numList = []) or (denList = [])) do
  (
  denItem : first(denList),
  print("denItem : ", denItem),
  candListSplit : splitList(numList,
                            lambda([x],degreeSelect(x,k,degree(first(denItem),k)))
                           ),
  print("candListSplit : ", candListSplit),
  candNumList : first(candListSplit),

numList : second(candListSplit),
candListSplit : splitList(denList,
                            lambda([x],degreeSelect(x,k,degree(first(denItem),k)))
                           ),
  print("candListSplit : ", candListSplit),
  candDenList : first(candListSplit),
denList : second(candListSplit),




  
print("entering inner loop"),
  unless candDenList = [] do
     (
     denItem : first(candDenList),
     tempList : candNumList,
     candNumList : [],
     unless tempList = [] do
        (
        
        
     print("BOGUS checking ", denItem ," against : ", first(tempList)),
     shiftRes : resultant(norm2polyPower(first(tempList)),
                          expand(subst(k+j,k,norm2polyPower(denItem))),k),
     print("shiftRes : ", shiftRes),


     factList : poly2list(factor(shiftRes)),
     print("factList : ", factList),
     intFactList : first(splitList(factList, lambda([y],integerLinear(y,j)))),
     print("intFactList : ", intFactList),
     solList : makeList(second(first(solve(part(intFactList,i),j))),i,1,length(intFactList)),
     print("solList : ", solList),
     intSolList : first(splitList(solList,lambda([y],integerp(y) and (y>=0)))),
     

     if intSolList # [] then
         (

         print("intSolList : ", intSolList),
         minSol : apply(min,intSolList), 
         print("minSol : ", minSol),
         
         numExp : second(first(tempList)),
         denExp : second(denItem),
         minExp : min(numExp,denExp),
         print("numExp : ", numExp),
         print("denExp : ", denExp),
         if numExp = denExp then
             (
             p : p * product(norm2polyPower(subst(k+j,k,denItem)),j,0,minSol-1),
             
             denItem : [1,1],
             tempList : []
             
             )
         else
             (
             item : [first(denItem),minExp],
             
             p : p * product(norm2polyPower(subst(k+j,k,item)),j,0,minSol-1),

             if numExp > denExp then
                (
                candNumList : endcons([first(first(tempList)),numExp-minExp],candNumList),
                denItem : [1,1],
                tempList : []
                )
             else
                (
                denItem : [first(denItem), denExp-minExp],
                tempList : rest(tempList)
                )
             )
         )
     else
         (
         print("no positive integer solutions"),
         candNumList : endcons(first(tempList),candNumList),
         tempList : rest(tempList)
         )

        ),
     r : r * norm2polyPower(denItem),
     candDenList : rest(candDenList)

     ),


print("end of inner loop"),

q : q * product(norm2polyPower(part(candNumList,i)),i,1,length(candNumList))

  ),

print("end of outer loop"),
print("numList : ", numList),
print("denList : ", denList),
if numList # [] then
  q : q * product(norm2polyPower(part(numList,i)),i,1,length(numList)),
if denList # [] then
  r : r * product(norm2polyPower(part(denList,i)),i,1,length(denList)),

print("q : ", q),
print("r : ", r),


/* Interger linear computation */
print("INTEGER LINEAR COMPUTATION"),
numList : intLinNormList(intLinNum,k), 

numList : sort(numList),

denList : intLinNormList(intLinDen,k),

denList : sort(denList),

constSep : intLinConstSep(numList),
normIntLinNum : constSep[1],
intLinNumConst : constSep[2],
print("normIntLinNum : ", normIntLinNum),
print("intLinNumConst : ", intLinNumConst),

constSep : intLinConstSep(denList),
normIntLinDen : constSep[1],
intLinDenConst : constSep[2],
print("normIntLinDen : ", normIntLinDen),
print("intLinDenConst : ", intLinDenConst),

numList : normIntLinNum,
denList : normIntLinDen,

  lengthNumList:length(numList),
  lengthDenList:length(denList),

unless ((numList = []) or (denList = [])) do
  (
  denItem : first(denList),

/* This is an adaptation of Schorn-Riese's Mathematica code */

print("denItem : ", denItem),

print("numList : ", numList),
print("denList : ", denList),


candListSplit : splitList(numList,
                lambda([x],intDistance(first(x),first(denItem)))),

print("NUM) candListSplit : ", candListSplit),


candNumList : first(candListSplit),
print("candNumList : ", candNumList),
numList : second(candListSplit),
candListSplit : splitList(denList,
                 lambda([x],intDistance(first(x),first(denItem)))),

print("DEN) candListSplit : ", candListSplit),


candDenList : first(candListSplit),
print("candDenList : ", candDenList),
denList : second(candListSplit),
     

unless ((candNumList = []) or (candDenList = [])) do
    (
    print("---"),
    diff : first(first(candNumList))-first(first(candDenList)),
    print("diff : ", diff),
    print("inner cycle) candNumList : ", candNumList),
    print("inner cycle) candDenList : ", candDenList),
    if not(integerp(diff)) or (integerp(diff) and (diff<0)) then
       (
       /* q must be updated here */
       print("Gosper-condition satisfied."),
       q : q * norm2polyPower(first(candNumList)),
       candNumList : rest(candNumList)
       )
    else
       (
       print("Gosper-condition NOT satisfied!"),
       /* p must be updated here */
       numExp:second(first(candNumList)),
       denExp:second(first(candDenList)),
       minExp:min(numExp,denExp),
       print("minExp : ", minExp),
       p : p * product(subst(k+i,k,norm2intLin(first(candDenList),k)^minExp),i,0,diff-1),
       print("p computed : ", p),
       if(numExp>denExp) then
          (
          item : [first(first(candNumList)),numExp-minExp],          
          print("item : ", item),
          candNumList : cons(item,rest(candNumList)),
          print("remaining power : ", item),        
          candDenList : rest(candDenList)
          )
       else
          if(numExp<denExp) then
             (
             item : [first(first(candDenList)),denExp-minExp],
             candNumList : rest(candNumList),
             candDenList : cons(item,rest(candDenList))
             )
          else
            (
            candNumList : rest(candNumList),
            candDenList : rest(candDenList)
            )

       )
    ), /* end inner unless cycle */

print("out of inner cycle!"),
  
if (candNumList # []) then
 q : q * product(norm2polyPower(part(candNumList,i)),i,1,length(candNumList)),

print("-----------------------"),
if(candDenList # []) then
 r : r * product(norm2polyPower(part(candDenList,i)),i,1,length(candDenList)),

print("end of between inner/outer cycle!")

 ), /* end unless */

if (numList # []) then
  q : q*product(norm2polyPower(part(numList,i)),i,1,length(numList)),

if (denList # []) then
  r : r*product(norm2polyPower(part(denList,i)),i,1,length(denList)),


r : subst(k-1,k,r),

return([p,q*formSign*intLinNumConst,r*intLinDenConst])


); /* end block */


/* Check Gosper's condition */
/* We are assuming that the input is factored */
/* into irreducible factors */
/* */
/* The numerator is q(k) and the denominator is r(k) */
makeGosperForm(expr,k) :=
  block(
  /* Local variables */
  [num,den,numList,denList,lengthNumList,lengthDenList,
   test,
   i,j,h,minExp,pulledPoly,pPoly,curExp,compPoly,formSign,
   p,q,r,pList,qList,rList,
   negNumFlag,negDenFlag,
   intLinNum,nonIntLinNum,intLinDen,nonIntLinDen,
   sepNumList,sepDenList,
   constIntLinNum, constIntLinDen, constSep, 
   normIntLinNum, normNonIntLinNum, normIntLinDen, normNonIntLinDen,
   numItem, denItem,
   numExp,denExp,minExp,diff,candListSplit,item],
  
if(expr=1) then 
  return([1,1,1]),

num:factor(num(expr)),
den:factor(denom(expr)),


negNumFlag : operatorp(num,"-"),
negDenFlag : operatorp(den,"-"),

if (negNumFlag) then
  num : -1 * num,
if (negDenFlag) then
  den : -1 * den,

if (negNumFlag and not(negDenFlag))or(not(negNumFlag) and negDenFlag) then
   (
   formSign : -1
   )
else
   formSign : 1,

pPoly : 1,


sepNumList:intLinSep(num,k),
sepDenList:intLinSep(den,k),

nonIntLinNum : first(sepNumList),
intLinNum : second(sepNumList),
nonIntLinDen : first(sepDenList),
intLinDen : second(sepDenList),

p:1,
q:1,
r:1,
pList:[],
qList:[],
rList:[],

/* Non-integer linear computation */

numList : normList(nonIntLinNum,k),
denList : normList(nonIntLinDen,k),


constSep : constSep(numList),
normNonIntLinNum : constSep[1],
nonIntLinNumConst : constSep[2],

constSep : constSep(denList),
normNonIntLinDen : constSep[1],
nonIntLinDenConst : constSep[2],

q : q * nonIntLinNumConst,
r : r * nonIntLinDenConst,

numList : normNonIntLinNum,
denList : normNonIntLinDen,

unless ((numList = []) or (denList = [])) do
  (
  denItem : first(denList),
  
  candListSplit : splitList(numList,
                            lambda([x],degreeSelect(x,k,degree(first(denItem),k)))
                           ),
  
  candNumList : first(candListSplit),

  numList : second(candListSplit),
  candListSplit : splitList(denList,
                            lambda([x],degreeSelect(x,k,degree(first(denItem),k)))
                           ),
  
  candDenList : first(candListSplit),
  denList : second(candListSplit),



  unless candDenList = [] do
     (
     denItem : first(candDenList),
     tempList : candNumList,
     candNumList : [],
     unless tempList = [] do
        (

     shiftRes : resultant(norm2polyPower(first(tempList)),
                          expand(subst(k+j,k,norm2polyPower(denItem))),k),

     factList : poly2list(factor(shiftRes)),
     
     intFactList : first(splitList(factList, lambda([y],integerLinear(y,j)))),
     
     solList : makeList(second(first(solve(part(intFactList,i),j))),i,1,length(intFactList)),

     intSolList : first(splitList(solList,lambda([y],integerp(y) and (y>=0)))),
     

     if intSolList # [] then
         (

         minSol : apply(min,intSolList), 
        
         numExp : second(first(tempList)),
         denExp : second(denItem),
         minExp : min(numExp,denExp),

         if numExp = denExp then
             (
             p : p * product(norm2polyPower(subst(k+j,k,denItem)),j,0,minSol-1),
             
             denItem : [1,1],
             tempList : []
             
             )
         else
             (
             item : [first(denItem),minExp],
             
             p : p * product(norm2polyPower(subst(k+j,k,item)),j,0,minSol-1),

             if numExp > denExp then
                (
                candNumList : endcons([first(first(tempList)),numExp-minExp],candNumList),
                denItem : [1,1],
                tempList : []
                )
             else
                (
                denItem : [first(denItem), denExp-minExp],
                tempList : rest(tempList)
                )
             )
         )
     else
         (
         
         candNumList : endcons(first(tempList),candNumList),
         tempList : rest(tempList)
         )

        ),
     r : r * norm2polyPower(denItem),
     candDenList : rest(candDenList)

     ),


  q : q * product(norm2polyPower(part(candNumList,i)),i,1,length(candNumList))

  ),


if numList # [] then
  q : q * product(norm2polyPower(part(numList,i)),i,1,length(numList)),
if denList # [] then
  r : r * product(norm2polyPower(part(denList,i)),i,1,length(denList)),

/* Interger linear computation */

numList : intLinNormList(intLinNum,k), 

numList : sort(numList),

denList : intLinNormList(intLinDen,k),

denList : sort(denList),

constSep : intLinConstSep(numList),
normIntLinNum : constSep[1],
intLinNumConst : constSep[2],

constSep : intLinConstSep(denList),
normIntLinDen : constSep[1],
intLinDenConst : constSep[2],

numList : normIntLinNum,
denList : normIntLinDen,

  lengthNumList:length(numList),
  lengthDenList:length(denList),

unless ((numList = []) or (denList = [])) do
  (
  denItem : first(denList),

/* This is a slight improvement of Schorn-Riese's Mathematica code */


  candListSplit : splitList(numList,
                lambda([x],intDistance(first(x),first(denItem)))),


  candNumList : first(candListSplit),

  numList : second(candListSplit),
  


  candListSplit : splitList(denList,
                 lambda([x],intDistance(first(x),first(denItem)))),



  candDenList : first(candListSplit),

  denList : second(candListSplit),
     

  unless ((candNumList = []) or (candDenList = [])) do
    (    
    diff : first(first(candNumList))-first(first(candDenList)),
    
    if not(integerp(diff)) or (integerp(diff) and (diff<0)) then
       (
       /* q must be updated here */

       q : q * norm2polyPower(first(candNumList)),
       candNumList : rest(candNumList)
       )
    else
       (
       
       /* p must be updated here */
       numExp:second(first(candNumList)),
       denExp:second(first(candDenList)),
       minExp:min(numExp,denExp),
       
       p : p * product(subst(k+i,k,norm2intLin(first(candDenList),k)^minExp),i,0,diff-1),
       
       if(numExp>denExp) then
          (
          item : [first(first(candNumList)),numExp-minExp],          
          
          candNumList : cons(item,rest(candNumList)),
                  
          candDenList : rest(candDenList)
          )
       else
          if(numExp<denExp) then
             (

             item : [first(first(candDenList)),denExp-minExp],
             candNumList : rest(candNumList),
             candDenList : cons(item,rest(candDenList))
             )
          else
            (
            candNumList : rest(candNumList),
            candDenList : rest(candDenList)
            )

       )
    ), /* end inner unless cycle */


  /* r must be updated here */  
if (candNumList # []) then
 q : q * product(norm2polyPower(part(candNumList,i)),i,1,length(candNumList)),


if(candDenList # []) then
 r : r * product(norm2polyPower(part(candDenList,i)),i,1,length(candDenList))


 ), /* end unless */

if (numList # []) then
  q : q*product(norm2polyPower(part(numList,i)),i,1,length(numList)),

if (denList # []) then
  r : r*product(norm2polyPower(part(denList,i)),i,1,length(denList)),



r : subst(k-1,k,r),

return([p,q*formSign*intLinNumConst,r*intLinDenConst])
); /* end block */






/* Macro that extracts p out of the Gosper form */
takeP(GosperForm) ::=
  buildq([GosperForm],first(GosperForm));


/* Macro that extracts q out of the Gosper form */
takeQ(GosperForm) ::=
  buildq([GosperForm],second(GosperForm));


/* Macro that extracts r out of the Gosper form */
takeR(GosperForm) ::=
  buildQ([GosperForm],third(GosperForm));






