/*
       ***************************************************************
       *                    Zeilberger Package                       *
       *                                                             *
       *      Zeilberger is a Maxima implementation of Gosper's      *
       *      and Zeilberger's algorithm for proving and finding     *
       *      indefinite and definite hypergeometric summation       *
       *      identities, implementing Axel Riese's filtering        *
       *      optimization. This is the code discussed in:           *
       *      F. Caruso, A Macsyma Implementation of Zeilberger's    *
       *      Fast Algorithm, RISC-Linz Report Series n. 99-21, J.   *
       *      Kepler University, Linz, 1999.                         *
       *                                                             *
       *                 					     *
       *                                                             *
       *                        Version 2.0                          *
       *                       March 15, 2004                        *
       *             License:  GPL (version 2 or later)              *
       *                                                             *
       *                 --------------------------                  *
       *   Copyright (C) Fabrizio Caruso and the RISC Combinatorics  *
       *   Group, Johannes Kepler Universitaet, Linz, Austria        *
       *                                                             *
       *   Filename:  norm.mac                                       *
       *                                                             *
       ***************************************************************
*/

/* Conversion routines    */
/* by Fabrizio Caruso     */
                                                                                                                             
/* Copyrighted to Fabrizio Caruso and to the RISC Combinatorics Group */
/* Johannes Kepler Universitaet, Linz, Austria                        */


/* It computes the norm of a non-trivial integer linear expression */
intLinConst(intLin,k,n) :=
   intLin - coeff(intLin,n,1)*n - coeff(intLin,k,1)*k;

/* It converts an intLinNorm into an integer linear */
norm2intLin(norm,k) :=
  first(norm);

/* It converts an intLinNorm into a power of an integer linear */
norm2polyPower(norm) :=
  first(norm)^second(norm);


/* Norm of a non-zero degree (in k) integer linear */
intLinPolyNorm(expr,k) :=
   if(freeof(k,expr)) then
      [expr,1]
   else
      [expand(expr/coeff(expr,k,1)),coeff(expr,k,1)];

polyNorm(expr,k) :=
   if (freeof(k,expr)) then
      [expr,1]
   else
      [expand(expr/coeff(expr,k,degree(expr,k))),
       coeff(expr,k,degree(expr,k))];

intLinNorm(expr,k) :=
 block([polyNorm,res,constRes],
  if operatorp(expr,"^") then
     (
     polyNorm : intLinPolyNorm(first(expr),k),
     res : [polyNorm[1],second(expr)],
     constRes : polyNorm[2]^second(expr)
     )
  else
     (
     polyNorm : intLinPolyNorm(expr,k),
     res : [polyNorm[1],1],
     constRes : polyNorm[2]
     ),
  return([res,constRes])
  );    


powerNorm(expr,k) :=
  block([base,res,constRes],
  if operatorp(expr,"^") then
     (
     base : polyNorm(first(expr),k),
     res : [base[1],second(expr)],
     constRes : base[2]^second(expr)
     )
  else
     (
     base : polyNorm(expr,k),
     res : [base[1],1],
     constRes : base[2]
     ),
  return([res,constRes])
  );    

 
/* It outputs the integer linear factor and non-integer linear factor of a given expression */                                                 
intLinSep(expr,k) :=
  block(
  [nonIntLinList,intLinList,length],

  nonIntLinList:[],
  intLinList:[],
  if atom(expr) or not(operatorp(expr,"*")) then
     if(integerLinear(expr,k)) then
       if (expr=1) then
           return([[],[]])
       else
        return([[],[expr]])
     else
        return([[expr],[]])
  else
     (
     length:length(expr),

     for i:1 thru length-1 do
       (
       if integerLinear(first(expr),k) then 
         intLinList:cons(first(expr),intLinList)
       else
         nonIntLinList:cons(first(expr),nonIntLinList),
       expr:expr/first(expr)
       ),
     if integerLinear(expr,k) then
      intLinList:cons(expr,intLinList)
     else 
      nonIntLinList:cons(expr,nonIntLinList),

     return([nonIntLinList,intLinList])
     )
  );


/* It creates a list of irreducible factors out of a factorized polynomial */
factored2List(expr) :=
  block(
  [list,length,i],

  list:[],
  if atom(expr)or not(operatorp(expr,"*")) then
     return([expr])
  else
     (
     length:length(expr),
     for i:1 thru length-1 do
       (
       list:cons(first(expr),list),
       expr:expr/first(expr)
       ),
     list:cons(expr,list),
     return(list)
     )
  );


/* It generates a list of normalized powers of integer linears */
intLinNormList(exprList,k) :=
  block([res,i],
   res:[],
   for i:1 thru length(exprList) do
      res:cons(intLinNorm(part(exprList,i),k),res),
          
   return(res)
   );

normList(exprList,k) :=
   block([res,i],
   res:[],
   for i:1 thru length(exprList) do
      res:cons(powerNorm(part(exprList,i),k),res),
   return(res)
   );



