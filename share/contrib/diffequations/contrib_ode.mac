/* contrib_ode.mac

  Driver for contributed ODE routines


  Copyright (C) 2004 David Billinghurst		 
  		       								 
  This program is free software; you can redistribute it and/or modify	 
  it under the terms of the GNU General Public License as published by	 
  the Free Software Foundation; either version 2 of the License, or		 
  (at your option) any later version.					 
 		       								 
  This program is distributed in the hope that it will be useful,		 
  but WITHOUT ANY WARRANTY; without even the implied warranty of		 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		 
  GNU General Public License for more details.				 
 		       								 
  You should have received a copy of the GNU General Public License	
  along with this program; if not, write to the Free Software 		 
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.	
*/

declare(method,special);

if get('ode1_nonlinear,'version)=false then
  load('ode1_nonlinear)$

if get('odelin,'version)=false then
  load('odelin)$

contrib_ode(eqn,y,x) := block(
  [soln,degree:derivdegree(eqn,y,x)],
  
  ode_disp("-> ode_contrib"),

  /* Try ode2 if first or second order*/
  if (degree < 1) then (
    ode_disp("   Degree of equation less than 1"),
    false
  ) 
  else if (degree > 2) then (
    ode_disp("   Degree of equation greater then 2"),
    false
  ) 
  else if (degree=1) then (
    ode_disp("   First order equation"),
    ode_disp("   -> ode2"),
    soln:ode2(eqn,y,x),
    if (soln#false) then (
      ode_disp("    Successful"),
      return([soln])
    )
    else (
      return(ode1_nonlinear(eqn,y,x))
    )
  )
  else if (degree=2) then (
    return(ode2_linear(eqn,y,x))
  )
  else (
    error("contrib_ode: This case cannot occur"),
    false
  )
)$

/* Try methods for linear 2nd order ODEs.
   eqn is a 2nd order ODE.
   FIXME: Remove multiple checks for linearity 
*/
ode2_linear(eqn,y,x) := block(
  [de,a1,a2,a3,a4,soln,%k1,%k2],
  ode_disp("   Second order equation"),
  de: desimp(lhs(eqn)-rhs(eqn)),
  a1: coeff(de,'diff(y,x,2)), 
  a2: coeff(de,'diff(y,x)), 
  a3: coeff(de,y),
  a4: expand(de - a1*'diff(y,x,2) - a2*'diff(y,x) - a3*y),
  if (freeof(y,[a1,a2,a3,a4])) then (
    ode_disp("     Linear 2nd order ODE"),
    /* Try the ode2 routines first */
    ode_disp("    -> ode2"),
    soln:ode2(eqn,y,x),
    if (soln#false) then (
      ode_disp("     Successful"),
      [soln]
    ) else if is(a4=0) then (
      /* Now try the routines in odelin */
      ode_disp("    -> odelin"),
      soln:odelin(eqn,y,x),
      if (soln#false) then (
        ode_disp("     Successful"),
        method:'odelin,
        ode_disp(soln),
        /* odelin returns a fundamental soln set */
        soln:listify(soln),
        [y=%k1*soln[1]+%k2*soln[2]]
      ) else (
        false
      )
    )
  ) else (
    ode_disp("     Non-linear 2nd order ODE"),
    false
  )
)$

ode_disp(msg) := block(
  if get('contrib_ode,'verbose) then print(msg)
)$

ode_disp2(msg,e) := block(
  if get('contrib_ode,'verbose) then print(msg,e)
)$

/* recurse through expression eq looking for a derivative
   Return the derivative if found, false otherwise
 */
ode_deriv(eq) := block( 
  [u,v:false],
  eq:expand(eq),
  if atom(eq) then return(false),
  if operatorp(eq,nounify('diff)) then return(eq),
  for u in eq do 
    (if (v:ode_deriv(u))#false then return(true)),
  v
)$

/* Check the solution of an ode. */
ode_check(e_,a_) := block(
  [deriv,x_,y_,diff_e,u,v],

  deriv:ode_deriv(e_),
  if deriv=false then (
    print("Not a differential equation"),
    return(false)
  ),
  x_:part(deriv,2),  /* Independent variable */
  y_:part(deriv,1),  /* Dependent variable */

  if not(atom(x_)) then (
    print("Independent variable ",x_," not an atom"),
    return(false)
  ),
  if not(atom(y_)) then (
    print("Dependent variable ",y_," not an atom"),
    return(false)
  ),

  /* Is it a simple solution */
  if lhs(a_)=y_ then (
    return(ratsimp(ev(lhs(e_)-rhs(e_),a_,diff)))
  ),

  /* Must be an implicit solution */
  diff_e:diff(subst(v(x),y_,a_),x_),
  diff_e:subst(y_,v(x),diff_e),
  u:solve(diff_e,'diff(y_,x_)),
  if u=[] then (
    print("Problem - dy/dx is ",u),
    return(false)
  ),
  u:first(u),
  if ( lhs(u)#'diff(y_,x_) or not(freeof('diff(y_,x_),rhs(u))) ) then (
    print("Problem - dy/dx is ",u),
    return(false)
  ),
  fullratsimp(ev(lhs(e_)-rhs(e_),u))
)$
