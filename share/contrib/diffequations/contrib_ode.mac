/* contrib_ode.mac

  Driver for contributed ODE routines


  Copyright (C) 2004 David Billinghurst		 
  		       								 
  This program is free software; you can redistribute it and/or modify	 
  it under the terms of the GNU General Public License as published by	 
  the Free Software Foundation; either version 2 of the License, or		 
  (at your option) any later version.					 
 		       								 
  This program is distributed in the hope that it will be useful,		 
  but WITHOUT ANY WARRANTY; without even the implied warranty of		 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		 
  GNU General Public License for more details.				 
 		       								 
  You should have received a copy of the GNU General Public License	
  along with this program; if not, write to the Free Software 		 
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.	
*/

if get('ode1_nonlinear,'version)=false then
  load('ode1_nonlinear)$

contrib_ode(eqn,y,x) := block(
  [soln,degree:derivdegree(eqn,y,x)],
  
  ode_disp("-> ode_contrib"),

  /* Try ode2 if first or second order*/
  if (degree < 1) then (
    ode_disp("   Degree of equation less than 1"),
    false
  ) 
  else if (degree > 2) then (
    ode_disp("   Degree of equation greater then 2"),
    false
  ) 
  else if (degree=1) then (
    ode_disp("   First order equation"),
    ode_disp("   -> ode2"),
    soln:ode2(eqn,y,x),
    if (soln#false) then (
      ode_disp("    Successful"),
      return([soln])
    )
    else (
      return(ode1_nonlinear(eqn,y,x))
    )
  )
  else if (degree=2) then (
    ode_disp("   Second order equation"),
    ode_disp("    -> ode2"),
    soln:ode2(eqn,y,x),
    if (soln#false) then (
      ode_disp("     Successful"),
      [soln]
    )
    else
      false
  )
  else (
    error("contrib_ode: This case cannot occur"),
    false
  )
)$

ode_disp(msg) := block(
  if get('contrib_ode,'verbose) then print(msg)
)$

ode_disp2(msg,e) := block(
  if get('contrib_ode,'verbose) then print(msg,e)
)$

/* recurse through expression eq looking for a derivative
   Return the derivative if found, false otherwise
 */
ode_deriv(eq) := block( 
  [u,v:false],
  eq:expand(eq),
  if atom(eq) then return(false),
  if operatorp(eq,nounify('diff)) then return(eq),
  for u in eq do 
    (if (v:ode_deriv(u))#false then return(true)),
  v
)$

/* Check the solution of an ode. */
ode_check(e_,a_) := block(
  [deriv,x_,y_,diff_e,u,v],

  deriv:ode_deriv(e_),
  if deriv=false then (
    print("Not a differential equation"),
    return(false)
  ),
  x_:part(deriv,2),  /* Independent variable */
  y_:part(deriv,1),  /* Dependent variable */

  if not(atom(x_)) then (
    print("Independent variable ",x_," not an atom"),
    return(false)
  ),
  if not(atom(y_)) then (
    print("Dependent variable ",y_," not an atom"),
    return(false)
  ),

  /* Is it a simple solution */
  if lhs(a_)=y_ then (
    return(ratsimp(ev(lhs(e_)-rhs(e_),a_,diff)))
  ),

  /* Must be an implicit solution */
  diff_e:diff(subst(v(x),y_,a_),x_),
  diff_e:subst(y_,v(x),diff_e),
  u:solve(diff_e,'diff(y_,x_)),
  if u=[] then (
    print("Problem - dy/dx is ",u),
    return(false)
  ),
  u:first(u),
  if ( lhs(u)#'diff(y_,x_) or not(freeof('diff(y_,x_),rhs(u))) ) then (
    print("Problem - dy/dx is ",u),
    return(false)
  ),
  fullratsimp(ev(lhs(e_)-rhs(e_),u))
)$
