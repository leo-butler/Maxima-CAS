\input texinfo
@setfilename numericalio.info
@settitle numericalio

@ifinfo 
@macro var {expr}
<\expr\>
@end macro
@end ifinfo

@node Top, Introduction to numericalio, (dir), (dir)
@top
@menu
* Introduction to numericalio::
* Definitions for numericalio::
* Function and variable index::
@end menu

@node Introduction to numericalio, Definitions for numericalio, Top, Top
@section Introduction to numericalio

@code{numericalio} is a collection of functions to read and write data files.
The entire file is read to construct one object;
partial reads are not supported.

It is assumed that each item to read or write is atomic:
an integer, float, bigfloat, string, or symbol,
and not a rational or complex number or any other kind of nonatomic expression.
These functions may attempt to do something sensible faced with nonatomic expressions,
but the results are not specified here and subject to change.

Atoms in both input and output files have the same format as
in Maxima batch files or the interactive console.
In particular, strings are enclosed in double quotes,
backslash @code{\} prevents any special interpretation of the next character,
and the question mark @code{?} is recognized at the beginning of a symbol
to mean a Lisp symbol (as opposed to a Maxima symbol).
No continuation character (to join broken lines) is recognized.

@var{separator_flag} tells which character separates elements.
It is an optional argument for all read and write functions.

For input, these values of @var{separator_flag} are recognized:
@code{comma} for comma separated values,
@code{pipe} for values separated by the vertical bar character @code{|},
@code{semicolon} for values separated by semicolon @code{;}, 
and @code{space} for values separated by space or tab characters.
If the file name ends in @code{.csv} and @var{separator_flag} is not specified,
@code{comma} is assumed.
If the file name ends in something other than @code{.csv} and @code{separator_flag} is not specified,
@code{space} is assumed.

For output, the same four flags are recognized as for input,
and also @code{tab}, for values separated by the tab character.

In input, multiple successive space and tab characters count as a single separator.
However, multiple comma, pipe, or semicolon characters are significant.
Successive comma, pipe, or semicolon characters (with or without intervening spaces or tabs)
are considered to have @code{false} between the separators.
For example, @code{1234,,Foo} is treated the same as @code{1234,false,Foo}.
In output, @code{false} atoms are written as such;
a list @code{[1234, false, Foo]} is written @code{1234,false,Foo},
and there is no attempt to collapse the output to @code{1234,,Foo}.

@node Definitions for numericalio, Function and variable index, Introduction to numericalio, Top
@section Definitions for numericalio

@deffn {Function} read_matrix (@var{file_name})
@deffnx {Function} read_matrix (@var{file_name}, @var{separator_flag})
Reads the file @var{file_name} and returns its entire content as a matrix.
If @var{separator_flag} is not specified, the file is assumed space-delimited.

@code{read_matrix} infers the size of the matrix from the input data.
Each line of the file becomes one row of the matrix.
If some lines have different lengths, @code{read_matrix} complains.

@end deffn

@deffn {Function} read_lisp_array (@var{file_name}, @var{A})
@deffnx {Function} read_lisp_array (@var{file_name}, @var{A}, @var{separator_flag})

@code{read_lisp_array} requires that the array
be declared by @code{make_array} before calling
the read function. (This obviates the need to infer the array 
dimensions, which could be a hassle for arrays with multiple dimensions.)

@code{read_lisp_array} does not check to see that the 
input file conforms in some way to the array dimensions; the input
is read as a flat list, then the array is filled using @code{fillarray}.

@end deffn

@deffn {Function} read_maxima_array (@var{file_name}, @var{A})
@deffnx {Function} read_maxima_array (@var{file_name}, @var{A}, @var{separator_flag})

@code{read_maxima_array} requires that the array
be declared by @code{array} before calling
the read function. (This obviates the need to infer the array 
dimensions, which could be a hassle for arrays with multiple dimensions.)

@code{read_maxima_array} does not check to see that the 
input file conforms in some way to the array dimensions; the input
is read as a flat list, then the array is filled using @code{fillarray}.

@end deffn

@deffn {Function} read_hashed_array (@var{file_name}, @var{A})
@deffnx {Function} read_hashed_array (@var{file_name}, @var{A}, @var{separator_flag})

@code{read_hashed_array} treats the first item on a line as a
hash key, and associates the remainder of the line (as a list) with the key.
For example,
the line @code{567 12 17 32 55} is equivalent to @code{A[567]: [12, 17, 32, 55]$}.
Lines need not have the same numbers of elements.

@end deffn

@deffn {Function} read_nested_list (@var{file_name})
@deffnx {Function} read_nested_list (@var{file_name}, @var{separator_flag})

@code{read_nested_list} returns a list which has a sublist for each
line of input. Lines need not have the same numbers of elements.
Empty lines are @i{not} ignored: an empty line yields an empty sublist.

@end deffn

@deffn {Function} read_list (@var{file_name})
@deffnx {Function} read_list (@var{file_name}, @var{separator_flag})

@code{read_list} reads all input into a flat list.
@code{read_list} ignores end-of-line characters.

@end deffn

@deffn {Function} write_data (@var{X}, @var{file_name})
@deffnx {Function} write_data (@var{object}, @var{file_name}, @var{separator_flag})

@code{write_data} writes the object @var{X} to the file @var{file_name}.

@code{write_data} writes matrices in row-major form,
with one line per row.

@code{write_data} writes Lisp and Maxima declared arrays in
row-major form, with a new line at the end of every slab.
Higher-dimensional slabs are separated by additional new lines.

@code{write_data} writes hashed arrays with a key followed by
the associated list on each line.

@code{write_data} writes a nested list with each sublist on one line.

@code{write_data} writes a flat list all on one line.

Whether @code{write_data} appends or truncates its output file
is governed by the global variable @code{file_output_append}.

@end deffn

@node Function and variable index,  , Definitions for numericalio, Top
@appendix Function and variable index
@printindex fn
@printindex vr

@bye
