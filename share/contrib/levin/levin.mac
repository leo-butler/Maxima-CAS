/* levin.mac v0.2.1 (c) Michel Van den Bergh   Licence: GPL.
0.0->0.1 Some suggestions by Richard Fateman incorporated
0.1->0.2 Now much faster. Zero entries are allowed.
0.2->0.2.1 Disable bflevin_u_sum for series with non rational terms
*/

/* see:  "Mathematical Properties of a
New Levin-Type Sequence Transformation"
by Ernst Joachim Weniger
Formula: (2.18)
arXiv:math-ph/0306063 */

levin_debug:false;

/* s     : array with partial sums of a series
   k+1   : number of partial sums to use
   n     : index of first partial sum to be used;
           in other words, we use: s[n],...,s[n+k]
   beta  : translation parameter; this parameter can be used to avoid division
           by zero;
   omega : an array of remainder estimates;
           depending on omega one gets a different type of levin
           transform; omega should not contain zero entries 
           or we get a division by zero */


levin(s,k,n,beta,omega):=block([i,j,numerator,denonimator],
  numerator:sum(((-1)^j)*binomial(k,j)*
             ((beta+n+j)^(k-1)/(beta+n+k)^(k-1))*
             (subvar(s,n+j)/subvar(omega,n+j)),
             j,0,k),
  denominator:sum(((-1)^j)*binomial(k,j)*
             ((beta+n+j)^(k-1)/(beta+n+k)^(k-1))*
             (1/subvar(omega,n+j)),
             j,0,k),
  numerator/denominator
);

/* Here we delete zero entries and compute the partial sums. We also
   set omega such that we get the levin_u transform.  In addition we 
   set beta=0 and n=1. Perhaps we should try several different values
   for beta in case division by zero occurs. */

levin_u(a,terms):=block([i,j,l,n,beta,last,omega_,t_,b_],
  local(omega_,t_,b_),
  n:1,
  beta:0,
  /* remove zeros */
  j:0,
  for i:0 thru terms-1 do (
      if sign(abs(subvar(a,i)))#zero then (
      b_[j]:subvar(a,i),
      j:j+1
    ) else (
      if levin_debug then print("ommitting zero term with index ",i)
    )
  ),
  last:j-1,
  omega_[l]:=l*b_[l],
  t_[l]:=t_[l-1]+b_[l],
  t_[-1]:0,
  levin(t_,last-n,n,beta,omega_)
);

/* User friendly version.

   Example
                               3899836039
   levin_u_sum(1/n^2,n,1,10) = ---------- = 1.644934081345832
                               2370816000
                       1968329
   sum(1/n^2,n,1,10) = ------- = 1.549767731166541
                       1270080

   sum(1/n^2,n,1,inf) = %pi^2/6 = 1.644934066848226  */

levin_u_sum(a_,index_var,start,terms):=block([n,c_,dummy],
  local(c_),
  for n:0 thru terms-1 do (
             dummy:subst(start+n,index_var,a_),
             c_[n]:ev(dummy,eval) ),
   levin_u(c_,terms) 
);

/* Numerical version. This function makes a crude attempt to compute
   an indefinite sum numerically with precision given by fpprec.
   This works (usually) for functions that take rational values only!
   For other functions the intermediate computations much be done in much
   greater precision. In that case use levin_u_sum with an appropriate number of terms.
   If you suspect something is wrong put levin_debug:true.
*/

bflevin_u_sum(a_,index_var,start):=block([n,fpprec_save,old,new,value,first_time,
               count,terms,begin_term,end_term,dummy,non_rational,c_],
  local(c_),
  fpprec_save:fpprec,
  fpprec:fpprec+6,
  first_time:true,
  count:0,
  terms:5,
  non_rational:false,
  value:do (
    if first_time then (
      begin_term:0,
      end_term:terms-1
    ) else (
      begin_term:terms/2,
      end_term:2*terms-1
    ),
    for n:begin_term thru end_term do (
                   dummy:subst(start+n,index_var,a_),
                   c_[n]:ev(dummy,eval),
                   if not(ratnump(c_[n])) and not(non_rational) then (
                     print(
"*** bflevin_u_sum does not work (yet) for series with non rational terms. ***"
                     ),
                     non_rational:true,
                     return(failed)
                   )
               ),
    if non_rational then return(bflevin_u_sum_failed),
    new:levin_u(c_,terms),
    new:bfloat(new),
    if not(first_time) then (
      if levin_debug then print("terms=",terms, " approximation=",new),
      if equal(old,bfloat(0)) and equal(new,bfloat(0)) then return(bfloat(0)),
      if abs(old-new)/max(abs(old),abs(new))<10^(-fpprec_save-3) then return(new),
      if (count:count+1)>10 then return(bflevin_u_sum_failed)
    ),
    terms:2*terms,
    old:new,
    first_time:false
  ),
  fpprec:fpprec_save,
  bfloat(value)
);


