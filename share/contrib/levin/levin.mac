/*               COPYRIGHT NOTICE
 
Copyright (C) 2006-2007 Michel Van den Bergh
 
This program is free software; you can redistribute
it and/or modify it under the terms of the
GNU General Public License as published by
the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
 
This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details at
http://www.gnu.org/copyleft/gpl.html
*/

/* The latest version of this package can be found at
          http://www.bertold.org/levin
*/



/*
0.0->0.1 Some suggestions by Richard Fateman incorporated
0.1->0.2 Now much faster. Zero entries are allowed.
0.2->0.2.1 Disable bflevin_u_sum for series with non rational terms
0.2->0.3 Argument treatment somewhat more robust. Added GPL header.
0.3->0.4 Extra checks on arguments.
         Variable lower bound for levin_u_sum is treated correctly.
*/

/* see:  "Mathematical Properties of a
New Levin-Type Sequence Transformation"
by Ernst Joachim Weniger
Formula: (2.18)
arXiv:math-ph/0306063 */

levin_options["debug"]:false;  /* when true gives some extra output; should
                                        really be a loglevel */
levin_options["initial_terms"]:5;    /* bflevin_u_sum starts with 5 terms */
levin_options["max_iters"]:7;         /* bflevin_u_sum tries up to 5*2^7 terms
                                         before bailing out */

/* s     : array with partial sums of a series
   k+1   : number of partial sums to use
   n     : index of first partial sum to be used;
           in other words, we use: s[n],...,s[n+k]
   beta  : translation parameter; this parameter can be used to avoid division
           by zero;
   omega : an array of remainder estimates;
           depending on omega one gets a different type of levin
           transform; omega should not contain zero entries 
           or we get a division by zero */


levin(s,k,n,beta,omega):=block([i__,j__,numerator__,denominator__,value__,
                               k__,n__,beta__,omega__,s__],
  k__:k,
  n__:n,
  beta__:beta,
  s__:s,
  omega__:omega,
  remvalue(k,n,beta,s,omega),
  numerator__:sum(((-1)^j__)*binomial(k__,j__)*
             ((beta__+n__+j__)^(k__-1)/(beta__+n__+k__)^(k__-1))*
             (subvar(s__,n__+j__)/subvar(omega__,n__+j__)),
             j__,0,k__),
  denominator__:sum(((-1)^j__)*binomial(k__,j__)*
             ((beta__+n__+j__)^(k__-1)/(beta__+n__+k__)^(k__-1))*
             (1/subvar(omega__,n__+j__)),
             j__,0,k__),
  value__:errcatch(numerator__/denominator__),
  if value__=[] then (
     print (
"*** levin has zero denominator ***"
     ),
     return(levin_failed)
  ),
  return(first(value__))
);

/* Here we delete zero entries and compute the partial sums. We also
   set omega such that we get the levin_u transform.  In addition we 
   set beta=0 and n=1. Perhaps we should try several different values
   for beta in case division by zero occurs. */

levin_u(a,terms):=block([i__,j__,l__,n__,beta__,last__,
                            omega__,t__,b__,terms__i,a__],
  terms__:terms,
  a__:a,  
  remvalue(terms,a),
  local(omega__,t__,b__),
  n__:1,
  beta__:0,
  /* remove zeros */
  j__:0,
  for i__:0 thru terms__-1 do (
      if sign(abs(subvar(a__,i__)))#zero then (
      b__[j__]:subvar(a__,i__),
      j__:j__+1
    ) else (
      if levin_options["debug"] then print("ommitting zero term with index ",i)
    )
  ),
  last__:j__-1,
  if last__<0 then (
    return(0)            /* best effort */
  ),
  if last__=0 then (
     return(b__[0])       /* best effort */
  ),
  omega__[l__]:=l__*b__[l__],
  t__[l__]:=t__[l__-1]+b__[l__],
  t__[-1]:0,
  levin(t__,last__-n__,n__,beta__,omega__)
);

/* User friendly version.

   Example
                               3899836039
   levin_u_sum(1/n^2,n,1,10) = ---------- = 1.644934081345832
                               2370816000
                       1968329
   sum(1/n^2,n,1,10) = ------- = 1.549767731166541
                       1270080

   sum(1/n^2,n,1,inf) = %pi^2/6 = 1.644934066848226  */

/* Robert Dodier: */
levin_check_lvalue(e__):=(symbolp(e__) or (subvarp(e__) and levin_check_lvalue(part(e__,0)))) and not ?mstringp(e__);

levin_u_sum(a,index_var,start,terms):=block([n__,c__,a__,start__,index_var__,
                                            terms__],
  local(c__),
  a__:a,
  start__:start,
  index_var__:index_var,
  terms__:terms,
  remvalue(a,index_var,start,terms), /* make sure things will be evaluated 
                       correctly in case a contains a parameter name */
  if not(integerp(terms__)) or not(constantp(terms__)) or terms__<0 then (
     print (
"*** levin_u_sum needs a positive constant integral number of terms ***"
     ),
     return(levin_u_sum_failed)
  ),
  if not(levin_check_lvalue(index_var__)) then (
     print (
"**** ",index_var," is not an lvalue ***"
     ),
     return(levin_u_sum_failed)
  ),
  for n__:0 thru terms__-1 do (
             c__[n__]:subst(start__+n__,index_var__,a__),
             c__[n__]:ev(c__[n__],eval) /* add evaluation round to tidy things up */
   ) ,    
   levin_u(c__,terms__) 
);

/* Numerical version. This function makes a crude attempt to compute
   an indefinite sum numerically with precision given by fpprec.
   This works (usually) for functions that take rational values only!
   For other functions the intermediate computations much be done in much
   greater precision. In that case use levin_u_sum with an appropriate number of terms.
   If you suspect something is wrong put levin_options["debug"]:true.
*/

bflevin_u_sum(a,index_var,start):=block([n__,fpprec_save__,old__,new__,value__,
                              first_time__, count__,terms__,begin_term__,
                               end_term__,non_rational__,c__,a__,start__, 
                               index_var__,fpprec:fpprec],
  local(c__),
  fpprec_save__:fpprec,
  fpprec:fpprec+6,
  first_time__:true,
  count__:1,
  terms__:levin_options["initial_terms"],
  non_rational__:false,
  a__:a,
  start__:start,
  index_var__:index_var,
  remvalue(a,index_var,start), /* make sure things will be evaluated correctly
                          in case a contains a parameter name */
  if not(levin_check_lvalue(index_var__)) then (
     print (
"**** ",index_var__," is not an lvalue ***"
     ),
     return(bflevin_u_sum_failed)
  ),
  value__:do (
    if first_time__ then (
      begin_term__:0,
      end_term__:terms__-1
    ) else (
      begin_term__:terms__/2,
      end_term__:2*terms__-1
    ),
   for n__:begin_term__ thru end_term__ do (
             c__[n__]:subst(start__+n__,index_var__,a__),
             c__[n__]:ev(c__[n__],eval),
             if not(ratnump(c__[n__])) then (
                     print(
"*** bflevin_u_sum does not work (yet) for series with non rational terms. ***"
                     ),
                   non_rational__:true,
                   return(failed)
                   )
   ),
    if non_rational__ then return(bflevin_u_sum_failed),
    new__:levin_u(c__,terms__),
    if constantp(new__) then new__:bfloat(new__) else return(new__),
    if not(first_time__) then (
      if levin_options["debug"] then print("terms=",terms__, " approximation=",new__),
      if equal(old__,bfloat(0)) and equal(new__,bfloat(0)) then return(bfloat(0)),
      if abs(old__-new__)/max(abs(old__),abs(new__))<10^(-fpprec_save__-3)
                           then return(new__)
    ),
    if count__>levin_options["max_iters"] then (
        print (
"*** bflevin_u_sum did not obtain the required precision using ",terms__," terms ***"
        ),
        return(bflevin_u_sum_failed)
    ),
    terms__:2*terms__,
    old__:new__,
    first_time__:false,
    count__:count__+1
  ),
  fpprec:fpprec_save__,
  bfloat(value__)
);


