/*               COPYRIGHT NOTICE
 
Copyright (C) 2006-2007 Michel Van den Bergh
 
This program is free software; you can redistribute
it and/or modify it under the terms of the
GNU General Public License as published by
the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
 
This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details at
http://www.gnu.org/copyleft/gpl.html
*/





/*
0.0->0.1 Some suggestions by Richard Fateman incorporated
0.1->0.2 Now much faster. Zero entries are allowed.
0.2->0.2.1 Disable bflevin_u_sum for series with non rational terms
0.2->0.3 Argument treatment somewhat more robust. Added GPL header.
*/

/* see:  "Mathematical Properties of a
New Levin-Type Sequence Transformation"
by Ernst Joachim Weniger
Formula: (2.18)
arXiv:math-ph/0306063 */

levin_debug:false;

/* s     : array with partial sums of a series
   k+1   : number of partial sums to use
   n     : index of first partial sum to be used;
           in other words, we use: s[n],...,s[n+k]
   beta  : translation parameter; this parameter can be used to avoid division
           by zero;
   omega : an array of remainder estimates;
           depending on omega one gets a different type of levin
           transform; omega should not contain zero entries 
           or we get a division by zero */


levin(s,k,n,beta,omega):=block([i,j,numerator,denonimator],
  numerator:sum(((-1)^j)*binomial(k,j)*
             ((beta+n+j)^(k-1)/(beta+n+k)^(k-1))*
             (subvar(s,n+j)/subvar(omega,n+j)),
             j,0,k),
  denominator:sum(((-1)^j)*binomial(k,j)*
             ((beta+n+j)^(k-1)/(beta+n+k)^(k-1))*
             (1/subvar(omega,n+j)),
             j,0,k),
  numerator/denominator
);

/* Here we delete zero entries and compute the partial sums. We also
   set omega such that we get the levin_u transform.  In addition we 
   set beta=0 and n=1. Perhaps we should try several different values
   for beta in case division by zero occurs. */

levin_u(a,terms):=block([i,j,l,n,beta,last,omega__,t__,b__],
  local(omega__,t__,b__),
  n:1,
  beta:0,
  /* remove zeros */
  j:0,
  for i:0 thru terms-1 do (
      if sign(abs(subvar(a,i)))#zero then (
      b__[j]:subvar(a,i),
      j:j+1
    ) else (
      if levin_debug then print("ommitting zero term with index ",i)
    )
  ),
  last:j-1,
  omega__[l]:=l*b__[l],
  t__[l]:=t__[l-1]+b__[l],
  t__[-1]:0,
  levin(t__,last-n,n,beta,omega__)
);

/* User friendly version.

   Example
                               3899836039
   levin_u_sum(1/n^2,n,1,10) = ---------- = 1.644934081345832
                               2370816000
                       1968329
   sum(1/n^2,n,1,10) = ------- = 1.549767731166541
                       1270080

   sum(1/n^2,n,1,inf) = %pi^2/6 = 1.644934066848226  */

levin_u_sum(a,index_var,start,terms):=block([n,c__,a__,start__,index_var__],
  local(c__),
  a__:a,
  start__:start,
  index_var__:index_var,
  remvalue(a,index_var,start), /* make sure things will be evaluated correctly
                          in case a contains a parameter name */
  for n:0 thru terms-1 do (
             c__[n]:subst(start__+n,index_var__,a__),
             c__[n]:ev(c__[n],eval) /* add evaluation round to tidy things up */
   ) ,    
   levin_u(c__,terms) 
);

/* Numerical version. This function makes a crude attempt to compute
   an indefinite sum numerically with precision given by fpprec.
   This works (usually) for functions that take rational values only!
   For other functions the intermediate computations much be done in much
   greater precision. In that case use levin_u_sum with an appropriate number of terms.
   If you suspect something is wrong put levin_debug:true.
*/

bflevin_u_sum(a,index_var,start):=block([n,fpprec_save,old,new,value,first_time,
               count,terms,begin_term,end_term,non_rational,c__,a__,start__,
               index_var__],
  local(c__),
  fpprec_save:fpprec,
  fpprec:fpprec+6,
  first_time:true,
  count:0,
  terms:5,
  non_rational:false,
  a__:a,
  start__:start,
  index_var__:index_var,
  remvalue(a,index_var,start), /* make sure things will be evaluated correctly
                          in case a contains a parameter name */
  value:do (
    if first_time then (
      begin_term:0,
      end_term:terms-1
    ) else (
      begin_term:terms/2,
      end_term:2*terms-1
    ),
   for n:begin_term thru end_term do (
             c__[n]:subst(start__+n,index_var__,a__),
             c__[n]:ev(c__[n],eval),
             if not(ratnump(c__[n])) then (
                     print(
"*** bflevin_u_sum does not work (yet) for series with non rational terms. ***"
                     ),
                   non_rational:true,
                   return(failed)
                   )
   ),
    if non_rational then return(bflevin_u_sum_failed),
    new:levin_u(c__,terms),
    new:bfloat(new),
    if not(first_time) then (
      if levin_debug then print("terms=",terms, " approximation=",new),
      if equal(old,bfloat(0)) and equal(new,bfloat(0)) then return(bfloat(0)),
      if abs(old-new)/max(abs(old),abs(new))<10^(-fpprec_save-3) then return(new),
      if (count:count+1)>10 then return(bflevin_u_sum_failed)
    ),
    terms:2*terms,
    old:new,
    first_time:false
  ),
  fpprec:fpprec_save,
  bfloat(value)
);


