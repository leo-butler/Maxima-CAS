/* augmented Lagrangian method for constrained optimization
 *
 * See http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html
 * and http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf
 *
 * At present this code minimizes the augmented Lagrangian by
 * solving for a stationary point of its gradient.
 * That's pretty weak, and the code could be improved by plugging in
 * a conjugate gradient or quasi-Newton minimization algorithm.
 *
 * FOM         = figure of merit expression
 * xx          = list of variables over which to minimize
 * constraints = list of expressions to be held equal to zero
 * yy          = list of initial guesses for xx
 *
 * mnewton (to solve grad L = 0) has to be loaded before calling augmented_lagrangian_method.
 *
 * Example:
 *
 * load (mnewton);
 * FOM: x^2 + 2*y^2;
 * xx: [x, y];
 * C: [x + y - 1]; 
 * yy: [1, 1];
 * augmented_lagrangian_method (FOM, xx, C, yy);
 *
 *  => [0.6478349834, 0.3239174917]
 *
 * copyright Robert Dodier, October 2005
 * Released under the terms of the GNU Public License
 */

niter: 10;

augmented_lagrangian_method (FOM, xx, constraints, yy) := 

  block ([n, augmented_lagrangian, augmented_lagrangian_gradient, %lambda, %nu],

  nc: length (constraints),

  augmented_lagrangian: FOM
    + apply ("+", makelist (%lambda[i] * constraints[i], i, 1, nc))
    + apply ("+", makelist (%nu[i] * constraints[i]^2, i, 1, nc)),

  augmented_lagrangian_gradient: map (lambda ([a], diff (augmented_lagrangian, a)), xx),

  %lambda: makelist (1, i, 1, nc),

  %nu: makelist (1, i, 1, nc),

  for i:1 thru niter do
    
    (soln: mnewton (ev (augmented_lagrangian_gradient), xx, yy),
    
    yy: map (rhs, soln[1]),

    %lambda: %lambda + apply ("+", %nu * map (lambda ([c], subst (soln[1], c)), constraints))),

  yy);
