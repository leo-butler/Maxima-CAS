
/* gcdex(f,g) yields a list [a,b,u] where
  u is the GCD of f and g, and 
  u = f*a+g*b;

    F and G should be univariate polynomials so that we are in a principal
    ideal domain, and the ideal generated by (f,g) is indeed generated
    by the gcd of f and g.

  mytest(f,g):=block([ans:gcdex(f,g)],[ratsimp(ans.[f,g,-1]),remainder(f,ans[3]),remainder(g,ans[3])]);    should always yield [0,0,0]
    
*/      
gcdex(f,g):=block([q0,q1,ok:true,lis1,lis2,lis3,q,tem,var:listofvars([f,g]),
  swap:false],
  if (length(var) > 1) then merror("only univariate polynomials"),
  var:var[1],
  q0:divide(f,g),   /* divide(f,g) ==> [q:quotient(f,g),remainder:f-g*q] */
	      /* if f/g is 0 then we reverse them */
  if (q0[1]=0) then
    (lis2:gcdex(g,f),return([lis2[2],lis2[1],lis2[3]])),
  if (q0[2]=0) then return([0,1,g]),
  q1:divide(g,q0[2]), 	
  lis1:[1,-q0[1],q0[2]],			
  if (q1[2]=0) then 
    (if numberp(lis1[3]) then lis1:lis1/lis1[3], 
     return(lis1)),
      /* lisi are always perpendicular to [f,g,-1] */
  lis2:[-q1[1],1+q0[1]*q1[1], q1[2]],
  while(ok) do 
    ( q:divide(lis1[3],lis2[3]),
      lis3:ratsimp(lis1-lis2*q[1]),
      tem:content(lis3[3],var)[1],
      if (not(tem=0)) then lis3:ratsimp(lis3/tem),
     if(lis3[3] = 0) then ok:false
       else (lis1:lis2, lis2:lis3)
    ),
   if numberp(lis2[3]) then lis2/lis2[3] else lis2);



