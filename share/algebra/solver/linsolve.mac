/*
This routine is a modified version of linsolve written in maxima
Copyright (C) 1999  Dan Stanger

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Library General Public License as published
by the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

Dan Stanger dan.stanger@ieee.org
please contact me for updates to this code
*/
/* modifies the global variable  Solve_Inconsistent_Eqn_Nos if
   Solve_Inconsistent_Error is false, LinsolveWarn and Linsolve_Params,
   but acts as if Linsolve_Params is false */

define_variable( Solve_Inconsistent_Error, true, any)$
define_variable( Solve_Inconsistent_Eqn_Nos, false, any)$

LinsolveM(ees,vees):=block([ne:length(ees),nv:length(vees),nvees,ns,am,tam,r,
   ic],
   /* check to see if there are less equations than unknowns, if so,
      solve for the first ones */
   ns:min(ne,nv),
   nvees:rest(vees,ns-nv),
   /* construct the augmented coef matrix and triangularize it.
      this assumes that all the non linear terms are on the rhs of the
      equations (ees) */
   am:augcoefmatrix(ees,nvees),
   tam:triangularize(am),
   /* search for inconsistant equations.  this assumes that they are on
      the bottom of the matrix.  there may be a better way of doing
      this but i am not sure of it */
   /* copy the rhs, its the last column of the matrix, and whack it */
   r:col(tam,ns+1), tam:submatrix(tam,ns+1), ic:[],
   for i:ne thru 1 step -1 do block([az:true],
      map(lambda([x],if x # 0 then az:false), tam[i]), 
      if az = true and r[i] # 0 then ic:endcons(i, ic)
   ),
   if ic # [] then ( /* equations are inconsistant */
      if Solve_Inconsistent_Error = false then (
	 Solve_Inconsistent_Eqn_Nos:ic, return([inconsistant])))
   else (if Solve_Inconsistent_Error = false then
	 Solve_Inconsistent_Eqn_Nos:[]),
   block([x:make_array('any,ns), l],
      for i:ns thru 1 step -1 do
	 x[i-1]:(-r[i]-sum(tam[i,k]*x[k-1],k,i+1,ns))/tam[i,i],
      l:map(first,listarray(x)),
      if globalsolve = true then
	 /* this line does not work correctly */
	 map(lambda([x,y],x::y,globalsetq(x,y)),nvees,l)
      else map(lambda([x,y],x=y),nvees,l)
      ))$
