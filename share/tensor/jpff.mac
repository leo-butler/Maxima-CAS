AUG 1

modedeclare(i,integer,j,integer,k,integer,l,integer)$

modedeclare(ricciscaleq,boolean,inverted,boolean,r,integer)$

inverted:false$

chr1[i,j,k]:=if i>=j then
    ratsimp((1/2)*(diff(g[i,k],x[j])+diff(g[j,k],x[i])-diff(g[i,j],x[k]))) 
  else chr1[j,i,k]$

chr2[i,j,l]:=if i>=j then block([ans],ans:0,
       if not inverted then [inverted:true,h:g^^-1],
       for k:1 thru 4 do ans:ans+chr1[i,j,k]*h[k,l],
       ratsimp(ans) ) 
    else chr2[j,i,k]$

riemann[i,j,k,l]:=if (i=j) or (l=k) then 0
    else if i<j then -riemann[j,i,k,l]
    else if k<l then -riemann[i,j,l,k]
    else if i+4*j<k+4*l then rieman[k,l,i,j]
    else ratsimp(rie1(j,l,i,k)-rie1(j,k,i,l)+rie2(i,l,j,k)-rie2(i,k,j,l))$

rie2(i,j,k,l):=if i<j then rie2(j,i,k,l)
    else if k<l then rie2(i,j,l,k)
    else block([ans], ans:0,
        for r:1 thru 4 do ans:ans+chr1[i,j,r]*chr2[k,l,r], ans)$

rie1(i,j,k,l):=if i>=j then diff(chr1[i,j,k],x[l]) else rie1(j,i,k,l)$

ricci[i,j]:=if i>=j then block([ans], ans:0,
    if not inverted then [inverted:true,h:g^^-1],
    for k:1 thru 4 do 
        for l:1 thru 4 do ans:ans+riemann[i,k,j,l]*h[k,l],
     ratsimp(ans))
  else ricci[j,i]$

ricciscaleq:false$

calscal():=(ricciscalar:0,
    if not inverted then [inverted:true,h:g^^-1],
    ricciscaleq:true,
     for i:1 thru 4 do for j:1 thru 4 do
        ricciscalar:ricciscalar+ricci[i,j]*h[i,j],
    ricciscalar:ratsimp(ricciscalar))$

einstein[i,j]:=if i>=j then block( if not ricciscaleq then calscal(),
    ratsimp(ricci[i,j]-(1/2)*ricciscalar*g[i,j])) else einstein[j,i]$

weyl[i,j,k,l]:=if (i=j) or (k=l) then 0
    else if i<j then -weyl[j,i,k,l]
    else if k<l then -weyl[i,j,l,k]
    else if i+4*j<k+4*l then weyl[k,l,i,j]
    else ( if not ricciscaleq then calscal(),
        ratsimp(riemann[i,j,k,l]+(1/2)*(g[i,l]*ricci[j,k]-g[i,k]*ricci[l,j]
                               +g[j,k]*ricci[l,i]-g[j,l]*ricci[k,i])
                        -(1/6)*ricciscalar*(g[i,l]*g[k,j]-g[i,k]*g[l,j]))
        )$

contract(l1,l2,l3,l4):=block([ans],ans:0,
    for i:1 thru 4 do for j:1 thru 4 do
        for k:1 thru 4 do for l:1 thru 4 do
            ans:ans+weyl[i,j,k,l]*l1[i]*l2[j]*l3[k]*l4[l],
    ratsimp(ans)
    )$

psi[i]:=( if not tetradcaleq then setuptetrad(),
    if not tetradcaleq then "ERROR--NO TETRAD",
    if i=0 then -contract(tet1,tet3,tet1,tet3)
    else if i=1 then -contract(tet1,tet2,tet1,tet3)
    else if i=2 then -(1/2)*(contract(tet1,tet2,tet1,tet2)+
                             contract(tet1,tet2,tet3,tet4))
    else if i=3 then contract(tet1,tet2,tet2,tet4)
    else if i=4 then -contract(tet2,tet4,tet2,tet4)
    else undefined)$

petrov():=block([ii,jj,gg,hh],
    ii:ratsimp(psi[0]*psi[4]-4*psi[1]*psi[3]+3*psi[2]^2),
    jj:ratsimp(determinant(matrix(
        [psi[0],psi[1],psi[2]],
        [psi[1],psi[2],psi[3]],
        [psi[2],psi[3],psi[4]]))),
    if ratsimp(ii^3-27*jj^2)#0 then "TYPE IS I"
    else (gg:ratsimp(psi[0]^2*psi[3]-3*psi[0]*psi[1]*psi[2]+2*psi[1]^3),
    if (ii=0)and(jj=0) then 
        if gg=0 then ( hh:ratsimp(psi[0]*psi[2]-psi[1]^2),
            if hh=0 then
                if (psi[0]=0)and(psi[1]=0)and(psi[2]=0)and
                    (psi[3]=0)and(psi[4]=0) then "TYPE IS FLAT(0)" else
                 "TYPE IS N" else "TYPE IS III")
            else "TYPE IS III"
    else (hh:ratsimp(psi[0]*psi[2]-psi[1]^2),
    if ratsimp(gg-psi[0]^2*ii-12*hh^2)#0 then "TYPE IS II" else "TYPE IS D"
)))$
    

tetradcaleq:false$

setuptetrad():=block([diagq],diag:true,
    for i:1 thru 4 do for j:i+1 thru 4 do if g[i,j]#0 then diagq:false,
    if diag then ( tetradcaleq:true,
        if not inverted then h:g^^-1,
        tet1:[(-h[1,1])^(1/2),0,0,h[4,4]^(1/2)]*2^(-1/2),
        tet2:[-(-h[1,1])^(1/2),0,0,h[4,4]^(1/2)]*2^(-1/2),
        tet3:[0,%i*(-h[2,2])^(1/2),(-h[3,3])^(1/2),0]*2^(-1/2),
        tet4:[0,-%i*(-h[2,2])^(1/2),(-h[3,3])^(1/2),0]*2^(-1/2) )
    else "CANNOT CALCULATE TETRAD????????")$

setup():=block([a], inverted:ricciscaleq:tetradcaleq:false,
    remvalue(h,chr1,chr2,riemann,ricci,ricciscalar,weyl,psi),
    if matrixp(g) then (print("IS THIS THE CORRECT METRIC?",g),
        a:read("0 FOR YES,1 FOR EDIT,2 FOR NEW:")) else a:2,
        if a=2 then (print("DIAGIONAL?","0 FOR YES","1 FOR NO"),
            a:read("?"),
            if a=0 then (g:diagmatrix(4,0),
                for i thru 4 do g[i,i]:read("[",i,i,"]"))
            else for i thru 4 do for j:i thru 4 do
                g[i,j]:g[j,i]:read("[",i,j,"]"),
            print("METRIC IS ",g))
        else if a=0 then done
        else if a=1 then block([ve],
            print("GIVE VECTOR [I,J] (GIVE A ZERO I WHEN FINISHED)"),
  again,    ve:read("?:-"),
            if ve[1]=0 then go(out),
            g[ve[1],ve[2]]:g[ve[2],ve[1]]:read("G",ve,"?"), go(again), out,
            print("METRIC IS ",g)),
        done )$


g:matrix([-(1-m/x[1])^-1,0,0,0],[0,-x[1]^2,0,0],[0,0,-(x[1]*sin(x[2]))^2,0],[0,0,0,(1-m/x[1])])$







aug 5

array(%tet,4,4)$
array(x,4)$
array(%chr1,4,4,4)$
array(%chr2,4,4,4)$
array(%riemann,4,4,4,4)$
array(%ricci,4,4)$
array(%weyl,4,4,4,4)$

chr1(i,j,k):=(modedeclare([i,j,k],integer),
  if %chr1[i,j,k]#undef then %chr1[i,j,k] 
  else %chr1[i,j,k]:%chr1[j,i,k]:
      ratsimp((1/2)*(diff(g[i,k],x[j])+diff(g[j,k],x[i])-diff(g[i,j],x[k]))) )$

chr2(i,j,l):=(modedeclare([i,j,k,l],integer),
  if %chr2[i,j,l]#undef then %chr2[i,j,l]
  else %chr2[i,j,l]:%chr2[j,i,l]:block([ans],ans:0,
       if not inverted then (inverted:true,h:g^^-1),
       for k:1 thru 4 do ans:ans+chr1(i,j,k)*h[k,l],
       ratsimp(ans) ) )$

riemann(i,j,k,l):=(modedeclare([i,j,k,l],integer),
  if %riemann[i,j,k,l]#undef then %riemann[i,j,k,l]
    else if (i=j) or (l=k) then %riemann[i,j,k,l]:0
    else if i<j then %riemann[i,j,k,l]:-riemann(j,i,k,l)
    else if k<l then %riemann[i,j,k,l]:-riemann(i,j,l,k)
    else if i+4*j<k+4*l then riemann(k,l,i,j)
    else %riemann[i,j,k,l]:%riemann[k,l,i,j]:ratsimp(
        rie1(j,l,i,k)-rie1(j,k,i,l)+rie2(i,l,j,k)-rie2(i,k,j,l)))$

rie2(i,j,k,l):=block([ans],
    modedeclare([i,j,k,l,r],integer),
     ans:0,
        for r:1 thru 4 do ans:ans+chr1(i,j,r)*chr2(k,l,r), ans)$

rie1(i,j,k,l):=(modedeclare([i,j,k,l],integer),
    diff(chr1(i,j,k),x[l]))$

ricci(i,j):=(
  modedeclare([i,j,k,l],integer,inverted,boolean),
  if %ricci[i,j]#undef then %ricci[i,j]
  else %ricci[i,j]:%ricci[j,i]:block([ans], ans:0,
    if not inverted then (inverted:true,h:g^^-1),
    for k:1 thru 4 do 
        for l:1 thru 4 do ans:ans+riemann(i,k,j,l)*h[k,l],
     ratsimp(ans))
)$


calscal():=(modedeclare([ricciscaleq,inverted],boolean,[i,j],integer),
    ricciscalar:0,
    if not inverted then (inverted:true,h:g^^-1),
    ricciscaleq:true,
     for i:1 thru 4 do for j:1 thru 4 do
        ricciscalar:ricciscalar+ricci(i,j)*h[i,j],
    ricciscalar:ratsimp(ricciscalar))$

einstein(i,j):=(modedeclare([i,j],integer,ricciscaleq,boolean),
  if %einstein[i,j]#undef then %einstein[i,j]
  else %einstein[i,j]:%einstein[j,i]:block( if not ricciscaleq then calscal(),
    ratsimp(ricci(i,j)-(1/2)*ricciscalar*g[i,j])) )$

weyl(i,j,k,l):=(modedeclare([i,j,k,l],integer,ricciscaleq,boolean),
if %weyl[i,j,k,l]#undef then %weyl[i,j,k,l]
  else %weyl[i,j,k,l]:%weyl[k,l,i,j]:if (i=j) or (k=l) then 0
    else if i<j then -weyl(j,i,k,l)
    else if k<l then -weyl(i,j,l,k)
    else ( if not ricciscaleq then calscal(),
        ratsimp(riemann(i,j,k,l)+(1/2)*(g[i,l]*ricci(j,k)-g[i,k]*ricci(l,j)
                               +g[j,k]*ricci(l,i)-g[j,l]*ricci(k,i))
                        -(1/6)*ricciscalar*(g[i,l]*g[k,j]-g[i,k]*g[l,j]))
        ))$

contract(l1,l2,l3,l4):=block([ans],
    modedeclare([l1,l2,l3,l4,i,j,k,l],integer),
    ans:0,
    for i:1 thru 4 do for j:1 thru 4 do
        for k:1 thru 4 do for l:1 thru 4 do
            ans:ans+weyl(i,j,k,l)*%tet[l1,i]*%tet[l2,j]*%tet[l3,k]*%tet[l4,l],
    ratsimp(ans)
    )$

psi(i):=(modedeclare(i,integer,tetradcaleq,boolean),
  if %psi[i]#undef then %psi[i]
  else %psi[i]:( if not tetradcaleq then setuptetrad(),
    if not tetradcaleq then "ERROR--NO TETRAD"
    else if i=0 then -contract(1,3,1,3)
    else if i=1 then -contract(1,2,1,3)
    else if i=2 then -(1/2)*(contract(1,2,1,2)+
                             contract(1,2,3,4))
    else if i=3 then contract(1,2,2,4)
    else if i=4 then -contract(2,4,2,4)
    else undefined))$

petrov():=block([ii,jj,gg,hh],
    ii:ratsimp(psi(0)*psi(4)-4*psi(1)*psi(3)+3*psi(2)^2),
    jj:ratsimp(determinant(matrix(
        [%psi[0],%psi[1],%psi[2]],
        [%psi[1],%psi[2],%psi[3]],
        [%psi[2],%psi[3],%psi[4]]))),
    if ratsimp(ii^3-27*jj^2)#0 then "TYPE IS I"
    else (gg:ratsimp(%psi[0]^2*%psi[3]-3*%psi[0]*%psi[1]*%psi[2]+2*%psi[1]^3),
    if (ii=0)and(jj=0) then 
        if gg=0 then ( hh:ratsimp(%psi[0]*%psi[2]-%psi[1]^2),
            if hh=0 then
                if (%psi[0]=0)and(%psi[1]=0)and(%psi[2]=0)and
                    (%psi[3]=0)and(%psi[4]=0) then "TYPE IS FLAT(0)" else
                 "TYPE IS N" else "TYPE IS III")
            else "TYPE IS III"
    else (hh:ratsimp(%psi[0]*%psi[2]-%psi[1]^2),
    if ratsimp(gg-%psi[0]^2*ii-12*hh^2)#0 then "TYPE IS II" else "TYPE IS D"
)))$
    


setuptetrad():=block([diagq],
    modedeclare([tetradcaleq,inverted,diagq],boolean,[i,j],integer),
    array(%tet,complete,4,4),
    diagq:true,
    for i:1 thru 4 do for j:i+1 thru 4 do if g[i,j]#0 then diagq:false,
    if diagq then ( tetradcaleq:true,
        if not inverted then (inverted:true, h:g^^-1),
        %tet[1,1]:(-h[1,1])^(1/2)*2^(-1/2),  %tet[1,2]:0,
            %tet[1,3]:0,    %tet[1,4]:h[4,4]^(1/2)*2^(-1/2),
        %tet[2,1]:-(-h[1,1])^(1/2)*2^(-1/2),  %tet[2,2]:0,  %tet[2,3]:0,
            %tet[2,4]:h[4,4]^(1/2)*2^(-1/2),
        %tet[3,1]:0,  %tet[3,2]:%i*(-h[2,2])^(1/2)*2^(-1/2),
            %tet[3,3]:(-h[3,3])^(1/2)*2^(-1/2),    %tet[3,4]:0,
        %tet[4,1]:0,    %tet[4,2]:-%i*(-h[2,2])^(1/2)*2^(-1/2),
            %tet[4,3]:(-h[3,3])^(1/2)*2^(-1/2),    %tet[4,4]:0 )
    else "CANNOT CALCULATE TETRAD????????")$

setup():=block([a], modedeclare([inverted,ricciscaleq,tetradcaleq],boolean),
    modedeclare([i,j,k,l],integer),
    array(%psi,complete,4), array(%ricci,complete,4,4),
    array(%einstein,complete,4,4), array(%chr1,complete,4,4,4),
    array(%chr2,complete,4,4,4), array(%riemann,complete,4,4,4,4),
    array(%weyl,complete,4,4,4,4),
    inverted:ricciscaleq:tetradcaleq:false,
    for i:0 thru 4 do %psi[i]:undef,
    for i thru 4 do for j thru 4 do (
        %ricci[i,j]:%einstein[i,j]:undef,
        for k thru 4 do (
            %chr1[i,j,k]:%chr2[i,j,k]:undef,
           for l thru 4 do %riemann[i,j,k,l]:%weyl[i,j,k,l]:undef)
        ),
    if matrixp(g) then (print("IS THIS THE CORRECT METRIC?",g),
        a:read("0 FOR YES,1 FOR EDIT,2 FOR NEW:")) else a:2,
        if a=2 then (print("DIAGIONAL?","0 FOR YES","1 FOR NO"),
            a:read("?"),
            if a=0 then (g:diagmatrix(4,0),
                for i thru 4 do g[i,i]:read("[",i,i,"]"))
            else for i thru 4 do for j:i thru 4 do
                g[i,j]:g[j,i]:read("[",i,j,"]"),
            print("METRIC IS ",g))
        else if a=0 then done
        else if a=1 then block([ve],
            print("GIVE VECTOR [I,J] (GIVE A ZERO I WHEN FINISHED)"),
  again,    ve:read("?:-"),
            if ve[1]=0 then go(out),
            g[ve[1],ve[2]]:g[ve[2],ve[1]]:read("G",ve,"?"), go(again), out,
            print("METRIC IS ",g)),
        print("IS THIS THE CORRECT COORDINATE VECTOR?",x[1],x[2],x[3],x[4]),
        a:read("0 for yes, OTHERWISE A VECTOR"),
        if a#0 then for i thru 4 do x[i]:a[i],
        if matrixp(h) then
            if ratsimp(h.g)=ident(4) then inverted:true
            else (print("IS THIS REALLY THE CONTRAVARIANT METRIC",h),
                a:read("0 FOR YES 1 FOR NO"),
                if a=0 then inverted:true),
        done )$


g:matrix([-(1-m/x[1])^-1,0,0,0],[0,-x[1]^2,0,0],[0,0,-(x[1]*sin(x[2]))^2,0],[0,0,0,(1-m/x[1])])$








jpff pet2

array(%tet,4,4)$
array(x,4)$
array(%chr1,4,4,4)$
array(%chr2,4,4,4)$
array(%riemann,4,4,4,4)$
array(%ricci,4,4)$
array(%weyl,4,4,4,4)$

chr1(i,j,k):=(modedeclare([i,j,k],integer),
  if %chr1[i,j,k]#undef then %chr1[i,j,k] 
  else %chr1[i,j,k]:%chr1[j,i,k]:
      ratsimp((1/2)*(diff(g[i,k],x[j])+diff(g[j,k],x[i])-diff(g[i,j],x[k]))) )$

chr2(i,j,l):=(modedeclare([i,j,k,l],integer),
  if %chr2[i,j,l]#undef then %chr2[i,j,l]
  else %chr2[i,j,l]:%chr2[j,i,l]:block([ans],ans:0,
       if not inverted then (inverted:true,h:g^^-1),
       for k:1 thru 4 do ans:ans+chr1(i,j,k)*h[k,l],
       ratsimp(ans) ) )$

riemann(i,j,k,l):=(modedeclare([i,j,k,l],integer),
  if %riemann[i,j,k,l]#undef then %riemann[i,j,k,l]
    else if (i=j) or (l=k) then %riemann[i,j,k,l]:0
    else if i<j then %riemann[i,j,k,l]:-riemann(j,i,k,l)
    else if k<l then %riemann[i,j,k,l]:-riemann(i,j,l,k)
    else if i+4*j<k+4*l then riemann(k,l,i,j)
    else %riemann[i,j,k,l]:%riemann[k,l,i,j]:ratsimp(
        rie1(j,l,i,k)-rie1(j,k,i,l)+rie2(i,l,j,k)-rie2(i,k,j,l)))$

rie2(i,j,k,l):=block([ans],
    modedeclare([i,j,k,l,r],integer),
     ans:0,
        for r:1 thru 4 do ans:ans+chr1(i,j,r)*chr2(k,l,r), ans)$

rie1(i,j,k,l):=(modedeclare([i,j,k,l],integer),
    diff(chr1(i,j,k),x[l]))$

ricci(i,j):=(
  modedeclare([i,j,k,l],integer,inverted,boolean),
  if %ricci[i,j]#undef then %ricci[i,j]
  else %ricci[i,j]:%ricci[j,i]:block([ans], ans:0,
    if not inverted then (inverted:true,h:g^^-1),
    for k:1 thru 4 do 
        for l:1 thru 4 do ans:ans+riemann(i,k,j,l)*h[k,l],
     ratsimp(ans))
)$


calscal():=(modedeclare([ricciscaleq,inverted],boolean,[i,j],integer),
    ricciscalar:0,
    if not inverted then (inverted:true,h:g^^-1),
    ricciscaleq:true,
     for i:1 thru 4 do for j:1 thru 4 do
        ricciscalar:ricciscalar+ricci(i,j)*h[i,j],
    ricciscalar:ratsimp(ricciscalar))$

einstein(i,j):=(modedeclare([i,j],integer,ricciscaleq,boolean),
  if %einstein[i,j]#undef then %einstein[i,j]
  else %einstein[i,j]:%einstein[j,i]:block( if not ricciscaleq then calscal(),
    ratsimp(ricci(i,j)-(1/2)*ricciscalar*g[i,j])) )$

weyl(i,j,k,l):=(modedeclare([i,j,k,l],integer,ricciscaleq,boolean),
if %weyl[i,j,k,l]#undef then %weyl[i,j,k,l]
  else %weyl[i,j,k,l]:%weyl[k,l,i,j]:if (i=j) or (k=l) then 0
    else if i<j then -weyl(j,i,k,l)
    else if k<l then -weyl(i,j,l,k)
    else ( if not ricciscaleq then calscal(),
        ratsimp(riemann(i,j,k,l)+(1/2)*(g[i,l]*ricci(j,k)-g[i,k]*ricci(l,j)
                               +g[j,k]*ricci(l,i)-g[j,l]*ricci(k,i))
                        -(1/6)*ricciscalar*(g[i,l]*g[k,j]-g[i,k]*g[l,j]))
        ))$

contract(l1,l2,l3,l4):=block([ans],
    modedeclare([l1,l2,l3,l4,i,j,k,l],integer),
    ans:0,
    for i:1 thru 4 do for j:1 thru 4 do
        for k:1 thru 4 do for l:1 thru 4 do
            ans:ans+weyl(i,j,k,l)*%tet[l1,i]*%tet[l2,j]*%tet[l3,k]*%tet[l4,l],
    ratsimp(ans)
    )$

psi(i):=(modedeclare(i,integer,tetradcaleq,boolean),
  if %psi[i]#undef then %psi[i]
  else %psi[i]:( if not tetradcaleq then setuptetrad(),
    if not tetradcaleq then "ERROR--NO TETRAD"
    else if i=0 then -contract(1,3,1,3)
    else if i=1 then -contract(1,2,1,3)
    else if i=2 then -(1/2)*(contract(1,2,1,2)+
                             contract(1,2,3,4))
    else if i=3 then contract(1,2,2,4)
    else if i=4 then -contract(2,4,2,4)
    else undefined))$

petrov():=block([ii,jj,gg,hh],
    ii:ratsimp(psi(0)*psi(4)-4*psi(1)*psi(3)+3*psi(2)^2),
    jj:ratsimp(determinant(matrix(
        [%psi[0],%psi[1],%psi[2]],
        [%psi[1],%psi[2],%psi[3]],
        [%psi[2],%psi[3],%psi[4]]))),
    if ratsimp(ii^3-27*jj^2)#0 then "TYPE IS I"
    else (gg:ratsimp(%psi[0]^2*%psi[3]-3*%psi[0]*%psi[1]*%psi[2]+2*%psi[1]^3),
    if (ii=0)and(jj=0) then 
        if gg=0 then ( hh:ratsimp(%psi[0]*%psi[2]-%psi[1]^2),
            if hh=0 then
                if (%psi[0]=0)and(%psi[1]=0)and(%psi[2]=0)and
                    (%psi[3]=0)and(%psi[4]=0) then "TYPE IS FLAT(0)" else
                 "TYPE IS N" else "TYPE IS III")
            else "TYPE IS III"
    else (hh:ratsimp(%psi[0]*%psi[2]-%psi[1]^2),
    if ratsimp(gg-%psi[0]^2*ii-12*hh^2)#0 then "TYPE IS II" else "TYPE IS D"
)))$
    


setuptetrad():=block([diagq],
    modedeclare([tetradcaleq,inverted,diagq],boolean,[i,j],integer),
    array(%tet,complete,4,4),
    diagq:true,
    for i:1 thru 4 do for j:i+1 thru 4 do if g[i,j]#0 then diagq:false,
    if diagq then ( tetradcaleq:true,
        if not inverted then (inverted:true, h:g^^-1),
        %tet[1,1]:(-h[1,1])^(1/2)*2^(-1/2),  %tet[1,2]:0,
            %tet[1,3]:0,    %tet[1,4]:h[4,4]^(1/2)*2^(-1/2),
        %tet[2,1]:-(-h[1,1])^(1/2)*2^(-1/2),  %tet[2,2]:0,  %tet[2,3]:0,
            %tet[2,4]:h[4,4]^(1/2)*2^(-1/2),
        %tet[3,1]:0,  %tet[3,2]:%i*(-h[2,2])^(1/2)*2^(-1/2),
            %tet[3,3]:(-h[3,3])^(1/2)*2^(-1/2),    %tet[3,4]:0,
        %tet[4,1]:0,    %tet[4,2]:-%i*(-h[2,2])^(1/2)*2^(-1/2),
            %tet[4,3]:(-h[3,3])^(1/2)*2^(-1/2),    %tet[4,4]:0 )
    else "CANNOT CALCULATE TETRAD????????")$

setup():=block([a], modedeclare([inverted,ricciscaleq,tetradcaleq],boolean),
    modedeclare([i,j,k,l],integer),
    array(%psi,complete,4), array(%ricci,complete,4,4),
    array(%einstein,complete,4,4), array(%chr1,complete,4,4,4),
    array(%chr2,complete,4,4,4), array(%riemann,complete,4,4,4,4),
    array(%weyl,complete,4,4,4,4),
    inverted:ricciscaleq:tetradcaleq:false,
    for i:0 thru 4 do %psi[i]:undef,
    for i thru 4 do for j thru 4 do (
        %ricci[i,j]:%einstein[i,j]:undef,
        for k thru 4 do (
            %chr1[i,j,k]:%chr2[i,j,k]:undef,
           for l thru 4 do %riemann[i,j,k,l]:%weyl[i,j,k,l]:undef)
        ),
    if matrixp(g) then (print("IS THIS THE CORRECT METRIC?",g),
        a:read("0 FOR YES,1 FOR EDIT,2 FOR NEW:")) else a:2,
        if a=2 then (print("DIAGIONAL?","0 FOR YES","1 FOR NO"),
            a:read("?"),
            if a=0 then (g:diagmatrix(4,0),
                for i thru 4 do g[i,i]:read("[",i,i,"]"))
            else for i thru 4 do for j:i thru 4 do
                g[i,j]:g[j,i]:read("[",i,j,"]"),
            print("METRIC IS ",g))
        else if a=0 then done
        else if a=1 then block([ve],
            print("GIVE VECTOR [I,J] (GIVE A ZERO I WHEN FINISHED)"),
  again,    ve:read("?:-"),
            if ve[1]=0 then go(out),
            g[ve[1],ve[2]]:g[ve[2],ve[1]]:read("G",ve,"?"), go(again), out,
            print("METRIC IS ",g)),
        print("IS THIS THE CORRECT COORDINATE VECTOR?",x[1],x[2],x[3],x[4]),
        a:read("0 for yes, OTHERWISE A VECTOR"),
        if a#0 then for i thru 4 do x[i]:a[i],
        if matrixp(h) then
            if ratsimp(h.g)=ident(4) then inverted:true
            else (print("IS THIS REALLY THE CONTRAVARIANT METRIC",h),
                a:read("0 FOR YES 1 FOR NO"),
                if a=0 then inverted:true),
        done )$


g:matrix([-(1-m/x[1])^-1,0,0,0],[0,-x[1]^2,0,0],[0,0,-(x[1]*sin(x[2]))^2,0],[0,0,0,(1-m/x[1])])$






