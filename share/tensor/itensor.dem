(load(ctensor),load(itensor))$
("ITENSOR - Basic Functions")$

("The function CHR1([i,j,k]) yields the Christoffel symbol of the first
kind via the definition to evaluate the Christoffel symbols for a
particular metric. The variable METRIC must be assigned a name.")$

metric:g$
show(chr1([i,j,k]))$
show(chr2([i,j],[k]))$

("As an example we consider a conformally flat metric and find the
Christoffel symbols of both kinds:")$

declare(e,constant)$

	/*(" Note function COMPONENTS() is broken
	Another possibility to assign the particular
	components to some tensor is following ")$

	G(L1,L2):=BLOCK(IF L2=[] THEN RETURN(E(L1,[])*P([],[]) ),
	  E([],L2)/P([],[]) )$ */

components(g([i,j],[]),e([i,j],[])*p([],[]));
components(g([],[i,j]),e([],[i,j])/p([],[]));

show(g([i,j],[]))$
show(g([],[i,j]))$
show(factor(chr1([i,j,k])))$
show(factor(chr2([i,j],[k])))$

("CURVATURE([i,j,k],[h]) yields the Riemann curvature tensor in terms of
the Christoffel symbols of the second kind (CHR2). The following notation
is used:")$

show(curvature([i,j,k],[h]))$

("Next we demostrate using KDELTA() and DEFCON() function that assigns
contraction properties to a particular tensor. Another example with
defcon is below.")$

dim:3;
defcon(e,e,kdelta)$
contract(kdelta([a],[b])*kdelta([b],[a]))$
show(ev(%,kdelta))$

show(contract(expand(g([a,b],[])*g([],[b,l]))))$

show(kdelta([a,b,c],[r,s,t]))$
 
("LC() gives Levi-Civita tensor. I would refer this function to the
ctensor package because it deals with integer types of indices. The
indicial Levi-Civita tensor might be defined through KDELTA, e.g.
KDELTA([1,2,3],[i,j,k])")$

lc([1,2,3]);lc([1,1,3]);lc([2,1,3]);

("Function GEODESIC(exp,name) enables the user to cause the
undifferentiated Christoffel symbols and first derivatives of the metric
tensor to vanish in exp. The name in the GEODESIC function refers to the
metric name (if it appears in exp) while the connection coefficients must
be called with the names CHR1 and/or CHR2. The following example
demonstrates the verification of the cyclic identity satisfied by the
Riemann curvature tensor using RENAME while also showing the use of the
GEODESIC function.")$

exp2:curvature([r,s,t],[u])+curvature([s,t,r],[u])+curvature([t,r,s,t],[u])$
show(exp2)$
show(geodesic(exp2,chr2))$
show(rename(exp2))$

("In order to evaluate an expression involving the Riemann tensor and
incorporate this given definition of metric explicitly into the result
the user can EV(expression), as the following example for the weak field
metric demonstrates:")$

remcomps(g);
declare(e,constant);
metric:g;
	/*G(L1,L2):=BLOCK( IF L2=[] THEN RETURN(E(L1,[])+2*L*P(L1,[]) ),
	  E([],L2)-2*L*P([],L2) )$*/
components(g([i,j],[]),e([i,j],[])*2*l*p([],[]));
components(g([],[i,j]),e([],[i,j])-2*l*p([],[i,j]));

show(g([i,j],[]))$
show(g([],[i,j]))$

(ratvars(l),ratweight(l,1),ratwtlvl:1)$
exp1:curvature([s,u,n],[y]);

	/*("Note the direct application ev(%) does not work currently")$
	undiff(exp1)$
	ev(%,chr2)$
	ev(%,diff)$*/
show(canform(contract(rename(ratexpand(ev(%))))))$

("CONMETDERIV(exp,tensor) is used to simplify expressions containing
ordinary derivatives of both covariant and contravariant forms of the
metric tensor (the current restriction).  For example, CONMETDERIV can
relate the derivative of the contravariant metric tensor with the
Christoffel symbols as seen from the following:")$

show(q([],[a,b],c))$
show(conmetderiv(%,q))$

("FLUSHD(exp,tensor1,tensor2,...) will set to zero in exp, all
occurrences of the tensori that have derivative indices.")$

exp1 : a([i],[j,r],k,r)+a([i],[j,r,s],k,r,s)$
show(exp1)$
show(flushd(exp1,a))$

("Function FLUSHND(exp,tensor1,n) will set to zero in exp, all
occurrences of the differentiated object tensor that have n or more
derivative indices")$ 

show(flushnd(exp1,a,3))$

("LORENTZ(exp, <tensor1, tensor2, ...>) imposes a generalized Lorentz
condition on exp replacing with zero those tensori that have a derivative
index identical to a contravariant index. If no tensori are specified,
this process will be performed on all indexed objects in exp. In the
following we costruct the Einstein tensor and impose the Lorentz
condition.")$

metric:g$
show(g([],[i,j]))$
defcon(e,e,kdelta)$
defcon(e,p,p)$
defcon(p,e,p)$

rr: g([],[r,t])*curvature([r,s,t],[s]);
rrij: g([],[i,r])*g([],[j,t])*curvature([r,s,t],[s]);
ein:-(rrij-1/2*rr*g([],[i,j]))$
	/*undiff(ein)$
	ev(%,chr2)$
	ev(%,diff)$*/
ein:canform(rename(contract(ratexpand(ev(%)))))$
lorentz(ein,p)$
show(%)$

("Now check whether the Einstein tensor is divergence free, a consequence
of the Bianchi identities.")$

divein: covdiff(ein,j)$
	/*undiff(divein)$
	ev(%,chr2)$
	ev(%,diff)$*/
divein: canform(rename(contract(ratexpand(ev(%)))))$
show(%)$

("Note that with help of CANTEN(), Maxima is able to prove the Bianchi
identities in the general case. Incoming!")$

kill:g;
metric:g;

("Declaring the symmetry properties")$

exp1:a([k,j,i],[])+ a([k,i,j],[])+ a([j,k,i],[])+
        a([j,i,k],[])+ a([i,k,j],[])+ a([i,j,k],[])$

show(exp1)$
allsym;
show(canform(exp1))$
allsym:false;
decsym(a,3,0,[anti(all)],[])$
dispsym(a,3,0);
show(canform(exp1))$
remsym(a,3,0);
decsym(a,3,0,[cyc(all)],[])$
show(canform(exp1))$

("DEFCON(tensor1,<tensor2,tensor3>) gives tensor1 the property that the
contraction of a product of tensor1 and tensor2 results in tensor3 with
the appropriate indices. If only one argument, tensor1, is given, then
the contraction of the product of tensor1 with any indexed object having
the appropriate indices (say tensor) will yield an indexed object with
that name, i.e. tensor, and with a new set of indices reflecting the
contractions performed. For example, if METRIC:G, then DEFCON(G) will
implement the raising and lowering of indices through contraction with
the metric tensor. CONTRACTIONS is a list of those indexed objects which
have been given contraction properties with DEFCON.

The following example for an algebraically special metric shows how the
null property of a vector field may be assigned as well as demonstrating
that more than one DEFCON assignment can be given for the same indexed
object.")$

declare(e,constant);

defcon(e);
defcon(e,e,kdelta);
defcon(l,l,w)$
w(l1,l2):=0$
	/*G(L1,L2):=BLOCK(
	IF L2=[] THEN RETURN(E(L1,[])+2*M*L([L1[1]],[])*L([L1[2]],[]) ),
	E([],L2)-2*M*L([],[L2[1]])*L([],[L2[2]]))$*/
remcomps(g);
components(g([i,j],[]),e([i,j],[])+2*m*l([i],[])*l([j],[]));
components(g([],[i,j]),e([],[i,j])-2*m*l([],[i])*l([],[j]));


show(g([i,j],[]))$
show(g([],[i,j]))$
contract(rename(expand(g([i,j],[])*g([],[j,k]))))$
show(%)$

("Indices control")$

remcomps(g);

exp1:curvature([i,j,k],[l])*curvature([a,b,c],[d])$
show(exp1)$

indices(%);
counter;
show(rename(exp1,10))$
counter;
dummyx;
dummyx:&$
show(rename(exp1,3))$

dummyx:di$
metric:g$
dim:3;

("The RHS of the heat transport equation")$

eq1:td = show(canform(rename(expand(covdiff(
     -k([],[])*covdiff(t([],[]),i),j)*g([],[i,j]))))+ source)$

heat:generate(eq1);

("First, write the equation in Cartesian coordinates.")$

omega:[x,y,z];

lg:matrix([1,0,0],[0,1,0],[0,0,1]);
ug : invert(lg); 
christof(mcs);


depends([t,k],omega);
ev(heat);

("Now get the equation in spherical coordinates.")$

omega:[r,th,ph];
lg:matrix([1,0,0],[0,r^2,0],[0,0,r^2*sin(th)^2])$
ug:invert(lg)$
christof(all);
remove([t,k],dependency);
depends(t,omega);
ev(heat);
