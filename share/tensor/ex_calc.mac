/* Copyright (C) 2003 Valerij Pipin <pip@iszf.irk.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * Commentary:
 * Its purpose is to extend the maxima's itensor ability to manage the
 exterior forms. We introduce the "&" operator for the exterior product,
 and "|_" for the inner product of a form with a vector.
*/
load("tensor/itensor")$
infix("&");
declare("&",additive); 

"&"(any,body):=block(local(i),
  l1:first(indices(any)),
  l2:first(indices(body)),
  if l1=[] then return(any*body)
  else if l2=[] then return(any*body)
  else ( l11 : makelist(idummy(), i,1, length(l1)),
    l22 : makelist(idummy(), i,1, length(l2)),
    l1s:map("=",l1,l11), l2s:map("=",l2,l22),
    lk1:append(l1,l2),lk2:append(l11,l22),
    any:sublis(l1s,any), body:sublis(l2s,body),
    evf:(if evenp(length(lk1)) then 1 else -1),
    canform(contract(
        expand(evf*kdelta(lk1,lk2)*any*body/(length(lk1)-1)!)))));

extdiff(forma,ind):=block(l1:first(indices(forma)),
  if l1=[] then return(diff(forma,ind))
  else ( l11 : makelist(idummy(), i,1, length(l1)),
    l1s:map("=",l1,l11),
    lk1:append([ind],l1),
    indd:idummy(),lk2:append(l11,[indd]),
    forma:sublis(l1s,forma),
    evf:(if evenp(length(lk1)) then 1 else -1),
    contract(canform(ratexpand(
          evf*kdelta(lk1,lk2)*diff(forma,indd)/(length(lk1)-1)!)))));

/* VTT: To ensure consistent application of the "first" index in |_ */
permutator(l):=block([result:1,temp],
	for i thru length(l)-1 do if orderlessp(l[i+1],l[i]) then
	(temp:l[i+1],l[i+1]:l[i],l[i]:temp,i:0,result:-result),
	[result,l]
);

infix("|_");
declare("|_",additive);
/* VTT: ADDITIVE doesn't always do the trick so we break up sums manually */
"|_"(forma,vec):=block(local(ind,perm),
  if not(atom(forma)) and (op(forma)="+" or op(forma)="=") then
    apply(op(forma),[part(forma,1)|_vec,rest(forma)|_vec])
  else (perm:permutator(first(indices(forma))),
    if perm[2]=[] then 0
    else perm[1]*(contract(canform(expand(forma*vec([],[first(perm[2])])))))));

liediff(forma,l1):=block(local(temp1,temp2,ind1),
  vec:first(l1),ind1:second(l1),
  if ind1=0 then (ind1:idummy(),v([],[ind1])*diff(forma,ind1))
  else(
/* VTT: some black magic needed because MAXIMA doesn't handle ADDITIVE as expected */
  temp1:rename(extdiff(forma,ind1)),
  temp1:ev(temp1|_vec,noeval),
  temp1:ev(temp1,eval),
  temp2:rename(forma),
  temp2:ev(temp2|_vec,noeval),
  temp2:extdiff(ev(temp2,eval),ind1),
  temp1+temp2));

