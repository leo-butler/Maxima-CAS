load(ctensor)$
load(itensor)$

("To show a tensor use ISHOW()")$
ishow(g([a,b],[c,i],i2,i1))$

("define tensor components through the usual maxima function syntax")$
t(l1,l2):=c*a(l1,l2)+b(l1,l2)$
ishow(t([i,k],[]))$
ishow(t([],[j,m]))$

("the Euler equation ")$
Eu(l1,l2):=block(d_t* v(l1,[])+v([],[j])*v(l1,[],j)+
1/rho([])*diff(p([],[]),l1[1])+diff(phi([],[]),l1[1]))$
ishow(Eu([i],[]))$
("one can give another definition for
  the Euler equation using the metric ")$
imetric:g$
Eu(l1,l2):=block(j1:idummy(), if l2=[] then
d_t* v(l1,[])+v([],[j1])*v(l1,[],j1)+1/rho([])*diff(p([],[]),l1[1])+diff(phi([],[]),l1[1])
 else d_t*v([],l2)+v([],[j1])*v([],l2,j1)+
g([],[l2[1],j1])*(diff(p([],[]),j1)/rho([])+diff(phi([],[]),j1)) )$
ishow(Eu([i],[]))$
ishow(Eu([],[i]))$
("control the dummy indices with idummyx: something")$
idummyx:n$
ishow(Eu([i],[]))$


("tensor algebra operations")$
("contractions, raising (lowering), symmetrization (antisymmetrization),
  exterior product, dualization, all of this is possible to do")$
("the Kronecker delta is very important")$
ishow(kdelta([i],[j]))$
ishow(kdelta([i,j],[n,m]))$
ishow(kdelta([i,j,k],[l,n,m]))$

("Contractions, to define defcon(tensor1,tensor2,tensor3) before")$
(declare(e, constant), defcon(e), defcon(e,e,kdelta))$
(defcon(l,l,w),w(l1,l2):=0)$
g(l1,l2):=block(
if l2=[] then e(l1,[])+m*l([l1[1]],[])*l([l1[2]],[])
else  e([],l2)-m*l([],[l2[1]])*l([],[l2[2]]))$
ishow(g([i,j],[]))$
ishow(g([],[i,j]))$
imetric:g$
ishow(contract(rename(expand(g([j,k],[])*g([],[i,j])))))$

("raising and lowering of indices with function contract(exp)")$
(defcon(Ti),expr1:Te([i,j],[k,l])*Ti([k,m])*Ti([l,n]),
expr2:Te([i,j],[k,l])*Ti([],[i,n])*Ti([],[j,m]))$
ishow(expr1)$
ishow(expr2)$

("symmetrization via contract with function kdels(L1,L2)")$
(" kdels(L1,L2) gives the symmetric combination of the Kronecker delta")$
ishow(kdels([i],[l]))$
ishow(kdels([i,j],[l,k]))$
ishow(kdels([i,j,k],[l,m,n]))$
ishow(ev(kdels([],[]),kdelta))$

("naturally the contraction of such symmetric and antisymmetric tensors
  like kdels and kdelta gives zero.  Look at the huge sum.")$
expr:expand(kdels([i,j,k],[l,m,n])*kdelta([l,m,n],[i1,i2,i3]))$
ishow(expr)$
("contract it to zero")$
ishow(contract(expr))$
("another example")$
("take the symmetrization of A_{ijk}")$
expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
ishow(expr)$
("declare A to be fully symmetric")$
decsym(a,3,0,[sym(all)],[])$
allsym:true;
("look at the result of the simplification with canform")$
ishow(canform(expr))$
("now let A be fully antisymmetric")$
allsym:false$
remsym(a,3,0)$
decsym(a,3,0,[anti(all)],[])$
dispsym(a,3,0);
("then the simplification of expr leads to another result")$
ishow(canform(expr))$
("again, if A is cyclic on indices")$ 
remsym(a,3,0);
decsym(a,3,0,[cyc(all)],[])$
ishow(canform(expand(expr)))$

("revise the defined contraction properties")$
dispcon(all);

("antisymmetrization via contract with kdelta")$
("define some symmetric tensor")$
decsym(s,0,3,[],[sym(all)]);
("take the antisymmetrization of another tensor
  B and contract the result with S")$
exp1: canform(contract(expand(kdelta([i,k,l],[i1,k1,l1])*b([i1,k1,l1],[]))))$
ishow(exp1)$
exp2:exp1*s([],[i,k,l])$
ishow(expand(exp2))$
ishow(canform(contract(%)))$

("the exterior algebra for the antisymmetric covariant objects")$
("the exterior product is defined through the infix operator ~
  the exterior derivative through extdiff(), inner product with | vec,
  and the Lie derivative through liediff(vec,x)")$
("load the package in the system")$
("now look at the exterior product of two 1-forms
  and 1-form with 2-form")$
allsym:false$
decsym(p,2,0,[anti(all)],[])$
kill(a)$
ishow(a([i])~b([j]))$
ishow(a([i])~p([j,k])+a([i])~b([j])~a([k]))$

("dualization")$
("the itensor's old-style Levi-Civita symbol operates only on integers")$
dim:3;
levi_civita([1,2,3]);
levi_civita([i,j,j]);
("but we now have a better implementation")$
ax_bxc:'levi_civita([i,j,k],[])*a([],[j])*'levi_civita([],[k,l,n])*b([l],[])*c([n],[])$
ishow(ax_bxc)$
lc2kdt(ax_bxc)$
ishow(contract(expand(%)))$

axb_cxu:'levi_civita([i,j,k],[])*a([],[j])*b([],[k])*'levi_civita([],[i,l,n])*c([l],[])*u([n],[])$
ishow(axb_cxu)$
lc2kdt(axb_cxu)$
ishow(contract(expand(%)))$

("The indexing properties of the Levi-Civita symbol are encoded in two")$
("simplification rules, LC_L and LC_U. These rules can be used to simplify")$
("expressions containing the unevaluated Levi-Civita symbol.")$
expr2:'levi_civita([i,j,k],[])*a([],[j])*a([],[k])+'levi_civita([],[i,j,k])*a([j])*b([k])$
ishow(expr2)$
applyb1(expr2,lc_l,lc_u)$
ishow(factor(canform(contract(expand(%)))))$

("finally look for the dualization of some tensor B")$
("declare symmetry prop of B")$
(allsym:false, decsym(b,2,0,[anti(all)],[]),ishow(b([i,j],[])))$
("compute the dualization")$
(rank:length(covi(b([i,j],[]))),dual:'levi_civita([],[l,i,j])*b([i,j],[])/rank!,ishow(dual))$
("return to the original")$
(ddual:'levi_civita([i2,j2,l],[])*dual,ishow(ddual))$
ishow(canform(contract(expand(lc2kdt(ddual)))))$

("differentiation of tensors")$
kill(g)$
remcomps(g)$
imetric:g$
dim:4$
ishow(ichr1([i,j,k]))$
ishow(ichr2([i,j],[k]))$
ishow(covdiff(a([j,k],[i]),i))$
expr:canform(contract(expand(ev(%,ichr2))))$
ishow(expr)$
ishow(igeodesic_coords(expr,g))$
("the geodesic was used to cancel the first derivatives of the metric")$
allsym:true$
exp:'icurvature([r,s,t],[u])+'icurvature([s,t,r],[u])+'icurvature([t,r,s],[u])$
ishow(exp)$
ishow(ev(exp,icurvature))$
ishow(igeodesic_coords(%,ichr2))$
ishow(rename(%))$

("exterior derivatives")$
(allsym:false,decsym(p,2,0,[anti(all)],[]),ishow(extdiff(p([i,j]),k)))$
("the Lie derivative of a 1-form")$
ishow(liediff(v,a([i])))$
("the Lie derivative has to commute with the exterior one.")$
ishow(canform(extdiff(liediff(v,a([i])),j)-liediff(v,extdiff(a([i]),j))))$
ishow(canform(extdiff(liediff(v,p([i1,i2])),i3)-liediff(v,extdiff(p([i1,i2]),i3))))$

("more examples about the Cartan identity are in car_iden.dem")$

("to simplify use rename, canform and canten")$
kill(g)$
remcomps(g)$
declare(e,constant)$
imetric:g$
components(g([i,j],[]),e([i,j],[])+2*l*p([i,j],[]));
components(g([],[i,j]),e([],[i,j])-2*l*p([],[i,j]));
	/*G(L1,L2):=BLOCK( IF L2=[] THEN RETURN(E(L1,[])+2*L*P(L1,[]) ),
	  E([],L2)-2*L*P([],L2) )$*/
ishow(g([i,j],[]))$
ishow(g([],[i,j]))$
(ratvars(l),ratweight(l,1),ratwtlvl:1)$
exp1:icurvature([s,u,n],[y])$
nterms(exp1);
exp2:ev(exp1)$
	/*(exp2:undiff(exp1),exp3:ev(exp2,ichr2),exp4:ev(exp3,diff))$*/
("look the number of terms with nterms")$
nterms(exp2);
ishow(canform(contract(rename(ratexpand(exp2)))))$
("the FLUSH() function is used to simplify an expr with derivatives")$
exp:u([i],[j,r],k,r)+a([i],[j,r,s],k,r,s)+b([i,k],[j,r],r)+u([i,k,r],[j,r])$
ishow(exp)$
ishow(flush(exp,u))$
ishow(flushd(exp,u,b))$
ishow(flushnd(exp,a,1))$
(if allsym=false then allsym:true)$
(" the divergence free terms could be removed with lorentz")$
defcon(e,e,kdelta)$
defcon(e,p,p)$
defcon(p,e,p)$
rr : g([],[r,t])*icurvature([r,s,t],[s])$
rrij : g([],[i,r])*g([],[j,t])*icurvature([r,s,t],[s])$
ein:-(rrij-1/2*rr*g([],[i,j]))$
	/*undiff(ein)$
	ev(%,ichr2)$
	ev(%,diff)$*/
ein:canform(rename(contract(ratexpand(ev(%)))))$
ishow(ein)$
ein_l:lorentz_gauge(ein,p)$
ishow(ein_l)$

("Now consider the permutations prop of the Riemann curvature tensor")$

("firstly, compute the symmetrization")$
exp:contract(expand('icurvature([k,i1,j1],[l])*kdels([i,j],[i1,j1])/2))$
ishow(exp)$
(exp1:ev(exp,icurvature),ishow(exp1))$
("simplify via canform")$
ishow(canform(exp1))$
("compute the antisymmetrization")$
exp:contract(expand('icurvature([i1,j1,k1],[l])*kdelta([i,j,k],[i1,j1,k1])))$
ishow(exp)$
(exp1:ev(exp,icurvature),ishow(expand(exp1)))$
ishow(canform(exp1))$
("the Bianchi rules")$
bianchi_r:'covdiff('icurvature([k,i1,j1],[l]),m1)*
'kdelta([i,j,m],[i1,j1,m1])=0$
ishow(bianchi_r)$
exp:contract(expand(ev(lhs(bianchi_r),kdelta,icurvature,covdiff)))$
nterms(exp);
ishow(canform(exp))$

("transition to the coordinates")$
idummyx:di$
remcomps(g);
imetric:g$
dim:3$
(" The RHS of the heat transport equation with Te as the temperature
  and k as the heat conductivity")$
eq1 : td = canform(rename(expand(covdiff( -k([],[])*covdiff(Te([],[]),i),j)*g([],[i,j]))))+ source$
heat : ic_convert(eq1 )$
(ct_coords:[x,y,z],lg:matrix([1,0,0],[0,1,0],[0,0,1]),ug : invert(lg))$
	/*(dim:DIM,ct_coords:CT_COORDS,lg:LG,ug:UG,christof(false),MCS:mcs)$*/
christof(false);
(depends(Te,ct_coords),depends(k,x))$
ev(heat);
(" get the equation in spherical coordinates ")$
ct_coords:[r,theta,phi];
lg:matrix([1,0,0],[0,r^2,0],[0,0,r^2*sin(theta)^2])$
ug : invert(lg)$
	/*(ct_coords:CT_COORDS,lg:LG,ug:UG,christof(false),MCS:mcs)$*/
christof(all);
remove([Te,k],dependency)$
(depends(Te,ct_coords),depends(k,r))$
ev(heat);
kill(ct_coords)$
("the conservation of the helicity in hydrodynamics")$
(if allsym=true then allsym:false)$
idummyx:j$
("the covariant formulation of the Euler equation is")$
euler: d_t*v([i1])+
'liediff(v,v([i0]))=-extdiff(p([]),i1)/rho([])+extdiff((v([i0])|v/2-phi([])),i1)$
ishow(euler)$
("take the exterior derivative of both sides")$
euler1:d_t*ct_coords([i1,i2])+'liediff(v,ct_coords([i0,i1]))=
extdiff(-extdiff(p([]),i1)/rho([])+extdiff(v([i0])|v/2-phi([]),i1),i2)$
ishow(euler1)$
ishow(ct_coords([i1,i2])=extdiff(v([i1]),i2))$
("declare the function's dependencies")$
depends(p,[rho,s])$
("define the chain rule for the derivatives' replacement")$
matchdeclare(i,symbolp);
defrule(p_r, p([],[],i),  'diff(p,rho)*rho([],[],i));
defrule(p_sr, p([],[],i),  'diff(p,s)*s([],[],i)+'diff(p,rho)*rho([],[],i));
("apply the rules")$
ishow(apply1(euler1,p_r))$
("this law was originally discovered by Lord Kelvin")$
("for the more general case there is Ertel's theorem")$
("apply another rule where pressure depends on both rho and the entropy")$
euler2:factor(expand(apply1(euler1,p_sr)))$
ishow(euler2)$
("so the rhs will vanish after forming the exterior product with
  the differential of the entropy")$
rhs(euler1)~extdiff(s([]),i3)$
ishow(factor(expand(apply1(%,p_sr))))$

("the magnetic field lines are embedded in the moving plasma")$
allsym:false$
("introduce the 2-form describing the magnetic field")$
decsym(b,2,0,[anti(all)],[])$
("due to the infinite conductivity the electric field is expressed through")$
e_field:b([i1,i2])|v$
equat: d_t*b([i2,i3])=-extdiff(e_field,i3)$
ishow(equat)$

("express B through the vector potential")$
("i.e., re-compute the electric field")$
e_field1:extdiff(a([i1]),i2)|v$
("substitute it in Equat")$
equat1: d_t*b([i2,i1])=-extdiff(e_field1,i1)$
("compute the Lie derivative of B")$
lie_derb: 'liediff(v,b([i1,i2]))=liediff(v,extdiff(a([i1]),i2))$
("summing up the lhs and rhs parts")$
emded:lhs(equat1)+lhs(lie_derb)=canform(rhs(equat1)+rhs(lie_derb))$
ishow(emded)$
