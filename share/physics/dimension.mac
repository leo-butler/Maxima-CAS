/*
Copyright (C) 2002 Barton Willis

Brief Description:
   Maxima code for dimensional analysis.

Author:
   Barton Willis
   Department of Mathematics
   University of Nebraska at Kearney
   Kearney NE 68849

License:
   GPL
*/

put('dimension,1,'version)$

/* 
If e is a list, return true if either e is empty or if e[i] = e[j]
for all 1 <= i,j <= length(e). If e isn't a list, return false.
*/

all_equalp (e) := listp(e) and cardinality(setify(e))< 2;


/*
fundamental_dimensions is a Maxima list that is used by the functions
dimensionless, natural_unit, and dimension_as_list; the function
dimension doesn't use this list.  A user may insert or remove elements
form the list; for example, to use quantities that involve
temperature, you could append temp onto fundamental_dimensions.

You'll get into trouble if you call any one of the functions
dimensionless, natural_unit, or  dimension_as_list with expressions
that have dimensions not in the list fundamental_dimensions.
Be careful.

The default value of fundamental_dimensions is [mass, length, time].
You can change this list to anything you like. 
*/

assume(mass > 0);
assume(length > 0);
assume(time > 0);

fundamental_dimensions : [mass, length, time];


/* Notes

0.  When e is a list, map dimension over the list.

1.  Use logcontract so that log(a) - log(b) is okay when a and b have the
    same dimensions.

2.  Maybe this should return "Unknown dimensions."

2.5  dimension(a[x]) = dimension(a) regardless of what x is.

3.  In a sum, check that all terms have the same dimensions; if not,
    signal the error "The expression is dimensionally inconsistent."

4.  abs, sqrt, max, and min  are the only prefix functions that may
    take an argument that isn't dimensionless.

5.  Check that all function arguments are dimensionless; if not,
    signal the error "The expression is dimensionally inconsistent."

Return the dimensions of the expression e; if e is dimensionally
inconsistent, signal an error "The expression is dimensionally inconsistent."

The infix binary operators +, *, /, ^, ^^, ., = and ~ are supported.
(Maxima's vector package defines ~ to be the cross product
operator.)  For the = operator, the expression is dimensionally
inconsistent if the dimension of the right and left sides differ.

It supports the prefix unary negation and the abs function. The nary
min and max functions are supported; for the min and max functions,
all arguments must have the same dimension, otherwise, the
expression is dimensionally inconsistent.
*/


dimension (e) := block([op, dim, var, i, n],

  if listp(e) then (                  /* 0 */
     map ('dimension, e))

  else (
  
  if not atom(e) then (
     op : part(e,0)),

  e : logcontract (e),                 /* 1 */

  if constantp (e) then (
     1)

  else if symbolp (e) then (          
     if member(e, fundamental_dimensions) then (
        e)
     else (
        dim : get (e, 'dimension),
        if dim = false then (
            funmake ('dimension, [e]))  /* 2 */
        else (
           dim)))

  else if subvarp (e) then (          /* 2.5 */
     dimension(part(e,0)))

   else if op = "*" or op = "." or op = "~" then (
     apply ("*", map ('dimension, args (e))))

  else if op = "/" then (
     dimension(num(e)) / dimension(denom(e)))
      /* apply (op, map ('dimension, args (e)))) */

  else if (op = "^" or op = "^^") and dimension (part (e,2)) = 1 then (
      dimension(part(e,1)) ^ part(e,2))

  else if op = "-" then (
      dimension(part(e,1)))

  else if op = "+" or op = 'max or op =  'min then ( /*3*/ 
     dim : map ('dimension, args (e)),
     if all_equalp (dim) then (
         first (dim))
     else (
         error ("The expression is dimensionally inconsistent.")))

  else if op = 'matrix then (
     dim : map ('dimension, args (e)),
     dim : apply ('append, dim),
     if all_equalp (dim) then (
        first(dim))
     else (
         error ("The expression is dimensionally inconsistent.")))

  else if (op = "="  or op = "#" or op = "<" or op = ">" or
       op = "<=" or op = ">=" ) then (
     if part(e,1) = 0 then (
        dimension (part(e,2)))
     else if part (e,2) = 0 then (
        dimension (part(e,1)))
     else (
        dim : dimension(part(e,1)),
        if dim = dimension(part(e,2)) then (
            dim )
         else (
            error ("The expression is dimensionally inconsistent."))))

  else if op = 'abs then (     /*  4 */
     dimension (part (e, 1)))

  else if op = 'sqrt then (
     dimension (part(e,1)) ^ (1/2))

  else if op = nounify('diff) then (
    var : args(e),
    n : length(var) - 1,
    dim : dimension (part(var,1)),
    for i : 2 thru n step 2 do (
       dim : dim / dimension (part(var,i)) ^ part(var,i+1)),
    dim)

  else if op = nounify('integrate) then (
    var : args(e),
    dim : dimension(part(var,1)) * dimension(part(var,2)),

    if length (e) = 4 and not all_equalp([dimension(part(var,2)),
        dimension(part(var,3)),dimension(part(var,4))]) then (
       error ("The expression is dimensionally inconsistent."))

    else (
       dim))

   else if op = nounify('sum) or op = nounify('product) then (
      error("The function dimension doesn't handle sums or products."))    

   else if op = "DIV" or  op = "div" or op = "GRAD" or op = "grad"  or
     op = "CURL" or op = "curl" then (
     if listp(part(e,1)) then (
        dim : map ('dimension, part(e,1)),
        if all_equalp(dim) then (
           dim : first(dim))
        else (
           error ("The expression is dimensionally inconsistent.")))
     else (
         dim : dimension (part(e,1))),
     dim / length)

   else if op = "laplacian" then (
     dimension(part(e,1) / length^2))

   else (                                /*  5 */
     dim : map ('dimension, args(e)),
     if all_equalp (cons (1,dim)) then (
        dim : dimension(part(e,0)),
        if not atom(dim) and ?equal(part(dim,0),'dimension) then (
           1)
        else (
           dim ))
     else (
         error ("The expression is dimensionally inconsistent.")))));

/*
For the expression e, return a list of the exponents of the
fundamental_dimensions. Thus if  fundamental_dimensions =
[mass, length, time] and c is a velocity, dimension_as_list(c)
returns [0,1,-1].
*/

dimension_as_list (e) := block([s : [ ], i, n],
  if listp(e) then (
    map ('dimension_as_list, e))
  else (
    e : dimension (e),
    n : length(fundamental_dimensions),
    for i : 1 thru n do (
      s : endcons(hipow(e, part(fundamental_dimensions,i)), s)),
    s));

/*
Return a basis for the dimensionless quantities that can be formed
from a product of powers of elements of the list e.  The basis excludes
the constants.
*/

dimensionless (e) := block([s, vars, linsolve_params : true,
    back_subst : true,globalsolve : false, solve_inconsistent_error : false,
    p, n, basis, sub, i, k, si],

  if not listp(e) then (
     error ("Argument to 'dimensionless' must be a list.")),

  s : map ('dimension_as_list, e),
  vars : makelist (p[k], k, 1,length (s)),
  s : linsolve (s . vars, vars),
  n : length(%rnum_list),
  basis : [1],

  if (n > 0 and s # [ ]) then (
     s : map ('rhs, s),
     s : apply ("*", map("^",e,s)),
     sub : map("=", %rnum_list, makelist(0,i,1,n)),
     for i : 1 thru n do (
        si : subst(1,%rnum_list[i], s),
        si : sublis(sub,si),
        basis : cons(si, basis))),

  basis);


 natural_unit(dim,e) := block([s,vars,k,i,n,p,basis,si,sub,linsolve_params : true,
     back_subst : true, globalsolve : false,
     solve_inconsistent_error : false],
 
   if not listp(e) then (
      error ("The second argument to 'natural_unit' must be a list.")),

   dim : dimension_as_list(dim),
   s : map ('dimension_as_list,e),
   vars : makelist(p[k],k,1,length(s)),
   s : linsolve(s . vars - dim, vars),
   n : length(%rnum_list),
   basis : [ ],

   if (s # [ ] and n = 0) then (
      s : map('rhs,s),
      basis : [apply("*", map ("^", e, s))])

   else if (s # [ ] and n > 0) then (
     s : map('rhs, s),
     sub : map("=", %rnum_list, makelist(0,i,1,n)),
     for i : 1 thru n do  (
        si : subst(1,%rnum_list[i],s),
        si : sublis(sub, si),
        si : apply("*",map ("^",e,si)),
        basis : cons(si, basis))),
     basis);

