/*               COPYRIGHT NOTICE

Copyright (C) 2005-2006 Mario Rodriguez Riotorto

This program is free software; you can redistribute
it and/or modify it under the terms of the
GNU General Public License as published by
the Free Software Foundation; either version 2 
of the License, or (at your option) any later version. 

This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details at
http://www.gnu.org/copyleft/gpl.html
*/


/*             INTRODUCTION

This package defines de Lagrangian, the linear and the cubic 
splines methods for polynomial interpolation.

For questions, suggestions, bugs and the like, feel free
to contact me at

mario @@@ edu DOT xunta DOT es
www.biomates.net

2005, october: first release
2006, february: added linear interpolation and cubic splines, together 
      with some other changes.
*/



/* Returns de input in the form of a list of pairs, ordered wrt the first */
/* coordinate. The argument must be either:                               */
/*  a) a two column matrix, p:matrix([2,4],[5,6],[9,3])                   */
/*  b) a list of pairs, p: [[2,4],[5,6],[9,3]]                            */
/*  c) a list of numbers, p: [4,6,3], in which case the abscissas will be */
/*     assigned automatically to 1, 2, 3, etc.                            */
/* This is an uxiliary function for the 'interpol' package. If the        */
/* returned value is a negative number, it's due to an error:             */
/*  -1: the argument is not a list nor a matrix                           */
/*  -2: sample pairs is too short                                         */
/*  -3: unknown error                                                     */
interpol_check_input(data):= block([n],
   if not listp(data) and not matrixp(data)
      then return(-1),
   n: length(data),
   if n<2
      then return(-2),
   if listp(data) and every('identity,map(lambda([x], listp(x) and length(x)=2),data))
      then return(sort(data)),
   if matrixp(data) and length(data[1]) = 2
      then return(sort(args(data))),
   if listp(data) and every('identity,map(lambda([x], not listp(x)),data)) 
      then return(makelist([i,data[i]],i,1,n))
   -3 )$



/* Computes the polynomial interpolation by the Lagrangian method. The         */
/* argument must be either:                                                    */
/*  a) a two column matrix, p:matrix([2,4],[5,6],[9,3])                        */
/*  b) a list of pairs, p: [[2,4],[5,6],[9,3]]                                 */
/*  c) a list of numbers, p: [4,6,3], in which case the abscissas will be      */
/*     assigned automatically to 1, 2, 3, etc.                                 */
/* In cases a) and b) the pairs are ordered wrt the 1st. coordinate before any */
/* computation is made. Option:                                                */
/*   'varname='x: the name of the independent variable                         */
/* Sample session:                                                             */
/* p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$                                          */
/* lagrange(p);                                                                */
/* f(x):=''%;                                                                  */
/* map(f,[2.3,5/7,%pi]);                                                       */
/* %,numer;                                                                    */
/* plot2d([f(x),[discrete,p]],[x,0,10],                                        */
/*        [gnuplot_curve_styles,["with lines","with points pointsize 3"]])$    */
lagrange(tab,[select]) := block([n,sum:0,prod,options, defaults],
   tab: interpol_check_input(tab),
   if numberp(tab) then
      if tab=-1
         then error("Argument to 'lagrange' must be a list or matrix")
         else if tab=-2
                 then error("Argument to 'lagrange' has too few sample points")
                 else error("Unknown error in 'lagrange' function"),
   options:  ['varname],
   defaults: ['x],
   for i in select do(
      aux: ?position(lhs(i),options),
      if numberp(aux) and aux <= length(options) and aux >= 1
        then defaults[aux]: rhs(i)),
   if not symbolp(defaults[1])
      then error("Option 'varname' is not correct"),

   n: length(tab),
   /* controlling duplicated x's */
   for i:2 thru n do
      if tab[i-1][1] = tab[i][1]
         then error("Duplicated abscissas are not allowed"),

   /* constructing the interpolating polynomial */
   for i:1 thru n do(
      prod: 1,
      for k:1 thru n do
         if k#i then prod: prod * (defaults[1]-tab[k][1]) / (tab[i][1]-tab[k][1]),
      sum: sum + prod * tab[i][2] ),
   expand(sum) )$



/* Characteristic function for intervals. Returns true iif  */
/* z belongs to [l1, l2). This is an auxiliary function to  */
/* be called from linearinterpol and cspline                */
charfun2(z,l1,l2):= charfun(l1 <= z and z < l2)$



/* Computes the linear interpolation function. The argument must be either:    */
/*  a) a two column matrix, p:matrix([2,4],[5,6],[9,3])                        */
/*  b) a list of pairs, p: [[2,4],[5,6],[9,3]]                                 */
/*  c) a list of numbers, p: [4,6,3], in which case the abscissas will be      */
/*     assigned automatically to 1, 2, 3, etc.                                 */
/* In cases a) and b) the pairs are ordered wrt the 1st. coordinate before any */
/* computation is made. Option:                                                */
/*   'varname='x: the name of the independent variable                         */
/* Sample session:                                                             */
/* p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$                                          */
/* linearinterpol(p);                                                          */
/* f(x):=''%;                                                                  */
/* map(f,[7.3,25/7,%pi]);                                                      */
/* %,numer;                                                                    */
/* plot2d(['(f(x)),[discrete,p]],[x,0,10],                                     */
/*        [gnuplot_curve_styles,["with lines","with points pointsize 3"]])$    */
linearinterpol(tab,[select]) := block([n,s:0,a,b,options, defaults],
   tab: interpol_check_input(tab),
   if numberp(tab) then
      if tab=-1
         then error("Argument to 'linearinterpol' must be a list or matrix")
         else if tab=-2
                 then error("Argument to 'linearinterpol' has too few sample points")
                 else error("Unknown error in 'linearinterpol' function"),
   options:  ['varname],
   defaults: ['x],
   for i in select do(
      aux: ?position(lhs(i),options),
      if numberp(aux) and aux <= length(options) and aux >= 1
        then defaults[aux]: rhs(i)),
   if not symbolp(defaults[1])
      then error("Option 'varname' is not correct"),

   n: length(tab),
   /* controlling duplicated x's */
   for i:2 thru n do
      if tab[i-1][1] = tab[i][1]
         then error("Duplicated abscissas are not allowed"),

   /* constructing the interpolating polynomial */
   if n=2 /* case of two points */
      then s: tab[2][2] + (tab[2][2]-tab[1][2]) *
                          (defaults[1]-tab[2][1]) /
                          (tab[2][1]-tab[1][1])
      else for i:2 thru n do(
               if i=2
                  then (a: 'minf, b: tab[i][1])
                  else if i=n
                          then (a: tab[i-1][1], b: 'inf)
                          else (a: tab[i-1][1], b: tab[i][1]),
               s: s + funmake('charfun2,[defaults[1], a, b]) *
                      expand( tab[i][2] + (tab[i][2]-tab[i-1][2]) *
                                    (defaults[1]-tab[i][1]) /
                                    (tab[i][1]-tab[i-1][1]) )   ),
   s )$



/* Computes the cubic spline interpolation function. The argument must be either:      */
/*  a) a two column matrix, p:matrix([2,4],[5,6],[9,3])                                */
/*  b) a list of pairs, p: [[2,4],[5,6],[9,3]]                                         */
/*  c) a list of numbers, p: [4,6,3], in which case the abscissas will be              */
/*     assigned automatically to 1, 2, 3, etc.                                         */
/* In cases a) and b) the pairs are ordered wrt the 1st. coordinate before any         */
/* computation is made. Options:                                                       */
/*   'd1='unknown: 1st derivative at x_1; if it is 'unknown, the second derivative     */
/*         at x_1 is made equal to 0 (natural cubic spline); if it is equal to a       */
/*         number, the second derivative is estimated based on this number             */
/*   'd2='unknown: 1st derivative at x_n; if it is 'unknown, the second derivative     */
/*         at x_n is made equal to 0 (natural cubic spline); if it is equal to a       */
/*         number, the second derivative is estimated based on this number             */
/*   'varname='x: the name of the independent variable                                 */
/* Reference: this algorithm is based on 'Numerical Recipes in C', section 3.3         */
/* Sample session:                                                                     */
/* p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$                                                  */
/* cspline(p); ==> natural cubic spline (second derivatives are zero in both extremes) */
/* f(x):=''%;                                                                          */
/* map(f,[2.3,5/7,%pi]);                                                               */
/* %,numer;                                                                            */
/* plot2d(['(f(x)),[discrete,p]],[x,0,10],                                             */
/*        [gnuplot_curve_styles,["with lines","with points pointsize 3"]])$            */
/* cspline(p,d1=0,dn=0);                                                               */
/* g(x):=''%;                                                                          */
/* plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],                                     */
/*      [gnuplot_curve_styles,["with lines","with lines","with points pointsize 3"]])$ */
cspline(tab,[select]):= block([options, defaults, n, aux, y2, u, sig, p,
                               qn, un, a, b, s:0, aj, bj, cj, dj, aux],
   tab: interpol_check_input(tab),
   if numberp(tab) then
      if tab=-1
         then error("Argument to 'cspline' must be a list or matrix")
         else if tab=-2
                 then error("Argument to 'cspline' has too few sample points")
                 else error("Unknown error in 'cspline' function"),
   options:  ['d1, 'dn, 'varname],
   defaults: ['unknown, 'unknown, 'x],
   for i in select do(
      aux: ?position(lhs(i),options),
      if numberp(aux) and aux <= length(options) and aux >= 1
        then defaults[aux]: rhs(i)),
   if not numberp(defaults[1]) and  defaults[1] # 'unknown
      then error("Option 'd1' is not correct"),
   if not numberp(defaults[2]) and  defaults[1] # 'unknown
      then error("Option 'dn' is not correct"),
   if not symbolp(defaults[3])
      then error("Option 'varname' is not correct"),

   n: length(tab),
   /* controlling duplicated x's */
   for i:2 thru n do
      if tab[i-1][1] = tab[i][1]
         then error("Duplicated abscissas are not allowed"),

   /* if tab contains only two points, linear interpolation */
   if n=2 /* case of two points */
      then return(ratsimp( tab[2][2] + (tab[2][2]-tab[1][2]) *
                                       (defaults[3]-tab[2][1]) /
                                       (tab[2][1]-tab[1][1]))),


   /* constructing the interpolating polynomial */
   y2: makelist(0,i,1,n),
   u: makelist(0,i,1,n-1),

   /* controlling the lower boundary condition */
   if /*d1*/ defaults[1] = 'unknown
      then (y2[1]: 0,
            u[1]: 0)
      else (y2[1]: -1/2,
            u[1]: 3 / (tab[2][1]-tab[1][1]) *
                      ((tab[2][2] - tab[1][2])/(tab[2][1] - tab[1][1]) - defaults[1]) ),

   /* decomposition loop of the triangular algorithm */
   for i:2 thru n-1 do (
      sig: (tab[i][1] - tab[i-1][1]) / (tab[i+1][1] - tab[i-1][1]),
      p: sig * y2[i-1] + 2,
      y2[i]: (sig - 1) / p,
      u[i]: (tab[i+1][2] - tab[i][2]) /(tab[i+1][1] - tab[i][1]) -
            (tab[i][2] - tab[i-1][2]) /(tab[i][1] - tab[i-1][1]),
      u[i]: (6 * u[i] / (tab[i+1][1] - tab[i-1][1]) - sig * u[i-1]) / p ) ,

   /* controlling the upper boundary condition */
   if /*dn*/ defaults[2] = 'unknown
      then (qn: 0,
            un: 0)
      else (qn: 1/2,
            un: 3 / (tab[n][1] - tab[n-1][1]) *
                (defaults[2] - (tab[n][2] - tab[n-1][2]) / (tab[n][1] - tab[n-1][1]))),
   y2[n]: (un - qn * u[n-1]) / (qn * y2[n-1] + 1),

   /* backsubstitution loop of the tridiagonal algorithm */
   for k: n-1 thru 1 step -1 do
      y2[k]: y2[k] * y2[k+1] + u[k],

   /* constructing the cubic splines */
   for j:2 thru n do (
      if j=2
          then (a: 'minf, b: tab[j][1] )
          else if j=n
                  then (a: tab[j-1][1], b: 'inf)
                  else (a: tab[j-1][1], b: tab[j][1]),
      /* in the following sentences, defaults[3] is variable's name */
      aux: (tab[j][1] - tab[j-1][1]),
      aj: (tab[j][1] - defaults[3]) / aux,
      bj: (defaults[3] - tab[j-1][1]) / aux,
      aux: aux * aux /6,
      cj: (aj^3 - aj) * aux,
      dj: (bj^3 - bj) * aux,

      s: s + funmake('charfun2,[defaults[3], a, b]) *
             expand(aj * tab[j-1][2] + bj * tab[j][2] + cj * y2[j-1] + dj * y2[j])  ),
   s )$


