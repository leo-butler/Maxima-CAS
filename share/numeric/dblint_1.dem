/* a macro for floatdefunk, needed until optimu is used */
load("fltdfnk.mc")$

/* Example of use of double integrator (DBLINT), part 2, plus
FLOATDEFUNK and QUANC8 */

/* Get the fasl file for DBLINT */ 
load('dblint); 
/* Get the fasl file for QUANC8 */
load('qq);

/* Use DBLINT to get the double integral of exp(x-y^2) over the region
bounded by y=1 and y=2+x^(3/2) and x=0 to x=1 */

/* Define the integrand as a function of two variables */

f(x,y):=(mode_declare([x,y],float),exp(x-y^2)); 

/* Define the lower and upper limits on the inner (y in this case)
integral as a function of the outer variable (x in this case) */

r(x):=(mode_declare(x,float),1.0); 
s1(x):=(mode_declare(x,float),2.0+x^(3/2));

/* Now translate these functions for the sake of efficiency */

translate(f,r,s1); 

/* Call the DBLINT function with quoted arguments for function names, and
floating point values for the endpoints of the outer (x) integration
*/ 

dblint_answer:dblint('f,'r,'s1,0.0,1.0); 

/* Now generate the exact integral over y using RISCH */

inty:risch(exp(x-y^2),y); 

/* Now get the integrand of the x integral */

xint:ev(inty,y:2+x^(3/2))-ev(inty,y:1);

/* Try to do the x integral exactly */

risch(xint,x);
radcan(%);
%,nouns;
/* Still no luck with closed-form */
/* The integral over x can't be done in closed-form, so let's use a
one-dimensional integrator to do it numerically. First, we must
define the integrand as a floating point function. FLOATDEFUNK
does this very conveniently on the expression */

floatdefunk(fun,[x],xint);

/* Now translate the function fun */
translate(fun);

/* Now call QUANC8 on the translated function (see SHARE1;QQ USAGE for
details) */

quanc8_answer:quanc8(fun,0.0,1.0);

/* Compare the answers from DBLINT and QUANC8 */

(dblint_answer-quanc8_answer)/dblint_answer;

/* It appears to be small enough relative error for most uses */
"end of dblint.dm1"$
